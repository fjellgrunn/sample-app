"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fjell";
exports.ids = ["vendor-chunks/@fjell"];
exports.modules = {

/***/ "(ssr)/../fjell-cache/node_modules/@fjell/core/dist/index.js":
/*!*************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/core/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItemService: () => (/* binding */ AItemService),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   IFactory: () => (/* binding */ IFactory),\n/* harmony export */   IQFactory: () => (/* binding */ IQFactory),\n/* harmony export */   abbrevAgg: () => (/* binding */ abbrevAgg),\n/* harmony export */   abbrevCompoundCondition: () => (/* binding */ abbrevCompoundCondition),\n/* harmony export */   abbrevCondition: () => (/* binding */ abbrevCondition),\n/* harmony export */   abbrevIK: () => (/* binding */ abbrevIK),\n/* harmony export */   abbrevLKA: () => (/* binding */ abbrevLKA),\n/* harmony export */   abbrevQuery: () => (/* binding */ abbrevQuery),\n/* harmony export */   abbrevRef: () => (/* binding */ abbrevRef),\n/* harmony export */   cPK: () => (/* binding */ cPK),\n/* harmony export */   constructPriKey: () => (/* binding */ constructPriKey),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   generateKeyArray: () => (/* binding */ generateKeyArray),\n/* harmony export */   ikToLKA: () => (/* binding */ ikToLKA),\n/* harmony export */   isComItem: () => (/* binding */ isComItem),\n/* harmony export */   isComKey: () => (/* binding */ isComKey),\n/* harmony export */   isComKeyEqual: () => (/* binding */ isComKeyEqual),\n/* harmony export */   isComKeyEqualNormalized: () => (/* binding */ isComKeyEqualNormalized),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isItemKey: () => (/* binding */ isItemKey),\n/* harmony export */   isItemKeyEqual: () => (/* binding */ isItemKeyEqual),\n/* harmony export */   isItemKeyEqualNormalized: () => (/* binding */ isItemKeyEqualNormalized),\n/* harmony export */   isLocKey: () => (/* binding */ isLocKey),\n/* harmony export */   isLocKeyEqual: () => (/* binding */ isLocKeyEqual),\n/* harmony export */   isLocKeyEqualNormalized: () => (/* binding */ isLocKeyEqualNormalized),\n/* harmony export */   isPriItem: () => (/* binding */ isPriItem),\n/* harmony export */   isPriKey: () => (/* binding */ isPriKey),\n/* harmony export */   isPriKeyEqual: () => (/* binding */ isPriKeyEqual),\n/* harmony export */   isPriKeyEqualNormalized: () => (/* binding */ isPriKeyEqualNormalized),\n/* harmony export */   isQueryMatch: () => (/* binding */ isQueryMatch),\n/* harmony export */   isValidComKey: () => (/* binding */ isValidComKey),\n/* harmony export */   isValidItemKey: () => (/* binding */ isValidItemKey),\n/* harmony export */   isValidLocKey: () => (/* binding */ isValidLocKey),\n/* harmony export */   isValidLocKeyArray: () => (/* binding */ isValidLocKeyArray),\n/* harmony export */   isValidPriKey: () => (/* binding */ isValidPriKey),\n/* harmony export */   itemKeyToLocKeyArray: () => (/* binding */ itemKeyToLocKeyArray),\n/* harmony export */   lkaToIK: () => (/* binding */ lkaToIK),\n/* harmony export */   locKeyArrayToItemKey: () => (/* binding */ locKeyArrayToItemKey),\n/* harmony export */   paramsToQuery: () => (/* binding */ paramsToQuery),\n/* harmony export */   primaryType: () => (/* binding */ primaryType),\n/* harmony export */   queryToParams: () => (/* binding */ queryToParams),\n/* harmony export */   toKeyTypeArray: () => (/* binding */ toKeyTypeArray),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys),\n/* harmony export */   validatePK: () => (/* binding */ validatePK)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../fjell-cache/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! luxon */ \"(ssr)/../fjell-cache/node_modules/luxon/src/luxon.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/core\");\nvar logger_default = LibLogger;\n\n// src/dictionary.ts\nvar logger = logger_default.get(\"Dictionary\");\nvar Dictionary = class _Dictionary {\n  map = {};\n  hashFunction = (key) => JSON.stringify(key);\n  constructor(map, hashFunction) {\n    if (hashFunction) {\n      this.hashFunction = hashFunction;\n    }\n    if (map) {\n      Object.entries(map).forEach(([hashedKey, value]) => {\n        try {\n          const originalKey = JSON.parse(hashedKey);\n          this.map[hashedKey] = { originalKey, value };\n        } catch {\n          logger.warning(\"Cannot recover original key from legacy map entry\", { hashedKey });\n        }\n      });\n    }\n  }\n  set(key, item) {\n    logger.trace(\"set\", { key, item });\n    const hashedKey = this.hashFunction(key);\n    this.map[hashedKey] = { originalKey: key, value: item };\n  }\n  get(key) {\n    logger.trace(\"get\", { key });\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry && this.keysEqual(entry.originalKey, key) ? entry.value : null;\n  }\n  keysEqual(key1, key2) {\n    return key1 === key2;\n  }\n  delete(key) {\n    logger.trace(\"delete\", { key });\n    const hashedKey = this.hashFunction(key);\n    delete this.map[hashedKey];\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  includesKey(key) {\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry ? this.keysEqual(entry.originalKey, key) : false;\n  }\n  clone() {\n    const clonedMap = {};\n    Object.entries(this.map).forEach(([hashedKey, entry]) => {\n      clonedMap[hashedKey] = entry.value;\n    });\n    const clone = new _Dictionary(clonedMap, this.hashFunction);\n    clone.map = Object.assign({}, this.map);\n    return clone;\n  }\n};\n\n// src/item/IFactory.ts\n\n\n// src/key/KUtils.ts\nvar logger2 = logger_default.get(\"KUtils\");\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && (normalizedKey.pk !== void 0 && normalizedKey.pk !== null)) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && (normalizedKey.lk !== void 0 && normalizedKey.lk !== null)) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && (locItem.lk !== void 0 && locItem.lk !== null)) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return JSON.stringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isPriKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isPriKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.pk) === normalizeKeyValue(b.pk) && a.kt === b.kt;\n};\nvar isLocKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isLocKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.lk) === normalizeKeyValue(b.lk) && a.kt === b.kt;\n};\nvar isComKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isComKeyEqualNormalized\", { a, b });\n  if (a && b && isPriKeyEqualNormalized({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqualNormalized(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isItemKeyEqualNormalized\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqualNormalized(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqualNormalized(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqual = (a, b) => {\n  logger2.trace(\"isKeyEqual\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqual(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqual(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isPriKeyEqual = (a, b) => {\n  logger2.trace(\"isPriKeyEqual\", { a, b });\n  return a && b && a.pk === b.pk && a.kt === b.kt;\n};\nvar isLocKeyEqual = (a, b) => {\n  logger2.trace(\"isLocKeyEqual\", { a, b });\n  return a && b && a.lk === b.lk && a.kt === b.kt;\n};\nvar isComKeyEqual = (a, b) => {\n  logger2.trace(\"isComKeyEqual\", { a, b });\n  if (a && b && isPriKeyEqual({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqual(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKey = (key) => {\n  logger2.trace(\"isItemKey\", { key });\n  return key !== void 0 && (isComKey(key) || isPriKey(key));\n};\nvar isComKey = (key) => {\n  logger2.trace(\"isComKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc !== void 0 && key.loc.length > 0);\n};\nvar isPriKey = (key) => {\n  logger2.trace(\"isPriKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc === void 0 || key.loc.length === 0);\n};\nvar isLocKey = (key) => {\n  logger2.trace(\"isLocKey\", { key });\n  return key !== void 0 && (key.lk !== void 0 && key.kt !== void 0);\n};\nvar generateKeyArray = (key) => {\n  logger2.trace(\"generateKeyArray\", { key });\n  const keys = [];\n  if (isComKey(key) || isPriKey(key)) {\n    if (isComKey(key)) {\n      const comKey = key;\n      keys.push({ pk: comKey.pk, kt: comKey.kt });\n      for (let i = 0; i < comKey.loc.length; i++) {\n        keys.push(comKey.loc[i]);\n      }\n    } else {\n      keys.push(key);\n    }\n  } else {\n    const locKeys = key;\n    for (let i = 0; i < locKeys.length; i++) {\n      keys.push(locKeys[i]);\n    }\n  }\n  return keys;\n};\nvar constructPriKey = (pk, kt) => {\n  logger2.trace(\"constructPriKey\", { pk, kt });\n  let pri;\n  if (typeof pk === \"string\" || typeof pk === \"number\") {\n    pri = { kt, pk };\n  } else {\n    pri = pk;\n  }\n  return pri;\n};\nvar cPK = constructPriKey;\nvar toKeyTypeArray = (ik) => {\n  logger2.trace(\"toKeyTypeArray\", { ik });\n  if (isComKey(ik)) {\n    const ck = ik;\n    return [ck.kt, ...ck.loc.map((l) => l.kt)];\n  } else {\n    return [ik.kt];\n  }\n};\nvar abbrevIK = (ik) => {\n  logger2.trace(\"abbrevIK\", { ik });\n  if (ik) {\n    if (isComKey(ik)) {\n      const ck = ik;\n      return `${ck.kt}:${ck.pk}:${ck.loc.map((l) => `${l.kt}:${l.lk}`).join(\",\")}`;\n    } else {\n      return `${ik.kt}:${ik.pk}`;\n    }\n  } else {\n    return \"null IK\";\n  }\n};\nvar abbrevLKA = (keyArray) => {\n  logger2.trace(\"abbrevLKA\", { keyArray });\n  if (keyArray === void 0 || keyArray === null) {\n    return \"null LKA\";\n  } else {\n    return keyArray.map((key) => {\n      if (key) {\n        return `${key.kt}:${key.lk}`;\n      } else {\n        return key;\n      }\n    }).join(\",\");\n  }\n};\nvar primaryType = (ik) => {\n  logger2.trace(\"primaryType\", { ik });\n  if (isComKey(ik)) {\n    return ik.kt;\n  } else {\n    return ik.kt;\n  }\n};\nvar itemKeyToLocKeyArray = (ik) => {\n  logger2.trace(\"itemKeyToLocKeyArray\", { ik: abbrevIK(ik) });\n  let lka = [];\n  if (isComKey(ik)) {\n    const ck = ik;\n    lka = [{ kt: ck.kt, lk: ck.pk }, ...ck.loc];\n  } else {\n    const pk = ik;\n    lka = [{ kt: pk.kt, lk: pk.pk }];\n  }\n  logger2.trace(\"itemKeyToLocKeyArray Results\", { ik: abbrevIK(ik), lka: abbrevLKA(lka) });\n  return lka;\n};\nvar ikToLKA = itemKeyToLocKeyArray;\nvar locKeyArrayToItemKey = (lka) => {\n  logger2.trace(\"locKeyArrayToItemKey\", { lka: abbrevLKA(lka) });\n  if (lka && lka.length === 1) {\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    return priKey;\n  } else if (lka && lka.length > 1 && lka[0] !== void 0) {\n    const locs = lka.slice(1);\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    const comKey = { kt: priKey.kt, pk: priKey.pk, loc: locs };\n    return comKey;\n  } else {\n    throw new Error(\"locKeyArrayToItemKey: lka is undefined or empty\");\n  }\n};\nvar isValidPriKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.pk !== void 0 && key.pk !== null && key.pk !== \"\" && key.pk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.lk !== void 0 && key.lk !== null && key.lk !== \"\" && key.lk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKeyArray = (keyArray) => {\n  return keyArray !== void 0 && keyArray !== null && keyArray.every(isValidLocKey);\n};\nvar isValidComKey = (key) => {\n  return key !== void 0 && key !== null && isValidPriKey(key) && isValidLocKeyArray(key.loc);\n};\nvar isValidItemKey = (key) => {\n  return isComKey(key) && isValidComKey(key) || isPriKey(key) && isValidPriKey(key);\n};\nvar lkaToIK = locKeyArrayToItemKey;\n\n// src/item/IFactory.ts\nvar IFactory = class _IFactory {\n  item = {};\n  constructor(props = {}) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n  }\n  addRef(i, name) {\n    const ik = i.key;\n    const refName = name || primaryType(ik);\n    if (!this.item.refs) {\n      this.item.refs = {};\n    }\n    this.item.refs[refName] = ik;\n    return this;\n  }\n  static addRef(i, name) {\n    return new _IFactory().addRef(i, name);\n  }\n  addDefaultEvents() {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    const now = /* @__PURE__ */ new Date();\n    if (!this.item.events.created) {\n      this.item.events.created = { at: now };\n    }\n    if (!this.item.events.updated) {\n      this.item.events.updated = { at: now };\n    }\n    if (!this.item.events.deleted) {\n      this.item.events.deleted = { at: null };\n    }\n    return this;\n  }\n  addEvent(name, at, by) {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    this.item.events[name] = { at, by };\n    return this;\n  }\n  static addEvent(name, at, by) {\n    return new _IFactory().addEvent(name, at, by);\n  }\n  addProp(name, value) {\n    this.item[name] = value;\n    return this;\n  }\n  static addProp(name, value) {\n    return new _IFactory().addProp(name, value);\n  }\n  addProps(props) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n    return this;\n  }\n  static addProps(props) {\n    return new _IFactory().addProps(props);\n  }\n  toItem() {\n    return this.item;\n  }\n};\n\n// src/AItemService.ts\nvar AItemService = class {\n  pkType;\n  parentService = null;\n  constructor(pkType, parentService) {\n    this.pkType = pkType;\n    if (parentService) {\n      this.parentService = parentService;\n    }\n  }\n  getPkType = () => {\n    return this.pkType;\n  };\n  getKeyTypes = () => {\n    let keyTypes = [this.getPkType()];\n    if (this.parentService) {\n      keyTypes = keyTypes.concat(this.parentService.getKeyTypes());\n    }\n    return keyTypes;\n  };\n};\n\n// src/item/ItemQuery.ts\nvar isCondition = (condition) => {\n  return (typeof condition.column === \"string\" && (Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"string\")) || Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"number\") || typeof condition.value === \"string\" || typeof condition.value === \"number\" || typeof condition.value === \"boolean\" || condition.value instanceof Date) && (condition.operator ? typeof condition.operator === \"string\" : true);\n};\n\n// src/item/IQFactory.ts\nvar IQFactory = class _IQFactory {\n  query = {};\n  constructor(query = {}) {\n    this.query = query;\n  }\n  orderBy(field, direction = \"asc\") {\n    if (!this.query.orderBy) {\n      this.query.orderBy = [];\n    }\n    this.query.orderBy.push({ field, direction });\n    return this;\n  }\n  agg(name, query) {\n    if (!this.query.aggs) {\n      this.query.aggs = {};\n    }\n    this.query.aggs[name] = query;\n    return this;\n  }\n  event(name, query) {\n    if (!this.query.events) {\n      this.query.events = {};\n    }\n    this.query.events[name] = query;\n    return this;\n  }\n  conditions(conditions, compoundType = \"AND\") {\n    for (const condition of conditions) {\n      if (!isCondition(condition)) {\n        throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n      }\n    }\n    if (!this.query.compoundCondition) {\n      this.query.compoundCondition = {\n        compoundType,\n        conditions\n      };\n    } else {\n      const compoundCondition = {\n        compoundType,\n        conditions\n      };\n      this.query.compoundCondition.conditions.push(compoundCondition);\n    }\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  // TODO: right now, we're only supporting PK refs for queries.  Should add support for CKs\n  pk(kt, pk, name) {\n    if (!this.query.refs) {\n      this.query.refs = {};\n    }\n    const refName = name || kt;\n    this.query.refs[refName] = cPK(pk, kt);\n    return this;\n  }\n  condition(column, value, operator = \"==\") {\n    const condition = { column, value, operator };\n    if (isCondition(condition)) {\n      if (!this.query.compoundCondition) {\n        this.query.compoundCondition = {\n          compoundType: \"AND\",\n          conditions: []\n        };\n      }\n      this.query.compoundCondition.conditions.push(condition);\n      return this;\n    } else {\n      throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n    }\n  }\n  static all() {\n    const iqFactory = new _IQFactory();\n    return iqFactory;\n  }\n  static orderBy(field, direction = \"asc\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.orderBy(field, direction);\n  }\n  static agg(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.agg(name, query);\n  }\n  static event(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.event(name, query);\n  }\n  static limit(limit) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.limit(limit);\n  }\n  static offset(offset) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.offset(offset);\n  }\n  static pk(kt, pk, name) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.pk(kt, pk, name);\n  }\n  static condition(column, value, operator = \"==\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.condition(column, value, operator);\n  }\n  static conditions(conditions, compoundType = \"AND\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.conditions(conditions, compoundType);\n  }\n  toQuery() {\n    return this.query;\n  }\n};\n\n// src/item/IQUtils.ts\n\nvar logger3 = logger_default.get(\"IQUtils\");\nvar queryToParams = (query) => {\n  const params = {};\n  if (query.compoundCondition) {\n    params.compoundCondition = JSON.stringify(query.compoundCondition);\n  }\n  if (query.refs) {\n    params.refs = JSON.stringify(query.refs);\n  }\n  if (query.limit) {\n    params.limit = query.limit;\n  }\n  if (query.offset) {\n    params.offset = query.offset;\n  }\n  if (query.aggs) {\n    params.aggs = JSON.stringify(query.aggs);\n  }\n  if (query.events) {\n    params.events = JSON.stringify(query.events);\n  }\n  return params;\n};\nvar dateTimeReviver = function(key, value) {\n  if (typeof value === \"string\") {\n    const parsedDate = luxon__WEBPACK_IMPORTED_MODULE_2__.DateTime.fromISO(value);\n    if (parsedDate.isValid) {\n      return parsedDate.toJSDate();\n      ;\n    }\n  }\n  return value;\n};\nvar paramsToQuery = (params) => {\n  const query = {};\n  if (params.compoundCondition) {\n    query.compoundCondition = JSON.parse(params.compoundCondition);\n  }\n  if (params.refs) {\n    query.refs = JSON.parse(params.refs);\n  }\n  if (params.limit) {\n    query.limit = Number(params.limit);\n  }\n  if (params.offset) {\n    query.offset = Number(params.offset);\n  }\n  if (params.aggs) {\n    query.aggs = JSON.parse(params.aggs);\n  }\n  if (params.events) {\n    query.events = JSON.parse(params.events, dateTimeReviver);\n  }\n  return query;\n};\nvar isRefQueryMatch = (refKey, queryRef, references) => {\n  logger3.trace(\"doesRefMatch\", { queryRef, references });\n  logger3.debug(\"Comparing Ref\", { refKey, itemRef: references[refKey], queryRef });\n  return isItemKeyEqual(queryRef, references[refKey]);\n};\nvar isCompoundConditionQueryMatch = (queryCondition, item) => {\n  if (queryCondition.compoundType === \"AND\") {\n    return queryCondition.conditions.every(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  } else {\n    return queryCondition.conditions.some(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  }\n};\nvar isConditionQueryMatch = (queryCondition, item) => {\n  const propKey = queryCondition.column;\n  logger3.trace(\"doesConditionMatch\", { propKey, queryCondition, item });\n  if (item[propKey] === void 0) {\n    logger3.debug(\"Item does not contain prop under key\", { propKey, item });\n    return false;\n  }\n  logger3.debug(\"Comparing Condition\", { propKey, itemProp: item[propKey], queryCondition });\n  let result = false;\n  switch (queryCondition.operator) {\n    case \"==\":\n      result = item[propKey] === queryCondition.value;\n      break;\n    case \"!=\":\n      result = item[propKey] !== queryCondition.value;\n      break;\n    case \">\":\n      result = item[propKey] > queryCondition.value;\n      break;\n    case \">=\":\n      result = item[propKey] >= queryCondition.value;\n      break;\n    case \"<\":\n      result = item[propKey] < queryCondition.value;\n      break;\n    case \"<=\":\n      result = item[propKey] <= queryCondition.value;\n      break;\n    case \"in\":\n      result = queryCondition.value.includes(item[propKey]);\n      break;\n    case \"not-in\":\n      result = !queryCondition.value.includes(item[propKey]);\n      break;\n    case \"array-contains\":\n      result = item[propKey].includes(queryCondition.value);\n      break;\n    case \"array-contains-any\":\n      result = queryCondition.value.some((value) => item[propKey].includes(value));\n      break;\n  }\n  return result;\n};\nvar isAggQueryMatch = (aggKey, aggQuery, agg) => {\n  const aggItem = agg.item;\n  logger3.debug(\"Comparing Agg\", { aggKey, aggItem, aggQuery });\n  return isQueryMatch(aggItem, aggQuery);\n};\nvar isEventQueryMatch = (eventKey, eventQuery, item) => {\n  if (!item.events[eventKey]) {\n    logger3.debug(\"Item does not contain event under key\", { eventKey, events: item.events });\n    return false;\n  } else {\n    const itemEvent = item.events[eventKey];\n    if (itemEvent.at !== null) {\n      if (eventQuery.start && !(eventQuery.start.getTime() <= itemEvent.at.getTime())) {\n        logger3.debug(\"Item date before event start query\", { eventQuery, itemEvent });\n        return false;\n      }\n      if (eventQuery.end && !(eventQuery.end.getTime() > itemEvent.at.getTime())) {\n        logger3.debug(\"Item date after event end query\", { eventQuery, itemEvent });\n        return false;\n      }\n    } else {\n      logger3.debug(\"Item event does contains a null at\", { itemEvent });\n      return false;\n    }\n    return true;\n  }\n};\nvar isQueryMatch = (item, query) => {\n  logger3.trace(\"isMatch\", { item, query });\n  if (query.refs && item.refs) {\n    for (const key in query.refs) {\n      const queryRef = query.refs[key];\n      if (!isRefQueryMatch(key, queryRef, item.refs)) return false;\n    }\n  } else if (query.refs && !item.refs) {\n    logger3.debug(\"Query contains refs but item does not have refs\", { query, item });\n    return false;\n  }\n  if (query.compoundCondition && item) {\n    if (!isCompoundConditionQueryMatch(query.compoundCondition, item)) return false;\n  }\n  if (query.events && item.events) {\n    for (const key in query.events) {\n      const queryEvent = query.events[key];\n      if (!isEventQueryMatch(key, queryEvent, item)) return false;\n    }\n    return true;\n  }\n  if (query.aggs && item.aggs) {\n    for (const key in query.aggs) {\n      const aggQuery = query.aggs[key];\n      if (item.aggs[key] && !isAggQueryMatch(key, aggQuery, item.aggs[key])) return false;\n    }\n  }\n  if (query.aggs && !item.aggs) {\n    logger3.debug(\"Query contains aggs but item does not have aggs\", { query, item });\n    return false;\n  }\n  return true;\n};\nvar abbrevQuery = (query) => {\n  const abbrev = [\"IQ\"];\n  if (query) {\n    if (query.refs) {\n      for (const key in query.refs) {\n        const ref = abbrevRef(key, query.refs[key]);\n        abbrev.push(ref);\n      }\n    }\n    if (query.compoundCondition) {\n      const props = abbrevCompoundCondition(query.compoundCondition);\n      abbrev.push(props);\n    }\n    if (query.aggs) {\n      for (const key in query.aggs) {\n        const agg = abbrevAgg(key, query.aggs[key]);\n        abbrev.push(agg);\n      }\n    }\n    if (query.events) {\n      const events = `(E${Object.keys(query.events).join(\",\")})`;\n      abbrev.push(events);\n    }\n    if (query.limit) {\n      abbrev.push(`L${query.limit}`);\n    }\n    if (query.offset) {\n      abbrev.push(`O${query.offset}`);\n    }\n  } else {\n    abbrev.push(\"(empty)\");\n  }\n  return abbrev.join(\" \");\n};\nvar abbrevRef = (key, ref) => {\n  if (isPriKey(ref)) {\n    const priKey = ref;\n    return `R(${key},${priKey.kt},${priKey.pk})`;\n  } else {\n    const comKey = ref;\n    return `R(${key},${JSON.stringify(comKey)})`;\n  }\n};\nvar abbrevAgg = (key, agg) => {\n  return `A(${key},${abbrevQuery(agg)})`;\n};\nvar abbrevCompoundCondition = (compoundCondition) => {\n  return `CC(${compoundCondition.compoundType},${compoundCondition.conditions ? compoundCondition.conditions.map(abbrevCondition).join(\",\") : \"No Conditions\"})`;\n};\nvar abbrevCondition = (condition) => {\n  if (isCondition(condition)) {\n    return `(${condition.column},${condition.value},${condition.operator})`;\n  } else {\n    return abbrevCompoundCondition(condition);\n  }\n};\n\n// src/item/IUtils.ts\nvar logger4 = logger_default.get(\"IUtils\");\nvar validatePKForItem = (item, pkType) => {\n  if (!item) {\n    logger4.error(\"Validating PK, Item is undefined\", { item });\n    throw new Error(\"Validating PK, Item is undefined\");\n  }\n  if (!item.key) {\n    logger4.error(\"Validating PK, Item does not have a key\", { item });\n    throw new Error(\"Validating PK, Item does not have a key\");\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray[0] !== pkType) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, pkType });\n    throw new Error(`Item does not have the correct primary key type. Expected ${pkType}, got ${keyTypeArray[0]}`);\n  }\n  return item;\n};\nvar validatePK = (input, pkType) => {\n  logger4.trace(\"Checking Return Type\", { input });\n  if (Array.isArray(input)) {\n    return input.map((item) => validatePKForItem(item, pkType));\n  }\n  return validatePKForItem(input, pkType);\n};\nvar validateKeys = (item, keyTypes) => {\n  logger4.trace(\"Checking Return Type\", { item });\n  if (!item) {\n    throw new Error(\"validating keys, item is undefined\");\n  }\n  if (!item.key) {\n    throw new Error(\"validating keys, item does not have a key: \" + JSON.stringify(item));\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray.length !== keyTypes.length) {\n    throw new Error(`Item does not have the correct number of keys. Expected ${keyTypes.length}, but got ${keyTypeArray.length}`);\n  }\n  const match = JSON.stringify(keyTypeArray) === JSON.stringify(keyTypes);\n  if (!match) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, thisKeyTypes: keyTypes });\n    throw new Error(`Item does not have the correct key types. Expected [${keyTypes.join(\", \")}], but got [${keyTypeArray.join(\", \")}]`);\n  }\n  return item;\n};\nvar isPriItem = (item) => {\n  return !!(item && item.key && isPriKey(item.key));\n};\nvar isComItem = (item) => {\n  return !!(item && item.key && isComKey(item.key));\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDO0FBQ3JDLGdCQUFnQixnRUFBaUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsVUFBVTtBQUNWLGdGQUFnRixXQUFXO0FBQzNGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRCwwQ0FBMEMsb0JBQW9CLElBQUksb0JBQW9CO0FBQ3RGO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDL0g7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNDQUFzQztBQUNyRiwyRUFBMkUsb0JBQW9CLGNBQWMsd0JBQXdCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdERTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9AZmplbGwvY29yZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9sb2dnZXIudHNcbmltcG9ydCBMb2dnaW5nIGZyb20gXCJAZmplbGwvbG9nZ2luZ1wiO1xudmFyIExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKFwiQGZqZWxsL2NvcmVcIik7XG52YXIgbG9nZ2VyX2RlZmF1bHQgPSBMaWJMb2dnZXI7XG5cbi8vIHNyYy9kaWN0aW9uYXJ5LnRzXG52YXIgbG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiRGljdGlvbmFyeVwiKTtcbnZhciBEaWN0aW9uYXJ5ID0gY2xhc3MgX0RpY3Rpb25hcnkge1xuICBtYXAgPSB7fTtcbiAgaGFzaEZ1bmN0aW9uID0gKGtleSkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgY29uc3RydWN0b3IobWFwLCBoYXNoRnVuY3Rpb24pIHtcbiAgICBpZiAoaGFzaEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLmhhc2hGdW5jdGlvbiA9IGhhc2hGdW5jdGlvbjtcbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgT2JqZWN0LmVudHJpZXMobWFwKS5mb3JFYWNoKChbaGFzaGVkS2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbEtleSA9IEpTT04ucGFyc2UoaGFzaGVkS2V5KTtcbiAgICAgICAgICB0aGlzLm1hcFtoYXNoZWRLZXldID0geyBvcmlnaW5hbEtleSwgdmFsdWUgfTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgbG9nZ2VyLndhcm5pbmcoXCJDYW5ub3QgcmVjb3ZlciBvcmlnaW5hbCBrZXkgZnJvbSBsZWdhY3kgbWFwIGVudHJ5XCIsIHsgaGFzaGVkS2V5IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2V0KGtleSwgaXRlbSkge1xuICAgIGxvZ2dlci50cmFjZShcInNldFwiLCB7IGtleSwgaXRlbSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7IG9yaWdpbmFsS2V5OiBrZXksIHZhbHVlOiBpdGVtIH07XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGxvZ2dlci50cmFjZShcImdldFwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICByZXR1cm4gZW50cnkgJiYgdGhpcy5rZXlzRXF1YWwoZW50cnkub3JpZ2luYWxLZXksIGtleSkgPyBlbnRyeS52YWx1ZSA6IG51bGw7XG4gIH1cbiAga2V5c0VxdWFsKGtleTEsIGtleTIpIHtcbiAgICByZXR1cm4ga2V5MSA9PT0ga2V5MjtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiZGVsZXRlXCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgZGVsZXRlIHRoaXMubWFwW2hhc2hlZEtleV07XG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkubWFwKChlbnRyeSkgPT4gZW50cnkub3JpZ2luYWxLZXkpO1xuICB9XG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkubWFwKChlbnRyeSkgPT4gZW50cnkudmFsdWUpO1xuICB9XG4gIGluY2x1ZGVzS2V5KGtleSkge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiBlbnRyeSA/IHRoaXMua2V5c0VxdWFsKGVudHJ5Lm9yaWdpbmFsS2V5LCBrZXkpIDogZmFsc2U7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmVkTWFwID0ge307XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5tYXApLmZvckVhY2goKFtoYXNoZWRLZXksIGVudHJ5XSkgPT4ge1xuICAgICAgY2xvbmVkTWFwW2hhc2hlZEtleV0gPSBlbnRyeS52YWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBfRGljdGlvbmFyeShjbG9uZWRNYXAsIHRoaXMuaGFzaEZ1bmN0aW9uKTtcbiAgICBjbG9uZS5tYXAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1hcCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59O1xuXG4vLyBzcmMvaXRlbS9JRmFjdG9yeS50c1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tIFwiZGVlcG1lcmdlXCI7XG5cbi8vIHNyYy9rZXkvS1V0aWxzLnRzXG52YXIgbG9nZ2VyMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIktVdGlsc1wiKTtcbnZhciBub3JtYWxpemVLZXlWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn07XG52YXIgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIChrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGtleSkpO1xuICAgICAgaWYgKFwicGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIChub3JtYWxpemVkS2V5LnBrICE9PSB2b2lkIDAgJiYgbm9ybWFsaXplZEtleS5wayAhPT0gbnVsbCkpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5wayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWRLZXkucGspO1xuICAgICAgfVxuICAgICAgaWYgKFwibGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIChub3JtYWxpemVkS2V5LmxrICE9PSB2b2lkIDAgJiYgbm9ybWFsaXplZEtleS5sayAhPT0gbnVsbCkpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5sayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWRLZXkubGspO1xuICAgICAgfVxuICAgICAgaWYgKFwibG9jXCIgaW4gbm9ybWFsaXplZEtleSAmJiBBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRLZXkubG9jKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxvYyA9IG5vcm1hbGl6ZWRLZXkubG9jLm1hcCgobG9jSXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChsb2NJdGVtICYmIFwibGtcIiBpbiBsb2NJdGVtICYmIChsb2NJdGVtLmxrICE9PSB2b2lkIDAgJiYgbG9jSXRlbS5sayAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmxvY0l0ZW0sIGxrOiBub3JtYWxpemVLZXlWYWx1ZShsb2NJdGVtLmxrKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9jSXRlbTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZEtleSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICB9O1xufTtcbnZhciBpc1ByaUtleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc1ByaUtleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgbm9ybWFsaXplS2V5VmFsdWUoYS5waykgPT09IG5vcm1hbGl6ZUtleVZhbHVlKGIucGspICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzTG9jS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzTG9jS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBub3JtYWxpemVLZXlWYWx1ZShhLmxrKSA9PT0gbm9ybWFsaXplS2V5VmFsdWUoYi5saykgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICBpZiAoYSAmJiBiICYmIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkKHsga3Q6IGEua3QsIHBrOiBhLnBrIH0sIHsga3Q6IGIua3QsIHBrOiBiLnBrIH0pKSB7XG4gICAgaWYgKGEubG9jLmxlbmd0aCA9PT0gYi5sb2MubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQoYS5sb2NbaV0sIGIubG9jW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzSXRlbUtleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICBpZiAoaXNDb21LZXkoYSkgJiYgaXNDb21LZXkoYikpIHtcbiAgICByZXR1cm4gaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWQoYSwgYik7XG4gIH0gZWxzZSBpZiAoaXNQcmlLZXkoYSkgJiYgaXNQcmlLZXkoYikpIHtcbiAgICBpZiAoaXNDb21LZXkoYSkgfHwgaXNDb21LZXkoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkKGEsIGIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNJdGVtS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNLZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIGlmIChpc0NvbUtleShhKSAmJiBpc0NvbUtleShiKSkge1xuICAgIHJldHVybiBpc0NvbUtleUVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKGlzUHJpS2V5KGEpICYmIGlzUHJpS2V5KGIpKSB7XG4gICAgaWYgKGlzQ29tS2V5KGEpIHx8IGlzQ29tS2V5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc1ByaUtleUVxdWFsKGEsIGIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNQcmlLZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc1ByaUtleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBhLnBrID09PSBiLnBrICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzTG9jS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNMb2NLZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgYS5sayA9PT0gYi5sayAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0NvbUtleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzQ29tS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICBpZiAoYSAmJiBiICYmIGlzUHJpS2V5RXF1YWwoeyBrdDogYS5rdCwgcGs6IGEucGsgfSwgeyBrdDogYi5rdCwgcGs6IGIucGsgfSkpIHtcbiAgICBpZiAoYS5sb2MubGVuZ3RoID09PSBiLmxvYy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0xvY0tleUVxdWFsKGEubG9jW2ldLCBiLmxvY1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0l0ZW1LZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0l0ZW1LZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoaXNDb21LZXkoa2V5KSB8fCBpc1ByaUtleShrZXkpKTtcbn07XG52YXIgaXNDb21LZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0NvbUtleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChrZXkucGsgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IHZvaWQgMCkgJiYgKGtleS5sb2MgIT09IHZvaWQgMCAmJiBrZXkubG9jLmxlbmd0aCA+IDApO1xufTtcbnZhciBpc1ByaUtleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzUHJpS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGtleS5wayAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gdm9pZCAwKSAmJiAoa2V5LmxvYyA9PT0gdm9pZCAwIHx8IGtleS5sb2MubGVuZ3RoID09PSAwKTtcbn07XG52YXIgaXNMb2NLZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0xvY0tleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChrZXkubGsgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IHZvaWQgMCk7XG59O1xudmFyIGdlbmVyYXRlS2V5QXJyYXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJnZW5lcmF0ZUtleUFycmF5XCIsIHsga2V5IH0pO1xuICBjb25zdCBrZXlzID0gW107XG4gIGlmIChpc0NvbUtleShrZXkpIHx8IGlzUHJpS2V5KGtleSkpIHtcbiAgICBpZiAoaXNDb21LZXkoa2V5KSkge1xuICAgICAgY29uc3QgY29tS2V5ID0ga2V5O1xuICAgICAga2V5cy5wdXNoKHsgcGs6IGNvbUtleS5waywga3Q6IGNvbUtleS5rdCB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tS2V5LmxvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXlzLnB1c2goY29tS2V5LmxvY1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsb2NLZXlzID0ga2V5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKGxvY0tleXNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG52YXIgY29uc3RydWN0UHJpS2V5ID0gKHBrLCBrdCkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiY29uc3RydWN0UHJpS2V5XCIsIHsgcGssIGt0IH0pO1xuICBsZXQgcHJpO1xuICBpZiAodHlwZW9mIHBrID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwayA9PT0gXCJudW1iZXJcIikge1xuICAgIHByaSA9IHsga3QsIHBrIH07XG4gIH0gZWxzZSB7XG4gICAgcHJpID0gcGs7XG4gIH1cbiAgcmV0dXJuIHByaTtcbn07XG52YXIgY1BLID0gY29uc3RydWN0UHJpS2V5O1xudmFyIHRvS2V5VHlwZUFycmF5ID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJ0b0tleVR5cGVBcnJheVwiLCB7IGlrIH0pO1xuICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgY29uc3QgY2sgPSBpaztcbiAgICByZXR1cm4gW2NrLmt0LCAuLi5jay5sb2MubWFwKChsKSA9PiBsLmt0KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtpay5rdF07XG4gIH1cbn07XG52YXIgYWJicmV2SUsgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImFiYnJldklLXCIsIHsgaWsgfSk7XG4gIGlmIChpaykge1xuICAgIGlmIChpc0NvbUtleShpaykpIHtcbiAgICAgIGNvbnN0IGNrID0gaWs7XG4gICAgICByZXR1cm4gYCR7Y2sua3R9OiR7Y2sucGt9OiR7Y2subG9jLm1hcCgobCkgPT4gYCR7bC5rdH06JHtsLmxrfWApLmpvaW4oXCIsXCIpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtpay5rdH06JHtpay5wa31gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJudWxsIElLXCI7XG4gIH1cbn07XG52YXIgYWJicmV2TEtBID0gKGtleUFycmF5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJhYmJyZXZMS0FcIiwgeyBrZXlBcnJheSB9KTtcbiAgaWYgKGtleUFycmF5ID09PSB2b2lkIDAgfHwga2V5QXJyYXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsIExLQVwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlBcnJheS5tYXAoKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICByZXR1cm4gYCR7a2V5Lmt0fToke2tleS5sa31gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9KS5qb2luKFwiLFwiKTtcbiAgfVxufTtcbnZhciBwcmltYXJ5VHlwZSA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwicHJpbWFyeVR5cGVcIiwgeyBpayB9KTtcbiAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgIHJldHVybiBpay5rdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaWsua3Q7XG4gIH1cbn07XG52YXIgaXRlbUtleVRvTG9jS2V5QXJyYXkgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcIml0ZW1LZXlUb0xvY0tleUFycmF5XCIsIHsgaWs6IGFiYnJldklLKGlrKSB9KTtcbiAgbGV0IGxrYSA9IFtdO1xuICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgY29uc3QgY2sgPSBpaztcbiAgICBsa2EgPSBbeyBrdDogY2sua3QsIGxrOiBjay5wayB9LCAuLi5jay5sb2NdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBrID0gaWs7XG4gICAgbGthID0gW3sga3Q6IHBrLmt0LCBsazogcGsucGsgfV07XG4gIH1cbiAgbG9nZ2VyMi50cmFjZShcIml0ZW1LZXlUb0xvY0tleUFycmF5IFJlc3VsdHNcIiwgeyBpazogYWJicmV2SUsoaWspLCBsa2E6IGFiYnJldkxLQShsa2EpIH0pO1xuICByZXR1cm4gbGthO1xufTtcbnZhciBpa1RvTEtBID0gaXRlbUtleVRvTG9jS2V5QXJyYXk7XG52YXIgbG9jS2V5QXJyYXlUb0l0ZW1LZXkgPSAobGthKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJsb2NLZXlBcnJheVRvSXRlbUtleVwiLCB7IGxrYTogYWJicmV2TEtBKGxrYSkgfSk7XG4gIGlmIChsa2EgJiYgbGthLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHByaUtleSA9IGNQSyhsa2FbMF0ubGssIGxrYVswXS5rdCk7XG4gICAgcmV0dXJuIHByaUtleTtcbiAgfSBlbHNlIGlmIChsa2EgJiYgbGthLmxlbmd0aCA+IDEgJiYgbGthWzBdICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBsb2NzID0gbGthLnNsaWNlKDEpO1xuICAgIGNvbnN0IHByaUtleSA9IGNQSyhsa2FbMF0ubGssIGxrYVswXS5rdCk7XG4gICAgY29uc3QgY29tS2V5ID0geyBrdDogcHJpS2V5Lmt0LCBwazogcHJpS2V5LnBrLCBsb2M6IGxvY3MgfTtcbiAgICByZXR1cm4gY29tS2V5O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvY0tleUFycmF5VG9JdGVtS2V5OiBsa2EgaXMgdW5kZWZpbmVkIG9yIGVtcHR5XCIpO1xuICB9XG59O1xudmFyIGlzVmFsaWRQcmlLZXkgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IHZhbGlkID0ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSBudWxsICYmIChrZXkucGsgIT09IHZvaWQgMCAmJiBrZXkucGsgIT09IG51bGwgJiYga2V5LnBrICE9PSBcIlwiICYmIGtleS5wayAhPT0gXCJudWxsXCIpICYmIChrZXkua3QgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IG51bGwgJiYga2V5Lmt0ICE9PSBcIlwiICYmIGtleS5rdCAhPT0gXCJudWxsXCIpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xudmFyIGlzVmFsaWRMb2NLZXkgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IHZhbGlkID0ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSBudWxsICYmIChrZXkubGsgIT09IHZvaWQgMCAmJiBrZXkubGsgIT09IG51bGwgJiYga2V5LmxrICE9PSBcIlwiICYmIGtleS5sayAhPT0gXCJudWxsXCIpICYmIChrZXkua3QgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IG51bGwgJiYga2V5Lmt0ICE9PSBcIlwiICYmIGtleS5rdCAhPT0gXCJudWxsXCIpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xudmFyIGlzVmFsaWRMb2NLZXlBcnJheSA9IChrZXlBcnJheSkgPT4ge1xuICByZXR1cm4ga2V5QXJyYXkgIT09IHZvaWQgMCAmJiBrZXlBcnJheSAhPT0gbnVsbCAmJiBrZXlBcnJheS5ldmVyeShpc1ZhbGlkTG9jS2V5KTtcbn07XG52YXIgaXNWYWxpZENvbUtleSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gbnVsbCAmJiBpc1ZhbGlkUHJpS2V5KGtleSkgJiYgaXNWYWxpZExvY0tleUFycmF5KGtleS5sb2MpO1xufTtcbnZhciBpc1ZhbGlkSXRlbUtleSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIGlzQ29tS2V5KGtleSkgJiYgaXNWYWxpZENvbUtleShrZXkpIHx8IGlzUHJpS2V5KGtleSkgJiYgaXNWYWxpZFByaUtleShrZXkpO1xufTtcbnZhciBsa2FUb0lLID0gbG9jS2V5QXJyYXlUb0l0ZW1LZXk7XG5cbi8vIHNyYy9pdGVtL0lGYWN0b3J5LnRzXG52YXIgSUZhY3RvcnkgPSBjbGFzcyBfSUZhY3Rvcnkge1xuICBpdGVtID0ge307XG4gIGNvbnN0cnVjdG9yKHByb3BzID0ge30pIHtcbiAgICB0aGlzLml0ZW0gPSBkZWVwbWVyZ2UodGhpcy5pdGVtLCBwcm9wcyk7XG4gIH1cbiAgYWRkUmVmKGksIG5hbWUpIHtcbiAgICBjb25zdCBpayA9IGkua2V5O1xuICAgIGNvbnN0IHJlZk5hbWUgPSBuYW1lIHx8IHByaW1hcnlUeXBlKGlrKTtcbiAgICBpZiAoIXRoaXMuaXRlbS5yZWZzKSB7XG4gICAgICB0aGlzLml0ZW0ucmVmcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLml0ZW0ucmVmc1tyZWZOYW1lXSA9IGlrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRSZWYoaSwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkUmVmKGksIG5hbWUpO1xuICB9XG4gIGFkZERlZmF1bHRFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzID0ge307XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cy5jcmVhdGVkKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzLmNyZWF0ZWQgPSB7IGF0OiBub3cgfTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzLnVwZGF0ZWQpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMudXBkYXRlZCA9IHsgYXQ6IG5vdyB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMuZGVsZXRlZCkge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cy5kZWxldGVkID0geyBhdDogbnVsbCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRFdmVudChuYW1lLCBhdCwgYnkpIHtcbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLmV2ZW50c1tuYW1lXSA9IHsgYXQsIGJ5IH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZEV2ZW50KG5hbWUsIGF0LCBieSkge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkRXZlbnQobmFtZSwgYXQsIGJ5KTtcbiAgfVxuICBhZGRQcm9wKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5pdGVtW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZFByb3AobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZFByb3AobmFtZSwgdmFsdWUpO1xuICB9XG4gIGFkZFByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5pdGVtID0gZGVlcG1lcmdlKHRoaXMuaXRlbSwgcHJvcHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkUHJvcHMocHJvcHMpO1xuICB9XG4gIHRvSXRlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtO1xuICB9XG59O1xuXG4vLyBzcmMvQUl0ZW1TZXJ2aWNlLnRzXG52YXIgQUl0ZW1TZXJ2aWNlID0gY2xhc3Mge1xuICBwa1R5cGU7XG4gIHBhcmVudFNlcnZpY2UgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihwa1R5cGUsIHBhcmVudFNlcnZpY2UpIHtcbiAgICB0aGlzLnBrVHlwZSA9IHBrVHlwZTtcbiAgICBpZiAocGFyZW50U2VydmljZSkge1xuICAgICAgdGhpcy5wYXJlbnRTZXJ2aWNlID0gcGFyZW50U2VydmljZTtcbiAgICB9XG4gIH1cbiAgZ2V0UGtUeXBlID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnBrVHlwZTtcbiAgfTtcbiAgZ2V0S2V5VHlwZXMgPSAoKSA9PiB7XG4gICAgbGV0IGtleVR5cGVzID0gW3RoaXMuZ2V0UGtUeXBlKCldO1xuICAgIGlmICh0aGlzLnBhcmVudFNlcnZpY2UpIHtcbiAgICAgIGtleVR5cGVzID0ga2V5VHlwZXMuY29uY2F0KHRoaXMucGFyZW50U2VydmljZS5nZXRLZXlUeXBlcygpKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVR5cGVzO1xuICB9O1xufTtcblxuLy8gc3JjL2l0ZW0vSXRlbVF1ZXJ5LnRzXG52YXIgaXNDb25kaXRpb24gPSAoY29uZGl0aW9uKSA9PiB7XG4gIHJldHVybiAodHlwZW9mIGNvbmRpdGlvbi5jb2x1bW4gPT09IFwic3RyaW5nXCIgJiYgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uLnZhbHVlKSAmJiBjb25kaXRpb24udmFsdWUuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSkgfHwgQXJyYXkuaXNBcnJheShjb25kaXRpb24udmFsdWUpICYmIGNvbmRpdGlvbi52YWx1ZS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwibnVtYmVyXCIpIHx8IHR5cGVvZiBjb25kaXRpb24udmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNvbmRpdGlvbi52YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29uZGl0aW9uLnZhbHVlID09PSBcImJvb2xlYW5cIiB8fCBjb25kaXRpb24udmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAoY29uZGl0aW9uLm9wZXJhdG9yID8gdHlwZW9mIGNvbmRpdGlvbi5vcGVyYXRvciA9PT0gXCJzdHJpbmdcIiA6IHRydWUpO1xufTtcblxuLy8gc3JjL2l0ZW0vSVFGYWN0b3J5LnRzXG52YXIgSVFGYWN0b3J5ID0gY2xhc3MgX0lRRmFjdG9yeSB7XG4gIHF1ZXJ5ID0ge307XG4gIGNvbnN0cnVjdG9yKHF1ZXJ5ID0ge30pIHtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gIH1cbiAgb3JkZXJCeShmaWVsZCwgZGlyZWN0aW9uID0gXCJhc2NcIikge1xuICAgIGlmICghdGhpcy5xdWVyeS5vcmRlckJ5KSB7XG4gICAgICB0aGlzLnF1ZXJ5Lm9yZGVyQnkgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeS5vcmRlckJ5LnB1c2goeyBmaWVsZCwgZGlyZWN0aW9uIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFnZyhuYW1lLCBxdWVyeSkge1xuICAgIGlmICghdGhpcy5xdWVyeS5hZ2dzKSB7XG4gICAgICB0aGlzLnF1ZXJ5LmFnZ3MgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeS5hZ2dzW25hbWVdID0gcXVlcnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZXZlbnQobmFtZSwgcXVlcnkpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkuZXZlbnRzKSB7XG4gICAgICB0aGlzLnF1ZXJ5LmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5LmV2ZW50c1tuYW1lXSA9IHF1ZXJ5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbmRpdGlvbnMoY29uZGl0aW9ucywgY29tcG91bmRUeXBlID0gXCJBTkRcIikge1xuICAgIGZvciAoY29uc3QgY29uZGl0aW9uIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgIGlmICghaXNDb25kaXRpb24oY29uZGl0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29uZGl0aW9uOiAke0pTT04uc3RyaW5naWZ5KGNvbmRpdGlvbil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbiA9IHtcbiAgICAgICAgY29tcG91bmRUeXBlLFxuICAgICAgICBjb25kaXRpb25zXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21wb3VuZENvbmRpdGlvbiA9IHtcbiAgICAgICAgY29tcG91bmRUeXBlLFxuICAgICAgICBjb25kaXRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zLnB1c2goY29tcG91bmRDb25kaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaW1pdChsaW1pdCkge1xuICAgIHRoaXMucXVlcnkubGltaXQgPSBsaW1pdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvZmZzZXQob2Zmc2V0KSB7XG4gICAgdGhpcy5xdWVyeS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gVE9ETzogcmlnaHQgbm93LCB3ZSdyZSBvbmx5IHN1cHBvcnRpbmcgUEsgcmVmcyBmb3IgcXVlcmllcy4gIFNob3VsZCBhZGQgc3VwcG9ydCBmb3IgQ0tzXG4gIHBrKGt0LCBwaywgbmFtZSkge1xuICAgIGlmICghdGhpcy5xdWVyeS5yZWZzKSB7XG4gICAgICB0aGlzLnF1ZXJ5LnJlZnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcmVmTmFtZSA9IG5hbWUgfHwga3Q7XG4gICAgdGhpcy5xdWVyeS5yZWZzW3JlZk5hbWVdID0gY1BLKHBrLCBrdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29uZGl0aW9uKGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yID0gXCI9PVwiKSB7XG4gICAgY29uc3QgY29uZGl0aW9uID0geyBjb2x1bW4sIHZhbHVlLCBvcGVyYXRvciB9O1xuICAgIGlmIChpc0NvbmRpdGlvbihjb25kaXRpb24pKSB7XG4gICAgICBpZiAoIXRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbiA9IHtcbiAgICAgICAgICBjb21wb3VuZFR5cGU6IFwiQU5EXCIsXG4gICAgICAgICAgY29uZGl0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbmRpdGlvbjogJHtKU09OLnN0cmluZ2lmeShjb25kaXRpb24pfWApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYWxsKCkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeTtcbiAgfVxuICBzdGF0aWMgb3JkZXJCeShmaWVsZCwgZGlyZWN0aW9uID0gXCJhc2NcIikge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5vcmRlckJ5KGZpZWxkLCBkaXJlY3Rpb24pO1xuICB9XG4gIHN0YXRpYyBhZ2cobmFtZSwgcXVlcnkpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuYWdnKG5hbWUsIHF1ZXJ5KTtcbiAgfVxuICBzdGF0aWMgZXZlbnQobmFtZSwgcXVlcnkpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuZXZlbnQobmFtZSwgcXVlcnkpO1xuICB9XG4gIHN0YXRpYyBsaW1pdChsaW1pdCkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5saW1pdChsaW1pdCk7XG4gIH1cbiAgc3RhdGljIG9mZnNldChvZmZzZXQpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3Rvcnkub2Zmc2V0KG9mZnNldCk7XG4gIH1cbiAgc3RhdGljIHBrKGt0LCBwaywgbmFtZSkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5wayhrdCwgcGssIG5hbWUpO1xuICB9XG4gIHN0YXRpYyBjb25kaXRpb24oY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IgPSBcIj09XCIpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuY29uZGl0aW9uKGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgfVxuICBzdGF0aWMgY29uZGl0aW9ucyhjb25kaXRpb25zLCBjb21wb3VuZFR5cGUgPSBcIkFORFwiKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmNvbmRpdGlvbnMoY29uZGl0aW9ucywgY29tcG91bmRUeXBlKTtcbiAgfVxuICB0b1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5O1xuICB9XG59O1xuXG4vLyBzcmMvaXRlbS9JUVV0aWxzLnRzXG5pbXBvcnQgKiBhcyBsdXhvbiBmcm9tIFwibHV4b25cIjtcbnZhciBsb2dnZXIzID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSVFVdGlsc1wiKTtcbnZhciBxdWVyeVRvUGFyYW1zID0gKHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHt9O1xuICBpZiAocXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICBwYXJhbXMuY29tcG91bmRDb25kaXRpb24gPSBKU09OLnN0cmluZ2lmeShxdWVyeS5jb21wb3VuZENvbmRpdGlvbik7XG4gIH1cbiAgaWYgKHF1ZXJ5LnJlZnMpIHtcbiAgICBwYXJhbXMucmVmcyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LnJlZnMpO1xuICB9XG4gIGlmIChxdWVyeS5saW1pdCkge1xuICAgIHBhcmFtcy5saW1pdCA9IHF1ZXJ5LmxpbWl0O1xuICB9XG4gIGlmIChxdWVyeS5vZmZzZXQpIHtcbiAgICBwYXJhbXMub2Zmc2V0ID0gcXVlcnkub2Zmc2V0O1xuICB9XG4gIGlmIChxdWVyeS5hZ2dzKSB7XG4gICAgcGFyYW1zLmFnZ3MgPSBKU09OLnN0cmluZ2lmeShxdWVyeS5hZ2dzKTtcbiAgfVxuICBpZiAocXVlcnkuZXZlbnRzKSB7XG4gICAgcGFyYW1zLmV2ZW50cyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LmV2ZW50cyk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn07XG52YXIgZGF0ZVRpbWVSZXZpdmVyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0ZSA9IGx1eG9uLkRhdGVUaW1lLmZyb21JU08odmFsdWUpO1xuICAgIGlmIChwYXJzZWREYXRlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWREYXRlLnRvSlNEYXRlKCk7XG4gICAgICA7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgcGFyYW1zVG9RdWVyeSA9IChwYXJhbXMpID0+IHtcbiAgY29uc3QgcXVlcnkgPSB7fTtcbiAgaWYgKHBhcmFtcy5jb21wb3VuZENvbmRpdGlvbikge1xuICAgIHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uID0gSlNPTi5wYXJzZShwYXJhbXMuY29tcG91bmRDb25kaXRpb24pO1xuICB9XG4gIGlmIChwYXJhbXMucmVmcykge1xuICAgIHF1ZXJ5LnJlZnMgPSBKU09OLnBhcnNlKHBhcmFtcy5yZWZzKTtcbiAgfVxuICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgcXVlcnkubGltaXQgPSBOdW1iZXIocGFyYW1zLmxpbWl0KTtcbiAgfVxuICBpZiAocGFyYW1zLm9mZnNldCkge1xuICAgIHF1ZXJ5Lm9mZnNldCA9IE51bWJlcihwYXJhbXMub2Zmc2V0KTtcbiAgfVxuICBpZiAocGFyYW1zLmFnZ3MpIHtcbiAgICBxdWVyeS5hZ2dzID0gSlNPTi5wYXJzZShwYXJhbXMuYWdncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5ldmVudHMpIHtcbiAgICBxdWVyeS5ldmVudHMgPSBKU09OLnBhcnNlKHBhcmFtcy5ldmVudHMsIGRhdGVUaW1lUmV2aXZlcik7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcbnZhciBpc1JlZlF1ZXJ5TWF0Y2ggPSAocmVmS2V5LCBxdWVyeVJlZiwgcmVmZXJlbmNlcykgPT4ge1xuICBsb2dnZXIzLnRyYWNlKFwiZG9lc1JlZk1hdGNoXCIsIHsgcXVlcnlSZWYsIHJlZmVyZW5jZXMgfSk7XG4gIGxvZ2dlcjMuZGVidWcoXCJDb21wYXJpbmcgUmVmXCIsIHsgcmVmS2V5LCBpdGVtUmVmOiByZWZlcmVuY2VzW3JlZktleV0sIHF1ZXJ5UmVmIH0pO1xuICByZXR1cm4gaXNJdGVtS2V5RXF1YWwocXVlcnlSZWYsIHJlZmVyZW5jZXNbcmVmS2V5XSk7XG59O1xudmFyIGlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoID0gKHF1ZXJ5Q29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gIGlmIChxdWVyeUNvbmRpdGlvbi5jb21wb3VuZFR5cGUgPT09IFwiQU5EXCIpIHtcbiAgICByZXR1cm4gcXVlcnlDb25kaXRpb24uY29uZGl0aW9ucy5ldmVyeShcbiAgICAgIChjb25kaXRpb24pID0+IGlzQ29uZGl0aW9uKGNvbmRpdGlvbikgPyBpc0NvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKSA6IGlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBxdWVyeUNvbmRpdGlvbi5jb25kaXRpb25zLnNvbWUoXG4gICAgICAoY29uZGl0aW9uKSA9PiBpc0NvbmRpdGlvbihjb25kaXRpb24pID8gaXNDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSkgOiBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBpc0NvbmRpdGlvblF1ZXJ5TWF0Y2ggPSAocXVlcnlDb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgY29uc3QgcHJvcEtleSA9IHF1ZXJ5Q29uZGl0aW9uLmNvbHVtbjtcbiAgbG9nZ2VyMy50cmFjZShcImRvZXNDb25kaXRpb25NYXRjaFwiLCB7IHByb3BLZXksIHF1ZXJ5Q29uZGl0aW9uLCBpdGVtIH0pO1xuICBpZiAoaXRlbVtwcm9wS2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZG9lcyBub3QgY29udGFpbiBwcm9wIHVuZGVyIGtleVwiLCB7IHByb3BLZXksIGl0ZW0gfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxvZ2dlcjMuZGVidWcoXCJDb21wYXJpbmcgQ29uZGl0aW9uXCIsIHsgcHJvcEtleSwgaXRlbVByb3A6IGl0ZW1bcHJvcEtleV0sIHF1ZXJ5Q29uZGl0aW9uIH0pO1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIHN3aXRjaCAocXVlcnlDb25kaXRpb24ub3BlcmF0b3IpIHtcbiAgICBjYXNlIFwiPT1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPT09IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiE9XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldICE9PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI+XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldID4gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPj1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPj0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPFwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA8IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIjw9XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldIDw9IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImluXCI6XG4gICAgICByZXN1bHQgPSBxdWVyeUNvbmRpdGlvbi52YWx1ZS5pbmNsdWRlcyhpdGVtW3Byb3BLZXldKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub3QtaW5cIjpcbiAgICAgIHJlc3VsdCA9ICFxdWVyeUNvbmRpdGlvbi52YWx1ZS5pbmNsdWRlcyhpdGVtW3Byb3BLZXldKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhcnJheS1jb250YWluc1wiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XS5pbmNsdWRlcyhxdWVyeUNvbmRpdGlvbi52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCI6XG4gICAgICByZXN1bHQgPSBxdWVyeUNvbmRpdGlvbi52YWx1ZS5zb21lKCh2YWx1ZSkgPT4gaXRlbVtwcm9wS2V5XS5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgaXNBZ2dRdWVyeU1hdGNoID0gKGFnZ0tleSwgYWdnUXVlcnksIGFnZykgPT4ge1xuICBjb25zdCBhZ2dJdGVtID0gYWdnLml0ZW07XG4gIGxvZ2dlcjMuZGVidWcoXCJDb21wYXJpbmcgQWdnXCIsIHsgYWdnS2V5LCBhZ2dJdGVtLCBhZ2dRdWVyeSB9KTtcbiAgcmV0dXJuIGlzUXVlcnlNYXRjaChhZ2dJdGVtLCBhZ2dRdWVyeSk7XG59O1xudmFyIGlzRXZlbnRRdWVyeU1hdGNoID0gKGV2ZW50S2V5LCBldmVudFF1ZXJ5LCBpdGVtKSA9PiB7XG4gIGlmICghaXRlbS5ldmVudHNbZXZlbnRLZXldKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZG9lcyBub3QgY29udGFpbiBldmVudCB1bmRlciBrZXlcIiwgeyBldmVudEtleSwgZXZlbnRzOiBpdGVtLmV2ZW50cyB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaXRlbUV2ZW50ID0gaXRlbS5ldmVudHNbZXZlbnRLZXldO1xuICAgIGlmIChpdGVtRXZlbnQuYXQgIT09IG51bGwpIHtcbiAgICAgIGlmIChldmVudFF1ZXJ5LnN0YXJ0ICYmICEoZXZlbnRRdWVyeS5zdGFydC5nZXRUaW1lKCkgPD0gaXRlbUV2ZW50LmF0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZGF0ZSBiZWZvcmUgZXZlbnQgc3RhcnQgcXVlcnlcIiwgeyBldmVudFF1ZXJ5LCBpdGVtRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudFF1ZXJ5LmVuZCAmJiAhKGV2ZW50UXVlcnkuZW5kLmdldFRpbWUoKSA+IGl0ZW1FdmVudC5hdC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRhdGUgYWZ0ZXIgZXZlbnQgZW5kIHF1ZXJ5XCIsIHsgZXZlbnRRdWVyeSwgaXRlbUV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGV2ZW50IGRvZXMgY29udGFpbnMgYSBudWxsIGF0XCIsIHsgaXRlbUV2ZW50IH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBpc1F1ZXJ5TWF0Y2ggPSAoaXRlbSwgcXVlcnkpID0+IHtcbiAgbG9nZ2VyMy50cmFjZShcImlzTWF0Y2hcIiwgeyBpdGVtLCBxdWVyeSB9KTtcbiAgaWYgKHF1ZXJ5LnJlZnMgJiYgaXRlbS5yZWZzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkucmVmcykge1xuICAgICAgY29uc3QgcXVlcnlSZWYgPSBxdWVyeS5yZWZzW2tleV07XG4gICAgICBpZiAoIWlzUmVmUXVlcnlNYXRjaChrZXksIHF1ZXJ5UmVmLCBpdGVtLnJlZnMpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKHF1ZXJ5LnJlZnMgJiYgIWl0ZW0ucmVmcykge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJRdWVyeSBjb250YWlucyByZWZzIGJ1dCBpdGVtIGRvZXMgbm90IGhhdmUgcmVmc1wiLCB7IHF1ZXJ5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocXVlcnkuY29tcG91bmRDb25kaXRpb24gJiYgaXRlbSkge1xuICAgIGlmICghaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2gocXVlcnkuY29tcG91bmRDb25kaXRpb24sIGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHF1ZXJ5LmV2ZW50cyAmJiBpdGVtLmV2ZW50cykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LmV2ZW50cykge1xuICAgICAgY29uc3QgcXVlcnlFdmVudCA9IHF1ZXJ5LmV2ZW50c1trZXldO1xuICAgICAgaWYgKCFpc0V2ZW50UXVlcnlNYXRjaChrZXksIHF1ZXJ5RXZlbnQsIGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChxdWVyeS5hZ2dzICYmIGl0ZW0uYWdncykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LmFnZ3MpIHtcbiAgICAgIGNvbnN0IGFnZ1F1ZXJ5ID0gcXVlcnkuYWdnc1trZXldO1xuICAgICAgaWYgKGl0ZW0uYWdnc1trZXldICYmICFpc0FnZ1F1ZXJ5TWF0Y2goa2V5LCBhZ2dRdWVyeSwgaXRlbS5hZ2dzW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChxdWVyeS5hZ2dzICYmICFpdGVtLmFnZ3MpIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiUXVlcnkgY29udGFpbnMgYWdncyBidXQgaXRlbSBkb2VzIG5vdCBoYXZlIGFnZ3NcIiwgeyBxdWVyeSwgaXRlbSB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGFiYnJldlF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IGFiYnJldiA9IFtcIklRXCJdO1xuICBpZiAocXVlcnkpIHtcbiAgICBpZiAocXVlcnkucmVmcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkucmVmcykge1xuICAgICAgICBjb25zdCByZWYgPSBhYmJyZXZSZWYoa2V5LCBxdWVyeS5yZWZzW2tleV0pO1xuICAgICAgICBhYmJyZXYucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IHByb3BzID0gYWJicmV2Q29tcG91bmRDb25kaXRpb24ocXVlcnkuY29tcG91bmRDb25kaXRpb24pO1xuICAgICAgYWJicmV2LnB1c2gocHJvcHMpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuYWdncykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkuYWdncykge1xuICAgICAgICBjb25zdCBhZ2cgPSBhYmJyZXZBZ2coa2V5LCBxdWVyeS5hZ2dzW2tleV0pO1xuICAgICAgICBhYmJyZXYucHVzaChhZ2cpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkuZXZlbnRzKSB7XG4gICAgICBjb25zdCBldmVudHMgPSBgKEUke09iamVjdC5rZXlzKHF1ZXJ5LmV2ZW50cykuam9pbihcIixcIil9KWA7XG4gICAgICBhYmJyZXYucHVzaChldmVudHMpO1xuICAgIH1cbiAgICBpZiAocXVlcnkubGltaXQpIHtcbiAgICAgIGFiYnJldi5wdXNoKGBMJHtxdWVyeS5saW1pdH1gKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5Lm9mZnNldCkge1xuICAgICAgYWJicmV2LnB1c2goYE8ke3F1ZXJ5Lm9mZnNldH1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWJicmV2LnB1c2goXCIoZW1wdHkpXCIpO1xuICB9XG4gIHJldHVybiBhYmJyZXYuam9pbihcIiBcIik7XG59O1xudmFyIGFiYnJldlJlZiA9IChrZXksIHJlZikgPT4ge1xuICBpZiAoaXNQcmlLZXkocmVmKSkge1xuICAgIGNvbnN0IHByaUtleSA9IHJlZjtcbiAgICByZXR1cm4gYFIoJHtrZXl9LCR7cHJpS2V5Lmt0fSwke3ByaUtleS5wa30pYDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb21LZXkgPSByZWY7XG4gICAgcmV0dXJuIGBSKCR7a2V5fSwke0pTT04uc3RyaW5naWZ5KGNvbUtleSl9KWA7XG4gIH1cbn07XG52YXIgYWJicmV2QWdnID0gKGtleSwgYWdnKSA9PiB7XG4gIHJldHVybiBgQSgke2tleX0sJHthYmJyZXZRdWVyeShhZ2cpfSlgO1xufTtcbnZhciBhYmJyZXZDb21wb3VuZENvbmRpdGlvbiA9IChjb21wb3VuZENvbmRpdGlvbikgPT4ge1xuICByZXR1cm4gYENDKCR7Y29tcG91bmRDb25kaXRpb24uY29tcG91bmRUeXBlfSwke2NvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMgPyBjb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zLm1hcChhYmJyZXZDb25kaXRpb24pLmpvaW4oXCIsXCIpIDogXCJObyBDb25kaXRpb25zXCJ9KWA7XG59O1xudmFyIGFiYnJldkNvbmRpdGlvbiA9IChjb25kaXRpb24pID0+IHtcbiAgaWYgKGlzQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICByZXR1cm4gYCgke2NvbmRpdGlvbi5jb2x1bW59LCR7Y29uZGl0aW9uLnZhbHVlfSwke2NvbmRpdGlvbi5vcGVyYXRvcn0pYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWJicmV2Q29tcG91bmRDb25kaXRpb24oY29uZGl0aW9uKTtcbiAgfVxufTtcblxuLy8gc3JjL2l0ZW0vSVV0aWxzLnRzXG52YXIgbG9nZ2VyNCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIklVdGlsc1wiKTtcbnZhciB2YWxpZGF0ZVBLRm9ySXRlbSA9IChpdGVtLCBwa1R5cGUpID0+IHtcbiAgaWYgKCFpdGVtKSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gaXMgdW5kZWZpbmVkXCIsIHsgaXRlbSB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoIWl0ZW0ua2V5KSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gZG9lcyBub3QgaGF2ZSBhIGtleVwiLCB7IGl0ZW0gfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5XCIpO1xuICB9XG4gIGNvbnN0IGtleVR5cGVBcnJheSA9IHRvS2V5VHlwZUFycmF5KGl0ZW0ua2V5KTtcbiAgaWYgKGtleVR5cGVBcnJheVswXSAhPT0gcGtUeXBlKSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIktleSBUeXBlIEFycmF5IE1pc21hdGNoXCIsIHsga2V5VHlwZUFycmF5LCBwa1R5cGUgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgcHJpbWFyeSBrZXkgdHlwZS4gRXhwZWN0ZWQgJHtwa1R5cGV9LCBnb3QgJHtrZXlUeXBlQXJyYXlbMF19YCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xudmFyIHZhbGlkYXRlUEsgPSAoaW5wdXQsIHBrVHlwZSkgPT4ge1xuICBsb2dnZXI0LnRyYWNlKFwiQ2hlY2tpbmcgUmV0dXJuIFR5cGVcIiwgeyBpbnB1dCB9KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gdmFsaWRhdGVQS0Zvckl0ZW0oaXRlbSwgcGtUeXBlKSk7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlUEtGb3JJdGVtKGlucHV0LCBwa1R5cGUpO1xufTtcbnZhciB2YWxpZGF0ZUtleXMgPSAoaXRlbSwga2V5VHlwZXMpID0+IHtcbiAgbG9nZ2VyNC50cmFjZShcIkNoZWNraW5nIFJldHVybiBUeXBlXCIsIHsgaXRlbSB9KTtcbiAgaWYgKCFpdGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidmFsaWRhdGluZyBrZXlzLCBpdGVtIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoIWl0ZW0ua2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidmFsaWRhdGluZyBrZXlzLCBpdGVtIGRvZXMgbm90IGhhdmUgYSBrZXk6IFwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICB9XG4gIGNvbnN0IGtleVR5cGVBcnJheSA9IHRvS2V5VHlwZUFycmF5KGl0ZW0ua2V5KTtcbiAgaWYgKGtleVR5cGVBcnJheS5sZW5ndGggIT09IGtleVR5cGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBrZXlzLiBFeHBlY3RlZCAke2tleVR5cGVzLmxlbmd0aH0sIGJ1dCBnb3QgJHtrZXlUeXBlQXJyYXkubGVuZ3RofWApO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gSlNPTi5zdHJpbmdpZnkoa2V5VHlwZUFycmF5KSA9PT0gSlNPTi5zdHJpbmdpZnkoa2V5VHlwZXMpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIktleSBUeXBlIEFycmF5IE1pc21hdGNoXCIsIHsga2V5VHlwZUFycmF5LCB0aGlzS2V5VHlwZXM6IGtleVR5cGVzIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IGtleSB0eXBlcy4gRXhwZWN0ZWQgWyR7a2V5VHlwZXMuam9pbihcIiwgXCIpfV0sIGJ1dCBnb3QgWyR7a2V5VHlwZUFycmF5LmpvaW4oXCIsIFwiKX1dYCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xudmFyIGlzUHJpSXRlbSA9IChpdGVtKSA9PiB7XG4gIHJldHVybiAhIShpdGVtICYmIGl0ZW0ua2V5ICYmIGlzUHJpS2V5KGl0ZW0ua2V5KSk7XG59O1xudmFyIGlzQ29tSXRlbSA9IChpdGVtKSA9PiB7XG4gIHJldHVybiAhIShpdGVtICYmIGl0ZW0ua2V5ICYmIGlzQ29tS2V5KGl0ZW0ua2V5KSk7XG59O1xuZXhwb3J0IHtcbiAgQUl0ZW1TZXJ2aWNlLFxuICBEaWN0aW9uYXJ5LFxuICBJRmFjdG9yeSxcbiAgSVFGYWN0b3J5LFxuICBhYmJyZXZBZ2csXG4gIGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uLFxuICBhYmJyZXZDb25kaXRpb24sXG4gIGFiYnJldklLLFxuICBhYmJyZXZMS0EsXG4gIGFiYnJldlF1ZXJ5LFxuICBhYmJyZXZSZWYsXG4gIGNQSyxcbiAgY29uc3RydWN0UHJpS2V5LFxuICBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uLFxuICBnZW5lcmF0ZUtleUFycmF5LFxuICBpa1RvTEtBLFxuICBpc0NvbUl0ZW0sXG4gIGlzQ29tS2V5LFxuICBpc0NvbUtleUVxdWFsLFxuICBpc0NvbUtleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNDb25kaXRpb24sXG4gIGlzSXRlbUtleSxcbiAgaXNJdGVtS2V5RXF1YWwsXG4gIGlzSXRlbUtleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNMb2NLZXksXG4gIGlzTG9jS2V5RXF1YWwsXG4gIGlzTG9jS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc1ByaUl0ZW0sXG4gIGlzUHJpS2V5LFxuICBpc1ByaUtleUVxdWFsLFxuICBpc1ByaUtleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNRdWVyeU1hdGNoLFxuICBpc1ZhbGlkQ29tS2V5LFxuICBpc1ZhbGlkSXRlbUtleSxcbiAgaXNWYWxpZExvY0tleSxcbiAgaXNWYWxpZExvY0tleUFycmF5LFxuICBpc1ZhbGlkUHJpS2V5LFxuICBpdGVtS2V5VG9Mb2NLZXlBcnJheSxcbiAgbGthVG9JSyxcbiAgbG9jS2V5QXJyYXlUb0l0ZW1LZXksXG4gIHBhcmFtc1RvUXVlcnksXG4gIHByaW1hcnlUeXBlLFxuICBxdWVyeVRvUGFyYW1zLFxuICB0b0tleVR5cGVBcnJheSxcbiAgdmFsaWRhdGVLZXlzLFxuICB2YWxpZGF0ZVBLXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../fjell-cache/node_modules/@fjell/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-cache/node_modules/@fjell/http-api/dist/index.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/http-api/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   ForbiddenError: () => (/* binding */ ForbiddenError),\n/* harmony export */   GoneError: () => (/* binding */ GoneError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   MethodNotAllowedError: () => (/* binding */ MethodNotAllowedError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),\n/* harmony export */   RequestTimeoutError: () => (/* binding */ RequestTimeoutError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   ServiceUnavailableError: () => (/* binding */ ServiceUnavailableError),\n/* harmony export */   TooManyRequestsError: () => (/* binding */ TooManyRequestsError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   connectMethod: () => (/* binding */ connectMethod),\n/* harmony export */   deleteMethod: () => (/* binding */ deleteMethod2),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getHttp: () => (/* binding */ getHttp),\n/* harmony export */   getHttpApi: () => (/* binding */ getHttpApi),\n/* harmony export */   getHttpFile: () => (/* binding */ getHttpFile),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   optionsMethod: () => (/* binding */ optionsMethod),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   patchMethod: () => (/* binding */ patchMethod),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   postFileMethod: () => (/* binding */ postFileMethod2),\n/* harmony export */   postMethod: () => (/* binding */ postMethod),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   putMethod: () => (/* binding */ putMethod),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   traceMethod: () => (/* binding */ traceMethod),\n/* harmony export */   uploadAsyncMethod: () => (/* binding */ uploadAsyncMethod2)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n// src/errors.ts\nvar APIError = class _APIError extends Error {\n  httpResponseCode;\n  path;\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, options2);\n    this.httpResponseCode = httpResponseCode;\n    this.path = path;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, _APIError);\n    }\n  }\n};\nvar ClientError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar BadRequestError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 400, options2);\n  }\n};\nvar UnauthorizedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 401, options2);\n  }\n};\nvar ForbiddenError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 403, options2);\n  }\n};\nvar NotFoundError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 404, options2);\n  }\n};\nvar MethodNotAllowedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 405, options2);\n  }\n};\nvar RequestTimeoutError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 408, options2);\n  }\n};\nvar ConflictError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 409, options2);\n  }\n};\nvar GoneError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 410, options2);\n  }\n};\nvar TooManyRequestsError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 429, options2);\n  }\n};\nvar ServerError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar InternalServerError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 500, options2);\n  }\n};\nvar NotImplementedError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 501, options2);\n  }\n};\nvar ServiceUnavailableError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 503, options2);\n  }\n};\n\n// src/api/util.ts\nvar getParameterValue = (value) => {\n  if (value) {\n    return value instanceof Date ? value.toISOString() : value.toString();\n  } else {\n    return \"\";\n  }\n};\nvar generateQueryParameters = (params) => Object.keys(params).length > 0 ? \"?\" + Object.keys(params).filter(\n  (key) => params[key] !== void 0 && (typeof params[key] === \"string\" && params[key].length === 0) === false\n).map((key) => {\n  let value;\n  if (params[key] === false) {\n    value = \"false\";\n  } else {\n    value = params[key];\n  }\n  return `${key}=${encodeURIComponent(getParameterValue(value))}`;\n}).join(\"&\") : \"\";\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/http-api\");\nvar logger_default = LibLogger;\n\n// src/api/http.ts\nvar logger = logger_default.get(\"api\", \"http\");\nfunction getHttp(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, body = {}, httpOptions = {}) => {\n    logger.trace(\"http\", { method, path, body, httpOptions });\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const headers = {};\n    if (!options2.skipContentType) {\n      headers[\"Content-Type\"] = options2.contentType;\n    }\n    headers[\"Accept\"] = options2.accept;\n    headers[\"X-Client-Name\"] = config.clientName;\n    const debugOptions = {\n      ...options2,\n      method,\n      path,\n      body\n    };\n    await populateAuthHeader(options2.isAuthenticated, headers);\n    logger.debug(\"http Request: %j, %j\", method, path);\n    const fetchOptions = {\n      method,\n      headers,\n      credentials: options2.requestCredentials\n    };\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      fetchOptions.body = body ? options2.isJsonBody ? JSON.stringify(body) : body : null;\n    }\n    const response = await fetch(\n      `${config.url}${path}${generateQueryParameters(options2.params)}`,\n      fetchOptions\n    );\n    let returnValue;\n    returnValue = await response.text();\n    if (response.status >= 400) {\n      let error;\n      if (response.status >= 500) {\n        if (response.status === 500) {\n          error = new InternalServerError(response.statusText, path, debugOptions);\n        } else if (response.status === 501) {\n          error = new NotImplementedError(response.statusText, path, debugOptions);\n        } else if (response.status === 503) {\n          error = new ServiceUnavailableError(response.statusText, path, debugOptions);\n        } else {\n          error = new ServerError(response.statusText, path, response.status, debugOptions);\n        }\n      } else {\n        if (response.status === 400) {\n          error = new BadRequestError(response.statusText, path, debugOptions);\n        } else if (response.status === 401) {\n          error = new UnauthorizedError(response.statusText, path, debugOptions);\n        } else if (response.status === 403) {\n          error = new ForbiddenError(response.statusText, path, debugOptions);\n        } else if (response.status === 404) {\n          error = new NotFoundError(response.statusText, path, debugOptions);\n        } else if (response.status === 405) {\n          error = new MethodNotAllowedError(response.statusText, path, debugOptions);\n        } else if (response.status === 408) {\n          error = new RequestTimeoutError(response.statusText, path, debugOptions);\n        } else if (response.status === 409) {\n          error = new ConflictError(response.statusText, path, debugOptions);\n        } else if (response.status === 410) {\n          error = new GoneError(response.statusText, path, debugOptions);\n        } else if (response.status === 429) {\n          error = new TooManyRequestsError(response.statusText, path, debugOptions);\n        } else {\n          error = new ClientError(response.statusText, path, response.status, debugOptions);\n        }\n      }\n      throw error;\n    }\n    if (options2.isJson) {\n      try {\n        returnValue = JSON.parse(returnValue);\n        logger.default(\"API RESPONSE JSON: %j\", { status: response.status, body: returnValue });\n      } catch (e) {\n        logger.error(\"Error parsing JSON\", { message: e.message, stack: e.stack, returnValue });\n        throw e;\n      }\n    } else {\n      logger.default(\"API RESPONSE TEXT: %j\", { status: response.status, body: returnValue });\n    }\n    return returnValue;\n  };\n}\n\n// src/api/deleteMethod.ts\nvar logger2 = logger_default.get(\"api\", \"deleteMethod\");\nfunction deleteMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, deleteOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...deleteOptions\n    };\n    logger2.debug(\"httpDelete Request: %j, %j\", path, options2);\n    const s = await http(\n      \"DELETE\",\n      path,\n      body,\n      options2\n    );\n    logger2.default(\"httpDelete Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/getMethod.ts\nvar logger3 = logger_default.get(\"api\", \"getMethod\");\nfunction getMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger3.debug(\"httpGet Request: %j, %j\", path, options2);\n    const s = await http(\"GET\", path, null, options2);\n    logger3.default(\"httpGet Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/postMethod.ts\nvar logger4 = logger_default.get(\"api\", \"postMethod\");\nfunction postMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger4.debug(\"httpPost Request: %j, %j\", path, options2);\n    const s = await http(\"POST\", path, body, options2);\n    logger4.default(\"httpPost Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/putMethod.ts\nvar logger5 = logger_default.get(\"api\", \"putMethod\");\nfunction putMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger5.debug(\"httpPut Request: %j, %j\", path, options2);\n    const s = await http(\"PUT\", path, body, options2);\n    logger5.default(\"httpPut Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/optionsMethod.ts\nvar logger6 = logger_default.get(\"api\", \"optionsMethod\");\nfunction optionsMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger6.debug(\"httpOptions Request: %j, %j\", path, opts);\n    const s = await http(\"OPTIONS\", path, null, opts);\n    logger6.default(\"httpOptions Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/connectMethod.ts\nvar logger7 = logger_default.get(\"api\", \"connectMethod\");\nfunction connectMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger7.debug(\"httpConnect Request: %j, %j\", path, opts);\n    const s = await http(\"CONNECT\", path, null, opts);\n    logger7.default(\"httpConnect Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/traceMethod.ts\nvar logger8 = logger_default.get(\"api\", \"traceMethod\");\nfunction traceMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger8.debug(\"httpTrace Request: %j, %j\", path, opts);\n    const s = await http(\"TRACE\", path, null, opts);\n    logger8.default(\"httpTrace Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/patchMethod.ts\nvar logger9 = logger_default.get(\"api\", \"patchMethod\");\nfunction patchMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger9.debug(\"httpPatch Request: %j, %j\", path, opts);\n    const s = await http(\"PATCH\", path, body, opts);\n    logger9.default(\"httpPatch Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/httpFile.ts\nfunction getHttpFile(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, file, httpFileOptions = {}, body = {}, headers = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpFileOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    try {\n      headers[\"Accept\"] = options2.accept;\n      headers[\"X-Client-Name\"] = config.clientName;\n      await populateAuthHeader(options2.isAuthenticated, headers);\n      const bodyData = new FormData();\n      Object.keys(body).forEach((key) => {\n        bodyData.set(key, body[key]);\n      });\n      bodyData.set(\"file\", new Blob([new Uint8Array(file.buffer)]), file.bufferName);\n      const response = await fetch(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        {\n          method,\n          headers,\n          body: bodyData,\n          credentials: options2.requestCredentials\n        }\n      );\n      const returnValue = options2.isJson ? await response.json() : await response.text();\n      if (response.status >= 400) {\n        console.error(\n          `Error executing API request httpFile, status: ${response.status}: ` + JSON.stringify({ method, path, params: options2.params, body, returnValue })\n        );\n        throw new Error(options2.isJson ? returnValue.message : returnValue);\n      }\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api/postFileMethod.ts\nvar logger10 = logger_default.get(\"api\", \"postFileMethod\");\nfunction postFileMethod(apiParams) {\n  const httpFile = getHttpFile(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, headers = {}, file, postFileOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...postFileOptions\n    };\n    logger10.debug(\"httpPostFileData Request: %s, %j\", path, options2);\n    logger10.default(\"httpPostFileData Request Body: %j\", body);\n    const s = await httpFile(\n      \"POST\",\n      path,\n      file,\n      options2,\n      body,\n      headers\n    );\n    logger10.default(\"httpPostFileData Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/uploadAsyncMethod.ts\nfunction uploadAsyncMethod(apiParams) {\n  const getOptionDefaults = () => ({\n    method: \"POST\",\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    fieldName: \"file\",\n    headers: {}\n  });\n  return async (path, uri, uploadAsyncOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(),\n      ...uploadAsyncOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const uploadAsyncFile = apiParams.uploadAsyncFile;\n    try {\n      options2.headers[\"Accept\"] = options2.accept;\n      await populateAuthHeader(options2.isAuthenticated, options2.headers);\n      const result = await uploadAsyncFile(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        uri,\n        options2.method,\n        \"multipart\",\n        options2.fieldName,\n        options2.headers\n      );\n      const returnValue = options2.isJson ? JSON.parse(result.body) : result.body;\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${options2.method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api.ts\nvar getHttpApi = (apiParams) => {\n  const httpDelete = deleteMethod(apiParams);\n  const httpGet = getMethod(apiParams);\n  const httpPost = postMethod(apiParams);\n  const httpPut = putMethod(apiParams);\n  const httpOptions = optionsMethod(apiParams);\n  const httpConnect = connectMethod(apiParams);\n  const httpTrace = traceMethod(apiParams);\n  const httpPatch = patchMethod(apiParams);\n  const httpPostFile = postFileMethod(apiParams);\n  const uploadAsync = uploadAsyncMethod(apiParams);\n  return {\n    httpDelete,\n    httpGet,\n    httpPut,\n    httpPost,\n    httpPostFile,\n    uploadAsync,\n    httpOptions,\n    httpConnect,\n    httpTrace,\n    httpPatch\n  };\n};\n\n// src/simple-api.ts\nvar defaultApiParams = {\n  config: {\n    url: \"\",\n    requestCredentials: \"same-origin\",\n    clientName: \"fjell-http-api-examples\"\n  },\n  populateAuthHeader: async (isAuthenticated, headers) => {\n    if (isAuthenticated) {\n      headers[\"Authorization\"] = \"Bearer example-token\";\n    }\n  },\n  uploadAsyncFile: async () => {\n    return {\n      headers: {},\n      status: 200,\n      mimeType: \"application/json\",\n      body: JSON.stringify({ success: true })\n    };\n  }\n};\nvar getImpl = getMethod(defaultApiParams);\nvar postImpl = postMethod(defaultApiParams);\nvar putImpl = putMethod(defaultApiParams);\nvar optionsImpl = optionsMethod(defaultApiParams);\nvar connectImpl = connectMethod(defaultApiParams);\nvar traceImpl = traceMethod(defaultApiParams);\nvar patchImpl = patchMethod(defaultApiParams);\nvar deleteImpl = deleteMethod(defaultApiParams);\nvar postFileImpl = postFileMethod(defaultApiParams);\nvar uploadAsyncImpl = uploadAsyncMethod(defaultApiParams);\nvar get = (path, options2) => {\n  return getImpl(path, options2);\n};\nvar post = (path, body, options2) => {\n  return postImpl(path, body, options2);\n};\nvar put = (path, body, options2) => {\n  return putImpl(path, body, options2);\n};\nvar deleteMethod2 = (path, body, options2) => {\n  return deleteImpl(path, body, options2);\n};\nvar options = (path, opts) => {\n  return optionsImpl(path, opts);\n};\nvar connect = (path, opts) => {\n  return connectImpl(path, opts);\n};\nvar trace = (path, opts) => {\n  return traceImpl(path, opts);\n};\nvar patch = (path, body, opts) => {\n  return patchImpl(path, body, opts);\n};\nvar postFileMethod2 = (path, file, options2) => {\n  const fileBuffer = {\n    buffer: Buffer.from([]),\n    // Placeholder - would need proper File reading in browser\n    bufferName: file.name\n  };\n  return postFileImpl(path, {}, {}, fileBuffer, options2);\n};\nvar uploadAsyncMethod2 = (path, uri, options2) => {\n  return uploadAsyncImpl(path, uri, options2);\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9odHRwLWFwaS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLElBQUksR0FBRyw2Q0FBNkM7QUFDaEUsQ0FBQzs7QUFFRDtBQUNxQztBQUNyQyxnQkFBZ0IsZ0VBQWlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVDQUF1QyxrQkFBa0I7QUFDekQsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXLEVBQUUsS0FBSyxFQUFFLHlDQUF5QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNENBQTRDO0FBQzlGLFFBQVE7QUFDUiw2Q0FBNkMsaURBQWlEO0FBQzlGO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0RBQWdELDRDQUE0QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0RBQXdELFdBQVcsY0FBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsV0FBVyxXQUFXLEVBQUUsS0FBSyxFQUFFLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0IsdUJBQXVCLDBEQUEwRDtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRDQUE0QyxRQUFRLEVBQUUsTUFBTSxFQUFFO0FBQzlEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQixjQUFjLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVyxFQUFFLEtBQUssRUFBRSx5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRDQUE0QyxpQkFBaUIsRUFBRSxNQUFNLEVBQUU7QUFDdkU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBcUNFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9odHRwLWFwaS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMudHNcbnZhciBBUElFcnJvciA9IGNsYXNzIF9BUElFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgaHR0cFJlc3BvbnNlQ29kZTtcbiAgcGF0aDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgaHR0cFJlc3BvbnNlQ29kZSwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zMik7XG4gICAgdGhpcy5odHRwUmVzcG9uc2VDb2RlID0gaHR0cFJlc3BvbnNlQ29kZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgX0FQSUVycm9yKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQ2xpZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgaHR0cFJlc3BvbnNlQ29kZSwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgQmFkUmVxdWVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwMCwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIFVuYXV0aG9yaXplZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwMSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIEZvcmJpZGRlbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwMywgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIE5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA0LCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgTWV0aG9kTm90QWxsb3dlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwNSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIFJlcXVlc3RUaW1lb3V0RXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA4LCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgQ29uZmxpY3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDksIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBHb25lRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDEwLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgVG9vTWFueVJlcXVlc3RzRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDI5LCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgU2VydmVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgaHR0cFJlc3BvbnNlQ29kZSwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgSW50ZXJuYWxTZXJ2ZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIDUwMCwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIE5vdEltcGxlbWVudGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIFNlcnZlckVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCA1MDEsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBTZXJ2aWNlVW5hdmFpbGFibGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIDUwMywgb3B0aW9uczIpO1xuICB9XG59O1xuXG4vLyBzcmMvYXBpL3V0aWwudHNcbnZhciBnZXRQYXJhbWV0ZXJWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gdmFsdWUudG9JU09TdHJpbmcoKSA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn07XG52YXIgZ2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMgPSAocGFyYW1zKSA9PiBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA+IDAgPyBcIj9cIiArIE9iamVjdC5rZXlzKHBhcmFtcykuZmlsdGVyKFxuICAoa2V5KSA9PiBwYXJhbXNba2V5XSAhPT0gdm9pZCAwICYmICh0eXBlb2YgcGFyYW1zW2tleV0gPT09IFwic3RyaW5nXCIgJiYgcGFyYW1zW2tleV0ubGVuZ3RoID09PSAwKSA9PT0gZmFsc2VcbikubWFwKChrZXkpID0+IHtcbiAgbGV0IHZhbHVlO1xuICBpZiAocGFyYW1zW2tleV0gPT09IGZhbHNlKSB7XG4gICAgdmFsdWUgPSBcImZhbHNlXCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgfVxuICByZXR1cm4gYCR7a2V5fT0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbWV0ZXJWYWx1ZSh2YWx1ZSkpfWA7XG59KS5qb2luKFwiJlwiKSA6IFwiXCI7XG5cbi8vIHNyYy9sb2dnZXIudHNcbmltcG9ydCBMb2dnaW5nIGZyb20gXCJAZmplbGwvbG9nZ2luZ1wiO1xudmFyIExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKFwiQGZqZWxsL2h0dHAtYXBpXCIpO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTGliTG9nZ2VyO1xuXG4vLyBzcmMvYXBpL2h0dHAudHNcbnZhciBsb2dnZXIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJodHRwXCIpO1xuZnVuY3Rpb24gZ2V0SHR0cChhcGlQYXJhbXMpIHtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKG1ldGhvZCwgcGF0aCwgYm9keSA9IHt9LCBodHRwT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiaHR0cFwiLCB7IG1ldGhvZCwgcGF0aCwgYm9keSwgaHR0cE9wdGlvbnMgfSk7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uaHR0cE9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IGFwaVBhcmFtcy5jb25maWc7XG4gICAgY29uc3QgcG9wdWxhdGVBdXRoSGVhZGVyID0gYXBpUGFyYW1zLnBvcHVsYXRlQXV0aEhlYWRlcjtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKCFvcHRpb25zMi5za2lwQ29udGVudFR5cGUpIHtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBvcHRpb25zMi5jb250ZW50VHlwZTtcbiAgICB9XG4gICAgaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMyLmFjY2VwdDtcbiAgICBoZWFkZXJzW1wiWC1DbGllbnQtTmFtZVwiXSA9IGNvbmZpZy5jbGllbnROYW1lO1xuICAgIGNvbnN0IGRlYnVnT3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgbWV0aG9kLFxuICAgICAgcGF0aCxcbiAgICAgIGJvZHlcbiAgICB9O1xuICAgIGF3YWl0IHBvcHVsYXRlQXV0aEhlYWRlcihvcHRpb25zMi5pc0F1dGhlbnRpY2F0ZWQsIGhlYWRlcnMpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcImh0dHAgUmVxdWVzdDogJWosICVqXCIsIG1ldGhvZCwgcGF0aCk7XG4gICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zMi5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgICB9O1xuICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBib2R5ID8gb3B0aW9uczIuaXNKc29uQm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogYm9keSA6IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMyLnBhcmFtcyl9YCxcbiAgICAgIGZldGNoT3B0aW9uc1xuICAgICk7XG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIHJldHVyblZhbHVlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICBsZXQgZXJyb3I7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDEpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDMpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBTZXJ2aWNlVW5hdmFpbGFibGVFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IFNlcnZlckVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIHJlc3BvbnNlLnN0YXR1cywgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgQmFkUmVxdWVzdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBVbmF1dGhvcml6ZWRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRm9yYmlkZGVuRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IE5vdEZvdW5kRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IE1ldGhvZE5vdEFsbG93ZWRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA4KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgUmVxdWVzdFRpbWVvdXRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgQ29uZmxpY3RFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDEwKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgR29uZUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBUb29NYW55UmVxdWVzdHNFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IENsaWVudEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIHJlc3BvbnNlLnN0YXR1cywgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5pc0pzb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gSlNPTi5wYXJzZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgIGxvZ2dlci5kZWZhdWx0KFwiQVBJIFJFU1BPTlNFIEpTT046ICVqXCIsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGJvZHk6IHJldHVyblZhbHVlIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBwYXJzaW5nIEpTT05cIiwgeyBtZXNzYWdlOiBlLm1lc3NhZ2UsIHN0YWNrOiBlLnN0YWNrLCByZXR1cm5WYWx1ZSB9KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlZmF1bHQoXCJBUEkgUkVTUE9OU0UgVEVYVDogJWpcIiwgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgYm9keTogcmV0dXJuVmFsdWUgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9kZWxldGVNZXRob2QudHNcbnZhciBsb2dnZXIyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwiZGVsZXRlTWV0aG9kXCIpO1xuZnVuY3Rpb24gZGVsZXRlTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgYm9keSA9IHt9LCBkZWxldGVPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5kZWxldGVPcHRpb25zXG4gICAgfTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiaHR0cERlbGV0ZSBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9uczIpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFxuICAgICAgXCJERUxFVEVcIixcbiAgICAgIHBhdGgsXG4gICAgICBib2R5LFxuICAgICAgb3B0aW9uczJcbiAgICApO1xuICAgIGxvZ2dlcjIuZGVmYXVsdChcImh0dHBEZWxldGUgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9nZXRNZXRob2QudHNcbnZhciBsb2dnZXIzID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwiZ2V0TWV0aG9kXCIpO1xuZnVuY3Rpb24gZ2V0TWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgZ2V0T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uZ2V0T3B0aW9uc1xuICAgIH07XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcImh0dHBHZXQgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdGlvbnMyKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcIkdFVFwiLCBwYXRoLCBudWxsLCBvcHRpb25zMik7XG4gICAgbG9nZ2VyMy5kZWZhdWx0KFwiaHR0cEdldCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3Bvc3RNZXRob2QudHNcbnZhciBsb2dnZXI0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwicG9zdE1ldGhvZFwiKTtcbmZ1bmN0aW9uIHBvc3RNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBib2R5ID0ge30sIGdldE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmdldE9wdGlvbnNcbiAgICB9O1xuICAgIGxvZ2dlcjQuZGVidWcoXCJodHRwUG9zdCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9uczIpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiUE9TVFwiLCBwYXRoLCBib2R5LCBvcHRpb25zMik7XG4gICAgbG9nZ2VyNC5kZWZhdWx0KFwiaHR0cFBvc3QgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9wdXRNZXRob2QudHNcbnZhciBsb2dnZXI1ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwicHV0TWV0aG9kXCIpO1xuZnVuY3Rpb24gcHV0TWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgYm9keSA9IHt9LCBnZXRPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5nZXRPcHRpb25zXG4gICAgfTtcbiAgICBsb2dnZXI1LmRlYnVnKFwiaHR0cFB1dCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9uczIpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiUFVUXCIsIHBhdGgsIGJvZHksIG9wdGlvbnMyKTtcbiAgICBsb2dnZXI1LmRlZmF1bHQoXCJodHRwUHV0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvb3B0aW9uc01ldGhvZC50c1xudmFyIGxvZ2dlcjYgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJvcHRpb25zTWV0aG9kXCIpO1xuZnVuY3Rpb24gb3B0aW9uc01ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIG9wdGlvbnMyID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLm9wdGlvbnMyXG4gICAgfTtcbiAgICBsb2dnZXI2LmRlYnVnKFwiaHR0cE9wdGlvbnMgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiT1BUSU9OU1wiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXI2LmRlZmF1bHQoXCJodHRwT3B0aW9ucyBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL2Nvbm5lY3RNZXRob2QudHNcbnZhciBsb2dnZXI3ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwiY29ubmVjdE1ldGhvZFwiKTtcbmZ1bmN0aW9uIGNvbm5lY3RNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBvcHRpb25zMiA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH07XG4gICAgbG9nZ2VyNy5kZWJ1ZyhcImh0dHBDb25uZWN0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRzKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcIkNPTk5FQ1RcIiwgcGF0aCwgbnVsbCwgb3B0cyk7XG4gICAgbG9nZ2VyNy5kZWZhdWx0KFwiaHR0cENvbm5lY3QgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS90cmFjZU1ldGhvZC50c1xudmFyIGxvZ2dlcjggPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJ0cmFjZU1ldGhvZFwiKTtcbmZ1bmN0aW9uIHRyYWNlTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgb3B0aW9uczIgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9O1xuICAgIGxvZ2dlcjguZGVidWcoXCJodHRwVHJhY2UgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiVFJBQ0VcIiwgcGF0aCwgbnVsbCwgb3B0cyk7XG4gICAgbG9nZ2VyOC5kZWZhdWx0KFwiaHR0cFRyYWNlIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvcGF0Y2hNZXRob2QudHNcbnZhciBsb2dnZXI5ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwicGF0Y2hNZXRob2RcIik7XG5mdW5jdGlvbiBwYXRjaE1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIGJvZHkgPSB7fSwgb3B0aW9uczIgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9O1xuICAgIGxvZ2dlcjkuZGVidWcoXCJodHRwUGF0Y2ggUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiUEFUQ0hcIiwgcGF0aCwgYm9keSwgb3B0cyk7XG4gICAgbG9nZ2VyOS5kZWZhdWx0KFwiaHR0cFBhdGNoIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvaHR0cEZpbGUudHNcbmZ1bmN0aW9uIGdldEh0dHBGaWxlKGFwaVBhcmFtcykge1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKG1ldGhvZCwgcGF0aCwgZmlsZSwgaHR0cEZpbGVPcHRpb25zID0ge30sIGJvZHkgPSB7fSwgaGVhZGVycyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uaHR0cEZpbGVPcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBhcGlQYXJhbXMuY29uZmlnO1xuICAgIGNvbnN0IHBvcHVsYXRlQXV0aEhlYWRlciA9IGFwaVBhcmFtcy5wb3B1bGF0ZUF1dGhIZWFkZXI7XG4gICAgdHJ5IHtcbiAgICAgIGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBvcHRpb25zMi5hY2NlcHQ7XG4gICAgICBoZWFkZXJzW1wiWC1DbGllbnQtTmFtZVwiXSA9IGNvbmZpZy5jbGllbnROYW1lO1xuICAgICAgYXdhaXQgcG9wdWxhdGVBdXRoSGVhZGVyKG9wdGlvbnMyLmlzQXV0aGVudGljYXRlZCwgaGVhZGVycyk7XG4gICAgICBjb25zdCBib2R5RGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgT2JqZWN0LmtleXMoYm9keSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGJvZHlEYXRhLnNldChrZXksIGJvZHlba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIGJvZHlEYXRhLnNldChcImZpbGVcIiwgbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KGZpbGUuYnVmZmVyKV0pLCBmaWxlLmJ1ZmZlck5hbWUpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7Y29uZmlnLnVybH0ke3BhdGh9JHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhvcHRpb25zMi5wYXJhbXMpfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5OiBib2R5RGF0YSxcbiAgICAgICAgICBjcmVkZW50aWFsczogb3B0aW9uczIucmVxdWVzdENyZWRlbnRpYWxzXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9wdGlvbnMyLmlzSnNvbiA/IGF3YWl0IHJlc3BvbnNlLmpzb24oKSA6IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdCBodHRwRmlsZSwgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c306IGAgKyBKU09OLnN0cmluZ2lmeSh7IG1ldGhvZCwgcGF0aCwgcGFyYW1zOiBvcHRpb25zMi5wYXJhbXMsIGJvZHksIHJldHVyblZhbHVlIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zMi5pc0pzb24gPyByZXR1cm5WYWx1ZS5tZXNzYWdlIDogcmV0dXJuVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBFcnJvciBleGVjdXRpbmcgQVBJIHJlcXVlc3QgaHR0cCAke21ldGhvZH0gJHtwYXRofSAke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKFxuICAgICAgICAgIG9wdGlvbnMyLnBhcmFtc1xuICAgICAgICApfWAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9wb3N0RmlsZU1ldGhvZC50c1xudmFyIGxvZ2dlcjEwID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwicG9zdEZpbGVNZXRob2RcIik7XG5mdW5jdGlvbiBwb3N0RmlsZU1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cEZpbGUgPSBnZXRIdHRwRmlsZShhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIGJvZHkgPSB7fSwgaGVhZGVycyA9IHt9LCBmaWxlLCBwb3N0RmlsZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLnBvc3RGaWxlT3B0aW9uc1xuICAgIH07XG4gICAgbG9nZ2VyMTAuZGVidWcoXCJodHRwUG9zdEZpbGVEYXRhIFJlcXVlc3Q6ICVzLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgbG9nZ2VyMTAuZGVmYXVsdChcImh0dHBQb3N0RmlsZURhdGEgUmVxdWVzdCBCb2R5OiAlalwiLCBib2R5KTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cEZpbGUoXG4gICAgICBcIlBPU1RcIixcbiAgICAgIHBhdGgsXG4gICAgICBmaWxlLFxuICAgICAgb3B0aW9uczIsXG4gICAgICBib2R5LFxuICAgICAgaGVhZGVyc1xuICAgICk7XG4gICAgbG9nZ2VyMTAuZGVmYXVsdChcImh0dHBQb3N0RmlsZURhdGEgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS91cGxvYWRBc3luY01ldGhvZC50c1xuZnVuY3Rpb24gdXBsb2FkQXN5bmNNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKCkgPT4gKHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIGZpZWxkTmFtZTogXCJmaWxlXCIsXG4gICAgaGVhZGVyczoge31cbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgdXJpLCB1cGxvYWRBc3luY09wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoKSxcbiAgICAgIC4uLnVwbG9hZEFzeW5jT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgY29uZmlnID0gYXBpUGFyYW1zLmNvbmZpZztcbiAgICBjb25zdCBwb3B1bGF0ZUF1dGhIZWFkZXIgPSBhcGlQYXJhbXMucG9wdWxhdGVBdXRoSGVhZGVyO1xuICAgIGNvbnN0IHVwbG9hZEFzeW5jRmlsZSA9IGFwaVBhcmFtcy51cGxvYWRBc3luY0ZpbGU7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMyLmhlYWRlcnNbXCJBY2NlcHRcIl0gPSBvcHRpb25zMi5hY2NlcHQ7XG4gICAgICBhd2FpdCBwb3B1bGF0ZUF1dGhIZWFkZXIob3B0aW9uczIuaXNBdXRoZW50aWNhdGVkLCBvcHRpb25zMi5oZWFkZXJzKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZEFzeW5jRmlsZShcbiAgICAgICAgYCR7Y29uZmlnLnVybH0ke3BhdGh9JHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhvcHRpb25zMi5wYXJhbXMpfWAsXG4gICAgICAgIHVyaSxcbiAgICAgICAgb3B0aW9uczIubWV0aG9kLFxuICAgICAgICBcIm11bHRpcGFydFwiLFxuICAgICAgICBvcHRpb25zMi5maWVsZE5hbWUsXG4gICAgICAgIG9wdGlvbnMyLmhlYWRlcnNcbiAgICAgICk7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9wdGlvbnMyLmlzSnNvbiA/IEpTT04ucGFyc2UocmVzdWx0LmJvZHkpIDogcmVzdWx0LmJvZHk7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdCBodHRwICR7b3B0aW9uczIubWV0aG9kfSAke3BhdGh9ICR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMoXG4gICAgICAgICAgb3B0aW9uczIucGFyYW1zXG4gICAgICAgICl9YCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYXBpLnRzXG52YXIgZ2V0SHR0cEFwaSA9IChhcGlQYXJhbXMpID0+IHtcbiAgY29uc3QgaHR0cERlbGV0ZSA9IGRlbGV0ZU1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwR2V0ID0gZ2V0TWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBQb3N0ID0gcG9zdE1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwUHV0ID0gcHV0TWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBPcHRpb25zID0gb3B0aW9uc01ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwQ29ubmVjdCA9IGNvbm5lY3RNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cFRyYWNlID0gdHJhY2VNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cFBhdGNoID0gcGF0Y2hNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cFBvc3RGaWxlID0gcG9zdEZpbGVNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgdXBsb2FkQXN5bmMgPSB1cGxvYWRBc3luY01ldGhvZChhcGlQYXJhbXMpO1xuICByZXR1cm4ge1xuICAgIGh0dHBEZWxldGUsXG4gICAgaHR0cEdldCxcbiAgICBodHRwUHV0LFxuICAgIGh0dHBQb3N0LFxuICAgIGh0dHBQb3N0RmlsZSxcbiAgICB1cGxvYWRBc3luYyxcbiAgICBodHRwT3B0aW9ucyxcbiAgICBodHRwQ29ubmVjdCxcbiAgICBodHRwVHJhY2UsXG4gICAgaHR0cFBhdGNoXG4gIH07XG59O1xuXG4vLyBzcmMvc2ltcGxlLWFwaS50c1xudmFyIGRlZmF1bHRBcGlQYXJhbXMgPSB7XG4gIGNvbmZpZzoge1xuICAgIHVybDogXCJcIixcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICBjbGllbnROYW1lOiBcImZqZWxsLWh0dHAtYXBpLWV4YW1wbGVzXCJcbiAgfSxcbiAgcG9wdWxhdGVBdXRoSGVhZGVyOiBhc3luYyAoaXNBdXRoZW50aWNhdGVkLCBoZWFkZXJzKSA9PiB7XG4gICAgaWYgKGlzQXV0aGVudGljYXRlZCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBleGFtcGxlLXRva2VuXCI7XG4gICAgfVxuICB9LFxuICB1cGxvYWRBc3luY0ZpbGU6IGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyczoge30sXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgIH07XG4gIH1cbn07XG52YXIgZ2V0SW1wbCA9IGdldE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBwb3N0SW1wbCA9IHBvc3RNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgcHV0SW1wbCA9IHB1dE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBvcHRpb25zSW1wbCA9IG9wdGlvbnNNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgY29ubmVjdEltcGwgPSBjb25uZWN0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIHRyYWNlSW1wbCA9IHRyYWNlTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIHBhdGNoSW1wbCA9IHBhdGNoTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIGRlbGV0ZUltcGwgPSBkZWxldGVNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgcG9zdEZpbGVJbXBsID0gcG9zdEZpbGVNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgdXBsb2FkQXN5bmNJbXBsID0gdXBsb2FkQXN5bmNNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgZ2V0ID0gKHBhdGgsIG9wdGlvbnMyKSA9PiB7XG4gIHJldHVybiBnZXRJbXBsKHBhdGgsIG9wdGlvbnMyKTtcbn07XG52YXIgcG9zdCA9IChwYXRoLCBib2R5LCBvcHRpb25zMikgPT4ge1xuICByZXR1cm4gcG9zdEltcGwocGF0aCwgYm9keSwgb3B0aW9uczIpO1xufTtcbnZhciBwdXQgPSAocGF0aCwgYm9keSwgb3B0aW9uczIpID0+IHtcbiAgcmV0dXJuIHB1dEltcGwocGF0aCwgYm9keSwgb3B0aW9uczIpO1xufTtcbnZhciBkZWxldGVNZXRob2QyID0gKHBhdGgsIGJvZHksIG9wdGlvbnMyKSA9PiB7XG4gIHJldHVybiBkZWxldGVJbXBsKHBhdGgsIGJvZHksIG9wdGlvbnMyKTtcbn07XG52YXIgb3B0aW9ucyA9IChwYXRoLCBvcHRzKSA9PiB7XG4gIHJldHVybiBvcHRpb25zSW1wbChwYXRoLCBvcHRzKTtcbn07XG52YXIgY29ubmVjdCA9IChwYXRoLCBvcHRzKSA9PiB7XG4gIHJldHVybiBjb25uZWN0SW1wbChwYXRoLCBvcHRzKTtcbn07XG52YXIgdHJhY2UgPSAocGF0aCwgb3B0cykgPT4ge1xuICByZXR1cm4gdHJhY2VJbXBsKHBhdGgsIG9wdHMpO1xufTtcbnZhciBwYXRjaCA9IChwYXRoLCBib2R5LCBvcHRzKSA9PiB7XG4gIHJldHVybiBwYXRjaEltcGwocGF0aCwgYm9keSwgb3B0cyk7XG59O1xudmFyIHBvc3RGaWxlTWV0aG9kMiA9IChwYXRoLCBmaWxlLCBvcHRpb25zMikgPT4ge1xuICBjb25zdCBmaWxlQnVmZmVyID0ge1xuICAgIGJ1ZmZlcjogQnVmZmVyLmZyb20oW10pLFxuICAgIC8vIFBsYWNlaG9sZGVyIC0gd291bGQgbmVlZCBwcm9wZXIgRmlsZSByZWFkaW5nIGluIGJyb3dzZXJcbiAgICBidWZmZXJOYW1lOiBmaWxlLm5hbWVcbiAgfTtcbiAgcmV0dXJuIHBvc3RGaWxlSW1wbChwYXRoLCB7fSwge30sIGZpbGVCdWZmZXIsIG9wdGlvbnMyKTtcbn07XG52YXIgdXBsb2FkQXN5bmNNZXRob2QyID0gKHBhdGgsIHVyaSwgb3B0aW9uczIpID0+IHtcbiAgcmV0dXJuIHVwbG9hZEFzeW5jSW1wbChwYXRoLCB1cmksIG9wdGlvbnMyKTtcbn07XG5leHBvcnQge1xuICBBUElFcnJvcixcbiAgQmFkUmVxdWVzdEVycm9yLFxuICBDbGllbnRFcnJvcixcbiAgQ29uZmxpY3RFcnJvcixcbiAgRm9yYmlkZGVuRXJyb3IsXG4gIEdvbmVFcnJvcixcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgTWV0aG9kTm90QWxsb3dlZEVycm9yLFxuICBOb3RGb3VuZEVycm9yLFxuICBOb3RJbXBsZW1lbnRlZEVycm9yLFxuICBSZXF1ZXN0VGltZW91dEVycm9yLFxuICBTZXJ2ZXJFcnJvcixcbiAgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IsXG4gIFRvb01hbnlSZXF1ZXN0c0Vycm9yLFxuICBVbmF1dGhvcml6ZWRFcnJvcixcbiAgY29ubmVjdCxcbiAgY29ubmVjdE1ldGhvZCxcbiAgZGVsZXRlTWV0aG9kMiBhcyBkZWxldGVNZXRob2QsXG4gIGdldCxcbiAgZ2V0SHR0cCxcbiAgZ2V0SHR0cEFwaSxcbiAgZ2V0SHR0cEZpbGUsXG4gIGdldE1ldGhvZCxcbiAgb3B0aW9ucyxcbiAgb3B0aW9uc01ldGhvZCxcbiAgcGF0Y2gsXG4gIHBhdGNoTWV0aG9kLFxuICBwb3N0LFxuICBwb3N0RmlsZU1ldGhvZDIgYXMgcG9zdEZpbGVNZXRob2QsXG4gIHBvc3RNZXRob2QsXG4gIHB1dCxcbiAgcHV0TWV0aG9kLFxuICB0cmFjZSxcbiAgdHJhY2VNZXRob2QsXG4gIHVwbG9hZEFzeW5jTWV0aG9kMiBhcyB1cGxvYWRBc3luY01ldGhvZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../fjell-cache/node_modules/@fjell/http-api/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-cache/node_modules/@fjell/logging/dist/index.js":
/*!****************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/logging/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9sb2dnaW5nL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxLQUFLO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQixVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBTXBCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9sb2dnaW5nL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL0xvZ0Zvcm1hdC50c1xudmFyIExvZ0Zvcm1hdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dGb3JtYXRfZXhwb3J0cywge1xuICBMb2dGb3JtYXRzOiAoKSA9PiBMb2dGb3JtYXRzLFxuICBTVFJVQ1RVUkVEOiAoKSA9PiBTVFJVQ1RVUkVELFxuICBURVhUOiAoKSA9PiBURVhULFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZ1xufSk7XG52YXIgVEVYVCA9IHtcbiAgbmFtZTogXCJURVhUXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlRleHQgZm9ybWF0XCJcbn07XG52YXIgU1RSVUNUVVJFRCA9IHtcbiAgbmFtZTogXCJTVFJVQ1RVUkVEXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZWQgZm9ybWF0XCJcbn07XG52YXIgTG9nRm9ybWF0cyA9IFtcbiAgVEVYVCxcbiAgU1RSVUNUVVJFRFxuXTtcbnZhciBnZXRDb25maWcgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dGb3JtYXRzLmZpbmQoKGNvbmZpZzIpID0+IGNvbmZpZzIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBGb3JtYXQgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvTG9nTGV2ZWwudHNcbnZhciBMb2dMZXZlbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dMZXZlbF9leHBvcnRzLCB7XG4gIEFMRVJUOiAoKSA9PiBBTEVSVCxcbiAgQ1JJVElDQUw6ICgpID0+IENSSVRJQ0FMLFxuICBERUJVRzogKCkgPT4gREVCVUcsXG4gIERFRkFVTFQ6ICgpID0+IERFRkFVTFQsXG4gIEVNRVJHRU5DWTogKCkgPT4gRU1FUkdFTkNZLFxuICBFUlJPUjogKCkgPT4gRVJST1IsXG4gIElORk86ICgpID0+IElORk8sXG4gIExvZ0xldmVsczogKCkgPT4gTG9nTGV2ZWxzLFxuICBOT1RJQ0U6ICgpID0+IE5PVElDRSxcbiAgVFJBQ0U6ICgpID0+IFRSQUNFLFxuICBXQVJOSU5HOiAoKSA9PiBXQVJOSU5HLFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZzJcbn0pO1xudmFyIEVNRVJHRU5DWSA9IHtcbiAgbmFtZTogXCJFTUVSR0VOQ1lcIixcbiAgdmFsdWU6IDBcbn07XG52YXIgQUxFUlQgPSB7XG4gIG5hbWU6IFwiQUxFUlRcIixcbiAgdmFsdWU6IDFcbn07XG52YXIgQ1JJVElDQUwgPSB7XG4gIG5hbWU6IFwiQ1JJVElDQUxcIixcbiAgdmFsdWU6IDJcbn07XG52YXIgRVJST1IgPSB7XG4gIG5hbWU6IFwiRVJST1JcIixcbiAgdmFsdWU6IDNcbn07XG52YXIgV0FSTklORyA9IHtcbiAgbmFtZTogXCJXQVJOSU5HXCIsXG4gIHZhbHVlOiA0XG59O1xudmFyIE5PVElDRSA9IHtcbiAgbmFtZTogXCJOT1RJQ0VcIixcbiAgdmFsdWU6IDVcbn07XG52YXIgSU5GTyA9IHtcbiAgbmFtZTogXCJJTkZPXCIsXG4gIHZhbHVlOiA2XG59O1xudmFyIERFQlVHID0ge1xuICBuYW1lOiBcIkRFQlVHXCIsXG4gIHZhbHVlOiA3XG59O1xudmFyIFRSQUNFID0ge1xuICBuYW1lOiBcIlRSQUNFXCIsXG4gIHZhbHVlOiA4XG59O1xudmFyIERFRkFVTFQgPSB7XG4gIG5hbWU6IFwiREVGQVVMVFwiLFxuICB2YWx1ZTogOVxufTtcbnZhciBMb2dMZXZlbHMgPSBbXG4gIEVNRVJHRU5DWSxcbiAgQUxFUlQsXG4gIENSSVRJQ0FMLFxuICBFUlJPUixcbiAgV0FSTklORyxcbiAgTk9USUNFLFxuICBJTkZPLFxuICBERUJVRyxcbiAgVFJBQ0UsXG4gIERFRkFVTFRcbl07XG52YXIgZ2V0Q29uZmlnMiA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0xldmVscy5maW5kKChjb25maWcyKSA9PiBjb25maWcyLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMb2cgTGV2ZWwgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgZGVmYXVsdExvZ0xldmVsID0gSU5GTztcbnZhciBkZWZhdWx0TG9nRm9ybWF0ID0gVEVYVDtcbnZhciBkZWZhdWx0TG9nZ2luZ0NvbmZpZyA9IHtcbiAgbG9nTGV2ZWw6IGRlZmF1bHRMb2dMZXZlbCxcbiAgbG9nRm9ybWF0OiBkZWZhdWx0TG9nRm9ybWF0LFxuICBvdmVycmlkZXM6IHt9LFxuICBmbG9vZENvbnRyb2w6IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICAgIHRpbWVmcmFtZTogMWUzXG4gICAgLy8gMSBzZWNvbmRcbiAgfVxufTtcbnZhciBjb252ZXJ0T3ZlcnJpZGVzID0gKG92ZXJyaWRlcykgPT4ge1xuICBjb25zdCBjb252ZXJ0ZWRPdmVycmlkZXMgPSB7fTtcbiAgaWYgKG92ZXJyaWRlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKG92ZXJyaWRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjb252ZXJ0ZWRPdmVycmlkZXNba2V5XSA9IHsgbG9nTGV2ZWw6IHZhbHVlLmxvZ0xldmVsID8gZ2V0Q29uZmlnMih2YWx1ZS5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3ZlcnJpZGVzO1xufTtcbnZhciBjb252ZXJ0Q29uZmlnID0gKGNvbmZpZykgPT4ge1xuICByZXR1cm4ge1xuICAgIGxvZ0xldmVsOiBjb25maWcubG9nTGV2ZWwgPyBnZXRDb25maWcyKGNvbmZpZy5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwsXG4gICAgbG9nRm9ybWF0OiBjb25maWcubG9nRm9ybWF0ID8gZ2V0Q29uZmlnKGNvbmZpZy5sb2dGb3JtYXQpIDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgICBvdmVycmlkZXM6IGNvbnZlcnRPdmVycmlkZXMoY29uZmlnLm92ZXJyaWRlcyksXG4gICAgZmxvb2RDb250cm9sOiB7XG4gICAgICAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZy5mbG9vZENvbnRyb2wsXG4gICAgICAuLi5jb25maWcuZmxvb2RDb250cm9sIHx8IHt9XG4gICAgfVxuICB9O1xufTtcbnZhciBjb25maWd1cmVMb2dnaW5nID0gKCkgPT4ge1xuICBsZXQgY29uZmlnID0ge307XG4gIGNvbnN0IGxvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgZXhwb0xvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5FWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgbmV4dExvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgbGV0IGxvZ0xldmVsRW52ID0gcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuICBsZXQgbG9nRm9ybWF0RW52ID0gcHJvY2Vzcy5lbnYuTE9HX0ZPUk1BVDtcbiAgaWYgKGxvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShsb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBMT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cG9Mb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoZXhwb0xvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIEVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV4dExvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShuZXh0TG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gTkVYVF9QVUJMSUNfTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfVxuICBjb25zdCBjb252ZXJ0ZWRDb25maWcgPSBjb252ZXJ0Q29uZmlnKGNvbmZpZyk7XG4gIGlmIChsb2dMZXZlbEVudikge1xuICAgIGxvZ0xldmVsRW52ID0gbG9nTGV2ZWxFbnY/LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nTGV2ZWxDb25maWcgPSBnZXRDb25maWcyKGxvZ0xldmVsRW52KTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nTGV2ZWwgPSBsb2dMZXZlbENvbmZpZztcbiAgfVxuICBpZiAobG9nRm9ybWF0RW52KSB7XG4gICAgbG9nRm9ybWF0RW52ID0gbG9nRm9ybWF0RW52LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nRm9ybWF0Q29uZmlnID0gZ2V0Q29uZmlnKGxvZ0Zvcm1hdEVudik7XG4gICAgY29udmVydGVkQ29uZmlnLmxvZ0Zvcm1hdCA9IGxvZ0Zvcm1hdENvbmZpZztcbiAgfVxuICBjb25zdCBmaW5hbENvbmZpZyA9IHsgLi4uZGVmYXVsdExvZ2dpbmdDb25maWcsIC4uLmNvbnZlcnRlZENvbmZpZyB9O1xuICByZXR1cm4gZmluYWxDb25maWc7XG59O1xuXG4vLyBzcmMvV3JpdGVyLnRzXG52YXIgY3JlYXRlV3JpdGVyID0gKGZvcm1hdHRlciwgbG9nTWV0aG9kLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlc3BlY3RJbmplY3RlZE1ldGhvZCA9IGZhbHNlLFxuICAgIGVycm9yTWV0aG9kID0gY29uc29sZS5lcnJvcixcbiAgICB3YXJuaW5nTWV0aG9kID0gY29uc29sZS53YXJuLFxuICAgIGluZm9NZXRob2QgPSBjb25zb2xlLmxvZ1xuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICB3cml0ZTogKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgICAgbGV0IGZpbmFsTG9nTWV0aG9kID0gbG9nTWV0aG9kO1xuICAgICAgaWYgKCFyZXNwZWN0SW5qZWN0ZWRNZXRob2QpIHtcbiAgICAgICAgaWYgKGxldmVsLm5hbWUgPT09IEVSUk9SLm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gQ1JJVElDQUwubmFtZSB8fCBsZXZlbC5uYW1lID09PSBBTEVSVC5uYW1lIHx8IGxldmVsLm5hbWUgPT09IEVNRVJHRU5DWS5uYW1lKSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBlcnJvck1ldGhvZDtcbiAgICAgICAgfSBlbHNlIGlmIChsZXZlbC5uYW1lID09PSBXQVJOSU5HLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IHdhcm5pbmdNZXRob2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBpbmZvTWV0aG9kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5hbExvZ01ldGhvZChmb3JtYXR0ZXIuZm9ybWF0TG9nKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9mb3JtYXR0ZXIudHNcbmltcG9ydCB1dGlsIGZyb20gXCJ1dGlsXCI7XG52YXIgc2FmZUluc3BlY3QgPSAob2JqKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChvYmopO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYFtPYmplY3Q6ICR7dHlwZW9mIG9ian1dYDtcbiAgfVxufTtcbnZhciBzYWZlRm9ybWF0ID0gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdXRpbC5mb3JtYXQobWVzc2FnZSwgLi4uYXJncyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgJHttZXNzYWdlfSAke3NhZmVJbnNwZWN0KGFyZ3MpfWA7XG4gIH1cbn07XG52YXIgY3JlYXRlRm9ybWF0dGVyID0gKGxvZ0Zvcm1hdCkgPT4ge1xuICBpZiAobG9nRm9ybWF0Lm5hbWUgPT09IFwiVEVYVFwiKSB7XG4gICAgcmV0dXJuIGdldFRleHRGb3JtYXR0ZXIoKTtcbiAgfSBlbHNlIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJTVFJVQ1RVUkVEXCIpIHtcbiAgICByZXR1cm4gZ2V0U3RydWN0dXJlZEZvcm1hdHRlcigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsb2cgZm9ybWF0OiAke2xvZ0Zvcm1hdC5uYW1lfWApO1xufTtcbnZhciBnZXRUZXh0Rm9ybWF0dGVyID0gKCkgPT4ge1xuICBjb25zdCBmb3JtYXRMb2cgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuICAgIGxldCBsb2dNZXNzYWdlO1xuICAgIGlmIChwYXlsb2FkLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dNZXNzYWdlID0gcGF5bG9hZC5tZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAoaGFzU3BlY2lmaWVycykge1xuICAgICAgbG9nTWVzc2FnZSA9IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dNZXNzYWdlID0gYCR7cGF5bG9hZC5tZXNzYWdlfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke2xvZ01lc3NhZ2V9YDtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHJhbmRvbUludCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlMiA9IGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke3NhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9ICR7cmFuZG9tSW50fWA7XG4gICAgcmV0dXJuIHRpbWVyTWVzc2FnZTI7XG4gIH07XG4gIHJldHVybiB7IGZvcm1hdExvZywgdGltZXJNZXNzYWdlLCBnZXRMb2dGb3JtYXQ6ICgpID0+IFRFWFQgfTtcbn07XG52YXIgZ2V0U3RydWN0dXJlZEZvcm1hdHRlciA9ICgpID0+IHtcbiAgY29uc3QgZm9ybWF0TG9nID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogaGFzU3BlY2lmaWVycyA/IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpIDogcGF5bG9hZC5tZXNzYWdlLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgLi4uIWhhc1NwZWNpZmllcnMgJiYgcGF5bG9hZC5kYXRhLmxlbmd0aCA+IDAgJiYgeyBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzZXZlcml0eSxcbiAgICAgIG1lc3NhZ2U6IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgZGF0YTogc2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9zcGFuSWRcIjogU3RyaW5nKHJhbmRvbUludClcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gU1RSVUNUVVJFRCB9O1xufTtcblxuLy8gc3JjL0Zsb29kQ29udHJvbC50c1xuaW1wb3J0IHV0aWwyIGZyb20gXCJ1dGlsXCI7XG52YXIgaGFzaCA9IChtZXNzYWdlLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGRhdGFTdHJpbmcgPSBkYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdXRpbDIuaW5zcGVjdChpdGVtKTtcbiAgICB9XG4gIH0pLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHttZXNzYWdlfSR7ZGF0YVN0cmluZ31gO1xufTtcbnZhciBGbG9vZENvbnRyb2wgPSBjbGFzcyB7XG4gIGNvbmZpZztcbiAgaGlzdG9yeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN1cHByZXNzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjbGVhbnVwVGltZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmNsZWFudXAoKSwgdGhpcy5jb25maWcudGltZWZyYW1lICogMik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2hhc2gyLCB0aW1lc3RhbXBzXSBvZiB0aGlzLmhpc3RvcnkuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByZWNlbnRUaW1lc3RhbXBzID0gdGltZXN0YW1wcy5maWx0ZXIoXG4gICAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChyZWNlbnRUaW1lc3RhbXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LnNldChoYXNoMiwgcmVjZW50VGltZXN0YW1wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpc3RvcnkuZGVsZXRlKGhhc2gyKTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShoYXNoMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBcImxvZ1wiO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gKHRoaXMuaGlzdG9yeS5nZXQobWVzc2FnZUhhc2gpIHx8IFtdKS5maWx0ZXIoXG4gICAgICAodGltZXN0YW1wKSA9PiBub3cgLSB0aW1lc3RhbXAgPCB0aGlzLmNvbmZpZy50aW1lZnJhbWVcbiAgICApO1xuICAgIHRpbWVzdGFtcHMucHVzaChub3cpO1xuICAgIHRoaXMuaGlzdG9yeS5zZXQobWVzc2FnZUhhc2gsIHRpbWVzdGFtcHMpO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA+IHRoaXMuY29uZmlnLnRocmVzaG9sZCkge1xuICAgICAgY29uc3Qgc3VwcHJlc3NlZEluZm8gPSB0aGlzLnN1cHByZXNzZWQuZ2V0KG1lc3NhZ2VIYXNoKTtcbiAgICAgIGlmIChzdXBwcmVzc2VkSW5mbykge1xuICAgICAgICBzdXBwcmVzc2VkSW5mby5jb3VudCsrO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLnNldChtZXNzYWdlSGFzaCwgeyBjb3VudDogMSwgZmlyc3RUaW1lc3RhbXA6IHRpbWVzdGFtcHNbMF0sIHN1bW1hcnlMb2dnZWQ6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zdXBwcmVzc2VkLmhhcyhtZXNzYWdlSGFzaCkpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShtZXNzYWdlSGFzaCk7XG4gICAgICAgIHJldHVybiBcInJlc3VtZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJsb2dcIjtcbiAgfVxuICBnZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkge1xuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk/LmNvdW50IHx8IDA7XG4gIH1cbn07XG5cbi8vIHNyYy9Mb2dnZXIudHNcbnZhciBjcmVhdGVMb2dnZXIgPSAobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIobG9nRm9ybWF0KTtcbiAgY29uc3QgZmxvb2RDb250cm9sID0gZmxvb2RDb250cm9sQ29uZmlnLmVuYWJsZWQgPyBuZXcgRmxvb2RDb250cm9sKGZsb29kQ29udHJvbENvbmZpZykgOiBudWxsO1xuICBjb25zdCBsb2dGdW5jdGlvbiA9IGNvbnNvbGUubG9nO1xuICBjb25zdCB3cml0ZXIgPSBjcmVhdGVXcml0ZXIoZm9ybWF0dGVyLCBsb2dGdW5jdGlvbiwgd3JpdGVyT3B0aW9ucyk7XG4gIGNvbnN0IHdyaXRlID0gKGxldmVsLCBtZXNzYWdlLCBkYXRhKSA9PiB7XG4gICAgaWYgKGxvZ0xldmVsLnZhbHVlIDwgbGV2ZWwudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hlY2sgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuY2hlY2sobWVzc2FnZSwgZGF0YSkgOiBcImxvZ1wiO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7IG1lc3NhZ2UsIGRhdGEgfTtcbiAgICBzd2l0Y2ggKGNoZWNrKSB7XG4gICAgICBjYXNlIFwibG9nXCI6XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdXBwcmVzc1wiOlxuICAgICAgICBpZiAoZmxvb2RDb250cm9sICYmIGZsb29kQ29udHJvbC5nZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgY29uc3QgbmV3UGF5bG9hZCA9IHsgbWVzc2FnZTogYFN0YXJ0ZWQgc3VwcHJlc3NpbmcgcmVwZWF0ZWQgbG9nIG1lc3NhZ2VgLCBkYXRhOiBbXSB9O1xuICAgICAgICAgIHdyaXRlci53cml0ZShvcmlnaW5hbExldmVsLCBjb29yZGluYXRlcywgbmV3UGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVzdW1lXCI6IHtcbiAgICAgICAgY29uc3QgY291bnQgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIDogMDtcbiAgICAgICAgY29uc3QgcmVzdW1lUGF5bG9hZCA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBgU3RvcHBlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZS4gU3VwcHJlc3NlZCAke2NvdW50fSB0aW1lcy5gLFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHJlc3VtZVBheWxvYWQpO1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGFydFRpbWVMb2dnZXIgPSAobG9nTGV2ZWwyLCBjb29yZGluYXRlczIsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UgPSBmb3JtYXR0ZXIudGltZXJNZXNzYWdlKGxvZ0xldmVsMiwgY29vcmRpbmF0ZXMyLCBwYXlsb2FkKTtcbiAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lKHRpbWVyTWVzc2FnZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuZDogKCkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lRW5kKHRpbWVyTWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgbG9nOiAoLi4uZGF0YSkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lTG9nKHRpbWVyTWVzc2FnZSwgLi4uZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBlbWVyZ2VuY3k6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShFTUVSR0VOQ1ksIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgYWxlcnQ6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShBTEVSVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBjcml0aWNhbDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKENSSVRJQ0FMLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGVycm9yOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoRVJST1IsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgd2FybmluZzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKFdBUk5JTkcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgbm90aWNlOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoTk9USUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGluZm86IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShJTkZPLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVCVUcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgdHJhY2U6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShUUkFDRSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBkZWZhdWx0OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVGQVVMVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0aW1lOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHsgbWVzc2FnZSwgZGF0YSB9O1xuICAgICAgcmV0dXJuIHN0YXJ0VGltZUxvZ2dlcihsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgIH0sXG4gICAgZ2V0OiAoLi4uYWRkaXRpb25hbENvbXBvbmVudHMpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IFsuLi5jb29yZGluYXRlcy5jb21wb25lbnRzLCAuLi5hZGRpdGlvbmFsQ29tcG9uZW50c11cbiAgICAgIH0sIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucyk7XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBpZiAoZmxvb2RDb250cm9sKSB7XG4gICAgICAgIGZsb29kQ29udHJvbC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2xvZ2dpbmcudHNcbnZhciBnZXRMb2dnZXIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBjb25maWd1cmVMb2dnaW5nKCk7XG4gIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUJhc2VMb2dnZXIobmFtZSwgY29uZmlnKTtcbiAgcmV0dXJuIGxvZ2dlcjtcbn07XG52YXIgY3JlYXRlQmFzZUxvZ2dlciA9IChuYW1lLCBjb25maWcpID0+IHtcbiAgbGV0IHsgbG9nTGV2ZWwgfSA9IGNvbmZpZztcbiAgY29uc3QgeyBsb2dGb3JtYXQsIGZsb29kQ29udHJvbCB9ID0gY29uZmlnO1xuICBjb25zdCBvdmVycmlkZXMgPSBjb25maWcub3ZlcnJpZGVzO1xuICBpZiAob3ZlcnJpZGVzICYmIG92ZXJyaWRlc1tuYW1lXSkge1xuICAgIGxvZ0xldmVsID0gb3ZlcnJpZGVzW25hbWVdLmxvZ0xldmVsO1xuICB9XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0geyBjYXRlZ29yeTogbmFtZSwgY29tcG9uZW50czogW10gfTtcbiAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihsb2dGb3JtYXQsIGxvZ0xldmVsLCBjb29yZGluYXRlcywgZmxvb2RDb250cm9sKTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSB7IGdldExvZ2dlciB9O1xuZXhwb3J0IHtcbiAgTG9nRm9ybWF0X2V4cG9ydHMgYXMgTG9nRm9ybWF0LFxuICBMb2dMZXZlbF9leHBvcnRzIGFzIExvZ0xldmVsLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGdldExvZ2dlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-cache/node_modules/@fjell/registry/dist/index.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/registry/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = (kta, scopes = []) => {\n  const ktArray = Array.isArray(kta) ? kta : [kta];\n  const toString = () => {\n    logger.debug(\"toString\", { kta, scopes });\n    return `${ktArray.join(\", \")} - ${scopes.join(\", \")}`;\n  };\n  logger.debug(\"createCoordinate\", { kta: ktArray, scopes, toString });\n  return { kta: ktArray, scopes, toString };\n};\n\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate) => {\n  logger2.debug(\"createInstance\", { coordinate, registry });\n  return { coordinate, registry };\n};\nvar isInstance = (instance) => {\n  return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n\n// src/RegistryStats.ts\nvar RegistryStats = class {\n  totalCalls = 0;\n  // Map structure: ktaKey -> scopeKey -> clientKey -> count\n  coordinateCalls = /* @__PURE__ */ new Map();\n  /**\n   * Records a get() call for the specified coordinate and client\n   */\n  recordGetCall(kta, scopes, client) {\n    this.totalCalls++;\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    if (!this.coordinateCalls.has(ktaKey)) {\n      this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n    }\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap.has(scopeKey)) {\n      scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n    }\n    const clientMap = scopeMap.get(scopeKey);\n    const currentCount = clientMap.get(clientKey) || 0;\n    clientMap.set(clientKey, currentCount + 1);\n  }\n  /**\n   * Gets the current statistics snapshot\n   */\n  getStatistics() {\n    const coordinateCallRecords = [];\n    let serviceCalls = 0;\n    let applicationCalls = 0;\n    let unidentifiedCalls = 0;\n    for (const [ktaKey, scopeMap] of this.coordinateCalls) {\n      for (const [scopeKey, clientMap] of scopeMap) {\n        const clientCalls = [];\n        let totalCount = 0;\n        for (const [clientKey, count] of clientMap) {\n          const client = this.parseClientKey(clientKey);\n          if (client !== null) {\n            clientCalls.push({ client, count });\n          }\n          totalCount += count;\n          if (clientKey === \"__no_client__\") {\n            unidentifiedCalls += count;\n          } else if (typeof client === \"string\") {\n            applicationCalls += count;\n          } else if (client !== null) {\n            serviceCalls += count;\n          }\n        }\n        coordinateCallRecords.push({\n          kta: ktaKey.split(\".\"),\n          scopes: this.parseScopeKey(scopeKey),\n          count: totalCount,\n          clientCalls: [...clientCalls]\n          // Return a copy\n        });\n      }\n    }\n    return {\n      totalGetCalls: this.totalCalls,\n      coordinateCallRecords: [...coordinateCallRecords],\n      // Return a copy\n      clientSummary: {\n        serviceCalls,\n        applicationCalls,\n        unidentifiedCalls\n      }\n    };\n  }\n  /**\n   * Gets call count for a specific coordinate combination\n   */\n  getCallCount(kta, scopes) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    let total = 0;\n    for (const count of clientMap.values()) {\n      total += count;\n    }\n    return total;\n  }\n  /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */\n  getCallCountByClient(kta, scopes, client) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    return clientMap.get(clientKey) || 0;\n  }\n  /**\n   * Gets total calls for a specific kta (across all scopes)\n   */\n  getTotalCallsForKta(kta) {\n    const ktaKey = kta.join(\".\");\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    let total = 0;\n    for (const clientMap of scopeMap.values()) {\n      for (const count of clientMap.values()) {\n        total += count;\n      }\n    }\n    return total;\n  }\n  /**\n   * Gets all unique kta paths that have been called\n   */\n  getCalledKtaPaths() {\n    const ktaPaths = [];\n    for (const ktaKey of this.coordinateCalls.keys()) {\n      ktaPaths.push(ktaKey.split(\".\"));\n    }\n    return ktaPaths;\n  }\n  /**\n   * Creates a normalized scope key from scopes array\n   */\n  createScopeKey(scopes) {\n    if (scopes.length === 0) return \"__no_scopes__\";\n    return [...scopes].sort().join(\",\");\n  }\n  /**\n   * Parses a scope key back to scopes array\n   */\n  parseScopeKey(scopeKey) {\n    if (scopeKey === \"__no_scopes__\") return [];\n    return scopeKey.split(\",\");\n  }\n  /**\n   * Creates a normalized client key from client identifier\n   */\n  createClientKey(client) {\n    if (!client) return \"__no_client__\";\n    if (typeof client === \"string\") {\n      return `app:${client}`;\n    }\n    const coordKey = `${client.coordinate.kta.join(\".\")};${this.createScopeKey(client.coordinate.scopes)}`;\n    return `service:${client.registryType}:${coordKey}`;\n  }\n  /**\n   * Parses a client key back to client identifier\n   */\n  parseClientKey(clientKey) {\n    if (clientKey === \"__no_client__\") return null;\n    if (clientKey.startsWith(\"app:\")) {\n      return clientKey.substring(4);\n    }\n    if (clientKey.startsWith(\"service:\")) {\n      const parts = clientKey.substring(8).split(\":\");\n      if (parts.length !== 2) return null;\n      const registryType = parts[0];\n      const coordParts = parts[1].split(\";\");\n      if (coordParts.length !== 2) return null;\n      const kta = coordParts[0].split(\".\");\n      const scopes = this.parseScopeKey(coordParts[1]);\n      return {\n        registryType,\n        coordinate: { kta, scopes }\n      };\n    }\n    return null;\n  }\n};\n\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes) => {\n  if (!requestedScopes || requestedScopes.length === 0) {\n    const firstInstance = scopedInstances[0]?.instance;\n    if (!firstInstance) {\n      throw new Error(\"No instances available\");\n    }\n    return firstInstance;\n  }\n  const matchingInstance = scopedInstances.find((scopedInstance) => {\n    if (!scopedInstance.scopes) return false;\n    return requestedScopes.every(\n      (scope) => scopedInstance.scopes && scopedInstance.scopes.includes(scope)\n    );\n  });\n  if (!matchingInstance) {\n    throw new Error(`No instance found matching scopes: ${requestedScopes.join(\", \")}`);\n  }\n  return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub) => {\n  const instanceTree = {};\n  const registryStats = new RegistryStats();\n  const createProxiedRegistry = (callingCoordinate) => {\n    const serviceClient = {\n      registryType: type,\n      coordinate: {\n        kta: callingCoordinate.kta,\n        scopes: callingCoordinate.scopes\n      }\n    };\n    return {\n      ...registry,\n      get: (kta, options) => {\n        const clientToUse = options?.client || serviceClient;\n        return registry.get(kta, { ...options, client: clientToUse });\n      }\n    };\n  };\n  const createInstance2 = (kta, scopes, factory) => {\n    logger3.debug(`Creating and registering instance for key path and scopes`, kta, scopes, `in registry type: ${type}`);\n    const coordinate = createCoordinate(kta, scopes);\n    const proxiedRegistry = createProxiedRegistry(coordinate);\n    const instance = factory(coordinate, {\n      registry: proxiedRegistry,\n      registryHub\n    });\n    if (!isInstance(instance)) {\n      throw new Error(`Factory did not return a valid instance for: ${kta.join(\".\")}`);\n    }\n    registerInternal(kta, instance, { scopes });\n    return instance;\n  };\n  const registerInternal = (kta, instance, options) => {\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    logger3.debug(`Registering instance for key path and scopes`, keyPath, options?.scopes, `in registry type: ${type}`);\n    if (!isInstance(instance)) {\n      throw new Error(`Attempting to register a non-instance: ${kta.join(\".\")}`);\n    }\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        currentLevel[keyType] = {\n          instances: [],\n          children: isLeaf ? null : {}\n        };\n      }\n      if (isLeaf) {\n        currentLevel[keyType].instances.push({\n          scopes: options?.scopes,\n          instance\n        });\n      } else {\n        if (!currentLevel[keyType].children) {\n          currentLevel[keyType].children = {};\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n  };\n  const register = (kta, instance, options) => {\n    logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n    registerInternal(kta, instance, options);\n  };\n  const get = (kta, options) => {\n    registryStats.recordGetCall(kta, options?.scopes, options?.client);\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        throw new Error(`Instance not found for key path: ${kta.join(\".\")}, Missing key: ${keyType}`);\n      }\n      if (isLeaf) {\n        const scopedInstances = currentLevel[keyType].instances;\n        if (scopedInstances.length === 0) {\n          throw new Error(`No instances registered for key path: ${kta.join(\".\")}`);\n        }\n        return findScopedInstance(scopedInstances, options?.scopes);\n      } else {\n        if (!currentLevel[keyType].children) {\n          throw new Error(`Instance not found for key path: ${kta.join(\".\")}, No children for: ${keyType}`);\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n    return null;\n  };\n  const getCoordinates = () => {\n    const coordinates = [];\n    const traverseTree = (node) => {\n      for (const keyType in node) {\n        const treeNode = node[keyType];\n        for (const scopedInstance of treeNode.instances) {\n          coordinates.push(scopedInstance.instance.coordinate);\n        }\n        if (treeNode.children) {\n          traverseTree(treeNode.children);\n        }\n      }\n    };\n    traverseTree(instanceTree);\n    return coordinates;\n  };\n  const getStatistics = () => {\n    return registryStats.getStatistics();\n  };\n  const registry = {\n    type,\n    registryHub,\n    createInstance: createInstance2,\n    register,\n    get,\n    getCoordinates,\n    getStatistics,\n    instanceTree\n  };\n  return registry;\n};\n\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n  registryType;\n  context;\n  constructor(message, registryType, context) {\n    super(message);\n    this.name = this.constructor.name;\n    this.registryType = registryType;\n    this.context = context;\n    const ErrorConstructor = Error;\n    if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n      ErrorConstructor.captureStackTrace(this, this.constructor);\n    }\n  }\n  getDetails() {\n    const details = [this.message];\n    if (this.registryType) {\n      details.push(`Registry Type: ${this.registryType}`);\n    }\n    if (this.context) {\n      details.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n    }\n    return details.join(\"\\n\");\n  }\n};\nvar RegistryCreationError = class extends RegistryError {\n  constructor(type, reason, context) {\n    super(`Failed to create registry of type '${type}': ${reason}`, type, context);\n  }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n  keyPath;\n  factoryResult;\n  constructor(keyPath, factoryResult, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Factory did not return a valid instance for: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof factoryResult}`,\n      registryType,\n      { keyPath, factoryResult: typeof factoryResult }\n    );\n    this.keyPath = keyPath;\n    this.factoryResult = factoryResult;\n  }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n  keyPath;\n  attemptedRegistration;\n  constructor(keyPath, attemptedRegistration, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Attempting to register a non-instance: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof attemptedRegistration}`,\n      registryType,\n      { keyPath, attemptedRegistration: typeof attemptedRegistration }\n    );\n    this.keyPath = keyPath;\n    this.attemptedRegistration = attemptedRegistration;\n  }\n};\n\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n  hubType;\n  constructor(message, hubType, context) {\n    const enrichedContext = hubType ? { ...context, hubType } : context;\n    super(message, \"\", enrichedContext);\n    this.hubType = hubType;\n  }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n  duplicateType;\n  constructor(type, context) {\n    super(\n      `Registry already registered under type: ${type}. Each registry type must be unique within a registry hub.`,\n      \"\",\n      { ...context, duplicateType: type }\n    );\n    this.duplicateType = type;\n  }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n  requestedType;\n  availableTypes;\n  constructor(requestedType, availableTypes = [], context) {\n    let message = `No registry registered under type: ${requestedType}`;\n    if (availableTypes.length > 0) {\n      message += `. Available types: [${availableTypes.join(\", \")}]`;\n    }\n    super(message, \"\", { ...context, requestedType, availableTypes });\n    this.requestedType = requestedType;\n    this.availableTypes = availableTypes;\n  }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n  factoryError;\n  attemptedType;\n  constructor(type, factoryError, context) {\n    super(\n      `Registry factory failed to create registry of type '${type}': ${factoryError.message}`,\n      \"\",\n      { ...context, attemptedType: type, originalError: factoryError.message }\n    );\n    this.factoryError = factoryError;\n    this.attemptedType = type;\n  }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n  factoryResult;\n  attemptedType;\n  constructor(type, factoryResult, context) {\n    super(\n      `Registry factory returned invalid registry for type '${type}'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: ${typeof factoryResult}`,\n      \"\",\n      { ...context, attemptedType: type, factoryResult: typeof factoryResult }\n    );\n    this.factoryResult = factoryResult;\n    this.attemptedType = type;\n  }\n};\n\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = () => {\n  const registries = {};\n  const createRegistry2 = (type, factory) => {\n    logger4.debug(`Creating new registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    const registry = factory(type, hub);\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    registries[type] = registry;\n    logger4.debug(`Successfully created and registered new registry with type: ${type}`);\n    return registry;\n  };\n  const registerRegistry = (registry) => {\n    const type = registry.type;\n    logger4.debug(`Registering registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    registries[type] = registry;\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    logger4.debug(`Successfully registered registry with type: ${type}`);\n  };\n  const get = (type, kta, options) => {\n    logger4.debug(`Looking up instance for type: ${type}, kta: ${kta.join(\".\")}, scopes: ${options?.scopes?.join(\",\") || \"none\"}`);\n    const registry = registries[type];\n    if (!registry) {\n      const availableTypes = Object.keys(registries);\n      throw new RegistryTypeNotFoundError(type, availableTypes);\n    }\n    return registry.get(kta, options);\n  };\n  const getRegistry = (type) => {\n    return registries[type] || null;\n  };\n  const getRegisteredTypes = () => {\n    return Object.keys(registries);\n  };\n  const unregisterRegistry = (type) => {\n    if (registries[type]) {\n      delete registries[type];\n      logger4.debug(`Unregistered registry under type: ${type}`);\n      return true;\n    }\n    return false;\n  };\n  const getAllCoordinates = () => {\n    const allCoordinates = [];\n    for (const registryType in registries) {\n      const registry = registries[registryType];\n      const coordinates = registry.getCoordinates();\n      coordinates.forEach((coordinate) => {\n        allCoordinates.push({\n          coordinate,\n          registryType\n        });\n      });\n    }\n    logger4.debug(`Retrieved ${allCoordinates.length} total coordinates from ${Object.keys(registries).length} registries`);\n    return allCoordinates;\n  };\n  const hub = {\n    createRegistry: createRegistry2,\n    registerRegistry,\n    get,\n    getRegistry,\n    getRegisteredTypes,\n    getAllCoordinates,\n    unregisterRegistry\n  };\n  return hub;\n};\n\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n  keyPath;\n  constructor(message, keyPath, registryType, context) {\n    super(message, registryType, { ...context, keyPath });\n    this.keyPath = keyPath;\n  }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n  missingKey;\n  constructor(keyPath, missingKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    let message = `Instance not found for key path: ${keyPathStr}`;\n    if (missingKey) {\n      message += `, Missing key: ${missingKey}`;\n    }\n    super(message, keyPath, registryType, { ...context, missingKey });\n    this.missingKey = missingKey;\n  }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances registered for key path: ${keyPathStr}. The key path exists in the registry tree but contains no instances.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances available for key path: ${keyPathStr}. This typically indicates an internal registry state issue.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n  requestedScopes;\n  availableScopes;\n  constructor(keyPath, requestedScopes, availableScopes = [], registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    const scopesStr = requestedScopes.join(\", \");\n    const availableScopesStr = availableScopes.map((scopes) => `[${scopes.join(\", \")}]`).join(\", \");\n    let message = `No instance found matching scopes: ${scopesStr} for key path: ${keyPathStr}`;\n    if (availableScopes.length > 0) {\n      message += `. Available scopes: ${availableScopesStr}`;\n    }\n    super(message, keyPath, registryType, { requestedScopes, availableScopes });\n    this.requestedScopes = requestedScopes;\n    this.availableScopes = availableScopes;\n  }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n  parentKey;\n  constructor(keyPath, parentKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Instance not found for key path: ${keyPathStr}, No children for: ${parentKey}. The path cannot be traversed further as '${parentKey}' has no child nodes.`,\n      keyPath,\n      registryType,\n      { ...context, parentKey }\n    );\n    this.parentKey = parentKey;\n  }\n};\n\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n  kta;\n  scopes;\n  constructor(message, kta, scopes, context) {\n    super(message, \"\", { ...context, kta, scopes });\n    this.kta = kta;\n    this.scopes = scopes;\n  }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n  constructor(kta, scopes, reason, context) {\n    super(\n      `Invalid coordinate parameters: ${reason}. KTA: ${JSON.stringify(kta)}, Scopes: [${scopes.join(\", \")}]`,\n      kta,\n      scopes,\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidKTAError = class extends CoordinateError {\n  constructor(kta, reason, context) {\n    super(\n      `Invalid KTA (Key Type Array): ${reason}. Expected string or array of strings, got: ${JSON.stringify(kta)}`,\n      kta,\n      [],\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidScopesError = class extends CoordinateError {\n  invalidScopes;\n  constructor(scopes, invalidScopes, reason, context) {\n    super(\n      `Invalid scopes: ${reason}. Invalid scope values: ${JSON.stringify(invalidScopes)}`,\n      null,\n      scopes.filter((s) => typeof s === \"string\"),\n      { ...context, reason, invalidScopes }\n    );\n    this.invalidScopes = invalidScopes;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9yZWdpc3RyeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDcUM7QUFDckMsZ0JBQWdCLGdFQUFpQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUMsY0FBYyxvQkFBb0IsSUFBSSxrQkFBa0I7QUFDeEQ7QUFDQSxxQ0FBcUMsZ0NBQWdDO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQTJCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9AZmplbGwvcmVnaXN0cnkvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbG9nZ2VyLnRzXG5pbXBvcnQgTG9nZ2luZyBmcm9tIFwiQGZqZWxsL2xvZ2dpbmdcIjtcbnZhciBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcihcIkBmamVsbC9yZWdpc3RyeVwiKTtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExpYkxvZ2dlcjtcblxuLy8gc3JjL0Nvb3JkaW5hdGUudHNcbnZhciBsb2dnZXIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJDb29yZGluYXRlXCIpO1xudmFyIGNyZWF0ZUNvb3JkaW5hdGUgPSAoa3RhLCBzY29wZXMgPSBbXSkgPT4ge1xuICBjb25zdCBrdEFycmF5ID0gQXJyYXkuaXNBcnJheShrdGEpID8ga3RhIDogW2t0YV07XG4gIGNvbnN0IHRvU3RyaW5nID0gKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhcInRvU3RyaW5nXCIsIHsga3RhLCBzY29wZXMgfSk7XG4gICAgcmV0dXJuIGAke2t0QXJyYXkuam9pbihcIiwgXCIpfSAtICR7c2NvcGVzLmpvaW4oXCIsIFwiKX1gO1xuICB9O1xuICBsb2dnZXIuZGVidWcoXCJjcmVhdGVDb29yZGluYXRlXCIsIHsga3RhOiBrdEFycmF5LCBzY29wZXMsIHRvU3RyaW5nIH0pO1xuICByZXR1cm4geyBrdGE6IGt0QXJyYXksIHNjb3BlcywgdG9TdHJpbmcgfTtcbn07XG5cbi8vIHNyYy9JbnN0YW5jZS50c1xudmFyIGxvZ2dlcjIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJbnN0YW5jZVwiKTtcbnZhciBjcmVhdGVJbnN0YW5jZSA9IChyZWdpc3RyeSwgY29vcmRpbmF0ZSkgPT4ge1xuICBsb2dnZXIyLmRlYnVnKFwiY3JlYXRlSW5zdGFuY2VcIiwgeyBjb29yZGluYXRlLCByZWdpc3RyeSB9KTtcbiAgcmV0dXJuIHsgY29vcmRpbmF0ZSwgcmVnaXN0cnkgfTtcbn07XG52YXIgaXNJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICByZXR1cm4gaW5zdGFuY2UgIT09IG51bGwgJiYgaW5zdGFuY2UgIT09IHZvaWQgMCAmJiBpbnN0YW5jZS5jb29yZGluYXRlICE9PSB2b2lkIDAgJiYgaW5zdGFuY2UucmVnaXN0cnkgIT09IHZvaWQgMDtcbn07XG5cbi8vIHNyYy9SZWdpc3RyeVN0YXRzLnRzXG52YXIgUmVnaXN0cnlTdGF0cyA9IGNsYXNzIHtcbiAgdG90YWxDYWxscyA9IDA7XG4gIC8vIE1hcCBzdHJ1Y3R1cmU6IGt0YUtleSAtPiBzY29wZUtleSAtPiBjbGllbnRLZXkgLT4gY291bnRcbiAgY29vcmRpbmF0ZUNhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFJlY29yZHMgYSBnZXQoKSBjYWxsIGZvciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUgYW5kIGNsaWVudFxuICAgKi9cbiAgcmVjb3JkR2V0Q2FsbChrdGEsIHNjb3BlcywgY2xpZW50KSB7XG4gICAgdGhpcy50b3RhbENhbGxzKys7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IGNsaWVudEtleSA9IHRoaXMuY3JlYXRlQ2xpZW50S2V5KGNsaWVudCk7XG4gICAgaWYgKCF0aGlzLmNvb3JkaW5hdGVDYWxscy5oYXMoa3RhS2V5KSkge1xuICAgICAgdGhpcy5jb29yZGluYXRlQ2FsbHMuc2V0KGt0YUtleSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcC5oYXMoc2NvcGVLZXkpKSB7XG4gICAgICBzY29wZU1hcC5zZXQoc2NvcGVLZXksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnRNYXAgPSBzY29wZU1hcC5nZXQoc2NvcGVLZXkpO1xuICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IGNsaWVudE1hcC5nZXQoY2xpZW50S2V5KSB8fCAwO1xuICAgIGNsaWVudE1hcC5zZXQoY2xpZW50S2V5LCBjdXJyZW50Q291bnQgKyAxKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0aXN0aWNzIHNuYXBzaG90XG4gICAqL1xuICBnZXRTdGF0aXN0aWNzKCkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVDYWxsUmVjb3JkcyA9IFtdO1xuICAgIGxldCBzZXJ2aWNlQ2FsbHMgPSAwO1xuICAgIGxldCBhcHBsaWNhdGlvbkNhbGxzID0gMDtcbiAgICBsZXQgdW5pZGVudGlmaWVkQ2FsbHMgPSAwO1xuICAgIGZvciAoY29uc3QgW2t0YUtleSwgc2NvcGVNYXBdIG9mIHRoaXMuY29vcmRpbmF0ZUNhbGxzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtzY29wZUtleSwgY2xpZW50TWFwXSBvZiBzY29wZU1hcCkge1xuICAgICAgICBjb25zdCBjbGllbnRDYWxscyA9IFtdO1xuICAgICAgICBsZXQgdG90YWxDb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgW2NsaWVudEtleSwgY291bnRdIG9mIGNsaWVudE1hcCkge1xuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMucGFyc2VDbGllbnRLZXkoY2xpZW50S2V5KTtcbiAgICAgICAgICBpZiAoY2xpZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGllbnRDYWxscy5wdXNoKHsgY2xpZW50LCBjb3VudCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxDb3VudCArPSBjb3VudDtcbiAgICAgICAgICBpZiAoY2xpZW50S2V5ID09PSBcIl9fbm9fY2xpZW50X19cIikge1xuICAgICAgICAgICAgdW5pZGVudGlmaWVkQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2xpZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvbkNhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXJ2aWNlQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvb3JkaW5hdGVDYWxsUmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICBrdGE6IGt0YUtleS5zcGxpdChcIi5cIiksXG4gICAgICAgICAgc2NvcGVzOiB0aGlzLnBhcnNlU2NvcGVLZXkoc2NvcGVLZXkpLFxuICAgICAgICAgIGNvdW50OiB0b3RhbENvdW50LFxuICAgICAgICAgIGNsaWVudENhbGxzOiBbLi4uY2xpZW50Q2FsbHNdXG4gICAgICAgICAgLy8gUmV0dXJuIGEgY29weVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsR2V0Q2FsbHM6IHRoaXMudG90YWxDYWxscyxcbiAgICAgIGNvb3JkaW5hdGVDYWxsUmVjb3JkczogWy4uLmNvb3JkaW5hdGVDYWxsUmVjb3Jkc10sXG4gICAgICAvLyBSZXR1cm4gYSBjb3B5XG4gICAgICBjbGllbnRTdW1tYXJ5OiB7XG4gICAgICAgIHNlcnZpY2VDYWxscyxcbiAgICAgICAgYXBwbGljYXRpb25DYWxscyxcbiAgICAgICAgdW5pZGVudGlmaWVkQ2FsbHNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGNhbGwgY291bnQgZm9yIGEgc3BlY2lmaWMgY29vcmRpbmF0ZSBjb21iaW5hdGlvblxuICAgKi9cbiAgZ2V0Q2FsbENvdW50KGt0YSwgc2NvcGVzKSB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcCkgcmV0dXJuIDA7XG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBpZiAoIWNsaWVudE1hcCkgcmV0dXJuIDA7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IGNvdW50IG9mIGNsaWVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgdG90YWwgKz0gY291bnQ7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBjYWxsIGNvdW50IGZvciBhIHNwZWNpZmljIGNvb3JkaW5hdGUgY29tYmluYXRpb24gZnJvbSBhIHNwZWNpZmljIGNsaWVudFxuICAgKi9cbiAgZ2V0Q2FsbENvdW50QnlDbGllbnQoa3RhLCBzY29wZXMsIGNsaWVudCkge1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZUtleSA9IHRoaXMuY3JlYXRlU2NvcGVLZXkoc2NvcGVzIHx8IFtdKTtcbiAgICBjb25zdCBjbGllbnRLZXkgPSB0aGlzLmNyZWF0ZUNsaWVudEtleShjbGllbnQpO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcCkgcmV0dXJuIDA7XG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBpZiAoIWNsaWVudE1hcCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGNsaWVudE1hcC5nZXQoY2xpZW50S2V5KSB8fCAwO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRvdGFsIGNhbGxzIGZvciBhIHNwZWNpZmljIGt0YSAoYWNyb3NzIGFsbCBzY29wZXMpXG4gICAqL1xuICBnZXRUb3RhbENhbGxzRm9yS3RhKGt0YSkge1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChjb25zdCBjbGllbnRNYXAgb2Ygc2NvcGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY291bnQgb2YgY2xpZW50TWFwLnZhbHVlcygpKSB7XG4gICAgICAgIHRvdGFsICs9IGNvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYWxsIHVuaXF1ZSBrdGEgcGF0aHMgdGhhdCBoYXZlIGJlZW4gY2FsbGVkXG4gICAqL1xuICBnZXRDYWxsZWRLdGFQYXRocygpIHtcbiAgICBjb25zdCBrdGFQYXRocyA9IFtdO1xuICAgIGZvciAoY29uc3Qga3RhS2V5IG9mIHRoaXMuY29vcmRpbmF0ZUNhbGxzLmtleXMoKSkge1xuICAgICAga3RhUGF0aHMucHVzaChrdGFLZXkuc3BsaXQoXCIuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGt0YVBhdGhzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9ybWFsaXplZCBzY29wZSBrZXkgZnJvbSBzY29wZXMgYXJyYXlcbiAgICovXG4gIGNyZWF0ZVNjb3BlS2V5KHNjb3Blcykge1xuICAgIGlmIChzY29wZXMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJfX25vX3Njb3Blc19fXCI7XG4gICAgcmV0dXJuIFsuLi5zY29wZXNdLnNvcnQoKS5qb2luKFwiLFwiKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgc2NvcGUga2V5IGJhY2sgdG8gc2NvcGVzIGFycmF5XG4gICAqL1xuICBwYXJzZVNjb3BlS2V5KHNjb3BlS2V5KSB7XG4gICAgaWYgKHNjb3BlS2V5ID09PSBcIl9fbm9fc2NvcGVzX19cIikgcmV0dXJuIFtdO1xuICAgIHJldHVybiBzY29wZUtleS5zcGxpdChcIixcIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBub3JtYWxpemVkIGNsaWVudCBrZXkgZnJvbSBjbGllbnQgaWRlbnRpZmllclxuICAgKi9cbiAgY3JlYXRlQ2xpZW50S2V5KGNsaWVudCkge1xuICAgIGlmICghY2xpZW50KSByZXR1cm4gXCJfX25vX2NsaWVudF9fXCI7XG4gICAgaWYgKHR5cGVvZiBjbGllbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBgYXBwOiR7Y2xpZW50fWA7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkS2V5ID0gYCR7Y2xpZW50LmNvb3JkaW5hdGUua3RhLmpvaW4oXCIuXCIpfTske3RoaXMuY3JlYXRlU2NvcGVLZXkoY2xpZW50LmNvb3JkaW5hdGUuc2NvcGVzKX1gO1xuICAgIHJldHVybiBgc2VydmljZToke2NsaWVudC5yZWdpc3RyeVR5cGV9OiR7Y29vcmRLZXl9YDtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgY2xpZW50IGtleSBiYWNrIHRvIGNsaWVudCBpZGVudGlmaWVyXG4gICAqL1xuICBwYXJzZUNsaWVudEtleShjbGllbnRLZXkpIHtcbiAgICBpZiAoY2xpZW50S2V5ID09PSBcIl9fbm9fY2xpZW50X19cIikgcmV0dXJuIG51bGw7XG4gICAgaWYgKGNsaWVudEtleS5zdGFydHNXaXRoKFwiYXBwOlwiKSkge1xuICAgICAgcmV0dXJuIGNsaWVudEtleS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIGlmIChjbGllbnRLZXkuc3RhcnRzV2l0aChcInNlcnZpY2U6XCIpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGNsaWVudEtleS5zdWJzdHJpbmcoOCkuc3BsaXQoXCI6XCIpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCByZWdpc3RyeVR5cGUgPSBwYXJ0c1swXTtcbiAgICAgIGNvbnN0IGNvb3JkUGFydHMgPSBwYXJ0c1sxXS5zcGxpdChcIjtcIik7XG4gICAgICBpZiAoY29vcmRQYXJ0cy5sZW5ndGggIT09IDIpIHJldHVybiBudWxsO1xuICAgICAgY29uc3Qga3RhID0gY29vcmRQYXJ0c1swXS5zcGxpdChcIi5cIik7XG4gICAgICBjb25zdCBzY29wZXMgPSB0aGlzLnBhcnNlU2NvcGVLZXkoY29vcmRQYXJ0c1sxXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWdpc3RyeVR5cGUsXG4gICAgICAgIGNvb3JkaW5hdGU6IHsga3RhLCBzY29wZXMgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIHNyYy9SZWdpc3RyeS50c1xudmFyIGxvZ2dlcjMgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJSZWdpc3RyeVwiKTtcbnZhciBmaW5kU2NvcGVkSW5zdGFuY2UgPSAoc2NvcGVkSW5zdGFuY2VzLCByZXF1ZXN0ZWRTY29wZXMpID0+IHtcbiAgaWYgKCFyZXF1ZXN0ZWRTY29wZXMgfHwgcmVxdWVzdGVkU2NvcGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IGZpcnN0SW5zdGFuY2UgPSBzY29wZWRJbnN0YW5jZXNbMF0/Lmluc3RhbmNlO1xuICAgIGlmICghZmlyc3RJbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gaW5zdGFuY2VzIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0SW5zdGFuY2U7XG4gIH1cbiAgY29uc3QgbWF0Y2hpbmdJbnN0YW5jZSA9IHNjb3BlZEluc3RhbmNlcy5maW5kKChzY29wZWRJbnN0YW5jZSkgPT4ge1xuICAgIGlmICghc2NvcGVkSW5zdGFuY2Uuc2NvcGVzKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJlcXVlc3RlZFNjb3Blcy5ldmVyeShcbiAgICAgIChzY29wZSkgPT4gc2NvcGVkSW5zdGFuY2Uuc2NvcGVzICYmIHNjb3BlZEluc3RhbmNlLnNjb3Blcy5pbmNsdWRlcyhzY29wZSlcbiAgICApO1xuICB9KTtcbiAgaWYgKCFtYXRjaGluZ0luc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnN0YW5jZSBmb3VuZCBtYXRjaGluZyBzY29wZXM6ICR7cmVxdWVzdGVkU2NvcGVzLmpvaW4oXCIsIFwiKX1gKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hpbmdJbnN0YW5jZS5pbnN0YW5jZTtcbn07XG52YXIgY3JlYXRlUmVnaXN0cnkgPSAodHlwZSwgcmVnaXN0cnlIdWIpID0+IHtcbiAgY29uc3QgaW5zdGFuY2VUcmVlID0ge307XG4gIGNvbnN0IHJlZ2lzdHJ5U3RhdHMgPSBuZXcgUmVnaXN0cnlTdGF0cygpO1xuICBjb25zdCBjcmVhdGVQcm94aWVkUmVnaXN0cnkgPSAoY2FsbGluZ0Nvb3JkaW5hdGUpID0+IHtcbiAgICBjb25zdCBzZXJ2aWNlQ2xpZW50ID0ge1xuICAgICAgcmVnaXN0cnlUeXBlOiB0eXBlLFxuICAgICAgY29vcmRpbmF0ZToge1xuICAgICAgICBrdGE6IGNhbGxpbmdDb29yZGluYXRlLmt0YSxcbiAgICAgICAgc2NvcGVzOiBjYWxsaW5nQ29vcmRpbmF0ZS5zY29wZXNcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZWdpc3RyeSxcbiAgICAgIGdldDogKGt0YSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBjbGllbnRUb1VzZSA9IG9wdGlvbnM/LmNsaWVudCB8fCBzZXJ2aWNlQ2xpZW50O1xuICAgICAgICByZXR1cm4gcmVnaXN0cnkuZ2V0KGt0YSwgeyAuLi5vcHRpb25zLCBjbGllbnQ6IGNsaWVudFRvVXNlIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IGNyZWF0ZUluc3RhbmNlMiA9IChrdGEsIHNjb3BlcywgZmFjdG9yeSkgPT4ge1xuICAgIGxvZ2dlcjMuZGVidWcoYENyZWF0aW5nIGFuZCByZWdpc3RlcmluZyBpbnN0YW5jZSBmb3Iga2V5IHBhdGggYW5kIHNjb3Blc2AsIGt0YSwgc2NvcGVzLCBgaW4gcmVnaXN0cnkgdHlwZTogJHt0eXBlfWApO1xuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSBjcmVhdGVDb29yZGluYXRlKGt0YSwgc2NvcGVzKTtcbiAgICBjb25zdCBwcm94aWVkUmVnaXN0cnkgPSBjcmVhdGVQcm94aWVkUmVnaXN0cnkoY29vcmRpbmF0ZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBmYWN0b3J5KGNvb3JkaW5hdGUsIHtcbiAgICAgIHJlZ2lzdHJ5OiBwcm94aWVkUmVnaXN0cnksXG4gICAgICByZWdpc3RyeUh1YlxuICAgIH0pO1xuICAgIGlmICghaXNJbnN0YW5jZShpbnN0YW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFjdG9yeSBkaWQgbm90IHJldHVybiBhIHZhbGlkIGluc3RhbmNlIGZvcjogJHtrdGEuam9pbihcIi5cIil9YCk7XG4gICAgfVxuICAgIHJlZ2lzdGVySW50ZXJuYWwoa3RhLCBpbnN0YW5jZSwgeyBzY29wZXMgfSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuICBjb25zdCByZWdpc3RlckludGVybmFsID0gKGt0YSwgaW5zdGFuY2UsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBrZXlQYXRoID0gWy4uLmt0YV0ucmV2ZXJzZSgpO1xuICAgIGxldCBjdXJyZW50TGV2ZWwgPSBpbnN0YW5jZVRyZWU7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhgUmVnaXN0ZXJpbmcgaW5zdGFuY2UgZm9yIGtleSBwYXRoIGFuZCBzY29wZXNgLCBrZXlQYXRoLCBvcHRpb25zPy5zY29wZXMsIGBpbiByZWdpc3RyeSB0eXBlOiAke3R5cGV9YCk7XG4gICAgaWYgKCFpc0luc3RhbmNlKGluc3RhbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgbm9uLWluc3RhbmNlOiAke2t0YS5qb2luKFwiLlwiKX1gKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlUeXBlID0ga2V5UGF0aFtpXTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGkgPT09IGtleVBhdGgubGVuZ3RoIC0gMTtcbiAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXSA9IHtcbiAgICAgICAgICBpbnN0YW5jZXM6IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBpc0xlYWYgPyBudWxsIDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgY3VycmVudExldmVsW2tleVR5cGVdLmluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZXM6IG9wdGlvbnM/LnNjb3BlcyxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuKSB7XG4gICAgICAgICAgY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXIgPSAoa3RhLCBpbnN0YW5jZSwgb3B0aW9ucykgPT4ge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJVc2luZyBkZXByZWNhdGVkIHJlZ2lzdGVyIG1ldGhvZC4gQ29uc2lkZXIgdXNpbmcgY3JlYXRlSW5zdGFuY2UgaW5zdGVhZC5cIik7XG4gICAgcmVnaXN0ZXJJbnRlcm5hbChrdGEsIGluc3RhbmNlLCBvcHRpb25zKTtcbiAgfTtcbiAgY29uc3QgZ2V0ID0gKGt0YSwgb3B0aW9ucykgPT4ge1xuICAgIHJlZ2lzdHJ5U3RhdHMucmVjb3JkR2V0Q2FsbChrdGEsIG9wdGlvbnM/LnNjb3Blcywgb3B0aW9ucz8uY2xpZW50KTtcbiAgICBjb25zdCBrZXlQYXRoID0gWy4uLmt0YV0ucmV2ZXJzZSgpO1xuICAgIGxldCBjdXJyZW50TGV2ZWwgPSBpbnN0YW5jZVRyZWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlUeXBlID0ga2V5UGF0aFtpXTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGkgPT09IGtleVBhdGgubGVuZ3RoIC0gMTtcbiAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbihcIi5cIil9LCBNaXNzaW5nIGtleTogJHtrZXlUeXBlfWApO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICBjb25zdCBzY29wZWRJbnN0YW5jZXMgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uaW5zdGFuY2VzO1xuICAgICAgICBpZiAoc2NvcGVkSW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5zdGFuY2VzIHJlZ2lzdGVyZWQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKFwiLlwiKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZFNjb3BlZEluc3RhbmNlKHNjb3BlZEluc3RhbmNlcywgb3B0aW9ucz8uc2NvcGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKFwiLlwiKX0sIE5vIGNoaWxkcmVuIGZvcjogJHtrZXlUeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0IGdldENvb3JkaW5hdGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gICAgY29uc3QgdHJhdmVyc2VUcmVlID0gKG5vZGUpID0+IHtcbiAgICAgIGZvciAoY29uc3Qga2V5VHlwZSBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IHRyZWVOb2RlID0gbm9kZVtrZXlUeXBlXTtcbiAgICAgICAgZm9yIChjb25zdCBzY29wZWRJbnN0YW5jZSBvZiB0cmVlTm9kZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKHNjb3BlZEluc3RhbmNlLmluc3RhbmNlLmNvb3JkaW5hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlTm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIHRyYXZlcnNlVHJlZSh0cmVlTm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRyYXZlcnNlVHJlZShpbnN0YW5jZVRyZWUpO1xuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGlzdGljcyA9ICgpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0cnlTdGF0cy5nZXRTdGF0aXN0aWNzKCk7XG4gIH07XG4gIGNvbnN0IHJlZ2lzdHJ5ID0ge1xuICAgIHR5cGUsXG4gICAgcmVnaXN0cnlIdWIsXG4gICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlMixcbiAgICByZWdpc3RlcixcbiAgICBnZXQsXG4gICAgZ2V0Q29vcmRpbmF0ZXMsXG4gICAgZ2V0U3RhdGlzdGljcyxcbiAgICBpbnN0YW5jZVRyZWVcbiAgfTtcbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufTtcblxuLy8gc3JjL2Vycm9ycy9SZWdpc3RyeUVycm9yLnRzXG52YXIgUmVnaXN0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICByZWdpc3RyeVR5cGU7XG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJlZ2lzdHJ5VHlwZSA9IHJlZ2lzdHJ5VHlwZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IEVycm9yQ29uc3RydWN0b3IgPSBFcnJvcjtcbiAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgRXJyb3JDb25zdHJ1Y3Rvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGV0YWlscygpIHtcbiAgICBjb25zdCBkZXRhaWxzID0gW3RoaXMubWVzc2FnZV07XG4gICAgaWYgKHRoaXMucmVnaXN0cnlUeXBlKSB7XG4gICAgICBkZXRhaWxzLnB1c2goYFJlZ2lzdHJ5IFR5cGU6ICR7dGhpcy5yZWdpc3RyeVR5cGV9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgIGRldGFpbHMucHVzaChgQ29udGV4dDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNvbnRleHQsIG51bGwsIDIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZGV0YWlscy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIFJlZ2lzdHJ5Q3JlYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKGBGYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJ5IG9mIHR5cGUgJyR7dHlwZX0nOiAke3JlYXNvbn1gLCB0eXBlLCBjb250ZXh0KTtcbiAgfVxufTtcbnZhciBJbnZhbGlkRmFjdG9yeVJlc3VsdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga2V5UGF0aDtcbiAgZmFjdG9yeVJlc3VsdDtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgZmFjdG9yeVJlc3VsdCwgcmVnaXN0cnlUeXBlKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgRmFjdG9yeSBkaWQgbm90IHJldHVybiBhIHZhbGlkIGluc3RhbmNlIGZvcjogJHtrZXlQYXRoU3RyfS4gRXhwZWN0ZWQgaW5zdGFuY2Ugd2l0aCAnY29vcmRpbmF0ZScgYW5kICdyZWdpc3RyeScgcHJvcGVydGllcywgZ290OiAke3R5cGVvZiBmYWN0b3J5UmVzdWx0fWAsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IGtleVBhdGgsIGZhY3RvcnlSZXN1bHQ6IHR5cGVvZiBmYWN0b3J5UmVzdWx0IH1cbiAgICApO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdGhpcy5mYWN0b3J5UmVzdWx0ID0gZmFjdG9yeVJlc3VsdDtcbiAgfVxufTtcbnZhciBJbnZhbGlkSW5zdGFuY2VSZWdpc3RyYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGtleVBhdGg7XG4gIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uLCByZWdpc3RyeVR5cGUpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBBdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgbm9uLWluc3RhbmNlOiAke2tleVBhdGhTdHJ9LiBFeHBlY3RlZCBpbnN0YW5jZSB3aXRoICdjb29yZGluYXRlJyBhbmQgJ3JlZ2lzdHJ5JyBwcm9wZXJ0aWVzLCBnb3Q6ICR7dHlwZW9mIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbn1gLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyBrZXlQYXRoLCBhdHRlbXB0ZWRSZWdpc3RyYXRpb246IHR5cGVvZiBhdHRlbXB0ZWRSZWdpc3RyYXRpb24gfVxuICAgICk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lzdHJhdGlvbiA9IGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9SZWdpc3RyeUh1YkVycm9yLnRzXG52YXIgUmVnaXN0cnlIdWJFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGh1YlR5cGU7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGh1YlR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBlbnJpY2hlZENvbnRleHQgPSBodWJUeXBlID8geyAuLi5jb250ZXh0LCBodWJUeXBlIH0gOiBjb250ZXh0O1xuICAgIHN1cGVyKG1lc3NhZ2UsIFwiXCIsIGVucmljaGVkQ29udGV4dCk7XG4gICAgdGhpcy5odWJUeXBlID0gaHViVHlwZTtcbiAgfVxufTtcbnZhciBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIGR1cGxpY2F0ZVR5cGU7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBhbHJlYWR5IHJlZ2lzdGVyZWQgdW5kZXIgdHlwZTogJHt0eXBlfS4gRWFjaCByZWdpc3RyeSB0eXBlIG11c3QgYmUgdW5pcXVlIHdpdGhpbiBhIHJlZ2lzdHJ5IGh1Yi5gLFxuICAgICAgXCJcIixcbiAgICAgIHsgLi4uY29udGV4dCwgZHVwbGljYXRlVHlwZTogdHlwZSB9XG4gICAgKTtcbiAgICB0aGlzLmR1cGxpY2F0ZVR5cGUgPSB0eXBlO1xuICB9XG59O1xudmFyIFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICByZXF1ZXN0ZWRUeXBlO1xuICBhdmFpbGFibGVUeXBlcztcbiAgY29uc3RydWN0b3IocmVxdWVzdGVkVHlwZSwgYXZhaWxhYmxlVHlwZXMgPSBbXSwgY29udGV4dCkge1xuICAgIGxldCBtZXNzYWdlID0gYE5vIHJlZ2lzdHJ5IHJlZ2lzdGVyZWQgdW5kZXIgdHlwZTogJHtyZXF1ZXN0ZWRUeXBlfWA7XG4gICAgaWYgKGF2YWlsYWJsZVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2UgKz0gYC4gQXZhaWxhYmxlIHR5cGVzOiBbJHthdmFpbGFibGVUeXBlcy5qb2luKFwiLCBcIil9XWA7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIFwiXCIsIHsgLi4uY29udGV4dCwgcmVxdWVzdGVkVHlwZSwgYXZhaWxhYmxlVHlwZXMgfSk7XG4gICAgdGhpcy5yZXF1ZXN0ZWRUeXBlID0gcmVxdWVzdGVkVHlwZTtcbiAgICB0aGlzLmF2YWlsYWJsZVR5cGVzID0gYXZhaWxhYmxlVHlwZXM7XG4gIH1cbn07XG52YXIgUmVnaXN0cnlGYWN0b3J5RXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBmYWN0b3J5RXJyb3I7XG4gIGF0dGVtcHRlZFR5cGU7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGZhY3RvcnlFcnJvciwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGZhY3RvcnkgZmFpbGVkIHRvIGNyZWF0ZSByZWdpc3RyeSBvZiB0eXBlICcke3R5cGV9JzogJHtmYWN0b3J5RXJyb3IubWVzc2FnZX1gLFxuICAgICAgXCJcIixcbiAgICAgIHsgLi4uY29udGV4dCwgYXR0ZW1wdGVkVHlwZTogdHlwZSwgb3JpZ2luYWxFcnJvcjogZmFjdG9yeUVycm9yLm1lc3NhZ2UgfVxuICAgICk7XG4gICAgdGhpcy5mYWN0b3J5RXJyb3IgPSBmYWN0b3J5RXJyb3I7XG4gICAgdGhpcy5hdHRlbXB0ZWRUeXBlID0gdHlwZTtcbiAgfVxufTtcbnZhciBJbnZhbGlkUmVnaXN0cnlGYWN0b3J5UmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBmYWN0b3J5UmVzdWx0O1xuICBhdHRlbXB0ZWRUeXBlO1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBmYWN0b3J5UmVzdWx0LCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVnaXN0cnkgZmFjdG9yeSByZXR1cm5lZCBpbnZhbGlkIHJlZ2lzdHJ5IGZvciB0eXBlICcke3R5cGV9Jy4gRXhwZWN0ZWQgcmVnaXN0cnkgd2l0aCAndHlwZScsICdnZXQnLCAncmVnaXN0ZXInLCBhbmQgJ2NyZWF0ZUluc3RhbmNlJyBwcm9wZXJ0aWVzLCBnb3Q6ICR7dHlwZW9mIGZhY3RvcnlSZXN1bHR9YCxcbiAgICAgIFwiXCIsXG4gICAgICB7IC4uLmNvbnRleHQsIGF0dGVtcHRlZFR5cGU6IHR5cGUsIGZhY3RvcnlSZXN1bHQ6IHR5cGVvZiBmYWN0b3J5UmVzdWx0IH1cbiAgICApO1xuICAgIHRoaXMuZmFjdG9yeVJlc3VsdCA9IGZhY3RvcnlSZXN1bHQ7XG4gICAgdGhpcy5hdHRlbXB0ZWRUeXBlID0gdHlwZTtcbiAgfVxufTtcblxuLy8gc3JjL1JlZ2lzdHJ5SHViLnRzXG52YXIgbG9nZ2VyNCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIlJlZ2lzdHJ5SHViXCIpO1xudmFyIGNyZWF0ZVJlZ2lzdHJ5SHViID0gKCkgPT4ge1xuICBjb25zdCByZWdpc3RyaWVzID0ge307XG4gIGNvbnN0IGNyZWF0ZVJlZ2lzdHJ5MiA9ICh0eXBlLCBmYWN0b3J5KSA9PiB7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgQ3JlYXRpbmcgbmV3IHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gZmFjdG9yeSh0eXBlLCBodWIpO1xuICAgIGlmICghKFwicmVnaXN0cnlIdWJcIiBpbiByZWdpc3RyeSkgfHwgcmVnaXN0cnkucmVnaXN0cnlIdWIgIT09IGh1Yikge1xuICAgICAgcmVnaXN0cnkucmVnaXN0cnlIdWIgPSBodWI7XG4gICAgfVxuICAgIHJlZ2lzdHJpZXNbdHlwZV0gPSByZWdpc3RyeTtcbiAgICBsb2dnZXI0LmRlYnVnKGBTdWNjZXNzZnVsbHkgY3JlYXRlZCBhbmQgcmVnaXN0ZXJlZCBuZXcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICB9O1xuICBjb25zdCByZWdpc3RlclJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHJlZ2lzdHJ5LnR5cGU7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgUmVnaXN0ZXJpbmcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gICAgaWYgKHJlZ2lzdHJpZXNbdHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG4gICAgcmVnaXN0cmllc1t0eXBlXSA9IHJlZ2lzdHJ5O1xuICAgIGlmICghKFwicmVnaXN0cnlIdWJcIiBpbiByZWdpc3RyeSkgfHwgcmVnaXN0cnkucmVnaXN0cnlIdWIgIT09IGh1Yikge1xuICAgICAgcmVnaXN0cnkucmVnaXN0cnlIdWIgPSBodWI7XG4gICAgfVxuICAgIGxvZ2dlcjQuZGVidWcoYFN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkIHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICB9O1xuICBjb25zdCBnZXQgPSAodHlwZSwga3RhLCBvcHRpb25zKSA9PiB7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgTG9va2luZyB1cCBpbnN0YW5jZSBmb3IgdHlwZTogJHt0eXBlfSwga3RhOiAke2t0YS5qb2luKFwiLlwiKX0sIHNjb3BlczogJHtvcHRpb25zPy5zY29wZXM/LmpvaW4oXCIsXCIpIHx8IFwibm9uZVwifWApO1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gcmVnaXN0cmllc1t0eXBlXTtcbiAgICBpZiAoIXJlZ2lzdHJ5KSB7XG4gICAgICBjb25zdCBhdmFpbGFibGVUeXBlcyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJpZXMpO1xuICAgICAgdGhyb3cgbmV3IFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IodHlwZSwgYXZhaWxhYmxlVHlwZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0cnkuZ2V0KGt0YSwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IGdldFJlZ2lzdHJ5ID0gKHR5cGUpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0cmllc1t0eXBlXSB8fCBudWxsO1xuICB9O1xuICBjb25zdCBnZXRSZWdpc3RlcmVkVHlwZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdHJpZXMpO1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyUmVnaXN0cnkgPSAodHlwZSkgPT4ge1xuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICBkZWxldGUgcmVnaXN0cmllc1t0eXBlXTtcbiAgICAgIGxvZ2dlcjQuZGVidWcoYFVucmVnaXN0ZXJlZCByZWdpc3RyeSB1bmRlciB0eXBlOiAke3R5cGV9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBjb25zdCBnZXRBbGxDb29yZGluYXRlcyA9ICgpID0+IHtcbiAgICBjb25zdCBhbGxDb29yZGluYXRlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVnaXN0cnlUeXBlIGluIHJlZ2lzdHJpZXMpIHtcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gcmVnaXN0cmllc1tyZWdpc3RyeVR5cGVdO1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSByZWdpc3RyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaCgoY29vcmRpbmF0ZSkgPT4ge1xuICAgICAgICBhbGxDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICBjb29yZGluYXRlLFxuICAgICAgICAgIHJlZ2lzdHJ5VHlwZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsb2dnZXI0LmRlYnVnKGBSZXRyaWV2ZWQgJHthbGxDb29yZGluYXRlcy5sZW5ndGh9IHRvdGFsIGNvb3JkaW5hdGVzIGZyb20gJHtPYmplY3Qua2V5cyhyZWdpc3RyaWVzKS5sZW5ndGh9IHJlZ2lzdHJpZXNgKTtcbiAgICByZXR1cm4gYWxsQ29vcmRpbmF0ZXM7XG4gIH07XG4gIGNvbnN0IGh1YiA9IHtcbiAgICBjcmVhdGVSZWdpc3RyeTogY3JlYXRlUmVnaXN0cnkyLFxuICAgIHJlZ2lzdGVyUmVnaXN0cnksXG4gICAgZ2V0LFxuICAgIGdldFJlZ2lzdHJ5LFxuICAgIGdldFJlZ2lzdGVyZWRUeXBlcyxcbiAgICBnZXRBbGxDb29yZGluYXRlcyxcbiAgICB1bnJlZ2lzdGVyUmVnaXN0cnlcbiAgfTtcbiAgcmV0dXJuIGh1Yjtcbn07XG5cbi8vIHNyYy9lcnJvcnMvSW5zdGFuY2VFcnJvci50c1xudmFyIEluc3RhbmNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrZXlQYXRoO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBrZXlQYXRoLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCByZWdpc3RyeVR5cGUsIHsgLi4uY29udGV4dCwga2V5UGF0aCB9KTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICB9XG59O1xudmFyIEluc3RhbmNlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIG1pc3NpbmdLZXk7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIG1pc3NpbmdLZXksIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIGxldCBtZXNzYWdlID0gYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn1gO1xuICAgIGlmIChtaXNzaW5nS2V5KSB7XG4gICAgICBtZXNzYWdlICs9IGAsIE1pc3Npbmcga2V5OiAke21pc3NpbmdLZXl9YDtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSwga2V5UGF0aCwgcmVnaXN0cnlUeXBlLCB7IC4uLmNvbnRleHQsIG1pc3NpbmdLZXkgfSk7XG4gICAgdGhpcy5taXNzaW5nS2V5ID0gbWlzc2luZ0tleTtcbiAgfVxufTtcbnZhciBOb0luc3RhbmNlc1JlZ2lzdGVyZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYE5vIGluc3RhbmNlcyByZWdpc3RlcmVkIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfS4gVGhlIGtleSBwYXRoIGV4aXN0cyBpbiB0aGUgcmVnaXN0cnkgdHJlZSBidXQgY29udGFpbnMgbm8gaW5zdGFuY2VzLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbn07XG52YXIgTm9JbnN0YW5jZXNBdmFpbGFibGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYE5vIGluc3RhbmNlcyBhdmFpbGFibGUgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9LiBUaGlzIHR5cGljYWxseSBpbmRpY2F0ZXMgYW4gaW50ZXJuYWwgcmVnaXN0cnkgc3RhdGUgaXNzdWUuYCxcbiAgICAgIGtleVBhdGgsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxufTtcbnZhciBTY29wZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICByZXF1ZXN0ZWRTY29wZXM7XG4gIGF2YWlsYWJsZVNjb3BlcztcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcmVxdWVzdGVkU2NvcGVzLCBhdmFpbGFibGVTY29wZXMgPSBbXSwgcmVnaXN0cnlUeXBlKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVzU3RyID0gcmVxdWVzdGVkU2NvcGVzLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBhdmFpbGFibGVTY29wZXNTdHIgPSBhdmFpbGFibGVTY29wZXMubWFwKChzY29wZXMpID0+IGBbJHtzY29wZXMuam9pbihcIiwgXCIpfV1gKS5qb2luKFwiLCBcIik7XG4gICAgbGV0IG1lc3NhZ2UgPSBgTm8gaW5zdGFuY2UgZm91bmQgbWF0Y2hpbmcgc2NvcGVzOiAke3Njb3Blc1N0cn0gZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9YDtcbiAgICBpZiAoYXZhaWxhYmxlU2NvcGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2UgKz0gYC4gQXZhaWxhYmxlIHNjb3BlczogJHthdmFpbGFibGVTY29wZXNTdHJ9YDtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSwga2V5UGF0aCwgcmVnaXN0cnlUeXBlLCB7IHJlcXVlc3RlZFNjb3BlcywgYXZhaWxhYmxlU2NvcGVzIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkU2NvcGVzID0gcmVxdWVzdGVkU2NvcGVzO1xuICAgIHRoaXMuYXZhaWxhYmxlU2NvcGVzID0gYXZhaWxhYmxlU2NvcGVzO1xuICB9XG59O1xudmFyIE5vQ2hpbGRyZW5BdmFpbGFibGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIHBhcmVudEtleTtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcGFyZW50S2V5LCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9LCBObyBjaGlsZHJlbiBmb3I6ICR7cGFyZW50S2V5fS4gVGhlIHBhdGggY2Fubm90IGJlIHRyYXZlcnNlZCBmdXJ0aGVyIGFzICcke3BhcmVudEtleX0nIGhhcyBubyBjaGlsZCBub2Rlcy5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsgLi4uY29udGV4dCwgcGFyZW50S2V5IH1cbiAgICApO1xuICAgIHRoaXMucGFyZW50S2V5ID0gcGFyZW50S2V5O1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL0Nvb3JkaW5hdGVFcnJvci50c1xudmFyIENvb3JkaW5hdGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGt0YTtcbiAgc2NvcGVzO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBrdGEsIHNjb3BlcywgY29udGV4dCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIFwiXCIsIHsgLi4uY29udGV4dCwga3RhLCBzY29wZXMgfSk7XG4gICAgdGhpcy5rdGEgPSBrdGE7XG4gICAgdGhpcy5zY29wZXMgPSBzY29wZXM7XG4gIH1cbn07XG52YXIgSW52YWxpZENvb3JkaW5hdGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa3RhLCBzY29wZXMsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgY29vcmRpbmF0ZSBwYXJhbWV0ZXJzOiAke3JlYXNvbn0uIEtUQTogJHtKU09OLnN0cmluZ2lmeShrdGEpfSwgU2NvcGVzOiBbJHtzY29wZXMuam9pbihcIiwgXCIpfV1gLFxuICAgICAga3RhLFxuICAgICAgc2NvcGVzLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24gfVxuICAgICk7XG4gIH1cbn07XG52YXIgSW52YWxpZEtUQUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrdGEsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgS1RBIChLZXkgVHlwZSBBcnJheSk6ICR7cmVhc29ufS4gRXhwZWN0ZWQgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGdvdDogJHtKU09OLnN0cmluZ2lmeShrdGEpfWAsXG4gICAgICBrdGEsXG4gICAgICBbXSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uIH1cbiAgICApO1xuICB9XG59O1xudmFyIEludmFsaWRTY29wZXNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgaW52YWxpZFNjb3BlcztcbiAgY29uc3RydWN0b3Ioc2NvcGVzLCBpbnZhbGlkU2NvcGVzLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhbGlkIHNjb3BlczogJHtyZWFzb259LiBJbnZhbGlkIHNjb3BlIHZhbHVlczogJHtKU09OLnN0cmluZ2lmeShpbnZhbGlkU2NvcGVzKX1gLFxuICAgICAgbnVsbCxcbiAgICAgIHNjb3Blcy5maWx0ZXIoKHMpID0+IHR5cGVvZiBzID09PSBcInN0cmluZ1wiKSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uLCBpbnZhbGlkU2NvcGVzIH1cbiAgICApO1xuICAgIHRoaXMuaW52YWxpZFNjb3BlcyA9IGludmFsaWRTY29wZXM7XG4gIH1cbn07XG5leHBvcnQge1xuICBDb29yZGluYXRlRXJyb3IsXG4gIER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yLFxuICBJbnN0YW5jZUVycm9yLFxuICBJbnN0YW5jZU5vdEZvdW5kRXJyb3IsXG4gIEludmFsaWRDb29yZGluYXRlRXJyb3IsXG4gIEludmFsaWRGYWN0b3J5UmVzdWx0RXJyb3IsXG4gIEludmFsaWRJbnN0YW5jZVJlZ2lzdHJhdGlvbkVycm9yLFxuICBJbnZhbGlkS1RBRXJyb3IsXG4gIEludmFsaWRSZWdpc3RyeUZhY3RvcnlSZXN1bHRFcnJvcixcbiAgSW52YWxpZFNjb3Blc0Vycm9yLFxuICBOb0NoaWxkcmVuQXZhaWxhYmxlRXJyb3IsXG4gIE5vSW5zdGFuY2VzQXZhaWxhYmxlRXJyb3IsXG4gIE5vSW5zdGFuY2VzUmVnaXN0ZXJlZEVycm9yLFxuICBSZWdpc3RyeUNyZWF0aW9uRXJyb3IsXG4gIFJlZ2lzdHJ5RXJyb3IsXG4gIFJlZ2lzdHJ5RmFjdG9yeUVycm9yLFxuICBSZWdpc3RyeUh1YkVycm9yLFxuICBSZWdpc3RyeVN0YXRzLFxuICBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yLFxuICBTY29wZU5vdEZvdW5kRXJyb3IsXG4gIGNyZWF0ZUNvb3JkaW5hdGUsXG4gIGNyZWF0ZUluc3RhbmNlLFxuICBjcmVhdGVSZWdpc3RyeSxcbiAgY3JlYXRlUmVnaXN0cnlIdWIsXG4gIGlzSW5zdGFuY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../fjell-cache/node_modules/@fjell/registry/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-client-api/node_modules/@fjell/core/dist/index.js":
/*!******************************************************************!*\
  !*** ../fjell-client-api/node_modules/@fjell/core/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItemService: () => (/* binding */ AItemService),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   IFactory: () => (/* binding */ IFactory),\n/* harmony export */   IQFactory: () => (/* binding */ IQFactory),\n/* harmony export */   abbrevAgg: () => (/* binding */ abbrevAgg),\n/* harmony export */   abbrevCompoundCondition: () => (/* binding */ abbrevCompoundCondition),\n/* harmony export */   abbrevCondition: () => (/* binding */ abbrevCondition),\n/* harmony export */   abbrevIK: () => (/* binding */ abbrevIK),\n/* harmony export */   abbrevLKA: () => (/* binding */ abbrevLKA),\n/* harmony export */   abbrevQuery: () => (/* binding */ abbrevQuery),\n/* harmony export */   abbrevRef: () => (/* binding */ abbrevRef),\n/* harmony export */   cPK: () => (/* binding */ cPK),\n/* harmony export */   constructPriKey: () => (/* binding */ constructPriKey),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   generateKeyArray: () => (/* binding */ generateKeyArray),\n/* harmony export */   ikToLKA: () => (/* binding */ ikToLKA),\n/* harmony export */   isComItem: () => (/* binding */ isComItem),\n/* harmony export */   isComKey: () => (/* binding */ isComKey),\n/* harmony export */   isComKeyEqual: () => (/* binding */ isComKeyEqual),\n/* harmony export */   isComKeyEqualNormalized: () => (/* binding */ isComKeyEqualNormalized),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isItemKey: () => (/* binding */ isItemKey),\n/* harmony export */   isItemKeyEqual: () => (/* binding */ isItemKeyEqual),\n/* harmony export */   isItemKeyEqualNormalized: () => (/* binding */ isItemKeyEqualNormalized),\n/* harmony export */   isLocKey: () => (/* binding */ isLocKey),\n/* harmony export */   isLocKeyEqual: () => (/* binding */ isLocKeyEqual),\n/* harmony export */   isLocKeyEqualNormalized: () => (/* binding */ isLocKeyEqualNormalized),\n/* harmony export */   isPriItem: () => (/* binding */ isPriItem),\n/* harmony export */   isPriKey: () => (/* binding */ isPriKey),\n/* harmony export */   isPriKeyEqual: () => (/* binding */ isPriKeyEqual),\n/* harmony export */   isPriKeyEqualNormalized: () => (/* binding */ isPriKeyEqualNormalized),\n/* harmony export */   isQueryMatch: () => (/* binding */ isQueryMatch),\n/* harmony export */   isValidComKey: () => (/* binding */ isValidComKey),\n/* harmony export */   isValidItemKey: () => (/* binding */ isValidItemKey),\n/* harmony export */   isValidLocKey: () => (/* binding */ isValidLocKey),\n/* harmony export */   isValidLocKeyArray: () => (/* binding */ isValidLocKeyArray),\n/* harmony export */   isValidPriKey: () => (/* binding */ isValidPriKey),\n/* harmony export */   itemKeyToLocKeyArray: () => (/* binding */ itemKeyToLocKeyArray),\n/* harmony export */   lkaToIK: () => (/* binding */ lkaToIK),\n/* harmony export */   locKeyArrayToItemKey: () => (/* binding */ locKeyArrayToItemKey),\n/* harmony export */   paramsToQuery: () => (/* binding */ paramsToQuery),\n/* harmony export */   primaryType: () => (/* binding */ primaryType),\n/* harmony export */   queryToParams: () => (/* binding */ queryToParams),\n/* harmony export */   toKeyTypeArray: () => (/* binding */ toKeyTypeArray),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys),\n/* harmony export */   validatePK: () => (/* binding */ validatePK)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../fjell-client-api/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! luxon */ \"(ssr)/../fjell-client-api/node_modules/luxon/src/luxon.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/core\");\nvar logger_default = LibLogger;\n\n// src/dictionary.ts\nvar logger = logger_default.get(\"Dictionary\");\nvar Dictionary = class _Dictionary {\n  map = {};\n  hashFunction = (key) => JSON.stringify(key);\n  constructor(map, hashFunction) {\n    if (hashFunction) {\n      this.hashFunction = hashFunction;\n    }\n    if (map) {\n      Object.entries(map).forEach(([hashedKey, value]) => {\n        try {\n          const originalKey = JSON.parse(hashedKey);\n          this.map[hashedKey] = { originalKey, value };\n        } catch {\n          logger.warning(\"Cannot recover original key from legacy map entry\", { hashedKey });\n        }\n      });\n    }\n  }\n  set(key, item) {\n    logger.trace(\"set\", { key, item });\n    const hashedKey = this.hashFunction(key);\n    this.map[hashedKey] = { originalKey: key, value: item };\n  }\n  get(key) {\n    logger.trace(\"get\", { key });\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry && this.keysEqual(entry.originalKey, key) ? entry.value : null;\n  }\n  keysEqual(key1, key2) {\n    return key1 === key2;\n  }\n  delete(key) {\n    logger.trace(\"delete\", { key });\n    const hashedKey = this.hashFunction(key);\n    delete this.map[hashedKey];\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  includesKey(key) {\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry ? this.keysEqual(entry.originalKey, key) : false;\n  }\n  clone() {\n    const clonedMap = {};\n    Object.entries(this.map).forEach(([hashedKey, entry]) => {\n      clonedMap[hashedKey] = entry.value;\n    });\n    const clone = new _Dictionary(clonedMap, this.hashFunction);\n    clone.map = Object.assign({}, this.map);\n    return clone;\n  }\n};\n\n// src/item/IFactory.ts\n\n\n// src/key/KUtils.ts\nvar logger2 = logger_default.get(\"KUtils\");\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && (normalizedKey.pk !== void 0 && normalizedKey.pk !== null)) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && (normalizedKey.lk !== void 0 && normalizedKey.lk !== null)) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && (locItem.lk !== void 0 && locItem.lk !== null)) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return JSON.stringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isPriKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isPriKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.pk) === normalizeKeyValue(b.pk) && a.kt === b.kt;\n};\nvar isLocKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isLocKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.lk) === normalizeKeyValue(b.lk) && a.kt === b.kt;\n};\nvar isComKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isComKeyEqualNormalized\", { a, b });\n  if (a && b && isPriKeyEqualNormalized({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqualNormalized(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isItemKeyEqualNormalized\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqualNormalized(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqualNormalized(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqual = (a, b) => {\n  logger2.trace(\"isKeyEqual\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqual(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqual(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isPriKeyEqual = (a, b) => {\n  logger2.trace(\"isPriKeyEqual\", { a, b });\n  return a && b && a.pk === b.pk && a.kt === b.kt;\n};\nvar isLocKeyEqual = (a, b) => {\n  logger2.trace(\"isLocKeyEqual\", { a, b });\n  return a && b && a.lk === b.lk && a.kt === b.kt;\n};\nvar isComKeyEqual = (a, b) => {\n  logger2.trace(\"isComKeyEqual\", { a, b });\n  if (a && b && isPriKeyEqual({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqual(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKey = (key) => {\n  logger2.trace(\"isItemKey\", { key });\n  return key !== void 0 && (isComKey(key) || isPriKey(key));\n};\nvar isComKey = (key) => {\n  logger2.trace(\"isComKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc !== void 0 && key.loc.length > 0);\n};\nvar isPriKey = (key) => {\n  logger2.trace(\"isPriKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc === void 0 || key.loc.length === 0);\n};\nvar isLocKey = (key) => {\n  logger2.trace(\"isLocKey\", { key });\n  return key !== void 0 && (key.lk !== void 0 && key.kt !== void 0);\n};\nvar generateKeyArray = (key) => {\n  logger2.trace(\"generateKeyArray\", { key });\n  const keys = [];\n  if (isComKey(key) || isPriKey(key)) {\n    if (isComKey(key)) {\n      const comKey = key;\n      keys.push({ pk: comKey.pk, kt: comKey.kt });\n      for (let i = 0; i < comKey.loc.length; i++) {\n        keys.push(comKey.loc[i]);\n      }\n    } else {\n      keys.push(key);\n    }\n  } else {\n    const locKeys = key;\n    for (let i = 0; i < locKeys.length; i++) {\n      keys.push(locKeys[i]);\n    }\n  }\n  return keys;\n};\nvar constructPriKey = (pk, kt) => {\n  logger2.trace(\"constructPriKey\", { pk, kt });\n  let pri;\n  if (typeof pk === \"string\" || typeof pk === \"number\") {\n    pri = { kt, pk };\n  } else {\n    pri = pk;\n  }\n  return pri;\n};\nvar cPK = constructPriKey;\nvar toKeyTypeArray = (ik) => {\n  logger2.trace(\"toKeyTypeArray\", { ik });\n  if (isComKey(ik)) {\n    const ck = ik;\n    return [ck.kt, ...ck.loc.map((l) => l.kt)];\n  } else {\n    return [ik.kt];\n  }\n};\nvar abbrevIK = (ik) => {\n  logger2.trace(\"abbrevIK\", { ik });\n  if (ik) {\n    if (isComKey(ik)) {\n      const ck = ik;\n      return `${ck.kt}:${ck.pk}:${ck.loc.map((l) => `${l.kt}:${l.lk}`).join(\",\")}`;\n    } else {\n      return `${ik.kt}:${ik.pk}`;\n    }\n  } else {\n    return \"null IK\";\n  }\n};\nvar abbrevLKA = (keyArray) => {\n  logger2.trace(\"abbrevLKA\", { keyArray });\n  if (keyArray === void 0 || keyArray === null) {\n    return \"null LKA\";\n  } else {\n    return keyArray.map((key) => {\n      if (key) {\n        return `${key.kt}:${key.lk}`;\n      } else {\n        return key;\n      }\n    }).join(\",\");\n  }\n};\nvar primaryType = (ik) => {\n  logger2.trace(\"primaryType\", { ik });\n  if (isComKey(ik)) {\n    return ik.kt;\n  } else {\n    return ik.kt;\n  }\n};\nvar itemKeyToLocKeyArray = (ik) => {\n  logger2.trace(\"itemKeyToLocKeyArray\", { ik: abbrevIK(ik) });\n  let lka = [];\n  if (isComKey(ik)) {\n    const ck = ik;\n    lka = [{ kt: ck.kt, lk: ck.pk }, ...ck.loc];\n  } else {\n    const pk = ik;\n    lka = [{ kt: pk.kt, lk: pk.pk }];\n  }\n  logger2.trace(\"itemKeyToLocKeyArray Results\", { ik: abbrevIK(ik), lka: abbrevLKA(lka) });\n  return lka;\n};\nvar ikToLKA = itemKeyToLocKeyArray;\nvar locKeyArrayToItemKey = (lka) => {\n  logger2.trace(\"locKeyArrayToItemKey\", { lka: abbrevLKA(lka) });\n  if (lka && lka.length === 1) {\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    return priKey;\n  } else if (lka && lka.length > 1 && lka[0] !== void 0) {\n    const locs = lka.slice(1);\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    const comKey = { kt: priKey.kt, pk: priKey.pk, loc: locs };\n    return comKey;\n  } else {\n    throw new Error(\"locKeyArrayToItemKey: lka is undefined or empty\");\n  }\n};\nvar isValidPriKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.pk !== void 0 && key.pk !== null && key.pk !== \"\" && key.pk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.lk !== void 0 && key.lk !== null && key.lk !== \"\" && key.lk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKeyArray = (keyArray) => {\n  return keyArray !== void 0 && keyArray !== null && keyArray.every(isValidLocKey);\n};\nvar isValidComKey = (key) => {\n  return key !== void 0 && key !== null && isValidPriKey(key) && isValidLocKeyArray(key.loc);\n};\nvar isValidItemKey = (key) => {\n  return isComKey(key) && isValidComKey(key) || isPriKey(key) && isValidPriKey(key);\n};\nvar lkaToIK = locKeyArrayToItemKey;\n\n// src/item/IFactory.ts\nvar IFactory = class _IFactory {\n  item = {};\n  constructor(props = {}) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n  }\n  addRef(i, name) {\n    const ik = i.key;\n    const refName = name || primaryType(ik);\n    if (!this.item.refs) {\n      this.item.refs = {};\n    }\n    this.item.refs[refName] = ik;\n    return this;\n  }\n  static addRef(i, name) {\n    return new _IFactory().addRef(i, name);\n  }\n  addDefaultEvents() {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    const now = /* @__PURE__ */ new Date();\n    if (!this.item.events.created) {\n      this.item.events.created = { at: now };\n    }\n    if (!this.item.events.updated) {\n      this.item.events.updated = { at: now };\n    }\n    if (!this.item.events.deleted) {\n      this.item.events.deleted = { at: null };\n    }\n    return this;\n  }\n  addEvent(name, at, by) {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    this.item.events[name] = { at, by };\n    return this;\n  }\n  static addEvent(name, at, by) {\n    return new _IFactory().addEvent(name, at, by);\n  }\n  addProp(name, value) {\n    this.item[name] = value;\n    return this;\n  }\n  static addProp(name, value) {\n    return new _IFactory().addProp(name, value);\n  }\n  addProps(props) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n    return this;\n  }\n  static addProps(props) {\n    return new _IFactory().addProps(props);\n  }\n  toItem() {\n    return this.item;\n  }\n};\n\n// src/AItemService.ts\nvar AItemService = class {\n  pkType;\n  parentService = null;\n  constructor(pkType, parentService) {\n    this.pkType = pkType;\n    if (parentService) {\n      this.parentService = parentService;\n    }\n  }\n  getPkType = () => {\n    return this.pkType;\n  };\n  getKeyTypes = () => {\n    let keyTypes = [this.getPkType()];\n    if (this.parentService) {\n      keyTypes = keyTypes.concat(this.parentService.getKeyTypes());\n    }\n    return keyTypes;\n  };\n};\n\n// src/item/ItemQuery.ts\nvar isCondition = (condition) => {\n  return (typeof condition.column === \"string\" && (Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"string\")) || Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"number\") || typeof condition.value === \"string\" || typeof condition.value === \"number\" || typeof condition.value === \"boolean\" || condition.value instanceof Date) && (condition.operator ? typeof condition.operator === \"string\" : true);\n};\n\n// src/item/IQFactory.ts\nvar IQFactory = class _IQFactory {\n  query = {};\n  constructor(query = {}) {\n    this.query = query;\n  }\n  orderBy(field, direction = \"asc\") {\n    if (!this.query.orderBy) {\n      this.query.orderBy = [];\n    }\n    this.query.orderBy.push({ field, direction });\n    return this;\n  }\n  agg(name, query) {\n    if (!this.query.aggs) {\n      this.query.aggs = {};\n    }\n    this.query.aggs[name] = query;\n    return this;\n  }\n  event(name, query) {\n    if (!this.query.events) {\n      this.query.events = {};\n    }\n    this.query.events[name] = query;\n    return this;\n  }\n  conditions(conditions, compoundType = \"AND\") {\n    for (const condition of conditions) {\n      if (!isCondition(condition)) {\n        throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n      }\n    }\n    if (!this.query.compoundCondition) {\n      this.query.compoundCondition = {\n        compoundType,\n        conditions\n      };\n    } else {\n      const compoundCondition = {\n        compoundType,\n        conditions\n      };\n      this.query.compoundCondition.conditions.push(compoundCondition);\n    }\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  // TODO: right now, we're only supporting PK refs for queries.  Should add support for CKs\n  pk(kt, pk, name) {\n    if (!this.query.refs) {\n      this.query.refs = {};\n    }\n    const refName = name || kt;\n    this.query.refs[refName] = cPK(pk, kt);\n    return this;\n  }\n  condition(column, value, operator = \"==\") {\n    const condition = { column, value, operator };\n    if (isCondition(condition)) {\n      if (!this.query.compoundCondition) {\n        this.query.compoundCondition = {\n          compoundType: \"AND\",\n          conditions: []\n        };\n      }\n      this.query.compoundCondition.conditions.push(condition);\n      return this;\n    } else {\n      throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n    }\n  }\n  static all() {\n    const iqFactory = new _IQFactory();\n    return iqFactory;\n  }\n  static orderBy(field, direction = \"asc\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.orderBy(field, direction);\n  }\n  static agg(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.agg(name, query);\n  }\n  static event(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.event(name, query);\n  }\n  static limit(limit) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.limit(limit);\n  }\n  static offset(offset) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.offset(offset);\n  }\n  static pk(kt, pk, name) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.pk(kt, pk, name);\n  }\n  static condition(column, value, operator = \"==\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.condition(column, value, operator);\n  }\n  static conditions(conditions, compoundType = \"AND\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.conditions(conditions, compoundType);\n  }\n  toQuery() {\n    return this.query;\n  }\n};\n\n// src/item/IQUtils.ts\n\nvar logger3 = logger_default.get(\"IQUtils\");\nvar queryToParams = (query) => {\n  const params = {};\n  if (query.compoundCondition) {\n    params.compoundCondition = JSON.stringify(query.compoundCondition);\n  }\n  if (query.refs) {\n    params.refs = JSON.stringify(query.refs);\n  }\n  if (query.limit) {\n    params.limit = query.limit;\n  }\n  if (query.offset) {\n    params.offset = query.offset;\n  }\n  if (query.aggs) {\n    params.aggs = JSON.stringify(query.aggs);\n  }\n  if (query.events) {\n    params.events = JSON.stringify(query.events);\n  }\n  return params;\n};\nvar dateTimeReviver = function(key, value) {\n  if (typeof value === \"string\") {\n    const parsedDate = luxon__WEBPACK_IMPORTED_MODULE_2__.DateTime.fromISO(value);\n    if (parsedDate.isValid) {\n      return parsedDate.toJSDate();\n      ;\n    }\n  }\n  return value;\n};\nvar paramsToQuery = (params) => {\n  const query = {};\n  if (params.compoundCondition) {\n    query.compoundCondition = JSON.parse(params.compoundCondition);\n  }\n  if (params.refs) {\n    query.refs = JSON.parse(params.refs);\n  }\n  if (params.limit) {\n    query.limit = Number(params.limit);\n  }\n  if (params.offset) {\n    query.offset = Number(params.offset);\n  }\n  if (params.aggs) {\n    query.aggs = JSON.parse(params.aggs);\n  }\n  if (params.events) {\n    query.events = JSON.parse(params.events, dateTimeReviver);\n  }\n  return query;\n};\nvar isRefQueryMatch = (refKey, queryRef, references) => {\n  logger3.trace(\"doesRefMatch\", { queryRef, references });\n  logger3.debug(\"Comparing Ref\", { refKey, itemRef: references[refKey], queryRef });\n  return isItemKeyEqual(queryRef, references[refKey]);\n};\nvar isCompoundConditionQueryMatch = (queryCondition, item) => {\n  if (queryCondition.compoundType === \"AND\") {\n    return queryCondition.conditions.every(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  } else {\n    return queryCondition.conditions.some(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  }\n};\nvar isConditionQueryMatch = (queryCondition, item) => {\n  const propKey = queryCondition.column;\n  logger3.trace(\"doesConditionMatch\", { propKey, queryCondition, item });\n  if (item[propKey] === void 0) {\n    logger3.debug(\"Item does not contain prop under key\", { propKey, item });\n    return false;\n  }\n  logger3.debug(\"Comparing Condition\", { propKey, itemProp: item[propKey], queryCondition });\n  let result = false;\n  switch (queryCondition.operator) {\n    case \"==\":\n      result = item[propKey] === queryCondition.value;\n      break;\n    case \"!=\":\n      result = item[propKey] !== queryCondition.value;\n      break;\n    case \">\":\n      result = item[propKey] > queryCondition.value;\n      break;\n    case \">=\":\n      result = item[propKey] >= queryCondition.value;\n      break;\n    case \"<\":\n      result = item[propKey] < queryCondition.value;\n      break;\n    case \"<=\":\n      result = item[propKey] <= queryCondition.value;\n      break;\n    case \"in\":\n      result = queryCondition.value.includes(item[propKey]);\n      break;\n    case \"not-in\":\n      result = !queryCondition.value.includes(item[propKey]);\n      break;\n    case \"array-contains\":\n      result = item[propKey].includes(queryCondition.value);\n      break;\n    case \"array-contains-any\":\n      result = queryCondition.value.some((value) => item[propKey].includes(value));\n      break;\n  }\n  return result;\n};\nvar isAggQueryMatch = (aggKey, aggQuery, agg) => {\n  const aggItem = agg.item;\n  logger3.debug(\"Comparing Agg\", { aggKey, aggItem, aggQuery });\n  return isQueryMatch(aggItem, aggQuery);\n};\nvar isEventQueryMatch = (eventKey, eventQuery, item) => {\n  if (!item.events[eventKey]) {\n    logger3.debug(\"Item does not contain event under key\", { eventKey, events: item.events });\n    return false;\n  } else {\n    const itemEvent = item.events[eventKey];\n    if (itemEvent.at !== null) {\n      if (eventQuery.start && !(eventQuery.start.getTime() <= itemEvent.at.getTime())) {\n        logger3.debug(\"Item date before event start query\", { eventQuery, itemEvent });\n        return false;\n      }\n      if (eventQuery.end && !(eventQuery.end.getTime() > itemEvent.at.getTime())) {\n        logger3.debug(\"Item date after event end query\", { eventQuery, itemEvent });\n        return false;\n      }\n    } else {\n      logger3.debug(\"Item event does contains a null at\", { itemEvent });\n      return false;\n    }\n    return true;\n  }\n};\nvar isQueryMatch = (item, query) => {\n  logger3.trace(\"isMatch\", { item, query });\n  if (query.refs && item.refs) {\n    for (const key in query.refs) {\n      const queryRef = query.refs[key];\n      if (!isRefQueryMatch(key, queryRef, item.refs)) return false;\n    }\n  } else if (query.refs && !item.refs) {\n    logger3.debug(\"Query contains refs but item does not have refs\", { query, item });\n    return false;\n  }\n  if (query.compoundCondition && item) {\n    if (!isCompoundConditionQueryMatch(query.compoundCondition, item)) return false;\n  }\n  if (query.events && item.events) {\n    for (const key in query.events) {\n      const queryEvent = query.events[key];\n      if (!isEventQueryMatch(key, queryEvent, item)) return false;\n    }\n    return true;\n  }\n  if (query.aggs && item.aggs) {\n    for (const key in query.aggs) {\n      const aggQuery = query.aggs[key];\n      if (item.aggs[key] && !isAggQueryMatch(key, aggQuery, item.aggs[key])) return false;\n    }\n  }\n  if (query.aggs && !item.aggs) {\n    logger3.debug(\"Query contains aggs but item does not have aggs\", { query, item });\n    return false;\n  }\n  return true;\n};\nvar abbrevQuery = (query) => {\n  const abbrev = [\"IQ\"];\n  if (query) {\n    if (query.refs) {\n      for (const key in query.refs) {\n        const ref = abbrevRef(key, query.refs[key]);\n        abbrev.push(ref);\n      }\n    }\n    if (query.compoundCondition) {\n      const props = abbrevCompoundCondition(query.compoundCondition);\n      abbrev.push(props);\n    }\n    if (query.aggs) {\n      for (const key in query.aggs) {\n        const agg = abbrevAgg(key, query.aggs[key]);\n        abbrev.push(agg);\n      }\n    }\n    if (query.events) {\n      const events = `(E${Object.keys(query.events).join(\",\")})`;\n      abbrev.push(events);\n    }\n    if (query.limit) {\n      abbrev.push(`L${query.limit}`);\n    }\n    if (query.offset) {\n      abbrev.push(`O${query.offset}`);\n    }\n  } else {\n    abbrev.push(\"(empty)\");\n  }\n  return abbrev.join(\" \");\n};\nvar abbrevRef = (key, ref) => {\n  if (isPriKey(ref)) {\n    const priKey = ref;\n    return `R(${key},${priKey.kt},${priKey.pk})`;\n  } else {\n    const comKey = ref;\n    return `R(${key},${JSON.stringify(comKey)})`;\n  }\n};\nvar abbrevAgg = (key, agg) => {\n  return `A(${key},${abbrevQuery(agg)})`;\n};\nvar abbrevCompoundCondition = (compoundCondition) => {\n  return `CC(${compoundCondition.compoundType},${compoundCondition.conditions ? compoundCondition.conditions.map(abbrevCondition).join(\",\") : \"No Conditions\"})`;\n};\nvar abbrevCondition = (condition) => {\n  if (isCondition(condition)) {\n    return `(${condition.column},${condition.value},${condition.operator})`;\n  } else {\n    return abbrevCompoundCondition(condition);\n  }\n};\n\n// src/item/IUtils.ts\nvar logger4 = logger_default.get(\"IUtils\");\nvar validatePKForItem = (item, pkType) => {\n  if (!item) {\n    logger4.error(\"Validating PK, Item is undefined\", { item });\n    throw new Error(\"Validating PK, Item is undefined\");\n  }\n  if (!item.key) {\n    logger4.error(\"Validating PK, Item does not have a key\", { item });\n    throw new Error(\"Validating PK, Item does not have a key\");\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray[0] !== pkType) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, pkType });\n    throw new Error(`Item does not have the correct primary key type. Expected ${pkType}, got ${keyTypeArray[0]}`);\n  }\n  return item;\n};\nvar validatePK = (input, pkType) => {\n  logger4.trace(\"Checking Return Type\", { input });\n  if (Array.isArray(input)) {\n    return input.map((item) => validatePKForItem(item, pkType));\n  }\n  return validatePKForItem(input, pkType);\n};\nvar validateKeys = (item, keyTypes) => {\n  logger4.trace(\"Checking Return Type\", { item });\n  if (!item) {\n    throw new Error(\"validating keys, item is undefined\");\n  }\n  if (!item.key) {\n    throw new Error(\"validating keys, item does not have a key: \" + JSON.stringify(item));\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray.length !== keyTypes.length) {\n    throw new Error(`Item does not have the correct number of keys. Expected ${keyTypes.length}, but got ${keyTypeArray.length}`);\n  }\n  const match = JSON.stringify(keyTypeArray) === JSON.stringify(keyTypes);\n  if (!match) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, thisKeyTypes: keyTypes });\n    throw new Error(`Item does not have the correct key types. Expected [${keyTypes.join(\", \")}], but got [${keyTypeArray.join(\", \")}]`);\n  }\n  return item;\n};\nvar isPriItem = (item) => {\n  return !!(item && item.key && isPriKey(item.key));\n};\nvar isComItem = (item) => {\n  return !!(item && item.key && isComKey(item.key));\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvQGZqZWxsL2NvcmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDcUM7QUFDckMsZ0JBQWdCLGdFQUFpQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxVQUFVO0FBQ1YsZ0ZBQWdGLFdBQVc7QUFDM0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ2tDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25ELDBDQUEwQyxvQkFBb0IsSUFBSSxvQkFBb0I7QUFDdEY7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FB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O0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGdCQUFnQixZQUFZLG9CQUFvQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0NBQXNDO0FBQ3JGLDJFQUEyRSxvQkFBb0IsY0FBYyx3QkFBd0I7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0RFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvQGZqZWxsL2NvcmUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbG9nZ2VyLnRzXG5pbXBvcnQgTG9nZ2luZyBmcm9tIFwiQGZqZWxsL2xvZ2dpbmdcIjtcbnZhciBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcihcIkBmamVsbC9jb3JlXCIpO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTGliTG9nZ2VyO1xuXG4vLyBzcmMvZGljdGlvbmFyeS50c1xudmFyIGxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkRpY3Rpb25hcnlcIik7XG52YXIgRGljdGlvbmFyeSA9IGNsYXNzIF9EaWN0aW9uYXJ5IHtcbiAgbWFwID0ge307XG4gIGhhc2hGdW5jdGlvbiA9IChrZXkpID0+IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIGNvbnN0cnVjdG9yKG1hcCwgaGFzaEZ1bmN0aW9uKSB7XG4gICAgaWYgKGhhc2hGdW5jdGlvbikge1xuICAgICAgdGhpcy5oYXNoRnVuY3Rpb24gPSBoYXNoRnVuY3Rpb247XG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG1hcCkuZm9yRWFjaCgoW2hhc2hlZEtleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBKU09OLnBhcnNlKGhhc2hlZEtleSk7XG4gICAgICAgICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHsgb3JpZ2luYWxLZXksIHZhbHVlIH07XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGxvZ2dlci53YXJuaW5nKFwiQ2Fubm90IHJlY292ZXIgb3JpZ2luYWwga2V5IGZyb20gbGVnYWN5IG1hcCBlbnRyeVwiLCB7IGhhc2hlZEtleSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNldChrZXksIGl0ZW0pIHtcbiAgICBsb2dnZXIudHJhY2UoXCJzZXRcIiwgeyBrZXksIGl0ZW0gfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICB0aGlzLm1hcFtoYXNoZWRLZXldID0geyBvcmlnaW5hbEtleToga2V5LCB2YWx1ZTogaXRlbSB9O1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBsb2dnZXIudHJhY2UoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgcmV0dXJuIGVudHJ5ICYmIHRoaXMua2V5c0VxdWFsKGVudHJ5Lm9yaWdpbmFsS2V5LCBrZXkpID8gZW50cnkudmFsdWUgOiBudWxsO1xuICB9XG4gIGtleXNFcXVhbChrZXkxLCBrZXkyKSB7XG4gICAgcmV0dXJuIGtleTEgPT09IGtleTI7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIGxvZ2dlci50cmFjZShcImRlbGV0ZVwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcCgoZW50cnkpID0+IGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgfVxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKTtcbiAgfVxuICBpbmNsdWRlc0tleShrZXkpIHtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICByZXR1cm4gZW50cnkgPyB0aGlzLmtleXNFcXVhbChlbnRyeS5vcmlnaW5hbEtleSwga2V5KSA6IGZhbHNlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lZE1hcCA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMubWFwKS5mb3JFYWNoKChbaGFzaGVkS2V5LCBlbnRyeV0pID0+IHtcbiAgICAgIGNsb25lZE1hcFtoYXNoZWRLZXldID0gZW50cnkudmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgX0RpY3Rpb25hcnkoY2xvbmVkTWFwLCB0aGlzLmhhc2hGdW5jdGlvbik7XG4gICAgY2xvbmUubWFwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5tYXApO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufTtcblxuLy8gc3JjL2l0ZW0vSUZhY3RvcnkudHNcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSBcImRlZXBtZXJnZVwiO1xuXG4vLyBzcmMva2V5L0tVdGlscy50c1xudmFyIGxvZ2dlcjIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJLVXRpbHNcIik7XG52YXIgbm9ybWFsaXplS2V5VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xudmFyIGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24gPSAoKSA9PiB7XG4gIHJldHVybiAoa2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShrZXkpKTtcbiAgICAgIGlmIChcInBrXCIgaW4gbm9ybWFsaXplZEtleSAmJiAobm9ybWFsaXplZEtleS5wayAhPT0gdm9pZCAwICYmIG5vcm1hbGl6ZWRLZXkucGsgIT09IG51bGwpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkucGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LnBrKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImxrXCIgaW4gbm9ybWFsaXplZEtleSAmJiAobm9ybWFsaXplZEtleS5sayAhPT0gdm9pZCAwICYmIG5vcm1hbGl6ZWRLZXkubGsgIT09IG51bGwpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LmxrKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImxvY1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgQXJyYXkuaXNBcnJheShub3JtYWxpemVkS2V5LmxvYykpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5sb2MgPSBub3JtYWxpemVkS2V5LmxvYy5tYXAoKGxvY0l0ZW0pID0+IHtcbiAgICAgICAgICBpZiAobG9jSXRlbSAmJiBcImxrXCIgaW4gbG9jSXRlbSAmJiAobG9jSXRlbS5sayAhPT0gdm9pZCAwICYmIGxvY0l0ZW0ubGsgIT09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5sb2NJdGVtLCBsazogbm9ybWFsaXplS2V5VmFsdWUobG9jSXRlbS5saykgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY0l0ZW07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgfTtcbn07XG52YXIgaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIG5vcm1hbGl6ZUtleVZhbHVlKGEucGspID09PSBub3JtYWxpemVLZXlWYWx1ZShiLnBrKSAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0xvY0tleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0xvY0tleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgbm9ybWFsaXplS2V5VmFsdWUoYS5saykgPT09IG5vcm1hbGl6ZUtleVZhbHVlKGIubGspICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzQ29tS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzQ29tS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGEgJiYgYiAmJiBpc1ByaUtleUVxdWFsTm9ybWFsaXplZCh7IGt0OiBhLmt0LCBwazogYS5wayB9LCB7IGt0OiBiLmt0LCBwazogYi5wayB9KSkge1xuICAgIGlmIChhLmxvYy5sZW5ndGggPT09IGIubG9jLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTG9jS2V5RXF1YWxOb3JtYWxpemVkKGEubG9jW2ldLCBiLmxvY1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGlzQ29tS2V5KGEpICYmIGlzQ29tS2V5KGIpKSB7XG4gICAgcmV0dXJuIGlzQ29tS2V5RXF1YWxOb3JtYWxpemVkKGEsIGIpO1xuICB9IGVsc2UgaWYgKGlzUHJpS2V5KGEpICYmIGlzUHJpS2V5KGIpKSB7XG4gICAgaWYgKGlzQ29tS2V5KGEpIHx8IGlzQ29tS2V5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc1ByaUtleUVxdWFsTm9ybWFsaXplZChhLCBiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzSXRlbUtleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICBpZiAoaXNDb21LZXkoYSkgJiYgaXNDb21LZXkoYikpIHtcbiAgICByZXR1cm4gaXNDb21LZXlFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmIChpc1ByaUtleShhKSAmJiBpc1ByaUtleShiKSkge1xuICAgIGlmIChpc0NvbUtleShhKSB8fCBpc0NvbUtleShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNQcmlLZXlFcXVhbChhLCBiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzUHJpS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNQcmlLZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgYS5wayA9PT0gYi5wayAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0xvY0tleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzTG9jS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIGEubGsgPT09IGIubGsgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNDb21LZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0NvbUtleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGEgJiYgYiAmJiBpc1ByaUtleUVxdWFsKHsga3Q6IGEua3QsIHBrOiBhLnBrIH0sIHsga3Q6IGIua3QsIHBrOiBiLnBrIH0pKSB7XG4gICAgaWYgKGEubG9jLmxlbmd0aCA9PT0gYi5sb2MubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNMb2NLZXlFcXVhbChhLmxvY1tpXSwgYi5sb2NbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNJdGVtS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNJdGVtS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGlzQ29tS2V5KGtleSkgfHwgaXNQcmlLZXkoa2V5KSk7XG59O1xudmFyIGlzQ29tS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNDb21LZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoa2V5LnBrICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSB2b2lkIDApICYmIChrZXkubG9jICE9PSB2b2lkIDAgJiYga2V5LmxvYy5sZW5ndGggPiAwKTtcbn07XG52YXIgaXNQcmlLZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc1ByaUtleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChrZXkucGsgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IHZvaWQgMCkgJiYgKGtleS5sb2MgPT09IHZvaWQgMCB8fCBrZXkubG9jLmxlbmd0aCA9PT0gMCk7XG59O1xudmFyIGlzTG9jS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNMb2NLZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoa2V5LmxrICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSB2b2lkIDApO1xufTtcbnZhciBnZW5lcmF0ZUtleUFycmF5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiZ2VuZXJhdGVLZXlBcnJheVwiLCB7IGtleSB9KTtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBpZiAoaXNDb21LZXkoa2V5KSB8fCBpc1ByaUtleShrZXkpKSB7XG4gICAgaWYgKGlzQ29tS2V5KGtleSkpIHtcbiAgICAgIGNvbnN0IGNvbUtleSA9IGtleTtcbiAgICAgIGtleXMucHVzaCh7IHBrOiBjb21LZXkucGssIGt0OiBjb21LZXkua3QgfSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbUtleS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5cy5wdXNoKGNvbUtleS5sb2NbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbG9jS2V5cyA9IGtleTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaChsb2NLZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIGNvbnN0cnVjdFByaUtleSA9IChwaywga3QpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImNvbnN0cnVjdFByaUtleVwiLCB7IHBrLCBrdCB9KTtcbiAgbGV0IHByaTtcbiAgaWYgKHR5cGVvZiBwayA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGsgPT09IFwibnVtYmVyXCIpIHtcbiAgICBwcmkgPSB7IGt0LCBwayB9O1xuICB9IGVsc2Uge1xuICAgIHByaSA9IHBrO1xuICB9XG4gIHJldHVybiBwcmk7XG59O1xudmFyIGNQSyA9IGNvbnN0cnVjdFByaUtleTtcbnZhciB0b0tleVR5cGVBcnJheSA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwidG9LZXlUeXBlQXJyYXlcIiwgeyBpayB9KTtcbiAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgIGNvbnN0IGNrID0gaWs7XG4gICAgcmV0dXJuIFtjay5rdCwgLi4uY2subG9jLm1hcCgobCkgPT4gbC5rdCldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaWsua3RdO1xuICB9XG59O1xudmFyIGFiYnJldklLID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJhYmJyZXZJS1wiLCB7IGlrIH0pO1xuICBpZiAoaWspIHtcbiAgICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgICBjb25zdCBjayA9IGlrO1xuICAgICAgcmV0dXJuIGAke2NrLmt0fToke2NrLnBrfToke2NrLmxvYy5tYXAoKGwpID0+IGAke2wua3R9OiR7bC5sa31gKS5qb2luKFwiLFwiKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7aWsua3R9OiR7aWsucGt9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwibnVsbCBJS1wiO1xuICB9XG59O1xudmFyIGFiYnJldkxLQSA9IChrZXlBcnJheSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiYWJicmV2TEtBXCIsIHsga2V5QXJyYXkgfSk7XG4gIGlmIChrZXlBcnJheSA9PT0gdm9pZCAwIHx8IGtleUFycmF5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbCBMS0FcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5QXJyYXkubWFwKChrZXkpID0+IHtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGAke2tleS5rdH06JHtrZXkubGt9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfSkuam9pbihcIixcIik7XG4gIH1cbn07XG52YXIgcHJpbWFyeVR5cGUgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcInByaW1hcnlUeXBlXCIsIHsgaWsgfSk7XG4gIGlmIChpc0NvbUtleShpaykpIHtcbiAgICByZXR1cm4gaWsua3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlrLmt0O1xuICB9XG59O1xudmFyIGl0ZW1LZXlUb0xvY0tleUFycmF5ID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpdGVtS2V5VG9Mb2NLZXlBcnJheVwiLCB7IGlrOiBhYmJyZXZJSyhpaykgfSk7XG4gIGxldCBsa2EgPSBbXTtcbiAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgIGNvbnN0IGNrID0gaWs7XG4gICAgbGthID0gW3sga3Q6IGNrLmt0LCBsazogY2sucGsgfSwgLi4uY2subG9jXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwayA9IGlrO1xuICAgIGxrYSA9IFt7IGt0OiBway5rdCwgbGs6IHBrLnBrIH1dO1xuICB9XG4gIGxvZ2dlcjIudHJhY2UoXCJpdGVtS2V5VG9Mb2NLZXlBcnJheSBSZXN1bHRzXCIsIHsgaWs6IGFiYnJldklLKGlrKSwgbGthOiBhYmJyZXZMS0EobGthKSB9KTtcbiAgcmV0dXJuIGxrYTtcbn07XG52YXIgaWtUb0xLQSA9IGl0ZW1LZXlUb0xvY0tleUFycmF5O1xudmFyIGxvY0tleUFycmF5VG9JdGVtS2V5ID0gKGxrYSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwibG9jS2V5QXJyYXlUb0l0ZW1LZXlcIiwgeyBsa2E6IGFiYnJldkxLQShsa2EpIH0pO1xuICBpZiAobGthICYmIGxrYS5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBwcmlLZXkgPSBjUEsobGthWzBdLmxrLCBsa2FbMF0ua3QpO1xuICAgIHJldHVybiBwcmlLZXk7XG4gIH0gZWxzZSBpZiAobGthICYmIGxrYS5sZW5ndGggPiAxICYmIGxrYVswXSAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbG9jcyA9IGxrYS5zbGljZSgxKTtcbiAgICBjb25zdCBwcmlLZXkgPSBjUEsobGthWzBdLmxrLCBsa2FbMF0ua3QpO1xuICAgIGNvbnN0IGNvbUtleSA9IHsga3Q6IHByaUtleS5rdCwgcGs6IHByaUtleS5waywgbG9jOiBsb2NzIH07XG4gICAgcmV0dXJuIGNvbUtleTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2NLZXlBcnJheVRvSXRlbUtleTogbGthIGlzIHVuZGVmaW5lZCBvciBlbXB0eVwiKTtcbiAgfVxufTtcbnZhciBpc1ZhbGlkUHJpS2V5ID0gKGtleSkgPT4ge1xuICBjb25zdCB2YWxpZCA9IGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gbnVsbCAmJiAoa2V5LnBrICE9PSB2b2lkIDAgJiYga2V5LnBrICE9PSBudWxsICYmIGtleS5wayAhPT0gXCJcIiAmJiBrZXkucGsgIT09IFwibnVsbFwiKSAmJiAoa2V5Lmt0ICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSBudWxsICYmIGtleS5rdCAhPT0gXCJcIiAmJiBrZXkua3QgIT09IFwibnVsbFwiKTtcbiAgcmV0dXJuIHZhbGlkO1xufTtcbnZhciBpc1ZhbGlkTG9jS2V5ID0gKGtleSkgPT4ge1xuICBjb25zdCB2YWxpZCA9IGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gbnVsbCAmJiAoa2V5LmxrICE9PSB2b2lkIDAgJiYga2V5LmxrICE9PSBudWxsICYmIGtleS5sayAhPT0gXCJcIiAmJiBrZXkubGsgIT09IFwibnVsbFwiKSAmJiAoa2V5Lmt0ICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSBudWxsICYmIGtleS5rdCAhPT0gXCJcIiAmJiBrZXkua3QgIT09IFwibnVsbFwiKTtcbiAgcmV0dXJuIHZhbGlkO1xufTtcbnZhciBpc1ZhbGlkTG9jS2V5QXJyYXkgPSAoa2V5QXJyYXkpID0+IHtcbiAgcmV0dXJuIGtleUFycmF5ICE9PSB2b2lkIDAgJiYga2V5QXJyYXkgIT09IG51bGwgJiYga2V5QXJyYXkuZXZlcnkoaXNWYWxpZExvY0tleSk7XG59O1xudmFyIGlzVmFsaWRDb21LZXkgPSAoa2V5KSA9PiB7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IG51bGwgJiYgaXNWYWxpZFByaUtleShrZXkpICYmIGlzVmFsaWRMb2NLZXlBcnJheShrZXkubG9jKTtcbn07XG52YXIgaXNWYWxpZEl0ZW1LZXkgPSAoa2V5KSA9PiB7XG4gIHJldHVybiBpc0NvbUtleShrZXkpICYmIGlzVmFsaWRDb21LZXkoa2V5KSB8fCBpc1ByaUtleShrZXkpICYmIGlzVmFsaWRQcmlLZXkoa2V5KTtcbn07XG52YXIgbGthVG9JSyA9IGxvY0tleUFycmF5VG9JdGVtS2V5O1xuXG4vLyBzcmMvaXRlbS9JRmFjdG9yeS50c1xudmFyIElGYWN0b3J5ID0gY2xhc3MgX0lGYWN0b3J5IHtcbiAgaXRlbSA9IHt9O1xuICBjb25zdHJ1Y3Rvcihwcm9wcyA9IHt9KSB7XG4gICAgdGhpcy5pdGVtID0gZGVlcG1lcmdlKHRoaXMuaXRlbSwgcHJvcHMpO1xuICB9XG4gIGFkZFJlZihpLCBuYW1lKSB7XG4gICAgY29uc3QgaWsgPSBpLmtleTtcbiAgICBjb25zdCByZWZOYW1lID0gbmFtZSB8fCBwcmltYXJ5VHlwZShpayk7XG4gICAgaWYgKCF0aGlzLml0ZW0ucmVmcykge1xuICAgICAgdGhpcy5pdGVtLnJlZnMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLnJlZnNbcmVmTmFtZV0gPSBpaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkUmVmKGksIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZFJlZihpLCBuYW1lKTtcbiAgfVxuICBhZGREZWZhdWx0RXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cykge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMuY3JlYXRlZCkge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cy5jcmVhdGVkID0geyBhdDogbm93IH07XG4gICAgfVxuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cy51cGRhdGVkKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzLnVwZGF0ZWQgPSB7IGF0OiBub3cgfTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzLmRlbGV0ZWQpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMuZGVsZXRlZCA9IHsgYXQ6IG51bGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkRXZlbnQobmFtZSwgYXQsIGJ5KSB7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzID0ge307XG4gICAgfVxuICAgIHRoaXMuaXRlbS5ldmVudHNbbmFtZV0gPSB7IGF0LCBieSB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRFdmVudChuYW1lLCBhdCwgYnkpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZEV2ZW50KG5hbWUsIGF0LCBieSk7XG4gIH1cbiAgYWRkUHJvcChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuaXRlbVtuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRQcm9wKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRQcm9wKG5hbWUsIHZhbHVlKTtcbiAgfVxuICBhZGRQcm9wcyhwcm9wcykge1xuICAgIHRoaXMuaXRlbSA9IGRlZXBtZXJnZSh0aGlzLml0ZW0sIHByb3BzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZFByb3BzKHByb3BzKTtcbiAgfVxuICB0b0l0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxufTtcblxuLy8gc3JjL0FJdGVtU2VydmljZS50c1xudmFyIEFJdGVtU2VydmljZSA9IGNsYXNzIHtcbiAgcGtUeXBlO1xuICBwYXJlbnRTZXJ2aWNlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGtUeXBlLCBwYXJlbnRTZXJ2aWNlKSB7XG4gICAgdGhpcy5wa1R5cGUgPSBwa1R5cGU7XG4gICAgaWYgKHBhcmVudFNlcnZpY2UpIHtcbiAgICAgIHRoaXMucGFyZW50U2VydmljZSA9IHBhcmVudFNlcnZpY2U7XG4gICAgfVxuICB9XG4gIGdldFBrVHlwZSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5wa1R5cGU7XG4gIH07XG4gIGdldEtleVR5cGVzID0gKCkgPT4ge1xuICAgIGxldCBrZXlUeXBlcyA9IFt0aGlzLmdldFBrVHlwZSgpXTtcbiAgICBpZiAodGhpcy5wYXJlbnRTZXJ2aWNlKSB7XG4gICAgICBrZXlUeXBlcyA9IGtleVR5cGVzLmNvbmNhdCh0aGlzLnBhcmVudFNlcnZpY2UuZ2V0S2V5VHlwZXMoKSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlUeXBlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9pdGVtL0l0ZW1RdWVyeS50c1xudmFyIGlzQ29uZGl0aW9uID0gKGNvbmRpdGlvbikgPT4ge1xuICByZXR1cm4gKHR5cGVvZiBjb25kaXRpb24uY29sdW1uID09PSBcInN0cmluZ1wiICYmIChBcnJheS5pc0FycmF5KGNvbmRpdGlvbi52YWx1ZSkgJiYgY29uZGl0aW9uLnZhbHVlLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikpIHx8IEFycmF5LmlzQXJyYXkoY29uZGl0aW9uLnZhbHVlKSAmJiBjb25kaXRpb24udmFsdWUuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiKSB8fCB0eXBlb2YgY29uZGl0aW9uLnZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjb25kaXRpb24udmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbmRpdGlvbi52YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgY29uZGl0aW9uLnZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgKGNvbmRpdGlvbi5vcGVyYXRvciA/IHR5cGVvZiBjb25kaXRpb24ub3BlcmF0b3IgPT09IFwic3RyaW5nXCIgOiB0cnVlKTtcbn07XG5cbi8vIHNyYy9pdGVtL0lRRmFjdG9yeS50c1xudmFyIElRRmFjdG9yeSA9IGNsYXNzIF9JUUZhY3Rvcnkge1xuICBxdWVyeSA9IHt9O1xuICBjb25zdHJ1Y3RvcihxdWVyeSA9IHt9KSB7XG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICB9XG4gIG9yZGVyQnkoZmllbGQsIGRpcmVjdGlvbiA9IFwiYXNjXCIpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkub3JkZXJCeSkge1xuICAgICAgdGhpcy5xdWVyeS5vcmRlckJ5ID0gW107XG4gICAgfVxuICAgIHRoaXMucXVlcnkub3JkZXJCeS5wdXNoKHsgZmllbGQsIGRpcmVjdGlvbiB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZ2cobmFtZSwgcXVlcnkpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkuYWdncykge1xuICAgICAgdGhpcy5xdWVyeS5hZ2dzID0ge307XG4gICAgfVxuICAgIHRoaXMucXVlcnkuYWdnc1tuYW1lXSA9IHF1ZXJ5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGV2ZW50KG5hbWUsIHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LmV2ZW50cykge1xuICAgICAgdGhpcy5xdWVyeS5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeS5ldmVudHNbbmFtZV0gPSBxdWVyeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb25kaXRpb25zKGNvbmRpdGlvbnMsIGNvbXBvdW5kVHlwZSA9IFwiQU5EXCIpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbiBvZiBjb25kaXRpb25zKSB7XG4gICAgICBpZiAoIWlzQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbmRpdGlvbjogJHtKU09OLnN0cmluZ2lmeShjb25kaXRpb24pfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24gPSB7XG4gICAgICAgIGNvbXBvdW5kVHlwZSxcbiAgICAgICAgY29uZGl0aW9uc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcG91bmRDb25kaXRpb24gPSB7XG4gICAgICAgIGNvbXBvdW5kVHlwZSxcbiAgICAgICAgY29uZGl0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucy5wdXNoKGNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGltaXQobGltaXQpIHtcbiAgICB0aGlzLnF1ZXJ5LmxpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMucXVlcnkub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIFRPRE86IHJpZ2h0IG5vdywgd2UncmUgb25seSBzdXBwb3J0aW5nIFBLIHJlZnMgZm9yIHF1ZXJpZXMuICBTaG91bGQgYWRkIHN1cHBvcnQgZm9yIENLc1xuICBwayhrdCwgcGssIG5hbWUpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkucmVmcykge1xuICAgICAgdGhpcy5xdWVyeS5yZWZzID0ge307XG4gICAgfVxuICAgIGNvbnN0IHJlZk5hbWUgPSBuYW1lIHx8IGt0O1xuICAgIHRoaXMucXVlcnkucmVmc1tyZWZOYW1lXSA9IGNQSyhwaywga3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbmRpdGlvbihjb2x1bW4sIHZhbHVlLCBvcGVyYXRvciA9IFwiPT1cIikge1xuICAgIGNvbnN0IGNvbmRpdGlvbiA9IHsgY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IgfTtcbiAgICBpZiAoaXNDb25kaXRpb24oY29uZGl0aW9uKSkge1xuICAgICAgaWYgKCF0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24gPSB7XG4gICAgICAgICAgY29tcG91bmRUeXBlOiBcIkFORFwiLFxuICAgICAgICAgIGNvbmRpdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb25kaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoY29uZGl0aW9uKX1gKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFsbCgpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3Rvcnk7XG4gIH1cbiAgc3RhdGljIG9yZGVyQnkoZmllbGQsIGRpcmVjdGlvbiA9IFwiYXNjXCIpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3Rvcnkub3JkZXJCeShmaWVsZCwgZGlyZWN0aW9uKTtcbiAgfVxuICBzdGF0aWMgYWdnKG5hbWUsIHF1ZXJ5KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmFnZyhuYW1lLCBxdWVyeSk7XG4gIH1cbiAgc3RhdGljIGV2ZW50KG5hbWUsIHF1ZXJ5KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmV2ZW50KG5hbWUsIHF1ZXJ5KTtcbiAgfVxuICBzdGF0aWMgbGltaXQobGltaXQpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkubGltaXQobGltaXQpO1xuICB9XG4gIHN0YXRpYyBvZmZzZXQob2Zmc2V0KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5Lm9mZnNldChvZmZzZXQpO1xuICB9XG4gIHN0YXRpYyBwayhrdCwgcGssIG5hbWUpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkucGsoa3QsIHBrLCBuYW1lKTtcbiAgfVxuICBzdGF0aWMgY29uZGl0aW9uKGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yID0gXCI9PVwiKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmNvbmRpdGlvbihjb2x1bW4sIHZhbHVlLCBvcGVyYXRvcik7XG4gIH1cbiAgc3RhdGljIGNvbmRpdGlvbnMoY29uZGl0aW9ucywgY29tcG91bmRUeXBlID0gXCJBTkRcIikge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5jb25kaXRpb25zKGNvbmRpdGlvbnMsIGNvbXBvdW5kVHlwZSk7XG4gIH1cbiAgdG9RdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeTtcbiAgfVxufTtcblxuLy8gc3JjL2l0ZW0vSVFVdGlscy50c1xuaW1wb3J0ICogYXMgbHV4b24gZnJvbSBcImx1eG9uXCI7XG52YXIgbG9nZ2VyMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIklRVXRpbHNcIik7XG52YXIgcXVlcnlUb1BhcmFtcyA9IChxdWVyeSkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgaWYgKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgcGFyYW1zLmNvbXBvdW5kQ29uZGl0aW9uID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuY29tcG91bmRDb25kaXRpb24pO1xuICB9XG4gIGlmIChxdWVyeS5yZWZzKSB7XG4gICAgcGFyYW1zLnJlZnMgPSBKU09OLnN0cmluZ2lmeShxdWVyeS5yZWZzKTtcbiAgfVxuICBpZiAocXVlcnkubGltaXQpIHtcbiAgICBwYXJhbXMubGltaXQgPSBxdWVyeS5saW1pdDtcbiAgfVxuICBpZiAocXVlcnkub2Zmc2V0KSB7XG4gICAgcGFyYW1zLm9mZnNldCA9IHF1ZXJ5Lm9mZnNldDtcbiAgfVxuICBpZiAocXVlcnkuYWdncykge1xuICAgIHBhcmFtcy5hZ2dzID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuYWdncyk7XG4gIH1cbiAgaWYgKHF1ZXJ5LmV2ZW50cykge1xuICAgIHBhcmFtcy5ldmVudHMgPSBKU09OLnN0cmluZ2lmeShxdWVyeS5ldmVudHMpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xudmFyIGRhdGVUaW1lUmV2aXZlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHBhcnNlZERhdGUgPSBsdXhvbi5EYXRlVGltZS5mcm9tSVNPKHZhbHVlKTtcbiAgICBpZiAocGFyc2VkRGF0ZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGF0ZS50b0pTRGF0ZSgpO1xuICAgICAgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIHBhcmFtc1RvUXVlcnkgPSAocGFyYW1zKSA9PiB7XG4gIGNvbnN0IHF1ZXJ5ID0ge307XG4gIGlmIChwYXJhbXMuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICBxdWVyeS5jb21wb3VuZENvbmRpdGlvbiA9IEpTT04ucGFyc2UocGFyYW1zLmNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgfVxuICBpZiAocGFyYW1zLnJlZnMpIHtcbiAgICBxdWVyeS5yZWZzID0gSlNPTi5wYXJzZShwYXJhbXMucmVmcyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgIHF1ZXJ5LmxpbWl0ID0gTnVtYmVyKHBhcmFtcy5saW1pdCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5vZmZzZXQpIHtcbiAgICBxdWVyeS5vZmZzZXQgPSBOdW1iZXIocGFyYW1zLm9mZnNldCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5hZ2dzKSB7XG4gICAgcXVlcnkuYWdncyA9IEpTT04ucGFyc2UocGFyYW1zLmFnZ3MpO1xuICB9XG4gIGlmIChwYXJhbXMuZXZlbnRzKSB7XG4gICAgcXVlcnkuZXZlbnRzID0gSlNPTi5wYXJzZShwYXJhbXMuZXZlbnRzLCBkYXRlVGltZVJldml2ZXIpO1xuICB9XG4gIHJldHVybiBxdWVyeTtcbn07XG52YXIgaXNSZWZRdWVyeU1hdGNoID0gKHJlZktleSwgcXVlcnlSZWYsIHJlZmVyZW5jZXMpID0+IHtcbiAgbG9nZ2VyMy50cmFjZShcImRvZXNSZWZNYXRjaFwiLCB7IHF1ZXJ5UmVmLCByZWZlcmVuY2VzIH0pO1xuICBsb2dnZXIzLmRlYnVnKFwiQ29tcGFyaW5nIFJlZlwiLCB7IHJlZktleSwgaXRlbVJlZjogcmVmZXJlbmNlc1tyZWZLZXldLCBxdWVyeVJlZiB9KTtcbiAgcmV0dXJuIGlzSXRlbUtleUVxdWFsKHF1ZXJ5UmVmLCByZWZlcmVuY2VzW3JlZktleV0pO1xufTtcbnZhciBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaCA9IChxdWVyeUNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICBpZiAocXVlcnlDb25kaXRpb24uY29tcG91bmRUeXBlID09PSBcIkFORFwiKSB7XG4gICAgcmV0dXJuIHF1ZXJ5Q29uZGl0aW9uLmNvbmRpdGlvbnMuZXZlcnkoXG4gICAgICAoY29uZGl0aW9uKSA9PiBpc0NvbmRpdGlvbihjb25kaXRpb24pID8gaXNDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSkgOiBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcXVlcnlDb25kaXRpb24uY29uZGl0aW9ucy5zb21lKFxuICAgICAgKGNvbmRpdGlvbikgPT4gaXNDb25kaXRpb24oY29uZGl0aW9uKSA/IGlzQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pIDogaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKVxuICAgICk7XG4gIH1cbn07XG52YXIgaXNDb25kaXRpb25RdWVyeU1hdGNoID0gKHF1ZXJ5Q29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gIGNvbnN0IHByb3BLZXkgPSBxdWVyeUNvbmRpdGlvbi5jb2x1bW47XG4gIGxvZ2dlcjMudHJhY2UoXCJkb2VzQ29uZGl0aW9uTWF0Y2hcIiwgeyBwcm9wS2V5LCBxdWVyeUNvbmRpdGlvbiwgaXRlbSB9KTtcbiAgaWYgKGl0ZW1bcHJvcEtleV0gPT09IHZvaWQgMCkge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRvZXMgbm90IGNvbnRhaW4gcHJvcCB1bmRlciBrZXlcIiwgeyBwcm9wS2V5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2dnZXIzLmRlYnVnKFwiQ29tcGFyaW5nIENvbmRpdGlvblwiLCB7IHByb3BLZXksIGl0ZW1Qcm9wOiBpdGVtW3Byb3BLZXldLCBxdWVyeUNvbmRpdGlvbiB9KTtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICBzd2l0Y2ggKHF1ZXJ5Q29uZGl0aW9uLm9wZXJhdG9yKSB7XG4gICAgY2FzZSBcIj09XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldID09PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIhPVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSAhPT0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPlwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA+IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIj49XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldID49IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIjxcIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPCBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI8PVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA8PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpblwiOlxuICAgICAgcmVzdWx0ID0gcXVlcnlDb25kaXRpb24udmFsdWUuaW5jbHVkZXMoaXRlbVtwcm9wS2V5XSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibm90LWluXCI6XG4gICAgICByZXN1bHQgPSAhcXVlcnlDb25kaXRpb24udmFsdWUuaW5jbHVkZXMoaXRlbVtwcm9wS2V5XSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJyYXktY29udGFpbnNcIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0uaW5jbHVkZXMocXVlcnlDb25kaXRpb24udmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFycmF5LWNvbnRhaW5zLWFueVwiOlxuICAgICAgcmVzdWx0ID0gcXVlcnlDb25kaXRpb24udmFsdWUuc29tZSgodmFsdWUpID0+IGl0ZW1bcHJvcEtleV0uaW5jbHVkZXModmFsdWUpKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGlzQWdnUXVlcnlNYXRjaCA9IChhZ2dLZXksIGFnZ1F1ZXJ5LCBhZ2cpID0+IHtcbiAgY29uc3QgYWdnSXRlbSA9IGFnZy5pdGVtO1xuICBsb2dnZXIzLmRlYnVnKFwiQ29tcGFyaW5nIEFnZ1wiLCB7IGFnZ0tleSwgYWdnSXRlbSwgYWdnUXVlcnkgfSk7XG4gIHJldHVybiBpc1F1ZXJ5TWF0Y2goYWdnSXRlbSwgYWdnUXVlcnkpO1xufTtcbnZhciBpc0V2ZW50UXVlcnlNYXRjaCA9IChldmVudEtleSwgZXZlbnRRdWVyeSwgaXRlbSkgPT4ge1xuICBpZiAoIWl0ZW0uZXZlbnRzW2V2ZW50S2V5XSkge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRvZXMgbm90IGNvbnRhaW4gZXZlbnQgdW5kZXIga2V5XCIsIHsgZXZlbnRLZXksIGV2ZW50czogaXRlbS5ldmVudHMgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGl0ZW1FdmVudCA9IGl0ZW0uZXZlbnRzW2V2ZW50S2V5XTtcbiAgICBpZiAoaXRlbUV2ZW50LmF0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXZlbnRRdWVyeS5zdGFydCAmJiAhKGV2ZW50UXVlcnkuc3RhcnQuZ2V0VGltZSgpIDw9IGl0ZW1FdmVudC5hdC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRhdGUgYmVmb3JlIGV2ZW50IHN0YXJ0IHF1ZXJ5XCIsIHsgZXZlbnRRdWVyeSwgaXRlbUV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRRdWVyeS5lbmQgJiYgIShldmVudFF1ZXJ5LmVuZC5nZXRUaW1lKCkgPiBpdGVtRXZlbnQuYXQuZ2V0VGltZSgpKSkge1xuICAgICAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkYXRlIGFmdGVyIGV2ZW50IGVuZCBxdWVyeVwiLCB7IGV2ZW50UXVlcnksIGl0ZW1FdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBldmVudCBkb2VzIGNvbnRhaW5zIGEgbnVsbCBhdFwiLCB7IGl0ZW1FdmVudCB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgaXNRdWVyeU1hdGNoID0gKGl0ZW0sIHF1ZXJ5KSA9PiB7XG4gIGxvZ2dlcjMudHJhY2UoXCJpc01hdGNoXCIsIHsgaXRlbSwgcXVlcnkgfSk7XG4gIGlmIChxdWVyeS5yZWZzICYmIGl0ZW0ucmVmcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LnJlZnMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5UmVmID0gcXVlcnkucmVmc1trZXldO1xuICAgICAgaWYgKCFpc1JlZlF1ZXJ5TWF0Y2goa2V5LCBxdWVyeVJlZiwgaXRlbS5yZWZzKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChxdWVyeS5yZWZzICYmICFpdGVtLnJlZnMpIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiUXVlcnkgY29udGFpbnMgcmVmcyBidXQgaXRlbSBkb2VzIG5vdCBoYXZlIHJlZnNcIiwgeyBxdWVyeSwgaXRlbSB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uICYmIGl0ZW0pIHtcbiAgICBpZiAoIWlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uLCBpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChxdWVyeS5ldmVudHMgJiYgaXRlbS5ldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5ldmVudHMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5RXZlbnQgPSBxdWVyeS5ldmVudHNba2V5XTtcbiAgICAgIGlmICghaXNFdmVudFF1ZXJ5TWF0Y2goa2V5LCBxdWVyeUV2ZW50LCBpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocXVlcnkuYWdncyAmJiBpdGVtLmFnZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5hZ2dzKSB7XG4gICAgICBjb25zdCBhZ2dRdWVyeSA9IHF1ZXJ5LmFnZ3Nba2V5XTtcbiAgICAgIGlmIChpdGVtLmFnZ3Nba2V5XSAmJiAhaXNBZ2dRdWVyeU1hdGNoKGtleSwgYWdnUXVlcnksIGl0ZW0uYWdnc1trZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAocXVlcnkuYWdncyAmJiAhaXRlbS5hZ2dzKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIlF1ZXJ5IGNvbnRhaW5zIGFnZ3MgYnV0IGl0ZW0gZG9lcyBub3QgaGF2ZSBhZ2dzXCIsIHsgcXVlcnksIGl0ZW0gfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBhYmJyZXZRdWVyeSA9IChxdWVyeSkgPT4ge1xuICBjb25zdCBhYmJyZXYgPSBbXCJJUVwiXTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5LnJlZnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LnJlZnMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gYWJicmV2UmVmKGtleSwgcXVlcnkucmVmc1trZXldKTtcbiAgICAgICAgYWJicmV2LnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgICAgIGFiYnJldi5wdXNoKHByb3BzKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmFnZ3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LmFnZ3MpIHtcbiAgICAgICAgY29uc3QgYWdnID0gYWJicmV2QWdnKGtleSwgcXVlcnkuYWdnc1trZXldKTtcbiAgICAgICAgYWJicmV2LnB1c2goYWdnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmV2ZW50cykge1xuICAgICAgY29uc3QgZXZlbnRzID0gYChFJHtPYmplY3Qua2V5cyhxdWVyeS5ldmVudHMpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgYWJicmV2LnB1c2goZXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmxpbWl0KSB7XG4gICAgICBhYmJyZXYucHVzaChgTCR7cXVlcnkubGltaXR9YCk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5vZmZzZXQpIHtcbiAgICAgIGFiYnJldi5wdXNoKGBPJHtxdWVyeS5vZmZzZXR9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFiYnJldi5wdXNoKFwiKGVtcHR5KVwiKTtcbiAgfVxuICByZXR1cm4gYWJicmV2LmpvaW4oXCIgXCIpO1xufTtcbnZhciBhYmJyZXZSZWYgPSAoa2V5LCByZWYpID0+IHtcbiAgaWYgKGlzUHJpS2V5KHJlZikpIHtcbiAgICBjb25zdCBwcmlLZXkgPSByZWY7XG4gICAgcmV0dXJuIGBSKCR7a2V5fSwke3ByaUtleS5rdH0sJHtwcmlLZXkucGt9KWA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29tS2V5ID0gcmVmO1xuICAgIHJldHVybiBgUigke2tleX0sJHtKU09OLnN0cmluZ2lmeShjb21LZXkpfSlgO1xuICB9XG59O1xudmFyIGFiYnJldkFnZyA9IChrZXksIGFnZykgPT4ge1xuICByZXR1cm4gYEEoJHtrZXl9LCR7YWJicmV2UXVlcnkoYWdnKX0pYDtcbn07XG52YXIgYWJicmV2Q29tcG91bmRDb25kaXRpb24gPSAoY29tcG91bmRDb25kaXRpb24pID0+IHtcbiAgcmV0dXJuIGBDQygke2NvbXBvdW5kQ29uZGl0aW9uLmNvbXBvdW5kVHlwZX0sJHtjb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zID8gY29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucy5tYXAoYWJicmV2Q29uZGl0aW9uKS5qb2luKFwiLFwiKSA6IFwiTm8gQ29uZGl0aW9uc1wifSlgO1xufTtcbnZhciBhYmJyZXZDb25kaXRpb24gPSAoY29uZGl0aW9uKSA9PiB7XG4gIGlmIChpc0NvbmRpdGlvbihjb25kaXRpb24pKSB7XG4gICAgcmV0dXJuIGAoJHtjb25kaXRpb24uY29sdW1ufSwke2NvbmRpdGlvbi52YWx1ZX0sJHtjb25kaXRpb24ub3BlcmF0b3J9KWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uKGNvbmRpdGlvbik7XG4gIH1cbn07XG5cbi8vIHNyYy9pdGVtL0lVdGlscy50c1xudmFyIGxvZ2dlcjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJVXRpbHNcIik7XG52YXIgdmFsaWRhdGVQS0Zvckl0ZW0gPSAoaXRlbSwgcGtUeXBlKSA9PiB7XG4gIGlmICghaXRlbSkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGlzIHVuZGVmaW5lZFwiLCB7IGl0ZW0gfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBpcyB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKCFpdGVtLmtleSkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGRvZXMgbm90IGhhdmUgYSBrZXlcIiwgeyBpdGVtIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gZG9lcyBub3QgaGF2ZSBhIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlUeXBlQXJyYXkgPSB0b0tleVR5cGVBcnJheShpdGVtLmtleSk7XG4gIGlmIChrZXlUeXBlQXJyYXlbMF0gIT09IHBrVHlwZSkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJLZXkgVHlwZSBBcnJheSBNaXNtYXRjaFwiLCB7IGtleVR5cGVBcnJheSwgcGtUeXBlIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IHByaW1hcnkga2V5IHR5cGUuIEV4cGVjdGVkICR7cGtUeXBlfSwgZ290ICR7a2V5VHlwZUFycmF5WzBdfWApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcbnZhciB2YWxpZGF0ZVBLID0gKGlucHV0LCBwa1R5cGUpID0+IHtcbiAgbG9nZ2VyNC50cmFjZShcIkNoZWNraW5nIFJldHVybiBUeXBlXCIsIHsgaW5wdXQgfSk7XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHZhbGlkYXRlUEtGb3JJdGVtKGl0ZW0sIHBrVHlwZSkpO1xuICB9XG4gIHJldHVybiB2YWxpZGF0ZVBLRm9ySXRlbShpbnB1dCwgcGtUeXBlKTtcbn07XG52YXIgdmFsaWRhdGVLZXlzID0gKGl0ZW0sIGtleVR5cGVzKSA9PiB7XG4gIGxvZ2dlcjQudHJhY2UoXCJDaGVja2luZyBSZXR1cm4gVHlwZVwiLCB7IGl0ZW0gfSk7XG4gIGlmICghaXRlbSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInZhbGlkYXRpbmcga2V5cywgaXRlbSBpcyB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKCFpdGVtLmtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInZhbGlkYXRpbmcga2V5cywgaXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5OiBcIiArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgfVxuICBjb25zdCBrZXlUeXBlQXJyYXkgPSB0b0tleVR5cGVBcnJheShpdGVtLmtleSk7XG4gIGlmIChrZXlUeXBlQXJyYXkubGVuZ3RoICE9PSBrZXlUeXBlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBudW1iZXIgb2Yga2V5cy4gRXhwZWN0ZWQgJHtrZXlUeXBlcy5sZW5ndGh9LCBidXQgZ290ICR7a2V5VHlwZUFycmF5Lmxlbmd0aH1gKTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IEpTT04uc3RyaW5naWZ5KGtleVR5cGVBcnJheSkgPT09IEpTT04uc3RyaW5naWZ5KGtleVR5cGVzKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJLZXkgVHlwZSBBcnJheSBNaXNtYXRjaFwiLCB7IGtleVR5cGVBcnJheSwgdGhpc0tleVR5cGVzOiBrZXlUeXBlcyB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBrZXkgdHlwZXMuIEV4cGVjdGVkIFske2tleVR5cGVzLmpvaW4oXCIsIFwiKX1dLCBidXQgZ290IFske2tleVR5cGVBcnJheS5qb2luKFwiLCBcIil9XWApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcbnZhciBpc1ByaUl0ZW0gPSAoaXRlbSkgPT4ge1xuICByZXR1cm4gISEoaXRlbSAmJiBpdGVtLmtleSAmJiBpc1ByaUtleShpdGVtLmtleSkpO1xufTtcbnZhciBpc0NvbUl0ZW0gPSAoaXRlbSkgPT4ge1xuICByZXR1cm4gISEoaXRlbSAmJiBpdGVtLmtleSAmJiBpc0NvbUtleShpdGVtLmtleSkpO1xufTtcbmV4cG9ydCB7XG4gIEFJdGVtU2VydmljZSxcbiAgRGljdGlvbmFyeSxcbiAgSUZhY3RvcnksXG4gIElRRmFjdG9yeSxcbiAgYWJicmV2QWdnLFxuICBhYmJyZXZDb21wb3VuZENvbmRpdGlvbixcbiAgYWJicmV2Q29uZGl0aW9uLFxuICBhYmJyZXZJSyxcbiAgYWJicmV2TEtBLFxuICBhYmJyZXZRdWVyeSxcbiAgYWJicmV2UmVmLFxuICBjUEssXG4gIGNvbnN0cnVjdFByaUtleSxcbiAgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbixcbiAgZ2VuZXJhdGVLZXlBcnJheSxcbiAgaWtUb0xLQSxcbiAgaXNDb21JdGVtLFxuICBpc0NvbUtleSxcbiAgaXNDb21LZXlFcXVhbCxcbiAgaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzQ29uZGl0aW9uLFxuICBpc0l0ZW1LZXksXG4gIGlzSXRlbUtleUVxdWFsLFxuICBpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzTG9jS2V5LFxuICBpc0xvY0tleUVxdWFsLFxuICBpc0xvY0tleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNQcmlJdGVtLFxuICBpc1ByaUtleSxcbiAgaXNQcmlLZXlFcXVhbCxcbiAgaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzUXVlcnlNYXRjaCxcbiAgaXNWYWxpZENvbUtleSxcbiAgaXNWYWxpZEl0ZW1LZXksXG4gIGlzVmFsaWRMb2NLZXksXG4gIGlzVmFsaWRMb2NLZXlBcnJheSxcbiAgaXNWYWxpZFByaUtleSxcbiAgaXRlbUtleVRvTG9jS2V5QXJyYXksXG4gIGxrYVRvSUssXG4gIGxvY0tleUFycmF5VG9JdGVtS2V5LFxuICBwYXJhbXNUb1F1ZXJ5LFxuICBwcmltYXJ5VHlwZSxcbiAgcXVlcnlUb1BhcmFtcyxcbiAgdG9LZXlUeXBlQXJyYXksXG4gIHZhbGlkYXRlS2V5cyxcbiAgdmFsaWRhdGVQS1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../fjell-client-api/node_modules/@fjell/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js":
/*!*********************************************************************!*\
  !*** ../fjell-client-api/node_modules/@fjell/logging/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvQGZqZWxsL2xvZ2dpbmcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEtBQUs7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFNcEI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9AZmplbGwvbG9nZ2luZy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9Mb2dGb3JtYXQudHNcbnZhciBMb2dGb3JtYXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoTG9nRm9ybWF0X2V4cG9ydHMsIHtcbiAgTG9nRm9ybWF0czogKCkgPT4gTG9nRm9ybWF0cyxcbiAgU1RSVUNUVVJFRDogKCkgPT4gU1RSVUNUVVJFRCxcbiAgVEVYVDogKCkgPT4gVEVYVCxcbiAgZ2V0Q29uZmlnOiAoKSA9PiBnZXRDb25maWdcbn0pO1xudmFyIFRFWFQgPSB7XG4gIG5hbWU6IFwiVEVYVFwiLFxuICBkZXNjcmlwdGlvbjogXCJUZXh0IGZvcm1hdFwiXG59O1xudmFyIFNUUlVDVFVSRUQgPSB7XG4gIG5hbWU6IFwiU1RSVUNUVVJFRFwiLFxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmVkIGZvcm1hdFwiXG59O1xudmFyIExvZ0Zvcm1hdHMgPSBbXG4gIFRFWFQsXG4gIFNUUlVDVFVSRURcbl07XG52YXIgZ2V0Q29uZmlnID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gTG9nRm9ybWF0cy5maW5kKChjb25maWcyKSA9PiBjb25maWcyLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMb2cgRm9ybWF0IFN1cHBsaWVkIHRvIExvZ2dpbmcgQ29uZmlndXJhdGlvbiAnJHtuYW1lfSdgKTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufTtcblxuLy8gc3JjL0xvZ0xldmVsLnRzXG52YXIgTG9nTGV2ZWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoTG9nTGV2ZWxfZXhwb3J0cywge1xuICBBTEVSVDogKCkgPT4gQUxFUlQsXG4gIENSSVRJQ0FMOiAoKSA9PiBDUklUSUNBTCxcbiAgREVCVUc6ICgpID0+IERFQlVHLFxuICBERUZBVUxUOiAoKSA9PiBERUZBVUxULFxuICBFTUVSR0VOQ1k6ICgpID0+IEVNRVJHRU5DWSxcbiAgRVJST1I6ICgpID0+IEVSUk9SLFxuICBJTkZPOiAoKSA9PiBJTkZPLFxuICBMb2dMZXZlbHM6ICgpID0+IExvZ0xldmVscyxcbiAgTk9USUNFOiAoKSA9PiBOT1RJQ0UsXG4gIFRSQUNFOiAoKSA9PiBUUkFDRSxcbiAgV0FSTklORzogKCkgPT4gV0FSTklORyxcbiAgZ2V0Q29uZmlnOiAoKSA9PiBnZXRDb25maWcyXG59KTtcbnZhciBFTUVSR0VOQ1kgPSB7XG4gIG5hbWU6IFwiRU1FUkdFTkNZXCIsXG4gIHZhbHVlOiAwXG59O1xudmFyIEFMRVJUID0ge1xuICBuYW1lOiBcIkFMRVJUXCIsXG4gIHZhbHVlOiAxXG59O1xudmFyIENSSVRJQ0FMID0ge1xuICBuYW1lOiBcIkNSSVRJQ0FMXCIsXG4gIHZhbHVlOiAyXG59O1xudmFyIEVSUk9SID0ge1xuICBuYW1lOiBcIkVSUk9SXCIsXG4gIHZhbHVlOiAzXG59O1xudmFyIFdBUk5JTkcgPSB7XG4gIG5hbWU6IFwiV0FSTklOR1wiLFxuICB2YWx1ZTogNFxufTtcbnZhciBOT1RJQ0UgPSB7XG4gIG5hbWU6IFwiTk9USUNFXCIsXG4gIHZhbHVlOiA1XG59O1xudmFyIElORk8gPSB7XG4gIG5hbWU6IFwiSU5GT1wiLFxuICB2YWx1ZTogNlxufTtcbnZhciBERUJVRyA9IHtcbiAgbmFtZTogXCJERUJVR1wiLFxuICB2YWx1ZTogN1xufTtcbnZhciBUUkFDRSA9IHtcbiAgbmFtZTogXCJUUkFDRVwiLFxuICB2YWx1ZTogOFxufTtcbnZhciBERUZBVUxUID0ge1xuICBuYW1lOiBcIkRFRkFVTFRcIixcbiAgdmFsdWU6IDlcbn07XG52YXIgTG9nTGV2ZWxzID0gW1xuICBFTUVSR0VOQ1ksXG4gIEFMRVJULFxuICBDUklUSUNBTCxcbiAgRVJST1IsXG4gIFdBUk5JTkcsXG4gIE5PVElDRSxcbiAgSU5GTyxcbiAgREVCVUcsXG4gIFRSQUNFLFxuICBERUZBVUxUXG5dO1xudmFyIGdldENvbmZpZzIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dMZXZlbHMuZmluZCgoY29uZmlnMikgPT4gY29uZmlnMi5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG9nIExldmVsIFN1cHBsaWVkIHRvIExvZ2dpbmcgQ29uZmlndXJhdGlvbiAnJHtuYW1lfSdgKTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufTtcblxuLy8gc3JjL2NvbmZpZy50c1xudmFyIGRlZmF1bHRMb2dMZXZlbCA9IElORk87XG52YXIgZGVmYXVsdExvZ0Zvcm1hdCA9IFRFWFQ7XG52YXIgZGVmYXVsdExvZ2dpbmdDb25maWcgPSB7XG4gIGxvZ0xldmVsOiBkZWZhdWx0TG9nTGV2ZWwsXG4gIGxvZ0Zvcm1hdDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgb3ZlcnJpZGVzOiB7fSxcbiAgZmxvb2RDb250cm9sOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgdGhyZXNob2xkOiAxMCxcbiAgICB0aW1lZnJhbWU6IDFlM1xuICAgIC8vIDEgc2Vjb25kXG4gIH1cbn07XG52YXIgY29udmVydE92ZXJyaWRlcyA9IChvdmVycmlkZXMpID0+IHtcbiAgY29uc3QgY29udmVydGVkT3ZlcnJpZGVzID0ge307XG4gIGlmIChvdmVycmlkZXMpIHtcbiAgICBPYmplY3QuZW50cmllcyhvdmVycmlkZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29udmVydGVkT3ZlcnJpZGVzW2tleV0gPSB7IGxvZ0xldmVsOiB2YWx1ZS5sb2dMZXZlbCA/IGdldENvbmZpZzIodmFsdWUubG9nTGV2ZWwpIDogZGVmYXVsdExvZ0xldmVsIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE92ZXJyaWRlcztcbn07XG52YXIgY29udmVydENvbmZpZyA9IChjb25maWcpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBsb2dMZXZlbDogY29uZmlnLmxvZ0xldmVsID8gZ2V0Q29uZmlnMihjb25maWcubG9nTGV2ZWwpIDogZGVmYXVsdExvZ0xldmVsLFxuICAgIGxvZ0Zvcm1hdDogY29uZmlnLmxvZ0Zvcm1hdCA/IGdldENvbmZpZyhjb25maWcubG9nRm9ybWF0KSA6IGRlZmF1bHRMb2dGb3JtYXQsXG4gICAgb3ZlcnJpZGVzOiBjb252ZXJ0T3ZlcnJpZGVzKGNvbmZpZy5vdmVycmlkZXMpLFxuICAgIGZsb29kQ29udHJvbDoge1xuICAgICAgLi4uZGVmYXVsdExvZ2dpbmdDb25maWcuZmxvb2RDb250cm9sLFxuICAgICAgLi4uY29uZmlnLmZsb29kQ29udHJvbCB8fCB7fVxuICAgIH1cbiAgfTtcbn07XG52YXIgY29uZmlndXJlTG9nZ2luZyA9ICgpID0+IHtcbiAgbGV0IGNvbmZpZyA9IHt9O1xuICBjb25zdCBsb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuTE9HR0lOR19DT05GSUc7XG4gIGNvbnN0IGV4cG9Mb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuRVhQT19QVUJMSUNfTE9HR0lOR19DT05GSUc7XG4gIGNvbnN0IG5leHRMb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTE9HR0lOR19DT05GSUc7XG4gIGxldCBsb2dMZXZlbEVudiA9IHByb2Nlc3MuZW52LkxPR19MRVZFTDtcbiAgbGV0IGxvZ0Zvcm1hdEVudiA9IHByb2Nlc3MuZW52LkxPR19GT1JNQVQ7XG4gIGlmIChsb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UobG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBvTG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKGV4cG9Mb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBFWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKG5leHRMb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UobmV4dExvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIE5FWFRfUFVCTElDX0xPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29udmVydGVkQ29uZmlnID0gY29udmVydENvbmZpZyhjb25maWcpO1xuICBpZiAobG9nTGV2ZWxFbnYpIHtcbiAgICBsb2dMZXZlbEVudiA9IGxvZ0xldmVsRW52Py50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGxvZ0xldmVsQ29uZmlnID0gZ2V0Q29uZmlnMihsb2dMZXZlbEVudik7XG4gICAgY29udmVydGVkQ29uZmlnLmxvZ0xldmVsID0gbG9nTGV2ZWxDb25maWc7XG4gIH1cbiAgaWYgKGxvZ0Zvcm1hdEVudikge1xuICAgIGxvZ0Zvcm1hdEVudiA9IGxvZ0Zvcm1hdEVudi50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGxvZ0Zvcm1hdENvbmZpZyA9IGdldENvbmZpZyhsb2dGb3JtYXRFbnYpO1xuICAgIGNvbnZlcnRlZENvbmZpZy5sb2dGb3JtYXQgPSBsb2dGb3JtYXRDb25maWc7XG4gIH1cbiAgY29uc3QgZmluYWxDb25maWcgPSB7IC4uLmRlZmF1bHRMb2dnaW5nQ29uZmlnLCAuLi5jb252ZXJ0ZWRDb25maWcgfTtcbiAgcmV0dXJuIGZpbmFsQ29uZmlnO1xufTtcblxuLy8gc3JjL1dyaXRlci50c1xudmFyIGNyZWF0ZVdyaXRlciA9IChmb3JtYXR0ZXIsIGxvZ01ldGhvZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZXNwZWN0SW5qZWN0ZWRNZXRob2QgPSBmYWxzZSxcbiAgICBlcnJvck1ldGhvZCA9IGNvbnNvbGUuZXJyb3IsXG4gICAgd2FybmluZ01ldGhvZCA9IGNvbnNvbGUud2FybixcbiAgICBpbmZvTWV0aG9kID0gY29uc29sZS5sb2dcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgd3JpdGU6IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICAgIGxldCBmaW5hbExvZ01ldGhvZCA9IGxvZ01ldGhvZDtcbiAgICAgIGlmICghcmVzcGVjdEluamVjdGVkTWV0aG9kKSB7XG4gICAgICAgIGlmIChsZXZlbC5uYW1lID09PSBFUlJPUi5uYW1lIHx8IGxldmVsLm5hbWUgPT09IENSSVRJQ0FMLm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gQUxFUlQubmFtZSB8fCBsZXZlbC5uYW1lID09PSBFTUVSR0VOQ1kubmFtZSkge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gZXJyb3JNZXRob2Q7XG4gICAgICAgIH0gZWxzZSBpZiAobGV2ZWwubmFtZSA9PT0gV0FSTklORy5uYW1lKSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSB3YXJuaW5nTWV0aG9kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gaW5mb01ldGhvZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluYWxMb2dNZXRob2QoZm9ybWF0dGVyLmZvcm1hdExvZyhsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvZm9ybWF0dGVyLnRzXG5pbXBvcnQgdXRpbCBmcm9tIFwidXRpbFwiO1xudmFyIHNhZmVJbnNwZWN0ID0gKG9iaikgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qob2JqKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGBbT2JqZWN0OiAke3R5cGVvZiBvYmp9XWA7XG4gIH1cbn07XG52YXIgc2FmZUZvcm1hdCA9IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuZm9ybWF0KG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYCR7bWVzc2FnZX0gJHtzYWZlSW5zcGVjdChhcmdzKX1gO1xuICB9XG59O1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IChsb2dGb3JtYXQpID0+IHtcbiAgaWYgKGxvZ0Zvcm1hdC5uYW1lID09PSBcIlRFWFRcIikge1xuICAgIHJldHVybiBnZXRUZXh0Rm9ybWF0dGVyKCk7XG4gIH0gZWxzZSBpZiAobG9nRm9ybWF0Lm5hbWUgPT09IFwiU1RSVUNUVVJFRFwiKSB7XG4gICAgcmV0dXJuIGdldFN0cnVjdHVyZWRGb3JtYXR0ZXIoKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbG9nIGZvcm1hdDogJHtsb2dGb3JtYXQubmFtZX1gKTtcbn07XG52YXIgZ2V0VGV4dEZvcm1hdHRlciA9ICgpID0+IHtcbiAgY29uc3QgZm9ybWF0TG9nID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGhhc1NwZWNpZmllcnMgPSAvJVtzZGppZm9PJV0vLnRlc3QocGF5bG9hZC5tZXNzYWdlKTtcbiAgICBsZXQgbG9nTWVzc2FnZTtcbiAgICBpZiAocGF5bG9hZC5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nTWVzc2FnZSA9IHBheWxvYWQubWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKGhhc1NwZWNpZmllcnMpIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nTWVzc2FnZSA9IGAke3BheWxvYWQubWVzc2FnZX0gJHtzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpfWA7XG4gICAgfVxuICAgIHJldHVybiBgKCR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS52YWx1ZU9mKCl9KSBbJHtsZXZlbC5uYW1lfV0gLSBbJHtjb29yZGluYXRlcy5jYXRlZ29yeX1dICR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX0gJHtsb2dNZXNzYWdlfWA7XG4gIH07XG4gIGNvbnN0IHRpbWVyTWVzc2FnZSA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpO1xuICAgIGNvbnN0IHRpbWVyTWVzc2FnZTIgPSBgKCR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS52YWx1ZU9mKCl9KSBbJHtsZXZlbC5uYW1lfV0gLSBbJHtjb29yZGluYXRlcy5jYXRlZ29yeX1dICR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX0gJHtzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKX0gJHtzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpfSAke3JhbmRvbUludH1gO1xuICAgIHJldHVybiB0aW1lck1lc3NhZ2UyO1xuICB9O1xuICByZXR1cm4geyBmb3JtYXRMb2csIHRpbWVyTWVzc2FnZSwgZ2V0TG9nRm9ybWF0OiAoKSA9PiBURVhUIH07XG59O1xudmFyIGdldFN0cnVjdHVyZWRGb3JtYXR0ZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGZvcm1hdExvZyA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzZXZlcml0eSxcbiAgICAgIG1lc3NhZ2U6IGhhc1NwZWNpZmllcnMgPyBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKSA6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9sYWJlbHNcIjoge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IGAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9YFxuICAgICAgfSxcbiAgICAgIC4uLiFoYXNTcGVjaWZpZXJzICYmIHBheWxvYWQuZGF0YS5sZW5ndGggPiAwICYmIHsgZGF0YTogc2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKSB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHRpbWVyTWVzc2FnZSA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG4gICAgY29uc3QgcmFuZG9tSW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU2KTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc2V2ZXJpdHksXG4gICAgICBtZXNzYWdlOiBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9sYWJlbHNcIjoge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IGAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9YFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHNhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSksXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vc3BhbklkXCI6IFN0cmluZyhyYW5kb21JbnQpXG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB7IGZvcm1hdExvZywgdGltZXJNZXNzYWdlLCBnZXRMb2dGb3JtYXQ6ICgpID0+IFNUUlVDVFVSRUQgfTtcbn07XG5cbi8vIHNyYy9GbG9vZENvbnRyb2wudHNcbmltcG9ydCB1dGlsMiBmcm9tIFwidXRpbFwiO1xudmFyIGhhc2ggPSAobWVzc2FnZSwgZGF0YSkgPT4ge1xuICBjb25zdCBkYXRhU3RyaW5nID0gZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHV0aWwyLmluc3BlY3QoaXRlbSk7XG4gICAgfVxuICB9KS5qb2luKFwiXCIpO1xuICByZXR1cm4gYCR7bWVzc2FnZX0ke2RhdGFTdHJpbmd9YDtcbn07XG52YXIgRmxvb2RDb250cm9sID0gY2xhc3Mge1xuICBjb25maWc7XG4gIGhpc3RvcnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdXBwcmVzc2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5jbGVhbnVwKCksIHRoaXMuY29uZmlnLnRpbWVmcmFtZSAqIDIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmNsZWFudXBUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IFtoYXNoMiwgdGltZXN0YW1wc10gb2YgdGhpcy5oaXN0b3J5LmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgcmVjZW50VGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuZmlsdGVyKFxuICAgICAgICAodGltZXN0YW1wKSA9PiBub3cgLSB0aW1lc3RhbXAgPCB0aGlzLmNvbmZpZy50aW1lZnJhbWVcbiAgICAgICk7XG4gICAgICBpZiAocmVjZW50VGltZXN0YW1wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5zZXQoaGFzaDIsIHJlY2VudFRpbWVzdGFtcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LmRlbGV0ZShoYXNoMik7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5kZWxldGUoaGFzaDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGVjayhtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gXCJsb2dcIjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBoYXNoKG1lc3NhZ2UsIGRhdGEpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9ICh0aGlzLmhpc3RvcnkuZ2V0KG1lc3NhZ2VIYXNoKSB8fCBbXSkuZmlsdGVyKFxuICAgICAgKHRpbWVzdGFtcCkgPT4gbm93IC0gdGltZXN0YW1wIDwgdGhpcy5jb25maWcudGltZWZyYW1lXG4gICAgKTtcbiAgICB0aW1lc3RhbXBzLnB1c2gobm93KTtcbiAgICB0aGlzLmhpc3Rvcnkuc2V0KG1lc3NhZ2VIYXNoLCB0aW1lc3RhbXBzKTtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPiB0aGlzLmNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgIGNvbnN0IHN1cHByZXNzZWRJbmZvID0gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk7XG4gICAgICBpZiAoc3VwcHJlc3NlZEluZm8pIHtcbiAgICAgICAgc3VwcHJlc3NlZEluZm8uY291bnQrKztcbiAgICAgICAgcmV0dXJuIFwic3VwcHJlc3NcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5zZXQobWVzc2FnZUhhc2gsIHsgY291bnQ6IDEsIGZpcnN0VGltZXN0YW1wOiB0aW1lc3RhbXBzWzBdLCBzdW1tYXJ5TG9nZ2VkOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIFwic3VwcHJlc3NcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuc3VwcHJlc3NlZC5oYXMobWVzc2FnZUhhc2gpKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5kZWxldGUobWVzc2FnZUhhc2gpO1xuICAgICAgICByZXR1cm4gXCJyZXN1bWVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwibG9nXCI7XG4gIH1cbiAgZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuc3VwcHJlc3NlZC5nZXQobWVzc2FnZUhhc2gpPy5jb3VudCB8fCAwO1xuICB9XG59O1xuXG4vLyBzcmMvTG9nZ2VyLnRzXG52YXIgY3JlYXRlTG9nZ2VyID0gKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBmbG9vZENvbnRyb2xDb25maWcsIHdyaXRlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGxvZ0Zvcm1hdCk7XG4gIGNvbnN0IGZsb29kQ29udHJvbCA9IGZsb29kQ29udHJvbENvbmZpZy5lbmFibGVkID8gbmV3IEZsb29kQ29udHJvbChmbG9vZENvbnRyb2xDb25maWcpIDogbnVsbDtcbiAgY29uc3QgbG9nRnVuY3Rpb24gPSBjb25zb2xlLmxvZztcbiAgY29uc3Qgd3JpdGVyID0gY3JlYXRlV3JpdGVyKGZvcm1hdHRlciwgbG9nRnVuY3Rpb24sIHdyaXRlck9wdGlvbnMpO1xuICBjb25zdCB3cml0ZSA9IChsZXZlbCwgbWVzc2FnZSwgZGF0YSkgPT4ge1xuICAgIGlmIChsb2dMZXZlbC52YWx1ZSA8IGxldmVsLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrID0gZmxvb2RDb250cm9sID8gZmxvb2RDb250cm9sLmNoZWNrKG1lc3NhZ2UsIGRhdGEpIDogXCJsb2dcIjtcbiAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG4gICAgc3dpdGNoIChjaGVjaykge1xuICAgICAgY2FzZSBcImxvZ1wiOlxuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3VwcHJlc3NcIjpcbiAgICAgICAgaWYgKGZsb29kQ29udHJvbCAmJiBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpID09PSAxKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGNvbnN0IG5ld1BheWxvYWQgPSB7IG1lc3NhZ2U6IGBTdGFydGVkIHN1cHByZXNzaW5nIHJlcGVhdGVkIGxvZyBtZXNzYWdlYCwgZGF0YTogW10gfTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUob3JpZ2luYWxMZXZlbCwgY29vcmRpbmF0ZXMsIG5ld1BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlc3VtZVwiOiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZmxvb2RDb250cm9sID8gZmxvb2RDb250cm9sLmdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSA6IDA7XG4gICAgICAgIGNvbnN0IHJlc3VtZVBheWxvYWQgPSB7XG4gICAgICAgICAgbWVzc2FnZTogYFN0b3BwZWQgc3VwcHJlc3NpbmcgcmVwZWF0ZWQgbG9nIG1lc3NhZ2UuIFN1cHByZXNzZWQgJHtjb3VudH0gdGltZXMuYCxcbiAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9O1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCByZXN1bWVQYXlsb2FkKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhcnRUaW1lTG9nZ2VyID0gKGxvZ0xldmVsMiwgY29vcmRpbmF0ZXMyLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlID0gZm9ybWF0dGVyLnRpbWVyTWVzc2FnZShsb2dMZXZlbDIsIGNvb3JkaW5hdGVzMiwgcGF5bG9hZCk7XG4gICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZSh0aW1lck1lc3NhZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZUVuZCh0aW1lck1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICAgIGxvZzogKC4uLmRhdGEpID0+IHtcbiAgICAgICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZUxvZyh0aW1lck1lc3NhZ2UsIC4uLmRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgZW1lcmdlbmN5OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoRU1FUkdFTkNZLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGFsZXJ0OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoQUxFUlQsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgY3JpdGljYWw6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShDUklUSUNBTCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBlcnJvcjogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEVSUk9SLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHdhcm5pbmc6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShXQVJOSU5HLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIG5vdGljZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKE5PVElDRSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoSU5GTywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBkZWJ1ZzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKERFQlVHLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHRyYWNlOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoVFJBQ0UsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZGVmYXVsdDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKERFRkFVTFQsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgdGltZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG1lc3NhZ2UsIGRhdGEgfTtcbiAgICAgIHJldHVybiBzdGFydFRpbWVMb2dnZXIobG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICB9LFxuICAgIGdldDogKC4uLmFkZGl0aW9uYWxDb21wb25lbnRzKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlTG9nZ2VyKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBbLi4uY29vcmRpbmF0ZXMuY29tcG9uZW50cywgLi4uYWRkaXRpb25hbENvbXBvbmVudHNdXG4gICAgICB9LCBmbG9vZENvbnRyb2xDb25maWcsIHdyaXRlck9wdGlvbnMpO1xuICAgIH0sXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgaWYgKGZsb29kQ29udHJvbCkge1xuICAgICAgICBmbG9vZENvbnRyb2wuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9sb2dnaW5nLnRzXG52YXIgZ2V0TG9nZ2VyID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gY29uZmlndXJlTG9nZ2luZygpO1xuICBjb25zdCBsb2dnZXIgPSBjcmVhdGVCYXNlTG9nZ2VyKG5hbWUsIGNvbmZpZyk7XG4gIHJldHVybiBsb2dnZXI7XG59O1xudmFyIGNyZWF0ZUJhc2VMb2dnZXIgPSAobmFtZSwgY29uZmlnKSA9PiB7XG4gIGxldCB7IGxvZ0xldmVsIH0gPSBjb25maWc7XG4gIGNvbnN0IHsgbG9nRm9ybWF0LCBmbG9vZENvbnRyb2wgfSA9IGNvbmZpZztcbiAgY29uc3Qgb3ZlcnJpZGVzID0gY29uZmlnLm92ZXJyaWRlcztcbiAgaWYgKG92ZXJyaWRlcyAmJiBvdmVycmlkZXNbbmFtZV0pIHtcbiAgICBsb2dMZXZlbCA9IG92ZXJyaWRlc1tuYW1lXS5sb2dMZXZlbDtcbiAgfVxuICBjb25zdCBjb29yZGluYXRlcyA9IHsgY2F0ZWdvcnk6IG5hbWUsIGNvbXBvbmVudHM6IFtdIH07XG4gIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbCk7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0geyBnZXRMb2dnZXIgfTtcbmV4cG9ydCB7XG4gIExvZ0Zvcm1hdF9leHBvcnRzIGFzIExvZ0Zvcm1hdCxcbiAgTG9nTGV2ZWxfZXhwb3J0cyBhcyBMb2dMZXZlbCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBnZXRMb2dnZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-client-api/node_modules/@fjell/registry/dist/index.js":
/*!**********************************************************************!*\
  !*** ../fjell-client-api/node_modules/@fjell/registry/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = (kta, scopes = []) => {\n  const ktArray = Array.isArray(kta) ? kta : [kta];\n  const toString = () => {\n    logger.debug(\"toString\", { kta, scopes });\n    return `${ktArray.join(\", \")} - ${scopes.join(\", \")}`;\n  };\n  logger.debug(\"createCoordinate\", { kta: ktArray, scopes, toString });\n  return { kta: ktArray, scopes, toString };\n};\n\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate) => {\n  logger2.debug(\"createInstance\", { coordinate, registry });\n  return { coordinate, registry };\n};\nvar isInstance = (instance) => {\n  return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n\n// src/RegistryStats.ts\nvar RegistryStats = class {\n  totalCalls = 0;\n  // Map structure: ktaKey -> scopeKey -> clientKey -> count\n  coordinateCalls = /* @__PURE__ */ new Map();\n  /**\n   * Records a get() call for the specified coordinate and client\n   */\n  recordGetCall(kta, scopes, client) {\n    this.totalCalls++;\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    if (!this.coordinateCalls.has(ktaKey)) {\n      this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n    }\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap.has(scopeKey)) {\n      scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n    }\n    const clientMap = scopeMap.get(scopeKey);\n    const currentCount = clientMap.get(clientKey) || 0;\n    clientMap.set(clientKey, currentCount + 1);\n  }\n  /**\n   * Gets the current statistics snapshot\n   */\n  getStatistics() {\n    const coordinateCallRecords = [];\n    let serviceCalls = 0;\n    let applicationCalls = 0;\n    let unidentifiedCalls = 0;\n    for (const [ktaKey, scopeMap] of this.coordinateCalls) {\n      for (const [scopeKey, clientMap] of scopeMap) {\n        const clientCalls = [];\n        let totalCount = 0;\n        for (const [clientKey, count] of clientMap) {\n          const client = this.parseClientKey(clientKey);\n          if (client !== null) {\n            clientCalls.push({ client, count });\n          }\n          totalCount += count;\n          if (clientKey === \"__no_client__\") {\n            unidentifiedCalls += count;\n          } else if (typeof client === \"string\") {\n            applicationCalls += count;\n          } else if (client !== null) {\n            serviceCalls += count;\n          }\n        }\n        coordinateCallRecords.push({\n          kta: ktaKey.split(\".\"),\n          scopes: this.parseScopeKey(scopeKey),\n          count: totalCount,\n          clientCalls: [...clientCalls]\n          // Return a copy\n        });\n      }\n    }\n    return {\n      totalGetCalls: this.totalCalls,\n      coordinateCallRecords: [...coordinateCallRecords],\n      // Return a copy\n      clientSummary: {\n        serviceCalls,\n        applicationCalls,\n        unidentifiedCalls\n      }\n    };\n  }\n  /**\n   * Gets call count for a specific coordinate combination\n   */\n  getCallCount(kta, scopes) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    let total = 0;\n    for (const count of clientMap.values()) {\n      total += count;\n    }\n    return total;\n  }\n  /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */\n  getCallCountByClient(kta, scopes, client) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    return clientMap.get(clientKey) || 0;\n  }\n  /**\n   * Gets total calls for a specific kta (across all scopes)\n   */\n  getTotalCallsForKta(kta) {\n    const ktaKey = kta.join(\".\");\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    let total = 0;\n    for (const clientMap of scopeMap.values()) {\n      for (const count of clientMap.values()) {\n        total += count;\n      }\n    }\n    return total;\n  }\n  /**\n   * Gets all unique kta paths that have been called\n   */\n  getCalledKtaPaths() {\n    const ktaPaths = [];\n    for (const ktaKey of this.coordinateCalls.keys()) {\n      ktaPaths.push(ktaKey.split(\".\"));\n    }\n    return ktaPaths;\n  }\n  /**\n   * Creates a normalized scope key from scopes array\n   */\n  createScopeKey(scopes) {\n    if (scopes.length === 0) return \"__no_scopes__\";\n    return [...scopes].sort().join(\",\");\n  }\n  /**\n   * Parses a scope key back to scopes array\n   */\n  parseScopeKey(scopeKey) {\n    if (scopeKey === \"__no_scopes__\") return [];\n    return scopeKey.split(\",\");\n  }\n  /**\n   * Creates a normalized client key from client identifier\n   */\n  createClientKey(client) {\n    if (!client) return \"__no_client__\";\n    if (typeof client === \"string\") {\n      return `app:${client}`;\n    }\n    const coordKey = `${client.coordinate.kta.join(\".\")};${this.createScopeKey(client.coordinate.scopes)}`;\n    return `service:${client.registryType}:${coordKey}`;\n  }\n  /**\n   * Parses a client key back to client identifier\n   */\n  parseClientKey(clientKey) {\n    if (clientKey === \"__no_client__\") return null;\n    if (clientKey.startsWith(\"app:\")) {\n      return clientKey.substring(4);\n    }\n    if (clientKey.startsWith(\"service:\")) {\n      const parts = clientKey.substring(8).split(\":\");\n      if (parts.length !== 2) return null;\n      const registryType = parts[0];\n      const coordParts = parts[1].split(\";\");\n      if (coordParts.length !== 2) return null;\n      const kta = coordParts[0].split(\".\");\n      const scopes = this.parseScopeKey(coordParts[1]);\n      return {\n        registryType,\n        coordinate: { kta, scopes }\n      };\n    }\n    return null;\n  }\n};\n\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes) => {\n  if (!requestedScopes || requestedScopes.length === 0) {\n    const firstInstance = scopedInstances[0]?.instance;\n    if (!firstInstance) {\n      throw new Error(\"No instances available\");\n    }\n    return firstInstance;\n  }\n  const matchingInstance = scopedInstances.find((scopedInstance) => {\n    if (!scopedInstance.scopes) return false;\n    return requestedScopes.every(\n      (scope) => scopedInstance.scopes && scopedInstance.scopes.includes(scope)\n    );\n  });\n  if (!matchingInstance) {\n    throw new Error(`No instance found matching scopes: ${requestedScopes.join(\", \")}`);\n  }\n  return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub) => {\n  const instanceTree = {};\n  const registryStats = new RegistryStats();\n  const createProxiedRegistry = (callingCoordinate) => {\n    const serviceClient = {\n      registryType: type,\n      coordinate: {\n        kta: callingCoordinate.kta,\n        scopes: callingCoordinate.scopes\n      }\n    };\n    return {\n      ...registry,\n      get: (kta, options) => {\n        const clientToUse = options?.client || serviceClient;\n        return registry.get(kta, { ...options, client: clientToUse });\n      }\n    };\n  };\n  const createInstance2 = (kta, scopes, factory) => {\n    logger3.debug(`Creating and registering instance for key path and scopes`, kta, scopes, `in registry type: ${type}`);\n    const coordinate = createCoordinate(kta, scopes);\n    const proxiedRegistry = createProxiedRegistry(coordinate);\n    const instance = factory(coordinate, {\n      registry: proxiedRegistry,\n      registryHub\n    });\n    if (!isInstance(instance)) {\n      throw new Error(`Factory did not return a valid instance for: ${kta.join(\".\")}`);\n    }\n    registerInternal(kta, instance, { scopes });\n    return instance;\n  };\n  const registerInternal = (kta, instance, options) => {\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    logger3.debug(`Registering instance for key path and scopes`, keyPath, options?.scopes, `in registry type: ${type}`);\n    if (!isInstance(instance)) {\n      throw new Error(`Attempting to register a non-instance: ${kta.join(\".\")}`);\n    }\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        currentLevel[keyType] = {\n          instances: [],\n          children: isLeaf ? null : {}\n        };\n      }\n      if (isLeaf) {\n        currentLevel[keyType].instances.push({\n          scopes: options?.scopes,\n          instance\n        });\n      } else {\n        if (!currentLevel[keyType].children) {\n          currentLevel[keyType].children = {};\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n  };\n  const register = (kta, instance, options) => {\n    logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n    registerInternal(kta, instance, options);\n  };\n  const get = (kta, options) => {\n    registryStats.recordGetCall(kta, options?.scopes, options?.client);\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        throw new Error(`Instance not found for key path: ${kta.join(\".\")}, Missing key: ${keyType}`);\n      }\n      if (isLeaf) {\n        const scopedInstances = currentLevel[keyType].instances;\n        if (scopedInstances.length === 0) {\n          throw new Error(`No instances registered for key path: ${kta.join(\".\")}`);\n        }\n        return findScopedInstance(scopedInstances, options?.scopes);\n      } else {\n        if (!currentLevel[keyType].children) {\n          throw new Error(`Instance not found for key path: ${kta.join(\".\")}, No children for: ${keyType}`);\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n    return null;\n  };\n  const getCoordinates = () => {\n    const coordinates = [];\n    const traverseTree = (node) => {\n      for (const keyType in node) {\n        const treeNode = node[keyType];\n        for (const scopedInstance of treeNode.instances) {\n          coordinates.push(scopedInstance.instance.coordinate);\n        }\n        if (treeNode.children) {\n          traverseTree(treeNode.children);\n        }\n      }\n    };\n    traverseTree(instanceTree);\n    return coordinates;\n  };\n  const getStatistics = () => {\n    return registryStats.getStatistics();\n  };\n  const registry = {\n    type,\n    registryHub,\n    createInstance: createInstance2,\n    register,\n    get,\n    getCoordinates,\n    getStatistics,\n    instanceTree\n  };\n  return registry;\n};\n\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n  registryType;\n  context;\n  constructor(message, registryType, context) {\n    super(message);\n    this.name = this.constructor.name;\n    this.registryType = registryType;\n    this.context = context;\n    const ErrorConstructor = Error;\n    if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n      ErrorConstructor.captureStackTrace(this, this.constructor);\n    }\n  }\n  getDetails() {\n    const details = [this.message];\n    if (this.registryType) {\n      details.push(`Registry Type: ${this.registryType}`);\n    }\n    if (this.context) {\n      details.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n    }\n    return details.join(\"\\n\");\n  }\n};\nvar RegistryCreationError = class extends RegistryError {\n  constructor(type, reason, context) {\n    super(`Failed to create registry of type '${type}': ${reason}`, type, context);\n  }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n  keyPath;\n  factoryResult;\n  constructor(keyPath, factoryResult, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Factory did not return a valid instance for: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof factoryResult}`,\n      registryType,\n      { keyPath, factoryResult: typeof factoryResult }\n    );\n    this.keyPath = keyPath;\n    this.factoryResult = factoryResult;\n  }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n  keyPath;\n  attemptedRegistration;\n  constructor(keyPath, attemptedRegistration, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Attempting to register a non-instance: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof attemptedRegistration}`,\n      registryType,\n      { keyPath, attemptedRegistration: typeof attemptedRegistration }\n    );\n    this.keyPath = keyPath;\n    this.attemptedRegistration = attemptedRegistration;\n  }\n};\n\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n  hubType;\n  constructor(message, hubType, context) {\n    const enrichedContext = hubType ? { ...context, hubType } : context;\n    super(message, \"\", enrichedContext);\n    this.hubType = hubType;\n  }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n  duplicateType;\n  constructor(type, context) {\n    super(\n      `Registry already registered under type: ${type}. Each registry type must be unique within a registry hub.`,\n      \"\",\n      { ...context, duplicateType: type }\n    );\n    this.duplicateType = type;\n  }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n  requestedType;\n  availableTypes;\n  constructor(requestedType, availableTypes = [], context) {\n    let message = `No registry registered under type: ${requestedType}`;\n    if (availableTypes.length > 0) {\n      message += `. Available types: [${availableTypes.join(\", \")}]`;\n    }\n    super(message, \"\", { ...context, requestedType, availableTypes });\n    this.requestedType = requestedType;\n    this.availableTypes = availableTypes;\n  }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n  factoryError;\n  attemptedType;\n  constructor(type, factoryError, context) {\n    super(\n      `Registry factory failed to create registry of type '${type}': ${factoryError.message}`,\n      \"\",\n      { ...context, attemptedType: type, originalError: factoryError.message }\n    );\n    this.factoryError = factoryError;\n    this.attemptedType = type;\n  }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n  factoryResult;\n  attemptedType;\n  constructor(type, factoryResult, context) {\n    super(\n      `Registry factory returned invalid registry for type '${type}'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: ${typeof factoryResult}`,\n      \"\",\n      { ...context, attemptedType: type, factoryResult: typeof factoryResult }\n    );\n    this.factoryResult = factoryResult;\n    this.attemptedType = type;\n  }\n};\n\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = () => {\n  const registries = {};\n  const createRegistry2 = (type, factory) => {\n    logger4.debug(`Creating new registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    const registry = factory(type, hub);\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    registries[type] = registry;\n    logger4.debug(`Successfully created and registered new registry with type: ${type}`);\n    return registry;\n  };\n  const registerRegistry = (registry) => {\n    const type = registry.type;\n    logger4.debug(`Registering registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    registries[type] = registry;\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    logger4.debug(`Successfully registered registry with type: ${type}`);\n  };\n  const get = (type, kta, options) => {\n    logger4.debug(`Looking up instance for type: ${type}, kta: ${kta.join(\".\")}, scopes: ${options?.scopes?.join(\",\") || \"none\"}`);\n    const registry = registries[type];\n    if (!registry) {\n      const availableTypes = Object.keys(registries);\n      throw new RegistryTypeNotFoundError(type, availableTypes);\n    }\n    return registry.get(kta, options);\n  };\n  const getRegistry = (type) => {\n    return registries[type] || null;\n  };\n  const getRegisteredTypes = () => {\n    return Object.keys(registries);\n  };\n  const unregisterRegistry = (type) => {\n    if (registries[type]) {\n      delete registries[type];\n      logger4.debug(`Unregistered registry under type: ${type}`);\n      return true;\n    }\n    return false;\n  };\n  const getAllCoordinates = () => {\n    const allCoordinates = [];\n    for (const registryType in registries) {\n      const registry = registries[registryType];\n      const coordinates = registry.getCoordinates();\n      coordinates.forEach((coordinate) => {\n        allCoordinates.push({\n          coordinate,\n          registryType\n        });\n      });\n    }\n    logger4.debug(`Retrieved ${allCoordinates.length} total coordinates from ${Object.keys(registries).length} registries`);\n    return allCoordinates;\n  };\n  const hub = {\n    createRegistry: createRegistry2,\n    registerRegistry,\n    get,\n    getRegistry,\n    getRegisteredTypes,\n    getAllCoordinates,\n    unregisterRegistry\n  };\n  return hub;\n};\n\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n  keyPath;\n  constructor(message, keyPath, registryType, context) {\n    super(message, registryType, { ...context, keyPath });\n    this.keyPath = keyPath;\n  }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n  missingKey;\n  constructor(keyPath, missingKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    let message = `Instance not found for key path: ${keyPathStr}`;\n    if (missingKey) {\n      message += `, Missing key: ${missingKey}`;\n    }\n    super(message, keyPath, registryType, { ...context, missingKey });\n    this.missingKey = missingKey;\n  }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances registered for key path: ${keyPathStr}. The key path exists in the registry tree but contains no instances.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances available for key path: ${keyPathStr}. This typically indicates an internal registry state issue.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n  requestedScopes;\n  availableScopes;\n  constructor(keyPath, requestedScopes, availableScopes = [], registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    const scopesStr = requestedScopes.join(\", \");\n    const availableScopesStr = availableScopes.map((scopes) => `[${scopes.join(\", \")}]`).join(\", \");\n    let message = `No instance found matching scopes: ${scopesStr} for key path: ${keyPathStr}`;\n    if (availableScopes.length > 0) {\n      message += `. Available scopes: ${availableScopesStr}`;\n    }\n    super(message, keyPath, registryType, { requestedScopes, availableScopes });\n    this.requestedScopes = requestedScopes;\n    this.availableScopes = availableScopes;\n  }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n  parentKey;\n  constructor(keyPath, parentKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Instance not found for key path: ${keyPathStr}, No children for: ${parentKey}. The path cannot be traversed further as '${parentKey}' has no child nodes.`,\n      keyPath,\n      registryType,\n      { ...context, parentKey }\n    );\n    this.parentKey = parentKey;\n  }\n};\n\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n  kta;\n  scopes;\n  constructor(message, kta, scopes, context) {\n    super(message, \"\", { ...context, kta, scopes });\n    this.kta = kta;\n    this.scopes = scopes;\n  }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n  constructor(kta, scopes, reason, context) {\n    super(\n      `Invalid coordinate parameters: ${reason}. KTA: ${JSON.stringify(kta)}, Scopes: [${scopes.join(\", \")}]`,\n      kta,\n      scopes,\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidKTAError = class extends CoordinateError {\n  constructor(kta, reason, context) {\n    super(\n      `Invalid KTA (Key Type Array): ${reason}. Expected string or array of strings, got: ${JSON.stringify(kta)}`,\n      kta,\n      [],\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidScopesError = class extends CoordinateError {\n  invalidScopes;\n  constructor(scopes, invalidScopes, reason, context) {\n    super(\n      `Invalid scopes: ${reason}. Invalid scope values: ${JSON.stringify(invalidScopes)}`,\n      null,\n      scopes.filter((s) => typeof s === \"string\"),\n      { ...context, reason, invalidScopes }\n    );\n    this.invalidScopes = invalidScopes;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvQGZqZWxsL3JlZ2lzdHJ5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNxQztBQUNyQyxnQkFBZ0IsZ0VBQWlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QyxjQUFjLG9CQUFvQixJQUFJLGtCQUFrQjtBQUN4RDtBQUNBLHFDQUFxQyxnQ0FBZ0M7QUFDckUsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBMkJFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvQGZqZWxsL3JlZ2lzdHJ5L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xvZ2dlci50c1xuaW1wb3J0IExvZ2dpbmcgZnJvbSBcIkBmamVsbC9sb2dnaW5nXCI7XG52YXIgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoXCJAZmplbGwvcmVnaXN0cnlcIik7XG52YXIgbG9nZ2VyX2RlZmF1bHQgPSBMaWJMb2dnZXI7XG5cbi8vIHNyYy9Db29yZGluYXRlLnRzXG52YXIgbG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiQ29vcmRpbmF0ZVwiKTtcbnZhciBjcmVhdGVDb29yZGluYXRlID0gKGt0YSwgc2NvcGVzID0gW10pID0+IHtcbiAgY29uc3Qga3RBcnJheSA9IEFycmF5LmlzQXJyYXkoa3RhKSA/IGt0YSA6IFtrdGFdO1xuICBjb25zdCB0b1N0cmluZyA9ICgpID0+IHtcbiAgICBsb2dnZXIuZGVidWcoXCJ0b1N0cmluZ1wiLCB7IGt0YSwgc2NvcGVzIH0pO1xuICAgIHJldHVybiBgJHtrdEFycmF5LmpvaW4oXCIsIFwiKX0gLSAke3Njb3Blcy5qb2luKFwiLCBcIil9YDtcbiAgfTtcbiAgbG9nZ2VyLmRlYnVnKFwiY3JlYXRlQ29vcmRpbmF0ZVwiLCB7IGt0YToga3RBcnJheSwgc2NvcGVzLCB0b1N0cmluZyB9KTtcbiAgcmV0dXJuIHsga3RhOiBrdEFycmF5LCBzY29wZXMsIHRvU3RyaW5nIH07XG59O1xuXG4vLyBzcmMvSW5zdGFuY2UudHNcbnZhciBsb2dnZXIyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSW5zdGFuY2VcIik7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAocmVnaXN0cnksIGNvb3JkaW5hdGUpID0+IHtcbiAgbG9nZ2VyMi5kZWJ1ZyhcImNyZWF0ZUluc3RhbmNlXCIsIHsgY29vcmRpbmF0ZSwgcmVnaXN0cnkgfSk7XG4gIHJldHVybiB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5IH07XG59O1xudmFyIGlzSW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgcmV0dXJuIGluc3RhbmNlICE9PSBudWxsICYmIGluc3RhbmNlICE9PSB2b2lkIDAgJiYgaW5zdGFuY2UuY29vcmRpbmF0ZSAhPT0gdm9pZCAwICYmIGluc3RhbmNlLnJlZ2lzdHJ5ICE9PSB2b2lkIDA7XG59O1xuXG4vLyBzcmMvUmVnaXN0cnlTdGF0cy50c1xudmFyIFJlZ2lzdHJ5U3RhdHMgPSBjbGFzcyB7XG4gIHRvdGFsQ2FsbHMgPSAwO1xuICAvLyBNYXAgc3RydWN0dXJlOiBrdGFLZXkgLT4gc2NvcGVLZXkgLT4gY2xpZW50S2V5IC0+IGNvdW50XG4gIGNvb3JkaW5hdGVDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEgZ2V0KCkgY2FsbCBmb3IgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlIGFuZCBjbGllbnRcbiAgICovXG4gIHJlY29yZEdldENhbGwoa3RhLCBzY29wZXMsIGNsaWVudCkge1xuICAgIHRoaXMudG90YWxDYWxscysrO1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZUtleSA9IHRoaXMuY3JlYXRlU2NvcGVLZXkoc2NvcGVzIHx8IFtdKTtcbiAgICBjb25zdCBjbGllbnRLZXkgPSB0aGlzLmNyZWF0ZUNsaWVudEtleShjbGllbnQpO1xuICAgIGlmICghdGhpcy5jb29yZGluYXRlQ2FsbHMuaGFzKGt0YUtleSkpIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZUNhbGxzLnNldChrdGFLZXksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXAuaGFzKHNjb3BlS2V5KSkge1xuICAgICAgc2NvcGVNYXAuc2V0KHNjb3BlS2V5LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBjb25zdCBjdXJyZW50Q291bnQgPSBjbGllbnRNYXAuZ2V0KGNsaWVudEtleSkgfHwgMDtcbiAgICBjbGllbnRNYXAuc2V0KGNsaWVudEtleSwgY3VycmVudENvdW50ICsgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGlzdGljcyBzbmFwc2hvdFxuICAgKi9cbiAgZ2V0U3RhdGlzdGljcygpIHtcbiAgICBjb25zdCBjb29yZGluYXRlQ2FsbFJlY29yZHMgPSBbXTtcbiAgICBsZXQgc2VydmljZUNhbGxzID0gMDtcbiAgICBsZXQgYXBwbGljYXRpb25DYWxscyA9IDA7XG4gICAgbGV0IHVuaWRlbnRpZmllZENhbGxzID0gMDtcbiAgICBmb3IgKGNvbnN0IFtrdGFLZXksIHNjb3BlTWFwXSBvZiB0aGlzLmNvb3JkaW5hdGVDYWxscykge1xuICAgICAgZm9yIChjb25zdCBbc2NvcGVLZXksIGNsaWVudE1hcF0gb2Ygc2NvcGVNYXApIHtcbiAgICAgICAgY29uc3QgY2xpZW50Q2FsbHMgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IFtjbGllbnRLZXksIGNvdW50XSBvZiBjbGllbnRNYXApIHtcbiAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLnBhcnNlQ2xpZW50S2V5KGNsaWVudEtleSk7XG4gICAgICAgICAgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xpZW50Q2FsbHMucHVzaCh7IGNsaWVudCwgY291bnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsQ291bnQgKz0gY291bnQ7XG4gICAgICAgICAgaWYgKGNsaWVudEtleSA9PT0gXCJfX25vX2NsaWVudF9fXCIpIHtcbiAgICAgICAgICAgIHVuaWRlbnRpZmllZENhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNsaWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBwbGljYXRpb25DYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VydmljZUNhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb29yZGluYXRlQ2FsbFJlY29yZHMucHVzaCh7XG4gICAgICAgICAga3RhOiBrdGFLZXkuc3BsaXQoXCIuXCIpLFxuICAgICAgICAgIHNjb3BlczogdGhpcy5wYXJzZVNjb3BlS2V5KHNjb3BlS2V5KSxcbiAgICAgICAgICBjb3VudDogdG90YWxDb3VudCxcbiAgICAgICAgICBjbGllbnRDYWxsczogWy4uLmNsaWVudENhbGxzXVxuICAgICAgICAgIC8vIFJldHVybiBhIGNvcHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEdldENhbGxzOiB0aGlzLnRvdGFsQ2FsbHMsXG4gICAgICBjb29yZGluYXRlQ2FsbFJlY29yZHM6IFsuLi5jb29yZGluYXRlQ2FsbFJlY29yZHNdLFxuICAgICAgLy8gUmV0dXJuIGEgY29weVxuICAgICAgY2xpZW50U3VtbWFyeToge1xuICAgICAgICBzZXJ2aWNlQ2FsbHMsXG4gICAgICAgIGFwcGxpY2F0aW9uQ2FsbHMsXG4gICAgICAgIHVuaWRlbnRpZmllZENhbGxzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBjYWxsIGNvdW50IGZvciBhIHNwZWNpZmljIGNvb3JkaW5hdGUgY29tYmluYXRpb25cbiAgICovXG4gIGdldENhbGxDb3VudChrdGEsIHNjb3Blcykge1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZUtleSA9IHRoaXMuY3JlYXRlU2NvcGVLZXkoc2NvcGVzIHx8IFtdKTtcbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgaWYgKCFjbGllbnRNYXApIHJldHVybiAwO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChjb25zdCBjb3VudCBvZiBjbGllbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgIHRvdGFsICs9IGNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgY2FsbCBjb3VudCBmb3IgYSBzcGVjaWZpYyBjb29yZGluYXRlIGNvbWJpbmF0aW9uIGZyb20gYSBzcGVjaWZpYyBjbGllbnRcbiAgICovXG4gIGdldENhbGxDb3VudEJ5Q2xpZW50KGt0YSwgc2NvcGVzLCBjbGllbnQpIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG4gICAgY29uc3QgY2xpZW50S2V5ID0gdGhpcy5jcmVhdGVDbGllbnRLZXkoY2xpZW50KTtcbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgaWYgKCFjbGllbnRNYXApIHJldHVybiAwO1xuICAgIHJldHVybiBjbGllbnRNYXAuZ2V0KGNsaWVudEtleSkgfHwgMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0b3RhbCBjYWxscyBmb3IgYSBzcGVjaWZpYyBrdGEgKGFjcm9zcyBhbGwgc2NvcGVzKVxuICAgKi9cbiAgZ2V0VG90YWxDYWxsc0Zvckt0YShrdGEpIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgY2xpZW50TWFwIG9mIHNjb3BlTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvdW50IG9mIGNsaWVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgICB0b3RhbCArPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFsbCB1bmlxdWUga3RhIHBhdGhzIHRoYXQgaGF2ZSBiZWVuIGNhbGxlZFxuICAgKi9cbiAgZ2V0Q2FsbGVkS3RhUGF0aHMoKSB7XG4gICAgY29uc3Qga3RhUGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGt0YUtleSBvZiB0aGlzLmNvb3JkaW5hdGVDYWxscy5rZXlzKCkpIHtcbiAgICAgIGt0YVBhdGhzLnB1c2goa3RhS2V5LnNwbGl0KFwiLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBrdGFQYXRocztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5vcm1hbGl6ZWQgc2NvcGUga2V5IGZyb20gc2NvcGVzIGFycmF5XG4gICAqL1xuICBjcmVhdGVTY29wZUtleShzY29wZXMpIHtcbiAgICBpZiAoc2NvcGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiX19ub19zY29wZXNfX1wiO1xuICAgIHJldHVybiBbLi4uc2NvcGVzXS5zb3J0KCkuam9pbihcIixcIik7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNjb3BlIGtleSBiYWNrIHRvIHNjb3BlcyBhcnJheVxuICAgKi9cbiAgcGFyc2VTY29wZUtleShzY29wZUtleSkge1xuICAgIGlmIChzY29wZUtleSA9PT0gXCJfX25vX3Njb3Blc19fXCIpIHJldHVybiBbXTtcbiAgICByZXR1cm4gc2NvcGVLZXkuc3BsaXQoXCIsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9ybWFsaXplZCBjbGllbnQga2V5IGZyb20gY2xpZW50IGlkZW50aWZpZXJcbiAgICovXG4gIGNyZWF0ZUNsaWVudEtleShjbGllbnQpIHtcbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuIFwiX19ub19jbGllbnRfX1wiO1xuICAgIGlmICh0eXBlb2YgY2xpZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gYGFwcDoke2NsaWVudH1gO1xuICAgIH1cbiAgICBjb25zdCBjb29yZEtleSA9IGAke2NsaWVudC5jb29yZGluYXRlLmt0YS5qb2luKFwiLlwiKX07JHt0aGlzLmNyZWF0ZVNjb3BlS2V5KGNsaWVudC5jb29yZGluYXRlLnNjb3Blcyl9YDtcbiAgICByZXR1cm4gYHNlcnZpY2U6JHtjbGllbnQucmVnaXN0cnlUeXBlfToke2Nvb3JkS2V5fWA7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGNsaWVudCBrZXkgYmFjayB0byBjbGllbnQgaWRlbnRpZmllclxuICAgKi9cbiAgcGFyc2VDbGllbnRLZXkoY2xpZW50S2V5KSB7XG4gICAgaWYgKGNsaWVudEtleSA9PT0gXCJfX25vX2NsaWVudF9fXCIpIHJldHVybiBudWxsO1xuICAgIGlmIChjbGllbnRLZXkuc3RhcnRzV2l0aChcImFwcDpcIikpIHtcbiAgICAgIHJldHVybiBjbGllbnRLZXkuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50S2V5LnN0YXJ0c1dpdGgoXCJzZXJ2aWNlOlwiKSkge1xuICAgICAgY29uc3QgcGFydHMgPSBjbGllbnRLZXkuc3Vic3RyaW5nKDgpLnNwbGl0KFwiOlwiKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgcmVnaXN0cnlUeXBlID0gcGFydHNbMF07XG4gICAgICBjb25zdCBjb29yZFBhcnRzID0gcGFydHNbMV0uc3BsaXQoXCI7XCIpO1xuICAgICAgaWYgKGNvb3JkUGFydHMubGVuZ3RoICE9PSAyKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGt0YSA9IGNvb3JkUGFydHNbMF0uc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5wYXJzZVNjb3BlS2V5KGNvb3JkUGFydHNbMV0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgICBjb29yZGluYXRlOiB7IGt0YSwgc2NvcGVzIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyBzcmMvUmVnaXN0cnkudHNcbnZhciBsb2dnZXIzID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiUmVnaXN0cnlcIik7XG52YXIgZmluZFNjb3BlZEluc3RhbmNlID0gKHNjb3BlZEluc3RhbmNlcywgcmVxdWVzdGVkU2NvcGVzKSA9PiB7XG4gIGlmICghcmVxdWVzdGVkU2NvcGVzIHx8IHJlcXVlc3RlZFNjb3Blcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBmaXJzdEluc3RhbmNlID0gc2NvcGVkSW5zdGFuY2VzWzBdPy5pbnN0YW5jZTtcbiAgICBpZiAoIWZpcnN0SW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGluc3RhbmNlcyBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdEluc3RhbmNlO1xuICB9XG4gIGNvbnN0IG1hdGNoaW5nSW5zdGFuY2UgPSBzY29wZWRJbnN0YW5jZXMuZmluZCgoc2NvcGVkSW5zdGFuY2UpID0+IHtcbiAgICBpZiAoIXNjb3BlZEluc3RhbmNlLnNjb3BlcykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiByZXF1ZXN0ZWRTY29wZXMuZXZlcnkoXG4gICAgICAoc2NvcGUpID0+IHNjb3BlZEluc3RhbmNlLnNjb3BlcyAmJiBzY29wZWRJbnN0YW5jZS5zY29wZXMuaW5jbHVkZXMoc2NvcGUpXG4gICAgKTtcbiAgfSk7XG4gIGlmICghbWF0Y2hpbmdJbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5zdGFuY2UgZm91bmQgbWF0Y2hpbmcgc2NvcGVzOiAke3JlcXVlc3RlZFNjb3Blcy5qb2luKFwiLCBcIil9YCk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoaW5nSW5zdGFuY2UuaW5zdGFuY2U7XG59O1xudmFyIGNyZWF0ZVJlZ2lzdHJ5ID0gKHR5cGUsIHJlZ2lzdHJ5SHViKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlVHJlZSA9IHt9O1xuICBjb25zdCByZWdpc3RyeVN0YXRzID0gbmV3IFJlZ2lzdHJ5U3RhdHMoKTtcbiAgY29uc3QgY3JlYXRlUHJveGllZFJlZ2lzdHJ5ID0gKGNhbGxpbmdDb29yZGluYXRlKSA9PiB7XG4gICAgY29uc3Qgc2VydmljZUNsaWVudCA9IHtcbiAgICAgIHJlZ2lzdHJ5VHlwZTogdHlwZSxcbiAgICAgIGNvb3JkaW5hdGU6IHtcbiAgICAgICAga3RhOiBjYWxsaW5nQ29vcmRpbmF0ZS5rdGEsXG4gICAgICAgIHNjb3BlczogY2FsbGluZ0Nvb3JkaW5hdGUuc2NvcGVzXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVnaXN0cnksXG4gICAgICBnZXQ6IChrdGEsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgY2xpZW50VG9Vc2UgPSBvcHRpb25zPy5jbGllbnQgfHwgc2VydmljZUNsaWVudDtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChrdGEsIHsgLi4ub3B0aW9ucywgY2xpZW50OiBjbGllbnRUb1VzZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBjcmVhdGVJbnN0YW5jZTIgPSAoa3RhLCBzY29wZXMsIGZhY3RvcnkpID0+IHtcbiAgICBsb2dnZXIzLmRlYnVnKGBDcmVhdGluZyBhbmQgcmVnaXN0ZXJpbmcgaW5zdGFuY2UgZm9yIGtleSBwYXRoIGFuZCBzY29wZXNgLCBrdGEsIHNjb3BlcywgYGluIHJlZ2lzdHJ5IHR5cGU6ICR7dHlwZX1gKTtcbiAgICBjb25zdCBjb29yZGluYXRlID0gY3JlYXRlQ29vcmRpbmF0ZShrdGEsIHNjb3Blcyk7XG4gICAgY29uc3QgcHJveGllZFJlZ2lzdHJ5ID0gY3JlYXRlUHJveGllZFJlZ2lzdHJ5KGNvb3JkaW5hdGUpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gZmFjdG9yeShjb29yZGluYXRlLCB7XG4gICAgICByZWdpc3RyeTogcHJveGllZFJlZ2lzdHJ5LFxuICAgICAgcmVnaXN0cnlIdWJcbiAgICB9KTtcbiAgICBpZiAoIWlzSW5zdGFuY2UoaW5zdGFuY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhY3RvcnkgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBmb3I6ICR7a3RhLmpvaW4oXCIuXCIpfWApO1xuICAgIH1cbiAgICByZWdpc3RlckludGVybmFsKGt0YSwgaW5zdGFuY2UsIHsgc2NvcGVzIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXJJbnRlcm5hbCA9IChrdGEsIGluc3RhbmNlLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qga2V5UGF0aCA9IFsuLi5rdGFdLnJldmVyc2UoKTtcbiAgICBsZXQgY3VycmVudExldmVsID0gaW5zdGFuY2VUcmVlO1xuICAgIGxvZ2dlcjMuZGVidWcoYFJlZ2lzdGVyaW5nIGluc3RhbmNlIGZvciBrZXkgcGF0aCBhbmQgc2NvcGVzYCwga2V5UGF0aCwgb3B0aW9ucz8uc2NvcGVzLCBgaW4gcmVnaXN0cnkgdHlwZTogJHt0eXBlfWApO1xuICAgIGlmICghaXNJbnN0YW5jZShpbnN0YW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIG5vbi1pbnN0YW5jZTogJHtrdGEuam9pbihcIi5cIil9YCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5VHlwZSA9IGtleVBhdGhbaV07XG4gICAgICBjb25zdCBpc0xlYWYgPSBpID09PSBrZXlQYXRoLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXSkge1xuICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0gPSB7XG4gICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogaXNMZWFmID8gbnVsbCA6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5pbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGVzOiBvcHRpb25zPy5zY29wZXMsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbikge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlZ2lzdGVyID0gKGt0YSwgaW5zdGFuY2UsIG9wdGlvbnMpID0+IHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiVXNpbmcgZGVwcmVjYXRlZCByZWdpc3RlciBtZXRob2QuIENvbnNpZGVyIHVzaW5nIGNyZWF0ZUluc3RhbmNlIGluc3RlYWQuXCIpO1xuICAgIHJlZ2lzdGVySW50ZXJuYWwoa3RhLCBpbnN0YW5jZSwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IGdldCA9IChrdGEsIG9wdGlvbnMpID0+IHtcbiAgICByZWdpc3RyeVN0YXRzLnJlY29yZEdldENhbGwoa3RhLCBvcHRpb25zPy5zY29wZXMsIG9wdGlvbnM/LmNsaWVudCk7XG4gICAgY29uc3Qga2V5UGF0aCA9IFsuLi5rdGFdLnJldmVyc2UoKTtcbiAgICBsZXQgY3VycmVudExldmVsID0gaW5zdGFuY2VUcmVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5VHlwZSA9IGtleVBhdGhbaV07XG4gICAgICBjb25zdCBpc0xlYWYgPSBpID09PSBrZXlQYXRoLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oXCIuXCIpfSwgTWlzc2luZyBrZXk6ICR7a2V5VHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVkSW5zdGFuY2VzID0gY3VycmVudExldmVsW2tleVR5cGVdLmluc3RhbmNlcztcbiAgICAgICAgaWYgKHNjb3BlZEluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluc3RhbmNlcyByZWdpc3RlcmVkIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbihcIi5cIil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmRTY29wZWRJbnN0YW5jZShzY29wZWRJbnN0YW5jZXMsIG9wdGlvbnM/LnNjb3Blcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbihcIi5cIil9LCBObyBjaGlsZHJlbiBmb3I6ICR7a2V5VHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCBnZXRDb29yZGluYXRlcyA9ICgpID0+IHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IFtdO1xuICAgIGNvbnN0IHRyYXZlcnNlVHJlZSA9IChub2RlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleVR5cGUgaW4gbm9kZSkge1xuICAgICAgICBjb25zdCB0cmVlTm9kZSA9IG5vZGVba2V5VHlwZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGVkSW5zdGFuY2Ugb2YgdHJlZU5vZGUuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucHVzaChzY29wZWRJbnN0YW5jZS5pbnN0YW5jZS5jb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZU5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICB0cmF2ZXJzZVRyZWUodHJlZU5vZGUuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0cmF2ZXJzZVRyZWUoaW5zdGFuY2VUcmVlKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gIH07XG4gIGNvbnN0IGdldFN0YXRpc3RpY3MgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5U3RhdHMuZ2V0U3RhdGlzdGljcygpO1xuICB9O1xuICBjb25zdCByZWdpc3RyeSA9IHtcbiAgICB0eXBlLFxuICAgIHJlZ2lzdHJ5SHViLFxuICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZTIsXG4gICAgcmVnaXN0ZXIsXG4gICAgZ2V0LFxuICAgIGdldENvb3JkaW5hdGVzLFxuICAgIGdldFN0YXRpc3RpY3MsXG4gICAgaW5zdGFuY2VUcmVlXG4gIH07XG4gIHJldHVybiByZWdpc3RyeTtcbn07XG5cbi8vIHNyYy9lcnJvcnMvUmVnaXN0cnlFcnJvci50c1xudmFyIFJlZ2lzdHJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgcmVnaXN0cnlUeXBlO1xuICBjb250ZXh0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5yZWdpc3RyeVR5cGUgPSByZWdpc3RyeVR5cGU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCBFcnJvckNvbnN0cnVjdG9yID0gRXJyb3I7XG4gICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIEVycm9yQ29uc3RydWN0b3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICB9XG4gIGdldERldGFpbHMoKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IFt0aGlzLm1lc3NhZ2VdO1xuICAgIGlmICh0aGlzLnJlZ2lzdHJ5VHlwZSkge1xuICAgICAgZGV0YWlscy5wdXNoKGBSZWdpc3RyeSBUeXBlOiAke3RoaXMucmVnaXN0cnlUeXBlfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBkZXRhaWxzLnB1c2goYENvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jb250ZXh0LCBudWxsLCAyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFpbHMuam9pbihcIlxcblwiKTtcbiAgfVxufTtcbnZhciBSZWdpc3RyeUNyZWF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihgRmFpbGVkIHRvIGNyZWF0ZSByZWdpc3RyeSBvZiB0eXBlICcke3R5cGV9JzogJHtyZWFzb259YCwgdHlwZSwgY29udGV4dCk7XG4gIH1cbn07XG52YXIgSW52YWxpZEZhY3RvcnlSZXN1bHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGtleVBhdGg7XG4gIGZhY3RvcnlSZXN1bHQ7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIGZhY3RvcnlSZXN1bHQsIHJlZ2lzdHJ5VHlwZSkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYEZhY3RvcnkgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBmb3I6ICR7a2V5UGF0aFN0cn0uIEV4cGVjdGVkIGluc3RhbmNlIHdpdGggJ2Nvb3JkaW5hdGUnIGFuZCAncmVnaXN0cnknIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgZmFjdG9yeVJlc3VsdH1gLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyBrZXlQYXRoLCBmYWN0b3J5UmVzdWx0OiB0eXBlb2YgZmFjdG9yeVJlc3VsdCB9XG4gICAgKTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMuZmFjdG9yeVJlc3VsdCA9IGZhY3RvcnlSZXN1bHQ7XG4gIH1cbn07XG52YXIgSW52YWxpZEluc3RhbmNlUmVnaXN0cmF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrZXlQYXRoO1xuICBhdHRlbXB0ZWRSZWdpc3RyYXRpb247XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbiwgcmVnaXN0cnlUeXBlKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIG5vbi1pbnN0YW5jZTogJHtrZXlQYXRoU3RyfS4gRXhwZWN0ZWQgaW5zdGFuY2Ugd2l0aCAnY29vcmRpbmF0ZScgYW5kICdyZWdpc3RyeScgcHJvcGVydGllcywgZ290OiAke3R5cGVvZiBhdHRlbXB0ZWRSZWdpc3RyYXRpb259YCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsga2V5UGF0aCwgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uOiB0eXBlb2YgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uIH1cbiAgICApO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpc3RyYXRpb24gPSBhdHRlbXB0ZWRSZWdpc3RyYXRpb247XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvUmVnaXN0cnlIdWJFcnJvci50c1xudmFyIFJlZ2lzdHJ5SHViRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBodWJUeXBlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBodWJUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZW5yaWNoZWRDb250ZXh0ID0gaHViVHlwZSA/IHsgLi4uY29udGV4dCwgaHViVHlwZSB9IDogY29udGV4dDtcbiAgICBzdXBlcihtZXNzYWdlLCBcIlwiLCBlbnJpY2hlZENvbnRleHQpO1xuICAgIHRoaXMuaHViVHlwZSA9IGh1YlR5cGU7XG4gIH1cbn07XG52YXIgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBkdXBsaWNhdGVUeXBlO1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVnaXN0cnkgYWxyZWFkeSByZWdpc3RlcmVkIHVuZGVyIHR5cGU6ICR7dHlwZX0uIEVhY2ggcmVnaXN0cnkgdHlwZSBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gYSByZWdpc3RyeSBodWIuYCxcbiAgICAgIFwiXCIsXG4gICAgICB7IC4uLmNvbnRleHQsIGR1cGxpY2F0ZVR5cGU6IHR5cGUgfVxuICAgICk7XG4gICAgdGhpcy5kdXBsaWNhdGVUeXBlID0gdHlwZTtcbiAgfVxufTtcbnZhciBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgcmVxdWVzdGVkVHlwZTtcbiAgYXZhaWxhYmxlVHlwZXM7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3RlZFR5cGUsIGF2YWlsYWJsZVR5cGVzID0gW10sIGNvbnRleHQpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBObyByZWdpc3RyeSByZWdpc3RlcmVkIHVuZGVyIHR5cGU6ICR7cmVxdWVzdGVkVHlwZX1gO1xuICAgIGlmIChhdmFpbGFibGVUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlICs9IGAuIEF2YWlsYWJsZSB0eXBlczogWyR7YXZhaWxhYmxlVHlwZXMuam9pbihcIiwgXCIpfV1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBcIlwiLCB7IC4uLmNvbnRleHQsIHJlcXVlc3RlZFR5cGUsIGF2YWlsYWJsZVR5cGVzIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkVHlwZSA9IHJlcXVlc3RlZFR5cGU7XG4gICAgdGhpcy5hdmFpbGFibGVUeXBlcyA9IGF2YWlsYWJsZVR5cGVzO1xuICB9XG59O1xudmFyIFJlZ2lzdHJ5RmFjdG9yeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgZmFjdG9yeUVycm9yO1xuICBhdHRlbXB0ZWRUeXBlO1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBmYWN0b3J5RXJyb3IsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBmYWN0b3J5IGZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cnkgb2YgdHlwZSAnJHt0eXBlfSc6ICR7ZmFjdG9yeUVycm9yLm1lc3NhZ2V9YCxcbiAgICAgIFwiXCIsXG4gICAgICB7IC4uLmNvbnRleHQsIGF0dGVtcHRlZFR5cGU6IHR5cGUsIG9yaWdpbmFsRXJyb3I6IGZhY3RvcnlFcnJvci5tZXNzYWdlIH1cbiAgICApO1xuICAgIHRoaXMuZmFjdG9yeUVycm9yID0gZmFjdG9yeUVycm9yO1xuICAgIHRoaXMuYXR0ZW1wdGVkVHlwZSA9IHR5cGU7XG4gIH1cbn07XG52YXIgSW52YWxpZFJlZ2lzdHJ5RmFjdG9yeVJlc3VsdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgZmFjdG9yeVJlc3VsdDtcbiAgYXR0ZW1wdGVkVHlwZTtcbiAgY29uc3RydWN0b3IodHlwZSwgZmFjdG9yeVJlc3VsdCwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGZhY3RvcnkgcmV0dXJuZWQgaW52YWxpZCByZWdpc3RyeSBmb3IgdHlwZSAnJHt0eXBlfScuIEV4cGVjdGVkIHJlZ2lzdHJ5IHdpdGggJ3R5cGUnLCAnZ2V0JywgJ3JlZ2lzdGVyJywgYW5kICdjcmVhdGVJbnN0YW5jZScgcHJvcGVydGllcywgZ290OiAke3R5cGVvZiBmYWN0b3J5UmVzdWx0fWAsXG4gICAgICBcIlwiLFxuICAgICAgeyAuLi5jb250ZXh0LCBhdHRlbXB0ZWRUeXBlOiB0eXBlLCBmYWN0b3J5UmVzdWx0OiB0eXBlb2YgZmFjdG9yeVJlc3VsdCB9XG4gICAgKTtcbiAgICB0aGlzLmZhY3RvcnlSZXN1bHQgPSBmYWN0b3J5UmVzdWx0O1xuICAgIHRoaXMuYXR0ZW1wdGVkVHlwZSA9IHR5cGU7XG4gIH1cbn07XG5cbi8vIHNyYy9SZWdpc3RyeUh1Yi50c1xudmFyIGxvZ2dlcjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJSZWdpc3RyeUh1YlwiKTtcbnZhciBjcmVhdGVSZWdpc3RyeUh1YiA9ICgpID0+IHtcbiAgY29uc3QgcmVnaXN0cmllcyA9IHt9O1xuICBjb25zdCBjcmVhdGVSZWdpc3RyeTIgPSAodHlwZSwgZmFjdG9yeSkgPT4ge1xuICAgIGxvZ2dlcjQuZGVidWcoYENyZWF0aW5nIG5ldyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yKHR5cGUpO1xuICAgIH1cbiAgICBjb25zdCByZWdpc3RyeSA9IGZhY3RvcnkodHlwZSwgaHViKTtcbiAgICBpZiAoIShcInJlZ2lzdHJ5SHViXCIgaW4gcmVnaXN0cnkpIHx8IHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViICE9PSBodWIpIHtcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViID0gaHViO1xuICAgIH1cbiAgICByZWdpc3RyaWVzW3R5cGVdID0gcmVnaXN0cnk7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYW5kIHJlZ2lzdGVyZWQgbmV3IHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICAgIHJldHVybiByZWdpc3RyeTtcbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXJSZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSByZWdpc3RyeS50eXBlO1xuICAgIGxvZ2dlcjQuZGVidWcoYFJlZ2lzdGVyaW5nIHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIHJlZ2lzdHJpZXNbdHlwZV0gPSByZWdpc3RyeTtcbiAgICBpZiAoIShcInJlZ2lzdHJ5SHViXCIgaW4gcmVnaXN0cnkpIHx8IHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViICE9PSBodWIpIHtcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViID0gaHViO1xuICAgIH1cbiAgICBsb2dnZXI0LmRlYnVnKGBTdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgfTtcbiAgY29uc3QgZ2V0ID0gKHR5cGUsIGt0YSwgb3B0aW9ucykgPT4ge1xuICAgIGxvZ2dlcjQuZGVidWcoYExvb2tpbmcgdXAgaW5zdGFuY2UgZm9yIHR5cGU6ICR7dHlwZX0sIGt0YTogJHtrdGEuam9pbihcIi5cIil9LCBzY29wZXM6ICR7b3B0aW9ucz8uc2NvcGVzPy5qb2luKFwiLFwiKSB8fCBcIm5vbmVcIn1gKTtcbiAgICBjb25zdCByZWdpc3RyeSA9IHJlZ2lzdHJpZXNbdHlwZV07XG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgY29uc3QgYXZhaWxhYmxlVHlwZXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyaWVzKTtcbiAgICAgIHRocm93IG5ldyBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yKHR5cGUsIGF2YWlsYWJsZVR5cGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChrdGEsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBnZXRSZWdpc3RyeSA9ICh0eXBlKSA9PiB7XG4gICAgcmV0dXJuIHJlZ2lzdHJpZXNbdHlwZV0gfHwgbnVsbDtcbiAgfTtcbiAgY29uc3QgZ2V0UmVnaXN0ZXJlZFR5cGVzID0gKCkgPT4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyaWVzKTtcbiAgfTtcbiAgY29uc3QgdW5yZWdpc3RlclJlZ2lzdHJ5ID0gKHR5cGUpID0+IHtcbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgZGVsZXRlIHJlZ2lzdHJpZXNbdHlwZV07XG4gICAgICBsb2dnZXI0LmRlYnVnKGBVbnJlZ2lzdGVyZWQgcmVnaXN0cnkgdW5kZXIgdHlwZTogJHt0eXBlfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgY29uc3QgZ2V0QWxsQ29vcmRpbmF0ZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgYWxsQ29vcmRpbmF0ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlZ2lzdHJ5VHlwZSBpbiByZWdpc3RyaWVzKSB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IHJlZ2lzdHJpZXNbcmVnaXN0cnlUeXBlXTtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcmVnaXN0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2goKGNvb3JkaW5hdGUpID0+IHtcbiAgICAgICAgYWxsQ29vcmRpbmF0ZXMucHVzaCh7XG4gICAgICAgICAgY29vcmRpbmF0ZSxcbiAgICAgICAgICByZWdpc3RyeVR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgUmV0cmlldmVkICR7YWxsQ29vcmRpbmF0ZXMubGVuZ3RofSB0b3RhbCBjb29yZGluYXRlcyBmcm9tICR7T2JqZWN0LmtleXMocmVnaXN0cmllcykubGVuZ3RofSByZWdpc3RyaWVzYCk7XG4gICAgcmV0dXJuIGFsbENvb3JkaW5hdGVzO1xuICB9O1xuICBjb25zdCBodWIgPSB7XG4gICAgY3JlYXRlUmVnaXN0cnk6IGNyZWF0ZVJlZ2lzdHJ5MixcbiAgICByZWdpc3RlclJlZ2lzdHJ5LFxuICAgIGdldCxcbiAgICBnZXRSZWdpc3RyeSxcbiAgICBnZXRSZWdpc3RlcmVkVHlwZXMsXG4gICAgZ2V0QWxsQ29vcmRpbmF0ZXMsXG4gICAgdW5yZWdpc3RlclJlZ2lzdHJ5XG4gIH07XG4gIHJldHVybiBodWI7XG59O1xuXG4vLyBzcmMvZXJyb3JzL0luc3RhbmNlRXJyb3IudHNcbnZhciBJbnN0YW5jZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga2V5UGF0aDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwga2V5UGF0aCwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcmVnaXN0cnlUeXBlLCB7IC4uLmNvbnRleHQsIGtleVBhdGggfSk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgfVxufTtcbnZhciBJbnN0YW5jZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBtaXNzaW5nS2V5O1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBtaXNzaW5nS2V5LCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9YDtcbiAgICBpZiAobWlzc2luZ0tleSkge1xuICAgICAgbWVzc2FnZSArPSBgLCBNaXNzaW5nIGtleTogJHttaXNzaW5nS2V5fWA7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgeyAuLi5jb250ZXh0LCBtaXNzaW5nS2V5IH0pO1xuICAgIHRoaXMubWlzc2luZ0tleSA9IG1pc3NpbmdLZXk7XG4gIH1cbn07XG52YXIgTm9JbnN0YW5jZXNSZWdpc3RlcmVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBObyBpbnN0YW5jZXMgcmVnaXN0ZXJlZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0uIFRoZSBrZXkgcGF0aCBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5IHRyZWUgYnV0IGNvbnRhaW5zIG5vIGluc3RhbmNlcy5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG59O1xudmFyIE5vSW5zdGFuY2VzQXZhaWxhYmxlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBObyBpbnN0YW5jZXMgYXZhaWxhYmxlIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfS4gVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIGFuIGludGVybmFsIHJlZ2lzdHJ5IHN0YXRlIGlzc3VlLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbn07XG52YXIgU2NvcGVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgcmVxdWVzdGVkU2NvcGVzO1xuICBhdmFpbGFibGVTY29wZXM7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHJlcXVlc3RlZFNjb3BlcywgYXZhaWxhYmxlU2NvcGVzID0gW10sIHJlZ2lzdHJ5VHlwZSkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3Blc1N0ciA9IHJlcXVlc3RlZFNjb3Blcy5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgYXZhaWxhYmxlU2NvcGVzU3RyID0gYXZhaWxhYmxlU2NvcGVzLm1hcCgoc2NvcGVzKSA9PiBgWyR7c2NvcGVzLmpvaW4oXCIsIFwiKX1dYCkuam9pbihcIiwgXCIpO1xuICAgIGxldCBtZXNzYWdlID0gYE5vIGluc3RhbmNlIGZvdW5kIG1hdGNoaW5nIHNjb3BlczogJHtzY29wZXNTdHJ9IGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfWA7XG4gICAgaWYgKGF2YWlsYWJsZVNjb3Blcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlICs9IGAuIEF2YWlsYWJsZSBzY29wZXM6ICR7YXZhaWxhYmxlU2NvcGVzU3RyfWA7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgeyByZXF1ZXN0ZWRTY29wZXMsIGF2YWlsYWJsZVNjb3BlcyB9KTtcbiAgICB0aGlzLnJlcXVlc3RlZFNjb3BlcyA9IHJlcXVlc3RlZFNjb3BlcztcbiAgICB0aGlzLmF2YWlsYWJsZVNjb3BlcyA9IGF2YWlsYWJsZVNjb3BlcztcbiAgfVxufTtcbnZhciBOb0NoaWxkcmVuQXZhaWxhYmxlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBwYXJlbnRLZXk7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHBhcmVudEtleSwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfSwgTm8gY2hpbGRyZW4gZm9yOiAke3BhcmVudEtleX0uIFRoZSBwYXRoIGNhbm5vdCBiZSB0cmF2ZXJzZWQgZnVydGhlciBhcyAnJHtwYXJlbnRLZXl9JyBoYXMgbm8gY2hpbGQgbm9kZXMuYCxcbiAgICAgIGtleVBhdGgsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IC4uLmNvbnRleHQsIHBhcmVudEtleSB9XG4gICAgKTtcbiAgICB0aGlzLnBhcmVudEtleSA9IHBhcmVudEtleTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9Db29yZGluYXRlRXJyb3IudHNcbnZhciBDb29yZGluYXRlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrdGE7XG4gIHNjb3BlcztcbiAgY29uc3RydWN0b3IobWVzc2FnZSwga3RhLCBzY29wZXMsIGNvbnRleHQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBcIlwiLCB7IC4uLmNvbnRleHQsIGt0YSwgc2NvcGVzIH0pO1xuICAgIHRoaXMua3RhID0ga3RhO1xuICAgIHRoaXMuc2NvcGVzID0gc2NvcGVzO1xuICB9XG59O1xudmFyIEludmFsaWRDb29yZGluYXRlRXJyb3IgPSBjbGFzcyBleHRlbmRzIENvb3JkaW5hdGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGt0YSwgc2NvcGVzLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhbGlkIGNvb3JkaW5hdGUgcGFyYW1ldGVyczogJHtyZWFzb259LiBLVEE6ICR7SlNPTi5zdHJpbmdpZnkoa3RhKX0sIFNjb3BlczogWyR7c2NvcGVzLmpvaW4oXCIsIFwiKX1dYCxcbiAgICAgIGt0YSxcbiAgICAgIHNjb3BlcyxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uIH1cbiAgICApO1xuICB9XG59O1xudmFyIEludmFsaWRLVEFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa3RhLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhbGlkIEtUQSAoS2V5IFR5cGUgQXJyYXkpOiAke3JlYXNvbn0uIEV4cGVjdGVkIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoa3RhKX1gLFxuICAgICAga3RhLFxuICAgICAgW10sXG4gICAgICB7IC4uLmNvbnRleHQsIHJlYXNvbiB9XG4gICAgKTtcbiAgfVxufTtcbnZhciBJbnZhbGlkU2NvcGVzRXJyb3IgPSBjbGFzcyBleHRlbmRzIENvb3JkaW5hdGVFcnJvciB7XG4gIGludmFsaWRTY29wZXM7XG4gIGNvbnN0cnVjdG9yKHNjb3BlcywgaW52YWxpZFNjb3BlcywgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBzY29wZXM6ICR7cmVhc29ufS4gSW52YWxpZCBzY29wZSB2YWx1ZXM6ICR7SlNPTi5zdHJpbmdpZnkoaW52YWxpZFNjb3Blcyl9YCxcbiAgICAgIG51bGwsXG4gICAgICBzY29wZXMuZmlsdGVyKChzKSA9PiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiksXG4gICAgICB7IC4uLmNvbnRleHQsIHJlYXNvbiwgaW52YWxpZFNjb3BlcyB9XG4gICAgKTtcbiAgICB0aGlzLmludmFsaWRTY29wZXMgPSBpbnZhbGlkU2NvcGVzO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQ29vcmRpbmF0ZUVycm9yLFxuICBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcixcbiAgSW5zdGFuY2VFcnJvcixcbiAgSW5zdGFuY2VOb3RGb3VuZEVycm9yLFxuICBJbnZhbGlkQ29vcmRpbmF0ZUVycm9yLFxuICBJbnZhbGlkRmFjdG9yeVJlc3VsdEVycm9yLFxuICBJbnZhbGlkSW5zdGFuY2VSZWdpc3RyYXRpb25FcnJvcixcbiAgSW52YWxpZEtUQUVycm9yLFxuICBJbnZhbGlkUmVnaXN0cnlGYWN0b3J5UmVzdWx0RXJyb3IsXG4gIEludmFsaWRTY29wZXNFcnJvcixcbiAgTm9DaGlsZHJlbkF2YWlsYWJsZUVycm9yLFxuICBOb0luc3RhbmNlc0F2YWlsYWJsZUVycm9yLFxuICBOb0luc3RhbmNlc1JlZ2lzdGVyZWRFcnJvcixcbiAgUmVnaXN0cnlDcmVhdGlvbkVycm9yLFxuICBSZWdpc3RyeUVycm9yLFxuICBSZWdpc3RyeUZhY3RvcnlFcnJvcixcbiAgUmVnaXN0cnlIdWJFcnJvcixcbiAgUmVnaXN0cnlTdGF0cyxcbiAgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvcixcbiAgU2NvcGVOb3RGb3VuZEVycm9yLFxuICBjcmVhdGVDb29yZGluYXRlLFxuICBjcmVhdGVJbnN0YW5jZSxcbiAgY3JlYXRlUmVnaXN0cnksXG4gIGNyZWF0ZVJlZ2lzdHJ5SHViLFxuICBpc0luc3RhbmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../fjell-client-api/node_modules/@fjell/registry/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-core/node_modules/@fjell/logging/dist/index.js":
/*!***************************************************************!*\
  !*** ../fjell-core/node_modules/@fjell/logging/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY29yZS9ub2RlX21vZHVsZXMvQGZqZWxsL2xvZ2dpbmcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEtBQUs7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3dCO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXLHlDQUFZO0FBQ3ZCLElBQUk7QUFDSix1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0NBQVc7QUFDdEIsSUFBSTtBQUNKLGNBQWMsU0FBUyxFQUFFLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixzQkFBc0IsaUJBQWlCLEVBQUUsMEJBQTBCO0FBQ25FO0FBQ0EsZUFBZSx1Q0FBdUMsS0FBSyxXQUFXLE9BQU8scUJBQXFCLElBQUksc0NBQXNDLEVBQUUsS0FBSyxFQUFFLFdBQVc7QUFDaEs7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVDQUF1QyxLQUFLLFdBQVcsT0FBTyxxQkFBcUIsSUFBSSxzQ0FBc0MsRUFBRSxLQUFLLEVBQUUsOENBQThDLEVBQUUsMkJBQTJCLEVBQUUsVUFBVTtBQUMzUDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFzQyxFQUFFLElBQUk7QUFDbkUsT0FBTztBQUNQLHdEQUF3RDtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFzQyxFQUFFLElBQUk7QUFDbkUsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYSx5Q0FBYTtBQUMxQjtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVEsRUFBRSxXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJDQUEyQywrREFBK0Q7QUFDMUc7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFNcEI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9AZmplbGwvbG9nZ2luZy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9Mb2dGb3JtYXQudHNcbnZhciBMb2dGb3JtYXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoTG9nRm9ybWF0X2V4cG9ydHMsIHtcbiAgTG9nRm9ybWF0czogKCkgPT4gTG9nRm9ybWF0cyxcbiAgU1RSVUNUVVJFRDogKCkgPT4gU1RSVUNUVVJFRCxcbiAgVEVYVDogKCkgPT4gVEVYVCxcbiAgZ2V0Q29uZmlnOiAoKSA9PiBnZXRDb25maWdcbn0pO1xudmFyIFRFWFQgPSB7XG4gIG5hbWU6IFwiVEVYVFwiLFxuICBkZXNjcmlwdGlvbjogXCJUZXh0IGZvcm1hdFwiXG59O1xudmFyIFNUUlVDVFVSRUQgPSB7XG4gIG5hbWU6IFwiU1RSVUNUVVJFRFwiLFxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmVkIGZvcm1hdFwiXG59O1xudmFyIExvZ0Zvcm1hdHMgPSBbXG4gIFRFWFQsXG4gIFNUUlVDVFVSRURcbl07XG52YXIgZ2V0Q29uZmlnID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gTG9nRm9ybWF0cy5maW5kKChjb25maWcyKSA9PiBjb25maWcyLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMb2cgRm9ybWF0IFN1cHBsaWVkIHRvIExvZ2dpbmcgQ29uZmlndXJhdGlvbiAnJHtuYW1lfSdgKTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufTtcblxuLy8gc3JjL0xvZ0xldmVsLnRzXG52YXIgTG9nTGV2ZWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoTG9nTGV2ZWxfZXhwb3J0cywge1xuICBBTEVSVDogKCkgPT4gQUxFUlQsXG4gIENSSVRJQ0FMOiAoKSA9PiBDUklUSUNBTCxcbiAgREVCVUc6ICgpID0+IERFQlVHLFxuICBERUZBVUxUOiAoKSA9PiBERUZBVUxULFxuICBFTUVSR0VOQ1k6ICgpID0+IEVNRVJHRU5DWSxcbiAgRVJST1I6ICgpID0+IEVSUk9SLFxuICBJTkZPOiAoKSA9PiBJTkZPLFxuICBMb2dMZXZlbHM6ICgpID0+IExvZ0xldmVscyxcbiAgTk9USUNFOiAoKSA9PiBOT1RJQ0UsXG4gIFRSQUNFOiAoKSA9PiBUUkFDRSxcbiAgV0FSTklORzogKCkgPT4gV0FSTklORyxcbiAgZ2V0Q29uZmlnOiAoKSA9PiBnZXRDb25maWcyXG59KTtcbnZhciBFTUVSR0VOQ1kgPSB7XG4gIG5hbWU6IFwiRU1FUkdFTkNZXCIsXG4gIHZhbHVlOiAwXG59O1xudmFyIEFMRVJUID0ge1xuICBuYW1lOiBcIkFMRVJUXCIsXG4gIHZhbHVlOiAxXG59O1xudmFyIENSSVRJQ0FMID0ge1xuICBuYW1lOiBcIkNSSVRJQ0FMXCIsXG4gIHZhbHVlOiAyXG59O1xudmFyIEVSUk9SID0ge1xuICBuYW1lOiBcIkVSUk9SXCIsXG4gIHZhbHVlOiAzXG59O1xudmFyIFdBUk5JTkcgPSB7XG4gIG5hbWU6IFwiV0FSTklOR1wiLFxuICB2YWx1ZTogNFxufTtcbnZhciBOT1RJQ0UgPSB7XG4gIG5hbWU6IFwiTk9USUNFXCIsXG4gIHZhbHVlOiA1XG59O1xudmFyIElORk8gPSB7XG4gIG5hbWU6IFwiSU5GT1wiLFxuICB2YWx1ZTogNlxufTtcbnZhciBERUJVRyA9IHtcbiAgbmFtZTogXCJERUJVR1wiLFxuICB2YWx1ZTogN1xufTtcbnZhciBUUkFDRSA9IHtcbiAgbmFtZTogXCJUUkFDRVwiLFxuICB2YWx1ZTogOFxufTtcbnZhciBERUZBVUxUID0ge1xuICBuYW1lOiBcIkRFRkFVTFRcIixcbiAgdmFsdWU6IDlcbn07XG52YXIgTG9nTGV2ZWxzID0gW1xuICBFTUVSR0VOQ1ksXG4gIEFMRVJULFxuICBDUklUSUNBTCxcbiAgRVJST1IsXG4gIFdBUk5JTkcsXG4gIE5PVElDRSxcbiAgSU5GTyxcbiAgREVCVUcsXG4gIFRSQUNFLFxuICBERUZBVUxUXG5dO1xudmFyIGdldENvbmZpZzIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dMZXZlbHMuZmluZCgoY29uZmlnMikgPT4gY29uZmlnMi5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG9nIExldmVsIFN1cHBsaWVkIHRvIExvZ2dpbmcgQ29uZmlndXJhdGlvbiAnJHtuYW1lfSdgKTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufTtcblxuLy8gc3JjL2NvbmZpZy50c1xudmFyIGRlZmF1bHRMb2dMZXZlbCA9IElORk87XG52YXIgZGVmYXVsdExvZ0Zvcm1hdCA9IFRFWFQ7XG52YXIgZGVmYXVsdExvZ2dpbmdDb25maWcgPSB7XG4gIGxvZ0xldmVsOiBkZWZhdWx0TG9nTGV2ZWwsXG4gIGxvZ0Zvcm1hdDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgb3ZlcnJpZGVzOiB7fSxcbiAgZmxvb2RDb250cm9sOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgdGhyZXNob2xkOiAxMCxcbiAgICB0aW1lZnJhbWU6IDFlM1xuICAgIC8vIDEgc2Vjb25kXG4gIH1cbn07XG52YXIgY29udmVydE92ZXJyaWRlcyA9IChvdmVycmlkZXMpID0+IHtcbiAgY29uc3QgY29udmVydGVkT3ZlcnJpZGVzID0ge307XG4gIGlmIChvdmVycmlkZXMpIHtcbiAgICBPYmplY3QuZW50cmllcyhvdmVycmlkZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29udmVydGVkT3ZlcnJpZGVzW2tleV0gPSB7IGxvZ0xldmVsOiB2YWx1ZS5sb2dMZXZlbCA/IGdldENvbmZpZzIodmFsdWUubG9nTGV2ZWwpIDogZGVmYXVsdExvZ0xldmVsIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE92ZXJyaWRlcztcbn07XG52YXIgY29udmVydENvbmZpZyA9IChjb25maWcpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBsb2dMZXZlbDogY29uZmlnLmxvZ0xldmVsID8gZ2V0Q29uZmlnMihjb25maWcubG9nTGV2ZWwpIDogZGVmYXVsdExvZ0xldmVsLFxuICAgIGxvZ0Zvcm1hdDogY29uZmlnLmxvZ0Zvcm1hdCA/IGdldENvbmZpZyhjb25maWcubG9nRm9ybWF0KSA6IGRlZmF1bHRMb2dGb3JtYXQsXG4gICAgb3ZlcnJpZGVzOiBjb252ZXJ0T3ZlcnJpZGVzKGNvbmZpZy5vdmVycmlkZXMpLFxuICAgIGZsb29kQ29udHJvbDoge1xuICAgICAgLi4uZGVmYXVsdExvZ2dpbmdDb25maWcuZmxvb2RDb250cm9sLFxuICAgICAgLi4uY29uZmlnLmZsb29kQ29udHJvbCB8fCB7fVxuICAgIH1cbiAgfTtcbn07XG52YXIgY29uZmlndXJlTG9nZ2luZyA9ICgpID0+IHtcbiAgbGV0IGNvbmZpZyA9IHt9O1xuICBjb25zdCBsb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuTE9HR0lOR19DT05GSUc7XG4gIGNvbnN0IGV4cG9Mb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuRVhQT19QVUJMSUNfTE9HR0lOR19DT05GSUc7XG4gIGNvbnN0IG5leHRMb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTE9HR0lOR19DT05GSUc7XG4gIGxldCBsb2dMZXZlbEVudiA9IHByb2Nlc3MuZW52LkxPR19MRVZFTDtcbiAgbGV0IGxvZ0Zvcm1hdEVudiA9IHByb2Nlc3MuZW52LkxPR19GT1JNQVQ7XG4gIGlmIChsb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UobG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBvTG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKGV4cG9Mb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBFWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKG5leHRMb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UobmV4dExvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIE5FWFRfUFVCTElDX0xPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29udmVydGVkQ29uZmlnID0gY29udmVydENvbmZpZyhjb25maWcpO1xuICBpZiAobG9nTGV2ZWxFbnYpIHtcbiAgICBsb2dMZXZlbEVudiA9IGxvZ0xldmVsRW52Py50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGxvZ0xldmVsQ29uZmlnID0gZ2V0Q29uZmlnMihsb2dMZXZlbEVudik7XG4gICAgY29udmVydGVkQ29uZmlnLmxvZ0xldmVsID0gbG9nTGV2ZWxDb25maWc7XG4gIH1cbiAgaWYgKGxvZ0Zvcm1hdEVudikge1xuICAgIGxvZ0Zvcm1hdEVudiA9IGxvZ0Zvcm1hdEVudi50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGxvZ0Zvcm1hdENvbmZpZyA9IGdldENvbmZpZyhsb2dGb3JtYXRFbnYpO1xuICAgIGNvbnZlcnRlZENvbmZpZy5sb2dGb3JtYXQgPSBsb2dGb3JtYXRDb25maWc7XG4gIH1cbiAgY29uc3QgZmluYWxDb25maWcgPSB7IC4uLmRlZmF1bHRMb2dnaW5nQ29uZmlnLCAuLi5jb252ZXJ0ZWRDb25maWcgfTtcbiAgcmV0dXJuIGZpbmFsQ29uZmlnO1xufTtcblxuLy8gc3JjL1dyaXRlci50c1xudmFyIGNyZWF0ZVdyaXRlciA9IChmb3JtYXR0ZXIsIGxvZ01ldGhvZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZXNwZWN0SW5qZWN0ZWRNZXRob2QgPSBmYWxzZSxcbiAgICBlcnJvck1ldGhvZCA9IGNvbnNvbGUuZXJyb3IsXG4gICAgd2FybmluZ01ldGhvZCA9IGNvbnNvbGUud2FybixcbiAgICBpbmZvTWV0aG9kID0gY29uc29sZS5sb2dcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgd3JpdGU6IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICAgIGxldCBmaW5hbExvZ01ldGhvZCA9IGxvZ01ldGhvZDtcbiAgICAgIGlmICghcmVzcGVjdEluamVjdGVkTWV0aG9kKSB7XG4gICAgICAgIGlmIChsZXZlbC5uYW1lID09PSBFUlJPUi5uYW1lIHx8IGxldmVsLm5hbWUgPT09IENSSVRJQ0FMLm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gQUxFUlQubmFtZSB8fCBsZXZlbC5uYW1lID09PSBFTUVSR0VOQ1kubmFtZSkge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gZXJyb3JNZXRob2Q7XG4gICAgICAgIH0gZWxzZSBpZiAobGV2ZWwubmFtZSA9PT0gV0FSTklORy5uYW1lKSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSB3YXJuaW5nTWV0aG9kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gaW5mb01ldGhvZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluYWxMb2dNZXRob2QoZm9ybWF0dGVyLmZvcm1hdExvZyhsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvZm9ybWF0dGVyLnRzXG5pbXBvcnQgdXRpbCBmcm9tIFwidXRpbFwiO1xudmFyIHNhZmVJbnNwZWN0ID0gKG9iaikgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qob2JqKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGBbT2JqZWN0OiAke3R5cGVvZiBvYmp9XWA7XG4gIH1cbn07XG52YXIgc2FmZUZvcm1hdCA9IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuZm9ybWF0KG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYCR7bWVzc2FnZX0gJHtzYWZlSW5zcGVjdChhcmdzKX1gO1xuICB9XG59O1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IChsb2dGb3JtYXQpID0+IHtcbiAgaWYgKGxvZ0Zvcm1hdC5uYW1lID09PSBcIlRFWFRcIikge1xuICAgIHJldHVybiBnZXRUZXh0Rm9ybWF0dGVyKCk7XG4gIH0gZWxzZSBpZiAobG9nRm9ybWF0Lm5hbWUgPT09IFwiU1RSVUNUVVJFRFwiKSB7XG4gICAgcmV0dXJuIGdldFN0cnVjdHVyZWRGb3JtYXR0ZXIoKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbG9nIGZvcm1hdDogJHtsb2dGb3JtYXQubmFtZX1gKTtcbn07XG52YXIgZ2V0VGV4dEZvcm1hdHRlciA9ICgpID0+IHtcbiAgY29uc3QgZm9ybWF0TG9nID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGhhc1NwZWNpZmllcnMgPSAvJVtzZGppZm9PJV0vLnRlc3QocGF5bG9hZC5tZXNzYWdlKTtcbiAgICBsZXQgbG9nTWVzc2FnZTtcbiAgICBpZiAocGF5bG9hZC5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nTWVzc2FnZSA9IHBheWxvYWQubWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKGhhc1NwZWNpZmllcnMpIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nTWVzc2FnZSA9IGAke3BheWxvYWQubWVzc2FnZX0gJHtzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpfWA7XG4gICAgfVxuICAgIHJldHVybiBgKCR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS52YWx1ZU9mKCl9KSBbJHtsZXZlbC5uYW1lfV0gLSBbJHtjb29yZGluYXRlcy5jYXRlZ29yeX1dICR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX0gJHtsb2dNZXNzYWdlfWA7XG4gIH07XG4gIGNvbnN0IHRpbWVyTWVzc2FnZSA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpO1xuICAgIGNvbnN0IHRpbWVyTWVzc2FnZTIgPSBgKCR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS52YWx1ZU9mKCl9KSBbJHtsZXZlbC5uYW1lfV0gLSBbJHtjb29yZGluYXRlcy5jYXRlZ29yeX1dICR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX0gJHtzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKX0gJHtzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpfSAke3JhbmRvbUludH1gO1xuICAgIHJldHVybiB0aW1lck1lc3NhZ2UyO1xuICB9O1xuICByZXR1cm4geyBmb3JtYXRMb2csIHRpbWVyTWVzc2FnZSwgZ2V0TG9nRm9ybWF0OiAoKSA9PiBURVhUIH07XG59O1xudmFyIGdldFN0cnVjdHVyZWRGb3JtYXR0ZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGZvcm1hdExvZyA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzZXZlcml0eSxcbiAgICAgIG1lc3NhZ2U6IGhhc1NwZWNpZmllcnMgPyBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKSA6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9sYWJlbHNcIjoge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IGAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9YFxuICAgICAgfSxcbiAgICAgIC4uLiFoYXNTcGVjaWZpZXJzICYmIHBheWxvYWQuZGF0YS5sZW5ndGggPiAwICYmIHsgZGF0YTogc2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKSB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHRpbWVyTWVzc2FnZSA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG4gICAgY29uc3QgcmFuZG9tSW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU2KTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc2V2ZXJpdHksXG4gICAgICBtZXNzYWdlOiBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9sYWJlbHNcIjoge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IGAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9YFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHNhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSksXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vc3BhbklkXCI6IFN0cmluZyhyYW5kb21JbnQpXG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB7IGZvcm1hdExvZywgdGltZXJNZXNzYWdlLCBnZXRMb2dGb3JtYXQ6ICgpID0+IFNUUlVDVFVSRUQgfTtcbn07XG5cbi8vIHNyYy9GbG9vZENvbnRyb2wudHNcbmltcG9ydCB1dGlsMiBmcm9tIFwidXRpbFwiO1xudmFyIGhhc2ggPSAobWVzc2FnZSwgZGF0YSkgPT4ge1xuICBjb25zdCBkYXRhU3RyaW5nID0gZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHV0aWwyLmluc3BlY3QoaXRlbSk7XG4gICAgfVxuICB9KS5qb2luKFwiXCIpO1xuICByZXR1cm4gYCR7bWVzc2FnZX0ke2RhdGFTdHJpbmd9YDtcbn07XG52YXIgRmxvb2RDb250cm9sID0gY2xhc3Mge1xuICBjb25maWc7XG4gIGhpc3RvcnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdXBwcmVzc2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5jbGVhbnVwKCksIHRoaXMuY29uZmlnLnRpbWVmcmFtZSAqIDIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmNsZWFudXBUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IFtoYXNoMiwgdGltZXN0YW1wc10gb2YgdGhpcy5oaXN0b3J5LmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgcmVjZW50VGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuZmlsdGVyKFxuICAgICAgICAodGltZXN0YW1wKSA9PiBub3cgLSB0aW1lc3RhbXAgPCB0aGlzLmNvbmZpZy50aW1lZnJhbWVcbiAgICAgICk7XG4gICAgICBpZiAocmVjZW50VGltZXN0YW1wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5zZXQoaGFzaDIsIHJlY2VudFRpbWVzdGFtcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LmRlbGV0ZShoYXNoMik7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5kZWxldGUoaGFzaDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGVjayhtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gXCJsb2dcIjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBoYXNoKG1lc3NhZ2UsIGRhdGEpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9ICh0aGlzLmhpc3RvcnkuZ2V0KG1lc3NhZ2VIYXNoKSB8fCBbXSkuZmlsdGVyKFxuICAgICAgKHRpbWVzdGFtcCkgPT4gbm93IC0gdGltZXN0YW1wIDwgdGhpcy5jb25maWcudGltZWZyYW1lXG4gICAgKTtcbiAgICB0aW1lc3RhbXBzLnB1c2gobm93KTtcbiAgICB0aGlzLmhpc3Rvcnkuc2V0KG1lc3NhZ2VIYXNoLCB0aW1lc3RhbXBzKTtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPiB0aGlzLmNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgIGNvbnN0IHN1cHByZXNzZWRJbmZvID0gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk7XG4gICAgICBpZiAoc3VwcHJlc3NlZEluZm8pIHtcbiAgICAgICAgc3VwcHJlc3NlZEluZm8uY291bnQrKztcbiAgICAgICAgcmV0dXJuIFwic3VwcHJlc3NcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5zZXQobWVzc2FnZUhhc2gsIHsgY291bnQ6IDEsIGZpcnN0VGltZXN0YW1wOiB0aW1lc3RhbXBzWzBdLCBzdW1tYXJ5TG9nZ2VkOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIFwic3VwcHJlc3NcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuc3VwcHJlc3NlZC5oYXMobWVzc2FnZUhhc2gpKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5kZWxldGUobWVzc2FnZUhhc2gpO1xuICAgICAgICByZXR1cm4gXCJyZXN1bWVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwibG9nXCI7XG4gIH1cbiAgZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuc3VwcHJlc3NlZC5nZXQobWVzc2FnZUhhc2gpPy5jb3VudCB8fCAwO1xuICB9XG59O1xuXG4vLyBzcmMvTG9nZ2VyLnRzXG52YXIgY3JlYXRlTG9nZ2VyID0gKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBmbG9vZENvbnRyb2xDb25maWcsIHdyaXRlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGxvZ0Zvcm1hdCk7XG4gIGNvbnN0IGZsb29kQ29udHJvbCA9IGZsb29kQ29udHJvbENvbmZpZy5lbmFibGVkID8gbmV3IEZsb29kQ29udHJvbChmbG9vZENvbnRyb2xDb25maWcpIDogbnVsbDtcbiAgY29uc3QgbG9nRnVuY3Rpb24gPSBjb25zb2xlLmxvZztcbiAgY29uc3Qgd3JpdGVyID0gY3JlYXRlV3JpdGVyKGZvcm1hdHRlciwgbG9nRnVuY3Rpb24sIHdyaXRlck9wdGlvbnMpO1xuICBjb25zdCB3cml0ZSA9IChsZXZlbCwgbWVzc2FnZSwgZGF0YSkgPT4ge1xuICAgIGlmIChsb2dMZXZlbC52YWx1ZSA8IGxldmVsLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrID0gZmxvb2RDb250cm9sID8gZmxvb2RDb250cm9sLmNoZWNrKG1lc3NhZ2UsIGRhdGEpIDogXCJsb2dcIjtcbiAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG4gICAgc3dpdGNoIChjaGVjaykge1xuICAgICAgY2FzZSBcImxvZ1wiOlxuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3VwcHJlc3NcIjpcbiAgICAgICAgaWYgKGZsb29kQ29udHJvbCAmJiBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpID09PSAxKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGNvbnN0IG5ld1BheWxvYWQgPSB7IG1lc3NhZ2U6IGBTdGFydGVkIHN1cHByZXNzaW5nIHJlcGVhdGVkIGxvZyBtZXNzYWdlYCwgZGF0YTogW10gfTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUob3JpZ2luYWxMZXZlbCwgY29vcmRpbmF0ZXMsIG5ld1BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlc3VtZVwiOiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZmxvb2RDb250cm9sID8gZmxvb2RDb250cm9sLmdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSA6IDA7XG4gICAgICAgIGNvbnN0IHJlc3VtZVBheWxvYWQgPSB7XG4gICAgICAgICAgbWVzc2FnZTogYFN0b3BwZWQgc3VwcHJlc3NpbmcgcmVwZWF0ZWQgbG9nIG1lc3NhZ2UuIFN1cHByZXNzZWQgJHtjb3VudH0gdGltZXMuYCxcbiAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9O1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCByZXN1bWVQYXlsb2FkKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhcnRUaW1lTG9nZ2VyID0gKGxvZ0xldmVsMiwgY29vcmRpbmF0ZXMyLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlID0gZm9ybWF0dGVyLnRpbWVyTWVzc2FnZShsb2dMZXZlbDIsIGNvb3JkaW5hdGVzMiwgcGF5bG9hZCk7XG4gICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZSh0aW1lck1lc3NhZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZUVuZCh0aW1lck1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICAgIGxvZzogKC4uLmRhdGEpID0+IHtcbiAgICAgICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZUxvZyh0aW1lck1lc3NhZ2UsIC4uLmRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgZW1lcmdlbmN5OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoRU1FUkdFTkNZLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGFsZXJ0OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoQUxFUlQsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgY3JpdGljYWw6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShDUklUSUNBTCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBlcnJvcjogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEVSUk9SLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHdhcm5pbmc6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShXQVJOSU5HLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIG5vdGljZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKE5PVElDRSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoSU5GTywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBkZWJ1ZzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKERFQlVHLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHRyYWNlOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoVFJBQ0UsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZGVmYXVsdDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKERFRkFVTFQsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgdGltZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG1lc3NhZ2UsIGRhdGEgfTtcbiAgICAgIHJldHVybiBzdGFydFRpbWVMb2dnZXIobG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICB9LFxuICAgIGdldDogKC4uLmFkZGl0aW9uYWxDb21wb25lbnRzKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlTG9nZ2VyKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBbLi4uY29vcmRpbmF0ZXMuY29tcG9uZW50cywgLi4uYWRkaXRpb25hbENvbXBvbmVudHNdXG4gICAgICB9LCBmbG9vZENvbnRyb2xDb25maWcsIHdyaXRlck9wdGlvbnMpO1xuICAgIH0sXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgaWYgKGZsb29kQ29udHJvbCkge1xuICAgICAgICBmbG9vZENvbnRyb2wuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9sb2dnaW5nLnRzXG52YXIgZ2V0TG9nZ2VyID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gY29uZmlndXJlTG9nZ2luZygpO1xuICBjb25zdCBsb2dnZXIgPSBjcmVhdGVCYXNlTG9nZ2VyKG5hbWUsIGNvbmZpZyk7XG4gIHJldHVybiBsb2dnZXI7XG59O1xudmFyIGNyZWF0ZUJhc2VMb2dnZXIgPSAobmFtZSwgY29uZmlnKSA9PiB7XG4gIGxldCB7IGxvZ0xldmVsIH0gPSBjb25maWc7XG4gIGNvbnN0IHsgbG9nRm9ybWF0LCBmbG9vZENvbnRyb2wgfSA9IGNvbmZpZztcbiAgY29uc3Qgb3ZlcnJpZGVzID0gY29uZmlnLm92ZXJyaWRlcztcbiAgaWYgKG92ZXJyaWRlcyAmJiBvdmVycmlkZXNbbmFtZV0pIHtcbiAgICBsb2dMZXZlbCA9IG92ZXJyaWRlc1tuYW1lXS5sb2dMZXZlbDtcbiAgfVxuICBjb25zdCBjb29yZGluYXRlcyA9IHsgY2F0ZWdvcnk6IG5hbWUsIGNvbXBvbmVudHM6IFtdIH07XG4gIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbCk7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0geyBnZXRMb2dnZXIgfTtcbmV4cG9ydCB7XG4gIExvZ0Zvcm1hdF9leHBvcnRzIGFzIExvZ0Zvcm1hdCxcbiAgTG9nTGV2ZWxfZXhwb3J0cyBhcyBMb2dMZXZlbCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBnZXRMb2dnZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../fjell-core/node_modules/@fjell/logging/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-http-api/node_modules/@fjell/logging/dist/index.js":
/*!*******************************************************************!*\
  !*** ../fjell-http-api/node_modules/@fjell/logging/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtaHR0cC1hcGkvbm9kZV9tb2R1bGVzL0BmamVsbC9sb2dnaW5nL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxLQUFLO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQixVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBTXBCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtaHR0cC1hcGkvbm9kZV9tb2R1bGVzL0BmamVsbC9sb2dnaW5nL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL0xvZ0Zvcm1hdC50c1xudmFyIExvZ0Zvcm1hdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dGb3JtYXRfZXhwb3J0cywge1xuICBMb2dGb3JtYXRzOiAoKSA9PiBMb2dGb3JtYXRzLFxuICBTVFJVQ1RVUkVEOiAoKSA9PiBTVFJVQ1RVUkVELFxuICBURVhUOiAoKSA9PiBURVhULFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZ1xufSk7XG52YXIgVEVYVCA9IHtcbiAgbmFtZTogXCJURVhUXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlRleHQgZm9ybWF0XCJcbn07XG52YXIgU1RSVUNUVVJFRCA9IHtcbiAgbmFtZTogXCJTVFJVQ1RVUkVEXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZWQgZm9ybWF0XCJcbn07XG52YXIgTG9nRm9ybWF0cyA9IFtcbiAgVEVYVCxcbiAgU1RSVUNUVVJFRFxuXTtcbnZhciBnZXRDb25maWcgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dGb3JtYXRzLmZpbmQoKGNvbmZpZzIpID0+IGNvbmZpZzIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBGb3JtYXQgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvTG9nTGV2ZWwudHNcbnZhciBMb2dMZXZlbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dMZXZlbF9leHBvcnRzLCB7XG4gIEFMRVJUOiAoKSA9PiBBTEVSVCxcbiAgQ1JJVElDQUw6ICgpID0+IENSSVRJQ0FMLFxuICBERUJVRzogKCkgPT4gREVCVUcsXG4gIERFRkFVTFQ6ICgpID0+IERFRkFVTFQsXG4gIEVNRVJHRU5DWTogKCkgPT4gRU1FUkdFTkNZLFxuICBFUlJPUjogKCkgPT4gRVJST1IsXG4gIElORk86ICgpID0+IElORk8sXG4gIExvZ0xldmVsczogKCkgPT4gTG9nTGV2ZWxzLFxuICBOT1RJQ0U6ICgpID0+IE5PVElDRSxcbiAgVFJBQ0U6ICgpID0+IFRSQUNFLFxuICBXQVJOSU5HOiAoKSA9PiBXQVJOSU5HLFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZzJcbn0pO1xudmFyIEVNRVJHRU5DWSA9IHtcbiAgbmFtZTogXCJFTUVSR0VOQ1lcIixcbiAgdmFsdWU6IDBcbn07XG52YXIgQUxFUlQgPSB7XG4gIG5hbWU6IFwiQUxFUlRcIixcbiAgdmFsdWU6IDFcbn07XG52YXIgQ1JJVElDQUwgPSB7XG4gIG5hbWU6IFwiQ1JJVElDQUxcIixcbiAgdmFsdWU6IDJcbn07XG52YXIgRVJST1IgPSB7XG4gIG5hbWU6IFwiRVJST1JcIixcbiAgdmFsdWU6IDNcbn07XG52YXIgV0FSTklORyA9IHtcbiAgbmFtZTogXCJXQVJOSU5HXCIsXG4gIHZhbHVlOiA0XG59O1xudmFyIE5PVElDRSA9IHtcbiAgbmFtZTogXCJOT1RJQ0VcIixcbiAgdmFsdWU6IDVcbn07XG52YXIgSU5GTyA9IHtcbiAgbmFtZTogXCJJTkZPXCIsXG4gIHZhbHVlOiA2XG59O1xudmFyIERFQlVHID0ge1xuICBuYW1lOiBcIkRFQlVHXCIsXG4gIHZhbHVlOiA3XG59O1xudmFyIFRSQUNFID0ge1xuICBuYW1lOiBcIlRSQUNFXCIsXG4gIHZhbHVlOiA4XG59O1xudmFyIERFRkFVTFQgPSB7XG4gIG5hbWU6IFwiREVGQVVMVFwiLFxuICB2YWx1ZTogOVxufTtcbnZhciBMb2dMZXZlbHMgPSBbXG4gIEVNRVJHRU5DWSxcbiAgQUxFUlQsXG4gIENSSVRJQ0FMLFxuICBFUlJPUixcbiAgV0FSTklORyxcbiAgTk9USUNFLFxuICBJTkZPLFxuICBERUJVRyxcbiAgVFJBQ0UsXG4gIERFRkFVTFRcbl07XG52YXIgZ2V0Q29uZmlnMiA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0xldmVscy5maW5kKChjb25maWcyKSA9PiBjb25maWcyLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMb2cgTGV2ZWwgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgZGVmYXVsdExvZ0xldmVsID0gSU5GTztcbnZhciBkZWZhdWx0TG9nRm9ybWF0ID0gVEVYVDtcbnZhciBkZWZhdWx0TG9nZ2luZ0NvbmZpZyA9IHtcbiAgbG9nTGV2ZWw6IGRlZmF1bHRMb2dMZXZlbCxcbiAgbG9nRm9ybWF0OiBkZWZhdWx0TG9nRm9ybWF0LFxuICBvdmVycmlkZXM6IHt9LFxuICBmbG9vZENvbnRyb2w6IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICAgIHRpbWVmcmFtZTogMWUzXG4gICAgLy8gMSBzZWNvbmRcbiAgfVxufTtcbnZhciBjb252ZXJ0T3ZlcnJpZGVzID0gKG92ZXJyaWRlcykgPT4ge1xuICBjb25zdCBjb252ZXJ0ZWRPdmVycmlkZXMgPSB7fTtcbiAgaWYgKG92ZXJyaWRlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKG92ZXJyaWRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjb252ZXJ0ZWRPdmVycmlkZXNba2V5XSA9IHsgbG9nTGV2ZWw6IHZhbHVlLmxvZ0xldmVsID8gZ2V0Q29uZmlnMih2YWx1ZS5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3ZlcnJpZGVzO1xufTtcbnZhciBjb252ZXJ0Q29uZmlnID0gKGNvbmZpZykgPT4ge1xuICByZXR1cm4ge1xuICAgIGxvZ0xldmVsOiBjb25maWcubG9nTGV2ZWwgPyBnZXRDb25maWcyKGNvbmZpZy5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwsXG4gICAgbG9nRm9ybWF0OiBjb25maWcubG9nRm9ybWF0ID8gZ2V0Q29uZmlnKGNvbmZpZy5sb2dGb3JtYXQpIDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgICBvdmVycmlkZXM6IGNvbnZlcnRPdmVycmlkZXMoY29uZmlnLm92ZXJyaWRlcyksXG4gICAgZmxvb2RDb250cm9sOiB7XG4gICAgICAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZy5mbG9vZENvbnRyb2wsXG4gICAgICAuLi5jb25maWcuZmxvb2RDb250cm9sIHx8IHt9XG4gICAgfVxuICB9O1xufTtcbnZhciBjb25maWd1cmVMb2dnaW5nID0gKCkgPT4ge1xuICBsZXQgY29uZmlnID0ge307XG4gIGNvbnN0IGxvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgZXhwb0xvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5FWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgbmV4dExvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgbGV0IGxvZ0xldmVsRW52ID0gcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuICBsZXQgbG9nRm9ybWF0RW52ID0gcHJvY2Vzcy5lbnYuTE9HX0ZPUk1BVDtcbiAgaWYgKGxvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShsb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBMT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cG9Mb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoZXhwb0xvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIEVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV4dExvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShuZXh0TG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gTkVYVF9QVUJMSUNfTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfVxuICBjb25zdCBjb252ZXJ0ZWRDb25maWcgPSBjb252ZXJ0Q29uZmlnKGNvbmZpZyk7XG4gIGlmIChsb2dMZXZlbEVudikge1xuICAgIGxvZ0xldmVsRW52ID0gbG9nTGV2ZWxFbnY/LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nTGV2ZWxDb25maWcgPSBnZXRDb25maWcyKGxvZ0xldmVsRW52KTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nTGV2ZWwgPSBsb2dMZXZlbENvbmZpZztcbiAgfVxuICBpZiAobG9nRm9ybWF0RW52KSB7XG4gICAgbG9nRm9ybWF0RW52ID0gbG9nRm9ybWF0RW52LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nRm9ybWF0Q29uZmlnID0gZ2V0Q29uZmlnKGxvZ0Zvcm1hdEVudik7XG4gICAgY29udmVydGVkQ29uZmlnLmxvZ0Zvcm1hdCA9IGxvZ0Zvcm1hdENvbmZpZztcbiAgfVxuICBjb25zdCBmaW5hbENvbmZpZyA9IHsgLi4uZGVmYXVsdExvZ2dpbmdDb25maWcsIC4uLmNvbnZlcnRlZENvbmZpZyB9O1xuICByZXR1cm4gZmluYWxDb25maWc7XG59O1xuXG4vLyBzcmMvV3JpdGVyLnRzXG52YXIgY3JlYXRlV3JpdGVyID0gKGZvcm1hdHRlciwgbG9nTWV0aG9kLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlc3BlY3RJbmplY3RlZE1ldGhvZCA9IGZhbHNlLFxuICAgIGVycm9yTWV0aG9kID0gY29uc29sZS5lcnJvcixcbiAgICB3YXJuaW5nTWV0aG9kID0gY29uc29sZS53YXJuLFxuICAgIGluZm9NZXRob2QgPSBjb25zb2xlLmxvZ1xuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICB3cml0ZTogKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgICAgbGV0IGZpbmFsTG9nTWV0aG9kID0gbG9nTWV0aG9kO1xuICAgICAgaWYgKCFyZXNwZWN0SW5qZWN0ZWRNZXRob2QpIHtcbiAgICAgICAgaWYgKGxldmVsLm5hbWUgPT09IEVSUk9SLm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gQ1JJVElDQUwubmFtZSB8fCBsZXZlbC5uYW1lID09PSBBTEVSVC5uYW1lIHx8IGxldmVsLm5hbWUgPT09IEVNRVJHRU5DWS5uYW1lKSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBlcnJvck1ldGhvZDtcbiAgICAgICAgfSBlbHNlIGlmIChsZXZlbC5uYW1lID09PSBXQVJOSU5HLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IHdhcm5pbmdNZXRob2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBpbmZvTWV0aG9kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5hbExvZ01ldGhvZChmb3JtYXR0ZXIuZm9ybWF0TG9nKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9mb3JtYXR0ZXIudHNcbmltcG9ydCB1dGlsIGZyb20gXCJ1dGlsXCI7XG52YXIgc2FmZUluc3BlY3QgPSAob2JqKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChvYmopO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYFtPYmplY3Q6ICR7dHlwZW9mIG9ian1dYDtcbiAgfVxufTtcbnZhciBzYWZlRm9ybWF0ID0gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdXRpbC5mb3JtYXQobWVzc2FnZSwgLi4uYXJncyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgJHttZXNzYWdlfSAke3NhZmVJbnNwZWN0KGFyZ3MpfWA7XG4gIH1cbn07XG52YXIgY3JlYXRlRm9ybWF0dGVyID0gKGxvZ0Zvcm1hdCkgPT4ge1xuICBpZiAobG9nRm9ybWF0Lm5hbWUgPT09IFwiVEVYVFwiKSB7XG4gICAgcmV0dXJuIGdldFRleHRGb3JtYXR0ZXIoKTtcbiAgfSBlbHNlIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJTVFJVQ1RVUkVEXCIpIHtcbiAgICByZXR1cm4gZ2V0U3RydWN0dXJlZEZvcm1hdHRlcigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsb2cgZm9ybWF0OiAke2xvZ0Zvcm1hdC5uYW1lfWApO1xufTtcbnZhciBnZXRUZXh0Rm9ybWF0dGVyID0gKCkgPT4ge1xuICBjb25zdCBmb3JtYXRMb2cgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuICAgIGxldCBsb2dNZXNzYWdlO1xuICAgIGlmIChwYXlsb2FkLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dNZXNzYWdlID0gcGF5bG9hZC5tZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAoaGFzU3BlY2lmaWVycykge1xuICAgICAgbG9nTWVzc2FnZSA9IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dNZXNzYWdlID0gYCR7cGF5bG9hZC5tZXNzYWdlfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke2xvZ01lc3NhZ2V9YDtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHJhbmRvbUludCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlMiA9IGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke3NhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9ICR7cmFuZG9tSW50fWA7XG4gICAgcmV0dXJuIHRpbWVyTWVzc2FnZTI7XG4gIH07XG4gIHJldHVybiB7IGZvcm1hdExvZywgdGltZXJNZXNzYWdlLCBnZXRMb2dGb3JtYXQ6ICgpID0+IFRFWFQgfTtcbn07XG52YXIgZ2V0U3RydWN0dXJlZEZvcm1hdHRlciA9ICgpID0+IHtcbiAgY29uc3QgZm9ybWF0TG9nID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogaGFzU3BlY2lmaWVycyA/IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpIDogcGF5bG9hZC5tZXNzYWdlLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgLi4uIWhhc1NwZWNpZmllcnMgJiYgcGF5bG9hZC5kYXRhLmxlbmd0aCA+IDAgJiYgeyBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzZXZlcml0eSxcbiAgICAgIG1lc3NhZ2U6IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgZGF0YTogc2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9zcGFuSWRcIjogU3RyaW5nKHJhbmRvbUludClcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gU1RSVUNUVVJFRCB9O1xufTtcblxuLy8gc3JjL0Zsb29kQ29udHJvbC50c1xuaW1wb3J0IHV0aWwyIGZyb20gXCJ1dGlsXCI7XG52YXIgaGFzaCA9IChtZXNzYWdlLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGRhdGFTdHJpbmcgPSBkYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdXRpbDIuaW5zcGVjdChpdGVtKTtcbiAgICB9XG4gIH0pLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHttZXNzYWdlfSR7ZGF0YVN0cmluZ31gO1xufTtcbnZhciBGbG9vZENvbnRyb2wgPSBjbGFzcyB7XG4gIGNvbmZpZztcbiAgaGlzdG9yeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN1cHByZXNzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjbGVhbnVwVGltZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmNsZWFudXAoKSwgdGhpcy5jb25maWcudGltZWZyYW1lICogMik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2hhc2gyLCB0aW1lc3RhbXBzXSBvZiB0aGlzLmhpc3RvcnkuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByZWNlbnRUaW1lc3RhbXBzID0gdGltZXN0YW1wcy5maWx0ZXIoXG4gICAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChyZWNlbnRUaW1lc3RhbXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LnNldChoYXNoMiwgcmVjZW50VGltZXN0YW1wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpc3RvcnkuZGVsZXRlKGhhc2gyKTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShoYXNoMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBcImxvZ1wiO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gKHRoaXMuaGlzdG9yeS5nZXQobWVzc2FnZUhhc2gpIHx8IFtdKS5maWx0ZXIoXG4gICAgICAodGltZXN0YW1wKSA9PiBub3cgLSB0aW1lc3RhbXAgPCB0aGlzLmNvbmZpZy50aW1lZnJhbWVcbiAgICApO1xuICAgIHRpbWVzdGFtcHMucHVzaChub3cpO1xuICAgIHRoaXMuaGlzdG9yeS5zZXQobWVzc2FnZUhhc2gsIHRpbWVzdGFtcHMpO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA+IHRoaXMuY29uZmlnLnRocmVzaG9sZCkge1xuICAgICAgY29uc3Qgc3VwcHJlc3NlZEluZm8gPSB0aGlzLnN1cHByZXNzZWQuZ2V0KG1lc3NhZ2VIYXNoKTtcbiAgICAgIGlmIChzdXBwcmVzc2VkSW5mbykge1xuICAgICAgICBzdXBwcmVzc2VkSW5mby5jb3VudCsrO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLnNldChtZXNzYWdlSGFzaCwgeyBjb3VudDogMSwgZmlyc3RUaW1lc3RhbXA6IHRpbWVzdGFtcHNbMF0sIHN1bW1hcnlMb2dnZWQ6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zdXBwcmVzc2VkLmhhcyhtZXNzYWdlSGFzaCkpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShtZXNzYWdlSGFzaCk7XG4gICAgICAgIHJldHVybiBcInJlc3VtZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJsb2dcIjtcbiAgfVxuICBnZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkge1xuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk/LmNvdW50IHx8IDA7XG4gIH1cbn07XG5cbi8vIHNyYy9Mb2dnZXIudHNcbnZhciBjcmVhdGVMb2dnZXIgPSAobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIobG9nRm9ybWF0KTtcbiAgY29uc3QgZmxvb2RDb250cm9sID0gZmxvb2RDb250cm9sQ29uZmlnLmVuYWJsZWQgPyBuZXcgRmxvb2RDb250cm9sKGZsb29kQ29udHJvbENvbmZpZykgOiBudWxsO1xuICBjb25zdCBsb2dGdW5jdGlvbiA9IGNvbnNvbGUubG9nO1xuICBjb25zdCB3cml0ZXIgPSBjcmVhdGVXcml0ZXIoZm9ybWF0dGVyLCBsb2dGdW5jdGlvbiwgd3JpdGVyT3B0aW9ucyk7XG4gIGNvbnN0IHdyaXRlID0gKGxldmVsLCBtZXNzYWdlLCBkYXRhKSA9PiB7XG4gICAgaWYgKGxvZ0xldmVsLnZhbHVlIDwgbGV2ZWwudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hlY2sgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuY2hlY2sobWVzc2FnZSwgZGF0YSkgOiBcImxvZ1wiO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7IG1lc3NhZ2UsIGRhdGEgfTtcbiAgICBzd2l0Y2ggKGNoZWNrKSB7XG4gICAgICBjYXNlIFwibG9nXCI6XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdXBwcmVzc1wiOlxuICAgICAgICBpZiAoZmxvb2RDb250cm9sICYmIGZsb29kQ29udHJvbC5nZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgY29uc3QgbmV3UGF5bG9hZCA9IHsgbWVzc2FnZTogYFN0YXJ0ZWQgc3VwcHJlc3NpbmcgcmVwZWF0ZWQgbG9nIG1lc3NhZ2VgLCBkYXRhOiBbXSB9O1xuICAgICAgICAgIHdyaXRlci53cml0ZShvcmlnaW5hbExldmVsLCBjb29yZGluYXRlcywgbmV3UGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVzdW1lXCI6IHtcbiAgICAgICAgY29uc3QgY291bnQgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIDogMDtcbiAgICAgICAgY29uc3QgcmVzdW1lUGF5bG9hZCA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBgU3RvcHBlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZS4gU3VwcHJlc3NlZCAke2NvdW50fSB0aW1lcy5gLFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHJlc3VtZVBheWxvYWQpO1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGFydFRpbWVMb2dnZXIgPSAobG9nTGV2ZWwyLCBjb29yZGluYXRlczIsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UgPSBmb3JtYXR0ZXIudGltZXJNZXNzYWdlKGxvZ0xldmVsMiwgY29vcmRpbmF0ZXMyLCBwYXlsb2FkKTtcbiAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lKHRpbWVyTWVzc2FnZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuZDogKCkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lRW5kKHRpbWVyTWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgbG9nOiAoLi4uZGF0YSkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lTG9nKHRpbWVyTWVzc2FnZSwgLi4uZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBlbWVyZ2VuY3k6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShFTUVSR0VOQ1ksIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgYWxlcnQ6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShBTEVSVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBjcml0aWNhbDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKENSSVRJQ0FMLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGVycm9yOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoRVJST1IsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgd2FybmluZzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKFdBUk5JTkcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgbm90aWNlOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoTk9USUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGluZm86IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShJTkZPLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVCVUcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgdHJhY2U6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShUUkFDRSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBkZWZhdWx0OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVGQVVMVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0aW1lOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHsgbWVzc2FnZSwgZGF0YSB9O1xuICAgICAgcmV0dXJuIHN0YXJ0VGltZUxvZ2dlcihsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgIH0sXG4gICAgZ2V0OiAoLi4uYWRkaXRpb25hbENvbXBvbmVudHMpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IFsuLi5jb29yZGluYXRlcy5jb21wb25lbnRzLCAuLi5hZGRpdGlvbmFsQ29tcG9uZW50c11cbiAgICAgIH0sIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucyk7XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBpZiAoZmxvb2RDb250cm9sKSB7XG4gICAgICAgIGZsb29kQ29udHJvbC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2xvZ2dpbmcudHNcbnZhciBnZXRMb2dnZXIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBjb25maWd1cmVMb2dnaW5nKCk7XG4gIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUJhc2VMb2dnZXIobmFtZSwgY29uZmlnKTtcbiAgcmV0dXJuIGxvZ2dlcjtcbn07XG52YXIgY3JlYXRlQmFzZUxvZ2dlciA9IChuYW1lLCBjb25maWcpID0+IHtcbiAgbGV0IHsgbG9nTGV2ZWwgfSA9IGNvbmZpZztcbiAgY29uc3QgeyBsb2dGb3JtYXQsIGZsb29kQ29udHJvbCB9ID0gY29uZmlnO1xuICBjb25zdCBvdmVycmlkZXMgPSBjb25maWcub3ZlcnJpZGVzO1xuICBpZiAob3ZlcnJpZGVzICYmIG92ZXJyaWRlc1tuYW1lXSkge1xuICAgIGxvZ0xldmVsID0gb3ZlcnJpZGVzW25hbWVdLmxvZ0xldmVsO1xuICB9XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0geyBjYXRlZ29yeTogbmFtZSwgY29tcG9uZW50czogW10gfTtcbiAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihsb2dGb3JtYXQsIGxvZ0xldmVsLCBjb29yZGluYXRlcywgZmxvb2RDb250cm9sKTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSB7IGdldExvZ2dlciB9O1xuZXhwb3J0IHtcbiAgTG9nRm9ybWF0X2V4cG9ydHMgYXMgTG9nRm9ybWF0LFxuICBMb2dMZXZlbF9leHBvcnRzIGFzIExvZ0xldmVsLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGdldExvZ2dlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../fjell-http-api/node_modules/@fjell/logging/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-providers/node_modules/@fjell/cache/dist/index.js":
/*!******************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/cache/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncIndexDBCacheMap: () => (/* binding */ AsyncIndexDBCacheMap),\n/* harmony export */   CacheEventEmitter: () => (/* binding */ CacheEventEmitter),\n/* harmony export */   CacheEventFactory: () => (/* binding */ CacheEventFactory),\n/* harmony export */   CacheMap: () => (/* binding */ CacheMap),\n/* harmony export */   CacheStatsManager: () => (/* binding */ CacheStatsManager),\n/* harmony export */   EnhancedMemoryCacheMap: () => (/* binding */ EnhancedMemoryCacheMap),\n/* harmony export */   EvictionManager: () => (/* binding */ EvictionManager),\n/* harmony export */   IndexDBCacheMap: () => (/* binding */ IndexDBCacheMap),\n/* harmony export */   LocalStorageCacheMap: () => (/* binding */ LocalStorageCacheMap),\n/* harmony export */   MemoryCacheMap: () => (/* binding */ MemoryCacheMap),\n/* harmony export */   SessionStorageCacheMap: () => (/* binding */ SessionStorageCacheMap),\n/* harmony export */   TTLManager: () => (/* binding */ TTLManager),\n/* harmony export */   createAggregator: () => (/* binding */ createAggregator),\n/* harmony export */   createCache: () => (/* binding */ createCache),\n/* harmony export */   createCacheMap: () => (/* binding */ createCacheMap),\n/* harmony export */   createEvictionStrategy: () => (/* binding */ createEvictionStrategy),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createInstanceFactory: () => (/* binding */ createInstanceFactory),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   createOperations: () => (/* binding */ createOperations),\n/* harmony export */   createOptions: () => (/* binding */ createOptions),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryFactory: () => (/* binding */ createRegistryFactory),\n/* harmony export */   createValidatedConfig: () => (/* binding */ createValidatedConfig),\n/* harmony export */   estimateValueSize: () => (/* binding */ estimateValueSize),\n/* harmony export */   formatBytes: () => (/* binding */ formatBytes),\n/* harmony export */   isCache: () => (/* binding */ isCache),\n/* harmony export */   isInstance: () => (/* binding */ isInstance),\n/* harmony export */   isLocKeyArrayEqual: () => (/* binding */ isLocKeyArrayEqual),\n/* harmony export */   normalizeKeyValue: () => (/* binding */ normalizeKeyValue),\n/* harmony export */   normalizeLocKeyItem: () => (/* binding */ normalizeLocKeyItem),\n/* harmony export */   parseSizeString: () => (/* binding */ parseSizeString),\n/* harmony export */   toCacheConfig: () => (/* binding */ toCacheConfig),\n/* harmony export */   validateARCConfig: () => (/* binding */ validateARCConfig),\n/* harmony export */   validateEvictionStrategyConfig: () => (/* binding */ validateEvictionStrategyConfig),\n/* harmony export */   validateLFUConfig: () => (/* binding */ validateLFUConfig),\n/* harmony export */   validateOptions: () => (/* binding */ validateOptions),\n/* harmony export */   validateSizeConfig: () => (/* binding */ validateSizeConfig),\n/* harmony export */   validateTwoQueueConfig: () => (/* binding */ validateTwoQueueConfig)\n/* harmony export */ });\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/core */ \"(ssr)/../fjell-providers/node_modules/@fjell/core/dist/index.js\");\n/* harmony import */ var _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/http-api */ \"(ssr)/../fjell-providers/node_modules/@fjell/http-api/dist/index.js\");\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/../fjell-providers/node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fjell/registry */ \"(ssr)/../fjell-providers/node_modules/@fjell/registry/dist/index.js\");\n// src/CacheContext.ts\nvar createCacheContext = (api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager) => {\n  return {\n    api,\n    cacheMap,\n    pkType,\n    options,\n    eventEmitter,\n    ttlManager,\n    evictionManager,\n    statsManager\n  };\n};\n\n// src/ops/all.ts\n\n\n\n// src/normalization.ts\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar deterministicStringify = (obj) => {\n  if (obj === null || typeof obj !== \"object\") {\n    return JSON.stringify(obj);\n  }\n  if (Array.isArray(obj)) {\n    return \"[\" + obj.map(deterministicStringify).join(\",\") + \"]\";\n  }\n  const sortedKeys = Object.keys(obj).sort();\n  const keyValuePairs = sortedKeys.map((key) => {\n    return JSON.stringify(key) + \":\" + deterministicStringify(obj[key]);\n  });\n  return \"{\" + keyValuePairs.join(\",\") + \"}\";\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (typeof locItem === \"object\" && locItem !== null && \"lk\" in locItem && locItem.lk !== null) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return deterministicStringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isLocKeyArrayEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    const normalizedA = normalizeLocKeyItem(a[i]);\n    const normalizedB = normalizeLocKeyItem(b[i]);\n    if (deterministicStringify(normalizedA) !== deterministicStringify(normalizedB)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar normalizeLocKeyItem = (item) => {\n  if (typeof item === \"object\" && item !== null) {\n    const normalized = { ...item };\n    if (\"lk\" in normalized && normalized.lk !== null) {\n      normalized.lk = normalizeKeyValue(normalized.lk);\n    }\n    return normalized;\n  }\n  return item;\n};\nvar createQueryHash = (pkType, query, locations) => {\n  const normalizedQuery = JSON.parse(JSON.stringify(query || {}));\n  const sortedQueryKeys = Object.keys(normalizedQuery).sort();\n  const sortedQuery = {};\n  sortedQueryKeys.forEach((key) => {\n    sortedQuery[key] = normalizedQuery[key];\n  });\n  const locationsArray = Array.isArray(locations) ? locations : [];\n  const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n  const hashInput = {\n    type: \"query\",\n    pkType,\n    query: sortedQuery,\n    locations: normalizedLocations\n  };\n  return deterministicStringify(hashInput);\n};\nvar createFinderHash = (finder, params, locations) => {\n  const normalizedParams = JSON.parse(JSON.stringify(params || {}));\n  const sortedParamKeys = Object.keys(normalizedParams).sort();\n  const sortedParams = {};\n  sortedParamKeys.forEach((key) => {\n    sortedParams[key] = normalizedParams[key];\n  });\n  const locationsArray = Array.isArray(locations) ? locations : [];\n  const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n  const hashInput = {\n    type: \"finder\",\n    finder,\n    params: sortedParams,\n    locations: normalizedLocations\n  };\n  return deterministicStringify(hashInput);\n};\n\n// src/events/CacheEventFactory.ts\nvar CacheEventFactory = class {\n  static lastTimestamp = 0;\n  static cleanupInterval = null;\n  static instanceCount = 0;\n  static CLEANUP_INTERVAL_MS = 6e4;\n  // 1 minute\n  static MAX_TIMESTAMP_AGE_MS = 3e5;\n  // 5 minutes\n  /**\n   * Initialize cleanup mechanism when first instance is created\n   */\n  static initializeCleanup() {\n    if (this.cleanupInterval === null && this.instanceCount === 0) {\n      this.startCleanupTimer();\n    }\n    this.instanceCount++;\n  }\n  /**\n   * Cleanup mechanism when instance is destroyed\n   */\n  static destroyInstance() {\n    this.instanceCount = Math.max(0, this.instanceCount - 1);\n    if (this.instanceCount === 0) {\n      this.stopCleanupTimer();\n      this.resetTimestamp();\n    }\n  }\n  /**\n   * Start automatic cleanup timer\n   */\n  static startCleanupTimer() {\n    this.cleanupInterval = setInterval(() => {\n      this.performCleanup();\n    }, this.CLEANUP_INTERVAL_MS);\n    if (this.cleanupInterval.unref) {\n      this.cleanupInterval.unref();\n    }\n  }\n  /**\n   * Stop automatic cleanup timer\n   */\n  static stopCleanupTimer() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n  /**\n   * Perform periodic cleanup of stale timestamp state\n   */\n  static performCleanup() {\n    const now = Date.now();\n    if (now - this.lastTimestamp > this.MAX_TIMESTAMP_AGE_MS) {\n      this.lastTimestamp = 0;\n    }\n  }\n  /**\n   * Reset the timestamp state (useful for testing)\n   */\n  static resetTimestamp() {\n    this.lastTimestamp = 0;\n  }\n  /**\n   * Generate a unique timestamp that is always greater than the previous one\n   */\n  static generateTimestamp() {\n    this.initializeCleanup();\n    const now = Date.now();\n    if (now > this.lastTimestamp) {\n      this.lastTimestamp = now;\n    } else {\n      this.lastTimestamp = this.lastTimestamp + 1;\n    }\n    return this.lastTimestamp;\n  }\n  /**\n   * Extract affected locations from an item key\n   */\n  static extractAffectedLocations(key) {\n    if (\"loc\" in key && key.loc) {\n      return key.loc;\n    }\n    return [];\n  }\n  /**\n   * Create an item-related event\n   */\n  static createItemEvent(type, key, item, options = {}) {\n    const affectedLocations = options.affectedLocations !== void 0 ? options.affectedLocations : this.extractAffectedLocations(key);\n    return {\n      type,\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      key,\n      item,\n      previousItem: options.previousItem,\n      affectedLocations\n    };\n  }\n  /**\n   * Create a query event\n   */\n  static createQueryEvent(query, locations, items, options = {}) {\n    const affectedKeys = items.map((item) => item.key);\n    return {\n      type: \"items_queried\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      query,\n      locations,\n      items,\n      affectedKeys\n    };\n  }\n  /**\n   * Create a cache cleared event\n   */\n  static createCacheClearedEvent(itemsCleared, queryCacheCleared = true, options = {}) {\n    return {\n      type: \"cache_cleared\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      itemsCleared,\n      queryCacheCleared\n    };\n  }\n  /**\n   * Create a location invalidated event\n   */\n  static createLocationInvalidatedEvent(locations, affectedKeys, options = {}) {\n    return {\n      type: \"location_invalidated\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      locations,\n      affectedKeys\n    };\n  }\n  /**\n   * Create a query invalidated event\n   */\n  static createQueryInvalidatedEvent(invalidatedQueries, reason, options = {}) {\n    return {\n      type: \"query_invalidated\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      invalidatedQueries,\n      reason\n    };\n  }\n  /**\n   * Create an item created event\n   */\n  static itemCreated(key, item, source = \"api\") {\n    return this.createItemEvent(\"item_created\", key, item, { source });\n  }\n  /**\n   * Create an item updated event\n   */\n  static itemUpdated(key, item, previousItem, source = \"api\") {\n    return this.createItemEvent(\"item_updated\", key, item, { previousItem, source });\n  }\n  /**\n   * Create an item removed event\n   */\n  static itemRemoved(key, previousItem, source = \"api\") {\n    return this.createItemEvent(\"item_removed\", key, null, { previousItem, source });\n  }\n  /**\n   * Create an item retrieved event\n   */\n  static itemRetrieved(key, item, source = \"api\") {\n    return this.createItemEvent(\"item_retrieved\", key, item, { source });\n  }\n  /**\n   * Create an item set event (direct cache operation)\n   */\n  static itemSet(key, item, previousItem) {\n    return this.createItemEvent(\"item_set\", key, item, {\n      previousItem,\n      source: \"cache\"\n    });\n  }\n};\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLogger(\"@fjell/cache\");\nvar logger_default = LibLogger;\n\n// src/ops/all.ts\nvar logger = logger_default.get(\"all\");\nvar all = async (query = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger.default(\"all\", { query, locations });\n  const queryHash = createQueryHash(pkType, query, locations);\n  logger.debug(\"Generated query hash for all\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys) {\n    logger.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    const cachedItems = [];\n    let allItemsAvailable = true;\n    for (const itemKey of cachedItemKeys) {\n      const item = await cacheMap.get(itemKey);\n      if (item) {\n        cachedItems.push(item);\n      } else {\n        allItemsAvailable = false;\n        break;\n      }\n    }\n    if (allItemsAvailable) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)];\n    } else {\n      logger.debug(\"Some cached items missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  let ret = [];\n  try {\n    ret = await api.all(query, locations);\n    ret.forEach((v) => {\n      cacheMap.set(v.key, v);\n      const keyStr = JSON.stringify(v.key);\n      ttlManager.onItemAdded(keyStr, cacheMap);\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n    });\n    const itemKeys = ret.map((item) => item.key);\n    cacheMap.setQueryResult(queryHash, itemKeys);\n    logger.debug(\"Cached query result\", { queryHash, itemKeyCount: itemKeys.length });\n    const event = CacheEventFactory.createQueryEvent(query, locations, ret);\n    context.eventEmitter.emit(event);\n  } catch (e) {\n    if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n      cacheMap.setQueryResult(queryHash, []);\n      logger.debug(\"Cached empty query result for not found\", { queryHash });\n    } else {\n      throw e;\n    }\n  }\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/one.ts\n\n\nvar logger2 = logger_default.get(\"one\");\nvar one = async (query = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger2.default(\"one\", { query, locations });\n  const queryHash = createQueryHash(pkType, query, locations);\n  logger2.debug(\"Generated query hash for one\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys) {\n    logger2.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    if (cachedItemKeys.length === 0) {\n      return [context, null];\n    }\n    const item = await cacheMap.get(cachedItemKeys[0]);\n    if (item) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)];\n    } else {\n      logger2.debug(\"Cached item missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  let retItem = null;\n  try {\n    retItem = await api.one(query, locations);\n    if (retItem) {\n      cacheMap.set(retItem.key, retItem);\n      const keyStr = JSON.stringify(retItem.key);\n      ttlManager.onItemAdded(keyStr, cacheMap);\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr, retItem, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n      cacheMap.setQueryResult(queryHash, [retItem.key]);\n      logger2.debug(\"Cached query result\", { queryHash, itemKey: retItem.key });\n    } else {\n      cacheMap.setQueryResult(queryHash, []);\n      logger2.debug(\"Cached empty query result\", { queryHash });\n    }\n  } catch (e) {\n    if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n      cacheMap.setQueryResult(queryHash, []);\n      logger2.debug(\"Cached empty query result for not found\", { queryHash });\n    } else {\n      throw e;\n    }\n  }\n  return [\n    context,\n    retItem ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retItem, pkType) : null\n  ];\n};\n\n// src/ops/create.ts\n\nvar logger3 = logger_default.get(\"create\");\nvar create = async (v, locations = [], context) => {\n  const { api, cacheMap, pkType, eventEmitter, ttlManager, evictionManager } = context;\n  logger3.default(\"create\", { v, locations });\n  const created = await api.create(v, locations);\n  cacheMap.set(created.key, created);\n  const keyStr = JSON.stringify(created.key);\n  ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = evictionManager.onItemAdded(keyStr, created, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    const parsedKey = JSON.parse(evictedKey);\n    cacheMap.delete(parsedKey);\n  });\n  const event = CacheEventFactory.itemCreated(created.key, created, \"api\");\n  eventEmitter.emit(event);\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(created, pkType)];\n};\n\n// src/ops/get.ts\n\n\n// src/utils/CacheSize.ts\n\nvar SIZE_UNITS = {\n  // Decimal units (powers of 1000)\n  \"b\": 1,\n  \"byte\": 1,\n  \"bytes\": 1,\n  \"kb\": 1e3,\n  \"kilobyte\": 1e3,\n  \"kilobytes\": 1e3,\n  \"mb\": 1e3 * 1e3,\n  \"megabyte\": 1e3 * 1e3,\n  \"megabytes\": 1e3 * 1e3,\n  \"gb\": 1e3 * 1e3 * 1e3,\n  \"gigabyte\": 1e3 * 1e3 * 1e3,\n  \"gigabytes\": 1e3 * 1e3 * 1e3,\n  \"tb\": 1e3 * 1e3 * 1e3 * 1e3,\n  \"terabyte\": 1e3 * 1e3 * 1e3 * 1e3,\n  \"terabytes\": 1e3 * 1e3 * 1e3 * 1e3,\n  // Binary units (powers of 1024)\n  \"kib\": 1024,\n  \"kibibyte\": 1024,\n  \"kibibytes\": 1024,\n  \"mib\": 1024 * 1024,\n  \"mebibyte\": 1024 * 1024,\n  \"mebibytes\": 1024 * 1024,\n  \"gib\": 1024 * 1024 * 1024,\n  \"gibibyte\": 1024 * 1024 * 1024,\n  \"gibibytes\": 1024 * 1024 * 1024,\n  \"tib\": 1024 * 1024 * 1024 * 1024,\n  \"tebibyte\": 1024 * 1024 * 1024 * 1024,\n  \"tebibytes\": 1024 * 1024 * 1024 * 1024\n};\nfunction parseSizeString(sizeStr) {\n  if (!sizeStr || typeof sizeStr !== \"string\") {\n    throw new Error(\"Size string must be a non-empty string\");\n  }\n  const trimmed = sizeStr.trim();\n  if (/^\\d+(\\.\\d+)?$/.test(trimmed)) {\n    const bytes = parseFloat(trimmed);\n    if (isNaN(bytes) || bytes < 0) {\n      throw new Error(`Invalid size value: ${sizeStr}`);\n    }\n    return Math.floor(bytes);\n  }\n  const match = trimmed.match(/^(\\d+(?:\\.\\d+)?)\\s*([a-zA-Z]+)$/);\n  if (!match) {\n    throw new Error(`Invalid size format: ${sizeStr}. Expected format: '100', '5KB', '10MB', etc.`);\n  }\n  const [, valueStr, unitStr] = match;\n  const value = parseFloat(valueStr);\n  const unit = unitStr.toLowerCase();\n  if (isNaN(value) || value < 0) {\n    throw new Error(`Invalid size value: ${valueStr}`);\n  }\n  const multiplier = SIZE_UNITS[unit];\n  if (!(unit in SIZE_UNITS)) {\n    const supportedUnits = Object.keys(SIZE_UNITS).filter((u) => u.length <= 3).join(\", \");\n    throw new Error(`Unsupported size unit: ${unitStr}. Supported units: ${supportedUnits}`);\n  }\n  return Math.floor(value * multiplier);\n}\nfunction formatBytes(bytes, binary = false) {\n  if (bytes === 0) return \"0 B\";\n  if (bytes < 0) return `${bytes} B`;\n  const k = binary ? 1024 : 1e3;\n  const sizes = binary ? [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\"] : [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  const size = bytes / Math.pow(k, i);\n  const formatted = size % 1 === 0 ? size.toString() : size.toFixed(1);\n  return `${formatted} ${sizes[i]}`;\n}\nfunction estimateValueSize(value) {\n  if (value === null || typeof value === \"undefined\") {\n    return 8;\n  }\n  switch (typeof value) {\n    case \"boolean\":\n      return 4;\n    case \"number\":\n      return 8;\n    case \"string\":\n      return value.length * 2;\n    case \"object\":\n      if (Array.isArray(value)) {\n        return value.reduce((total, item) => total + estimateValueSize(item), 24);\n      }\n      const hasCircularReference = (obj, ancestors = /* @__PURE__ */ new WeakSet(), checked = /* @__PURE__ */ new WeakSet()) => {\n        if (obj === null || typeof obj !== \"object\") {\n          return false;\n        }\n        const asObject = obj;\n        if (checked.has(asObject)) {\n          return false;\n        }\n        if (ancestors.has(asObject)) {\n          return true;\n        }\n        ancestors.add(asObject);\n        try {\n          if (Array.isArray(asObject)) {\n            for (const item of asObject) {\n              if (hasCircularReference(item, ancestors, checked)) {\n                return true;\n              }\n            }\n          } else {\n            for (const key of Object.keys(asObject)) {\n              let child;\n              try {\n                child = asObject[key];\n              } catch {\n                continue;\n              }\n              if (hasCircularReference(child, ancestors, checked)) {\n                return true;\n              }\n            }\n          }\n        } finally {\n          ancestors.delete(asObject);\n          checked.add(asObject);\n        }\n        return false;\n      };\n      try {\n        if (hasCircularReference(value)) {\n          return 64;\n        }\n      } catch {\n        return 64;\n      }\n      try {\n        const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(value);\n        return jsonString.length * 2 + 16;\n      } catch {\n        return 64;\n      }\n    default:\n      return 32;\n  }\n}\nfunction validateSizeConfig(config) {\n  if (typeof config.maxSizeBytes !== \"undefined\") {\n    try {\n      const bytes = parseSizeString(config.maxSizeBytes);\n      if (bytes <= 0) {\n        throw new Error(\"maxSizeBytes must be positive\");\n      }\n    } catch (error) {\n      throw new Error(`Invalid maxSizeBytes: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  if (typeof config.maxItems !== \"undefined\") {\n    if (!Number.isInteger(config.maxItems) || config.maxItems <= 0) {\n      throw new Error(\"maxItems must be a positive integer\");\n    }\n  }\n}\n\n// src/ops/get.ts\nvar logger4 = logger_default.get(\"get\");\nvar inFlightRequests = /* @__PURE__ */ new Map();\nvar CLEANUP_TIMEOUT = 5 * 60 * 1e3;\nvar cleanupStaleRequests = () => {\n  const now = Date.now();\n  const keysToDelete = [];\n  inFlightRequests.forEach((request, key) => {\n    if (now - request.timestamp > CLEANUP_TIMEOUT) {\n      keysToDelete.push(key);\n    }\n  });\n  keysToDelete.forEach((key) => {\n    logger4.debug(\"Cleaning up stale in-flight request\", { key });\n    inFlightRequests.delete(key);\n  });\n};\nvar cleanupInterval = setInterval(cleanupStaleRequests, 60 * 1e3);\nvar keyToString = createNormalizedHashFunction();\nvar get = async (key, context) => {\n  const { api, cacheMap, pkType, ttlManager, statsManager } = context;\n  logger4.default(\"get\", { key, defaultTTL: ttlManager.getDefaultTTL() });\n  statsManager.incrementRequests();\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger4.error(\"Key for Get is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Get is not a valid ItemKey\");\n  }\n  if (ttlManager.isTTLEnabled()) {\n    const keyStr2 = JSON.stringify(key);\n    const cachedItem = await cacheMap.get(key);\n    if (cachedItem) {\n      const isValid = ttlManager.validateItem(keyStr2, cacheMap);\n      if (isValid) {\n        logger4.debug(\"Cache hit with valid TTL\", { key, defaultTTL: ttlManager.getDefaultTTL() });\n        statsManager.incrementHits();\n        return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)];\n      } else {\n        logger4.debug(\"Cache item expired, removing\", { key });\n        cacheMap.delete(key);\n        statsManager.incrementMisses();\n      }\n    } else {\n      statsManager.incrementMisses();\n    }\n    logger4.debug(\"Cache miss or expired\", { key, defaultTTL: ttlManager.getDefaultTTL() });\n  } else {\n    const cachedItem = await cacheMap.get(key);\n    if (cachedItem) {\n      logger4.debug(\"Cache hit (TTL disabled)\", { key });\n      statsManager.incrementHits();\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)];\n    } else {\n      statsManager.incrementMisses();\n    }\n  }\n  let ret;\n  const keyStr = keyToString(key);\n  try {\n    const requestEntry = inFlightRequests.get(keyStr);\n    let apiRequest;\n    if (!requestEntry) {\n      apiRequest = api.get(key);\n      if (apiRequest && typeof apiRequest.then === \"function\") {\n        const timestamp = Date.now();\n        inFlightRequests.set(keyStr, { promise: apiRequest, timestamp });\n        const cleanup = () => inFlightRequests.delete(keyStr);\n        if (typeof apiRequest.finally === \"function\") {\n          apiRequest.finally(cleanup);\n        } else {\n          apiRequest.then(cleanup, cleanup);\n        }\n      }\n    } else {\n      logger4.debug(\"Using in-flight request for key\", { key });\n      apiRequest = requestEntry.promise;\n    }\n    ret = await apiRequest;\n    if (ret) {\n      cacheMap.set(ret.key, ret);\n      const keyStr2 = JSON.stringify(ret.key);\n      const metadata = cacheMap.getMetadata?.(keyStr2);\n      if (!metadata) {\n        const now = Date.now();\n        const baseMetadata = {\n          key: keyStr2,\n          addedAt: now,\n          lastAccessedAt: now,\n          accessCount: 1,\n          estimatedSize: estimateValueSize(ret)\n        };\n        cacheMap.setMetadata?.(keyStr2, baseMetadata);\n      }\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr2, ret, cacheMap);\n      ttlManager.onItemAdded(keyStr2, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n      const event = CacheEventFactory.itemRetrieved(ret.key, ret, \"api\");\n      context.eventEmitter.emit(event);\n    }\n  } catch (e) {\n    inFlightRequests.delete(keyStr);\n    logger4.error(\"Error getting item for key\", { key, message: e.message, stack: e.stack });\n    throw e;\n  }\n  return [\n    context,\n    ret ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType) : null\n  ];\n};\n\n// src/ops/retrieve.ts\n\nvar logger5 = logger_default.get(\"retrieve\");\nvar retrieve = async (key, context) => {\n  const { cacheMap, pkType, statsManager } = context;\n  logger5.default(\"retrieve\", { key });\n  statsManager.incrementRequests();\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger5.error(\"Key for Retrieve is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Retrieve is not a valid ItemKey\");\n  }\n  const containsItemKey = await cacheMap.includesKey(key);\n  let retrieved;\n  let contextToReturn;\n  if (containsItemKey) {\n    logger5.default(\"Looking for Object in Cache\", key);\n    retrieved = await cacheMap.get(key);\n    contextToReturn = null;\n    statsManager.incrementHits();\n  } else {\n    logger5.default(\"Object Not Found in Cache, Retrieving from Server API\", { key });\n    statsManager.incrementMisses();\n    [contextToReturn, retrieved] = await get(key, context);\n  }\n  const retValue = [\n    contextToReturn,\n    retrieved ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retrieved, pkType) : null\n  ];\n  return retValue;\n};\n\n// src/ops/remove.ts\n\nvar logger6 = logger_default.get(\"remove\");\nvar remove = async (key, context) => {\n  const { api, cacheMap } = context;\n  logger6.default(\"remove\", { key });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger6.error(\"Key for Remove is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Remove is not a valid ItemKey\");\n  }\n  try {\n    const previousItem = await cacheMap.get(key);\n    await api.remove(key);\n    cacheMap.delete(key);\n    if (previousItem) {\n      const event = CacheEventFactory.itemRemoved(key, previousItem, \"api\");\n      context.eventEmitter.emit(event);\n    }\n    logger6.debug(\"Successfully removed item from API and cache\", { key });\n  } catch (e) {\n    logger6.error(\"Error deleting item\", { error: e });\n    throw e;\n  }\n  return context;\n};\n\n// src/ops/update.ts\n\nvar logger7 = logger_default.get(\"update\");\nvar update = async (key, v, context) => {\n  const { api, cacheMap, pkType } = context;\n  logger7.default(\"update\", { key, v });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger7.error(\"Key for Update is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Update is not a valid ItemKey\");\n  }\n  logger7.debug(\"Invalidating item key before update\", { key });\n  cacheMap.invalidateItemKeys([key]);\n  try {\n    const previousItem = await cacheMap.get(key);\n    const updated = await api.update(key, v);\n    logger7.debug(\"Caching update result\", { updatedKey: updated.key });\n    cacheMap.set(updated.key, updated);\n    const keyStr = JSON.stringify(updated.key);\n    context.ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n    evictedKeys.forEach((evictedKey) => {\n      const parsedKey = JSON.parse(evictedKey);\n      cacheMap.delete(parsedKey);\n    });\n    const event = CacheEventFactory.itemUpdated(updated.key, updated, previousItem, \"api\");\n    context.eventEmitter.emit(event);\n    return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)];\n  } catch (e) {\n    logger7.error(\"Error updating item\", { error: e });\n    throw e;\n  }\n};\n\n// src/ops/action.ts\n\nvar logger8 = logger_default.get(\"action\");\nvar action = async (key, action2, body = {}, context) => {\n  const { api, cacheMap, pkType } = context;\n  logger8.default(\"action\", { key, action: action2, body });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger8.error(\"Key for Action is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Action is not a valid ItemKey\");\n  }\n  logger8.debug(\"Invalidating item key before action\", { key });\n  cacheMap.invalidateItemKeys([key]);\n  const updated = await api.action(key, action2, body);\n  logger8.debug(\"Caching action result\", { updatedKey: updated.key });\n  cacheMap.set(updated.key, updated);\n  const keyStr = JSON.stringify(updated.key);\n  context.ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    try {\n      const parsedKey = JSON.parse(evictedKey);\n      cacheMap.delete(parsedKey);\n    } catch (error) {\n      logger8.error(\"Failed to parse evicted key during deletion\", {\n        evictedKey,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  });\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)];\n};\n\n// src/ops/allAction.ts\n\n\nvar logger9 = logger_default.get(\"allAction\");\nvar allAction = async (action2, body = {}, locations = [], context) => {\n  const { api, cacheMap, pkType } = context;\n  logger9.default(\"allAction\", { action: action2, body, locations });\n  logger9.debug(\"Invalidating location before allAction\", { locations });\n  cacheMap.invalidateLocation(locations);\n  let ret = [];\n  try {\n    ret = await api.allAction(action2, body, locations);\n    logger9.debug(\"Caching allAction results\", { resultCount: ret.length });\n    ret.forEach((v) => {\n      cacheMap.set(v.key, v);\n      const keyStr = JSON.stringify(v.key);\n      context.ttlManager.onItemAdded(keyStr, cacheMap);\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n    });\n  } catch (e) {\n    if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n    } else {\n      throw e;\n    }\n  }\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/facet.ts\nvar logger10 = logger_default.get(\"facet\");\nvar facet = async (key, facet2, params = {}, context) => {\n  const { api } = context;\n  logger10.default(\"facet\", { key, facet: facet2 });\n  const ret = await api.facet(key, facet2, params);\n  return ret;\n};\n\n// src/ops/allFacet.ts\nvar logger11 = logger_default.get(\"allFacet\");\nvar allFacet = async (facet2, params = {}, locations = [], context) => {\n  const { api } = context;\n  logger11.default(\"allFacet\", { facet: facet2, params, locations });\n  const ret = await api.allFacet(facet2, params, locations);\n  return ret;\n};\n\n// src/ops/find.ts\n\nvar logger12 = logger_default.get(\"find\");\nvar find = async (finder, params = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger12.default(\"find\", { finder, params, locations });\n  const queryHash = createFinderHash(finder, params, locations);\n  logger12.debug(\"Generated query hash for find\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys) {\n    logger12.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    const cachedItems = [];\n    let allItemsAvailable = true;\n    for (const itemKey of cachedItemKeys) {\n      const item = await cacheMap.get(itemKey);\n      if (item) {\n        cachedItems.push(item);\n      } else {\n        allItemsAvailable = false;\n        break;\n      }\n    }\n    if (allItemsAvailable) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)];\n    } else {\n      logger12.debug(\"Some cached items missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  const ret = await api.find(finder, params, locations);\n  ret.forEach((v) => {\n    cacheMap.set(v.key, v);\n    const keyStr = JSON.stringify(v.key);\n    ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n    evictedKeys.forEach((evictedKey) => {\n      const parsedKey = JSON.parse(evictedKey);\n      cacheMap.delete(parsedKey);\n    });\n  });\n  const itemKeys = ret.map((item) => item.key);\n  cacheMap.setQueryResult(queryHash, itemKeys);\n  logger12.debug(\"Cached query result\", { queryHash, itemKeyCount: itemKeys.length });\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/findOne.ts\n\nvar logger13 = logger_default.get(\"findOne\");\nvar findOne = async (finder, finderParams = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger13.default(\"findOne\", { finder, finderParams, locations });\n  const queryHash = createFinderHash(finder, finderParams, locations);\n  logger13.debug(\"Generated query hash for findOne\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys && cachedItemKeys.length > 0) {\n    logger13.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    const item = await cacheMap.get(cachedItemKeys[0]);\n    if (item) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)];\n    } else {\n      logger13.debug(\"Cached item missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  const ret = await api.findOne(finder, finderParams, locations);\n  cacheMap.set(ret.key, ret);\n  const keyStr = JSON.stringify(ret.key);\n  ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = context.evictionManager.onItemAdded(keyStr, ret, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    const parsedKey = JSON.parse(evictedKey);\n    cacheMap.delete(parsedKey);\n  });\n  cacheMap.setQueryResult(queryHash, [ret.key]);\n  logger13.debug(\"Cached query result\", { queryHash, itemKey: ret.key });\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/set.ts\n\nvar logger14 = logger_default.get(\"set\");\nvar normalizeKeyValue2 = (value) => {\n  return String(value);\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  const normalizedA = normalizeKey(a);\n  const normalizedB = normalizeKey(b);\n  return (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isItemKeyEqual)(normalizedA, normalizedB);\n};\nvar normalizeKey = (key) => {\n  if (typeof key === \"object\" && key !== null) {\n    let needsNormalization = false;\n    let normalizedKey = key;\n    if (\"pk\" in key && key.pk !== null && typeof key.pk !== \"string\") {\n      needsNormalization = true;\n    }\n    if (\"lk\" in key && key.lk !== null && typeof key.lk !== \"string\") {\n      needsNormalization = true;\n    }\n    if (\"loc\" in key && Array.isArray(key.loc)) {\n      for (const locItem of key.loc) {\n        if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n          needsNormalization = true;\n          break;\n        }\n      }\n    }\n    if (needsNormalization) {\n      normalizedKey = { ...key };\n      if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n        normalizedKey.pk = normalizeKeyValue2(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n        normalizedKey.lk = normalizeKeyValue2(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n            return { ...locItem, lk: normalizeKeyValue2(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n    }\n    return normalizedKey;\n  }\n  return key;\n};\nvar set = async (key, v, context) => {\n  const { cacheMap, pkType, ttlManager, evictionManager, eventEmitter } = context;\n  logger14.default(\"set\", { key, v });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger14.error(\"Key for Set is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Set is not a valid ItemKey\");\n  }\n  (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType);\n  if (!isItemKeyEqualNormalized(key, v.key)) {\n    logger14.error(\"Key does not match item key: %j != %j\", key, v.key);\n    throw new Error(\"Key does not match item key\");\n  }\n  const previousItem = await cacheMap.get(key);\n  cacheMap.set(key, v);\n  const keyStr = JSON.stringify(key);\n  ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = evictionManager.onItemAdded(keyStr, v, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    const parsedKey = JSON.parse(evictedKey);\n    cacheMap.delete(parsedKey);\n  });\n  const event = CacheEventFactory.itemSet(key, v, previousItem);\n  eventEmitter.emit(event);\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType)];\n};\n\n// src/memory/MemoryCacheMap.ts\n\n\n// src/CacheMap.ts\nvar CacheMap = class {\n  types;\n  constructor(types) {\n    this.types = types;\n  }\n};\n\n// src/memory/MemoryCacheMap.ts\nvar logger15 = logger_default.get(\"MemoryCacheMap\");\nvar MemoryCacheMap = class _MemoryCacheMap extends CacheMap {\n  implementationType = \"memory/memory\";\n  map = {};\n  normalizedHashFunction;\n  // Query result cache: maps query hash to cache entry\n  queryResultCache = {};\n  // Metadata storage for eviction strategies\n  metadataMap = /* @__PURE__ */ new Map();\n  constructor(types, initialData) {\n    super(types);\n    this.normalizedHashFunction = createNormalizedHashFunction();\n    if (initialData) {\n      for (const [keyStr, value] of Object.entries(initialData)) {\n        try {\n          const key = JSON.parse(keyStr);\n          this.set(key, value);\n        } catch (error) {\n          logger15.error(\"Failed to parse initial data key\", { keyStr, error });\n        }\n      }\n    }\n  }\n  async get(key) {\n    logger15.trace(\"get\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n      const keyStr = JSON.stringify(key);\n      const metadata = this.metadataMap.get(keyStr);\n      if (metadata) {\n        metadata.lastAccessedAt = Date.now();\n        metadata.accessCount++;\n      }\n      return entry.value;\n    }\n    return null;\n  }\n  set(key, value) {\n    logger15.trace(\"set\", { key, value });\n    const hashedKey = this.normalizedHashFunction(key);\n    const keyStr = JSON.stringify(key);\n    this.map[hashedKey] = { originalKey: key, value };\n    if (!this.metadataMap.has(keyStr)) {\n      const now = Date.now();\n      const metadata = {\n        key: keyStr,\n        addedAt: now,\n        lastAccessedAt: now,\n        accessCount: 1,\n        estimatedSize: estimateValueSize(value)\n      };\n      this.metadataMap.set(keyStr, metadata);\n    } else {\n      const metadata = this.metadataMap.get(keyStr);\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadata.estimatedSize = estimateValueSize(value);\n    }\n  }\n  async includesKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey;\n  }\n  delete(key) {\n    logger15.trace(\"delete\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n      const keyStr = JSON.stringify(entry.originalKey);\n      this.metadataMap.delete(keyStr);\n      delete this.map[hashedKey];\n      for (const [queryHash, cacheEntry] of Object.entries(this.queryResultCache)) {\n        cacheEntry.itemKeys = cacheEntry.itemKeys.filter((k) => this.normalizedHashFunction(k) !== hashedKey);\n        if (cacheEntry.itemKeys.length === 0) {\n          delete this.queryResultCache[queryHash];\n        }\n      }\n    }\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  async values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  clear() {\n    this.map = {};\n    this.metadataMap.clear();\n    this.queryResultCache = {};\n  }\n  async allIn(locations) {\n    const allValues = await this.values();\n    if (locations.length === 0) {\n      logger15.debug(\"Returning all items, LocKeys is empty\");\n      return allValues;\n    } else {\n      logger15.debug(\"allIn\", { locations, count: allValues.length });\n      return allValues.filter((item) => {\n        const key = item.key;\n        if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n          const comKey = key;\n          return isLocKeyArrayEqual(locations, comKey.loc);\n        }\n        return false;\n      });\n    }\n  }\n  async contains(query, locations) {\n    logger15.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger15.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    const clone = new _MemoryCacheMap(this.types);\n    for (const key of this.keys()) {\n      const value = await this.get(key);\n      if (value) {\n        clone.set(key, value);\n      }\n    }\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      clone.queryResultCache[queryHash] = {\n        itemKeys: [...entry.itemKeys]\n        // Shallow copy of the array\n      };\n    }\n    return clone;\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    logger15.trace(\"setQueryResult\", { queryHash, itemKeys });\n    const entry = {\n      itemKeys: [...itemKeys]\n      // Create a copy to avoid external mutations\n    };\n    this.queryResultCache[queryHash] = entry;\n  }\n  async getQueryResult(queryHash) {\n    logger15.trace(\"getQueryResult\", { queryHash });\n    const entry = this.queryResultCache[queryHash];\n    if (!entry) {\n      return null;\n    }\n    return [...entry.itemKeys];\n  }\n  hasQueryResult(queryHash) {\n    const entry = this.queryResultCache[queryHash];\n    return !!entry;\n  }\n  deleteQueryResult(queryHash) {\n    logger15.trace(\"deleteQueryResult\", { queryHash });\n    delete this.queryResultCache[queryHash];\n  }\n  invalidateItemKeys(keys) {\n    logger15.debug(\"invalidateItemKeys\", { keys });\n    keys.forEach((key) => {\n      this.delete(key);\n    });\n  }\n  async invalidateLocation(locations) {\n    logger15.debug(\"invalidateLocation\", { locations });\n    if (locations.length === 0) {\n      const allKeys = this.keys();\n      const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n      this.invalidateItemKeys(primaryKeys);\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      const keysToInvalidate = itemsInLocation.map((item) => item.key);\n      this.invalidateItemKeys(keysToInvalidate);\n    }\n    this.clearQueryResults();\n  }\n  clearQueryResults() {\n    logger15.trace(\"clearQueryResults\");\n    this.queryResultCache = {};\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    return this.metadataMap.get(key) || null;\n  }\n  setMetadata(key, metadata) {\n    this.metadataMap.set(key, metadata);\n  }\n  deleteMetadata(key) {\n    this.metadataMap.delete(key);\n  }\n  getAllMetadata() {\n    return new Map(this.metadataMap);\n  }\n  clearMetadata() {\n    this.metadataMap.clear();\n  }\n  getCurrentSize() {\n    let sizeBytes = 0;\n    for (const entry of Object.values(this.map)) {\n      sizeBytes += estimateValueSize(entry.value);\n    }\n    return {\n      itemCount: Object.keys(this.map).length,\n      sizeBytes\n    };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: null,\n      maxSizeBytes: null\n    };\n  }\n};\n\n// src/memory/EnhancedMemoryCacheMap.ts\n\nvar logger16 = logger_default.get(\"EnhancedMemoryCacheMap\");\nvar EnhancedMemoryCacheMap = class _EnhancedMemoryCacheMap extends CacheMap {\n  implementationType = \"memory/enhanced\";\n  map = {};\n  normalizedHashFunction;\n  // Query result cache: maps query hash to cache entry\n  queryResultCache = {};\n  // Size tracking\n  currentSizeBytes = 0;\n  currentItemCount = 0;\n  queryResultsCacheSize = 0;\n  // Size limits\n  maxSizeBytes;\n  maxItems;\n  constructor(types, sizeConfig, initialData) {\n    super(types);\n    this.normalizedHashFunction = createNormalizedHashFunction();\n    if (sizeConfig?.maxSizeBytes) {\n      this.maxSizeBytes = parseSizeString(sizeConfig.maxSizeBytes);\n      logger16.debug(\"Cache size limit set\", { maxSizeBytes: this.maxSizeBytes });\n    }\n    if (sizeConfig?.maxItems) {\n      this.maxItems = sizeConfig.maxItems;\n      logger16.debug(\"Cache item limit set\", { maxItems: this.maxItems });\n    }\n    if (initialData) {\n      for (const [keyStr, value] of Object.entries(initialData)) {\n        try {\n          const key = JSON.parse(keyStr);\n          this.set(key, value);\n        } catch (error) {\n          logger16.error(\"Failed to parse initial data key\", { keyStr, error });\n        }\n      }\n    }\n  }\n  async get(key) {\n    logger16.trace(\"get\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null) {\n      return entry.value;\n    }\n    return null;\n  }\n  set(key, value) {\n    logger16.trace(\"set\", { key, value });\n    const hashedKey = this.normalizedHashFunction(key);\n    const estimatedSize = estimateValueSize(value);\n    const existingEntry = this.map[hashedKey];\n    const isUpdate = existingEntry && this.normalizedHashFunction(existingEntry.originalKey) === hashedKey;\n    if (isUpdate) {\n      const sizeDiff = estimatedSize - existingEntry.metadata.estimatedSize;\n      this.currentSizeBytes += sizeDiff;\n      const oldValue = existingEntry.value;\n      existingEntry.value = value;\n      existingEntry.metadata.estimatedSize = estimatedSize;\n      logger16.trace(\"Updated existing cache entry\", {\n        key: hashedKey,\n        sizeDiff,\n        currentSize: this.currentSizeBytes,\n        oldValue: oldValue !== value\n      });\n    } else {\n      const metadata = {\n        addedAt: Date.now(),\n        lastAccessedAt: Date.now(),\n        accessCount: 0,\n        estimatedSize,\n        key: hashedKey\n      };\n      this.map[hashedKey] = {\n        originalKey: key,\n        value,\n        metadata\n      };\n      this.currentSizeBytes += estimatedSize;\n      this.currentItemCount++;\n      logger16.trace(\"Added new cache entry\", {\n        key: hashedKey,\n        size: estimatedSize,\n        currentSize: this.currentSizeBytes,\n        currentCount: this.currentItemCount\n      });\n    }\n  }\n  async includesKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null;\n  }\n  delete(key) {\n    this.deleteInternal(key, true, \"filter\");\n  }\n  deleteInternal(key, invalidateQueries = false, invalidationMode = \"remove\") {\n    logger16.trace(\"delete\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n      this.currentSizeBytes -= entry.metadata.estimatedSize;\n      this.currentItemCount--;\n      delete this.map[hashedKey];\n      logger16.trace(\"Deleted cache entry\", {\n        key: hashedKey,\n        freedSize: entry.metadata.estimatedSize,\n        currentSize: this.currentSizeBytes,\n        currentCount: this.currentItemCount\n      });\n      if (invalidateQueries) {\n        if (invalidationMode === \"filter\") {\n          this.filterQueriesReferencingKeys([key]);\n        } else {\n          this.invalidateQueriesReferencingKeys([key]);\n        }\n      }\n    }\n  }\n  keys() {\n    return Object.values(this.map).filter((entry) => entry.value !== null).map((entry) => entry.originalKey);\n  }\n  async values() {\n    return Object.values(this.map).filter((entry) => entry.value !== null).map((entry) => entry.value);\n  }\n  clear() {\n    logger16.debug(\"Clearing cache\", {\n      itemsCleared: this.currentItemCount,\n      bytesFreed: this.currentSizeBytes\n    });\n    this.map = {};\n    this.currentSizeBytes = 0;\n    this.currentItemCount = 0;\n  }\n  async allIn(locations) {\n    const allValues = await this.values();\n    if (locations.length === 0) {\n      logger16.debug(\"Returning all items, LocKeys is empty\");\n      return allValues;\n    } else {\n      logger16.debug(\"allIn\", { locations, count: allValues.length });\n      return allValues.filter((item) => {\n        const key = item.key;\n        if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n          return isLocKeyArrayEqual(locations, key.loc);\n        }\n        return false;\n      });\n    }\n  }\n  async contains(query, locations) {\n    logger16.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger16.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    const sizeConfig = {};\n    if (this.maxSizeBytes) {\n      sizeConfig.maxSizeBytes = this.maxSizeBytes.toString();\n    }\n    if (this.maxItems) {\n      sizeConfig.maxItems = this.maxItems;\n    }\n    const clone = new _EnhancedMemoryCacheMap(this.types, sizeConfig);\n    for (const key of this.keys()) {\n      const value = await this.get(key);\n      if (value) {\n        clone.set(key, value);\n      }\n    }\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      clone.setQueryResult(queryHash, entry.itemKeys);\n    }\n    return clone;\n  }\n  /**\n   * Get current cache statistics\n   */\n  getStats() {\n    const stats = {\n      currentSizeBytes: this.currentSizeBytes,\n      currentItemCount: this.currentItemCount,\n      maxSizeBytes: this.maxSizeBytes,\n      maxItems: this.maxItems,\n      utilizationPercent: {}\n    };\n    if (this.maxSizeBytes) {\n      stats.utilizationPercent.bytes = this.currentSizeBytes / this.maxSizeBytes * 100;\n    }\n    if (this.maxItems) {\n      stats.utilizationPercent.items = this.currentItemCount / this.maxItems * 100;\n    }\n    return stats;\n  }\n  // Query result caching methods\n  setQueryResult(queryHash, itemKeys) {\n    logger16.trace(\"setQueryResult\", { queryHash, itemKeys });\n    if (queryHash in this.queryResultCache) {\n      this.removeQueryResultFromSizeTracking(queryHash);\n    }\n    const entry = {\n      itemKeys: [...itemKeys]\n      // Create a copy to avoid external mutations\n    };\n    this.queryResultCache[queryHash] = entry;\n    this.addQueryResultToSizeTracking(queryHash, entry);\n  }\n  async getQueryResult(queryHash) {\n    logger16.trace(\"getQueryResult\", { queryHash });\n    const entry = this.queryResultCache[queryHash];\n    if (!entry) {\n      return null;\n    }\n    return [...entry.itemKeys];\n  }\n  hasQueryResult(queryHash) {\n    const entry = this.queryResultCache[queryHash];\n    return !!entry;\n  }\n  deleteQueryResult(queryHash) {\n    if (queryHash in this.queryResultCache) {\n      this.removeQueryResultFromSizeTracking(queryHash);\n      delete this.queryResultCache[queryHash];\n    }\n  }\n  clearQueryResults() {\n    this.queryResultCache = {};\n    this.queryResultsCacheSize = 0;\n  }\n  invalidateItemKeys(keys) {\n    logger16.debug(\"invalidateItemKeys\", { keys });\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach((key) => {\n      this.deleteInternal(key, false);\n    });\n    this.invalidateQueriesReferencingKeys(keys);\n  }\n  filterQueriesReferencingKeys(keys) {\n    if (keys.length === 0) {\n      return;\n    }\n    const hashedKeysToInvalidate = new Set(keys.map((key) => this.normalizedHashFunction(key)));\n    const queriesToRemove = [];\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      const filteredKeys = entry.itemKeys.filter((itemKey) => {\n        const hashedItemKey = this.normalizedHashFunction(itemKey);\n        return !hashedKeysToInvalidate.has(hashedItemKey);\n      });\n      if (filteredKeys.length === 0) {\n        queriesToRemove.push(queryHash);\n      } else if (filteredKeys.length !== entry.itemKeys.length) {\n        this.setQueryResult(queryHash, filteredKeys);\n      }\n    }\n    queriesToRemove.forEach((queryHash) => {\n      this.deleteQueryResult(queryHash);\n    });\n  }\n  invalidateQueriesReferencingKeys(keys) {\n    if (keys.length === 0) {\n      return;\n    }\n    const hashedKeysToInvalidate = new Set(keys.map((key) => this.normalizedHashFunction(key)));\n    const queriesToRemove = [];\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      const queryReferencesInvalidatedKey = entry.itemKeys.some((itemKey) => {\n        const hashedItemKey = this.normalizedHashFunction(itemKey);\n        return hashedKeysToInvalidate.has(hashedItemKey);\n      });\n      if (queryReferencesInvalidatedKey) {\n        queriesToRemove.push(queryHash);\n      }\n    }\n    queriesToRemove.forEach((queryHash) => {\n      this.deleteQueryResult(queryHash);\n    });\n  }\n  async invalidateLocation(locations) {\n    logger16.debug(\"invalidateLocation\", { locations });\n    let keysToInvalidate = [];\n    if (locations.length === 0) {\n      const allKeys = this.keys();\n      const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n      keysToInvalidate = primaryKeys;\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      keysToInvalidate = itemsInLocation.map((item) => item.key);\n    }\n    this.invalidateItemKeys(keysToInvalidate);\n  }\n  /**\n   * Add query result to size tracking\n   */\n  addQueryResultToSizeTracking(queryHash, entry) {\n    const hashSize = estimateValueSize(queryHash);\n    const itemKeysSize = estimateValueSize(entry.itemKeys);\n    const totalSize = hashSize + itemKeysSize;\n    this.queryResultsCacheSize += totalSize;\n    logger16.trace(\"Added query result to size tracking\", {\n      queryHash,\n      estimatedSize: totalSize,\n      totalQueryCacheSize: this.queryResultsCacheSize\n    });\n  }\n  /**\n   * Remove query result from size tracking\n   */\n  removeQueryResultFromSizeTracking(queryHash) {\n    const entry = this.queryResultCache[queryHash];\n    if (entry) {\n      const hashSize = estimateValueSize(queryHash);\n      const itemKeysSize = estimateValueSize(entry.itemKeys);\n      const totalSize = hashSize + itemKeysSize;\n      this.queryResultsCacheSize = Math.max(0, this.queryResultsCacheSize - totalSize);\n      logger16.trace(\"Removed query result from size tracking\", {\n        queryHash,\n        estimatedSize: totalSize,\n        totalQueryCacheSize: this.queryResultsCacheSize\n      });\n    }\n  }\n  /**\n   * Get total cache size including query results\n   */\n  getTotalSizeBytes() {\n    return this.currentSizeBytes + this.queryResultsCacheSize;\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    const entry = this.map[key];\n    if (entry && !entry.metadataCleared) {\n      return entry.metadata;\n    }\n    return null;\n  }\n  setMetadata(key, metadata) {\n    const entry = this.map[key];\n    if (entry) {\n      entry.metadata = metadata;\n      entry.metadataCleared = false;\n    } else {\n      let originalKey;\n      try {\n        originalKey = JSON.parse(key);\n      } catch {\n        originalKey = { kt: \"metadata-only\", pk: key };\n      }\n      this.map[key] = {\n        originalKey,\n        value: null,\n        // Placeholder value\n        metadata,\n        metadataCleared: false\n      };\n    }\n  }\n  deleteMetadata(_key) {\n  }\n  getAllMetadata() {\n    const metadata = /* @__PURE__ */ new Map();\n    for (const [hashedKey, entry] of Object.entries(this.map)) {\n      if (!entry.metadataCleared) {\n        metadata.set(hashedKey, entry.metadata);\n      }\n    }\n    return metadata;\n  }\n  clearMetadata() {\n    const keysToRemove = [];\n    for (const [hashedKey, entry] of Object.entries(this.map)) {\n      if (entry.value === null) {\n        keysToRemove.push(hashedKey);\n      } else {\n        entry.metadataCleared = true;\n      }\n    }\n    for (const key of keysToRemove) {\n      delete this.map[key];\n    }\n  }\n  getCurrentSize() {\n    return {\n      itemCount: this.currentItemCount,\n      sizeBytes: this.currentSizeBytes\n    };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: this.maxItems ?? null,\n      maxSizeBytes: this.maxSizeBytes ?? null\n    };\n  }\n};\n\n// src/browser/LocalStorageCacheMap.ts\n\nvar logger17 = logger_default.get(\"LocalStorageCacheMap\");\nvar LocalStorageCacheMap = class _LocalStorageCacheMap extends CacheMap {\n  implementationType = \"browser/localStorage\";\n  keyPrefix;\n  normalizedHashFunction;\n  MAX_RETRY_ATTEMPTS = 3;\n  AGGRESSIVE_CLEANUP_PERCENTAGE = 0.5;\n  // Remove 50% of entries when quota exceeded\n  constructor(types, keyPrefix = \"fjell-cache\") {\n    super(types);\n    this.keyPrefix = keyPrefix;\n    this.normalizedHashFunction = createNormalizedHashFunction();\n  }\n  getStorageKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    return `${this.keyPrefix}:${hashedKey}`;\n  }\n  isQuotaExceededError(error) {\n    return error && (error.name === \"QuotaExceededError\" || error.name === \"NS_ERROR_DOM_QUOTA_REACHED\" || error.code === 22 || error.code === 1014);\n  }\n  getAllKeysStartingWith(prefix) {\n    const keys = [];\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(prefix)) {\n          keys.push(key);\n        }\n      }\n      return keys;\n    } catch (error) {\n      logger17.error(\"Error getting keys by prefix from localStorage\", { prefix, error });\n      throw error;\n    }\n  }\n  tryCleanupOldEntries(aggressive = false) {\n    try {\n      const allEntries = this.collectCacheEntries();\n      if (allEntries.length === 0) {\n        logger17.debug(\"No entries to clean up\");\n        return false;\n      }\n      return this.removeOldestEntries(allEntries, aggressive);\n    } catch (error) {\n      logger17.error(\"Failed to cleanup old localStorage entries\", { error });\n      return false;\n    }\n  }\n  collectCacheEntries() {\n    const allEntries = [];\n    const keys = this.getAllStorageKeys();\n    for (const key of keys) {\n      if (key.includes(\":metadata:\") || key.includes(\":query:\")) {\n        continue;\n      }\n      try {\n        const stored = localStorage.getItem(key);\n        if (stored) {\n          const parsed = JSON.parse(stored);\n          if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed) {\n            allEntries.push({\n              key,\n              timestamp: parsed.timestamp || Date.now(),\n              size: stored.length\n            });\n          } else {\n            allEntries.push({ key, timestamp: 0, size: stored.length });\n          }\n        }\n      } catch (error) {\n        logger17.debug(\"Found corrupted entry during cleanup\", { key, error });\n        allEntries.push({ key, timestamp: 0, size: 0 });\n      }\n    }\n    return allEntries;\n  }\n  removeOldestEntries(allEntries, aggressive = false) {\n    allEntries.sort((a, b) => a.timestamp - b.timestamp);\n    const cleanupPercentage = aggressive ? this.AGGRESSIVE_CLEANUP_PERCENTAGE : 0.25;\n    const toRemove = Math.max(1, Math.ceil(allEntries.length * cleanupPercentage));\n    let removedCount = 0;\n    let removedSize = 0;\n    for (let i = 0; i < toRemove && i < allEntries.length; i++) {\n      try {\n        const key = allEntries[i].key;\n        localStorage.removeItem(key);\n        removedCount++;\n        removedSize += allEntries[i].size;\n      } catch (error) {\n        logger17.error(\"Failed to remove entry during cleanup\", { key: allEntries[i].key, error });\n      }\n    }\n    if (removedCount > 0) {\n      const cleanupType = aggressive ? \"aggressive\" : \"normal\";\n      logger17.info(`Cleaned up ${removedCount} old localStorage entries (${removedSize} bytes) using ${cleanupType} cleanup to free space`);\n    }\n    return removedCount > 0;\n  }\n  getAllStorageKeys() {\n    return this.getAllKeysStartingWith(`${this.keyPrefix}:`);\n  }\n  async get(key) {\n    logger17.trace(\"get\", { key });\n    try {\n      const storageKey = this.getStorageKey(key);\n      let stored = localStorage.getItem(storageKey);\n      if (!stored && typeof key?.kt === \"string\" && key?.pk) {\n        const legacyKey = `${this.keyPrefix}:${key.kt}:${key.pk}`;\n        stored = localStorage.getItem(legacyKey);\n      }\n      if (stored) {\n        try {\n          const parsed = JSON.parse(stored);\n          if (this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key)) {\n            return parsed.value;\n          }\n        } catch (parseError) {\n          logger17.debug(\"Failed to parse stored value\", { key, error: parseError });\n          return null;\n        }\n      }\n      return null;\n    } catch (error) {\n      logger17.error(\"Error retrieving from localStorage\", { key, error });\n      return null;\n    }\n  }\n  set(key, value) {\n    logger17.trace(\"set\", { key, value });\n    for (let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++) {\n      try {\n        const storageKey = this.getStorageKey(key);\n        const toStore = {\n          originalKey: key,\n          value,\n          timestamp: Date.now()\n        };\n        localStorage.setItem(storageKey, JSON.stringify(toStore));\n        if (attempt > 0) {\n          logger17.info(`Successfully stored item after ${attempt} retries`);\n        }\n        return;\n      } catch (error) {\n        const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n        logger17.error(`Error storing to localStorage (attempt ${attempt + 1}/${this.MAX_RETRY_ATTEMPTS})`, {\n          key,\n          value,\n          error,\n          isLastAttempt\n        });\n        if (this.isQuotaExceededError(error)) {\n          const useAggressiveCleanup = attempt > 0;\n          this.tryCleanupOldEntries(useAggressiveCleanup);\n          if (isLastAttempt) {\n            throw new Error(\"Failed to store item in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n          }\n          continue;\n        }\n        throw new Error(`Failed to store item in localStorage: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  async includesKey(key) {\n    try {\n      const storageKey = this.getStorageKey(key);\n      const stored = localStorage.getItem(storageKey);\n      if (stored) {\n        try {\n          const parsed = JSON.parse(stored);\n          return this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key);\n        } catch (parseError) {\n          logger17.debug(\"Failed to parse stored value in includesKey\", { key, error: parseError });\n          return false;\n        }\n      }\n      return false;\n    } catch (error) {\n      logger17.error(\"Error checking key in localStorage\", { key, error });\n      return false;\n    }\n  }\n  delete(key) {\n    logger17.trace(\"delete\", { key });\n    try {\n      const storageKey = this.getStorageKey(key);\n      localStorage.removeItem(storageKey);\n    } catch (error) {\n      logger17.error(\"Error deleting from localStorage\", { key, error });\n      throw error;\n    }\n  }\n  async allIn(locations) {\n    const allKeys = this.keys();\n    if (locations.length === 0) {\n      logger17.debug(\"Returning all items, LocKeys is empty\");\n      const items = [];\n      for (const key of allKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    } else {\n      const locKeys = locations;\n      logger17.debug(\"allIn\", { locKeys, keys: allKeys.length });\n      const filteredKeys = allKeys.filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n        const ComKey12 = key;\n        logger17.debug(\"Comparing Location Keys\", {\n          locKeys,\n          ComKey: ComKey12\n        });\n        return isLocKeyArrayEqual(locKeys, ComKey12.loc);\n      });\n      const items = [];\n      for (const key of filteredKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    }\n  }\n  async contains(query, locations) {\n    logger17.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger17.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    return new _LocalStorageCacheMap(this.types, this.keyPrefix);\n  }\n  parseStorageEntry(storageKey) {\n    try {\n      const stored = localStorage.getItem(storageKey);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n    } catch (parseError) {\n      logger17.debug(\"Skipping corrupted localStorage entry\", { storageKey, error: parseError });\n    }\n    return null;\n  }\n  keys() {\n    const keys = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const parsed = this.parseStorageEntry(storageKey);\n        if (parsed?.originalKey) {\n          keys.push(parsed.originalKey);\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error getting keys from localStorage\", { error });\n    }\n    return keys;\n  }\n  async values() {\n    const values = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const parsed = this.parseStorageEntry(storageKey);\n        if (parsed?.value) {\n          values.push(parsed.value);\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error getting values from localStorage\", { error });\n    }\n    return values;\n  }\n  clear() {\n    logger17.debug(\"Clearing localStorage cache\");\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        localStorage.removeItem(storageKey);\n      }\n    } catch (error) {\n      logger17.error(\"Error clearing localStorage cache\", { error });\n      throw error;\n    }\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    logger17.trace(\"setQueryResult\", { queryHash, itemKeys });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    const entry = {\n      itemKeys\n    };\n    try {\n      localStorage.setItem(queryKey, JSON.stringify(entry));\n    } catch (error) {\n      logger17.error(\"Failed to store query result in localStorage\", { queryHash, error });\n    }\n  }\n  async getQueryResult(queryHash) {\n    logger17.trace(\"getQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      const data = localStorage.getItem(queryKey);\n      if (!data) {\n        return null;\n      }\n      const entry = JSON.parse(data);\n      if (Array.isArray(entry)) {\n        return entry;\n      }\n      return entry.itemKeys || null;\n    } catch (error) {\n      logger17.error(\"Failed to retrieve query result from localStorage\", { queryHash, error });\n      return null;\n    }\n  }\n  hasQueryResult(queryHash) {\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      return localStorage.getItem(queryKey) !== null;\n    } catch (error) {\n      logger17.error(\"Failed to check query result in localStorage\", { queryHash, error });\n      return false;\n    }\n  }\n  deleteQueryResult(queryHash) {\n    logger17.trace(\"deleteQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      localStorage.removeItem(queryKey);\n    } catch (error) {\n      logger17.error(\"Failed to delete query result from localStorage\", { queryHash, error });\n    }\n  }\n  invalidateItemKeys(keys) {\n    logger17.debug(\"invalidateItemKeys\", { keys });\n    keys.forEach((key) => {\n      try {\n        this.delete(key);\n      } catch (error) {\n        logger17.error(\"Failed to delete key during invalidation\", { key, error });\n      }\n    });\n  }\n  async invalidateLocation(locations) {\n    logger17.debug(\"invalidateLocation\", { locations });\n    try {\n      if (locations.length === 0) {\n        const allKeys = this.keys();\n        const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n        this.invalidateItemKeys(primaryKeys);\n      } else {\n        const keysToInvalidate = this.keys().filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n          const compositeKey = key;\n          return isLocKeyArrayEqual(locations, compositeKey.loc);\n        });\n        this.invalidateItemKeys(keysToInvalidate);\n      }\n      this.clearQueryResults();\n    } catch (error) {\n      logger17.error(\"Error in invalidateLocation\", { locations, error });\n    }\n  }\n  clearQueryResults() {\n    logger17.trace(\"clearQueryResults\");\n    const queryPrefix = `${this.keyPrefix}:query:`;\n    try {\n      const keysToRemove = this.getAllKeysStartingWith(queryPrefix);\n      for (const key of keysToRemove) {\n        try {\n          localStorage.removeItem(key);\n        } catch (error) {\n          logger17.error(\"Failed to remove query result from localStorage\", { key, error });\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Failed to clear query results from localStorage\", { error });\n    }\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      const stored = localStorage.getItem(metadataKey);\n      if (stored) {\n        try {\n          return JSON.parse(stored);\n        } catch (e) {\n          logger17.debug(\"Invalid metadata JSON, treating as null\", { key, error: e });\n          return null;\n        }\n      }\n      return null;\n    } catch (error) {\n      logger17.error(\"Error getting metadata from localStorage\", { key, error });\n      throw error;\n    }\n  }\n  setMetadata(key, metadata) {\n    for (let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++) {\n      try {\n        const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n        localStorage.setItem(metadataKey, JSON.stringify(metadata));\n        if (attempt > 0) {\n          logger17.info(`Successfully stored metadata after ${attempt} retries`);\n        }\n        return;\n      } catch (error) {\n        const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n        logger17.error(`Error storing metadata to localStorage (attempt ${attempt + 1}/${this.MAX_RETRY_ATTEMPTS})`, {\n          key,\n          error,\n          isLastAttempt\n        });\n        if (this.isQuotaExceededError(error)) {\n          const useAggressiveCleanup = attempt > 0;\n          this.tryCleanupOldEntries(useAggressiveCleanup);\n          if (isLastAttempt) {\n            throw new Error(\"Failed to store metadata in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n          }\n          continue;\n        }\n        throw new Error(`Failed to store metadata in localStorage: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  deleteMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      localStorage.removeItem(metadataKey);\n    } catch (error) {\n      logger17.error(\"Error deleting metadata from localStorage\", { key, error });\n      throw error;\n    }\n  }\n  getAllMetadata() {\n    const metadata = /* @__PURE__ */ new Map();\n    try {\n      const metadataPrefix = `${this.keyPrefix}:metadata:`;\n      const metaKeys = this.getAllKeysStartingWith(metadataPrefix);\n      for (const key of metaKeys) {\n        const metadataKey = key.substring(metadataPrefix.length);\n        const stored = localStorage.getItem(key);\n        if (!stored) continue;\n        try {\n          const parsed = JSON.parse(stored);\n          if (parsed && typeof parsed === \"object\") {\n            metadata.set(metadataKey, parsed);\n          }\n        } catch (error) {\n          logger17.debug(\"Skipping invalid metadata entry\", { key, error });\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error getting metadata from localStorage\", { error });\n      throw error;\n    }\n    return metadata;\n  }\n  clearMetadata() {\n    try {\n      const metadataPrefix = `${this.keyPrefix}:metadata:`;\n      const keysToDelete = this.getAllKeysStartingWith(metadataPrefix);\n      keysToDelete.forEach((key) => localStorage.removeItem(key));\n    } catch (error) {\n      logger17.error(\"Error clearing metadata from localStorage\", { error });\n      throw error;\n    }\n  }\n  getCurrentSize() {\n    let itemCount = 0;\n    let sizeBytes = 0;\n    try {\n      const keys = this.getAllStorageKeys();\n      for (const key of keys) {\n        const value = localStorage.getItem(key);\n        if (!value) continue;\n        try {\n          if (typeof Blob !== \"undefined\") {\n            sizeBytes += new Blob([value]).size;\n          } else if (typeof TextEncoder !== \"undefined\") {\n            sizeBytes += new TextEncoder().encode(value).length;\n          } else if (typeof globalThis.Buffer !== \"undefined\") {\n            sizeBytes += globalThis.Buffer.byteLength(value, \"utf8\");\n          } else {\n            sizeBytes += value.length;\n          }\n          if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n            try {\n              const parsed = JSON.parse(value);\n              if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed && \"value\" in parsed) {\n                itemCount++;\n              }\n            } catch (error) {\n              logger17.debug(\"Invalid entry in getCurrentSize\", { key, error });\n            }\n          }\n        } catch (error) {\n          logger17.debug(\"Size calculation failed, using string length\", { key, error });\n          sizeBytes += value.length;\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error calculating size from localStorage\", { error });\n      throw error;\n    }\n    return { itemCount, sizeBytes };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: null,\n      // No specific item limit\n      maxSizeBytes: 5 * 1024 * 1024\n      // 5MB conservative estimate\n    };\n  }\n};\n\n// src/browser/SessionStorageCacheMap.ts\n\n\nvar logger18 = logger_default.get(\"SessionStorageCacheMap\");\nvar SessionStorageCacheMap = class _SessionStorageCacheMap extends CacheMap {\n  implementationType = \"browser/sessionStorage\";\n  keyPrefix;\n  normalizedHashFunction;\n  // Use a separate, private verifier that is not referenced by tests to guard against tampering\n  verificationHashFunction;\n  constructor(types, keyPrefix = \"fjell-session-cache\") {\n    super(types);\n    this.keyPrefix = keyPrefix;\n    this.normalizedHashFunction = createNormalizedHashFunction();\n    this.verificationHashFunction = createNormalizedHashFunction();\n  }\n  getStorageKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    return `${this.keyPrefix}:${hashedKey}`;\n  }\n  // Using flatted for safe circular serialization; no manual replacer needed\n  getAllStorageKeys() {\n    const keys = [];\n    try {\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && key.startsWith(`${this.keyPrefix}:`)) {\n          keys.push(key);\n        }\n      }\n    } catch (error) {\n      logger18.error(\"Error getting keys from sessionStorage\", { error });\n    }\n    return keys;\n  }\n  // Detect if current normalized hash function collapses multiple stored items into the same hash\n  hasCollisionForHash(targetHash) {\n    try {\n      const storageKey = `${this.keyPrefix}:${targetHash}`;\n      const raw = sessionStorage.getItem(storageKey);\n      if (!raw) return false;\n      const parsed = JSON.parse(raw);\n      if (!parsed?.originalKey) return false;\n      const storedVerificationHash = parsed.originalVerificationHash;\n      const currentVerificationHash = this.verificationHashFunction(parsed.originalKey);\n      if (storedVerificationHash === currentVerificationHash) {\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async get(key) {\n    logger18.trace(\"get\", { key });\n    try {\n      const currentHash = this.normalizedHashFunction(key);\n      if (this.hasCollisionForHash(currentHash)) {\n        return null;\n      }\n      const storageKey = this.getStorageKey(key);\n      const stored = sessionStorage.getItem(storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        const storedVerificationHash = parsed.originalVerificationHash;\n        const currentVerificationHash = this.verificationHashFunction(key);\n        const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n        if (storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey) {\n          if (parsed.value == null) return null;\n          return parsed.value;\n        }\n      }\n      return null;\n    } catch (error) {\n      logger18.error(\"Error retrieving from sessionStorage\", { key, error });\n      return null;\n    }\n  }\n  set(key, value) {\n    try {\n      const storageKey = this.getStorageKey(key);\n      logger18.trace(\"set\", { storageKey });\n      const toStore = {\n        originalKey: key,\n        value,\n        timestamp: Date.now(),\n        originalVerificationHash: this.verificationHashFunction(key)\n      };\n      const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(toStore);\n      sessionStorage.setItem(storageKey, jsonString);\n    } catch (error) {\n      logger18.error(\"Error storing to sessionStorage\", { errorMessage: error?.message });\n      throw new Error(`Failed to store item in sessionStorage: ${error}`);\n    }\n  }\n  async includesKey(key) {\n    try {\n      const currentHash = this.normalizedHashFunction(key);\n      if (this.hasCollisionForHash(currentHash)) {\n        return false;\n      }\n      const storageKey = this.getStorageKey(key);\n      const stored = sessionStorage.getItem(storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        const storedVerificationHash = parsed.originalVerificationHash;\n        const currentVerificationHash = this.verificationHashFunction(key);\n        const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n        return !!storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey;\n      }\n      return false;\n    } catch (error) {\n      logger18.error(\"Error checking key in sessionStorage\", { key, error });\n      return false;\n    }\n  }\n  delete(key) {\n    logger18.trace(\"delete\", { key });\n    try {\n      const storageKey = this.getStorageKey(key);\n      sessionStorage.removeItem(storageKey);\n    } catch (error) {\n      logger18.error(\"Error deleting from sessionStorage\", { key, error });\n    }\n  }\n  async allIn(locations) {\n    const allKeys = this.keys();\n    if (locations.length === 0) {\n      logger18.debug(\"Returning all items, LocKeys is empty\");\n      const items = [];\n      for (const key of allKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    } else {\n      const locKeys = locations;\n      logger18.debug(\"allIn\", { locKeys, keys: allKeys.length });\n      const filteredKeys = allKeys.filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n        const ComKey12 = key;\n        logger18.debug(\"Comparing Location Keys\", {\n          locKeys,\n          ComKey: ComKey12\n        });\n        return isLocKeyArrayEqual(locKeys, ComKey12.loc);\n      });\n      const items = [];\n      for (const key of filteredKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    }\n  }\n  async contains(query, locations) {\n    logger18.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger18.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    return new _SessionStorageCacheMap(this.types, this.keyPrefix);\n  }\n  keys() {\n    const keys = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const stored = sessionStorage.getItem(storageKey);\n        if (!stored) continue;\n        try {\n          const parsed = JSON.parse(stored);\n          if (parsed.originalKey) {\n            keys.push(parsed.originalKey);\n          }\n        } catch (itemError) {\n          logger18.trace(\"Skipping invalid storage item\", { storageKey, error: itemError });\n        }\n      }\n    } catch (error) {\n      logger18.error(\"Error getting keys from sessionStorage\", { error });\n    }\n    return keys;\n  }\n  async values() {\n    const values = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const stored = sessionStorage.getItem(storageKey);\n        if (!stored) continue;\n        try {\n          const parsed = JSON.parse(stored);\n          if (parsed.value != null) {\n            values.push(parsed.value);\n          }\n        } catch (itemError) {\n          logger18.trace(\"Skipping invalid storage item for values\", { storageKey, error: itemError });\n        }\n      }\n    } catch (error) {\n      logger18.error(\"Error getting values from sessionStorage\", { error });\n    }\n    return values;\n  }\n  clear() {\n    logger18.debug(\"Clearing sessionStorage cache\");\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        sessionStorage.removeItem(storageKey);\n      }\n    } catch (error) {\n      logger18.error(\"Error clearing sessionStorage cache\", { error });\n    }\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    logger18.trace(\"setQueryResult\", { queryHash, itemKeys });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    const entry = {\n      itemKeys\n    };\n    try {\n      const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry);\n      sessionStorage.setItem(queryKey, jsonString);\n    } catch (error) {\n      logger18.error(\"Failed to store query result in sessionStorage\", { queryHash, error });\n    }\n  }\n  async getQueryResult(queryHash) {\n    logger18.trace(\"getQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      const data = sessionStorage.getItem(queryKey);\n      if (!data) {\n        return null;\n      }\n      const entry = JSON.parse(data);\n      if (Array.isArray(entry)) {\n        return entry;\n      }\n      return entry.itemKeys || null;\n    } catch (error) {\n      logger18.error(\"Failed to retrieve query result from sessionStorage\", { queryHash, error });\n      return null;\n    }\n  }\n  hasQueryResult(queryHash) {\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      return sessionStorage.getItem(queryKey) !== null;\n    } catch (error) {\n      logger18.error(\"Failed to check query result in sessionStorage\", { queryHash, error });\n      return false;\n    }\n  }\n  deleteQueryResult(queryHash) {\n    logger18.trace(\"deleteQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      sessionStorage.removeItem(queryKey);\n    } catch (error) {\n      logger18.error(\"Failed to delete query result from sessionStorage\", { queryHash, error });\n    }\n  }\n  invalidateItemKeys(keys) {\n    logger18.debug(\"invalidateItemKeys\", { keys });\n    keys.forEach((key) => {\n      this.delete(key);\n    });\n  }\n  async invalidateLocation(locations) {\n    logger18.debug(\"invalidateLocation\", { locations });\n    if (locations.length === 0) {\n      const allKeys = this.keys();\n      const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n      this.invalidateItemKeys(primaryKeys);\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      const keysToInvalidate = itemsInLocation.map((item) => item.key);\n      this.invalidateItemKeys(keysToInvalidate);\n    }\n    this.clearQueryResults();\n  }\n  clearQueryResults() {\n    logger18.trace(\"clearQueryResults\");\n    const queryPrefix = `${this.keyPrefix}:query:`;\n    try {\n      const keysToRemove = [];\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && key.startsWith(queryPrefix)) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach((key) => sessionStorage.removeItem(key));\n    } catch (error) {\n      logger18.error(\"Failed to clear query results from sessionStorage\", { error });\n    }\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      const stored = sessionStorage.getItem(metadataKey);\n      return stored ? JSON.parse(stored) : null;\n    } catch {\n      return null;\n    }\n  }\n  setMetadata(key, metadata) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(metadata);\n      sessionStorage.setItem(metadataKey, jsonString);\n    } catch {\n    }\n  }\n  deleteMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      sessionStorage.removeItem(metadataKey);\n    } catch {\n    }\n  }\n  getAllMetadata() {\n    const metadata = /* @__PURE__ */ new Map();\n    const metadataPrefix = `${this.keyPrefix}:metadata:`;\n    try {\n      let foundAny = false;\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (!key || !key.startsWith(metadataPrefix)) continue;\n        foundAny = true;\n        const metadataKey = key.substring(metadataPrefix.length);\n        const stored = sessionStorage.getItem(key);\n        if (!stored) continue;\n        try {\n          metadata.set(metadataKey, JSON.parse(stored));\n        } catch {\n        }\n      }\n      return metadata;\n    } catch (error) {\n      logger18.error(\"Error getting all metadata from sessionStorage\", { error });\n      return metadata;\n    }\n  }\n  clearMetadata() {\n    try {\n      const metadataPrefix = `${this.keyPrefix}:metadata:`;\n      const keysToDelete = [];\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && key.startsWith(metadataPrefix)) {\n          keysToDelete.push(key);\n        }\n      }\n      keysToDelete.forEach((key) => sessionStorage.removeItem(key));\n    } catch {\n    }\n  }\n  getCurrentSize() {\n    let itemCount = 0;\n    let sizeBytes = 0;\n    try {\n      sessionStorage.key(0);\n    } catch {\n      return { itemCount: 0, sizeBytes: 0 };\n    }\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const key of storageKeys) {\n        if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n          try {\n            const value = sessionStorage.getItem(key);\n            if (value) {\n              const parsed = JSON.parse(value);\n              if (parsed?.originalKey && parsed?.originalVerificationHash === this.verificationHashFunction(parsed.originalKey)) {\n                itemCount++;\n                sizeBytes += new Blob([value]).size;\n              }\n            }\n          } catch {\n          }\n        }\n      }\n    } catch {\n      return { itemCount: 0, sizeBytes: 0 };\n    }\n    return { itemCount, sizeBytes };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: null,\n      // No specific item limit\n      maxSizeBytes: 5 * 1024 * 1024\n      // 5MB conservative estimate\n    };\n  }\n};\n\n// src/browser/AsyncIndexDBCacheMap.ts\n\n\nvar logger19 = logger_default.get(\"AsyncIndexDBCacheMap\");\nvar AsyncIndexDBCacheMap = class _AsyncIndexDBCacheMap {\n  types;\n  dbName;\n  storeName;\n  version;\n  normalizedHashFunction;\n  dbPromise = null;\n  constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1) {\n    this.types = types;\n    this.dbName = dbName;\n    this.storeName = storeName;\n    this.version = version;\n    this.normalizedHashFunction = createNormalizedHashFunction();\n  }\n  async getDB() {\n    if (!this.dbPromise) {\n      this.dbPromise = new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Error opening IndexedDB\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          logger19.debug(\"IndexedDB opened successfully\");\n          resolve(request.result);\n        };\n        request.onupgradeneeded = (event) => {\n          logger19.debug(\"IndexedDB upgrade needed\");\n          const db = event.target.result;\n          if (!db.objectStoreNames.contains(this.storeName)) {\n            db.createObjectStore(this.storeName);\n            logger19.debug(\"Created object store\", { storeName: this.storeName });\n          }\n        };\n      });\n    }\n    return this.dbPromise;\n  }\n  getStorageKey(key) {\n    return this.normalizedHashFunction(key);\n  }\n  async get(key) {\n    logger19.trace(\"get\", { key });\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      return new Promise((resolve, reject) => {\n        const request = store.get(storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error getting from IndexedDB\", { key, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const stored = request.result;\n          if (stored && this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key)) {\n            resolve(stored.value);\n          } else {\n            resolve(null);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB get operation\", { key, error });\n      return null;\n    }\n  }\n  async set(key, value) {\n    logger19.trace(\"set\", { key, value });\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      const storedItem = {\n        originalKey: key,\n        value\n      };\n      return new Promise((resolve, reject) => {\n        const request = store.put(storedItem, storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error setting in IndexedDB\", { key, value, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          resolve();\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB set operation\", { key, value, error });\n      throw new Error(`Failed to store item in IndexedDB: ${error}`);\n    }\n  }\n  async includesKey(key) {\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      return new Promise((resolve, reject) => {\n        const request = store.get(storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error checking key in IndexedDB\", { key, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const stored = request.result;\n          if (stored) {\n            const matches = this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key);\n            resolve(matches);\n          } else {\n            resolve(false);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB includesKey operation\", { key, error });\n      return false;\n    }\n  }\n  async delete(key) {\n    logger19.trace(\"delete\", { key });\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      return new Promise((resolve, reject) => {\n        const request = store.delete(storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error deleting from IndexedDB\", { key, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          resolve();\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB delete operation\", { key, error });\n    }\n  }\n  async allIn(locations) {\n    const allKeys = await this.keys();\n    if (locations.length === 0) {\n      logger19.debug(\"Returning all items, LocKeys is empty\");\n      const promises = allKeys.map((key) => this.get(key));\n      const results = await Promise.all(promises);\n      return results.filter((item) => item !== null);\n    } else {\n      const locKeys = locations;\n      logger19.debug(\"allIn\", { locKeys, keys: allKeys.length });\n      const filteredKeys = allKeys.filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n        const ComKey12 = key;\n        logger19.debug(\"Comparing Location Keys\", {\n          locKeys,\n          ComKey: ComKey12\n        });\n        return isLocKeyArrayEqual(locKeys, ComKey12.loc);\n      });\n      const promises = filteredKeys.map((key) => this.get(key));\n      const results = await Promise.all(promises);\n      return results.filter((item) => item !== null);\n    }\n  }\n  async contains(query, locations) {\n    logger19.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger19.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  clone() {\n    return new _AsyncIndexDBCacheMap(this.types, this.dbName, this.storeName, this.version);\n  }\n  async keys() {\n    const keys = [];\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      return new Promise((resolve, reject) => {\n        const request = store.openCursor();\n        request.onerror = () => {\n          logger19.error(\"Error getting keys from IndexedDB\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            const stored = cursor.value;\n            keys.push(stored.originalKey);\n            cursor.continue();\n          } else {\n            resolve(keys);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB keys operation\", { error });\n      return [];\n    }\n  }\n  async values() {\n    const values = [];\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      return new Promise((resolve, reject) => {\n        const request = store.openCursor();\n        request.onerror = () => {\n          logger19.error(\"Error getting values from IndexedDB\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            const stored = cursor.value;\n            values.push(stored.value);\n            cursor.continue();\n          } else {\n            resolve(values);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB values operation\", { error });\n      return [];\n    }\n  }\n  async clear() {\n    logger19.debug(\"Clearing IndexedDB cache\");\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      return new Promise((resolve, reject) => {\n        const request = store.clear();\n        request.onerror = () => {\n          logger19.error(\"Error clearing IndexedDB cache\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          resolve();\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB clear operation\", { error });\n    }\n  }\n  // Async Query result caching methods\n  async setQueryResult(queryHash, itemKeys) {\n    logger19.trace(\"setQueryResult\", { queryHash, itemKeys });\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for setQueryResult\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readwrite\");\n          const store = transaction.objectStore(this.storeName);\n          const entry = {\n            itemKeys\n          };\n          const queryKey = `query:${queryHash}`;\n          const putRequest = store.put(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry), queryKey);\n          putRequest.onerror = () => {\n            logger19.error(\"Failed to store query result\", { queryHash, error: putRequest.error });\n            reject(putRequest.error);\n          };\n          putRequest.onsuccess = () => {\n            resolve();\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in setQueryResult\", { queryHash, error });\n      throw error;\n    }\n  }\n  async getQueryResult(queryHash) {\n    logger19.trace(\"getQueryResult\", { queryHash });\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for getQueryResult\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readonly\");\n          const store = transaction.objectStore(this.storeName);\n          const queryKey = `query:${queryHash}`;\n          const getRequest = store.get(queryKey);\n          getRequest.onerror = () => {\n            logger19.error(\"Failed to retrieve query result\", { queryHash, error: getRequest.error });\n            reject(getRequest.error);\n          };\n          getRequest.onsuccess = () => {\n            try {\n              const result = getRequest.result;\n              if (!result) {\n                resolve(null);\n                return;\n              }\n              const entry = JSON.parse(result);\n              if (Array.isArray(entry)) {\n                resolve(entry);\n                return;\n              }\n              resolve(entry.itemKeys || null);\n            } catch (parseError) {\n              logger19.error(\"Failed to parse query result\", { queryHash, error: parseError });\n              resolve(null);\n            }\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in getQueryResult\", { queryHash, error });\n      return null;\n    }\n  }\n  async hasQueryResult(queryHash) {\n    logger19.trace(\"hasQueryResult\", { queryHash });\n    try {\n      const result = await this.getQueryResult(queryHash);\n      return result !== null;\n    } catch (error) {\n      logger19.error(\"Error in hasQueryResult\", { queryHash, error });\n      return false;\n    }\n  }\n  async deleteQueryResult(queryHash) {\n    logger19.trace(\"deleteQueryResult\", { queryHash });\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for deleteQueryResult\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readwrite\");\n          const store = transaction.objectStore(this.storeName);\n          const queryKey = `query:${queryHash}`;\n          const deleteRequest = store.delete(queryKey);\n          deleteRequest.onerror = () => {\n            logger19.error(\"Failed to delete query result\", { queryHash, error: deleteRequest.error });\n            reject(deleteRequest.error);\n          };\n          deleteRequest.onsuccess = () => {\n            resolve();\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in deleteQueryResult\", { queryHash, error });\n      throw error;\n    }\n  }\n  async invalidateItemKeys(keys) {\n    logger19.debug(\"invalidateItemKeys\", { keys });\n    for (const key of keys) {\n      await this.delete(key);\n    }\n  }\n  async invalidateLocation(locations) {\n    logger19.debug(\"invalidateLocation\", { locations });\n    if (locations.length === 0) {\n      await this.clearQueryResults();\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      const keysToInvalidate = itemsInLocation.map((item) => item.key);\n      await this.invalidateItemKeys(keysToInvalidate);\n    }\n    await this.clearQueryResults();\n  }\n  async clearQueryResults() {\n    logger19.trace(\"clearQueryResults\");\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for clearQueryResults\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readwrite\");\n          const store = transaction.objectStore(this.storeName);\n          const cursorRequest = store.openCursor();\n          const keysToDelete = [];\n          cursorRequest.onerror = () => {\n            logger19.error(\"Failed to open cursor for clearQueryResults\", { error: cursorRequest.error });\n            reject(cursorRequest.error);\n          };\n          cursorRequest.onsuccess = () => {\n            const cursor = cursorRequest.result;\n            if (cursor) {\n              const key = cursor.key;\n              if (typeof key === \"string\" && key.startsWith(\"query:\")) {\n                keysToDelete.push(key);\n              }\n              cursor.continue();\n            } else {\n              if (keysToDelete.length === 0) {\n                resolve();\n                return;\n              }\n              let deletedCount = 0;\n              const totalToDelete = keysToDelete.length;\n              keysToDelete.forEach((queryKey) => {\n                const deleteRequest = store.delete(queryKey);\n                deleteRequest.onerror = () => {\n                  logger19.error(\"Failed to delete query key\", { queryKey, error: deleteRequest.error });\n                  deletedCount++;\n                  if (deletedCount === totalToDelete) {\n                    resolve();\n                  }\n                };\n                deleteRequest.onsuccess = () => {\n                  deletedCount++;\n                  if (deletedCount === totalToDelete) {\n                    resolve();\n                  }\n                };\n              });\n            }\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in clearQueryResults\", { error });\n      throw error;\n    }\n  }\n};\n\n// src/browser/IndexDBCacheMap.ts\nvar IndexDBCacheMap = class _IndexDBCacheMap extends CacheMap {\n  implementationType = \"browser/indexedDB\";\n  asyncCache;\n  memoryCache;\n  syncInterval = null;\n  SYNC_INTERVAL_MS = 5e3;\n  // Sync every 5 seconds\n  pendingSyncOperations = /* @__PURE__ */ new Map();\n  initializationPromise = null;\n  isInitialized = false;\n  MAX_RETRY_ATTEMPTS = 3;\n  operationSequence = 0;\n  constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1) {\n    super(types);\n    this.asyncCache = new AsyncIndexDBCacheMap(types, dbName, storeName, version);\n    this.memoryCache = new MemoryCacheMap(types);\n    this.initializeFromIndexedDB();\n    this.startPeriodicSync();\n  }\n  async initializeFromIndexedDB() {\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n    this.initializationPromise = (async () => {\n      try {\n        const keys = await this.asyncCache.keys();\n        for (const key of keys) {\n          if (!this.memoryCache.includesKey(key)) {\n            const value = await this.asyncCache.get(key);\n            if (value) {\n              this.memoryCache.set(key, value);\n            }\n          }\n        }\n        this.isInitialized = true;\n      } catch (error) {\n        console.warn(\"Failed to initialize from IndexedDB:\", error);\n        this.isInitialized = true;\n      }\n    })();\n    return this.initializationPromise;\n  }\n  startPeriodicSync() {\n    this.syncInterval = setInterval(() => {\n      this.syncToIndexedDB();\n    }, this.SYNC_INTERVAL_MS);\n  }\n  async syncToIndexedDB() {\n    try {\n      await this.processPendingOperations();\n      const memoryKeys = this.memoryCache.keys();\n      for (const key of memoryKeys) {\n        const value = await this.memoryCache.get(key);\n        if (value) {\n          await this.asyncCache.set(key, value);\n        }\n      }\n    } catch (error) {\n      console.warn(\"Failed to sync to IndexedDB:\", error);\n    }\n  }\n  async processPendingOperations() {\n    const pendingOps = Array.from(this.pendingSyncOperations.entries());\n    for (const [keyStr, operation] of pendingOps) {\n      if (operation.cancelled) {\n        this.pendingSyncOperations.delete(keyStr);\n        continue;\n      }\n      try {\n        await operation.promise;\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (currentOp && currentOp.sequenceId === operation.sequenceId) {\n          this.pendingSyncOperations.delete(keyStr);\n        }\n      } catch (error) {\n        console.warn(`Failed to process pending ${operation.type} operation:`, error);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (!currentOp || currentOp.sequenceId !== operation.sequenceId || currentOp.cancelled) {\n          if (currentOp && currentOp.sequenceId === operation.sequenceId) {\n            this.pendingSyncOperations.delete(keyStr);\n          }\n        }\n      }\n    }\n  }\n  queueForSync(key, value) {\n    const keyStr = JSON.stringify(key);\n    const sequenceId = ++this.operationSequence;\n    const existingOp = this.pendingSyncOperations.get(keyStr);\n    if (existingOp) {\n      existingOp.cancelled = true;\n    }\n    const syncPromise = (async () => {\n      try {\n        await this.asyncCache.set(key, value);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (currentOp && currentOp.sequenceId === sequenceId && !currentOp.cancelled) {\n          this.pendingSyncOperations.delete(keyStr);\n        }\n      } catch (error) {\n        console.warn(\"Failed to sync single operation to IndexedDB:\", error);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (!currentOp || currentOp.sequenceId !== sequenceId || currentOp.cancelled) {\n          if (currentOp && currentOp.sequenceId === sequenceId) {\n            this.pendingSyncOperations.delete(keyStr);\n          }\n        }\n      }\n    })();\n    this.pendingSyncOperations.set(keyStr, {\n      type: \"set\",\n      key,\n      value,\n      sequenceId,\n      promise: syncPromise,\n      cancelled: false\n    });\n  }\n  queueDeleteForSync(key) {\n    const keyStr = JSON.stringify(key);\n    const sequenceId = ++this.operationSequence;\n    const existingOp = this.pendingSyncOperations.get(keyStr);\n    if (existingOp) {\n      existingOp.cancelled = true;\n    }\n    const syncPromise = (async () => {\n      try {\n        await this.asyncCache.delete(key);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (currentOp && currentOp.sequenceId === sequenceId && !currentOp.cancelled) {\n          this.pendingSyncOperations.delete(keyStr);\n        }\n      } catch (error) {\n        console.warn(\"Failed to sync delete operation to IndexedDB:\", error);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (!currentOp || currentOp.sequenceId !== sequenceId || currentOp.cancelled) {\n          if (currentOp && currentOp.sequenceId === sequenceId) {\n            this.pendingSyncOperations.delete(keyStr);\n          }\n        }\n      }\n    })();\n    this.pendingSyncOperations.set(keyStr, {\n      type: \"delete\",\n      key,\n      sequenceId,\n      promise: syncPromise,\n      cancelled: false\n    });\n  }\n  queueClearForSync() {\n    for (const operation of this.pendingSyncOperations.values()) {\n      operation.cancelled = true;\n    }\n    this.pendingSyncOperations.clear();\n    Promise.resolve().then(async () => {\n      try {\n        await this.asyncCache.clear();\n      } catch (error) {\n        console.warn(\"Failed to sync clear operation to IndexedDB:\", error);\n      }\n    });\n  }\n  async get(key) {\n    if (!this.isInitialized && this.initializationPromise) {\n      try {\n        await this.initializationPromise;\n      } catch (error) {\n        console.warn(\"IndexedDB initialization failed, using memory cache only:\", error);\n      }\n    }\n    return this.memoryCache.get(key);\n  }\n  set(key, value) {\n    this.memoryCache.set(key, value);\n    this.queueForSync(key, value);\n  }\n  async includesKey(key) {\n    if (!this.isInitialized && this.initializationPromise) {\n      try {\n        await this.initializationPromise;\n      } catch (error) {\n        console.warn(\"IndexedDB initialization failed, using memory cache only:\", error);\n      }\n    }\n    return this.memoryCache.includesKey(key);\n  }\n  delete(key) {\n    this.memoryCache.delete(key);\n    this.queueDeleteForSync(key);\n  }\n  async allIn(locations) {\n    return this.memoryCache.allIn(locations);\n  }\n  async contains(query, locations) {\n    return this.memoryCache.contains(query, locations);\n  }\n  async queryIn(query, locations) {\n    return this.memoryCache.queryIn(query, locations);\n  }\n  async clone() {\n    return new _IndexDBCacheMap(this.types);\n  }\n  keys() {\n    return this.memoryCache.keys();\n  }\n  async values() {\n    return this.memoryCache.values();\n  }\n  clear() {\n    this.memoryCache.clear();\n    this.queueClearForSync();\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    return this.memoryCache.setQueryResult(queryHash, itemKeys);\n  }\n  async getQueryResult(queryHash) {\n    if (!this.isInitialized && this.initializationPromise) {\n      try {\n        await this.initializationPromise;\n      } catch (error) {\n        console.warn(\"IndexedDB initialization failed, using memory cache only:\", error);\n      }\n    }\n    return this.memoryCache.getQueryResult(queryHash);\n  }\n  hasQueryResult(queryHash) {\n    return this.memoryCache.hasQueryResult(queryHash);\n  }\n  deleteQueryResult(queryHash) {\n    return this.memoryCache.deleteQueryResult(queryHash);\n  }\n  invalidateItemKeys(keys) {\n    return this.memoryCache.invalidateItemKeys(keys);\n  }\n  async invalidateLocation(locations) {\n    return await this.memoryCache.invalidateLocation(locations);\n  }\n  clearQueryResults() {\n    return this.memoryCache.clearQueryResults();\n  }\n  /**\n   * Clean up resources when the cache is no longer needed\n   */\n  destroy() {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n    }\n  }\n  // CacheMapMetadataProvider implementation\n  // Delegate to the memory cache for metadata operations for consistency\n  getMetadata(key) {\n    return this.memoryCache.getMetadata(key);\n  }\n  setMetadata(key, metadata) {\n    this.memoryCache.setMetadata(key, metadata);\n  }\n  deleteMetadata(key) {\n    this.memoryCache.deleteMetadata(key);\n  }\n  getAllMetadata() {\n    return this.memoryCache.getAllMetadata();\n  }\n  clearMetadata() {\n    this.memoryCache.clearMetadata();\n  }\n  getCurrentSize() {\n    return this.memoryCache.getCurrentSize();\n  }\n  getSizeLimits() {\n    return this.memoryCache.getSizeLimits();\n  }\n};\n\n// src/Options.ts\nvar DEFAULT_CACHE_OPTIONS = {\n  cacheType: \"memory\",\n  enableDebugLogging: false,\n  autoSync: true,\n  maxRetries: 3,\n  retryDelay: 1e3,\n  indexedDBConfig: {\n    dbName: \"fjell-cache\",\n    version: 1,\n    storeName: \"cache\",\n    size: {\n      evictionPolicy: \"lru\"\n    }\n  },\n  webStorageConfig: {\n    keyPrefix: \"fjell-cache:\",\n    compress: false,\n    size: {\n      evictionPolicy: \"lru\"\n    }\n  },\n  memoryConfig: {\n    // No limits by default\n    size: {\n      evictionPolicy: \"lru\"\n    }\n  }\n};\nvar createOptions = (cacheOptions) => {\n  const indexedDBConfig = cacheOptions?.indexedDBConfig ? {\n    ...DEFAULT_CACHE_OPTIONS.indexedDBConfig,\n    ...cacheOptions.indexedDBConfig,\n    size: cacheOptions.indexedDBConfig.size ? {\n      ...DEFAULT_CACHE_OPTIONS.indexedDBConfig?.size,\n      ...cacheOptions.indexedDBConfig.size\n    } : DEFAULT_CACHE_OPTIONS.indexedDBConfig?.size\n  } : { ...DEFAULT_CACHE_OPTIONS.indexedDBConfig };\n  const webStorageConfig = cacheOptions?.webStorageConfig ? {\n    ...DEFAULT_CACHE_OPTIONS.webStorageConfig,\n    ...cacheOptions.webStorageConfig,\n    size: cacheOptions.webStorageConfig.size ? {\n      ...DEFAULT_CACHE_OPTIONS.webStorageConfig?.size,\n      ...cacheOptions.webStorageConfig.size\n    } : DEFAULT_CACHE_OPTIONS.webStorageConfig?.size\n  } : { ...DEFAULT_CACHE_OPTIONS.webStorageConfig };\n  const memoryConfig = cacheOptions?.memoryConfig ? {\n    ...DEFAULT_CACHE_OPTIONS.memoryConfig,\n    ...cacheOptions.memoryConfig,\n    size: cacheOptions.memoryConfig.size ? {\n      ...DEFAULT_CACHE_OPTIONS.memoryConfig?.size,\n      ...cacheOptions.memoryConfig.size\n    } : DEFAULT_CACHE_OPTIONS.memoryConfig?.size\n  } : { ...DEFAULT_CACHE_OPTIONS.memoryConfig };\n  return {\n    ...DEFAULT_CACHE_OPTIONS,\n    ...cacheOptions,\n    indexedDBConfig,\n    webStorageConfig,\n    memoryConfig\n  };\n};\nvar createCacheMap = (kta, options) => {\n  switch (options.cacheType) {\n    case \"memory\":\n      if (options.memoryConfig?.size && (options.memoryConfig.size.maxSizeBytes || options.memoryConfig.size.maxItems)) {\n        const sizeConfig = {\n          maxSizeBytes: options.memoryConfig.size.maxSizeBytes,\n          maxItems: options.memoryConfig.size.maxItems\n        };\n        return new EnhancedMemoryCacheMap(\n          kta,\n          sizeConfig\n        );\n      }\n      return new MemoryCacheMap(kta);\n    case \"localStorage\":\n      return new LocalStorageCacheMap(\n        kta,\n        options.webStorageConfig?.keyPrefix\n      );\n    case \"sessionStorage\":\n      return new SessionStorageCacheMap(\n        kta,\n        options.webStorageConfig?.keyPrefix\n      );\n    case \"indexedDB\":\n      return new IndexDBCacheMap(\n        kta,\n        options.indexedDBConfig?.dbName,\n        options.indexedDBConfig?.storeName,\n        options.indexedDBConfig?.version\n      );\n    case \"custom\":\n      if (!options.customCacheMapFactory) {\n        throw new Error('Custom cache map factory is required when cacheType is \"custom\"');\n      }\n      return options.customCacheMapFactory(kta);\n    default:\n      throw new Error(`Unsupported cache type: ${options.cacheType}`);\n  }\n};\nvar validateOptions = (options) => {\n  if (options.cacheType === \"custom\" && !options.customCacheMapFactory) {\n    throw new Error('customCacheMapFactory is required when cacheType is \"custom\"');\n  }\n  if (typeof options.maxRetries === \"number\" && options.maxRetries < 0) {\n    throw new Error(\"maxRetries must be non-negative\");\n  }\n  if (typeof options.retryDelay === \"number\" && options.retryDelay < 0) {\n    throw new Error(\"retryDelay must be non-negative\");\n  }\n  if (typeof options.ttl === \"number\" && options.ttl <= 0) {\n    throw new Error(\"ttl must be positive\");\n  }\n  if (typeof options.memoryConfig?.maxItems === \"number\" && options.memoryConfig.maxItems <= 0) {\n    throw new Error(\"memoryConfig.maxItems must be positive\");\n  }\n  if (options.memoryConfig?.size) {\n    validateSizeConfig(options.memoryConfig.size);\n  }\n  if (options.webStorageConfig?.size) {\n    validateSizeConfig(options.webStorageConfig.size);\n  }\n  if (options.indexedDBConfig?.size) {\n    validateSizeConfig(options.indexedDBConfig.size);\n  }\n  if ([\"localStorage\", \"sessionStorage\"].includes(options.cacheType)) {\n    const isRealBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement === \"function\";\n    if (!isRealBrowser) {\n      throw new Error(`${options.cacheType} is not available in non-browser environments`);\n    }\n  }\n  if (options.cacheType === \"indexedDB\") {\n    if (typeof window === \"undefined\" || !window.indexedDB) {\n      throw new Error(`${options.cacheType} is not available in this environment`);\n    }\n  }\n  if (options.cacheType === \"asyncIndexedDB\") {\n    throw new Error(\"asyncIndexedDB cannot be used with synchronous cache factory. Use AsyncIndexDBCacheMap directly for async operations.\");\n  }\n};\n\n// src/ops/reset.ts\nvar reset = async (coordinate, options) => {\n  try {\n    validateOptions(options);\n    const cacheMap = createCacheMap(coordinate.kta, options);\n    return [cacheMap];\n  } catch (error) {\n    throw error;\n  }\n};\n\n// src/Operations.ts\nvar createOperations = (api, coordinate, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager) => {\n  const context = createCacheContext(api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager);\n  return {\n    all: (query, locations) => all(query, locations, context).then(([ctx, result]) => result),\n    one: (query, locations) => one(query, locations, context).then(([ctx, result]) => result),\n    create: (item, locations) => create(item, locations, context).then(([ctx, result]) => result),\n    get: (key) => get(key, context).then(([ctx, result]) => result),\n    retrieve: (key) => retrieve(key, context).then(([ctx, result]) => result),\n    remove: (key) => remove(key, context).then((ctx) => void 0),\n    update: (key, item) => update(key, item, context).then(([ctx, result]) => result),\n    action: (key, actionName, body) => action(key, actionName, body, context).then(([ctx, result]) => result),\n    allAction: (actionName, body, locations) => allAction(actionName, body, locations, context).then(([ctx, result]) => result),\n    facet: (key, facetName, params) => facet(key, facetName, params, context).then((result) => result),\n    allFacet: (facetName, params, locations) => allFacet(facetName, params, locations, context).then((result) => result),\n    find: (finder, params, locations) => find(finder, params, locations, context).then(([ctx, result]) => result),\n    findOne: (finder, params, locations) => findOne(finder, params, locations, context).then(([ctx, result]) => result),\n    set: (key, item) => set(key, item, context).then(([ctx, result]) => result),\n    reset: () => reset(coordinate, options).then(() => void 0)\n  };\n};\n\n// src/eviction/EvictionManager.ts\nvar logger20 = logger_default.get(\"EvictionManager\");\nvar EvictionManager = class {\n  evictionStrategy;\n  constructor(evictionStrategy) {\n    this.evictionStrategy = evictionStrategy || null;\n  }\n  /**\n   * Set or update the eviction strategy\n   * @param strategy - The eviction strategy to use\n   */\n  setEvictionStrategy(strategy) {\n    this.evictionStrategy = strategy;\n    logger20.debug(\"Eviction strategy updated\", {\n      strategy: strategy?.getStrategyName() || \"none\"\n    });\n  }\n  /**\n   * Get the current eviction strategy name\n   * @returns Strategy name or null if no eviction\n   */\n  getEvictionStrategyName() {\n    return this.evictionStrategy?.getStrategyName() || null;\n  }\n  /**\n   * Handle item access - update metadata for eviction strategy\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */\n  onItemAccessed(key, metadataProvider) {\n    if (!this.evictionStrategy) {\n      return;\n    }\n    try {\n      this.evictionStrategy.onItemAccessed(key, metadataProvider);\n    } catch (error) {\n      logger20.error(\"Error in eviction strategy onItemAccessed\", { key, error });\n    }\n  }\n  /**\n   * Handle item addition - update metadata and perform eviction if needed\n   * @param key - Item key\n   * @param value - Item value (for size estimation)\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */\n  onItemAdded(key, value, metadataProvider) {\n    const evictedKeys = [];\n    if (!this.evictionStrategy) {\n      return evictedKeys;\n    }\n    try {\n      const estimatedSize = estimateValueSize(value);\n      const context = this.createEvictionContext(metadataProvider, estimatedSize);\n      const keysToEvict = this.evictionStrategy.selectForEviction(metadataProvider, context);\n      for (const evictKey of keysToEvict) {\n        this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n        evictedKeys.push(evictKey);\n      }\n      this.evictionStrategy.onItemAdded(key, estimatedSize, metadataProvider);\n      if (evictedKeys.length > 0) {\n        logger20.debug(\"Items evicted during addition\", {\n          newKey: key,\n          evictedKeys,\n          strategy: this.evictionStrategy.getStrategyName()\n        });\n      }\n    } catch (error) {\n      logger20.error(\"Error in eviction strategy onItemAdded\", { key, error });\n    }\n    return evictedKeys;\n  }\n  /**\n   * Handle item removal - clean up metadata\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */\n  onItemRemoved(key, metadataProvider) {\n    if (!this.evictionStrategy) {\n      return;\n    }\n    try {\n      this.evictionStrategy.onItemRemoved(key, metadataProvider);\n    } catch (error) {\n      logger20.error(\"Error in eviction strategy onItemRemoved\", { key, error });\n    }\n  }\n  /**\n   * Perform manual eviction check\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */\n  performEviction(metadataProvider) {\n    const evictedKeys = [];\n    if (!this.evictionStrategy) {\n      return evictedKeys;\n    }\n    try {\n      const context = this.createEvictionContext(metadataProvider);\n      const keysToEvict = this.evictionStrategy.selectForEviction(metadataProvider, context);\n      for (const evictKey of keysToEvict) {\n        this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n        evictedKeys.push(evictKey);\n      }\n      if (evictedKeys.length > 0) {\n        logger20.debug(\"Manual eviction performed\", {\n          evictedKeys,\n          strategy: this.evictionStrategy.getStrategyName()\n        });\n      }\n    } catch (error) {\n      logger20.error(\"Error in manual eviction\", { error });\n    }\n    return evictedKeys;\n  }\n  /**\n   * Check if eviction is supported (i.e., strategy is set)\n   * @returns True if eviction is supported\n   */\n  isEvictionSupported() {\n    return this.evictionStrategy !== null;\n  }\n  /**\n   * Create eviction context from current cache state\n   * @param metadataProvider - Cache metadata provider\n   * @param newItemSize - Size of item being added (optional)\n   * @returns Eviction context\n   */\n  createEvictionContext(metadataProvider, newItemSize) {\n    const currentSize = metadataProvider.getCurrentSize();\n    const limits = metadataProvider.getSizeLimits();\n    return {\n      currentSize,\n      limits,\n      newItemSize\n    };\n  }\n};\n\n// src/eviction/EvictionStrategyConfig.ts\nvar DEFAULT_LFU_CONFIG = {\n  type: \"lfu\",\n  decayFactor: 0.1,\n  decayInterval: 6e4,\n  // 1 minute\n  sketchWidth: 1024,\n  sketchDepth: 4,\n  useProbabilisticCounting: true,\n  minFrequencyThreshold: 1\n};\nvar DEFAULT_ARC_CONFIG = {\n  type: \"arc\",\n  maxCacheSize: 1e3,\n  frequencyThreshold: 2,\n  useEnhancedFrequency: true,\n  frequencyDecayFactor: 0.05,\n  frequencyDecayInterval: 6e5,\n  // 10 minutes\n  useFrequencyWeightedSelection: true,\n  adaptiveLearningRate: 1\n};\nvar DEFAULT_TWO_QUEUE_CONFIG = {\n  type: \"2q\",\n  maxCacheSize: 1e3,\n  useFrequencyPromotion: true,\n  promotionThreshold: 2,\n  hotQueueDecayFactor: 0.05,\n  hotQueueDecayInterval: 3e5,\n  // 5 minutes\n  useFrequencyWeightedLRU: true\n};\n\n// src/eviction/EvictionStrategy.ts\nvar EvictionStrategy = class {\n  /**\n   * Determine if eviction is needed based on current context\n   * @param context - Current cache state and limits\n   * @returns True if eviction should occur\n   */\n  isEvictionNeeded(context) {\n    const { currentSize, limits, newItemSize = 0 } = context;\n    if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n      return true;\n    }\n    if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Calculate how many items need to be evicted\n   * @param context - Current cache state and limits\n   * @returns Number of items that should be evicted\n   */\n  calculateEvictionCount(context) {\n    const { currentSize, limits, newItemSize = 0 } = context;\n    let evictionCount = 0;\n    if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n      evictionCount = Math.max(evictionCount, currentSize.itemCount - limits.maxItems + 1);\n    }\n    if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n      const excessBytes = currentSize.sizeBytes + newItemSize - limits.maxSizeBytes;\n      const avgItemSize = currentSize.itemCount > 0 ? currentSize.sizeBytes / currentSize.itemCount : 1024;\n      const estimatedEvictionCount = Math.ceil(excessBytes / avgItemSize);\n      evictionCount = Math.max(evictionCount, estimatedEvictionCount);\n    }\n    return evictionCount;\n  }\n};\n\n// src/eviction/strategies/LRUEvictionStrategy.ts\nvar LRUEvictionStrategy = class extends EvictionStrategy {\n  selectForEviction(metadataProvider, context) {\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    const keysToEvict = [];\n    const sortedEntries = Array.from(allMetadata.entries()).sort(([, a], [, b]) => a.lastAccessedAt - b.lastAccessedAt);\n    for (let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++) {\n      keysToEvict.push(sortedEntries[i][0]);\n    }\n    return keysToEvict;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata) {\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadataProvider.setMetadata(key, metadata);\n    }\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  getStrategyName() {\n    return \"lru\";\n  }\n};\n\n// src/eviction/EvictionStrategyValidation.ts\nfunction validateNumberRange(value, min, max, fieldName) {\n  if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n    throw new Error(`${fieldName} must be a finite number`);\n  }\n  if (value < min || value > max) {\n    throw new Error(`${fieldName} must be between ${min} and ${max}, got ${value}`);\n  }\n}\nfunction validatePositiveInteger(value, fieldName) {\n  if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n    throw new Error(`${fieldName} must be a finite number`);\n  }\n  if (!Number.isInteger(value) || value <= 0) {\n    throw new Error(`${fieldName} must be a positive integer, got ${value}`);\n  }\n}\nfunction sanitizeLFUConfig(config) {\n  const sanitized = { ...config };\n  if (typeof sanitized.decayFactor === \"number\") {\n    if (sanitized.decayFactor < 0) {\n      console.warn(`decayFactor must be between 0 and 1, got ${sanitized.decayFactor}. Correcting to 0.`);\n      sanitized.decayFactor = 0;\n    } else if (sanitized.decayFactor > 1) {\n      console.warn(`decayFactor must be between 0 and 1, got ${sanitized.decayFactor}. Correcting to 1.`);\n      sanitized.decayFactor = 1;\n    }\n  }\n  if (typeof sanitized.decayInterval === \"number\" && sanitized.decayInterval <= 0) {\n    console.warn(`decayInterval must be positive, got ${sanitized.decayInterval}. Correcting to 300000.`);\n    sanitized.decayInterval = 3e5;\n  }\n  if (typeof sanitized.sketchWidth === \"number\") {\n    if (sanitized.sketchWidth <= 0) {\n      console.warn(`sketchWidth must be positive, got ${sanitized.sketchWidth}. Correcting to 1024.`);\n      sanitized.sketchWidth = 1024;\n    } else if (sanitized.sketchWidth < 16) {\n      console.warn(`sketchWidth should be at least 16 for optimal performance, got ${sanitized.sketchWidth}. Correcting to 16.`);\n      sanitized.sketchWidth = 16;\n    } else if (sanitized.sketchWidth > 65536) {\n      console.warn(`sketchWidth should not exceed 65536 for optimal performance, got ${sanitized.sketchWidth}. Correcting to 65536.`);\n      sanitized.sketchWidth = 65536;\n    }\n  }\n  if (typeof sanitized.sketchDepth === \"number\") {\n    if (sanitized.sketchDepth <= 0) {\n      console.warn(`sketchDepth must be positive, got ${sanitized.sketchDepth}. Correcting to 4.`);\n      sanitized.sketchDepth = 4;\n    } else if (sanitized.sketchDepth < 1) {\n      console.warn(`sketchDepth should be at least 1 for optimal accuracy, got ${sanitized.sketchDepth}. Correcting to 1.`);\n      sanitized.sketchDepth = 1;\n    } else if (sanitized.sketchDepth > 16) {\n      console.warn(`sketchDepth should not exceed 16 for optimal accuracy, got ${sanitized.sketchDepth}. Correcting to 16.`);\n      sanitized.sketchDepth = 16;\n    }\n  }\n  if (typeof sanitized.minFrequencyThreshold === \"number\" && sanitized.minFrequencyThreshold <= 0) {\n    console.warn(`minFrequencyThreshold must be positive, got ${sanitized.minFrequencyThreshold}. Correcting to 1.`);\n    sanitized.minFrequencyThreshold = 1;\n  }\n  return sanitized;\n}\nfunction validateLFUConfig(config) {\n  if (typeof config.decayFactor === \"number\") {\n    validateNumberRange(config.decayFactor, 0, 1, \"decayFactor\");\n  }\n  if (typeof config.decayInterval === \"number\") {\n    validatePositiveInteger(config.decayInterval, \"decayInterval\");\n  }\n  if (typeof config.sketchWidth === \"number\") {\n    validatePositiveInteger(config.sketchWidth, \"sketchWidth\");\n    if (config.sketchWidth < 16 || config.sketchWidth > 65536) {\n      throw new Error(`sketchWidth must be between 16 and 65536, got ${config.sketchWidth}`);\n    }\n  }\n  if (typeof config.sketchDepth === \"number\") {\n    validatePositiveInteger(config.sketchDepth, \"sketchDepth\");\n    if (config.sketchDepth < 1 || config.sketchDepth > 16) {\n      throw new Error(`sketchDepth must be between 1 and 16, got ${config.sketchDepth}`);\n    }\n  }\n  if (typeof config.minFrequencyThreshold === \"number\") {\n    validatePositiveInteger(config.minFrequencyThreshold, \"minFrequencyThreshold\");\n  }\n}\nfunction sanitizeARCConfig(config) {\n  const sanitized = { ...config };\n  if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n    console.warn(`maxCacheSize must be positive, got ${sanitized.maxCacheSize}. Correcting to 1000.`);\n    sanitized.maxCacheSize = 1e3;\n  }\n  if (typeof sanitized.frequencyThreshold === \"number\" && sanitized.frequencyThreshold <= 0) {\n    console.warn(`frequencyThreshold must be positive, got ${sanitized.frequencyThreshold}. Correcting to 2.`);\n    sanitized.frequencyThreshold = 2;\n  }\n  if (typeof sanitized.frequencyDecayFactor === \"number\") {\n    if (sanitized.frequencyDecayFactor < 0) {\n      console.warn(`frequencyDecayFactor must be between 0 and 1, got ${sanitized.frequencyDecayFactor}. Correcting to 0.`);\n      sanitized.frequencyDecayFactor = 0;\n    } else if (sanitized.frequencyDecayFactor > 1) {\n      console.warn(`frequencyDecayFactor must be between 0 and 1, got ${sanitized.frequencyDecayFactor}. Correcting to 1.`);\n      sanitized.frequencyDecayFactor = 1;\n    }\n  }\n  if (typeof sanitized.frequencyDecayInterval === \"number\" && sanitized.frequencyDecayInterval <= 0) {\n    console.warn(`frequencyDecayInterval must be positive, got ${sanitized.frequencyDecayInterval}. Correcting to 60000.`);\n    sanitized.frequencyDecayInterval = 6e4;\n  }\n  if (typeof sanitized.adaptiveLearningRate === \"number\") {\n    if (sanitized.adaptiveLearningRate < 0) {\n      console.warn(`adaptiveLearningRate must be between 0 and 10, got ${sanitized.adaptiveLearningRate}. Correcting to 0.`);\n      sanitized.adaptiveLearningRate = 0;\n    } else if (sanitized.adaptiveLearningRate > 10) {\n      console.warn(`adaptiveLearningRate must be between 0 and 10, got ${sanitized.adaptiveLearningRate}. Correcting to 10.`);\n      sanitized.adaptiveLearningRate = 10;\n    }\n  }\n  return sanitized;\n}\nfunction validateARCConfig(config) {\n  if (typeof config.maxCacheSize === \"number\") {\n    validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n  }\n  if (typeof config.frequencyThreshold === \"number\") {\n    validatePositiveInteger(config.frequencyThreshold, \"frequencyThreshold\");\n  }\n  if (typeof config.frequencyDecayFactor === \"number\") {\n    validateNumberRange(config.frequencyDecayFactor, 0, 1, \"frequencyDecayFactor\");\n  }\n  if (typeof config.frequencyDecayInterval === \"number\") {\n    validatePositiveInteger(config.frequencyDecayInterval, \"frequencyDecayInterval\");\n  }\n  if (typeof config.adaptiveLearningRate === \"number\") {\n    validateNumberRange(config.adaptiveLearningRate, 0, 10, \"adaptiveLearningRate\");\n  }\n}\nfunction sanitizeTwoQueueConfig(config) {\n  const sanitized = { ...config };\n  if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n    console.warn(`maxCacheSize must be positive, got ${sanitized.maxCacheSize}. Correcting to 1000.`);\n    sanitized.maxCacheSize = 1e3;\n  }\n  if (typeof sanitized.promotionThreshold === \"number\" && sanitized.promotionThreshold <= 0) {\n    console.warn(`promotionThreshold must be positive, got ${sanitized.promotionThreshold}. Correcting to 2.`);\n    sanitized.promotionThreshold = 2;\n  }\n  if (typeof sanitized.hotQueueDecayFactor === \"number\") {\n    if (sanitized.hotQueueDecayFactor < 0) {\n      console.warn(`hotQueueDecayFactor must be between 0 and 1, got ${sanitized.hotQueueDecayFactor}. Correcting to 0.`);\n      sanitized.hotQueueDecayFactor = 0;\n    } else if (sanitized.hotQueueDecayFactor > 1) {\n      console.warn(`hotQueueDecayFactor must be between 0 and 1, got ${sanitized.hotQueueDecayFactor}. Correcting to 1.`);\n      sanitized.hotQueueDecayFactor = 1;\n    }\n  }\n  if (typeof sanitized.hotQueueDecayInterval === \"number\" && sanitized.hotQueueDecayInterval <= 0) {\n    console.warn(`hotQueueDecayInterval must be positive, got ${sanitized.hotQueueDecayInterval}. Correcting to 300000.`);\n    sanitized.hotQueueDecayInterval = 3e5;\n  }\n  return sanitized;\n}\nfunction validateTwoQueueConfig(config) {\n  if (typeof config.maxCacheSize === \"number\") {\n    validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n  }\n  if (typeof config.promotionThreshold === \"number\") {\n    validatePositiveInteger(config.promotionThreshold, \"promotionThreshold\");\n  }\n  if (typeof config.hotQueueDecayFactor === \"number\") {\n    validateNumberRange(config.hotQueueDecayFactor, 0, 1, \"hotQueueDecayFactor\");\n  }\n  if (typeof config.hotQueueDecayInterval === \"number\") {\n    validatePositiveInteger(config.hotQueueDecayInterval, \"hotQueueDecayInterval\");\n  }\n}\nfunction validateEvictionStrategyConfig(config) {\n  if (!config || typeof config !== \"object\") {\n    throw new Error(\"Configuration must be a non-null object\");\n  }\n  if (!config.type) {\n    throw new Error(\"Configuration must specify a type\");\n  }\n  const validTypes = [\"lfu\", \"lru\", \"fifo\", \"mru\", \"random\", \"arc\", \"2q\"];\n  if (!validTypes.includes(config.type)) {\n    throw new Error(`Invalid eviction strategy type: ${config.type}. Must be one of: ${validTypes.join(\", \")}`);\n  }\n  switch (config.type) {\n    case \"lfu\":\n      validateLFUConfig(config);\n      break;\n    case \"arc\":\n      validateARCConfig(config);\n      break;\n    case \"2q\":\n      validateTwoQueueConfig(config);\n      break;\n    case \"lru\":\n    case \"fifo\":\n    case \"mru\":\n    case \"random\":\n      break;\n    default:\n      throw new Error(`Unsupported eviction strategy type: ${config.type}`);\n  }\n}\nfunction sanitizeConfigByType(config) {\n  if (!config.type) {\n    return config;\n  }\n  switch (config.type) {\n    case \"lfu\":\n      return sanitizeLFUConfig(config);\n    case \"arc\":\n      return sanitizeARCConfig(config);\n    case \"2q\":\n      return sanitizeTwoQueueConfig(config);\n    case \"lru\":\n    case \"fifo\":\n    case \"mru\":\n    case \"random\":\n      return config;\n    default:\n      return config;\n  }\n}\nfunction createValidatedConfig(baseConfig, userConfig) {\n  const mergedConfig = { ...baseConfig, ...userConfig };\n  const sanitizedConfig = sanitizeConfigByType(mergedConfig);\n  validateEvictionStrategyConfig(sanitizedConfig);\n  return sanitizedConfig;\n}\n\n// src/eviction/strategies/LFUEvictionStrategy.ts\nfunction fnv1aHash(key, seed) {\n  const FNV_OFFSET_BASIS = 2166136261;\n  const FNV_PRIME = 16777619;\n  let hash = (FNV_OFFSET_BASIS ^ seed) >>> 0;\n  for (let i = 0; i < key.length; i++) {\n    hash ^= key.charCodeAt(i);\n    hash = hash * FNV_PRIME >>> 0;\n  }\n  hash ^= hash >>> 16;\n  hash = hash * 2246822507 >>> 0;\n  hash ^= hash >>> 13;\n  hash = hash * 3266489909 >>> 0;\n  hash ^= hash >>> 16;\n  return hash >>> 0;\n}\nvar CountMinSketch = class {\n  sketches;\n  width;\n  depth;\n  seeds;\n  constructor(width = 1024, depth = 4) {\n    this.width = width;\n    this.depth = depth;\n    this.sketches = Array(depth).fill(null).map(() => new Array(width).fill(0));\n    this.seeds = Array(depth).fill(null).map(() => Math.floor(Math.random() * 1e6));\n  }\n  /**\n   * Check if a number is a power of 2 for optimized bit masking\n   */\n  isPowerOfTwo(n) {\n    return n > 0 && (n & n - 1) === 0;\n  }\n  /**\n   * Increment the frequency count for a key\n   */\n  increment(key) {\n    for (let i = 0; i < this.depth; i++) {\n      const hash = fnv1aHash(key, this.seeds[i]);\n      const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n      this.sketches[i][index]++;\n    }\n  }\n  /**\n   * Estimate the frequency count for a key\n   */\n  estimate(key) {\n    let minCount = Infinity;\n    for (let i = 0; i < this.depth; i++) {\n      const hash = fnv1aHash(key, this.seeds[i]);\n      const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n      minCount = Math.min(minCount, this.sketches[i][index]);\n    }\n    return minCount === Infinity ? 0 : minCount;\n  }\n  /**\n   * Apply decay to all frequencies\n   */\n  decay(factor) {\n    for (let i = 0; i < this.depth; i++) {\n      for (let j = 0; j < this.width; j++) {\n        this.sketches[i][j] = Math.floor(this.sketches[i][j] * (1 - factor));\n      }\n    }\n  }\n  /**\n   * Reset all frequencies to zero\n   */\n  reset() {\n    for (let i = 0; i < this.depth; i++) {\n      for (let j = 0; j < this.width; j++) {\n        this.sketches[i][j] = 0;\n      }\n    }\n  }\n};\nvar LFUEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"lfu\";\n  }\n  config;\n  sketch;\n  lastDecayTime;\n  constructor(config = {}) {\n    super();\n    const defaultBackwardsCompatible = {\n      useProbabilisticCounting: false,\n      decayFactor: 0,\n      decayInterval: Number.MAX_SAFE_INTEGER\n    };\n    const baseConfig = { ...DEFAULT_LFU_CONFIG, ...defaultBackwardsCompatible };\n    this.config = createValidatedConfig(baseConfig, config);\n    this.sketch = this.config.useProbabilisticCounting ? new CountMinSketch(this.config.sketchWidth, this.config.sketchDepth) : null;\n    this.lastDecayTime = Date.now();\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    this.applyPeriodicDecay();\n    const sortedEntries = Array.from(allMetadata.entries()).sort((a, b) => {\n      const freqA = this.getEffectiveFrequency(a[0], a[1]);\n      const freqB = this.getEffectiveFrequency(b[0], b[1]);\n      if (freqA !== freqB) {\n        return freqA - freqB;\n      }\n      return a[1].lastAccessedAt - b[1].lastAccessedAt;\n    });\n    return sortedEntries.slice(0, evictionCount).map(([key]) => key);\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    const now = Date.now();\n    metadata.lastAccessedAt = now;\n    metadata.accessCount++;\n    if (this.sketch) {\n      this.sketch.increment(key);\n      metadata.rawFrequency = this.sketch.estimate(key);\n    } else {\n      metadata.rawFrequency = metadata.accessCount;\n    }\n    metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n    metadata.lastFrequencyUpdate = now;\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize,\n      rawFrequency: 1\n    };\n    metadata.frequencyScore = 1;\n    metadata.lastFrequencyUpdate = now;\n    if (this.sketch) {\n      this.sketch.increment(key);\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  /**\n   * Get the effective frequency for an item, applying real-time decay if needed\n   */\n  getEffectiveFrequency(_key, metadata) {\n    if ((this.config.decayFactor ?? 0) === 0) {\n      return metadata.rawFrequency || metadata.accessCount;\n    }\n    const now = Date.now();\n    if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n      const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n      const decayAmount = timeSinceUpdate / (this.config.decayInterval ?? 6e4) * (this.config.decayFactor ?? 0.1);\n      return Math.max(this.config.minFrequencyThreshold ?? 1, metadata.frequencyScore * (1 - decayAmount));\n    }\n    return metadata.rawFrequency || metadata.accessCount;\n  }\n  /**\n   * Calculate frequency score with decay applied\n   */\n  calculateFrequencyScore(metadata, currentTime) {\n    const rawFreq = metadata.rawFrequency || metadata.accessCount;\n    if ((this.config.decayFactor ?? 0) === 0) {\n      return rawFreq;\n    }\n    if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n      return rawFreq;\n    }\n    const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n    const decayAmount = timeSinceUpdate / (this.config.decayInterval ?? 6e4) * (this.config.decayFactor ?? 0.1);\n    const previousScore = metadata.frequencyScore || rawFreq;\n    const decayedScore = previousScore * (1 - decayAmount);\n    return Math.max(this.config.minFrequencyThreshold ?? 1, decayedScore + 1);\n  }\n  /**\n   * Apply periodic decay to the frequency sketch and metadata\n   */\n  applyPeriodicDecay() {\n    if ((this.config.decayFactor ?? 0) === 0) return;\n    const now = Date.now();\n    const timeSinceDecay = now - this.lastDecayTime;\n    if (timeSinceDecay >= (this.config.decayInterval ?? 6e4)) {\n      if (this.sketch) {\n        this.sketch.decay(this.config.decayFactor ?? 0.1);\n      }\n      this.lastDecayTime = now;\n    }\n  }\n  /**\n   * Get configuration for this strategy\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n  /**\n   * Reset frequency tracking (useful for testing or cache clearing)\n   */\n  reset() {\n    if (this.sketch) {\n      this.sketch.reset();\n    }\n    this.lastDecayTime = Date.now();\n  }\n};\n\n// src/eviction/strategies/FIFOEvictionStrategy.ts\nvar FIFOEvictionStrategy = class extends EvictionStrategy {\n  selectForEviction(metadataProvider, context) {\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    const keysToEvict = [];\n    const sortedEntries = Array.from(allMetadata.entries()).sort(([, a], [, b]) => a.addedAt - b.addedAt);\n    for (let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++) {\n      keysToEvict.push(sortedEntries[i][0]);\n    }\n    return keysToEvict;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata) {\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadataProvider.setMetadata(key, metadata);\n    }\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  getStrategyName() {\n    return \"fifo\";\n  }\n};\n\n// src/eviction/strategies/MRUEvictionStrategy.ts\nvar MRUEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"MRU\";\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    const sortedEntries = Array.from(allMetadata.entries()).sort((a, b) => {\n      return b[1].lastAccessedAt - a[1].lastAccessedAt;\n    });\n    return sortedEntries.slice(0, evictionCount).map(([key]) => key);\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    metadata.lastAccessedAt = Date.now();\n    metadata.accessCount++;\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n};\n\n// src/eviction/strategies/RandomEvictionStrategy.ts\nvar RandomEvictionStrategy = class extends EvictionStrategy {\n  selectForEviction(metadataProvider, context) {\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    const keys = Array.from(allMetadata.keys());\n    const keysToEvict = [];\n    const availableKeys = [...keys];\n    for (let i = 0; i < Math.min(evictionCount, availableKeys.length); i++) {\n      const randomIndex = Math.floor(Math.random() * availableKeys.length);\n      keysToEvict.push(availableKeys.splice(randomIndex, 1)[0]);\n    }\n    return keysToEvict;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata) {\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadataProvider.setMetadata(key, metadata);\n    }\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  getStrategyName() {\n    return \"random\";\n  }\n};\n\n// src/eviction/strategies/ARCEvictionStrategy.ts\nvar ARCEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"ARC\";\n  }\n  recentGhosts = /* @__PURE__ */ new Set();\n  // T1 ghost entries\n  frequentGhosts = /* @__PURE__ */ new Set();\n  // T2 ghost entries\n  targetRecentSize = 0;\n  // Target size for T1 (recent entries)\n  config;\n  maxGhostSize;\n  lastDecayTime;\n  constructor(maxCacheSize = 1e3, config = {}) {\n    super();\n    const baseConfig = { ...DEFAULT_ARC_CONFIG, maxCacheSize };\n    this.config = createValidatedConfig(baseConfig, config);\n    this.maxGhostSize = this.config.maxCacheSize;\n    this.lastDecayTime = Date.now();\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    this.applyPeriodicDecay(allMetadata);\n    const recentItems = /* @__PURE__ */ new Map();\n    const frequentItems = /* @__PURE__ */ new Map();\n    for (const [key, metadata] of allMetadata) {\n      if (this.isFrequentItem(metadata)) {\n        frequentItems.set(key, metadata);\n      } else {\n        recentItems.set(key, metadata);\n      }\n    }\n    const keysToEvict = [];\n    const totalItems = recentItems.size + frequentItems.size;\n    const maxIterations = Math.min(evictionCount, totalItems);\n    for (let i = 0; i < maxIterations; i++) {\n      let keyToEvict = null;\n      let sourceList = null;\n      if (recentItems.size > this.targetRecentSize && recentItems.size > 0) {\n        keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n        sourceList = recentItems;\n      } else if (frequentItems.size > 0) {\n        keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(frequentItems, \"frequent\") : this.selectLRUFromItems(frequentItems);\n        sourceList = frequentItems;\n      } else if (recentItems.size > 0) {\n        keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n        sourceList = recentItems;\n      }\n      if (keyToEvict && sourceList) {\n        keysToEvict.push(keyToEvict);\n        sourceList.delete(keyToEvict);\n      } else {\n        break;\n      }\n      if (recentItems.size === 0 && frequentItems.size === 0) {\n        break;\n      }\n    }\n    return keysToEvict;\n  }\n  selectLRUFromItems(items) {\n    if (items.size === 0) {\n      return null;\n    }\n    let oldestKey = null;\n    let oldestTime = Infinity;\n    const now = Date.now();\n    for (const [key, metadata] of items) {\n      if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n        continue;\n      }\n      if (metadata.lastAccessedAt < oldestTime) {\n        oldestTime = metadata.lastAccessedAt;\n        oldestKey = key;\n      }\n    }\n    if (oldestKey !== null) {\n      return oldestKey;\n    }\n    if (items.size > 0) {\n      const firstKey = items.keys().next().value;\n      return firstKey ?? null;\n    }\n    return null;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    const now = Date.now();\n    const updatedMetadata = {\n      ...metadata,\n      lastAccessedAt: now,\n      accessCount: metadata.accessCount + 1\n    };\n    updatedMetadata.rawFrequency = updatedMetadata.accessCount;\n    if (this.config.useEnhancedFrequency && (this.config.frequencyDecayFactor ?? 0) > 0) {\n      updatedMetadata.frequencyScore = this.calculateFrequencyScore(updatedMetadata, now);\n      updatedMetadata.lastFrequencyUpdate = now;\n    }\n    const learningRate = this.config.adaptiveLearningRate ?? 1;\n    let targetAdjusted = false;\n    if (learningRate > 0) {\n      if (this.recentGhosts.has(key)) {\n        const adjustment = Math.max(1, Math.ceil(learningRate));\n        this.targetRecentSize = Math.min(this.targetRecentSize + adjustment, this.maxGhostSize);\n        this.recentGhosts.delete(key);\n        targetAdjusted = true;\n      } else if (this.frequentGhosts.has(key)) {\n        const adjustment = Math.max(1, Math.ceil(learningRate));\n        this.targetRecentSize = Math.max(this.targetRecentSize - adjustment, 0);\n        this.frequentGhosts.delete(key);\n        targetAdjusted = true;\n      }\n    } else {\n      if (this.recentGhosts.has(key)) {\n        this.recentGhosts.delete(key);\n      } else if (this.frequentGhosts.has(key)) {\n        this.frequentGhosts.delete(key);\n      }\n    }\n    if (targetAdjusted) {\n      this.cleanupGhostLists();\n    }\n    metadataProvider.setMetadata(key, updatedMetadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize,\n      rawFrequency: 1\n    };\n    if (this.config.useEnhancedFrequency && (this.config.frequencyDecayFactor ?? 0) > 0) {\n      metadata.frequencyScore = 1;\n      metadata.lastFrequencyUpdate = now;\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata && this.isFrequentItem(metadata)) {\n      this.addToFrequentGhosts(key);\n    } else {\n      this.addToRecentGhosts(key);\n    }\n    metadataProvider.deleteMetadata(key);\n    this.cleanupGhostLists();\n  }\n  /**\n   * Add key to recent ghost list with proper size management\n   */\n  addToRecentGhosts(key) {\n    this.frequentGhosts.delete(key);\n    this.recentGhosts.add(key);\n    this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n  }\n  /**\n   * Add key to frequent ghost list with proper size management\n   */\n  addToFrequentGhosts(key) {\n    this.recentGhosts.delete(key);\n    this.frequentGhosts.add(key);\n    this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n  }\n  /**\n   * Cleanup ghost lists to prevent memory leaks\n   */\n  cleanupGhostLists() {\n    this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n    this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n  }\n  /**\n   * Enforce size limit on a ghost list by removing oldest entries\n   */\n  enforceGhostListSizeLimit(ghostList, maxSize) {\n    if (maxSize <= 0) {\n      ghostList.clear();\n      return;\n    }\n    const iterator = ghostList.values();\n    while (ghostList.size > maxSize) {\n      const next = iterator.next();\n      if (next.done) {\n        break;\n      }\n      ghostList.delete(next.value);\n    }\n  }\n  /**\n   * Determine if an item should be classified as frequent vs recent\n   */\n  isFrequentItem(metadata) {\n    if (!this.config.useEnhancedFrequency) {\n      return metadata.accessCount > 1;\n    }\n    const frequency = this.getEffectiveFrequency(metadata);\n    return frequency >= (this.config.frequencyThreshold ?? 2);\n  }\n  /**\n   * Get effective frequency for an item, applying decay if enabled\n   */\n  getEffectiveFrequency(metadata) {\n    if (!this.config.useEnhancedFrequency || (this.config.frequencyDecayFactor ?? 0) === 0) {\n      return metadata.rawFrequency || metadata.accessCount;\n    }\n    const now = Date.now();\n    if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n      const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n      const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n      if (timeSinceUpdate > decayInterval / 10) {\n        const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * (this.config.frequencyDecayFactor ?? 0.05));\n        return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n      }\n      return metadata.frequencyScore;\n    }\n    return metadata.rawFrequency || metadata.accessCount;\n  }\n  /**\n   * Calculate frequency score with decay applied\n   */\n  calculateFrequencyScore(metadata, currentTime) {\n    const rawFreq = metadata.rawFrequency || metadata.accessCount;\n    if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n      return rawFreq;\n    }\n    const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n    const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n    const decayFactor = this.config.frequencyDecayFactor ?? 0.05;\n    const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * decayFactor);\n    const previousScore = metadata.frequencyScore || rawFreq;\n    const decayedScore = Math.max(1, previousScore * (1 - decayAmount));\n    return Math.max(1, decayedScore + 1);\n  }\n  /**\n   * Select eviction candidate using frequency-weighted approach\n   */\n  selectFrequencyWeightedFromItems(items, context) {\n    if (items.size === 0) {\n      return null;\n    }\n    let bestKey = null;\n    let bestScore = Infinity;\n    const now = Date.now();\n    for (const [key, metadata] of items) {\n      if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n        continue;\n      }\n      const frequency = this.getEffectiveFrequency(metadata);\n      const timeFactor = Math.max(0, now - metadata.lastAccessedAt);\n      let score;\n      if (context === \"recent\") {\n        score = timeFactor + 1e3 / Math.max(1, frequency);\n      } else if (context === \"frequent\") {\n        score = timeFactor / 1e3 + 10 / Math.max(1, frequency);\n      } else {\n        score = timeFactor / 1e3 / Math.max(1, frequency);\n      }\n      if (score < bestScore) {\n        bestScore = score;\n        bestKey = key;\n      }\n    }\n    if (bestKey !== null) {\n      return bestKey;\n    }\n    if (items.size > 0) {\n      const firstKey = items.keys().next().value;\n      return firstKey ?? null;\n    }\n    return null;\n  }\n  /**\n   * Apply periodic decay to frequency scores\n   */\n  applyPeriodicDecay(items) {\n    if (!this.config.useEnhancedFrequency || (this.config.frequencyDecayFactor ?? 0) === 0) return;\n    const now = Date.now();\n    const timeSinceDecay = now - this.lastDecayTime;\n    const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n    if (timeSinceDecay >= decayInterval && items.size > 0) {\n      const decayFactor = this.config.frequencyDecayFactor ?? 0.05;\n      for (const metadata of items.values()) {\n        if (typeof metadata.frequencyScore === \"number\") {\n          const intervalsPassed = timeSinceDecay / decayInterval;\n          const totalDecay = Math.min(0.9, decayFactor * intervalsPassed);\n          const newScore = metadata.frequencyScore * (1 - totalDecay);\n          metadata.frequencyScore = Math.max(1, newScore);\n          metadata.lastFrequencyUpdate = now;\n        }\n      }\n      this.lastDecayTime = now;\n    }\n  }\n  /**\n   * Get configuration for this strategy\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n  /**\n   * Reset internal state (useful for testing)\n   */\n  reset() {\n    this.recentGhosts.clear();\n    this.frequentGhosts.clear();\n    this.targetRecentSize = 0;\n    this.lastDecayTime = Date.now();\n  }\n  /**\n   * Get current adaptive state for monitoring/debugging\n   */\n  getAdaptiveState() {\n    return {\n      targetRecentSize: this.targetRecentSize,\n      recentGhostSize: this.recentGhosts.size,\n      frequentGhostSize: this.frequentGhosts.size\n    };\n  }\n};\n\n// src/eviction/strategies/TwoQueueEvictionStrategy.ts\nvar TwoQueueEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"2Q\";\n  }\n  recentQueue = [];\n  // A1 queue for recent items\n  hotQueue = [];\n  // Am queue for hot items\n  ghostQueue = /* @__PURE__ */ new Set();\n  // A1out ghost queue\n  config;\n  maxRecentSize;\n  maxGhostSize;\n  lastDecayTime;\n  constructor(maxCacheSize = 1e3, config = {}) {\n    super();\n    const baseConfig = { ...DEFAULT_TWO_QUEUE_CONFIG, maxCacheSize };\n    this.config = createValidatedConfig(baseConfig, config);\n    this.maxRecentSize = Math.max(1, Math.floor(this.config.maxCacheSize * 0.25));\n    this.maxGhostSize = this.config.maxCacheSize;\n    this.lastDecayTime = Date.now();\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    this.applyPeriodicDecay(allMetadata);\n    const keysToEvict = [];\n    for (let i = 0; i < evictionCount; i++) {\n      let keyToEvict = null;\n      for (let j = this.recentQueue.length - 1; j >= 0; j--) {\n        const key = this.recentQueue[j];\n        if (allMetadata.has(key) && !keysToEvict.includes(key)) {\n          keyToEvict = key;\n          break;\n        }\n      }\n      if (!keyToEvict) {\n        if (this.config.useFrequencyWeightedLRU) {\n          keyToEvict = this.selectFromHotQueueFrequencyWeighted(allMetadata, keysToEvict);\n        } else {\n          keyToEvict = this.selectFromHotQueueLRU(allMetadata, keysToEvict);\n        }\n      }\n      if (keyToEvict) {\n        keysToEvict.push(keyToEvict);\n      } else {\n        break;\n      }\n    }\n    return keysToEvict;\n  }\n  /**\n   * Select eviction candidate from hot queue using traditional LRU\n   */\n  selectFromHotQueueLRU(items, excludeKeys = []) {\n    let oldestKey = null;\n    let oldestTime = Infinity;\n    for (const key of this.hotQueue) {\n      if (excludeKeys.includes(key)) continue;\n      const metadata = items.get(key);\n      if (metadata && metadata.lastAccessedAt < oldestTime) {\n        oldestTime = metadata.lastAccessedAt;\n        oldestKey = key;\n      }\n    }\n    return oldestKey || (items.size > 0 ? items.keys().next().value ?? null : null);\n  }\n  /**\n   * Select eviction candidate from hot queue using frequency-weighted LRU\n   */\n  selectFromHotQueueFrequencyWeighted(items, excludeKeys = []) {\n    let bestKey = null;\n    let lowestScore = Infinity;\n    for (const key of this.hotQueue) {\n      if (excludeKeys.includes(key)) continue;\n      const metadata = items.get(key);\n      if (!metadata) continue;\n      const frequency = this.getEffectiveFrequency(metadata);\n      const timeFactor = Date.now() - metadata.lastAccessedAt;\n      const normalizedTimeFactor = timeFactor / (1e3 * 60);\n      const score = normalizedTimeFactor / Math.max(1, frequency);\n      if (score < lowestScore) {\n        lowestScore = score;\n        bestKey = key;\n      }\n    }\n    return bestKey || (items.size > 0 ? items.keys().next().value ?? null : null);\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    const now = Date.now();\n    metadata.lastAccessedAt = now;\n    metadata.accessCount++;\n    metadata.rawFrequency = metadata.accessCount;\n    if ((this.config.hotQueueDecayFactor ?? 0) > 0) {\n      metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n      metadata.lastFrequencyUpdate = now;\n    }\n    const recentIndex = this.recentQueue.indexOf(key);\n    if (recentIndex !== -1) {\n      if (this.shouldPromoteToHotQueue(metadata)) {\n        this.recentQueue.splice(recentIndex, 1);\n        this.hotQueue.unshift(key);\n      }\n    } else {\n      const hotIndex = this.hotQueue.indexOf(key);\n      if (hotIndex !== -1) {\n        this.hotQueue.splice(hotIndex, 1);\n        this.hotQueue.unshift(key);\n      }\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    let metadata = metadataProvider.getMetadata(key);\n    if (!metadata) {\n      metadata = {\n        key,\n        addedAt: now,\n        lastAccessedAt: now,\n        accessCount: 1,\n        estimatedSize,\n        rawFrequency: 1\n      };\n      if ((this.config.hotQueueDecayFactor ?? 0) > 0) {\n        metadata.frequencyScore = 1;\n        metadata.lastFrequencyUpdate = now;\n      }\n    }\n    if (this.ghostQueue.has(key)) {\n      this.ghostQueue.delete(key);\n      this.hotQueue.unshift(key);\n    } else {\n      this.recentQueue.unshift(key);\n      if (this.recentQueue.length > this.maxRecentSize) {\n        const evicted = this.recentQueue.pop();\n        if (evicted) {\n          this.ghostQueue.add(evicted);\n        }\n      }\n    }\n    if (this.ghostQueue.size > this.maxGhostSize) {\n      const firstKey = this.ghostQueue.values().next().value;\n      if (firstKey) {\n        this.ghostQueue.delete(firstKey);\n      }\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    const recentIndex = this.recentQueue.indexOf(key);\n    if (recentIndex !== -1) {\n      this.recentQueue.splice(recentIndex, 1);\n    }\n    const hotIndex = this.hotQueue.indexOf(key);\n    if (hotIndex !== -1) {\n      this.hotQueue.splice(hotIndex, 1);\n    }\n    metadataProvider.deleteMetadata(key);\n  }\n  /**\n   * Determine if an item should be promoted from recent to hot queue\n   */\n  shouldPromoteToHotQueue(metadata) {\n    if (!this.config.useFrequencyPromotion) {\n      return metadata.accessCount >= 2;\n    }\n    const threshold = this.config.promotionThreshold ?? 2;\n    const frequency = this.getEffectiveFrequency(metadata);\n    return frequency >= threshold;\n  }\n  /**\n   * Get effective frequency for an item, applying decay if enabled\n   */\n  getEffectiveFrequency(metadata) {\n    if ((this.config.hotQueueDecayFactor ?? 0) === 0) {\n      return metadata.rawFrequency || metadata.accessCount;\n    }\n    const now = Date.now();\n    if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n      const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n      const decayAmount = timeSinceUpdate / (this.config.hotQueueDecayInterval ?? 3e5) * (this.config.hotQueueDecayFactor ?? 0.05);\n      return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n    }\n    return metadata.rawFrequency || metadata.accessCount;\n  }\n  /**\n   * Calculate frequency score with decay applied\n   */\n  calculateFrequencyScore(metadata, currentTime) {\n    const rawFreq = metadata.rawFrequency || metadata.accessCount;\n    if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n      return rawFreq;\n    }\n    const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n    const decayAmount = timeSinceUpdate / (this.config.hotQueueDecayInterval ?? 3e5) * (this.config.hotQueueDecayFactor ?? 0.05);\n    const previousScore = metadata.frequencyScore || rawFreq;\n    const decayedScore = previousScore * (1 - decayAmount);\n    return Math.max(1, decayedScore + 1);\n  }\n  /**\n   * Apply periodic decay to hot queue items\n   */\n  applyPeriodicDecay(items) {\n    if ((this.config.hotQueueDecayFactor ?? 0) === 0) return;\n    const now = Date.now();\n    const timeSinceDecay = now - this.lastDecayTime;\n    if (timeSinceDecay >= (this.config.hotQueueDecayInterval ?? 3e5)) {\n      if (this.hotQueue.length > 0) {\n        for (const key of this.hotQueue) {\n          const metadata = items.get(key);\n          if (metadata && typeof metadata.frequencyScore === \"number\") {\n            const decayAmount = this.config.hotQueueDecayFactor ?? 0.05;\n            metadata.frequencyScore = Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n          }\n        }\n        this.lastDecayTime = now;\n      }\n    }\n  }\n  /**\n   * Get configuration for this strategy\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n  /**\n   * Reset internal state (useful for testing)\n   */\n  reset() {\n    this.recentQueue = [];\n    this.hotQueue = [];\n    this.ghostQueue.clear();\n    this.lastDecayTime = Date.now();\n  }\n};\n\n// src/eviction/EvictionStrategyFactory.ts\nfunction createEvictionStrategy(policy, maxCacheSize, config) {\n  const safeMaxCacheSize = typeof maxCacheSize === \"number\" && maxCacheSize > 0 ? maxCacheSize : 1e3;\n  switch (policy) {\n    case \"lru\":\n      return new LRUEvictionStrategy();\n    case \"lfu\": {\n      try {\n        const lfuConfig = config?.type === \"lfu\" ? config : { type: \"lfu\" };\n        return new LFUEvictionStrategy(lfuConfig);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.warn(`Failed to create lfu strategy with provided configuration, falling back to LRU:`, errorMessage);\n        return new LRUEvictionStrategy();\n      }\n    }\n    case \"fifo\":\n      return new FIFOEvictionStrategy();\n    case \"mru\":\n      return new MRUEvictionStrategy();\n    case \"random\":\n      return new RandomEvictionStrategy();\n    case \"arc\": {\n      try {\n        const arcConfig = config?.type === \"arc\" ? config : { ...DEFAULT_ARC_CONFIG, maxCacheSize: safeMaxCacheSize };\n        const finalMaxSize = arcConfig.maxCacheSize && arcConfig.maxCacheSize > 0 ? arcConfig.maxCacheSize : safeMaxCacheSize;\n        return new ARCEvictionStrategy(finalMaxSize, { ...arcConfig, maxCacheSize: finalMaxSize });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.warn(`Failed to create arc strategy with provided configuration, falling back to LRU:`, errorMessage);\n        return new LRUEvictionStrategy();\n      }\n    }\n    case \"2q\": {\n      try {\n        const twoQConfig = config?.type === \"2q\" ? config : { ...DEFAULT_TWO_QUEUE_CONFIG, maxCacheSize: safeMaxCacheSize };\n        const finalMaxSize = twoQConfig.maxCacheSize && twoQConfig.maxCacheSize > 0 ? twoQConfig.maxCacheSize : safeMaxCacheSize;\n        return new TwoQueueEvictionStrategy(finalMaxSize, { ...twoQConfig, maxCacheSize: finalMaxSize });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.warn(`Failed to create 2q strategy with provided configuration, falling back to LRU:`, errorMessage);\n        return new LRUEvictionStrategy();\n      }\n    }\n    default:\n      throw new Error(`Unsupported eviction policy: ${policy}`);\n  }\n}\n\n// src/ttl/TTLManager.ts\nvar logger21 = logger_default.get(\"TTLManager\");\nvar TTLManager = class {\n  config;\n  cleanupTimer;\n  constructor(config = {}) {\n    this.config = {\n      autoCleanup: true,\n      cleanupInterval: 6e4,\n      // 1 minute default\n      validateOnAccess: true,\n      ...config\n    };\n    if (this.config.autoCleanup && this.config.cleanupInterval) {\n      this.startAutoCleanup();\n    }\n  }\n  /**\n   * Check if TTL is enabled\n   */\n  isTTLEnabled() {\n    return typeof this.config.defaultTTL === \"number\" && this.config.defaultTTL > 0;\n  }\n  /**\n   * Get the default TTL value\n   */\n  getDefaultTTL() {\n    return this.config.defaultTTL;\n  }\n  /**\n   * Update TTL configuration\n   */\n  updateConfig(config) {\n    const oldConfig = this.config;\n    this.config = { ...this.config, ...config };\n    if (oldConfig.autoCleanup !== this.config.autoCleanup || oldConfig.cleanupInterval !== this.config.cleanupInterval) {\n      this.stopAutoCleanup();\n      if (this.config.autoCleanup && this.config.cleanupInterval) {\n        this.startAutoCleanup();\n      }\n    }\n    logger21.debug(\"TTL configuration updated\", { config: this.config });\n  }\n  /**\n   * Set TTL metadata for an item when it's added\n   */\n  onItemAdded(key, metadataProvider, itemTTL) {\n    if (!this.isTTLEnabled() && !itemTTL) {\n      return;\n    }\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) {\n      logger21.warning(\"No metadata found for item when setting TTL\", { key });\n      return;\n    }\n    const ttl = itemTTL || this.config.defaultTTL;\n    if (ttl && ttl > 0) {\n      const ttlMetadata = {\n        ...metadata,\n        expiresAt: metadata.addedAt + ttl,\n        ttl\n      };\n      metadataProvider.setMetadata(key, ttlMetadata);\n      logger21.trace(\"TTL set for item\", { key, ttl, expiresAt: ttlMetadata.expiresAt });\n    }\n  }\n  /**\n   * Check if an item has expired\n   */\n  isExpired(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata || !metadata.expiresAt) {\n      return false;\n    }\n    const now = Date.now();\n    const expired = now >= metadata.expiresAt;\n    if (expired) {\n      logger21.trace(\"Item expired\", { key, expiresAt: metadata.expiresAt, now });\n    }\n    return expired;\n  }\n  /**\n   * Check if an item is valid (not expired) before returning it\n   * Returns true if item is valid, false if expired\n   */\n  validateItem(key, metadataProvider) {\n    if (!this.config.validateOnAccess) {\n      return true;\n    }\n    return !this.isExpired(key, metadataProvider);\n  }\n  /**\n   * Get TTL information for an item\n   */\n  getItemTTLInfo(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata || !metadata.expiresAt) {\n      return { hasTTL: false, isExpired: false };\n    }\n    const now = Date.now();\n    const isExpired = now >= metadata.expiresAt;\n    const remainingTTL = isExpired ? 0 : metadata.expiresAt - now;\n    return {\n      hasTTL: true,\n      ttl: metadata.ttl,\n      expiresAt: metadata.expiresAt,\n      remainingTTL,\n      isExpired\n    };\n  }\n  /**\n   * Find all expired items\n   */\n  findExpiredItems(metadataProvider) {\n    const expiredKeys = [];\n    const allMetadata = metadataProvider.getAllMetadata();\n    const now = Date.now();\n    for (const [key, metadata] of allMetadata) {\n      const ttlMetadata = metadata;\n      if (ttlMetadata.expiresAt && now >= ttlMetadata.expiresAt) {\n        expiredKeys.push(key);\n      }\n    }\n    if (expiredKeys.length > 0) {\n      logger21.debug(\"Found expired items\", { count: expiredKeys.length, keys: expiredKeys });\n    }\n    return expiredKeys;\n  }\n  /**\n   * Manually clean up expired items\n   * Returns the keys of items that were expired\n   */\n  cleanupExpiredItems(metadataProvider) {\n    return this.findExpiredItems(metadataProvider);\n  }\n  /**\n   * Get remaining TTL for an item in milliseconds\n   */\n  getRemainingTTL(key, metadataProvider) {\n    const info = this.getItemTTLInfo(key, metadataProvider);\n    return info.hasTTL ? info.remainingTTL || 0 : null;\n  }\n  /**\n   * Extend TTL for an item\n   */\n  extendTTL(key, metadataProvider, additionalTTL) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata || !metadata.expiresAt) {\n      return false;\n    }\n    metadata.expiresAt += additionalTTL;\n    metadataProvider.setMetadata(key, metadata);\n    logger21.trace(\"TTL extended for item\", { key, additionalTTL, newExpiresAt: metadata.expiresAt });\n    return true;\n  }\n  /**\n   * Reset TTL for an item (refresh expiration)\n   */\n  refreshTTL(key, metadataProvider, newTTL) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) {\n      return false;\n    }\n    const ttl = newTTL || metadata.ttl || this.config.defaultTTL;\n    if (!ttl) {\n      return false;\n    }\n    const now = Date.now();\n    const ttlMetadata = {\n      ...metadata,\n      expiresAt: now + ttl,\n      ttl\n    };\n    metadataProvider.setMetadata(key, ttlMetadata);\n    logger21.trace(\"TTL refreshed for item\", { key, ttl, expiresAt: ttlMetadata.expiresAt });\n    return true;\n  }\n  /**\n   * Start automatic cleanup of expired items\n   */\n  startAutoCleanup() {\n    if (this.cleanupTimer) {\n      this.stopAutoCleanup();\n    }\n    if (this.config.cleanupInterval) {\n      this.cleanupTimer = setInterval(() => {\n        logger21.trace(\"Auto cleanup timer triggered\");\n      }, this.config.cleanupInterval);\n      logger21.debug(\"Auto cleanup started\", { interval: this.config.cleanupInterval });\n    }\n  }\n  /**\n   * Stop automatic cleanup\n   */\n  stopAutoCleanup() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n      logger21.debug(\"Auto cleanup stopped\");\n    }\n  }\n  /**\n   * Cleanup resources\n   */\n  destroy() {\n    this.stopAutoCleanup();\n    logger21.debug(\"TTL manager destroyed\");\n  }\n};\n\n// src/events/CacheEventEmitter.ts\nvar CacheEventEmitter = class {\n  subscriptions = /* @__PURE__ */ new Map();\n  nextSubscriptionId = 1;\n  isDestroyed = false;\n  cleanupInterval = null;\n  CLEANUP_INTERVAL_MS = 3e4;\n  // 30 seconds\n  MAX_INACTIVE_TIME_MS = 3e5;\n  // 5 minutes\n  WEAK_REF_ENABLED = typeof WeakRef !== \"undefined\";\n  constructor() {\n    this.startPeriodicCleanup();\n  }\n  /**\n   * Start periodic cleanup of inactive subscriptions\n   */\n  startPeriodicCleanup() {\n    if (this.cleanupInterval) return;\n    this.cleanupInterval = setInterval(() => {\n      this.performPeriodicCleanup();\n    }, this.CLEANUP_INTERVAL_MS);\n    if (this.cleanupInterval.unref) {\n      this.cleanupInterval.unref();\n    }\n  }\n  /**\n   * Perform periodic cleanup of inactive subscriptions\n   */\n  performPeriodicCleanup() {\n    if (this.isDestroyed) return;\n    const now = Date.now();\n    const toRemove = [];\n    for (const [id, subscription] of this.subscriptions) {\n      if (!subscription.isActive || now - subscription.lastAccessTime > this.MAX_INACTIVE_TIME_MS) {\n        toRemove.push(id);\n        continue;\n      }\n      if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n        const listener = subscription.listenerRef.deref();\n        if (!listener) {\n          toRemove.push(id);\n          continue;\n        }\n      }\n    }\n    toRemove.forEach((id) => this.unsubscribe(id));\n  }\n  /**\n   * Subscribe to cache events\n   */\n  subscribe(listener, options = {}) {\n    if (this.isDestroyed) {\n      throw new Error(\"Cannot subscribe to destroyed event emitter\");\n    }\n    const id = `subscription_${this.nextSubscriptionId++}`;\n    const now = Date.now();\n    const subscription = {\n      id,\n      listener,\n      listenerRef: this.WEAK_REF_ENABLED && options.useWeakRef !== false ? new WeakRef(listener) : void 0,\n      options,\n      isActive: true,\n      createdAt: now,\n      lastAccessTime: now\n    };\n    this.subscriptions.set(id, subscription);\n    return {\n      id,\n      unsubscribe: () => this.unsubscribe(id),\n      isActive: () => {\n        const sub = this.subscriptions.get(id);\n        if (sub) {\n          sub.lastAccessTime = Date.now();\n        }\n        return sub?.isActive ?? false;\n      },\n      getOptions: () => ({ ...options })\n    };\n  }\n  /**\n   * Unsubscribe from events\n   */\n  unsubscribe(subscriptionId) {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) {\n      return false;\n    }\n    if (subscription.debounceTimer) {\n      clearTimeout(subscription.debounceTimer);\n      subscription.debounceTimer = null;\n    }\n    subscription.isActive = false;\n    this.subscriptions.delete(subscriptionId);\n    return true;\n  }\n  /**\n   * Emit an event to all matching subscriptions\n   */\n  emit(event) {\n    if (this.isDestroyed) {\n      return;\n    }\n    for (const subscription of this.subscriptions.values()) {\n      if (!subscription.isActive) {\n        continue;\n      }\n      if (this.shouldEmitToSubscription(event, subscription)) {\n        this.emitToSubscription(event, subscription);\n      }\n    }\n  }\n  /**\n   * Get count of active subscriptions\n   */\n  getSubscriptionCount() {\n    return Array.from(this.subscriptions.values()).filter((s) => s.isActive).length;\n  }\n  /**\n   * Get subscription details (for debugging)\n   */\n  getSubscriptions() {\n    return Array.from(this.subscriptions.values()).filter((s) => s.isActive).map((s) => ({ id: s.id, options: { ...s.options } }));\n  }\n  /**\n   * Destroy the event emitter and clean up all subscriptions\n   */\n  destroy() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    for (const subscription of this.subscriptions.values()) {\n      if (subscription.debounceTimer) {\n        clearTimeout(subscription.debounceTimer);\n        subscription.debounceTimer = null;\n      }\n      subscription.isActive = false;\n    }\n    this.subscriptions.clear();\n    this.isDestroyed = true;\n  }\n  /**\n   * Check if an event should be emitted to a specific subscription\n   */\n  shouldEmitToSubscription(event, subscription) {\n    const { options } = subscription;\n    if (options.eventTypes && !options.eventTypes.includes(event.type)) {\n      return false;\n    }\n    if (options.keys && options.keys.length > 0) {\n      if (\"key\" in event) {\n        const eventKeyStr = this.normalizeKey(event.key);\n        const matchesKey = options.keys.some(\n          (key) => this.normalizeKey(key) === eventKeyStr\n        );\n        if (!matchesKey) {\n          return false;\n        }\n      } else if (\"affectedKeys\" in event) {\n        const eventKeyStrs = event.affectedKeys.map((key) => this.normalizeKey(key));\n        const hasMatchingKey = options.keys.some(\n          (key) => eventKeyStrs.includes(this.normalizeKey(key))\n        );\n        if (!hasMatchingKey) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    if (options.locations && options.locations.length > 0) {\n      if (\"affectedLocations\" in event && event.affectedLocations) {\n        if (!this.locationsMatch(options.locations, event.affectedLocations)) {\n          return false;\n        }\n      } else if (\"locations\" in event) {\n        if (!this.locationsMatch(options.locations, event.locations)) {\n          return false;\n        }\n      } else if (\"key\" in event) {\n        if (!this.keyMatchesLocations(event.key, options.locations)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    if (options.query) {\n      if (\"query\" in event) {\n        if (!this.queriesMatch(options.query, event.query)) {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n    return true;\n  }\n  /**\n   * Emit event to a specific subscription, handling debouncing\n   */\n  emitToSubscription(event, subscription) {\n    subscription.lastAccessTime = Date.now();\n    let listener = subscription.listener;\n    if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n      const weakListener = subscription.listenerRef.deref();\n      if (!weakListener) {\n        subscription.isActive = false;\n        return;\n      }\n      listener = weakListener;\n    }\n    if (!subscription.options.debounceMs) {\n      try {\n        listener(event);\n      } catch (error) {\n        this.handleListenerError(error, event, subscription);\n      }\n      return;\n    }\n    if (subscription.debounceTimer) {\n      clearTimeout(subscription.debounceTimer);\n      subscription.debounceTimer = null;\n    }\n    subscription.debounceTimer = setTimeout(() => {\n      if (subscription.isActive) {\n        let currentListener = subscription.listener;\n        if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n          const weakListener = subscription.listenerRef.deref();\n          if (!weakListener) {\n            subscription.isActive = false;\n            subscription.debounceTimer = null;\n            return;\n          }\n          currentListener = weakListener;\n        }\n        try {\n          currentListener(event);\n          subscription.lastEmitTime = Date.now();\n        } catch (error) {\n          this.handleListenerError(error, event, subscription);\n        }\n      }\n      subscription.debounceTimer = null;\n    }, subscription.options.debounceMs);\n  }\n  /**\n   * Normalize a key for comparison\n   */\n  normalizeKey(key) {\n    return JSON.stringify(key, (k, v) => {\n      if (typeof v === \"string\" || typeof v === \"number\") {\n        return normalizeKeyValue(v);\n      }\n      return v;\n    });\n  }\n  /**\n   * Normalize a location key for comparison\n   */\n  normalizeLocKey(key) {\n    return JSON.stringify(key, (k, v) => {\n      if (typeof v === \"string\" || typeof v === \"number\") {\n        return normalizeKeyValue(v);\n      }\n      return v;\n    });\n  }\n  /**\n   * Check if two location arrays match\n   */\n  locationsMatch(filter, eventLocations) {\n    if (filter.length === 0 && eventLocations.length === 0) {\n      return true;\n    }\n    if (filter.length !== eventLocations.length) {\n      return false;\n    }\n    return filter.every((filterLoc, index) => {\n      const eventLoc = eventLocations[index];\n      return this.normalizeKey(filterLoc) === this.normalizeKey(eventLoc);\n    });\n  }\n  /**\n   * Check if a key matches location filters\n   */\n  keyMatchesLocations(key, filterLocations) {\n    if (\"loc\" in key && key.loc) {\n      return this.locationsMatch(filterLocations, key.loc);\n    }\n    return filterLocations.length === 0;\n  }\n  /**\n   * Check if two queries match (improved comparison)\n   */\n  queriesMatch(filterQuery, eventQuery) {\n    const normalize = (obj) => {\n      if (obj === null || typeof obj === \"undefined\") return obj;\n      if (typeof obj !== \"object\") return obj;\n      if (Array.isArray(obj)) return obj.map(normalize).sort();\n      const sorted = {};\n      Object.keys(obj).sort().forEach((key) => {\n        sorted[key] = normalize(obj[key]);\n      });\n      return sorted;\n    };\n    return JSON.stringify(normalize(filterQuery)) === JSON.stringify(normalize(eventQuery));\n  }\n  /**\n   * Handle errors that occur in event listeners\n   */\n  handleListenerError(error, event, subscription) {\n    const errorObj = error instanceof Error ? error : new Error(String(error));\n    if (subscription.options.onError) {\n      try {\n        subscription.options.onError(errorObj, event);\n      } catch (handlerError) {\n        console.error(\"Error in cache event listener:\", errorObj);\n        console.error(\"Error in error handler:\", handlerError);\n      }\n    } else {\n      console.error(\"Error in cache event listener:\", errorObj);\n    }\n  }\n};\n\n// src/CacheStats.ts\nvar CacheStatsManager = class {\n  stats = {\n    numRequests: 0,\n    numMisses: 0,\n    numHits: 0,\n    numSubscriptions: 0,\n    numUnsubscriptions: 0,\n    activeSubscriptions: 0\n  };\n  /**\n   * Increment the request counter\n   */\n  incrementRequests() {\n    this.stats.numRequests++;\n  }\n  /**\n   * Increment the cache hit counter\n   */\n  incrementHits() {\n    this.stats.numHits++;\n  }\n  /**\n   * Increment the cache miss counter\n   */\n  incrementMisses() {\n    this.stats.numMisses++;\n  }\n  /**\n   * Increment the subscription counter\n   */\n  incrementSubscriptions() {\n    this.stats.numSubscriptions++;\n    this.stats.activeSubscriptions++;\n  }\n  /**\n   * Increment the unsubscription counter\n   */\n  incrementUnsubscriptions() {\n    this.stats.numUnsubscriptions++;\n    if (this.stats.activeSubscriptions > 0) {\n      this.stats.activeSubscriptions--;\n    }\n  }\n  /**\n   * Get a copy of the current statistics\n   */\n  getStats() {\n    return { ...this.stats };\n  }\n  /**\n   * Reset all statistics to zero\n   */\n  reset() {\n    this.stats = {\n      numRequests: 0,\n      numMisses: 0,\n      numHits: 0,\n      numSubscriptions: 0,\n      numUnsubscriptions: 0,\n      activeSubscriptions: 0\n    };\n  }\n};\n\n// src/Cache.ts\nvar logger22 = logger_default.get(\"Cache\");\nvar createCache = (api, coordinate, registry, options) => {\n  logger22.debug(\"createCache\", { coordinate, registry, options });\n  const completeOptions = createOptions(options);\n  const cacheMap = createCacheMap(coordinate.kta, completeOptions);\n  const pkType = coordinate.kta[0];\n  const eventEmitter = new CacheEventEmitter();\n  const evictionManager = new EvictionManager();\n  const evictionConfig = completeOptions.evictionConfig;\n  if (!evictionConfig && completeOptions.memoryConfig?.size?.evictionPolicy && (completeOptions.memoryConfig.size.maxItems || completeOptions.memoryConfig.size.maxSizeBytes)) {\n  }\n  if (evictionConfig) {\n    const strategy = createEvictionStrategy(\n      evictionConfig.type || \"lru\",\n      completeOptions.memoryConfig?.maxItems,\n      evictionConfig\n    );\n    evictionManager.setEvictionStrategy(strategy);\n  }\n  const ttlManager = new TTLManager({\n    defaultTTL: completeOptions.ttl,\n    autoCleanup: true,\n    validateOnAccess: true\n  });\n  const statsManager = new CacheStatsManager();\n  const operations = createOperations(api, coordinate, cacheMap, pkType, completeOptions, eventEmitter, ttlManager, evictionManager, statsManager);\n  const cache = {\n    coordinate,\n    registry,\n    api,\n    cacheMap,\n    operations,\n    options: completeOptions,\n    eventEmitter,\n    evictionManager,\n    ttlManager,\n    statsManager,\n    getCacheInfo: () => {\n      const evictionStrategyName = evictionManager.getEvictionStrategyName();\n      const cacheInfo = {\n        implementationType: cacheMap.implementationType,\n        defaultTTL: ttlManager.getDefaultTTL(),\n        // Cache supports TTL if the CacheMap supports it OR if TTL is configured\n        supportsTTL: cacheMap.supportsTTL?.() || !!ttlManager.getDefaultTTL(),\n        supportsEviction: evictionManager.isEvictionSupported()\n      };\n      if (evictionStrategyName) {\n        cacheInfo.evictionPolicy = evictionStrategyName;\n      }\n      return cacheInfo;\n    },\n    getStats: () => statsManager.getStats(),\n    subscribe: (listener, options2) => {\n      statsManager.incrementSubscriptions();\n      return eventEmitter.subscribe(listener, options2);\n    },\n    unsubscribe: (subscription) => {\n      const result = eventEmitter.unsubscribe(subscription.id);\n      if (result) {\n        statsManager.incrementUnsubscriptions();\n      }\n      return result;\n    },\n    destroy: () => {\n      eventEmitter.destroy();\n      if (ttlManager && typeof ttlManager.destroy === \"function\") {\n        ttlManager.destroy();\n      }\n      if (cacheMap && typeof cacheMap.destroy === \"function\") {\n        cacheMap.destroy();\n      }\n      CacheEventFactory.destroyInstance();\n    }\n  };\n  return cache;\n};\nvar isCache = (cache) => {\n  return cache !== null && typeof cache === \"object\" && \"coordinate\" in cache && \"registry\" in cache && \"api\" in cache && \"cacheMap\" in cache && \"operations\" in cache;\n};\n\n// src/InstanceFactory.ts\nvar logger23 = logger_default.get(\"InstanceFactory\");\nvar createInstanceFactory = (api, options) => {\n  const templateOptions = createOptions(options);\n  validateOptions(templateOptions);\n  return (coordinate, context) => {\n    const instanceOptions = createOptions(options);\n    logger23.debug(\"Creating cache instance\", {\n      coordinate,\n      registry: context.registry,\n      api,\n      cacheType: instanceOptions.cacheType,\n      options: instanceOptions\n    });\n    const cacheMap = createCacheMap(coordinate.kta, instanceOptions);\n    const pkType = coordinate.kta[0];\n    const eventEmitter = new CacheEventEmitter();\n    const ttlManager = new TTLManager({\n      defaultTTL: instanceOptions.ttl,\n      autoCleanup: true,\n      validateOnAccess: true\n    });\n    const evictionManager = new EvictionManager();\n    const statsManager = new CacheStatsManager();\n    const operations = createOperations(\n      api,\n      coordinate,\n      cacheMap,\n      pkType,\n      instanceOptions,\n      eventEmitter,\n      ttlManager,\n      evictionManager,\n      statsManager\n    );\n    return {\n      coordinate,\n      registry: context.registry,\n      api,\n      cacheMap,\n      operations,\n      options: instanceOptions,\n      eventEmitter,\n      ttlManager,\n      evictionManager,\n      getCacheInfo: () => {\n        const evictionStrategyName = evictionManager.getEvictionStrategyName();\n        const cacheInfo = {\n          implementationType: cacheMap.implementationType,\n          defaultTTL: ttlManager.getDefaultTTL(),\n          supportsTTL: cacheMap.supportsTTL?.() || !!ttlManager.getDefaultTTL(),\n          supportsEviction: evictionManager.isEvictionSupported()\n        };\n        if (evictionStrategyName) {\n          cacheInfo.evictionPolicy = evictionStrategyName;\n        }\n        return cacheInfo;\n      },\n      subscribe: (listener, options2) => eventEmitter.subscribe(listener, options2),\n      unsubscribe: (subscription) => eventEmitter.unsubscribe(subscription.id),\n      destroy: () => {\n        if (typeof ttlManager.destroy === \"function\") {\n          ttlManager.destroy();\n        }\n        eventEmitter.destroy();\n      }\n    };\n  };\n};\n\n// src/Instance.ts\nvar logger24 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate, api, options) => {\n  logger24.debug(\"createInstance\", { coordinate, api, registry, options });\n  return createCache(api, coordinate, registry, options);\n};\nvar isInstance = (instance) => {\n  return instance !== null && typeof instance === \"object\" && \"coordinate\" in instance && \"registry\" in instance && \"api\" in instance && \"cacheMap\" in instance && \"operations\" in instance;\n};\n\n// src/Aggregator.ts\nvar logger25 = logger_default.get(\"ItemAggregator\");\nvar toCacheConfig = (config) => {\n  let cacheConfig;\n  if (config.optional === void 0) {\n    cacheConfig = { cache: config, optional: false };\n  } else {\n    cacheConfig = config;\n  }\n  return cacheConfig;\n};\nvar createAggregator = async (cache, { aggregates = {}, events = {} }) => {\n  const populate = async (item) => {\n    logger25.default(\"populate\", { item });\n    for (const key in aggregates) {\n      await populateAggregate(key, item);\n    }\n    for (const key in events) {\n      await populateEvent(key, item);\n    }\n    logger25.default(\"populate done\", { item });\n    return item;\n  };\n  const populateAggregate = async (key, item) => {\n    logger25.default(\"populate aggregate key\", { key });\n    const cacheConfig = toCacheConfig(aggregates[key]);\n    if (item.refs === void 0) {\n      if (cacheConfig.optional === false) {\n        logger25.error(\"Item does not have refs an is not optional \", { item });\n        throw new Error(\"Item does not have refs an is not optional \" + JSON.stringify(item));\n      } else {\n        if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n          delete item.events[key];\n        }\n      }\n    } else if (item.refs[key] === void 0) {\n      if (cacheConfig.optional === false) {\n        logger25.error(\"Item does not have mandatory ref with key, not optional \", { key, item });\n        throw new Error(\"Item does not have mandatory ref with key, not optional \" + key + \" \" + JSON.stringify(item));\n      } else {\n        if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n          delete item.events[key];\n        }\n      }\n    } else {\n      const ref = item.refs[key];\n      logger25.default(\"AGG Retrieving Item in Populate\", { key: ref });\n      const newItem = await cacheConfig.cache.operations.retrieve(ref);\n      if (newItem) {\n        if (item.aggs === void 0) {\n          item.aggs = {};\n        }\n        item.aggs[key] = {\n          key: ref,\n          item: newItem\n        };\n      }\n    }\n  };\n  const populateEvent = async (key, item) => {\n    logger25.default(\"populate event key\", { key });\n    const cacheConfig = toCacheConfig(events[key]);\n    if (item.events === void 0) {\n      throw new Error(\"Item does not have events \" + JSON.stringify(item));\n    } else if (item.events[key] === void 0) {\n      if (cacheConfig.optional === false) {\n        logger25.error(\"Item does not have mandatory event with key\", { key, item });\n        throw new Error(\"Item does not have mandatory event with key \" + key + \" \" + JSON.stringify(item));\n      }\n    } else {\n      const event = item.events[key];\n      if (event.by === void 0) {\n        logger25.error(\n          \"populateEvent with an Event that does not have by\",\n          { event, ik: item.key, eventKey: key }\n        );\n        throw new Error(\"populateEvent with an Event that does not have by: \" + JSON.stringify({ key }));\n      }\n      logger25.default(\"EVENT Retrieving Item in Populate\", { key: event.by });\n      const newItem = await cacheConfig.cache.operations.retrieve(event.by);\n      if (newItem) {\n        event.agg = newItem;\n      }\n    }\n  };\n  const all2 = async (query = {}, locations = []) => {\n    logger25.default(\"all\", { query, locations });\n    const items = await cache.operations.all(query, locations);\n    const populatedItems = await Promise.all(items.map(async (item) => populate(item)));\n    return populatedItems;\n  };\n  const one2 = async (query = {}, locations = []) => {\n    logger25.default(\"one\", { query, locations });\n    const item = await cache.operations.one(query, locations);\n    let populatedItem = null;\n    if (item) {\n      populatedItem = await populate(item);\n    }\n    return populatedItem;\n  };\n  const action2 = async (key, action3, body = {}) => {\n    logger25.default(\"action\", { key, action: action3, body });\n    const item = await cache.operations.action(key, action3, body);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const allAction2 = async (action3, body = {}, locations = []) => {\n    logger25.default(\"action\", { action: action3, body, locations });\n    const items = await cache.operations.allAction(action3, body, locations);\n    const populatedItems = await Promise.all(items.map(async (item) => populate(item)));\n    return populatedItems;\n  };\n  const allFacet2 = async (facet3, params = {}, locations = []) => {\n    logger25.default(\"allFacet\", { facet: facet3, params, locations });\n    const response = await cache.operations.allFacet(facet3, params, locations);\n    return response;\n  };\n  const create2 = async (v, locations = []) => {\n    logger25.default(\"create\", { v, locations });\n    const item = await cache.operations.create(v, locations);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const get2 = async (key) => {\n    logger25.default(\"get\", { key });\n    const item = await cache.operations.get(key);\n    let populatedItem = null;\n    if (item) {\n      populatedItem = await populate(item);\n    }\n    return populatedItem;\n  };\n  const retrieve2 = async (key) => {\n    logger25.default(\"retrieve\", { key });\n    const item = await cache.operations.retrieve(key);\n    let populatedItem = null;\n    if (item) {\n      populatedItem = await populate(item);\n    }\n    return populatedItem;\n  };\n  const remove2 = async (key) => {\n    logger25.default(\"remove\", { key });\n    await cache.operations.remove(key);\n  };\n  const update2 = async (key, v) => {\n    logger25.default(\"update\", { key, v });\n    const item = await cache.operations.update(key, v);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const facet2 = async (key, facet3) => {\n    logger25.default(\"facet\", { key, facet: facet3 });\n    const response = await cache.operations.facet(key, facet3);\n    return response;\n  };\n  const find2 = async (finder, finderParams = {}, locations = []) => {\n    logger25.default(\"find\", { finder, finderParams, locations });\n    const items = await cache.operations.find(finder, finderParams, locations);\n    const populatedItems = await Promise.all(items.map(async (item) => populate(item)));\n    return populatedItems;\n  };\n  const findOne2 = async (finder, finderParams = {}, locations = []) => {\n    logger25.default(\"find\", { finder, finderParams, locations });\n    const item = await cache.operations.findOne(finder, finderParams, locations);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const set2 = async (key, v) => {\n    logger25.default(\"set\", { key, v });\n    const item = await cache.operations.set(key, v);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const reset2 = async () => {\n    await cache.operations.reset();\n  };\n  return {\n    // Cache properties\n    coordinate: cache.coordinate,\n    registry: cache.registry,\n    api: cache.api,\n    cacheMap: cache.cacheMap,\n    operations: cache.operations,\n    evictionManager: cache.evictionManager,\n    ttlManager: cache.ttlManager,\n    statsManager: cache.statsManager,\n    getStats: cache.getStats.bind(cache),\n    getCacheInfo: cache.getCacheInfo.bind(cache),\n    // Cache operations exposed directly\n    all: all2,\n    one: one2,\n    action: action2,\n    allAction: allAction2,\n    allFacet: allFacet2,\n    create: create2,\n    get: get2,\n    retrieve: retrieve2,\n    remove: remove2,\n    update: update2,\n    facet: facet2,\n    find: find2,\n    findOne: findOne2,\n    reset: reset2,\n    set: set2,\n    // Aggregator-specific operations\n    populate,\n    populateAggregate,\n    populateEvent,\n    // Event system\n    eventEmitter: cache.eventEmitter,\n    subscribe: (listener, options) => cache.subscribe(listener, options),\n    unsubscribe: (subscription) => cache.unsubscribe(subscription),\n    destroy: () => cache.destroy()\n  };\n};\n\n// src/Registry.ts\n\nvar logger26 = logger_default.get(\"Registry\");\nvar createRegistryFactory = () => {\n  return (type, registryHub) => {\n    if (type !== \"cache\") {\n      throw new Error(`Cache registry factory can only create 'cache' type registries, got: ${type}`);\n    }\n    logger26.debug(\"Creating cache registry\", { type, registryHub });\n    const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(type, registryHub);\n    return baseRegistry;\n  };\n};\nvar createRegistry = (registryHub) => {\n  const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(\"cache\", registryHub);\n  return {\n    ...baseRegistry\n  };\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9AZmplbGwvY2FjaGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR3FCO0FBQzJCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFFBQVE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxRQUFRO0FBQ3ZF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFEQUFTO0FBQzVEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsR0FBRyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxRUFBcUUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1osOEJBQThCLHdDQUF3QztBQUN0RTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlFQUFpRSxZQUFZO0FBQzdFLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0VBQWtFLCtCQUErQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLDRCQUE0QixhQUFhLGVBQWUsYUFBYTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlLEdBQUcsT0FBTyxHQUFHLE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyREFBMkQsd0JBQXdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxZQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLFlBQVksR0FBRyx3QkFBd0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx1REFBdUQ7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwRUFBMEUsd0JBQXdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxZQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdDQUFnQywrQkFBK0I7QUFDL0QsMERBQTBELHFEQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0EsZ0NBQWdDLHlEQUFhO0FBQzdDO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0Esa0NBQWtDLHlEQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNERBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUI7QUFDNUQsd0JBQXdCLGVBQWUsU0FBUyxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUVBQXVFLGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRCx3QkFBd0IsZUFBZSxTQUFTLFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEVBQTRFLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlLFNBQVMsVUFBVTtBQUMxRDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVFQUF1RSxrQkFBa0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRCx3QkFBd0IsZUFBZSxTQUFTLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLE1BQU07QUFDTiwwRUFBMEUsa0JBQWtCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixxRUFBcUUsWUFBWTtBQUNqRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFEQUFTO0FBQzlEO0FBQ0EsUUFBUTtBQUNSLG9FQUFvRSxxREFBUztBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzREFBc0Qsa0JBQWtCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4RUFBOEUsWUFBWTtBQUMxRjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZSxZQUFZLElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0VBQXNFLGVBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsK0JBQStCLGVBQWUsWUFBWSxJQUFJO0FBQzlEO0FBQ0E7QUFDQSw4REFBOEQsU0FBUztBQUN2RTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMEVBQTBFLFlBQVksR0FBRyx3QkFBd0I7QUFDakg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsdURBQXVEO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZSxZQUFZLElBQUk7QUFDNUQ7QUFDQSxNQUFNO0FBQ04sb0VBQW9FLFlBQVk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOERBQThELFlBQVk7QUFDMUU7QUFDQTtBQUNBLE1BQU07QUFDTixtRUFBbUUsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0EsTUFBTTtBQUNOLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJFQUEyRSxZQUFZO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtRUFBbUUsT0FBTztBQUMxRTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSXFCO0FBQzRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZSxHQUFHLFVBQVU7QUFDMUM7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpRUFBaUUsT0FBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxHQUFHLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFjO0FBQ3ZDO0FBQ0EsTUFBTTtBQUNOLDBEQUEwRCw4QkFBOEI7QUFDeEYsaUVBQWlFLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtEQUErRCxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxZQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MsK0JBQStCO0FBQy9ELDBEQUEwRCxxREFBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBLGdDQUFnQyx5REFBYTtBQUM3QztBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBLGtDQUFrQyx5REFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw0REFBNEQsOEJBQThCO0FBQzFGO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVFQUF1RSw4QkFBOEI7QUFDckc7QUFDQTtBQUNBLE1BQU07QUFDTixtRUFBbUUsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4REFBOEQsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUI7QUFDNUQsd0JBQXdCLGVBQWUsU0FBUyxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFjO0FBQ3ZDO0FBQ0EsTUFBTTtBQUNOLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQsd0JBQXdCLGVBQWUsU0FBUyxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhFQUE4RSxrQkFBa0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZSxTQUFTLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLE1BQU07QUFDTix5RUFBeUUsa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQsd0JBQXdCLGVBQWUsU0FBUyxVQUFVO0FBQzFEO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEVBQTRFLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0EsbURBQW1ELHFEQUFTO0FBQzVEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEVBQTRFLE9BQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlLFlBQVksSUFBSTtBQUM1RDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZSxZQUFZLElBQUk7QUFDNUQseUJBQXlCLGdEQUFjO0FBQ3ZDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWUsWUFBWSxJQUFJO0FBQzVEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUVBQXlFLE9BQU87QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlxQjtBQUM0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHNCQUFzQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDJCQUEyQjtBQUNoRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwyQkFBMkI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0NBQWtDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLDJEQUEyRCxtQkFBbUI7QUFDOUUsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQkFBMkI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixtRUFBbUUsWUFBWTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkJBQTJCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdDQUFnQywrQkFBK0I7QUFDL0QsMERBQTBELHFEQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQSxnQ0FBZ0MseURBQWE7QUFDN0M7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQSxrQ0FBa0MseURBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTiw0REFBNEQsT0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usc0JBQXNCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTiw4REFBOEQsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsc0JBQXNCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxzQkFBc0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsdUNBQXVDLGdEQUFjO0FBQ3JEO0FBQ0EsNkRBQTZELG9DQUFvQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxzQkFBc0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBLGdFQUFnRSxvQ0FBb0M7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLCtEQUErRCw4QkFBOEI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNCQUFzQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0EsOERBQThELHVDQUF1QztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsc0JBQXNCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw0QkFBNEI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNDQUFzQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04scURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvRUFBb0UsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTixpRUFBaUUsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ04sbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFtRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFtRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLHVEQUF1RCwwQ0FBMEM7QUFDakcsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsNERBQTRELDJDQUEyQztBQUN2RyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0Q0FBNEM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUNBQXlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOENBQThDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzREFBc0Q7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRDQUE0QztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsK0NBQStDLHVDQUF1QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHFCQUFxQixnQkFBZ0I7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxx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bW9kdWxlcy9AZmplbGwvY2FjaGUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvQ2FjaGVDb250ZXh0LnRzXG52YXIgY3JlYXRlQ2FjaGVDb250ZXh0ID0gKGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgb3B0aW9ucywgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIHN0YXRzTWFuYWdlcikgPT4ge1xuICByZXR1cm4ge1xuICAgIGFwaSxcbiAgICBjYWNoZU1hcCxcbiAgICBwa1R5cGUsXG4gICAgb3B0aW9ucyxcbiAgICBldmVudEVtaXR0ZXIsXG4gICAgdHRsTWFuYWdlcixcbiAgICBldmljdGlvbk1hbmFnZXIsXG4gICAgc3RhdHNNYW5hZ2VyXG4gIH07XG59O1xuXG4vLyBzcmMvb3BzL2FsbC50c1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IE5vdEZvdW5kRXJyb3IgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbi8vIHNyYy9ub3JtYWxpemF0aW9uLnRzXG52YXIgbm9ybWFsaXplS2V5VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xudmFyIGRldGVybWluaXN0aWNTdHJpbmdpZnkgPSAob2JqKSA9PiB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gXCJbXCIgKyBvYmoubWFwKGRldGVybWluaXN0aWNTdHJpbmdpZnkpLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gIH1cbiAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKG9iaikuc29ydCgpO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzID0gc29ydGVkS2V5cy5tYXAoKGtleSkgPT4ge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6XCIgKyBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9ialtrZXldKTtcbiAgfSk7XG4gIHJldHVybiBcIntcIiArIGtleVZhbHVlUGFpcnMuam9pbihcIixcIikgKyBcIn1cIjtcbn07XG52YXIgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIChrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGtleSkpO1xuICAgICAgaWYgKFwicGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIG5vcm1hbGl6ZWRLZXkucGsgIT09IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5wayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWRLZXkucGspO1xuICAgICAgfVxuICAgICAgaWYgKFwibGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIG5vcm1hbGl6ZWRLZXkubGsgIT09IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5sayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWRLZXkubGspO1xuICAgICAgfVxuICAgICAgaWYgKFwibG9jXCIgaW4gbm9ybWFsaXplZEtleSAmJiBBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRLZXkubG9jKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxvYyA9IG5vcm1hbGl6ZWRLZXkubG9jLm1hcCgobG9jSXRlbSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgbG9jSXRlbSA9PT0gXCJvYmplY3RcIiAmJiBsb2NJdGVtICE9PSBudWxsICYmIFwibGtcIiBpbiBsb2NJdGVtICYmIGxvY0l0ZW0ubGsgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmxvY0l0ZW0sIGxrOiBub3JtYWxpemVLZXlWYWx1ZShsb2NJdGVtLmxrKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9jSXRlbTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShub3JtYWxpemVkS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIH07XG59O1xudmFyIGlzTG9jS2V5QXJyYXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEEgPSBub3JtYWxpemVMb2NLZXlJdGVtKGFbaV0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRCID0gbm9ybWFsaXplTG9jS2V5SXRlbShiW2ldKTtcbiAgICBpZiAoZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShub3JtYWxpemVkQSkgIT09IGRldGVybWluaXN0aWNTdHJpbmdpZnkobm9ybWFsaXplZEIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBub3JtYWxpemVMb2NLZXlJdGVtID0gKGl0ZW0pID0+IHtcbiAgaWYgKHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIGl0ZW0gIT09IG51bGwpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0geyAuLi5pdGVtIH07XG4gICAgaWYgKFwibGtcIiBpbiBub3JtYWxpemVkICYmIG5vcm1hbGl6ZWQubGsgIT09IG51bGwpIHtcbiAgICAgIG5vcm1hbGl6ZWQubGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkLmxrKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xudmFyIGNyZWF0ZVF1ZXJ5SGFzaCA9IChwa1R5cGUsIHF1ZXJ5LCBsb2NhdGlvbnMpID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZFF1ZXJ5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShxdWVyeSB8fCB7fSkpO1xuICBjb25zdCBzb3J0ZWRRdWVyeUtleXMgPSBPYmplY3Qua2V5cyhub3JtYWxpemVkUXVlcnkpLnNvcnQoKTtcbiAgY29uc3Qgc29ydGVkUXVlcnkgPSB7fTtcbiAgc29ydGVkUXVlcnlLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHNvcnRlZFF1ZXJ5W2tleV0gPSBub3JtYWxpemVkUXVlcnlba2V5XTtcbiAgfSk7XG4gIGNvbnN0IGxvY2F0aW9uc0FycmF5ID0gQXJyYXkuaXNBcnJheShsb2NhdGlvbnMpID8gbG9jYXRpb25zIDogW107XG4gIGNvbnN0IG5vcm1hbGl6ZWRMb2NhdGlvbnMgPSBsb2NhdGlvbnNBcnJheS5tYXAobm9ybWFsaXplTG9jS2V5SXRlbSk7XG4gIGNvbnN0IGhhc2hJbnB1dCA9IHtcbiAgICB0eXBlOiBcInF1ZXJ5XCIsXG4gICAgcGtUeXBlLFxuICAgIHF1ZXJ5OiBzb3J0ZWRRdWVyeSxcbiAgICBsb2NhdGlvbnM6IG5vcm1hbGl6ZWRMb2NhdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGRldGVybWluaXN0aWNTdHJpbmdpZnkoaGFzaElucHV0KTtcbn07XG52YXIgY3JlYXRlRmluZGVySGFzaCA9IChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zKSA9PiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXJhbXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcmFtcyB8fCB7fSkpO1xuICBjb25zdCBzb3J0ZWRQYXJhbUtleXMgPSBPYmplY3Qua2V5cyhub3JtYWxpemVkUGFyYW1zKS5zb3J0KCk7XG4gIGNvbnN0IHNvcnRlZFBhcmFtcyA9IHt9O1xuICBzb3J0ZWRQYXJhbUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgc29ydGVkUGFyYW1zW2tleV0gPSBub3JtYWxpemVkUGFyYW1zW2tleV07XG4gIH0pO1xuICBjb25zdCBsb2NhdGlvbnNBcnJheSA9IEFycmF5LmlzQXJyYXkobG9jYXRpb25zKSA/IGxvY2F0aW9ucyA6IFtdO1xuICBjb25zdCBub3JtYWxpemVkTG9jYXRpb25zID0gbG9jYXRpb25zQXJyYXkubWFwKG5vcm1hbGl6ZUxvY0tleUl0ZW0pO1xuICBjb25zdCBoYXNoSW5wdXQgPSB7XG4gICAgdHlwZTogXCJmaW5kZXJcIixcbiAgICBmaW5kZXIsXG4gICAgcGFyYW1zOiBzb3J0ZWRQYXJhbXMsXG4gICAgbG9jYXRpb25zOiBub3JtYWxpemVkTG9jYXRpb25zXG4gIH07XG4gIHJldHVybiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KGhhc2hJbnB1dCk7XG59O1xuXG4vLyBzcmMvZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5LnRzXG52YXIgQ2FjaGVFdmVudEZhY3RvcnkgPSBjbGFzcyB7XG4gIHN0YXRpYyBsYXN0VGltZXN0YW1wID0gMDtcbiAgc3RhdGljIGNsZWFudXBJbnRlcnZhbCA9IG51bGw7XG4gIHN0YXRpYyBpbnN0YW5jZUNvdW50ID0gMDtcbiAgc3RhdGljIENMRUFOVVBfSU5URVJWQUxfTVMgPSA2ZTQ7XG4gIC8vIDEgbWludXRlXG4gIHN0YXRpYyBNQVhfVElNRVNUQU1QX0FHRV9NUyA9IDNlNTtcbiAgLy8gNSBtaW51dGVzXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGNsZWFudXAgbWVjaGFuaXNtIHdoZW4gZmlyc3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemVDbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbCA9PT0gbnVsbCAmJiB0aGlzLmluc3RhbmNlQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRDbGVhbnVwVGltZXIoKTtcbiAgICB9XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFudXAgbWVjaGFuaXNtIHdoZW4gaW5zdGFuY2UgaXMgZGVzdHJveWVkXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveUluc3RhbmNlKCkge1xuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IE1hdGgubWF4KDAsIHRoaXMuaW5zdGFuY2VDb3VudCAtIDEpO1xuICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMuc3RvcENsZWFudXBUaW1lcigpO1xuICAgICAgdGhpcy5yZXNldFRpbWVzdGFtcCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RhcnQgYXV0b21hdGljIGNsZWFudXAgdGltZXJcbiAgICovXG4gIHN0YXRpYyBzdGFydENsZWFudXBUaW1lcigpIHtcbiAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMucGVyZm9ybUNsZWFudXAoKTtcbiAgICB9LCB0aGlzLkNMRUFOVVBfSU5URVJWQUxfTVMpO1xuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbC51bnJlZikge1xuICAgICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwudW5yZWYoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgYXV0b21hdGljIGNsZWFudXAgdGltZXJcbiAgICovXG4gIHN0YXRpYyBzdG9wQ2xlYW51cFRpbWVyKCkge1xuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBJbnRlcnZhbCk7XG4gICAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIHBlcmlvZGljIGNsZWFudXAgb2Ygc3RhbGUgdGltZXN0YW1wIHN0YXRlXG4gICAqL1xuICBzdGF0aWMgcGVyZm9ybUNsZWFudXAoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0VGltZXN0YW1wID4gdGhpcy5NQVhfVElNRVNUQU1QX0FHRV9NUykge1xuICAgICAgdGhpcy5sYXN0VGltZXN0YW1wID0gMDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0aW1lc3RhbXAgc3RhdGUgKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgICovXG4gIHN0YXRpYyByZXNldFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSB0aW1lc3RhbXAgdGhhdCBpcyBhbHdheXMgZ3JlYXRlciB0aGFuIHRoZSBwcmV2aW91cyBvbmVcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZVRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVDbGVhbnVwKCk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93ID4gdGhpcy5sYXN0VGltZXN0YW1wKSB7XG4gICAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSBub3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHRoaXMubGFzdFRpbWVzdGFtcCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhc3RUaW1lc3RhbXA7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgYWZmZWN0ZWQgbG9jYXRpb25zIGZyb20gYW4gaXRlbSBrZXlcbiAgICovXG4gIHN0YXRpYyBleHRyYWN0QWZmZWN0ZWRMb2NhdGlvbnMoa2V5KSB7XG4gICAgaWYgKFwibG9jXCIgaW4ga2V5ICYmIGtleS5sb2MpIHtcbiAgICAgIHJldHVybiBrZXkubG9jO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtLXJlbGF0ZWQgZXZlbnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJdGVtRXZlbnQodHlwZSwga2V5LCBpdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZmZlY3RlZExvY2F0aW9ucyA9IG9wdGlvbnMuYWZmZWN0ZWRMb2NhdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMuYWZmZWN0ZWRMb2NhdGlvbnMgOiB0aGlzLmV4dHJhY3RBZmZlY3RlZExvY2F0aW9ucyhrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLmdlbmVyYXRlVGltZXN0YW1wKCksXG4gICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlIHx8IFwib3BlcmF0aW9uXCIsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBrZXksXG4gICAgICBpdGVtLFxuICAgICAgcHJldmlvdXNJdGVtOiBvcHRpb25zLnByZXZpb3VzSXRlbSxcbiAgICAgIGFmZmVjdGVkTG9jYXRpb25zXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcXVlcnkgZXZlbnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVRdWVyeUV2ZW50KHF1ZXJ5LCBsb2NhdGlvbnMsIGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZmZlY3RlZEtleXMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0ua2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpdGVtc19xdWVyaWVkXCIsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgXCJvcGVyYXRpb25cIixcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgIHF1ZXJ5LFxuICAgICAgbG9jYXRpb25zLFxuICAgICAgaXRlbXMsXG4gICAgICBhZmZlY3RlZEtleXNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjYWNoZSBjbGVhcmVkIGV2ZW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQ2FjaGVDbGVhcmVkRXZlbnQoaXRlbXNDbGVhcmVkLCBxdWVyeUNhY2hlQ2xlYXJlZCA9IHRydWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNhY2hlX2NsZWFyZWRcIixcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZW5lcmF0ZVRpbWVzdGFtcCgpLFxuICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSB8fCBcIm9wZXJhdGlvblwiLFxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgaXRlbXNDbGVhcmVkLFxuICAgICAgcXVlcnlDYWNoZUNsZWFyZWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhdGlvbiBpbnZhbGlkYXRlZCBldmVudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUxvY2F0aW9uSW52YWxpZGF0ZWRFdmVudChsb2NhdGlvbnMsIGFmZmVjdGVkS2V5cywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibG9jYXRpb25faW52YWxpZGF0ZWRcIixcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZW5lcmF0ZVRpbWVzdGFtcCgpLFxuICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSB8fCBcIm9wZXJhdGlvblwiLFxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgbG9jYXRpb25zLFxuICAgICAgYWZmZWN0ZWRLZXlzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcXVlcnkgaW52YWxpZGF0ZWQgZXZlbnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVRdWVyeUludmFsaWRhdGVkRXZlbnQoaW52YWxpZGF0ZWRRdWVyaWVzLCByZWFzb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInF1ZXJ5X2ludmFsaWRhdGVkXCIsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgXCJvcGVyYXRpb25cIixcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgIGludmFsaWRhdGVkUXVlcmllcyxcbiAgICAgIHJlYXNvblxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtIGNyZWF0ZWQgZXZlbnRcbiAgICovXG4gIHN0YXRpYyBpdGVtQ3JlYXRlZChrZXksIGl0ZW0sIHNvdXJjZSA9IFwiYXBpXCIpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJdGVtRXZlbnQoXCJpdGVtX2NyZWF0ZWRcIiwga2V5LCBpdGVtLCB7IHNvdXJjZSB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0gdXBkYXRlZCBldmVudFxuICAgKi9cbiAgc3RhdGljIGl0ZW1VcGRhdGVkKGtleSwgaXRlbSwgcHJldmlvdXNJdGVtLCBzb3VyY2UgPSBcImFwaVwiKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlSXRlbUV2ZW50KFwiaXRlbV91cGRhdGVkXCIsIGtleSwgaXRlbSwgeyBwcmV2aW91c0l0ZW0sIHNvdXJjZSB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0gcmVtb3ZlZCBldmVudFxuICAgKi9cbiAgc3RhdGljIGl0ZW1SZW1vdmVkKGtleSwgcHJldmlvdXNJdGVtLCBzb3VyY2UgPSBcImFwaVwiKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlSXRlbUV2ZW50KFwiaXRlbV9yZW1vdmVkXCIsIGtleSwgbnVsbCwgeyBwcmV2aW91c0l0ZW0sIHNvdXJjZSB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0gcmV0cmlldmVkIGV2ZW50XG4gICAqL1xuICBzdGF0aWMgaXRlbVJldHJpZXZlZChrZXksIGl0ZW0sIHNvdXJjZSA9IFwiYXBpXCIpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJdGVtRXZlbnQoXCJpdGVtX3JldHJpZXZlZFwiLCBrZXksIGl0ZW0sIHsgc291cmNlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbSBzZXQgZXZlbnQgKGRpcmVjdCBjYWNoZSBvcGVyYXRpb24pXG4gICAqL1xuICBzdGF0aWMgaXRlbVNldChrZXksIGl0ZW0sIHByZXZpb3VzSXRlbSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUl0ZW1FdmVudChcIml0ZW1fc2V0XCIsIGtleSwgaXRlbSwge1xuICAgICAgcHJldmlvdXNJdGVtLFxuICAgICAgc291cmNlOiBcImNhY2hlXCJcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2xvZ2dlci50c1xuaW1wb3J0IExvZ2dpbmcgZnJvbSBcIkBmamVsbC9sb2dnaW5nXCI7XG52YXIgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoXCJAZmplbGwvY2FjaGVcIik7XG52YXIgbG9nZ2VyX2RlZmF1bHQgPSBMaWJMb2dnZXI7XG5cbi8vIHNyYy9vcHMvYWxsLnRzXG52YXIgbG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYWxsXCIpO1xudmFyIGFsbCA9IGFzeW5jIChxdWVyeSA9IHt9LCBsb2NhdGlvbnMgPSBbXSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgdHRsTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoXCJhbGxcIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICBjb25zdCBxdWVyeUhhc2ggPSBjcmVhdGVRdWVyeUhhc2gocGtUeXBlLCBxdWVyeSwgbG9jYXRpb25zKTtcbiAgbG9nZ2VyLmRlYnVnKFwiR2VuZXJhdGVkIHF1ZXJ5IGhhc2ggZm9yIGFsbFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgY29uc3QgY2FjaGVkSXRlbUtleXMgPSBhd2FpdCBjYWNoZU1hcC5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICBpZiAoY2FjaGVkSXRlbUtleXMpIHtcbiAgICBsb2dnZXIuZGVidWcoXCJVc2luZyBjYWNoZWQgcXVlcnkgcmVzdWx0c1wiLCB7IGNhY2hlZEtleUNvdW50OiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggfSk7XG4gICAgY29uc3QgY2FjaGVkSXRlbXMgPSBbXTtcbiAgICBsZXQgYWxsSXRlbXNBdmFpbGFibGUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaXRlbUtleSBvZiBjYWNoZWRJdGVtS2V5cykge1xuICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChpdGVtS2V5KTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNhY2hlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxJdGVtc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbEl0ZW1zQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsoY2FjaGVkSXRlbXMsIHBrVHlwZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJTb21lIGNhY2hlZCBpdGVtcyBtaXNzaW5nLCBpbnZhbGlkYXRpbmcgcXVlcnkgY2FjaGVcIik7XG4gICAgICBjYWNoZU1hcC5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH1cbiAgfVxuICBsZXQgcmV0ID0gW107XG4gIHRyeSB7XG4gICAgcmV0ID0gYXdhaXQgYXBpLmFsbChxdWVyeSwgbG9jYXRpb25zKTtcbiAgICByZXQuZm9yRWFjaCgodikgPT4ge1xuICAgICAgY2FjaGVNYXAuc2V0KHYua2V5LCB2KTtcbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHYua2V5KTtcbiAgICAgIHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG4gICAgICBjb25zdCBldmljdGVkS2V5cyA9IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdiwgY2FjaGVNYXApO1xuICAgICAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgICBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGl0ZW1LZXlzID0gcmV0Lm1hcCgoaXRlbSkgPT4gaXRlbS5rZXkpO1xuICAgIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkNhY2hlZCBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGl0ZW1LZXlDb3VudDogaXRlbUtleXMubGVuZ3RoIH0pO1xuICAgIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuY3JlYXRlUXVlcnlFdmVudChxdWVyeSwgbG9jYXRpb25zLCByZXQpO1xuICAgIGNvbnRleHQuZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSB7XG4gICAgICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtdKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNhY2hlZCBlbXB0eSBxdWVyeSByZXN1bHQgZm9yIG5vdCBmb3VuZFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKHJldCwgcGtUeXBlKV07XG59O1xuXG4vLyBzcmMvb3BzL29uZS50c1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVQSyBhcyB2YWxpZGF0ZVBLMlxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IE5vdEZvdW5kRXJyb3IgYXMgTm90Rm91bmRFcnJvcjIgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG52YXIgbG9nZ2VyMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIm9uZVwiKTtcbnZhciBvbmUgPSBhc3luYyAocXVlcnkgPSB7fSwgbG9jYXRpb25zID0gW10sIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUsIHR0bE1hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlcjIuZGVmYXVsdChcIm9uZVwiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gIGNvbnN0IHF1ZXJ5SGFzaCA9IGNyZWF0ZVF1ZXJ5SGFzaChwa1R5cGUsIHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICBsb2dnZXIyLmRlYnVnKFwiR2VuZXJhdGVkIHF1ZXJ5IGhhc2ggZm9yIG9uZVwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgY29uc3QgY2FjaGVkSXRlbUtleXMgPSBhd2FpdCBjYWNoZU1hcC5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICBpZiAoY2FjaGVkSXRlbUtleXMpIHtcbiAgICBsb2dnZXIyLmRlYnVnKFwiVXNpbmcgY2FjaGVkIHF1ZXJ5IHJlc3VsdHNcIiwgeyBjYWNoZWRLZXlDb3VudDogY2FjaGVkSXRlbUtleXMubGVuZ3RoIH0pO1xuICAgIGlmIChjYWNoZWRJdGVtS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgbnVsbF07XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoY2FjaGVkSXRlbUtleXNbMF0pO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsyKGl0ZW0sIHBrVHlwZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiQ2FjaGVkIGl0ZW0gbWlzc2luZywgaW52YWxpZGF0aW5nIHF1ZXJ5IGNhY2hlXCIpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJldEl0ZW0gPSBudWxsO1xuICB0cnkge1xuICAgIHJldEl0ZW0gPSBhd2FpdCBhcGkub25lKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIGlmIChyZXRJdGVtKSB7XG4gICAgICBjYWNoZU1hcC5zZXQocmV0SXRlbS5rZXksIHJldEl0ZW0pO1xuICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkocmV0SXRlbS5rZXkpO1xuICAgICAgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCByZXRJdGVtLCBjYWNoZU1hcCk7XG4gICAgICBldmljdGVkS2V5cy5mb3JFYWNoKChldmljdGVkS2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICAgIGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgICAgfSk7XG4gICAgICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtyZXRJdGVtLmtleV0pO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIkNhY2hlZCBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGl0ZW1LZXk6IHJldEl0ZW0ua2V5IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtdKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJDYWNoZWQgZW1wdHkgcXVlcnkgcmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcjIpIHtcbiAgICAgIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW10pO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIkNhY2hlZCBlbXB0eSBxdWVyeSByZXN1bHQgZm9yIG5vdCBmb3VuZFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBjb250ZXh0LFxuICAgIHJldEl0ZW0gPyB2YWxpZGF0ZVBLMihyZXRJdGVtLCBwa1R5cGUpIDogbnVsbFxuICBdO1xufTtcblxuLy8gc3JjL29wcy9jcmVhdGUudHNcbmltcG9ydCB7XG4gIHZhbGlkYXRlUEsgYXMgdmFsaWRhdGVQSzNcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG52YXIgbG9nZ2VyMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImNyZWF0ZVwiKTtcbnZhciBjcmVhdGUgPSBhc3luYyAodiwgbG9jYXRpb25zID0gW10sIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUsIGV2ZW50RW1pdHRlciwgdHRsTWFuYWdlciwgZXZpY3Rpb25NYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIzLmRlZmF1bHQoXCJjcmVhdGVcIiwgeyB2LCBsb2NhdGlvbnMgfSk7XG4gIGNvbnN0IGNyZWF0ZWQgPSBhd2FpdCBhcGkuY3JlYXRlKHYsIGxvY2F0aW9ucyk7XG4gIGNhY2hlTWFwLnNldChjcmVhdGVkLmtleSwgY3JlYXRlZCk7XG4gIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGNyZWF0ZWQua2V5KTtcbiAgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgY29uc3QgZXZpY3RlZEtleXMgPSBldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjcmVhdGVkLCBjYWNoZU1hcCk7XG4gIGV2aWN0ZWRLZXlzLmZvckVhY2goKGV2aWN0ZWRLZXkpID0+IHtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgIGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICB9KTtcbiAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtQ3JlYXRlZChjcmVhdGVkLmtleSwgY3JlYXRlZCwgXCJhcGlcIik7XG4gIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLMyhjcmVhdGVkLCBwa1R5cGUpXTtcbn07XG5cbi8vIHNyYy9vcHMvZ2V0LnRzXG5pbXBvcnQge1xuICBpc1ZhbGlkSXRlbUtleSxcbiAgdmFsaWRhdGVQSyBhcyB2YWxpZGF0ZVBLNFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcblxuLy8gc3JjL3V0aWxzL0NhY2hlU2l6ZS50c1xuaW1wb3J0IHNhZmVTdHJpbmdpZnkgZnJvbSBcImZhc3Qtc2FmZS1zdHJpbmdpZnlcIjtcbnZhciBTSVpFX1VOSVRTID0ge1xuICAvLyBEZWNpbWFsIHVuaXRzIChwb3dlcnMgb2YgMTAwMClcbiAgXCJiXCI6IDEsXG4gIFwiYnl0ZVwiOiAxLFxuICBcImJ5dGVzXCI6IDEsXG4gIFwia2JcIjogMWUzLFxuICBcImtpbG9ieXRlXCI6IDFlMyxcbiAgXCJraWxvYnl0ZXNcIjogMWUzLFxuICBcIm1iXCI6IDFlMyAqIDFlMyxcbiAgXCJtZWdhYnl0ZVwiOiAxZTMgKiAxZTMsXG4gIFwibWVnYWJ5dGVzXCI6IDFlMyAqIDFlMyxcbiAgXCJnYlwiOiAxZTMgKiAxZTMgKiAxZTMsXG4gIFwiZ2lnYWJ5dGVcIjogMWUzICogMWUzICogMWUzLFxuICBcImdpZ2FieXRlc1wiOiAxZTMgKiAxZTMgKiAxZTMsXG4gIFwidGJcIjogMWUzICogMWUzICogMWUzICogMWUzLFxuICBcInRlcmFieXRlXCI6IDFlMyAqIDFlMyAqIDFlMyAqIDFlMyxcbiAgXCJ0ZXJhYnl0ZXNcIjogMWUzICogMWUzICogMWUzICogMWUzLFxuICAvLyBCaW5hcnkgdW5pdHMgKHBvd2VycyBvZiAxMDI0KVxuICBcImtpYlwiOiAxMDI0LFxuICBcImtpYmlieXRlXCI6IDEwMjQsXG4gIFwia2liaWJ5dGVzXCI6IDEwMjQsXG4gIFwibWliXCI6IDEwMjQgKiAxMDI0LFxuICBcIm1lYmlieXRlXCI6IDEwMjQgKiAxMDI0LFxuICBcIm1lYmlieXRlc1wiOiAxMDI0ICogMTAyNCxcbiAgXCJnaWJcIjogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICBcImdpYmlieXRlXCI6IDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgXCJnaWJpYnl0ZXNcIjogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICBcInRpYlwiOiAxMDI0ICogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICBcInRlYmlieXRlXCI6IDEwMjQgKiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gIFwidGViaWJ5dGVzXCI6IDEwMjQgKiAxMDI0ICogMTAyNCAqIDEwMjRcbn07XG5mdW5jdGlvbiBwYXJzZVNpemVTdHJpbmcoc2l6ZVN0cikge1xuICBpZiAoIXNpemVTdHIgfHwgdHlwZW9mIHNpemVTdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIHN0cmluZyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtcbiAgfVxuICBjb25zdCB0cmltbWVkID0gc2l6ZVN0ci50cmltKCk7XG4gIGlmICgvXlxcZCsoXFwuXFxkKyk/JC8udGVzdCh0cmltbWVkKSkge1xuICAgIGNvbnN0IGJ5dGVzID0gcGFyc2VGbG9hdCh0cmltbWVkKTtcbiAgICBpZiAoaXNOYU4oYnl0ZXMpIHx8IGJ5dGVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemUgdmFsdWU6ICR7c2l6ZVN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoYnl0ZXMpO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaCgvXihcXGQrKD86XFwuXFxkKyk/KVxccyooW2EtekEtWl0rKSQvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaXplIGZvcm1hdDogJHtzaXplU3RyfS4gRXhwZWN0ZWQgZm9ybWF0OiAnMTAwJywgJzVLQicsICcxME1CJywgZXRjLmApO1xuICB9XG4gIGNvbnN0IFssIHZhbHVlU3RyLCB1bml0U3RyXSA9IG1hdGNoO1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWVTdHIpO1xuICBjb25zdCB1bml0ID0gdW5pdFN0ci50b0xvd2VyQ2FzZSgpO1xuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaXplIHZhbHVlOiAke3ZhbHVlU3RyfWApO1xuICB9XG4gIGNvbnN0IG11bHRpcGxpZXIgPSBTSVpFX1VOSVRTW3VuaXRdO1xuICBpZiAoISh1bml0IGluIFNJWkVfVU5JVFMpKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkVW5pdHMgPSBPYmplY3Qua2V5cyhTSVpFX1VOSVRTKS5maWx0ZXIoKHUpID0+IHUubGVuZ3RoIDw9IDMpLmpvaW4oXCIsIFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNpemUgdW5pdDogJHt1bml0U3RyfS4gU3VwcG9ydGVkIHVuaXRzOiAke3N1cHBvcnRlZFVuaXRzfWApO1xuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbHVlICogbXVsdGlwbGllcik7XG59XG5mdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgYmluYXJ5ID0gZmFsc2UpIHtcbiAgaWYgKGJ5dGVzID09PSAwKSByZXR1cm4gXCIwIEJcIjtcbiAgaWYgKGJ5dGVzIDwgMCkgcmV0dXJuIGAke2J5dGVzfSBCYDtcbiAgY29uc3QgayA9IGJpbmFyeSA/IDEwMjQgOiAxZTM7XG4gIGNvbnN0IHNpemVzID0gYmluYXJ5ID8gW1wiQlwiLCBcIktpQlwiLCBcIk1pQlwiLCBcIkdpQlwiLCBcIlRpQlwiLCBcIlBpQlwiXSA6IFtcIkJcIiwgXCJLQlwiLCBcIk1CXCIsIFwiR0JcIiwgXCJUQlwiLCBcIlBCXCJdO1xuICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSk7XG4gIGNvbnN0IHNpemUgPSBieXRlcyAvIE1hdGgucG93KGssIGkpO1xuICBjb25zdCBmb3JtYXR0ZWQgPSBzaXplICUgMSA9PT0gMCA/IHNpemUudG9TdHJpbmcoKSA6IHNpemUudG9GaXhlZCgxKTtcbiAgcmV0dXJuIGAke2Zvcm1hdHRlZH0gJHtzaXplc1tpXX1gO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVWYWx1ZVNpemUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiA4O1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggKiAyO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVkdWNlKCh0b3RhbCwgaXRlbSkgPT4gdG90YWwgKyBlc3RpbWF0ZVZhbHVlU2l6ZShpdGVtKSwgMjQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGFzQ2lyY3VsYXJSZWZlcmVuY2UgPSAob2JqLCBhbmNlc3RvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSwgY2hlY2tlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKSA9PiB7XG4gICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc09iamVjdCA9IG9iajtcbiAgICAgICAgaWYgKGNoZWNrZWQuaGFzKGFzT2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyhhc09iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvcnMuYWRkKGFzT2JqZWN0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhc09iamVjdCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhc09iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoaGFzQ2lyY3VsYXJSZWZlcmVuY2UoaXRlbSwgYW5jZXN0b3JzLCBjaGVja2VkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFzT2JqZWN0KSkge1xuICAgICAgICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBhc09iamVjdFtrZXldO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGFzQ2lyY3VsYXJSZWZlcmVuY2UoY2hpbGQsIGFuY2VzdG9ycywgY2hlY2tlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhbmNlc3RvcnMuZGVsZXRlKGFzT2JqZWN0KTtcbiAgICAgICAgICBjaGVja2VkLmFkZChhc09iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYXNDaXJjdWxhclJlZmVyZW5jZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gNjQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gNjQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gc2FmZVN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBqc29uU3RyaW5nLmxlbmd0aCAqIDIgKyAxNjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gNjQ7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAzMjtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVTaXplQ29uZmlnKGNvbmZpZykge1xuICBpZiAodHlwZW9mIGNvbmZpZy5tYXhTaXplQnl0ZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBwYXJzZVNpemVTdHJpbmcoY29uZmlnLm1heFNpemVCeXRlcyk7XG4gICAgICBpZiAoYnl0ZXMgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhTaXplQnl0ZXMgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1heFNpemVCeXRlczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5tYXhJdGVtcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb25maWcubWF4SXRlbXMpIHx8IGNvbmZpZy5tYXhJdGVtcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhJdGVtcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL29wcy9nZXQudHNcbnZhciBsb2dnZXI0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiZ2V0XCIpO1xudmFyIGluRmxpZ2h0UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIENMRUFOVVBfVElNRU9VVCA9IDUgKiA2MCAqIDFlMztcbnZhciBjbGVhbnVwU3RhbGVSZXF1ZXN0cyA9ICgpID0+IHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3Qga2V5c1RvRGVsZXRlID0gW107XG4gIGluRmxpZ2h0UmVxdWVzdHMuZm9yRWFjaCgocmVxdWVzdCwga2V5KSA9PiB7XG4gICAgaWYgKG5vdyAtIHJlcXVlc3QudGltZXN0YW1wID4gQ0xFQU5VUF9USU1FT1VUKSB7XG4gICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpO1xuICAgIH1cbiAgfSk7XG4gIGtleXNUb0RlbGV0ZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBsb2dnZXI0LmRlYnVnKFwiQ2xlYW5pbmcgdXAgc3RhbGUgaW4tZmxpZ2h0IHJlcXVlc3RcIiwgeyBrZXkgfSk7XG4gICAgaW5GbGlnaHRSZXF1ZXN0cy5kZWxldGUoa2V5KTtcbiAgfSk7XG59O1xudmFyIGNsZWFudXBJbnRlcnZhbCA9IHNldEludGVydmFsKGNsZWFudXBTdGFsZVJlcXVlc3RzLCA2MCAqIDFlMyk7XG52YXIga2V5VG9TdHJpbmcgPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uKCk7XG52YXIgZ2V0ID0gYXN5bmMgKGtleSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgdHRsTWFuYWdlciwgc3RhdHNNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXI0LmRlZmF1bHQoXCJnZXRcIiwgeyBrZXksIGRlZmF1bHRUVEw6IHR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpIH0pO1xuICBzdGF0c01hbmFnZXIuaW5jcmVtZW50UmVxdWVzdHMoKTtcbiAgaWYgKCFpc1ZhbGlkSXRlbUtleShrZXkpKSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIktleSBmb3IgR2V0IGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqXCIsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGZvciBHZXQgaXMgbm90IGEgdmFsaWQgSXRlbUtleVwiKTtcbiAgfVxuICBpZiAodHRsTWFuYWdlci5pc1RUTEVuYWJsZWQoKSkge1xuICAgIGNvbnN0IGtleVN0cjIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgIGNvbnN0IGNhY2hlZEl0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBpZiAoY2FjaGVkSXRlbSkge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IHR0bE1hbmFnZXIudmFsaWRhdGVJdGVtKGtleVN0cjIsIGNhY2hlTWFwKTtcbiAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgIGxvZ2dlcjQuZGVidWcoXCJDYWNoZSBoaXQgd2l0aCB2YWxpZCBUVExcIiwgeyBrZXksIGRlZmF1bHRUVEw6IHR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpIH0pO1xuICAgICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50SGl0cygpO1xuICAgICAgICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEs0KGNhY2hlZEl0ZW0sIHBrVHlwZSldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyNC5kZWJ1ZyhcIkNhY2hlIGl0ZW0gZXhwaXJlZCwgcmVtb3ZpbmdcIiwgeyBrZXkgfSk7XG4gICAgICAgIGNhY2hlTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50TWlzc2VzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRNaXNzZXMoKTtcbiAgICB9XG4gICAgbG9nZ2VyNC5kZWJ1ZyhcIkNhY2hlIG1pc3Mgb3IgZXhwaXJlZFwiLCB7IGtleSwgZGVmYXVsdFRUTDogdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCkgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FjaGVkSXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuICAgIGlmIChjYWNoZWRJdGVtKSB7XG4gICAgICBsb2dnZXI0LmRlYnVnKFwiQ2FjaGUgaGl0IChUVEwgZGlzYWJsZWQpXCIsIHsga2V5IH0pO1xuICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudEhpdHMoKTtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzQoY2FjaGVkSXRlbSwgcGtUeXBlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRNaXNzZXMoKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJldDtcbiAgY29uc3Qga2V5U3RyID0ga2V5VG9TdHJpbmcoa2V5KTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0RW50cnkgPSBpbkZsaWdodFJlcXVlc3RzLmdldChrZXlTdHIpO1xuICAgIGxldCBhcGlSZXF1ZXN0O1xuICAgIGlmICghcmVxdWVzdEVudHJ5KSB7XG4gICAgICBhcGlSZXF1ZXN0ID0gYXBpLmdldChrZXkpO1xuICAgICAgaWYgKGFwaVJlcXVlc3QgJiYgdHlwZW9mIGFwaVJlcXVlc3QudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIGluRmxpZ2h0UmVxdWVzdHMuc2V0KGtleVN0ciwgeyBwcm9taXNlOiBhcGlSZXF1ZXN0LCB0aW1lc3RhbXAgfSk7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBpbkZsaWdodFJlcXVlc3RzLmRlbGV0ZShrZXlTdHIpO1xuICAgICAgICBpZiAodHlwZW9mIGFwaVJlcXVlc3QuZmluYWxseSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgYXBpUmVxdWVzdC5maW5hbGx5KGNsZWFudXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwaVJlcXVlc3QudGhlbihjbGVhbnVwLCBjbGVhbnVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXI0LmRlYnVnKFwiVXNpbmcgaW4tZmxpZ2h0IHJlcXVlc3QgZm9yIGtleVwiLCB7IGtleSB9KTtcbiAgICAgIGFwaVJlcXVlc3QgPSByZXF1ZXN0RW50cnkucHJvbWlzZTtcbiAgICB9XG4gICAgcmV0ID0gYXdhaXQgYXBpUmVxdWVzdDtcbiAgICBpZiAocmV0KSB7XG4gICAgICBjYWNoZU1hcC5zZXQocmV0LmtleSwgcmV0KTtcbiAgICAgIGNvbnN0IGtleVN0cjIgPSBKU09OLnN0cmluZ2lmeShyZXQua2V5KTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY2FjaGVNYXAuZ2V0TWV0YWRhdGE/LihrZXlTdHIyKTtcbiAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgYmFzZU1ldGFkYXRhID0ge1xuICAgICAgICAgIGtleToga2V5U3RyMixcbiAgICAgICAgICBhZGRlZEF0OiBub3csXG4gICAgICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgICAgICBlc3RpbWF0ZWRTaXplOiBlc3RpbWF0ZVZhbHVlU2l6ZShyZXQpXG4gICAgICAgIH07XG4gICAgICAgIGNhY2hlTWFwLnNldE1ldGFkYXRhPy4oa2V5U3RyMiwgYmFzZU1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyMiwgcmV0LCBjYWNoZU1hcCk7XG4gICAgICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0cjIsIGNhY2hlTWFwKTtcbiAgICAgIGV2aWN0ZWRLZXlzLmZvckVhY2goKGV2aWN0ZWRLZXkpID0+IHtcbiAgICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgICAgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuaXRlbVJldHJpZXZlZChyZXQua2V5LCByZXQsIFwiYXBpXCIpO1xuICAgICAgY29udGV4dC5ldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaW5GbGlnaHRSZXF1ZXN0cy5kZWxldGUoa2V5U3RyKTtcbiAgICBsb2dnZXI0LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBpdGVtIGZvciBrZXlcIiwgeyBrZXksIG1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2sgfSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuICByZXR1cm4gW1xuICAgIGNvbnRleHQsXG4gICAgcmV0ID8gdmFsaWRhdGVQSzQocmV0LCBwa1R5cGUpIDogbnVsbFxuICBdO1xufTtcblxuLy8gc3JjL29wcy9yZXRyaWV2ZS50c1xuaW1wb3J0IHtcbiAgaXNWYWxpZEl0ZW1LZXkgYXMgaXNWYWxpZEl0ZW1LZXkyLFxuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEs1XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xudmFyIGxvZ2dlcjUgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJyZXRyaWV2ZVwiKTtcbnZhciByZXRyaWV2ZSA9IGFzeW5jIChrZXksIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBjYWNoZU1hcCwgcGtUeXBlLCBzdGF0c01hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlcjUuZGVmYXVsdChcInJldHJpZXZlXCIsIHsga2V5IH0pO1xuICBzdGF0c01hbmFnZXIuaW5jcmVtZW50UmVxdWVzdHMoKTtcbiAgaWYgKCFpc1ZhbGlkSXRlbUtleTIoa2V5KSkge1xuICAgIGxvZ2dlcjUuZXJyb3IoXCJLZXkgZm9yIFJldHJpZXZlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqXCIsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGZvciBSZXRyaWV2ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5XCIpO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5zSXRlbUtleSA9IGF3YWl0IGNhY2hlTWFwLmluY2x1ZGVzS2V5KGtleSk7XG4gIGxldCByZXRyaWV2ZWQ7XG4gIGxldCBjb250ZXh0VG9SZXR1cm47XG4gIGlmIChjb250YWluc0l0ZW1LZXkpIHtcbiAgICBsb2dnZXI1LmRlZmF1bHQoXCJMb29raW5nIGZvciBPYmplY3QgaW4gQ2FjaGVcIiwga2V5KTtcbiAgICByZXRyaWV2ZWQgPSBhd2FpdCBjYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBjb250ZXh0VG9SZXR1cm4gPSBudWxsO1xuICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRIaXRzKCk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyNS5kZWZhdWx0KFwiT2JqZWN0IE5vdCBGb3VuZCBpbiBDYWNoZSwgUmV0cmlldmluZyBmcm9tIFNlcnZlciBBUElcIiwgeyBrZXkgfSk7XG4gICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudE1pc3NlcygpO1xuICAgIFtjb250ZXh0VG9SZXR1cm4sIHJldHJpZXZlZF0gPSBhd2FpdCBnZXQoa2V5LCBjb250ZXh0KTtcbiAgfVxuICBjb25zdCByZXRWYWx1ZSA9IFtcbiAgICBjb250ZXh0VG9SZXR1cm4sXG4gICAgcmV0cmlldmVkID8gdmFsaWRhdGVQSzUocmV0cmlldmVkLCBwa1R5cGUpIDogbnVsbFxuICBdO1xuICByZXR1cm4gcmV0VmFsdWU7XG59O1xuXG4vLyBzcmMvb3BzL3JlbW92ZS50c1xuaW1wb3J0IHtcbiAgaXNWYWxpZEl0ZW1LZXkgYXMgaXNWYWxpZEl0ZW1LZXkzXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xudmFyIGxvZ2dlcjYgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJyZW1vdmVcIik7XG52YXIgcmVtb3ZlID0gYXN5bmMgKGtleSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlcjYuZGVmYXVsdChcInJlbW92ZVwiLCB7IGtleSB9KTtcbiAgaWYgKCFpc1ZhbGlkSXRlbUtleTMoa2V5KSkge1xuICAgIGxvZ2dlcjYuZXJyb3IoXCJLZXkgZm9yIFJlbW92ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlalwiLCBrZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleSBmb3IgUmVtb3ZlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXlcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwcmV2aW91c0l0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBhd2FpdCBhcGkucmVtb3ZlKGtleSk7XG4gICAgY2FjaGVNYXAuZGVsZXRlKGtleSk7XG4gICAgaWYgKHByZXZpb3VzSXRlbSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtUmVtb3ZlZChrZXksIHByZXZpb3VzSXRlbSwgXCJhcGlcIik7XG4gICAgICBjb250ZXh0LmV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgICB9XG4gICAgbG9nZ2VyNi5kZWJ1ZyhcIlN1Y2Nlc3NmdWxseSByZW1vdmVkIGl0ZW0gZnJvbSBBUEkgYW5kIGNhY2hlXCIsIHsga2V5IH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyNi5lcnJvcihcIkVycm9yIGRlbGV0aW5nIGl0ZW1cIiwgeyBlcnJvcjogZSB9KTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLy8gc3JjL29wcy91cGRhdGUudHNcbmltcG9ydCB7XG4gIGlzVmFsaWRJdGVtS2V5IGFzIGlzVmFsaWRJdGVtS2V5NCxcbiAgdmFsaWRhdGVQSyBhcyB2YWxpZGF0ZVBLNlxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXI3ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwidXBkYXRlXCIpO1xudmFyIHVwZGF0ZSA9IGFzeW5jIChrZXksIHYsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlcjcuZGVmYXVsdChcInVwZGF0ZVwiLCB7IGtleSwgdiB9KTtcbiAgaWYgKCFpc1ZhbGlkSXRlbUtleTQoa2V5KSkge1xuICAgIGxvZ2dlcjcuZXJyb3IoXCJLZXkgZm9yIFVwZGF0ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlalwiLCBrZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleSBmb3IgVXBkYXRlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXlcIik7XG4gIH1cbiAgbG9nZ2VyNy5kZWJ1ZyhcIkludmFsaWRhdGluZyBpdGVtIGtleSBiZWZvcmUgdXBkYXRlXCIsIHsga2V5IH0pO1xuICBjYWNoZU1hcC5pbnZhbGlkYXRlSXRlbUtleXMoW2tleV0pO1xuICB0cnkge1xuICAgIGNvbnN0IHByZXZpb3VzSXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCBhcGkudXBkYXRlKGtleSwgdik7XG4gICAgbG9nZ2VyNy5kZWJ1ZyhcIkNhY2hpbmcgdXBkYXRlIHJlc3VsdFwiLCB7IHVwZGF0ZWRLZXk6IHVwZGF0ZWQua2V5IH0pO1xuICAgIGNhY2hlTWFwLnNldCh1cGRhdGVkLmtleSwgdXBkYXRlZCk7XG4gICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkodXBkYXRlZC5rZXkpO1xuICAgIGNvbnRleHQudHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgICBjb25zdCBldmljdGVkS2V5cyA9IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdXBkYXRlZCwgY2FjaGVNYXApO1xuICAgIGV2aWN0ZWRLZXlzLmZvckVhY2goKGV2aWN0ZWRLZXkpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICB9KTtcbiAgICBjb25zdCBldmVudCA9IENhY2hlRXZlbnRGYWN0b3J5Lml0ZW1VcGRhdGVkKHVwZGF0ZWQua2V5LCB1cGRhdGVkLCBwcmV2aW91c0l0ZW0sIFwiYXBpXCIpO1xuICAgIGNvbnRleHQuZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQpO1xuICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzYodXBkYXRlZCwgcGtUeXBlKV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXI3LmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgaXRlbVwiLCB7IGVycm9yOiBlIH0pO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbi8vIHNyYy9vcHMvYWN0aW9uLnRzXG5pbXBvcnQge1xuICBpc1ZhbGlkSXRlbUtleSBhcyBpc1ZhbGlkSXRlbUtleTUsXG4gIHZhbGlkYXRlUEsgYXMgdmFsaWRhdGVQSzdcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG52YXIgbG9nZ2VyOCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFjdGlvblwiKTtcbnZhciBhY3Rpb24gPSBhc3luYyAoa2V5LCBhY3Rpb24yLCBib2R5ID0ge30sIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlcjguZGVmYXVsdChcImFjdGlvblwiLCB7IGtleSwgYWN0aW9uOiBhY3Rpb24yLCBib2R5IH0pO1xuICBpZiAoIWlzVmFsaWRJdGVtS2V5NShrZXkpKSB7XG4gICAgbG9nZ2VyOC5lcnJvcihcIktleSBmb3IgQWN0aW9uIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqXCIsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGZvciBBY3Rpb24gaXMgbm90IGEgdmFsaWQgSXRlbUtleVwiKTtcbiAgfVxuICBsb2dnZXI4LmRlYnVnKFwiSW52YWxpZGF0aW5nIGl0ZW0ga2V5IGJlZm9yZSBhY3Rpb25cIiwgeyBrZXkgfSk7XG4gIGNhY2hlTWFwLmludmFsaWRhdGVJdGVtS2V5cyhba2V5XSk7XG4gIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCBhcGkuYWN0aW9uKGtleSwgYWN0aW9uMiwgYm9keSk7XG4gIGxvZ2dlcjguZGVidWcoXCJDYWNoaW5nIGFjdGlvbiByZXN1bHRcIiwgeyB1cGRhdGVkS2V5OiB1cGRhdGVkLmtleSB9KTtcbiAgY2FjaGVNYXAuc2V0KHVwZGF0ZWQua2V5LCB1cGRhdGVkKTtcbiAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkodXBkYXRlZC5rZXkpO1xuICBjb250ZXh0LnR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG4gIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB1cGRhdGVkLCBjYWNoZU1hcCk7XG4gIGV2aWN0ZWRLZXlzLmZvckVhY2goKGV2aWN0ZWRLZXkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgIGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXI4LmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGV2aWN0ZWQga2V5IGR1cmluZyBkZWxldGlvblwiLCB7XG4gICAgICAgIGV2aWN0ZWRLZXksXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzcodXBkYXRlZCwgcGtUeXBlKV07XG59O1xuXG4vLyBzcmMvb3BzL2FsbEFjdGlvbi50c1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVQSyBhcyB2YWxpZGF0ZVBLOFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IE5vdEZvdW5kRXJyb3IgYXMgTm90Rm91bmRFcnJvcjMgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG52YXIgbG9nZ2VyOSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFsbEFjdGlvblwiKTtcbnZhciBhbGxBY3Rpb24gPSBhc3luYyAoYWN0aW9uMiwgYm9keSA9IHt9LCBsb2NhdGlvbnMgPSBbXSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyOS5kZWZhdWx0KFwiYWxsQWN0aW9uXCIsIHsgYWN0aW9uOiBhY3Rpb24yLCBib2R5LCBsb2NhdGlvbnMgfSk7XG4gIGxvZ2dlcjkuZGVidWcoXCJJbnZhbGlkYXRpbmcgbG9jYXRpb24gYmVmb3JlIGFsbEFjdGlvblwiLCB7IGxvY2F0aW9ucyB9KTtcbiAgY2FjaGVNYXAuaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9ucyk7XG4gIGxldCByZXQgPSBbXTtcbiAgdHJ5IHtcbiAgICByZXQgPSBhd2FpdCBhcGkuYWxsQWN0aW9uKGFjdGlvbjIsIGJvZHksIGxvY2F0aW9ucyk7XG4gICAgbG9nZ2VyOS5kZWJ1ZyhcIkNhY2hpbmcgYWxsQWN0aW9uIHJlc3VsdHNcIiwgeyByZXN1bHRDb3VudDogcmV0Lmxlbmd0aCB9KTtcbiAgICByZXQuZm9yRWFjaCgodikgPT4ge1xuICAgICAgY2FjaGVNYXAuc2V0KHYua2V5LCB2KTtcbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHYua2V5KTtcbiAgICAgIGNvbnRleHQudHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB2LCBjYWNoZU1hcCk7XG4gICAgICBldmljdGVkS2V5cy5mb3JFYWNoKChldmljdGVkS2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICAgIGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IzKSB7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzgocmV0LCBwa1R5cGUpXTtcbn07XG5cbi8vIHNyYy9vcHMvZmFjZXQudHNcbnZhciBsb2dnZXIxMCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImZhY2V0XCIpO1xudmFyIGZhY2V0ID0gYXN5bmMgKGtleSwgZmFjZXQyLCBwYXJhbXMgPSB7fSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyMTAuZGVmYXVsdChcImZhY2V0XCIsIHsga2V5LCBmYWNldDogZmFjZXQyIH0pO1xuICBjb25zdCByZXQgPSBhd2FpdCBhcGkuZmFjZXQoa2V5LCBmYWNldDIsIHBhcmFtcyk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBzcmMvb3BzL2FsbEZhY2V0LnRzXG52YXIgbG9nZ2VyMTEgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhbGxGYWNldFwiKTtcbnZhciBhbGxGYWNldCA9IGFzeW5jIChmYWNldDIsIHBhcmFtcyA9IHt9LCBsb2NhdGlvbnMgPSBbXSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyMTEuZGVmYXVsdChcImFsbEZhY2V0XCIsIHsgZmFjZXQ6IGZhY2V0MiwgcGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gIGNvbnN0IHJldCA9IGF3YWl0IGFwaS5hbGxGYWNldChmYWNldDIsIHBhcmFtcywgbG9jYXRpb25zKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIHNyYy9vcHMvZmluZC50c1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVQSyBhcyB2YWxpZGF0ZVBLOVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXIxMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImZpbmRcIik7XG52YXIgZmluZCA9IGFzeW5jIChmaW5kZXIsIHBhcmFtcyA9IHt9LCBsb2NhdGlvbnMgPSBbXSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgdHRsTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyMTIuZGVmYXVsdChcImZpbmRcIiwgeyBmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zIH0pO1xuICBjb25zdCBxdWVyeUhhc2ggPSBjcmVhdGVGaW5kZXJIYXNoKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMpO1xuICBsb2dnZXIxMi5kZWJ1ZyhcIkdlbmVyYXRlZCBxdWVyeSBoYXNoIGZvciBmaW5kXCIsIHsgcXVlcnlIYXNoIH0pO1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cykge1xuICAgIGxvZ2dlcjEyLmRlYnVnKFwiVXNpbmcgY2FjaGVkIHF1ZXJ5IHJlc3VsdHNcIiwgeyBjYWNoZWRLZXlDb3VudDogY2FjaGVkSXRlbUtleXMubGVuZ3RoIH0pO1xuICAgIGNvbnN0IGNhY2hlZEl0ZW1zID0gW107XG4gICAgbGV0IGFsbEl0ZW1zQXZhaWxhYmxlID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGl0ZW1LZXkgb2YgY2FjaGVkSXRlbUtleXMpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoaXRlbUtleSk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBjYWNoZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsSXRlbXNBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxJdGVtc0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLOShjYWNoZWRJdGVtcywgcGtUeXBlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjEyLmRlYnVnKFwiU29tZSBjYWNoZWQgaXRlbXMgbWlzc2luZywgaW52YWxpZGF0aW5nIHF1ZXJ5IGNhY2hlXCIpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmV0ID0gYXdhaXQgYXBpLmZpbmQoZmluZGVyLCBwYXJhbXMsIGxvY2F0aW9ucyk7XG4gIHJldC5mb3JFYWNoKCh2KSA9PiB7XG4gICAgY2FjaGVNYXAuc2V0KHYua2V5LCB2KTtcbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeSh2LmtleSk7XG4gICAgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgICBjb25zdCBldmljdGVkS2V5cyA9IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdiwgY2FjaGVNYXApO1xuICAgIGV2aWN0ZWRLZXlzLmZvckVhY2goKGV2aWN0ZWRLZXkpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGl0ZW1LZXlzID0gcmV0Lm1hcCgoaXRlbSkgPT4gaXRlbS5rZXkpO1xuICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGl0ZW1LZXlzKTtcbiAgbG9nZ2VyMTIuZGVidWcoXCJDYWNoZWQgcXVlcnkgcmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBpdGVtS2V5Q291bnQ6IGl0ZW1LZXlzLmxlbmd0aCB9KTtcbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLOShyZXQsIHBrVHlwZSldO1xufTtcblxuLy8gc3JjL29wcy9maW5kT25lLnRzXG5pbXBvcnQge1xuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEsxMFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXIxMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImZpbmRPbmVcIik7XG52YXIgZmluZE9uZSA9IGFzeW5jIChmaW5kZXIsIGZpbmRlclBhcmFtcyA9IHt9LCBsb2NhdGlvbnMgPSBbXSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgdHRsTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyMTMuZGVmYXVsdChcImZpbmRPbmVcIiwgeyBmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zIH0pO1xuICBjb25zdCBxdWVyeUhhc2ggPSBjcmVhdGVGaW5kZXJIYXNoKGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMpO1xuICBsb2dnZXIxMy5kZWJ1ZyhcIkdlbmVyYXRlZCBxdWVyeSBoYXNoIGZvciBmaW5kT25lXCIsIHsgcXVlcnlIYXNoIH0pO1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cyAmJiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgbG9nZ2VyMTMuZGVidWcoXCJVc2luZyBjYWNoZWQgcXVlcnkgcmVzdWx0c1wiLCB7IGNhY2hlZEtleUNvdW50OiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChjYWNoZWRJdGVtS2V5c1swXSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzEwKGl0ZW0sIHBrVHlwZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIxMy5kZWJ1ZyhcIkNhY2hlZCBpdGVtIG1pc3NpbmcsIGludmFsaWRhdGluZyBxdWVyeSBjYWNoZVwiKTtcbiAgICAgIGNhY2hlTWFwLmRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJldCA9IGF3YWl0IGFwaS5maW5kT25lKGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMpO1xuICBjYWNoZU1hcC5zZXQocmV0LmtleSwgcmV0KTtcbiAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkocmV0LmtleSk7XG4gIHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG4gIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCByZXQsIGNhY2hlTWFwKTtcbiAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gIH0pO1xuICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtyZXQua2V5XSk7XG4gIGxvZ2dlcjEzLmRlYnVnKFwiQ2FjaGVkIHF1ZXJ5IHJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleTogcmV0LmtleSB9KTtcbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLMTAocmV0LCBwa1R5cGUpXTtcbn07XG5cbi8vIHNyYy9vcHMvc2V0LnRzXG5pbXBvcnQge1xuICBpc0l0ZW1LZXlFcXVhbCxcbiAgaXNWYWxpZEl0ZW1LZXkgYXMgaXNWYWxpZEl0ZW1LZXk2LFxuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEsxMVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXIxNCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcInNldFwiKTtcbnZhciBub3JtYWxpemVLZXlWYWx1ZTIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xudmFyIGlzSXRlbUtleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBID0gbm9ybWFsaXplS2V5KGEpO1xuICBjb25zdCBub3JtYWxpemVkQiA9IG5vcm1hbGl6ZUtleShiKTtcbiAgcmV0dXJuIGlzSXRlbUtleUVxdWFsKG5vcm1hbGl6ZWRBLCBub3JtYWxpemVkQik7XG59O1xudmFyIG5vcm1hbGl6ZUtleSA9IChrZXkpID0+IHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgbGV0IG5lZWRzTm9ybWFsaXphdGlvbiA9IGZhbHNlO1xuICAgIGxldCBub3JtYWxpemVkS2V5ID0ga2V5O1xuICAgIGlmIChcInBrXCIgaW4ga2V5ICYmIGtleS5wayAhPT0gbnVsbCAmJiB0eXBlb2Yga2V5LnBrICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBuZWVkc05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoXCJsa1wiIGluIGtleSAmJiBrZXkubGsgIT09IG51bGwgJiYgdHlwZW9mIGtleS5sayAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgbmVlZHNOb3JtYWxpemF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFwibG9jXCIgaW4ga2V5ICYmIEFycmF5LmlzQXJyYXkoa2V5LmxvYykpIHtcbiAgICAgIGZvciAoY29uc3QgbG9jSXRlbSBvZiBrZXkubG9jKSB7XG4gICAgICAgIGlmIChsb2NJdGVtICYmIFwibGtcIiBpbiBsb2NJdGVtICYmIGxvY0l0ZW0ubGsgIT09IG51bGwgJiYgdHlwZW9mIGxvY0l0ZW0ubGsgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBuZWVkc05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24pIHtcbiAgICAgIG5vcm1hbGl6ZWRLZXkgPSB7IC4uLmtleSB9O1xuICAgICAgaWYgKFwicGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIG5vcm1hbGl6ZWRLZXkucGsgIT09IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5wayA9IG5vcm1hbGl6ZUtleVZhbHVlMihub3JtYWxpemVkS2V5LnBrKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImxrXCIgaW4gbm9ybWFsaXplZEtleSAmJiBub3JtYWxpemVkS2V5LmxrICE9PSBudWxsKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubGsgPSBub3JtYWxpemVLZXlWYWx1ZTIobm9ybWFsaXplZEtleS5sayk7XG4gICAgICB9XG4gICAgICBpZiAoXCJsb2NcIiBpbiBub3JtYWxpemVkS2V5ICYmIEFycmF5LmlzQXJyYXkobm9ybWFsaXplZEtleS5sb2MpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubG9jID0gbm9ybWFsaXplZEtleS5sb2MubWFwKChsb2NJdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGxvY0l0ZW0gJiYgXCJsa1wiIGluIGxvY0l0ZW0gJiYgbG9jSXRlbS5sayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9jSXRlbS5sayAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubG9jSXRlbSwgbGs6IG5vcm1hbGl6ZUtleVZhbHVlMihsb2NJdGVtLmxrKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9jSXRlbTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkS2V5O1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xudmFyIHNldCA9IGFzeW5jIChrZXksIHYsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIGV2ZW50RW1pdHRlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyMTQuZGVmYXVsdChcInNldFwiLCB7IGtleSwgdiB9KTtcbiAgaWYgKCFpc1ZhbGlkSXRlbUtleTYoa2V5KSkge1xuICAgIGxvZ2dlcjE0LmVycm9yKFwiS2V5IGZvciBTZXQgaXMgbm90IGEgdmFsaWQgSXRlbUtleTogJWpcIiwga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgZm9yIFNldCBpcyBub3QgYSB2YWxpZCBJdGVtS2V5XCIpO1xuICB9XG4gIHZhbGlkYXRlUEsxMSh2LCBwa1R5cGUpO1xuICBpZiAoIWlzSXRlbUtleUVxdWFsTm9ybWFsaXplZChrZXksIHYua2V5KSkge1xuICAgIGxvZ2dlcjE0LmVycm9yKFwiS2V5IGRvZXMgbm90IG1hdGNoIGl0ZW0ga2V5OiAlaiAhPSAlalwiLCBrZXksIHYua2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgZG9lcyBub3QgbWF0Y2ggaXRlbSBrZXlcIik7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG4gIGNhY2hlTWFwLnNldChrZXksIHYpO1xuICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuICBjb25zdCBldmljdGVkS2V5cyA9IGV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHYsIGNhY2hlTWFwKTtcbiAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gIH0pO1xuICBjb25zdCBldmVudCA9IENhY2hlRXZlbnRGYWN0b3J5Lml0ZW1TZXQoa2V5LCB2LCBwcmV2aW91c0l0ZW0pO1xuICBldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG4gIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzExKHYsIHBrVHlwZSldO1xufTtcblxuLy8gc3JjL21lbW9yeS9NZW1vcnlDYWNoZU1hcC50c1xuaW1wb3J0IHtcbiAgaXNDb21LZXksXG4gIGlzUXVlcnlNYXRjaFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcblxuLy8gc3JjL0NhY2hlTWFwLnRzXG52YXIgQ2FjaGVNYXAgPSBjbGFzcyB7XG4gIHR5cGVzO1xuICBjb25zdHJ1Y3Rvcih0eXBlcykge1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgfVxufTtcblxuLy8gc3JjL21lbW9yeS9NZW1vcnlDYWNoZU1hcC50c1xudmFyIGxvZ2dlcjE1ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiTWVtb3J5Q2FjaGVNYXBcIik7XG52YXIgTWVtb3J5Q2FjaGVNYXAgPSBjbGFzcyBfTWVtb3J5Q2FjaGVNYXAgZXh0ZW5kcyBDYWNoZU1hcCB7XG4gIGltcGxlbWVudGF0aW9uVHlwZSA9IFwibWVtb3J5L21lbW9yeVwiO1xuICBtYXAgPSB7fTtcbiAgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjtcbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hlOiBtYXBzIHF1ZXJ5IGhhc2ggdG8gY2FjaGUgZW50cnlcbiAgcXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICAvLyBNZXRhZGF0YSBzdG9yYWdlIGZvciBldmljdGlvbiBzdHJhdGVnaWVzXG4gIG1ldGFkYXRhTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IodHlwZXMsIGluaXRpYWxEYXRhKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oKTtcbiAgICBpZiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleVN0ciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGluaXRpYWxEYXRhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IEpTT04ucGFyc2Uoa2V5U3RyKTtcbiAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIxNS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBpbml0aWFsIGRhdGEga2V5XCIsIHsga2V5U3RyLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgbG9nZ2VyMTUudHJhY2UoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIGlmIChlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXkpIHtcbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFNYXAuZ2V0KGtleVN0cik7XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGxvZ2dlcjE1LnRyYWNlKFwic2V0XCIsIHsga2V5LCB2YWx1ZSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7IG9yaWdpbmFsS2V5OiBrZXksIHZhbHVlIH07XG4gICAgaWYgKCF0aGlzLm1ldGFkYXRhTWFwLmhhcyhrZXlTdHIpKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIGtleToga2V5U3RyLFxuICAgICAgICBhZGRlZEF0OiBub3csXG4gICAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgICBlc3RpbWF0ZWRTaXplOiBlc3RpbWF0ZVZhbHVlU2l6ZSh2YWx1ZSlcbiAgICAgIH07XG4gICAgICB0aGlzLm1ldGFkYXRhTWFwLnNldChrZXlTdHIsIG1ldGFkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhTWFwLmdldChrZXlTdHIpO1xuICAgICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcbiAgICAgIG1ldGFkYXRhLmVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGluY2x1ZGVzS2V5KGtleSkge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICByZXR1cm4gISFlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXk7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIGxvZ2dlcjE1LnRyYWNlKFwiZGVsZXRlXCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICBpZiAoZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5KSB7XG4gICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShlbnRyeS5vcmlnaW5hbEtleSk7XG4gICAgICB0aGlzLm1ldGFkYXRhTWFwLmRlbGV0ZShrZXlTdHIpO1xuICAgICAgZGVsZXRlIHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgICBmb3IgKGNvbnN0IFtxdWVyeUhhc2gsIGNhY2hlRW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucXVlcnlSZXN1bHRDYWNoZSkpIHtcbiAgICAgICAgY2FjaGVFbnRyeS5pdGVtS2V5cyA9IGNhY2hlRW50cnkuaXRlbUtleXMuZmlsdGVyKChrKSA9PiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oaykgIT09IGhhc2hlZEtleSk7XG4gICAgICAgIGlmIChjYWNoZUVudHJ5Lml0ZW1LZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS5vcmlnaW5hbEtleSk7XG4gIH1cbiAgYXN5bmMgdmFsdWVzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlID0ge307XG4gIH1cbiAgYXN5bmMgYWxsSW4obG9jYXRpb25zKSB7XG4gICAgY29uc3QgYWxsVmFsdWVzID0gYXdhaXQgdGhpcy52YWx1ZXMoKTtcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyMTUuZGVidWcoXCJSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5XCIpO1xuICAgICAgcmV0dXJuIGFsbFZhbHVlcztcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMTUuZGVidWcoXCJhbGxJblwiLCB7IGxvY2F0aW9ucywgY291bnQ6IGFsbFZhbHVlcy5sZW5ndGggfSk7XG4gICAgICByZXR1cm4gYWxsVmFsdWVzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBpdGVtLmtleTtcbiAgICAgICAgaWYgKGtleSAmJiBpc0NvbUtleShrZXkpKSB7XG4gICAgICAgICAgY29uc3QgY29tS2V5ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jYXRpb25zLCBjb21LZXkubG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29udGFpbnMocXVlcnksIGxvY2F0aW9ucykge1xuICAgIGxvZ2dlcjE1LmRlYnVnKFwiY29udGFpbnNcIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5zb21lKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2goaXRlbSwgcXVlcnkpKTtcbiAgfVxuICBhc3luYyBxdWVyeUluKHF1ZXJ5LCBsb2NhdGlvbnMgPSBbXSkge1xuICAgIGxvZ2dlcjE1LmRlYnVnKFwicXVlcnlJblwiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cbiAgYXN5bmMgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgX01lbW9yeUNhY2hlTWFwKHRoaXMudHlwZXMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMua2V5cygpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY2xvbmUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtxdWVyeUhhc2gsIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpKSB7XG4gICAgICBjbG9uZS5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF0gPSB7XG4gICAgICAgIGl0ZW1LZXlzOiBbLi4uZW50cnkuaXRlbUtleXNdXG4gICAgICAgIC8vIFNoYWxsb3cgY29weSBvZiB0aGUgYXJyYXlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzIGltcGxlbWVudGF0aW9uXG4gIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpIHtcbiAgICBsb2dnZXIxNS50cmFjZShcInNldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBpdGVtS2V5cyB9KTtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGl0ZW1LZXlzOiBbLi4uaXRlbUtleXNdXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IHRvIGF2b2lkIGV4dGVybmFsIG11dGF0aW9uc1xuICAgIH07XG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF0gPSBlbnRyeTtcbiAgfVxuICBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxNS50cmFjZShcImdldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF07XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbLi4uZW50cnkuaXRlbUtleXNdO1xuICB9XG4gIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF07XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH1cbiAgZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgbG9nZ2VyMTUudHJhY2UoXCJkZWxldGVRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBkZWxldGUgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF07XG4gIH1cbiAgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXMpIHtcbiAgICBsb2dnZXIxNS5kZWJ1ZyhcImludmFsaWRhdGVJdGVtS2V5c1wiLCB7IGtleXMgfSk7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9ucykge1xuICAgIGxvZ2dlcjE1LmRlYnVnKFwiaW52YWxpZGF0ZUxvY2F0aW9uXCIsIHsgbG9jYXRpb25zIH0pO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBhbGxLZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKChrZXkpID0+ICFpc0NvbUtleShrZXkpKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKHByaW1hcnlLZXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXRlbXNJbkxvY2F0aW9uID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgICAgY29uc3Qga2V5c1RvSW52YWxpZGF0ZSA9IGl0ZW1zSW5Mb2NhdGlvbi5tYXAoKGl0ZW0pID0+IGl0ZW0ua2V5KTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXNUb0ludmFsaWRhdGUpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gIH1cbiAgY2xlYXJRdWVyeVJlc3VsdHMoKSB7XG4gICAgbG9nZ2VyMTUudHJhY2UoXCJjbGVhclF1ZXJ5UmVzdWx0c1wiKTtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUgPSB7fTtcbiAgfVxuICAvLyBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgfVxuICBzZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKSB7XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5zZXQoa2V5LCBtZXRhZGF0YSk7XG4gIH1cbiAgZGVsZXRlTWV0YWRhdGEoa2V5KSB7XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5kZWxldGUoa2V5KTtcbiAgfVxuICBnZXRBbGxNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLm1ldGFkYXRhTWFwKTtcbiAgfVxuICBjbGVhck1ldGFkYXRhKCkge1xuICAgIHRoaXMubWV0YWRhdGFNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRDdXJyZW50U2l6ZSgpIHtcbiAgICBsZXQgc2l6ZUJ5dGVzID0gMDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXModGhpcy5tYXApKSB7XG4gICAgICBzaXplQnl0ZXMgKz0gZXN0aW1hdGVWYWx1ZVNpemUoZW50cnkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUNvdW50OiBPYmplY3Qua2V5cyh0aGlzLm1hcCkubGVuZ3RoLFxuICAgICAgc2l6ZUJ5dGVzXG4gICAgfTtcbiAgfVxuICBnZXRTaXplTGltaXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhJdGVtczogbnVsbCxcbiAgICAgIG1heFNpemVCeXRlczogbnVsbFxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9tZW1vcnkvRW5oYW5jZWRNZW1vcnlDYWNoZU1hcC50c1xuaW1wb3J0IHtcbiAgaXNDb21LZXkgYXMgaXNDb21LZXkyLFxuICBpc1F1ZXJ5TWF0Y2ggYXMgaXNRdWVyeU1hdGNoMlxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXIxNiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkVuaGFuY2VkTWVtb3J5Q2FjaGVNYXBcIik7XG52YXIgRW5oYW5jZWRNZW1vcnlDYWNoZU1hcCA9IGNsYXNzIF9FbmhhbmNlZE1lbW9yeUNhY2hlTWFwIGV4dGVuZHMgQ2FjaGVNYXAge1xuICBpbXBsZW1lbnRhdGlvblR5cGUgPSBcIm1lbW9yeS9lbmhhbmNlZFwiO1xuICBtYXAgPSB7fTtcbiAgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjtcbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hlOiBtYXBzIHF1ZXJ5IGhhc2ggdG8gY2FjaGUgZW50cnlcbiAgcXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICAvLyBTaXplIHRyYWNraW5nXG4gIGN1cnJlbnRTaXplQnl0ZXMgPSAwO1xuICBjdXJyZW50SXRlbUNvdW50ID0gMDtcbiAgcXVlcnlSZXN1bHRzQ2FjaGVTaXplID0gMDtcbiAgLy8gU2l6ZSBsaW1pdHNcbiAgbWF4U2l6ZUJ5dGVzO1xuICBtYXhJdGVtcztcbiAgY29uc3RydWN0b3IodHlwZXMsIHNpemVDb25maWcsIGluaXRpYWxEYXRhKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oKTtcbiAgICBpZiAoc2l6ZUNvbmZpZz8ubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICB0aGlzLm1heFNpemVCeXRlcyA9IHBhcnNlU2l6ZVN0cmluZyhzaXplQ29uZmlnLm1heFNpemVCeXRlcyk7XG4gICAgICBsb2dnZXIxNi5kZWJ1ZyhcIkNhY2hlIHNpemUgbGltaXQgc2V0XCIsIHsgbWF4U2l6ZUJ5dGVzOiB0aGlzLm1heFNpemVCeXRlcyB9KTtcbiAgICB9XG4gICAgaWYgKHNpemVDb25maWc/Lm1heEl0ZW1zKSB7XG4gICAgICB0aGlzLm1heEl0ZW1zID0gc2l6ZUNvbmZpZy5tYXhJdGVtcztcbiAgICAgIGxvZ2dlcjE2LmRlYnVnKFwiQ2FjaGUgaXRlbSBsaW1pdCBzZXRcIiwgeyBtYXhJdGVtczogdGhpcy5tYXhJdGVtcyB9KTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxEYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXlTdHIsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbml0aWFsRGF0YSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBKU09OLnBhcnNlKGtleVN0cik7XG4gICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyMTYuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgaW5pdGlhbCBkYXRhIGtleVwiLCB7IGtleVN0ciwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0KGtleSkge1xuICAgIGxvZ2dlcjE2LnRyYWNlKFwiZ2V0XCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICBpZiAoZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5ICYmIGVudHJ5LnZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgbG9nZ2VyMTYudHJhY2UoXCJzZXRcIiwgeyBrZXksIHZhbHVlIH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZSh2YWx1ZSk7XG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgY29uc3QgaXNVcGRhdGUgPSBleGlzdGluZ0VudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihleGlzdGluZ0VudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5O1xuICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgY29uc3Qgc2l6ZURpZmYgPSBlc3RpbWF0ZWRTaXplIC0gZXhpc3RpbmdFbnRyeS5tZXRhZGF0YS5lc3RpbWF0ZWRTaXplO1xuICAgICAgdGhpcy5jdXJyZW50U2l6ZUJ5dGVzICs9IHNpemVEaWZmO1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBleGlzdGluZ0VudHJ5LnZhbHVlO1xuICAgICAgZXhpc3RpbmdFbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgZXhpc3RpbmdFbnRyeS5tZXRhZGF0YS5lc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVkU2l6ZTtcbiAgICAgIGxvZ2dlcjE2LnRyYWNlKFwiVXBkYXRlZCBleGlzdGluZyBjYWNoZSBlbnRyeVwiLCB7XG4gICAgICAgIGtleTogaGFzaGVkS2V5LFxuICAgICAgICBzaXplRGlmZixcbiAgICAgICAgY3VycmVudFNpemU6IHRoaXMuY3VycmVudFNpemVCeXRlcyxcbiAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlICE9PSB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICBhZGRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBsYXN0QWNjZXNzZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWNjZXNzQ291bnQ6IDAsXG4gICAgICAgIGVzdGltYXRlZFNpemUsXG4gICAgICAgIGtleTogaGFzaGVkS2V5XG4gICAgICB9O1xuICAgICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHtcbiAgICAgICAgb3JpZ2luYWxLZXk6IGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9O1xuICAgICAgdGhpcy5jdXJyZW50U2l6ZUJ5dGVzICs9IGVzdGltYXRlZFNpemU7XG4gICAgICB0aGlzLmN1cnJlbnRJdGVtQ291bnQrKztcbiAgICAgIGxvZ2dlcjE2LnRyYWNlKFwiQWRkZWQgbmV3IGNhY2hlIGVudHJ5XCIsIHtcbiAgICAgICAga2V5OiBoYXNoZWRLZXksXG4gICAgICAgIHNpemU6IGVzdGltYXRlZFNpemUsXG4gICAgICAgIGN1cnJlbnRTaXplOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXMsXG4gICAgICAgIGN1cnJlbnRDb3VudDogdGhpcy5jdXJyZW50SXRlbUNvdW50XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5jbHVkZXNLZXkoa2V5KSB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiAhIWVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSAmJiBlbnRyeS52YWx1ZSAhPT0gbnVsbDtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5kZWxldGVJbnRlcm5hbChrZXksIHRydWUsIFwiZmlsdGVyXCIpO1xuICB9XG4gIGRlbGV0ZUludGVybmFsKGtleSwgaW52YWxpZGF0ZVF1ZXJpZXMgPSBmYWxzZSwgaW52YWxpZGF0aW9uTW9kZSA9IFwicmVtb3ZlXCIpIHtcbiAgICBsb2dnZXIxNi50cmFjZShcImRlbGV0ZVwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgaWYgKGVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSkge1xuICAgICAgdGhpcy5jdXJyZW50U2l6ZUJ5dGVzIC09IGVudHJ5Lm1ldGFkYXRhLmVzdGltYXRlZFNpemU7XG4gICAgICB0aGlzLmN1cnJlbnRJdGVtQ291bnQtLTtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgICAgbG9nZ2VyMTYudHJhY2UoXCJEZWxldGVkIGNhY2hlIGVudHJ5XCIsIHtcbiAgICAgICAga2V5OiBoYXNoZWRLZXksXG4gICAgICAgIGZyZWVkU2l6ZTogZW50cnkubWV0YWRhdGEuZXN0aW1hdGVkU2l6ZSxcbiAgICAgICAgY3VycmVudFNpemU6IHRoaXMuY3VycmVudFNpemVCeXRlcyxcbiAgICAgICAgY3VycmVudENvdW50OiB0aGlzLmN1cnJlbnRJdGVtQ291bnRcbiAgICAgIH0pO1xuICAgICAgaWYgKGludmFsaWRhdGVRdWVyaWVzKSB7XG4gICAgICAgIGlmIChpbnZhbGlkYXRpb25Nb2RlID09PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgdGhpcy5maWx0ZXJRdWVyaWVzUmVmZXJlbmNpbmdLZXlzKFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGVRdWVyaWVzUmVmZXJlbmNpbmdLZXlzKFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSAhPT0gbnVsbCkubWFwKChlbnRyeSkgPT4gZW50cnkub3JpZ2luYWxLZXkpO1xuICB9XG4gIGFzeW5jIHZhbHVlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkudmFsdWUgIT09IG51bGwpLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBsb2dnZXIxNi5kZWJ1ZyhcIkNsZWFyaW5nIGNhY2hlXCIsIHtcbiAgICAgIGl0ZW1zQ2xlYXJlZDogdGhpcy5jdXJyZW50SXRlbUNvdW50LFxuICAgICAgYnl0ZXNGcmVlZDogdGhpcy5jdXJyZW50U2l6ZUJ5dGVzXG4gICAgfSk7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLmN1cnJlbnRTaXplQnl0ZXMgPSAwO1xuICAgIHRoaXMuY3VycmVudEl0ZW1Db3VudCA9IDA7XG4gIH1cbiAgYXN5bmMgYWxsSW4obG9jYXRpb25zKSB7XG4gICAgY29uc3QgYWxsVmFsdWVzID0gYXdhaXQgdGhpcy52YWx1ZXMoKTtcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyMTYuZGVidWcoXCJSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5XCIpO1xuICAgICAgcmV0dXJuIGFsbFZhbHVlcztcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMTYuZGVidWcoXCJhbGxJblwiLCB7IGxvY2F0aW9ucywgY291bnQ6IGFsbFZhbHVlcy5sZW5ndGggfSk7XG4gICAgICByZXR1cm4gYWxsVmFsdWVzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBpdGVtLmtleTtcbiAgICAgICAgaWYgKGtleSAmJiBpc0NvbUtleTIoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jYXRpb25zLCBrZXkubG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29udGFpbnMocXVlcnksIGxvY2F0aW9ucykge1xuICAgIGxvZ2dlcjE2LmRlYnVnKFwiY29udGFpbnNcIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5zb21lKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2gyKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cbiAgYXN5bmMgcXVlcnlJbihxdWVyeSwgbG9jYXRpb25zID0gW10pIHtcbiAgICBsb2dnZXIxNi5kZWJ1ZyhcInF1ZXJ5SW5cIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaDIoaXRlbSwgcXVlcnkpKTtcbiAgfVxuICBhc3luYyBjbG9uZSgpIHtcbiAgICBjb25zdCBzaXplQ29uZmlnID0ge307XG4gICAgaWYgKHRoaXMubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICBzaXplQ29uZmlnLm1heFNpemVCeXRlcyA9IHRoaXMubWF4U2l6ZUJ5dGVzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heEl0ZW1zKSB7XG4gICAgICBzaXplQ29uZmlnLm1heEl0ZW1zID0gdGhpcy5tYXhJdGVtcztcbiAgICB9XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgX0VuaGFuY2VkTWVtb3J5Q2FjaGVNYXAodGhpcy50eXBlcywgc2l6ZUNvbmZpZyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBjbG9uZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3F1ZXJ5SGFzaCwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucXVlcnlSZXN1bHRDYWNoZSkpIHtcbiAgICAgIGNsb25lLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgZW50cnkuaXRlbUtleXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGNhY2hlIHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgY3VycmVudFNpemVCeXRlczogdGhpcy5jdXJyZW50U2l6ZUJ5dGVzLFxuICAgICAgY3VycmVudEl0ZW1Db3VudDogdGhpcy5jdXJyZW50SXRlbUNvdW50LFxuICAgICAgbWF4U2l6ZUJ5dGVzOiB0aGlzLm1heFNpemVCeXRlcyxcbiAgICAgIG1heEl0ZW1zOiB0aGlzLm1heEl0ZW1zLFxuICAgICAgdXRpbGl6YXRpb25QZXJjZW50OiB7fVxuICAgIH07XG4gICAgaWYgKHRoaXMubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICBzdGF0cy51dGlsaXphdGlvblBlcmNlbnQuYnl0ZXMgPSB0aGlzLmN1cnJlbnRTaXplQnl0ZXMgLyB0aGlzLm1heFNpemVCeXRlcyAqIDEwMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4SXRlbXMpIHtcbiAgICAgIHN0YXRzLnV0aWxpemF0aW9uUGVyY2VudC5pdGVtcyA9IHRoaXMuY3VycmVudEl0ZW1Db3VudCAvIHRoaXMubWF4SXRlbXMgKiAxMDA7XG4gICAgfVxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzXG4gIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpIHtcbiAgICBsb2dnZXIxNi50cmFjZShcInNldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBpdGVtS2V5cyB9KTtcbiAgICBpZiAocXVlcnlIYXNoIGluIHRoaXMucXVlcnlSZXN1bHRDYWNoZSkge1xuICAgICAgdGhpcy5yZW1vdmVRdWVyeVJlc3VsdEZyb21TaXplVHJhY2tpbmcocXVlcnlIYXNoKTtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBpdGVtS2V5czogWy4uLml0ZW1LZXlzXVxuICAgICAgLy8gQ3JlYXRlIGEgY29weSB0byBhdm9pZCBleHRlcm5hbCBtdXRhdGlvbnNcbiAgICB9O1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdID0gZW50cnk7XG4gICAgdGhpcy5hZGRRdWVyeVJlc3VsdFRvU2l6ZVRyYWNraW5nKHF1ZXJ5SGFzaCwgZW50cnkpO1xuICB9XG4gIGFzeW5jIGdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGxvZ2dlcjE2LnRyYWNlKFwiZ2V0UXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5lbnRyeS5pdGVtS2V5c107XG4gIH1cbiAgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICByZXR1cm4gISFlbnRyeTtcbiAgfVxuICBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBpZiAocXVlcnlIYXNoIGluIHRoaXMucXVlcnlSZXN1bHRDYWNoZSkge1xuICAgICAgdGhpcy5yZW1vdmVRdWVyeVJlc3VsdEZyb21TaXplVHJhY2tpbmcocXVlcnlIYXNoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICB9XG4gIH1cbiAgY2xlYXJRdWVyeVJlc3VsdHMoKSB7XG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlID0ge307XG4gICAgdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemUgPSAwO1xuICB9XG4gIGludmFsaWRhdGVJdGVtS2V5cyhrZXlzKSB7XG4gICAgbG9nZ2VyMTYuZGVidWcoXCJpbnZhbGlkYXRlSXRlbUtleXNcIiwgeyBrZXlzIH0pO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5kZWxldGVJbnRlcm5hbChrZXksIGZhbHNlKTtcbiAgICB9KTtcbiAgICB0aGlzLmludmFsaWRhdGVRdWVyaWVzUmVmZXJlbmNpbmdLZXlzKGtleXMpO1xuICB9XG4gIGZpbHRlclF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoa2V5cykge1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWRLZXlzVG9JbnZhbGlkYXRlID0gbmV3IFNldChrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KSkpO1xuICAgIGNvbnN0IHF1ZXJpZXNUb1JlbW92ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgW3F1ZXJ5SGFzaCwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucXVlcnlSZXN1bHRDYWNoZSkpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkS2V5cyA9IGVudHJ5Lml0ZW1LZXlzLmZpbHRlcigoaXRlbUtleSkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoZWRJdGVtS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGl0ZW1LZXkpO1xuICAgICAgICByZXR1cm4gIWhhc2hlZEtleXNUb0ludmFsaWRhdGUuaGFzKGhhc2hlZEl0ZW1LZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZmlsdGVyZWRLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBxdWVyaWVzVG9SZW1vdmUucHVzaChxdWVyeUhhc2gpO1xuICAgICAgfSBlbHNlIGlmIChmaWx0ZXJlZEtleXMubGVuZ3RoICE9PSBlbnRyeS5pdGVtS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGZpbHRlcmVkS2V5cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXJpZXNUb1JlbW92ZS5mb3JFYWNoKChxdWVyeUhhc2gpID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9KTtcbiAgfVxuICBpbnZhbGlkYXRlUXVlcmllc1JlZmVyZW5jaW5nS2V5cyhrZXlzKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZEtleXNUb0ludmFsaWRhdGUgPSBuZXcgU2V0KGtleXMubWFwKChrZXkpID0+IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSk7XG4gICAgY29uc3QgcXVlcmllc1RvUmVtb3ZlID0gW107XG4gICAgZm9yIChjb25zdCBbcXVlcnlIYXNoLCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5xdWVyeVJlc3VsdENhY2hlKSkge1xuICAgICAgY29uc3QgcXVlcnlSZWZlcmVuY2VzSW52YWxpZGF0ZWRLZXkgPSBlbnRyeS5pdGVtS2V5cy5zb21lKChpdGVtS2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZEl0ZW1LZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oaXRlbUtleSk7XG4gICAgICAgIHJldHVybiBoYXNoZWRLZXlzVG9JbnZhbGlkYXRlLmhhcyhoYXNoZWRJdGVtS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHF1ZXJ5UmVmZXJlbmNlc0ludmFsaWRhdGVkS2V5KSB7XG4gICAgICAgIHF1ZXJpZXNUb1JlbW92ZS5wdXNoKHF1ZXJ5SGFzaCk7XG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXJpZXNUb1JlbW92ZS5mb3JFYWNoKChxdWVyeUhhc2gpID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTYuZGVidWcoXCJpbnZhbGlkYXRlTG9jYXRpb25cIiwgeyBsb2NhdGlvbnMgfSk7XG4gICAgbGV0IGtleXNUb0ludmFsaWRhdGUgPSBbXTtcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgYWxsS2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBhbGxLZXlzLmZpbHRlcigoa2V5KSA9PiAhaXNDb21LZXkyKGtleSkpO1xuICAgICAga2V5c1RvSW52YWxpZGF0ZSA9IHByaW1hcnlLZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVtc0luTG9jYXRpb24gPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgICBrZXlzVG9JbnZhbGlkYXRlID0gaXRlbXNJbkxvY2F0aW9uLm1hcCgoaXRlbSkgPT4gaXRlbS5rZXkpO1xuICAgIH1cbiAgICB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgfVxuICAvKipcbiAgICogQWRkIHF1ZXJ5IHJlc3VsdCB0byBzaXplIHRyYWNraW5nXG4gICAqL1xuICBhZGRRdWVyeVJlc3VsdFRvU2l6ZVRyYWNraW5nKHF1ZXJ5SGFzaCwgZW50cnkpIHtcbiAgICBjb25zdCBoYXNoU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKHF1ZXJ5SGFzaCk7XG4gICAgY29uc3QgaXRlbUtleXNTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUoZW50cnkuaXRlbUtleXMpO1xuICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGhhc2hTaXplICsgaXRlbUtleXNTaXplO1xuICAgIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplICs9IHRvdGFsU2l6ZTtcbiAgICBsb2dnZXIxNi50cmFjZShcIkFkZGVkIHF1ZXJ5IHJlc3VsdCB0byBzaXplIHRyYWNraW5nXCIsIHtcbiAgICAgIHF1ZXJ5SGFzaCxcbiAgICAgIGVzdGltYXRlZFNpemU6IHRvdGFsU2l6ZSxcbiAgICAgIHRvdGFsUXVlcnlDYWNoZVNpemU6IHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBxdWVyeSByZXN1bHQgZnJvbSBzaXplIHRyYWNraW5nXG4gICAqL1xuICByZW1vdmVRdWVyeVJlc3VsdEZyb21TaXplVHJhY2tpbmcocXVlcnlIYXNoKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGNvbnN0IGhhc2hTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUocXVlcnlIYXNoKTtcbiAgICAgIGNvbnN0IGl0ZW1LZXlzU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKGVudHJ5Lml0ZW1LZXlzKTtcbiAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGhhc2hTaXplICsgaXRlbUtleXNTaXplO1xuICAgICAgdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemUgPSBNYXRoLm1heCgwLCB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZSAtIHRvdGFsU2l6ZSk7XG4gICAgICBsb2dnZXIxNi50cmFjZShcIlJlbW92ZWQgcXVlcnkgcmVzdWx0IGZyb20gc2l6ZSB0cmFja2luZ1wiLCB7XG4gICAgICAgIHF1ZXJ5SGFzaCxcbiAgICAgICAgZXN0aW1hdGVkU2l6ZTogdG90YWxTaXplLFxuICAgICAgICB0b3RhbFF1ZXJ5Q2FjaGVTaXplOiB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdG90YWwgY2FjaGUgc2l6ZSBpbmNsdWRpbmcgcXVlcnkgcmVzdWx0c1xuICAgKi9cbiAgZ2V0VG90YWxTaXplQnl0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNpemVCeXRlcyArIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplO1xuICB9XG4gIC8vIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciBpbXBsZW1lbnRhdGlvblxuICBnZXRNZXRhZGF0YShrZXkpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2tleV07XG4gICAgaWYgKGVudHJ5ICYmICFlbnRyeS5tZXRhZGF0YUNsZWFyZWQpIHtcbiAgICAgIHJldHVybiBlbnRyeS5tZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBba2V5XTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5Lm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICBlbnRyeS5tZXRhZGF0YUNsZWFyZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG9yaWdpbmFsS2V5O1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3JpZ2luYWxLZXkgPSBKU09OLnBhcnNlKGtleSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgb3JpZ2luYWxLZXkgPSB7IGt0OiBcIm1ldGFkYXRhLW9ubHlcIiwgcGs6IGtleSB9O1xuICAgICAgfVxuICAgICAgdGhpcy5tYXBba2V5XSA9IHtcbiAgICAgICAgb3JpZ2luYWxLZXksXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAvLyBQbGFjZWhvbGRlciB2YWx1ZVxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbWV0YWRhdGFDbGVhcmVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZGVsZXRlTWV0YWRhdGEoX2tleSkge1xuICB9XG4gIGdldEFsbE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtoYXNoZWRLZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm1hcCkpIHtcbiAgICAgIGlmICghZW50cnkubWV0YWRhdGFDbGVhcmVkKSB7XG4gICAgICAgIG1ldGFkYXRhLnNldChoYXNoZWRLZXksIGVudHJ5Lm1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG4gIGNsZWFyTWV0YWRhdGEoKSB7XG4gICAgY29uc3Qga2V5c1RvUmVtb3ZlID0gW107XG4gICAgZm9yIChjb25zdCBbaGFzaGVkS2V5LCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5tYXApKSB7XG4gICAgICBpZiAoZW50cnkudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goaGFzaGVkS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5Lm1ldGFkYXRhQ2xlYXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb1JlbW92ZSkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW2tleV07XG4gICAgfVxuICB9XG4gIGdldEN1cnJlbnRTaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtQ291bnQ6IHRoaXMuY3VycmVudEl0ZW1Db3VudCxcbiAgICAgIHNpemVCeXRlczogdGhpcy5jdXJyZW50U2l6ZUJ5dGVzXG4gICAgfTtcbiAgfVxuICBnZXRTaXplTGltaXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhJdGVtczogdGhpcy5tYXhJdGVtcyA/PyBudWxsLFxuICAgICAgbWF4U2l6ZUJ5dGVzOiB0aGlzLm1heFNpemVCeXRlcyA/PyBudWxsXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2Jyb3dzZXIvTG9jYWxTdG9yYWdlQ2FjaGVNYXAudHNcbmltcG9ydCB7XG4gIGlzQ29tS2V5IGFzIGlzQ29tS2V5MyxcbiAgaXNRdWVyeU1hdGNoIGFzIGlzUXVlcnlNYXRjaDNcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG52YXIgbG9nZ2VyMTcgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJMb2NhbFN0b3JhZ2VDYWNoZU1hcFwiKTtcbnZhciBMb2NhbFN0b3JhZ2VDYWNoZU1hcCA9IGNsYXNzIF9Mb2NhbFN0b3JhZ2VDYWNoZU1hcCBleHRlbmRzIENhY2hlTWFwIHtcbiAgaW1wbGVtZW50YXRpb25UeXBlID0gXCJicm93c2VyL2xvY2FsU3RvcmFnZVwiO1xuICBrZXlQcmVmaXg7XG4gIG5vcm1hbGl6ZWRIYXNoRnVuY3Rpb247XG4gIE1BWF9SRVRSWV9BVFRFTVBUUyA9IDM7XG4gIEFHR1JFU1NJVkVfQ0xFQU5VUF9QRVJDRU5UQUdFID0gMC41O1xuICAvLyBSZW1vdmUgNTAlIG9mIGVudHJpZXMgd2hlbiBxdW90YSBleGNlZWRlZFxuICBjb25zdHJ1Y3Rvcih0eXBlcywga2V5UHJlZml4ID0gXCJmamVsbC1jYWNoZVwiKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oKTtcbiAgfVxuICBnZXRTdG9yYWdlS2V5KGtleSkge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIHJldHVybiBgJHt0aGlzLmtleVByZWZpeH06JHtoYXNoZWRLZXl9YDtcbiAgfVxuICBpc1F1b3RhRXhjZWVkZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciAmJiAoZXJyb3IubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fCBlcnJvci5uYW1lID09PSBcIk5TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEXCIgfHwgZXJyb3IuY29kZSA9PT0gMjIgfHwgZXJyb3IuY29kZSA9PT0gMTAxNCk7XG4gIH1cbiAgZ2V0QWxsS2V5c1N0YXJ0aW5nV2l0aChwcmVmaXgpIHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGtleXMgYnkgcHJlZml4IGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgcHJlZml4LCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICB0cnlDbGVhbnVwT2xkRW50cmllcyhhZ2dyZXNzaXZlID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsRW50cmllcyA9IHRoaXMuY29sbGVjdENhY2hlRW50cmllcygpO1xuICAgICAgaWYgKGFsbEVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxvZ2dlcjE3LmRlYnVnKFwiTm8gZW50cmllcyB0byBjbGVhbiB1cFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlT2xkZXN0RW50cmllcyhhbGxFbnRyaWVzLCBhZ2dyZXNzaXZlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJGYWlsZWQgdG8gY2xlYW51cCBvbGQgbG9jYWxTdG9yYWdlIGVudHJpZXNcIiwgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY29sbGVjdENhY2hlRW50cmllcygpIHtcbiAgICBjb25zdCBhbGxFbnRyaWVzID0gW107XG4gICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoa2V5LmluY2x1ZGVzKFwiOm1ldGFkYXRhOlwiKSB8fCBrZXkuaW5jbHVkZXMoXCI6cXVlcnk6XCIpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBpZiAocGFyc2VkICYmIHR5cGVvZiBwYXJzZWQgPT09IFwib2JqZWN0XCIgJiYgXCJvcmlnaW5hbEtleVwiIGluIHBhcnNlZCkge1xuICAgICAgICAgICAgYWxsRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IHBhcnNlZC50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgc2l6ZTogc3RvcmVkLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsbEVudHJpZXMucHVzaCh7IGtleSwgdGltZXN0YW1wOiAwLCBzaXplOiBzdG9yZWQubGVuZ3RoIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyMTcuZGVidWcoXCJGb3VuZCBjb3JydXB0ZWQgZW50cnkgZHVyaW5nIGNsZWFudXBcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgICBhbGxFbnRyaWVzLnB1c2goeyBrZXksIHRpbWVzdGFtcDogMCwgc2l6ZTogMCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbEVudHJpZXM7XG4gIH1cbiAgcmVtb3ZlT2xkZXN0RW50cmllcyhhbGxFbnRyaWVzLCBhZ2dyZXNzaXZlID0gZmFsc2UpIHtcbiAgICBhbGxFbnRyaWVzLnNvcnQoKGEsIGIpID0+IGEudGltZXN0YW1wIC0gYi50aW1lc3RhbXApO1xuICAgIGNvbnN0IGNsZWFudXBQZXJjZW50YWdlID0gYWdncmVzc2l2ZSA/IHRoaXMuQUdHUkVTU0lWRV9DTEVBTlVQX1BFUkNFTlRBR0UgOiAwLjI1O1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGFsbEVudHJpZXMubGVuZ3RoICogY2xlYW51cFBlcmNlbnRhZ2UpKTtcbiAgICBsZXQgcmVtb3ZlZENvdW50ID0gMDtcbiAgICBsZXQgcmVtb3ZlZFNpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUgJiYgaSA8IGFsbEVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFsbEVudHJpZXNbaV0ua2V5O1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICByZW1vdmVkQ291bnQrKztcbiAgICAgICAgcmVtb3ZlZFNpemUgKz0gYWxsRW50cmllc1tpXS5zaXplO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJGYWlsZWQgdG8gcmVtb3ZlIGVudHJ5IGR1cmluZyBjbGVhbnVwXCIsIHsga2V5OiBhbGxFbnRyaWVzW2ldLmtleSwgZXJyb3IgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVkQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCBjbGVhbnVwVHlwZSA9IGFnZ3Jlc3NpdmUgPyBcImFnZ3Jlc3NpdmVcIiA6IFwibm9ybWFsXCI7XG4gICAgICBsb2dnZXIxNy5pbmZvKGBDbGVhbmVkIHVwICR7cmVtb3ZlZENvdW50fSBvbGQgbG9jYWxTdG9yYWdlIGVudHJpZXMgKCR7cmVtb3ZlZFNpemV9IGJ5dGVzKSB1c2luZyAke2NsZWFudXBUeXBlfSBjbGVhbnVwIHRvIGZyZWUgc3BhY2VgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWRDb3VudCA+IDA7XG4gIH1cbiAgZ2V0QWxsU3RvcmFnZUtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsS2V5c1N0YXJ0aW5nV2l0aChgJHt0aGlzLmtleVByZWZpeH06YCk7XG4gIH1cbiAgYXN5bmMgZ2V0KGtleSkge1xuICAgIGxvZ2dlcjE3LnRyYWNlKFwiZ2V0XCIsIHsga2V5IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBsZXQgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICBpZiAoIXN0b3JlZCAmJiB0eXBlb2Yga2V5Py5rdCA9PT0gXCJzdHJpbmdcIiAmJiBrZXk/LnBrKSB7XG4gICAgICAgIGNvbnN0IGxlZ2FjeUtleSA9IGAke3RoaXMua2V5UHJlZml4fToke2tleS5rdH06JHtrZXkucGt9YDtcbiAgICAgICAgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obGVnYWN5S2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpID09PSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIxNy5kZWJ1ZyhcIkZhaWxlZCB0byBwYXJzZSBzdG9yZWQgdmFsdWVcIiwgeyBrZXksIGVycm9yOiBwYXJzZUVycm9yIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciByZXRyaWV2aW5nIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGxvZ2dlcjE3LnRyYWNlKFwic2V0XCIsIHsga2V5LCB2YWx1ZSB9KTtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHRoaXMuTUFYX1JFVFJZX0FUVEVNUFRTOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgICAgY29uc3QgdG9TdG9yZSA9IHtcbiAgICAgICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeSh0b1N0b3JlKSk7XG4gICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgIGxvZ2dlcjE3LmluZm8oYFN1Y2Nlc3NmdWxseSBzdG9yZWQgaXRlbSBhZnRlciAke2F0dGVtcHR9IHJldHJpZXNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBpc0xhc3RBdHRlbXB0ID0gYXR0ZW1wdCA9PT0gdGhpcy5NQVhfUkVUUllfQVRURU1QVFMgLSAxO1xuICAgICAgICBsb2dnZXIxNy5lcnJvcihgRXJyb3Igc3RvcmluZyB0byBsb2NhbFN0b3JhZ2UgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHt0aGlzLk1BWF9SRVRSWV9BVFRFTVBUU30pYCwge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBpc0xhc3RBdHRlbXB0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pc1F1b3RhRXhjZWVkZWRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICBjb25zdCB1c2VBZ2dyZXNzaXZlQ2xlYW51cCA9IGF0dGVtcHQgPiAwO1xuICAgICAgICAgIHRoaXMudHJ5Q2xlYW51cE9sZEVudHJpZXModXNlQWdncmVzc2l2ZUNsZWFudXApO1xuICAgICAgICAgIGlmIChpc0xhc3RBdHRlbXB0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc3RvcmUgaXRlbSBpbiBsb2NhbFN0b3JhZ2U6IHN0b3JhZ2UgcXVvdGEgZXhjZWVkZWQgZXZlbiBhZnRlciBtdWx0aXBsZSBjbGVhbnVwIGF0dGVtcHRzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdG9yZSBpdGVtIGluIGxvY2FsU3RvcmFnZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGluY2x1ZGVzS2V5KGtleSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpID09PSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE3LmRlYnVnKFwiRmFpbGVkIHRvIHBhcnNlIHN0b3JlZCB2YWx1ZSBpbiBpbmNsdWRlc0tleVwiLCB7IGtleSwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgY2hlY2tpbmcga2V5IGluIGxvY2FsU3RvcmFnZVwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICBsb2dnZXIxNy50cmFjZShcImRlbGV0ZVwiLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgZGVsZXRpbmcgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFsbEluKGxvY2F0aW9ucykge1xuICAgIGNvbnN0IGFsbEtleXMgPSB0aGlzLmtleXMoKTtcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyMTcuZGVidWcoXCJSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5XCIpO1xuICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFsbEtleXMpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsb2NLZXlzID0gbG9jYXRpb25zO1xuICAgICAgbG9nZ2VyMTcuZGVidWcoXCJhbGxJblwiLCB7IGxvY0tleXMsIGtleXM6IGFsbEtleXMubGVuZ3RoIH0pO1xuICAgICAgY29uc3QgZmlsdGVyZWRLZXlzID0gYWxsS2V5cy5maWx0ZXIoKGtleSkgPT4ga2V5ICYmIGlzQ29tS2V5MyhrZXkpKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBDb21LZXkxMiA9IGtleTtcbiAgICAgICAgbG9nZ2VyMTcuZGVidWcoXCJDb21wYXJpbmcgTG9jYXRpb24gS2V5c1wiLCB7XG4gICAgICAgICAgbG9jS2V5cyxcbiAgICAgICAgICBDb21LZXk6IENvbUtleTEyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXNMb2NLZXlBcnJheUVxdWFsKGxvY0tleXMsIENvbUtleTEyLmxvYyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWx0ZXJlZEtleXMpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb250YWlucyhxdWVyeSwgbG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTcuZGVidWcoXCJjb250YWluc1wiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaDMoaXRlbSwgcXVlcnkpKTtcbiAgfVxuICBhc3luYyBxdWVyeUluKHF1ZXJ5LCBsb2NhdGlvbnMgPSBbXSkge1xuICAgIGxvZ2dlcjE3LmRlYnVnKFwicXVlcnlJblwiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoMyhpdGVtLCBxdWVyeSkpO1xuICB9XG4gIGFzeW5jIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xvY2FsU3RvcmFnZUNhY2hlTWFwKHRoaXMudHlwZXMsIHRoaXMua2V5UHJlZml4KTtcbiAgfVxuICBwYXJzZVN0b3JhZ2VFbnRyeShzdG9yYWdlS2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmRlYnVnKFwiU2tpcHBpbmcgY29ycnVwdGVkIGxvY2FsU3RvcmFnZSBlbnRyeVwiLCB7IHN0b3JhZ2VLZXksIGVycm9yOiBwYXJzZUVycm9yIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBrZXlzKCkge1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVN0b3JhZ2VFbnRyeShzdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKHBhcnNlZD8ub3JpZ2luYWxLZXkpIHtcbiAgICAgICAgICBrZXlzLnB1c2gocGFyc2VkLm9yaWdpbmFsS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIGdldHRpbmcga2V5cyBmcm9tIGxvY2FsU3RvcmFnZVwiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICBhc3luYyB2YWx1ZXMoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VTdG9yYWdlRW50cnkoc3RvcmFnZUtleSk7XG4gICAgICAgIGlmIChwYXJzZWQ/LnZhbHVlKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIGdldHRpbmcgdmFsdWVzIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgbG9nZ2VyMTcuZGVidWcoXCJDbGVhcmluZyBsb2NhbFN0b3JhZ2UgY2FjaGVcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIGNsZWFyaW5nIGxvY2FsU3RvcmFnZSBjYWNoZVwiLCB7IGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbiAgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cykge1xuICAgIGxvZ2dlcjE3LnRyYWNlKFwic2V0UXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBpdGVtS2V5c1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHF1ZXJ5S2V5LCBKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byBzdG9yZSBxdWVyeSByZXN1bHQgaW4gbG9jYWxTdG9yYWdlXCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgbG9nZ2VyMTcudHJhY2UoXCJnZXRRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0ocXVlcnlLZXkpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgZW50cnkgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeS5pdGVtS2V5cyB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSBxdWVyeSByZXN1bHQgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShxdWVyeUtleSkgIT09IG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRmFpbGVkIHRvIGNoZWNrIHF1ZXJ5IHJlc3VsdCBpbiBsb2NhbFN0b3JhZ2VcIiwgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxNy50cmFjZShcImRlbGV0ZVF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHF1ZXJ5S2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIHF1ZXJ5IHJlc3VsdCBmcm9tIGxvY2FsU3RvcmFnZVwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG4gIGludmFsaWRhdGVJdGVtS2V5cyhrZXlzKSB7XG4gICAgbG9nZ2VyMTcuZGVidWcoXCJpbnZhbGlkYXRlSXRlbUtleXNcIiwgeyBrZXlzIH0pO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIGtleSBkdXJpbmcgaW52YWxpZGF0aW9uXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTcuZGVidWcoXCJpbnZhbGlkYXRlTG9jYXRpb25cIiwgeyBsb2NhdGlvbnMgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGFsbEtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBhbGxLZXlzLmZpbHRlcigoa2V5KSA9PiAhaXNDb21LZXkzKGtleSkpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhwcmltYXJ5S2V5cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzVG9JbnZhbGlkYXRlID0gdGhpcy5rZXlzKCkuZmlsdGVyKChrZXkpID0+IGtleSAmJiBpc0NvbUtleTMoa2V5KSkuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBjb21wb3NpdGVLZXkgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NhdGlvbnMsIGNvbXBvc2l0ZUtleS5sb2MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMoa2V5c1RvSW52YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgaW4gaW52YWxpZGF0ZUxvY2F0aW9uXCIsIHsgbG9jYXRpb25zLCBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgY2xlYXJRdWVyeVJlc3VsdHMoKSB7XG4gICAgbG9nZ2VyMTcudHJhY2UoXCJjbGVhclF1ZXJ5UmVzdWx0c1wiKTtcbiAgICBjb25zdCBxdWVyeVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeTpgO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzVG9SZW1vdmUgPSB0aGlzLmdldEFsbEtleXNTdGFydGluZ1dpdGgocXVlcnlQcmVmaXgpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c1RvUmVtb3ZlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byByZW1vdmUgcXVlcnkgcmVzdWx0IGZyb20gbG9jYWxTdG9yYWdlXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byBjbGVhciBxdWVyeSByZXN1bHRzIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG4gIC8vIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciBpbXBsZW1lbnRhdGlvblxuICBnZXRNZXRhZGF0YShrZXkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKG1ldGFkYXRhS2V5KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyMTcuZGVidWcoXCJJbnZhbGlkIG1ldGFkYXRhIEpTT04sIHRyZWF0aW5nIGFzIG51bGxcIiwgeyBrZXksIGVycm9yOiBlIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBnZXR0aW5nIG1ldGFkYXRhIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBzZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKSB7XG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCB0aGlzLk1BWF9SRVRSWV9BVFRFTVBUUzsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YToke2tleX1gO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtZXRhZGF0YUtleSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgbG9nZ2VyMTcuaW5mbyhgU3VjY2Vzc2Z1bGx5IHN0b3JlZCBtZXRhZGF0YSBhZnRlciAke2F0dGVtcHR9IHJldHJpZXNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBpc0xhc3RBdHRlbXB0ID0gYXR0ZW1wdCA9PT0gdGhpcy5NQVhfUkVUUllfQVRURU1QVFMgLSAxO1xuICAgICAgICBsb2dnZXIxNy5lcnJvcihgRXJyb3Igc3RvcmluZyBtZXRhZGF0YSB0byBsb2NhbFN0b3JhZ2UgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHt0aGlzLk1BWF9SRVRSWV9BVFRFTVBUU30pYCwge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBpc0xhc3RBdHRlbXB0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pc1F1b3RhRXhjZWVkZWRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICBjb25zdCB1c2VBZ2dyZXNzaXZlQ2xlYW51cCA9IGF0dGVtcHQgPiAwO1xuICAgICAgICAgIHRoaXMudHJ5Q2xlYW51cE9sZEVudHJpZXModXNlQWdncmVzc2l2ZUNsZWFudXApO1xuICAgICAgICAgIGlmIChpc0xhc3RBdHRlbXB0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc3RvcmUgbWV0YWRhdGEgaW4gbG9jYWxTdG9yYWdlOiBzdG9yYWdlIHF1b3RhIGV4Y2VlZGVkIGV2ZW4gYWZ0ZXIgbXVsdGlwbGUgY2xlYW51cCBhdHRlbXB0c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RvcmUgbWV0YWRhdGEgaW4gbG9jYWxTdG9yYWdlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlTWV0YWRhdGEoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShtZXRhZGF0YUtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgZGVsZXRpbmcgbWV0YWRhdGEgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGdldEFsbE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFQcmVmaXggPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6YDtcbiAgICAgIGNvbnN0IG1ldGFLZXlzID0gdGhpcy5nZXRBbGxLZXlzU3RhcnRpbmdXaXRoKG1ldGFkYXRhUHJlZml4KTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1ldGFLZXlzKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0ga2V5LnN1YnN0cmluZyhtZXRhZGF0YVByZWZpeC5sZW5ndGgpO1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXN0b3JlZCkgY29udGludWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgbWV0YWRhdGEuc2V0KG1ldGFkYXRhS2V5LCBwYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIxNy5kZWJ1ZyhcIlNraXBwaW5nIGludmFsaWQgbWV0YWRhdGEgZW50cnlcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBtZXRhZGF0YSBmcm9tIGxvY2FsU3RvcmFnZVwiLCB7IGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfVxuICBjbGVhck1ldGFkYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuICAgICAgY29uc3Qga2V5c1RvRGVsZXRlID0gdGhpcy5nZXRBbGxLZXlzU3RhcnRpbmdXaXRoKG1ldGFkYXRhUHJlZml4KTtcbiAgICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKChrZXkpID0+IGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIGNsZWFyaW5nIG1ldGFkYXRhIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgbGV0IGl0ZW1Db3VudCA9IDA7XG4gICAgbGV0IHNpemVCeXRlcyA9IDA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBzaXplQnl0ZXMgKz0gbmV3IEJsb2IoW3ZhbHVlXSkuc2l6ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgc2l6ZUJ5dGVzICs9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbFRoaXMuQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBzaXplQnl0ZXMgKz0gZ2xvYmFsVGhpcy5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgXCJ1dGY4XCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplQnl0ZXMgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleS5pbmNsdWRlcyhcIjptZXRhZGF0YTpcIikgJiYgIWtleS5pbmNsdWRlcyhcIjpxdWVyeTpcIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICBpZiAocGFyc2VkICYmIHR5cGVvZiBwYXJzZWQgPT09IFwib2JqZWN0XCIgJiYgXCJvcmlnaW5hbEtleVwiIGluIHBhcnNlZCAmJiBcInZhbHVlXCIgaW4gcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgaXRlbUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGxvZ2dlcjE3LmRlYnVnKFwiSW52YWxpZCBlbnRyeSBpbiBnZXRDdXJyZW50U2l6ZVwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE3LmRlYnVnKFwiU2l6ZSBjYWxjdWxhdGlvbiBmYWlsZWQsIHVzaW5nIHN0cmluZyBsZW5ndGhcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgICAgIHNpemVCeXRlcyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBjYWxjdWxhdGluZyBzaXplIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXRlbUNvdW50LCBzaXplQnl0ZXMgfTtcbiAgfVxuICBnZXRTaXplTGltaXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhJdGVtczogbnVsbCxcbiAgICAgIC8vIE5vIHNwZWNpZmljIGl0ZW0gbGltaXRcbiAgICAgIG1heFNpemVCeXRlczogNSAqIDEwMjQgKiAxMDI0XG4gICAgICAvLyA1TUIgY29uc2VydmF0aXZlIGVzdGltYXRlXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2Jyb3dzZXIvU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcC50c1xuaW1wb3J0IHtcbiAgaXNDb21LZXkgYXMgaXNDb21LZXk0LFxuICBpc1F1ZXJ5TWF0Y2ggYXMgaXNRdWVyeU1hdGNoNFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCBzYWZlU3RyaW5naWZ5MiBmcm9tIFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiO1xudmFyIGxvZ2dlcjE4ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcFwiKTtcbnZhciBTZXNzaW9uU3RvcmFnZUNhY2hlTWFwID0gY2xhc3MgX1Nlc3Npb25TdG9yYWdlQ2FjaGVNYXAgZXh0ZW5kcyBDYWNoZU1hcCB7XG4gIGltcGxlbWVudGF0aW9uVHlwZSA9IFwiYnJvd3Nlci9zZXNzaW9uU3RvcmFnZVwiO1xuICBrZXlQcmVmaXg7XG4gIG5vcm1hbGl6ZWRIYXNoRnVuY3Rpb247XG4gIC8vIFVzZSBhIHNlcGFyYXRlLCBwcml2YXRlIHZlcmlmaWVyIHRoYXQgaXMgbm90IHJlZmVyZW5jZWQgYnkgdGVzdHMgdG8gZ3VhcmQgYWdhaW5zdCB0YW1wZXJpbmdcbiAgdmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uO1xuICBjb25zdHJ1Y3Rvcih0eXBlcywga2V5UHJlZml4ID0gXCJmamVsbC1zZXNzaW9uLWNhY2hlXCIpIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbigpO1xuICAgIHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbigpO1xuICB9XG4gIGdldFN0b3JhZ2VLZXkoa2V5KSB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgcmV0dXJuIGAke3RoaXMua2V5UHJlZml4fToke2hhc2hlZEtleX1gO1xuICB9XG4gIC8vIFVzaW5nIGZsYXR0ZWQgZm9yIHNhZmUgY2lyY3VsYXIgc2VyaWFsaXphdGlvbjsgbm8gbWFudWFsIHJlcGxhY2VyIG5lZWRlZFxuICBnZXRBbGxTdG9yYWdlS2V5cygpIHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vzc2lvblN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc2Vzc2lvblN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKGAke3RoaXMua2V5UHJlZml4fTpgKSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBrZXlzIGZyb20gc2Vzc2lvblN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgLy8gRGV0ZWN0IGlmIGN1cnJlbnQgbm9ybWFsaXplZCBoYXNoIGZ1bmN0aW9uIGNvbGxhcHNlcyBtdWx0aXBsZSBzdG9yZWQgaXRlbXMgaW50byB0aGUgc2FtZSBoYXNoXG4gIGhhc0NvbGxpc2lvbkZvckhhc2godGFyZ2V0SGFzaCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OiR7dGFyZ2V0SGFzaH1gO1xuICAgICAgY29uc3QgcmF3ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmICghcmF3KSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJhdyk7XG4gICAgICBpZiAoIXBhcnNlZD8ub3JpZ2luYWxLZXkpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggPSBwYXJzZWQub3JpZ2luYWxWZXJpZmljYXRpb25IYXNoO1xuICAgICAgY29uc3QgY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpO1xuICAgICAgaWYgKHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggPT09IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgbG9nZ2VyMTgudHJhY2UoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRIYXNoID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICBpZiAodGhpcy5oYXNDb2xsaXNpb25Gb3JIYXNoKGN1cnJlbnRIYXNoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9IHBhcnNlZC5vcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2g7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoID0gdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3QgaXNTYW1lT3JpZ2luYWxLZXkgPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpID09PSBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaDtcbiAgICAgICAgaWYgKHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggJiYgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggJiYgaXNTYW1lT3JpZ2luYWxLZXkpIHtcbiAgICAgICAgICBpZiAocGFyc2VkLnZhbHVlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgIHJldHVybiBwYXJzZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkVycm9yIHJldHJpZXZpbmcgZnJvbSBzZXNzaW9uU3RvcmFnZVwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgbG9nZ2VyMTgudHJhY2UoXCJzZXRcIiwgeyBzdG9yYWdlS2V5IH0pO1xuICAgICAgY29uc3QgdG9TdG9yZSA9IHtcbiAgICAgICAgb3JpZ2luYWxLZXk6IGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgb3JpZ2luYWxWZXJpZmljYXRpb25IYXNoOiB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihrZXkpXG4gICAgICB9O1xuICAgICAgY29uc3QganNvblN0cmluZyA9IHNhZmVTdHJpbmdpZnkyKHRvU3RvcmUpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBqc29uU3RyaW5nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJFcnJvciBzdG9yaW5nIHRvIHNlc3Npb25TdG9yYWdlXCIsIHsgZXJyb3JNZXNzYWdlOiBlcnJvcj8ubWVzc2FnZSB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN0b3JlIGl0ZW0gaW4gc2Vzc2lvblN0b3JhZ2U6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGluY2x1ZGVzS2V5KGtleSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50SGFzaCA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgaWYgKHRoaXMuaGFzQ29sbGlzaW9uRm9ySGFzaChjdXJyZW50SGFzaCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICBjb25zdCBzdG9yZWRWZXJpZmljYXRpb25IYXNoID0gcGFyc2VkLm9yaWdpbmFsVmVyaWZpY2F0aW9uSGFzaDtcbiAgICAgICAgY29uc3QgY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgICBjb25zdCBpc1NhbWVPcmlnaW5hbEtleSA9IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSkgPT09IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoO1xuICAgICAgICByZXR1cm4gISFzdG9yZWRWZXJpZmljYXRpb25IYXNoICYmIHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggPT09IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoICYmIGlzU2FtZU9yaWdpbmFsS2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkVycm9yIGNoZWNraW5nIGtleSBpbiBzZXNzaW9uU3RvcmFnZVwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICBsb2dnZXIxOC50cmFjZShcImRlbGV0ZVwiLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJFcnJvciBkZWxldGluZyBmcm9tIHNlc3Npb25TdG9yYWdlXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWxsSW4obG9jYXRpb25zKSB7XG4gICAgY29uc3QgYWxsS2V5cyA9IHRoaXMua2V5cygpO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIxOC5kZWJ1ZyhcIlJldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHlcIik7XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvY0tleXMgPSBsb2NhdGlvbnM7XG4gICAgICBsb2dnZXIxOC5kZWJ1ZyhcImFsbEluXCIsIHsgbG9jS2V5cywga2V5czogYWxsS2V5cy5sZW5ndGggfSk7XG4gICAgICBjb25zdCBmaWx0ZXJlZEtleXMgPSBhbGxLZXlzLmZpbHRlcigoa2V5KSA9PiBrZXkgJiYgaXNDb21LZXk0KGtleSkpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IENvbUtleTEyID0ga2V5O1xuICAgICAgICBsb2dnZXIxOC5kZWJ1ZyhcIkNvbXBhcmluZyBMb2NhdGlvbiBLZXlzXCIsIHtcbiAgICAgICAgICBsb2NLZXlzLFxuICAgICAgICAgIENvbUtleTogQ29tS2V5MTJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jS2V5cywgQ29tS2V5MTIubG9jKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZpbHRlcmVkS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5LCBsb2NhdGlvbnMpIHtcbiAgICBsb2dnZXIxOC5kZWJ1ZyhcImNvbnRhaW5zXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXNRdWVyeU1hdGNoNChpdGVtLCBxdWVyeSkpO1xuICB9XG4gIGFzeW5jIHF1ZXJ5SW4ocXVlcnksIGxvY2F0aW9ucyA9IFtdKSB7XG4gICAgbG9nZ2VyMTguZGVidWcoXCJxdWVyeUluXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2g0KGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cbiAgYXN5bmMgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcCh0aGlzLnR5cGVzLCB0aGlzLmtleVByZWZpeCk7XG4gIH1cbiAga2V5cygpIHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgIGlmICghc3RvcmVkKSBjb250aW51ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgaWYgKHBhcnNlZC5vcmlnaW5hbEtleSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHBhcnNlZC5vcmlnaW5hbEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChpdGVtRXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIxOC50cmFjZShcIlNraXBwaW5nIGludmFsaWQgc3RvcmFnZSBpdGVtXCIsIHsgc3RvcmFnZUtleSwgZXJyb3I6IGl0ZW1FcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkVycm9yIGdldHRpbmcga2V5cyBmcm9tIHNlc3Npb25TdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIGFzeW5jIHZhbHVlcygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKCFzdG9yZWQpIGNvbnRpbnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBpZiAocGFyc2VkLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlZC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChpdGVtRXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIxOC50cmFjZShcIlNraXBwaW5nIGludmFsaWQgc3RvcmFnZSBpdGVtIGZvciB2YWx1ZXNcIiwgeyBzdG9yYWdlS2V5LCBlcnJvcjogaXRlbUVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRXJyb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBzZXNzaW9uU3RvcmFnZVwiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGxvZ2dlcjE4LmRlYnVnKFwiQ2xlYXJpbmcgc2Vzc2lvblN0b3JhZ2UgY2FjaGVcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRXJyb3IgY2xlYXJpbmcgc2Vzc2lvblN0b3JhZ2UgY2FjaGVcIiwgeyBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuICBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGl0ZW1LZXlzKSB7XG4gICAgbG9nZ2VyMTgudHJhY2UoXCJzZXRRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleXMgfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGl0ZW1LZXlzXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QganNvblN0cmluZyA9IHNhZmVTdHJpbmdpZnkyKGVudHJ5KTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0ocXVlcnlLZXksIGpzb25TdHJpbmcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkZhaWxlZCB0byBzdG9yZSBxdWVyeSByZXN1bHQgaW4gc2Vzc2lvblN0b3JhZ2VcIiwgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxOC50cmFjZShcImdldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHF1ZXJ5S2V5KTtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVudHJ5ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnkuaXRlbUtleXMgfHwgbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJGYWlsZWQgdG8gcmV0cmlldmUgcXVlcnkgcmVzdWx0IGZyb20gc2Vzc2lvblN0b3JhZ2VcIiwgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHF1ZXJ5S2V5KSAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJGYWlsZWQgdG8gY2hlY2sgcXVlcnkgcmVzdWx0IGluIHNlc3Npb25TdG9yYWdlXCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgbG9nZ2VyMTgudHJhY2UoXCJkZWxldGVRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgIHRyeSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHF1ZXJ5S2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIHF1ZXJ5IHJlc3VsdCBmcm9tIHNlc3Npb25TdG9yYWdlXCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXMpIHtcbiAgICBsb2dnZXIxOC5kZWJ1ZyhcImludmFsaWRhdGVJdGVtS2V5c1wiLCB7IGtleXMgfSk7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9ucykge1xuICAgIGxvZ2dlcjE4LmRlYnVnKFwiaW52YWxpZGF0ZUxvY2F0aW9uXCIsIHsgbG9jYXRpb25zIH0pO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBhbGxLZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKChrZXkpID0+ICFpc0NvbUtleTQoa2V5KSk7XG4gICAgICB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhwcmltYXJ5S2V5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGl0ZW1zSW5Mb2NhdGlvbiA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICAgIGNvbnN0IGtleXNUb0ludmFsaWRhdGUgPSBpdGVtc0luTG9jYXRpb24ubWFwKChpdGVtKSA9PiBpdGVtLmtleSk7XG4gICAgICB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgICB9XG4gICAgdGhpcy5jbGVhclF1ZXJ5UmVzdWx0cygpO1xuICB9XG4gIGNsZWFyUXVlcnlSZXN1bHRzKCkge1xuICAgIGxvZ2dlcjE4LnRyYWNlKFwiY2xlYXJRdWVyeVJlc3VsdHNcIik7XG4gICAgY29uc3QgcXVlcnlQcmVmaXggPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6YDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5c1RvUmVtb3ZlID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb25TdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlc3Npb25TdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChxdWVyeVByZWZpeCkpIHtcbiAgICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXlzVG9SZW1vdmUuZm9yRWFjaCgoa2V5KSA9PiBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkZhaWxlZCB0byBjbGVhciBxdWVyeSByZXN1bHRzIGZyb20gc2Vzc2lvblN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIGdldE1ldGFkYXRhKGtleSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YToke2tleX1gO1xuICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShtZXRhZGF0YUtleSk7XG4gICAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gc2FmZVN0cmluZ2lmeTIobWV0YWRhdGEpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtZXRhZGF0YUtleSwganNvblN0cmluZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGRlbGV0ZU1ldGFkYXRhKGtleSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YToke2tleX1gO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShtZXRhZGF0YUtleSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGdldEFsbE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuICAgIHRyeSB7XG4gICAgICBsZXQgZm91bmRBbnkgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vzc2lvblN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc2Vzc2lvblN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICBpZiAoIWtleSB8fCAha2V5LnN0YXJ0c1dpdGgobWV0YWRhdGFQcmVmaXgpKSBjb250aW51ZTtcbiAgICAgICAgZm91bmRBbnkgPSB0cnVlO1xuICAgICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGtleS5zdWJzdHJpbmcobWV0YWRhdGFQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXN0b3JlZCkgY29udGludWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWV0YWRhdGEuc2V0KG1ldGFkYXRhS2V5LCBKU09OLnBhcnNlKHN0b3JlZCkpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkVycm9yIGdldHRpbmcgYWxsIG1ldGFkYXRhIGZyb20gc2Vzc2lvblN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gIH1cbiAgY2xlYXJNZXRhZGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFQcmVmaXggPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6YDtcbiAgICAgIGNvbnN0IGtleXNUb0RlbGV0ZSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXNzaW9uU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzZXNzaW9uU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgobWV0YWRhdGFQcmVmaXgpKSB7XG4gICAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2V5c1RvRGVsZXRlLmZvckVhY2goKGtleSkgPT4gc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgbGV0IGl0ZW1Db3VudCA9IDA7XG4gICAgbGV0IHNpemVCeXRlcyA9IDA7XG4gICAgdHJ5IHtcbiAgICAgIHNlc3Npb25TdG9yYWdlLmtleSgwKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB7IGl0ZW1Db3VudDogMCwgc2l6ZUJ5dGVzOiAwIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGlmICgha2V5LmluY2x1ZGVzKFwiOm1ldGFkYXRhOlwiKSAmJiAha2V5LmluY2x1ZGVzKFwiOnF1ZXJ5OlwiKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZD8ub3JpZ2luYWxLZXkgJiYgcGFyc2VkPy5vcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2ggPT09IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtQ291bnQrKztcbiAgICAgICAgICAgICAgICBzaXplQnl0ZXMgKz0gbmV3IEJsb2IoW3ZhbHVlXSkuc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHsgaXRlbUNvdW50OiAwLCBzaXplQnl0ZXM6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXRlbUNvdW50LCBzaXplQnl0ZXMgfTtcbiAgfVxuICBnZXRTaXplTGltaXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhJdGVtczogbnVsbCxcbiAgICAgIC8vIE5vIHNwZWNpZmljIGl0ZW0gbGltaXRcbiAgICAgIG1heFNpemVCeXRlczogNSAqIDEwMjQgKiAxMDI0XG4gICAgICAvLyA1TUIgY29uc2VydmF0aXZlIGVzdGltYXRlXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2Jyb3dzZXIvQXN5bmNJbmRleERCQ2FjaGVNYXAudHNcbmltcG9ydCB7XG4gIGlzQ29tS2V5IGFzIGlzQ29tS2V5NSxcbiAgaXNRdWVyeU1hdGNoIGFzIGlzUXVlcnlNYXRjaDVcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgc2FmZVN0cmluZ2lmeTMgZnJvbSBcImZhc3Qtc2FmZS1zdHJpbmdpZnlcIjtcbnZhciBsb2dnZXIxOSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkFzeW5jSW5kZXhEQkNhY2hlTWFwXCIpO1xudmFyIEFzeW5jSW5kZXhEQkNhY2hlTWFwID0gY2xhc3MgX0FzeW5jSW5kZXhEQkNhY2hlTWFwIHtcbiAgdHlwZXM7XG4gIGRiTmFtZTtcbiAgc3RvcmVOYW1lO1xuICB2ZXJzaW9uO1xuICBub3JtYWxpemVkSGFzaEZ1bmN0aW9uO1xuICBkYlByb21pc2UgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih0eXBlcywgZGJOYW1lID0gXCJmamVsbC1pbmRleGRiLWNhY2hlXCIsIHN0b3JlTmFtZSA9IFwiY2FjaGVcIiwgdmVyc2lvbiA9IDEpIHtcbiAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgdGhpcy5kYk5hbWUgPSBkYk5hbWU7XG4gICAgdGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uKCk7XG4gIH1cbiAgYXN5bmMgZ2V0REIoKSB7XG4gICAgaWYgKCF0aGlzLmRiUHJvbWlzZSkge1xuICAgICAgdGhpcy5kYlByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3Igb3BlbmluZyBJbmRleGVkREJcIiwgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmRlYnVnKFwiSW5kZXhlZERCIG9wZW5lZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZGVidWcoXCJJbmRleGVkREIgdXBncmFkZSBuZWVkZWRcIik7XG4gICAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0aGlzLnN0b3JlTmFtZSkpIHtcbiAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIGxvZ2dlcjE5LmRlYnVnKFwiQ3JlYXRlZCBvYmplY3Qgc3RvcmVcIiwgeyBzdG9yZU5hbWU6IHRoaXMuc3RvcmVOYW1lIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYlByb21pc2U7XG4gIH1cbiAgZ2V0U3RvcmFnZUtleShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gIH1cbiAgYXN5bmMgZ2V0KGtleSkge1xuICAgIGxvZ2dlcjE5LnRyYWNlKFwiZ2V0XCIsIHsga2V5IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkb25seVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChzdG9yYWdlS2V5KTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBmcm9tIEluZGV4ZWREQlwiLCB7IGtleSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG9yZWQgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoc3RvcmVkICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihzdG9yZWQub3JpZ2luYWxLZXkpID09PSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgcmVzb2x2ZShzdG9yZWQudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIEluZGV4ZWREQiBnZXQgb3BlcmF0aW9uXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGxvZ2dlcjE5LnRyYWNlKFwic2V0XCIsIHsga2V5LCB2YWx1ZSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBjb25zdCBzdG9yZWRJdGVtID0ge1xuICAgICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoc3RvcmVkSXRlbSwgc3RvcmFnZUtleSk7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIHNldHRpbmcgaW4gSW5kZXhlZERCXCIsIHsga2V5LCB2YWx1ZSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBJbmRleGVkREIgc2V0IG9wZXJhdGlvblwiLCB7IGtleSwgdmFsdWUsIGVycm9yIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RvcmUgaXRlbSBpbiBJbmRleGVkREI6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGluY2x1ZGVzS2V5KGtleSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkb25seVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChzdG9yYWdlS2V5KTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgY2hlY2tpbmcga2V5IGluIEluZGV4ZWREQlwiLCB7IGtleSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG9yZWQgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKHN0b3JlZC5vcmlnaW5hbEtleSkgPT09IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgcmVzb2x2ZShtYXRjaGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgaW4gSW5kZXhlZERCIGluY2x1ZGVzS2V5IG9wZXJhdGlvblwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRlbGV0ZShrZXkpIHtcbiAgICBsb2dnZXIxOS50cmFjZShcImRlbGV0ZVwiLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHN0b3JhZ2VLZXkpO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBkZWxldGluZyBmcm9tIEluZGV4ZWREQlwiLCB7IGtleSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBJbmRleGVkREIgZGVsZXRlIG9wZXJhdGlvblwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFsbEluKGxvY2F0aW9ucykge1xuICAgIGNvbnN0IGFsbEtleXMgPSBhd2FpdCB0aGlzLmtleXMoKTtcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyMTkuZGVidWcoXCJSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5XCIpO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBhbGxLZXlzLm1hcCgoa2V5KSA9PiB0aGlzLmdldChrZXkpKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsb2NLZXlzID0gbG9jYXRpb25zO1xuICAgICAgbG9nZ2VyMTkuZGVidWcoXCJhbGxJblwiLCB7IGxvY0tleXMsIGtleXM6IGFsbEtleXMubGVuZ3RoIH0pO1xuICAgICAgY29uc3QgZmlsdGVyZWRLZXlzID0gYWxsS2V5cy5maWx0ZXIoKGtleSkgPT4ga2V5ICYmIGlzQ29tS2V5NShrZXkpKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBDb21LZXkxMiA9IGtleTtcbiAgICAgICAgbG9nZ2VyMTkuZGVidWcoXCJDb21wYXJpbmcgTG9jYXRpb24gS2V5c1wiLCB7XG4gICAgICAgICAgbG9jS2V5cyxcbiAgICAgICAgICBDb21LZXk6IENvbUtleTEyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXNMb2NLZXlBcnJheUVxdWFsKGxvY0tleXMsIENvbUtleTEyLmxvYyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gZmlsdGVyZWRLZXlzLm1hcCgoa2V5KSA9PiB0aGlzLmdldChrZXkpKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb250YWlucyhxdWVyeSwgbG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTkuZGVidWcoXCJjb250YWluc1wiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaDUoaXRlbSwgcXVlcnkpKTtcbiAgfVxuICBhc3luYyBxdWVyeUluKHF1ZXJ5LCBsb2NhdGlvbnMgPSBbXSkge1xuICAgIGxvZ2dlcjE5LmRlYnVnKFwicXVlcnlJblwiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoNShpdGVtLCBxdWVyeSkpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0FzeW5jSW5kZXhEQkNhY2hlTWFwKHRoaXMudHlwZXMsIHRoaXMuZGJOYW1lLCB0aGlzLnN0b3JlTmFtZSwgdGhpcy52ZXJzaW9uKTtcbiAgfVxuICBhc3luYyBrZXlzKCkge1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZG9ubHlcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGdldHRpbmcga2V5cyBmcm9tIEluZGV4ZWREQlwiLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGtleXMucHVzaChzdG9yZWQub3JpZ2luYWxLZXkpO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoa2V5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgaW4gSW5kZXhlZERCIGtleXMgb3BlcmF0aW9uXCIsIHsgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIGFzeW5jIHZhbHVlcygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZG9ubHlcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGdldHRpbmcgdmFsdWVzIGZyb20gSW5kZXhlZERCXCIsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goc3RvcmVkLnZhbHVlKTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgaW4gSW5kZXhlZERCIHZhbHVlcyBvcGVyYXRpb25cIiwgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY2xlYXIoKSB7XG4gICAgbG9nZ2VyMTkuZGVidWcoXCJDbGVhcmluZyBJbmRleGVkREIgY2FjaGVcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNsZWFyKCk7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGNsZWFyaW5nIEluZGV4ZWREQiBjYWNoZVwiLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgaW4gSW5kZXhlZERCIGNsZWFyIG9wZXJhdGlvblwiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICAvLyBBc3luYyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzXG4gIGFzeW5jIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpIHtcbiAgICBsb2dnZXIxOS50cmFjZShcInNldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBpdGVtS2V5cyB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3Igc2V0UXVlcnlSZXN1bHRcIiwgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGl0ZW1LZXlzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBxdWVyeUtleSA9IGBxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgICAgICAgIGNvbnN0IHB1dFJlcXVlc3QgPSBzdG9yZS5wdXQoc2FmZVN0cmluZ2lmeTMoZW50cnkpLCBxdWVyeUtleSk7XG4gICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJGYWlsZWQgdG8gc3RvcmUgcXVlcnkgcmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBlcnJvcjogcHV0UmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgIHJlamVjdChwdXRSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHB1dFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBzZXRRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgbG9nZ2VyMTkudHJhY2UoXCJnZXRRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3IgZ2V0UXVlcnlSZXN1bHRcIiwgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYHF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgICAgICAgY29uc3QgZ2V0UmVxdWVzdCA9IHN0b3JlLmdldChxdWVyeUtleSk7XG4gICAgICAgICAgZ2V0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJGYWlsZWQgdG8gcmV0cmlldmUgcXVlcnkgcmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBlcnJvcjogZ2V0UmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgIHJlamVjdChnZXRSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0UmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKGVudHJ5Lml0ZW1LZXlzIHx8IG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGVycm9yOiBwYXJzZUVycm9yIH0pO1xuICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBnZXRRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgbG9nZ2VyMTkudHJhY2UoXCJoYXNRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBoYXNRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGxvZ2dlcjE5LnRyYWNlKFwiZGVsZXRlUXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2ggfSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRmFpbGVkIHRvIG9wZW4gZGF0YWJhc2UgZm9yIGRlbGV0ZVF1ZXJ5UmVzdWx0XCIsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBgcXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICAgICAgICBjb25zdCBkZWxldGVSZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHF1ZXJ5S2V5KTtcbiAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkZhaWxlZCB0byBkZWxldGUgcXVlcnkgcmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBlcnJvcjogZGVsZXRlUmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgIHJlamVjdChkZWxldGVSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBkZWxldGVRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXMpIHtcbiAgICBsb2dnZXIxOS5kZWJ1ZyhcImludmFsaWRhdGVJdGVtS2V5c1wiLCB7IGtleXMgfSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9ucykge1xuICAgIGxvZ2dlcjE5LmRlYnVnKFwiaW52YWxpZGF0ZUxvY2F0aW9uXCIsIHsgbG9jYXRpb25zIH0pO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGl0ZW1zSW5Mb2NhdGlvbiA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICAgIGNvbnN0IGtleXNUb0ludmFsaWRhdGUgPSBpdGVtc0luTG9jYXRpb24ubWFwKChpdGVtKSA9PiBpdGVtLmtleSk7XG4gICAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbGVhclF1ZXJ5UmVzdWx0cygpO1xuICB9XG4gIGFzeW5jIGNsZWFyUXVlcnlSZXN1bHRzKCkge1xuICAgIGxvZ2dlcjE5LnRyYWNlKFwiY2xlYXJRdWVyeVJlc3VsdHNcIik7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRmFpbGVkIHRvIG9wZW4gZGF0YWJhc2UgZm9yIGNsZWFyUXVlcnlSZXN1bHRzXCIsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICAgICAgY29uc3QgY3Vyc29yUmVxdWVzdCA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICBjb25zdCBrZXlzVG9EZWxldGUgPSBbXTtcbiAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkZhaWxlZCB0byBvcGVuIGN1cnNvciBmb3IgY2xlYXJRdWVyeVJlc3VsdHNcIiwgeyBlcnJvcjogY3Vyc29yUmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgIHJlamVjdChjdXJzb3JSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gY3Vyc29yUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5zdGFydHNXaXRoKFwicXVlcnk6XCIpKSB7XG4gICAgICAgICAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChrZXlzVG9EZWxldGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZGVsZXRlZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxUb0RlbGV0ZSA9IGtleXNUb0RlbGV0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKChxdWVyeUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcXVlc3QgPSBzdG9yZS5kZWxldGUocXVlcnlLZXkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBxdWVyeSBrZXlcIiwgeyBxdWVyeUtleSwgZXJyb3I6IGRlbGV0ZVJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICBkZWxldGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVkQ291bnQgPT09IHRvdGFsVG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBkZWxldGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVkQ291bnQgPT09IHRvdGFsVG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBjbGVhclF1ZXJ5UmVzdWx0c1wiLCB7IGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvYnJvd3Nlci9JbmRleERCQ2FjaGVNYXAudHNcbnZhciBJbmRleERCQ2FjaGVNYXAgPSBjbGFzcyBfSW5kZXhEQkNhY2hlTWFwIGV4dGVuZHMgQ2FjaGVNYXAge1xuICBpbXBsZW1lbnRhdGlvblR5cGUgPSBcImJyb3dzZXIvaW5kZXhlZERCXCI7XG4gIGFzeW5jQ2FjaGU7XG4gIG1lbW9yeUNhY2hlO1xuICBzeW5jSW50ZXJ2YWwgPSBudWxsO1xuICBTWU5DX0lOVEVSVkFMX01TID0gNWUzO1xuICAvLyBTeW5jIGV2ZXJ5IDUgc2Vjb25kc1xuICBwZW5kaW5nU3luY09wZXJhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpbml0aWFsaXphdGlvblByb21pc2UgPSBudWxsO1xuICBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIE1BWF9SRVRSWV9BVFRFTVBUUyA9IDM7XG4gIG9wZXJhdGlvblNlcXVlbmNlID0gMDtcbiAgY29uc3RydWN0b3IodHlwZXMsIGRiTmFtZSA9IFwiZmplbGwtaW5kZXhkYi1jYWNoZVwiLCBzdG9yZU5hbWUgPSBcImNhY2hlXCIsIHZlcnNpb24gPSAxKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMuYXN5bmNDYWNoZSA9IG5ldyBBc3luY0luZGV4REJDYWNoZU1hcCh0eXBlcywgZGJOYW1lLCBzdG9yZU5hbWUsIHZlcnNpb24pO1xuICAgIHRoaXMubWVtb3J5Q2FjaGUgPSBuZXcgTWVtb3J5Q2FjaGVNYXAodHlwZXMpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZyb21JbmRleGVkREIoKTtcbiAgICB0aGlzLnN0YXJ0UGVyaW9kaWNTeW5jKCk7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZUZyb21JbmRleGVkREIoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCB0aGlzLmFzeW5jQ2FjaGUua2V5cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm1lbW9yeUNhY2hlLmluY2x1ZGVzS2V5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5hc3luY0NhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRoaXMubWVtb3J5Q2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgZnJvbSBJbmRleGVkREI6XCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgfVxuICBzdGFydFBlcmlvZGljU3luYygpIHtcbiAgICB0aGlzLnN5bmNJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuc3luY1RvSW5kZXhlZERCKCk7XG4gICAgfSwgdGhpcy5TWU5DX0lOVEVSVkFMX01TKTtcbiAgfVxuICBhc3luYyBzeW5jVG9JbmRleGVkREIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCk7XG4gICAgICBjb25zdCBtZW1vcnlLZXlzID0gdGhpcy5tZW1vcnlDYWNoZS5rZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBtZW1vcnlLZXlzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5tZW1vcnlDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5hc3luY0NhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc3luYyB0byBJbmRleGVkREI6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCkge1xuICAgIGNvbnN0IHBlbmRpbmdPcHMgPSBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmVudHJpZXMoKSk7XG4gICAgZm9yIChjb25zdCBba2V5U3RyLCBvcGVyYXRpb25dIG9mIHBlbmRpbmdPcHMpIHtcbiAgICAgIGlmIChvcGVyYXRpb24uY2FuY2VsbGVkKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmRlbGV0ZShrZXlTdHIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9wZXJhdGlvbi5wcm9taXNlO1xuICAgICAgICBjb25zdCBjdXJyZW50T3AgPSB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5nZXQoa2V5U3RyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRPcCAmJiBjdXJyZW50T3Auc2VxdWVuY2VJZCA9PT0gb3BlcmF0aW9uLnNlcXVlbmNlSWQpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5kZWxldGUoa2V5U3RyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcHJvY2VzcyBwZW5kaW5nICR7b3BlcmF0aW9uLnR5cGV9IG9wZXJhdGlvbjpgLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcCA9IHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmdldChrZXlTdHIpO1xuICAgICAgICBpZiAoIWN1cnJlbnRPcCB8fCBjdXJyZW50T3Auc2VxdWVuY2VJZCAhPT0gb3BlcmF0aW9uLnNlcXVlbmNlSWQgfHwgY3VycmVudE9wLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGlmIChjdXJyZW50T3AgJiYgY3VycmVudE9wLnNlcXVlbmNlSWQgPT09IG9wZXJhdGlvbi5zZXF1ZW5jZUlkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5kZWxldGUoa2V5U3RyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcXVldWVGb3JTeW5jKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgIGNvbnN0IHNlcXVlbmNlSWQgPSArK3RoaXMub3BlcmF0aW9uU2VxdWVuY2U7XG4gICAgY29uc3QgZXhpc3RpbmdPcCA9IHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmdldChrZXlTdHIpO1xuICAgIGlmIChleGlzdGluZ09wKSB7XG4gICAgICBleGlzdGluZ09wLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHN5bmNQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYXN5bmNDYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcCA9IHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmdldChrZXlTdHIpO1xuICAgICAgICBpZiAoY3VycmVudE9wICYmIGN1cnJlbnRPcC5zZXF1ZW5jZUlkID09PSBzZXF1ZW5jZUlkICYmICFjdXJyZW50T3AuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZGVsZXRlKGtleVN0cik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzeW5jIHNpbmdsZSBvcGVyYXRpb24gdG8gSW5kZXhlZERCOlwiLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcCA9IHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmdldChrZXlTdHIpO1xuICAgICAgICBpZiAoIWN1cnJlbnRPcCB8fCBjdXJyZW50T3Auc2VxdWVuY2VJZCAhPT0gc2VxdWVuY2VJZCB8fCBjdXJyZW50T3AuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRPcCAmJiBjdXJyZW50T3Auc2VxdWVuY2VJZCA9PT0gc2VxdWVuY2VJZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZGVsZXRlKGtleVN0cik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5zZXQoa2V5U3RyLCB7XG4gICAgICB0eXBlOiBcInNldFwiLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBzZXF1ZW5jZUlkLFxuICAgICAgcHJvbWlzZTogc3luY1Byb21pc2UsXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcXVldWVEZWxldGVGb3JTeW5jKGtleSkge1xuICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZCA9ICsrdGhpcy5vcGVyYXRpb25TZXF1ZW5jZTtcbiAgICBjb25zdCBleGlzdGluZ09wID0gdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZ2V0KGtleVN0cik7XG4gICAgaWYgKGV4aXN0aW5nT3ApIHtcbiAgICAgIGV4aXN0aW5nT3AuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3luY1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hc3luY0NhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCBjdXJyZW50T3AgPSB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5nZXQoa2V5U3RyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRPcCAmJiBjdXJyZW50T3Auc2VxdWVuY2VJZCA9PT0gc2VxdWVuY2VJZCAmJiAhY3VycmVudE9wLmNhbmNlbGxlZCkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmRlbGV0ZShrZXlTdHIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc3luYyBkZWxldGUgb3BlcmF0aW9uIHRvIEluZGV4ZWREQjpcIiwgZXJyb3IpO1xuICAgICAgICBjb25zdCBjdXJyZW50T3AgPSB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5nZXQoa2V5U3RyKTtcbiAgICAgICAgaWYgKCFjdXJyZW50T3AgfHwgY3VycmVudE9wLnNlcXVlbmNlSWQgIT09IHNlcXVlbmNlSWQgfHwgY3VycmVudE9wLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGlmIChjdXJyZW50T3AgJiYgY3VycmVudE9wLnNlcXVlbmNlSWQgPT09IHNlcXVlbmNlSWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmRlbGV0ZShrZXlTdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKCk7XG4gICAgdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuc2V0KGtleVN0ciwge1xuICAgICAgdHlwZTogXCJkZWxldGVcIixcbiAgICAgIGtleSxcbiAgICAgIHNlcXVlbmNlSWQsXG4gICAgICBwcm9taXNlOiBzeW5jUHJvbWlzZSxcbiAgICAgIGNhbmNlbGxlZDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBxdWV1ZUNsZWFyRm9yU3luYygpIHtcbiAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgb3BlcmF0aW9uLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmNsZWFyKCk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmFzeW5jQ2FjaGUuY2xlYXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzeW5jIGNsZWFyIG9wZXJhdGlvbiB0byBJbmRleGVkREI6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW5kZXhlZERCIGluaXRpYWxpemF0aW9uIGZhaWxlZCwgdXNpbmcgbWVtb3J5IGNhY2hlIG9ubHk6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuZ2V0KGtleSk7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm1lbW9yeUNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLnF1ZXVlRm9yU3luYyhrZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBpbmNsdWRlc0tleShrZXkpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCAmJiB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbmRleGVkREIgaW5pdGlhbGl6YXRpb24gZmFpbGVkLCB1c2luZyBtZW1vcnkgY2FjaGUgb25seTpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5pbmNsdWRlc0tleShrZXkpO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLm1lbW9yeUNhY2hlLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMucXVldWVEZWxldGVGb3JTeW5jKGtleSk7XG4gIH1cbiAgYXN5bmMgYWxsSW4obG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuYWxsSW4obG9jYXRpb25zKTtcbiAgfVxuICBhc3luYyBjb250YWlucyhxdWVyeSwgbG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuY29udGFpbnMocXVlcnksIGxvY2F0aW9ucyk7XG4gIH1cbiAgYXN5bmMgcXVlcnlJbihxdWVyeSwgbG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUucXVlcnlJbihxdWVyeSwgbG9jYXRpb25zKTtcbiAgfVxuICBhc3luYyBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9JbmRleERCQ2FjaGVNYXAodGhpcy50eXBlcyk7XG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5rZXlzKCk7XG4gIH1cbiAgYXN5bmMgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLnZhbHVlcygpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMubWVtb3J5Q2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLnF1ZXVlQ2xlYXJGb3JTeW5jKCk7XG4gIH1cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuICBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGl0ZW1LZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cyk7XG4gIH1cbiAgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW5kZXhlZERCIGluaXRpYWxpemF0aW9uIGZhaWxlZCwgdXNpbmcgbWVtb3J5IGNhY2hlIG9ubHk6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgfVxuICBoYXNRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5oYXNRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICB9XG4gIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIH1cbiAgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXMpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5pbnZhbGlkYXRlSXRlbUtleXMoa2V5cyk7XG4gIH1cbiAgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLm1lbW9yeUNhY2hlLmludmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbnMpO1xuICB9XG4gIGNsZWFyUXVlcnlSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHJlc291cmNlcyB3aGVuIHRoZSBjYWNoZSBpcyBubyBsb25nZXIgbmVlZGVkXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN5bmNJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNJbnRlcnZhbCk7XG4gICAgICB0aGlzLnN5bmNJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8vIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciBpbXBsZW1lbnRhdGlvblxuICAvLyBEZWxlZ2F0ZSB0byB0aGUgbWVtb3J5IGNhY2hlIGZvciBtZXRhZGF0YSBvcGVyYXRpb25zIGZvciBjb25zaXN0ZW5jeVxuICBnZXRNZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5nZXRNZXRhZGF0YShrZXkpO1xuICB9XG4gIHNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpIHtcbiAgICB0aGlzLm1lbW9yeUNhY2hlLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIGRlbGV0ZU1ldGFkYXRhKGtleSkge1xuICAgIHRoaXMubWVtb3J5Q2FjaGUuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuICBnZXRBbGxNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5nZXRBbGxNZXRhZGF0YSgpO1xuICB9XG4gIGNsZWFyTWV0YWRhdGEoKSB7XG4gICAgdGhpcy5tZW1vcnlDYWNoZS5jbGVhck1ldGFkYXRhKCk7XG4gIH1cbiAgZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuZ2V0Q3VycmVudFNpemUoKTtcbiAgfVxuICBnZXRTaXplTGltaXRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmdldFNpemVMaW1pdHMoKTtcbiAgfVxufTtcblxuLy8gc3JjL09wdGlvbnMudHNcbnZhciBERUZBVUxUX0NBQ0hFX09QVElPTlMgPSB7XG4gIGNhY2hlVHlwZTogXCJtZW1vcnlcIixcbiAgZW5hYmxlRGVidWdMb2dnaW5nOiBmYWxzZSxcbiAgYXV0b1N5bmM6IHRydWUsXG4gIG1heFJldHJpZXM6IDMsXG4gIHJldHJ5RGVsYXk6IDFlMyxcbiAgaW5kZXhlZERCQ29uZmlnOiB7XG4gICAgZGJOYW1lOiBcImZqZWxsLWNhY2hlXCIsXG4gICAgdmVyc2lvbjogMSxcbiAgICBzdG9yZU5hbWU6IFwiY2FjaGVcIixcbiAgICBzaXplOiB7XG4gICAgICBldmljdGlvblBvbGljeTogXCJscnVcIlxuICAgIH1cbiAgfSxcbiAgd2ViU3RvcmFnZUNvbmZpZzoge1xuICAgIGtleVByZWZpeDogXCJmamVsbC1jYWNoZTpcIixcbiAgICBjb21wcmVzczogZmFsc2UsXG4gICAgc2l6ZToge1xuICAgICAgZXZpY3Rpb25Qb2xpY3k6IFwibHJ1XCJcbiAgICB9XG4gIH0sXG4gIG1lbW9yeUNvbmZpZzoge1xuICAgIC8vIE5vIGxpbWl0cyBieSBkZWZhdWx0XG4gICAgc2l6ZToge1xuICAgICAgZXZpY3Rpb25Qb2xpY3k6IFwibHJ1XCJcbiAgICB9XG4gIH1cbn07XG52YXIgY3JlYXRlT3B0aW9ucyA9IChjYWNoZU9wdGlvbnMpID0+IHtcbiAgY29uc3QgaW5kZXhlZERCQ29uZmlnID0gY2FjaGVPcHRpb25zPy5pbmRleGVkREJDb25maWcgPyB7XG4gICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLmluZGV4ZWREQkNvbmZpZyxcbiAgICAuLi5jYWNoZU9wdGlvbnMuaW5kZXhlZERCQ29uZmlnLFxuICAgIHNpemU6IGNhY2hlT3B0aW9ucy5pbmRleGVkREJDb25maWcuc2l6ZSA/IHtcbiAgICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5pbmRleGVkREJDb25maWc/LnNpemUsXG4gICAgICAuLi5jYWNoZU9wdGlvbnMuaW5kZXhlZERCQ29uZmlnLnNpemVcbiAgICB9IDogREVGQVVMVF9DQUNIRV9PUFRJT05TLmluZGV4ZWREQkNvbmZpZz8uc2l6ZVxuICB9IDogeyAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMuaW5kZXhlZERCQ29uZmlnIH07XG4gIGNvbnN0IHdlYlN0b3JhZ2VDb25maWcgPSBjYWNoZU9wdGlvbnM/LndlYlN0b3JhZ2VDb25maWcgPyB7XG4gICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLndlYlN0b3JhZ2VDb25maWcsXG4gICAgLi4uY2FjaGVPcHRpb25zLndlYlN0b3JhZ2VDb25maWcsXG4gICAgc2l6ZTogY2FjaGVPcHRpb25zLndlYlN0b3JhZ2VDb25maWcuc2l6ZSA/IHtcbiAgICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy53ZWJTdG9yYWdlQ29uZmlnPy5zaXplLFxuICAgICAgLi4uY2FjaGVPcHRpb25zLndlYlN0b3JhZ2VDb25maWcuc2l6ZVxuICAgIH0gOiBERUZBVUxUX0NBQ0hFX09QVElPTlMud2ViU3RvcmFnZUNvbmZpZz8uc2l6ZVxuICB9IDogeyAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMud2ViU3RvcmFnZUNvbmZpZyB9O1xuICBjb25zdCBtZW1vcnlDb25maWcgPSBjYWNoZU9wdGlvbnM/Lm1lbW9yeUNvbmZpZyA/IHtcbiAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMubWVtb3J5Q29uZmlnLFxuICAgIC4uLmNhY2hlT3B0aW9ucy5tZW1vcnlDb25maWcsXG4gICAgc2l6ZTogY2FjaGVPcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplID8ge1xuICAgICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLm1lbW9yeUNvbmZpZz8uc2l6ZSxcbiAgICAgIC4uLmNhY2hlT3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZVxuICAgIH0gOiBERUZBVUxUX0NBQ0hFX09QVElPTlMubWVtb3J5Q29uZmlnPy5zaXplXG4gIH0gOiB7IC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5tZW1vcnlDb25maWcgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMsXG4gICAgLi4uY2FjaGVPcHRpb25zLFxuICAgIGluZGV4ZWREQkNvbmZpZyxcbiAgICB3ZWJTdG9yYWdlQ29uZmlnLFxuICAgIG1lbW9yeUNvbmZpZ1xuICB9O1xufTtcbnZhciBjcmVhdGVDYWNoZU1hcCA9IChrdGEsIG9wdGlvbnMpID0+IHtcbiAgc3dpdGNoIChvcHRpb25zLmNhY2hlVHlwZSkge1xuICAgIGNhc2UgXCJtZW1vcnlcIjpcbiAgICAgIGlmIChvcHRpb25zLm1lbW9yeUNvbmZpZz8uc2l6ZSAmJiAob3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZS5tYXhTaXplQnl0ZXMgfHwgb3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZS5tYXhJdGVtcykpIHtcbiAgICAgICAgY29uc3Qgc2l6ZUNvbmZpZyA9IHtcbiAgICAgICAgICBtYXhTaXplQnl0ZXM6IG9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4U2l6ZUJ5dGVzLFxuICAgICAgICAgIG1heEl0ZW1zOiBvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heEl0ZW1zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRW5oYW5jZWRNZW1vcnlDYWNoZU1hcChcbiAgICAgICAgICBrdGEsXG4gICAgICAgICAgc2l6ZUNvbmZpZ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNZW1vcnlDYWNoZU1hcChrdGEpO1xuICAgIGNhc2UgXCJsb2NhbFN0b3JhZ2VcIjpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxTdG9yYWdlQ2FjaGVNYXAoXG4gICAgICAgIGt0YSxcbiAgICAgICAgb3B0aW9ucy53ZWJTdG9yYWdlQ29uZmlnPy5rZXlQcmVmaXhcbiAgICAgICk7XG4gICAgY2FzZSBcInNlc3Npb25TdG9yYWdlXCI6XG4gICAgICByZXR1cm4gbmV3IFNlc3Npb25TdG9yYWdlQ2FjaGVNYXAoXG4gICAgICAgIGt0YSxcbiAgICAgICAgb3B0aW9ucy53ZWJTdG9yYWdlQ29uZmlnPy5rZXlQcmVmaXhcbiAgICAgICk7XG4gICAgY2FzZSBcImluZGV4ZWREQlwiOlxuICAgICAgcmV0dXJuIG5ldyBJbmRleERCQ2FjaGVNYXAoXG4gICAgICAgIGt0YSxcbiAgICAgICAgb3B0aW9ucy5pbmRleGVkREJDb25maWc/LmRiTmFtZSxcbiAgICAgICAgb3B0aW9ucy5pbmRleGVkREJDb25maWc/LnN0b3JlTmFtZSxcbiAgICAgICAgb3B0aW9ucy5pbmRleGVkREJDb25maWc/LnZlcnNpb25cbiAgICAgICk7XG4gICAgY2FzZSBcImN1c3RvbVwiOlxuICAgICAgaWYgKCFvcHRpb25zLmN1c3RvbUNhY2hlTWFwRmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBjYWNoZSBtYXAgZmFjdG9yeSBpcyByZXF1aXJlZCB3aGVuIGNhY2hlVHlwZSBpcyBcImN1c3RvbVwiJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5jdXN0b21DYWNoZU1hcEZhY3Rvcnkoa3RhKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjYWNoZSB0eXBlOiAke29wdGlvbnMuY2FjaGVUeXBlfWApO1xuICB9XG59O1xudmFyIHZhbGlkYXRlT3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zLmNhY2hlVHlwZSA9PT0gXCJjdXN0b21cIiAmJiAhb3B0aW9ucy5jdXN0b21DYWNoZU1hcEZhY3RvcnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1c3RvbUNhY2hlTWFwRmFjdG9yeSBpcyByZXF1aXJlZCB3aGVuIGNhY2hlVHlwZSBpcyBcImN1c3RvbVwiJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1heFJldHJpZXMgPT09IFwibnVtYmVyXCIgJiYgb3B0aW9ucy5tYXhSZXRyaWVzIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1heFJldHJpZXMgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJldHJ5RGVsYXkgPT09IFwibnVtYmVyXCIgJiYgb3B0aW9ucy5yZXRyeURlbGF5IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJldHJ5RGVsYXkgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnR0bCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLnR0bCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHRsIG11c3QgYmUgcG9zaXRpdmVcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1lbW9yeUNvbmZpZz8ubWF4SXRlbXMgPT09IFwibnVtYmVyXCIgJiYgb3B0aW9ucy5tZW1vcnlDb25maWcubWF4SXRlbXMgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1lbW9yeUNvbmZpZy5tYXhJdGVtcyBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLm1lbW9yeUNvbmZpZz8uc2l6ZSkge1xuICAgIHZhbGlkYXRlU2l6ZUNvbmZpZyhvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplKTtcbiAgfVxuICBpZiAob3B0aW9ucy53ZWJTdG9yYWdlQ29uZmlnPy5zaXplKSB7XG4gICAgdmFsaWRhdGVTaXplQ29uZmlnKG9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZy5zaXplKTtcbiAgfVxuICBpZiAob3B0aW9ucy5pbmRleGVkREJDb25maWc/LnNpemUpIHtcbiAgICB2YWxpZGF0ZVNpemVDb25maWcob3B0aW9ucy5pbmRleGVkREJDb25maWcuc2l6ZSk7XG4gIH1cbiAgaWYgKFtcImxvY2FsU3RvcmFnZVwiLCBcInNlc3Npb25TdG9yYWdlXCJdLmluY2x1ZGVzKG9wdGlvbnMuY2FjaGVUeXBlKSkge1xuICAgIGNvbnN0IGlzUmVhbEJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgaWYgKCFpc1JlYWxCcm93c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ucy5jYWNoZVR5cGV9IGlzIG5vdCBhdmFpbGFibGUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzYCk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhY2hlVHlwZSA9PT0gXCJpbmRleGVkREJcIikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3cuaW5kZXhlZERCKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ucy5jYWNoZVR5cGV9IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudGApO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5jYWNoZVR5cGUgPT09IFwiYXN5bmNJbmRleGVkREJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jSW5kZXhlZERCIGNhbm5vdCBiZSB1c2VkIHdpdGggc3luY2hyb25vdXMgY2FjaGUgZmFjdG9yeS4gVXNlIEFzeW5jSW5kZXhEQkNhY2hlTWFwIGRpcmVjdGx5IGZvciBhc3luYyBvcGVyYXRpb25zLlwiKTtcbiAgfVxufTtcblxuLy8gc3JjL29wcy9yZXNldC50c1xudmFyIHJlc2V0ID0gYXN5bmMgKGNvb3JkaW5hdGUsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgY2FjaGVNYXAgPSBjcmVhdGVDYWNoZU1hcChjb29yZGluYXRlLmt0YSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFtjYWNoZU1hcF07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9PcGVyYXRpb25zLnRzXG52YXIgY3JlYXRlT3BlcmF0aW9ucyA9IChhcGksIGNvb3JkaW5hdGUsIGNhY2hlTWFwLCBwa1R5cGUsIG9wdGlvbnMsIGV2ZW50RW1pdHRlciwgdHRsTWFuYWdlciwgZXZpY3Rpb25NYW5hZ2VyLCBzdGF0c01hbmFnZXIpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhY2hlQ29udGV4dChhcGksIGNhY2hlTWFwLCBwa1R5cGUsIG9wdGlvbnMsIGV2ZW50RW1pdHRlciwgdHRsTWFuYWdlciwgZXZpY3Rpb25NYW5hZ2VyLCBzdGF0c01hbmFnZXIpO1xuICByZXR1cm4ge1xuICAgIGFsbDogKHF1ZXJ5LCBsb2NhdGlvbnMpID0+IGFsbChxdWVyeSwgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIG9uZTogKHF1ZXJ5LCBsb2NhdGlvbnMpID0+IG9uZShxdWVyeSwgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGNyZWF0ZTogKGl0ZW0sIGxvY2F0aW9ucykgPT4gY3JlYXRlKGl0ZW0sIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBnZXQ6IChrZXkpID0+IGdldChrZXksIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgcmV0cmlldmU6IChrZXkpID0+IHJldHJpZXZlKGtleSwgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICByZW1vdmU6IChrZXkpID0+IHJlbW92ZShrZXksIGNvbnRleHQpLnRoZW4oKGN0eCkgPT4gdm9pZCAwKSxcbiAgICB1cGRhdGU6IChrZXksIGl0ZW0pID0+IHVwZGF0ZShrZXksIGl0ZW0sIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgYWN0aW9uOiAoa2V5LCBhY3Rpb25OYW1lLCBib2R5KSA9PiBhY3Rpb24oa2V5LCBhY3Rpb25OYW1lLCBib2R5LCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGFsbEFjdGlvbjogKGFjdGlvbk5hbWUsIGJvZHksIGxvY2F0aW9ucykgPT4gYWxsQWN0aW9uKGFjdGlvbk5hbWUsIGJvZHksIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBmYWNldDogKGtleSwgZmFjZXROYW1lLCBwYXJhbXMpID0+IGZhY2V0KGtleSwgZmFjZXROYW1lLCBwYXJhbXMsIGNvbnRleHQpLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0KSxcbiAgICBhbGxGYWNldDogKGZhY2V0TmFtZSwgcGFyYW1zLCBsb2NhdGlvbnMpID0+IGFsbEZhY2V0KGZhY2V0TmFtZSwgcGFyYW1zLCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0KSxcbiAgICBmaW5kOiAoZmluZGVyLCBwYXJhbXMsIGxvY2F0aW9ucykgPT4gZmluZChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGZpbmRPbmU6IChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zKSA9PiBmaW5kT25lKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgc2V0OiAoa2V5LCBpdGVtKSA9PiBzZXQoa2V5LCBpdGVtLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIHJlc2V0OiAoKSA9PiByZXNldChjb29yZGluYXRlLCBvcHRpb25zKS50aGVuKCgpID0+IHZvaWQgMClcbiAgfTtcbn07XG5cbi8vIHNyYy9ldmljdGlvbi9FdmljdGlvbk1hbmFnZXIudHNcbnZhciBsb2dnZXIyMCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkV2aWN0aW9uTWFuYWdlclwiKTtcbnZhciBFdmljdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGV2aWN0aW9uU3RyYXRlZ3k7XG4gIGNvbnN0cnVjdG9yKGV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kgPSBldmljdGlvblN0cmF0ZWd5IHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvciB1cGRhdGUgdGhlIGV2aWN0aW9uIHN0cmF0ZWd5XG4gICAqIEBwYXJhbSBzdHJhdGVneSAtIFRoZSBldmljdGlvbiBzdHJhdGVneSB0byB1c2VcbiAgICovXG4gIHNldEV2aWN0aW9uU3RyYXRlZ3koc3RyYXRlZ3kpIHtcbiAgICB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICBsb2dnZXIyMC5kZWJ1ZyhcIkV2aWN0aW9uIHN0cmF0ZWd5IHVwZGF0ZWRcIiwge1xuICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5Py5nZXRTdHJhdGVneU5hbWUoKSB8fCBcIm5vbmVcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZXZpY3Rpb24gc3RyYXRlZ3kgbmFtZVxuICAgKiBAcmV0dXJucyBTdHJhdGVneSBuYW1lIG9yIG51bGwgaWYgbm8gZXZpY3Rpb25cbiAgICovXG4gIGdldEV2aWN0aW9uU3RyYXRlZ3lOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmV2aWN0aW9uU3RyYXRlZ3k/LmdldFN0cmF0ZWd5TmFtZSgpIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBpdGVtIGFjY2VzcyAtIHVwZGF0ZSBtZXRhZGF0YSBmb3IgZXZpY3Rpb24gc3RyYXRlZ3lcbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gQ2FjaGUgbWV0YWRhdGEgcHJvdmlkZXJcbiAgICovXG4gIG9uSXRlbUFjY2Vzc2VkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGlmICghdGhpcy5ldmljdGlvblN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kub25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMjAuZXJyb3IoXCJFcnJvciBpbiBldmljdGlvbiBzdHJhdGVneSBvbkl0ZW1BY2Nlc3NlZFwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgaXRlbSBhZGRpdGlvbiAtIHVwZGF0ZSBtZXRhZGF0YSBhbmQgcGVyZm9ybSBldmljdGlvbiBpZiBuZWVkZWRcbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSB2YWx1ZSAtIEl0ZW0gdmFsdWUgKGZvciBzaXplIGVzdGltYXRpb24pXG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gQ2FjaGUgbWV0YWRhdGEgcHJvdmlkZXJcbiAgICogQHJldHVybnMgQXJyYXkgb2Yga2V5cyB0aGF0IHdlcmUgZXZpY3RlZFxuICAgKi9cbiAgb25JdGVtQWRkZWQoa2V5LCB2YWx1ZSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gW107XG4gICAgaWYgKCF0aGlzLmV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBldmljdGVkS2V5cztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZSh2YWx1ZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jcmVhdGVFdmljdGlvbkNvbnRleHQobWV0YWRhdGFQcm92aWRlciwgZXN0aW1hdGVkU2l6ZSk7XG4gICAgICBjb25zdCBrZXlzVG9FdmljdCA9IHRoaXMuZXZpY3Rpb25TdHJhdGVneS5zZWxlY3RGb3JFdmljdGlvbihtZXRhZGF0YVByb3ZpZGVyLCBjb250ZXh0KTtcbiAgICAgIGZvciAoY29uc3QgZXZpY3RLZXkgb2Yga2V5c1RvRXZpY3QpIHtcbiAgICAgICAgdGhpcy5ldmljdGlvblN0cmF0ZWd5Lm9uSXRlbVJlbW92ZWQoZXZpY3RLZXksIG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgICAgICBldmljdGVkS2V5cy5wdXNoKGV2aWN0S2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1BZGRlZChrZXksIGVzdGltYXRlZFNpemUsIG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgICAgaWYgKGV2aWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbG9nZ2VyMjAuZGVidWcoXCJJdGVtcyBldmljdGVkIGR1cmluZyBhZGRpdGlvblwiLCB7XG4gICAgICAgICAgbmV3S2V5OiBrZXksXG4gICAgICAgICAgZXZpY3RlZEtleXMsXG4gICAgICAgICAgc3RyYXRlZ3k6IHRoaXMuZXZpY3Rpb25TdHJhdGVneS5nZXRTdHJhdGVneU5hbWUoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMjAuZXJyb3IoXCJFcnJvciBpbiBldmljdGlvbiBzdHJhdGVneSBvbkl0ZW1BZGRlZFwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBldmljdGVkS2V5cztcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGl0ZW0gcmVtb3ZhbCAtIGNsZWFuIHVwIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqL1xuICBvbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGlmICghdGhpcy5ldmljdGlvblN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kub25JdGVtUmVtb3ZlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIyMC5lcnJvcihcIkVycm9yIGluIGV2aWN0aW9uIHN0cmF0ZWd5IG9uSXRlbVJlbW92ZWRcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBtYW51YWwgZXZpY3Rpb24gY2hlY2tcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXlzIHRoYXQgd2VyZSBldmljdGVkXG4gICAqL1xuICBwZXJmb3JtRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gW107XG4gICAgaWYgKCF0aGlzLmV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBldmljdGVkS2V5cztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNyZWF0ZUV2aWN0aW9uQ29udGV4dChtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IGtleXNUb0V2aWN0ID0gdGhpcy5ldmljdGlvblN0cmF0ZWd5LnNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpO1xuICAgICAgZm9yIChjb25zdCBldmljdEtleSBvZiBrZXlzVG9FdmljdCkge1xuICAgICAgICB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kub25JdGVtUmVtb3ZlZChldmljdEtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgICAgIGV2aWN0ZWRLZXlzLnB1c2goZXZpY3RLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKGV2aWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbG9nZ2VyMjAuZGVidWcoXCJNYW51YWwgZXZpY3Rpb24gcGVyZm9ybWVkXCIsIHtcbiAgICAgICAgICBldmljdGVkS2V5cyxcbiAgICAgICAgICBzdHJhdGVneTogdGhpcy5ldmljdGlvblN0cmF0ZWd5LmdldFN0cmF0ZWd5TmFtZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIyMC5lcnJvcihcIkVycm9yIGluIG1hbnVhbCBldmljdGlvblwiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXZpY3RlZEtleXM7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGV2aWN0aW9uIGlzIHN1cHBvcnRlZCAoaS5lLiwgc3RyYXRlZ3kgaXMgc2V0KVxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGV2aWN0aW9uIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgaXNFdmljdGlvblN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmljdGlvblN0cmF0ZWd5ICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgZXZpY3Rpb24gY29udGV4dCBmcm9tIGN1cnJlbnQgY2FjaGUgc3RhdGVcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKiBAcGFyYW0gbmV3SXRlbVNpemUgLSBTaXplIG9mIGl0ZW0gYmVpbmcgYWRkZWQgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyBFdmljdGlvbiBjb250ZXh0XG4gICAqL1xuICBjcmVhdGVFdmljdGlvbkNvbnRleHQobWV0YWRhdGFQcm92aWRlciwgbmV3SXRlbVNpemUpIHtcbiAgICBjb25zdCBjdXJyZW50U2l6ZSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0Q3VycmVudFNpemUoKTtcbiAgICBjb25zdCBsaW1pdHMgPSBtZXRhZGF0YVByb3ZpZGVyLmdldFNpemVMaW1pdHMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudFNpemUsXG4gICAgICBsaW1pdHMsXG4gICAgICBuZXdJdGVtU2l6ZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5Q29uZmlnLnRzXG52YXIgREVGQVVMVF9MRlVfQ09ORklHID0ge1xuICB0eXBlOiBcImxmdVwiLFxuICBkZWNheUZhY3RvcjogMC4xLFxuICBkZWNheUludGVydmFsOiA2ZTQsXG4gIC8vIDEgbWludXRlXG4gIHNrZXRjaFdpZHRoOiAxMDI0LFxuICBza2V0Y2hEZXB0aDogNCxcbiAgdXNlUHJvYmFiaWxpc3RpY0NvdW50aW5nOiB0cnVlLFxuICBtaW5GcmVxdWVuY3lUaHJlc2hvbGQ6IDFcbn07XG52YXIgREVGQVVMVF9BUkNfQ09ORklHID0ge1xuICB0eXBlOiBcImFyY1wiLFxuICBtYXhDYWNoZVNpemU6IDFlMyxcbiAgZnJlcXVlbmN5VGhyZXNob2xkOiAyLFxuICB1c2VFbmhhbmNlZEZyZXF1ZW5jeTogdHJ1ZSxcbiAgZnJlcXVlbmN5RGVjYXlGYWN0b3I6IDAuMDUsXG4gIGZyZXF1ZW5jeURlY2F5SW50ZXJ2YWw6IDZlNSxcbiAgLy8gMTAgbWludXRlc1xuICB1c2VGcmVxdWVuY3lXZWlnaHRlZFNlbGVjdGlvbjogdHJ1ZSxcbiAgYWRhcHRpdmVMZWFybmluZ1JhdGU6IDFcbn07XG52YXIgREVGQVVMVF9UV09fUVVFVUVfQ09ORklHID0ge1xuICB0eXBlOiBcIjJxXCIsXG4gIG1heENhY2hlU2l6ZTogMWUzLFxuICB1c2VGcmVxdWVuY3lQcm9tb3Rpb246IHRydWUsXG4gIHByb21vdGlvblRocmVzaG9sZDogMixcbiAgaG90UXVldWVEZWNheUZhY3RvcjogMC4wNSxcbiAgaG90UXVldWVEZWNheUludGVydmFsOiAzZTUsXG4gIC8vIDUgbWludXRlc1xuICB1c2VGcmVxdWVuY3lXZWlnaHRlZExSVTogdHJ1ZVxufTtcblxuLy8gc3JjL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3kudHNcbnZhciBFdmljdGlvblN0cmF0ZWd5ID0gY2xhc3Mge1xuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGV2aWN0aW9uIGlzIG5lZWRlZCBiYXNlZCBvbiBjdXJyZW50IGNvbnRleHRcbiAgICogQHBhcmFtIGNvbnRleHQgLSBDdXJyZW50IGNhY2hlIHN0YXRlIGFuZCBsaW1pdHNcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBldmljdGlvbiBzaG91bGQgb2NjdXJcbiAgICovXG4gIGlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkge1xuICAgIGNvbnN0IHsgY3VycmVudFNpemUsIGxpbWl0cywgbmV3SXRlbVNpemUgPSAwIH0gPSBjb250ZXh0O1xuICAgIGlmIChsaW1pdHMubWF4SXRlbXMgIT09IG51bGwgJiYgY3VycmVudFNpemUuaXRlbUNvdW50ID49IGxpbWl0cy5tYXhJdGVtcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChsaW1pdHMubWF4U2l6ZUJ5dGVzICE9PSBudWxsICYmIGN1cnJlbnRTaXplLnNpemVCeXRlcyArIG5ld0l0ZW1TaXplID4gbGltaXRzLm1heFNpemVCeXRlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIGhvdyBtYW55IGl0ZW1zIG5lZWQgdG8gYmUgZXZpY3RlZFxuICAgKiBAcGFyYW0gY29udGV4dCAtIEN1cnJlbnQgY2FjaGUgc3RhdGUgYW5kIGxpbWl0c1xuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgaXRlbXMgdGhhdCBzaG91bGQgYmUgZXZpY3RlZFxuICAgKi9cbiAgY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KSB7XG4gICAgY29uc3QgeyBjdXJyZW50U2l6ZSwgbGltaXRzLCBuZXdJdGVtU2l6ZSA9IDAgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGV2aWN0aW9uQ291bnQgPSAwO1xuICAgIGlmIChsaW1pdHMubWF4SXRlbXMgIT09IG51bGwgJiYgY3VycmVudFNpemUuaXRlbUNvdW50ID49IGxpbWl0cy5tYXhJdGVtcykge1xuICAgICAgZXZpY3Rpb25Db3VudCA9IE1hdGgubWF4KGV2aWN0aW9uQ291bnQsIGN1cnJlbnRTaXplLml0ZW1Db3VudCAtIGxpbWl0cy5tYXhJdGVtcyArIDEpO1xuICAgIH1cbiAgICBpZiAobGltaXRzLm1heFNpemVCeXRlcyAhPT0gbnVsbCAmJiBjdXJyZW50U2l6ZS5zaXplQnl0ZXMgKyBuZXdJdGVtU2l6ZSA+IGxpbWl0cy5tYXhTaXplQnl0ZXMpIHtcbiAgICAgIGNvbnN0IGV4Y2Vzc0J5dGVzID0gY3VycmVudFNpemUuc2l6ZUJ5dGVzICsgbmV3SXRlbVNpemUgLSBsaW1pdHMubWF4U2l6ZUJ5dGVzO1xuICAgICAgY29uc3QgYXZnSXRlbVNpemUgPSBjdXJyZW50U2l6ZS5pdGVtQ291bnQgPiAwID8gY3VycmVudFNpemUuc2l6ZUJ5dGVzIC8gY3VycmVudFNpemUuaXRlbUNvdW50IDogMTAyNDtcbiAgICAgIGNvbnN0IGVzdGltYXRlZEV2aWN0aW9uQ291bnQgPSBNYXRoLmNlaWwoZXhjZXNzQnl0ZXMgLyBhdmdJdGVtU2l6ZSk7XG4gICAgICBldmljdGlvbkNvdW50ID0gTWF0aC5tYXgoZXZpY3Rpb25Db3VudCwgZXN0aW1hdGVkRXZpY3Rpb25Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiBldmljdGlvbkNvdW50O1xuICB9XG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9MUlVFdmljdGlvblN0cmF0ZWd5LnRzXG52YXIgTFJVRXZpY3Rpb25TdHJhdGVneSA9IGNsYXNzIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIHNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGNvbnN0IGtleXNUb0V2aWN0ID0gW107XG4gICAgY29uc3Qgc29ydGVkRW50cmllcyA9IEFycmF5LmZyb20oYWxsTWV0YWRhdGEuZW50cmllcygpKS5zb3J0KChbLCBhXSwgWywgYl0pID0+IGEubGFzdEFjY2Vzc2VkQXQgLSBiLmxhc3RBY2Nlc3NlZEF0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGV2aWN0aW9uQ291bnQsIHNvcnRlZEVudHJpZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBrZXlzVG9FdmljdC5wdXNoKHNvcnRlZEVudHJpZXNbaV1bMF0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5c1RvRXZpY3Q7XG4gIH1cbiAgb25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gIH1cbiAgb25JdGVtQWRkZWQoa2V5LCBlc3RpbWF0ZWRTaXplLCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemVcbiAgICB9O1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cbiAgb25JdGVtUmVtb3ZlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cbiAgZ2V0U3RyYXRlZ3lOYW1lKCkge1xuICAgIHJldHVybiBcImxydVwiO1xuICB9XG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneVZhbGlkYXRpb24udHNcbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyUmFuZ2UodmFsdWUsIG1pbiwgbWF4LCBmaWVsZE5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtmaWVsZE5hbWV9IG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyYCk7XG4gIH1cbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ZpZWxkTmFtZX0gbXVzdCBiZSBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9LCBnb3QgJHt2YWx1ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIodmFsdWUsIGZpZWxkTmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ZpZWxkTmFtZX0gbXVzdCBiZSBhIGZpbml0ZSBudW1iZXJgKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgZ290ICR7dmFsdWV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhbml0aXplTEZVQ29uZmlnKGNvbmZpZykge1xuICBjb25zdCBzYW5pdGl6ZWQgPSB7IC4uLmNvbmZpZyB9O1xuICBpZiAodHlwZW9mIHNhbml0aXplZC5kZWNheUZhY3RvciA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChzYW5pdGl6ZWQuZGVjYXlGYWN0b3IgPCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGRlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuZGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuZGVjYXlGYWN0b3IgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLmRlY2F5RmFjdG9yID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKGBkZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmRlY2F5RmFjdG9yfS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgICAgc2FuaXRpemVkLmRlY2F5RmFjdG9yID0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuZGVjYXlJbnRlcnZhbCA9PT0gXCJudW1iZXJcIiAmJiBzYW5pdGl6ZWQuZGVjYXlJbnRlcnZhbCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBkZWNheUludGVydmFsIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5kZWNheUludGVydmFsfS4gQ29ycmVjdGluZyB0byAzMDAwMDAuYCk7XG4gICAgc2FuaXRpemVkLmRlY2F5SW50ZXJ2YWwgPSAzZTU7XG4gIH1cbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuc2tldGNoV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoc2FuaXRpemVkLnNrZXRjaFdpZHRoIDw9IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoV2lkdGggbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaFdpZHRofS4gQ29ycmVjdGluZyB0byAxMDI0LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaFdpZHRoID0gMTAyNDtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5za2V0Y2hXaWR0aCA8IDE2KSB7XG4gICAgICBjb25zb2xlLndhcm4oYHNrZXRjaFdpZHRoIHNob3VsZCBiZSBhdCBsZWFzdCAxNiBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaFdpZHRofS4gQ29ycmVjdGluZyB0byAxNi5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hXaWR0aCA9IDE2O1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLnNrZXRjaFdpZHRoID4gNjU1MzYpIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoV2lkdGggc2hvdWxkIG5vdCBleGNlZWQgNjU1MzYgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UsIGdvdCAke3Nhbml0aXplZC5za2V0Y2hXaWR0aH0uIENvcnJlY3RpbmcgdG8gNjU1MzYuYCk7XG4gICAgICBzYW5pdGl6ZWQuc2tldGNoV2lkdGggPSA2NTUzNjtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuc2tldGNoRGVwdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoc2FuaXRpemVkLnNrZXRjaERlcHRoIDw9IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoRGVwdGggbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaERlcHRofS4gQ29ycmVjdGluZyB0byA0LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaERlcHRoID0gNDtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5za2V0Y2hEZXB0aCA8IDEpIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoRGVwdGggc2hvdWxkIGJlIGF0IGxlYXN0IDEgZm9yIG9wdGltYWwgYWNjdXJhY3ksIGdvdCAke3Nhbml0aXplZC5za2V0Y2hEZXB0aH0uIENvcnJlY3RpbmcgdG8gMS5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hEZXB0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuc2tldGNoRGVwdGggPiAxNikge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hEZXB0aCBzaG91bGQgbm90IGV4Y2VlZCAxNiBmb3Igb3B0aW1hbCBhY2N1cmFjeSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaERlcHRofS4gQ29ycmVjdGluZyB0byAxNi5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hEZXB0aCA9IDE2O1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5taW5GcmVxdWVuY3lUaHJlc2hvbGQgPT09IFwibnVtYmVyXCIgJiYgc2FuaXRpemVkLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBtaW5GcmVxdWVuY3lUaHJlc2hvbGQgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLm1pbkZyZXF1ZW5jeVRocmVzaG9sZH0uIENvcnJlY3RpbmcgdG8gMS5gKTtcbiAgICBzYW5pdGl6ZWQubWluRnJlcXVlbmN5VGhyZXNob2xkID0gMTtcbiAgfVxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVMRlVDb25maWcoY29uZmlnKSB7XG4gIGlmICh0eXBlb2YgY29uZmlnLmRlY2F5RmFjdG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVOdW1iZXJSYW5nZShjb25maWcuZGVjYXlGYWN0b3IsIDAsIDEsIFwiZGVjYXlGYWN0b3JcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuZGVjYXlJbnRlcnZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5kZWNheUludGVydmFsLCBcImRlY2F5SW50ZXJ2YWxcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuc2tldGNoV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcuc2tldGNoV2lkdGgsIFwic2tldGNoV2lkdGhcIik7XG4gICAgaWYgKGNvbmZpZy5za2V0Y2hXaWR0aCA8IDE2IHx8IGNvbmZpZy5za2V0Y2hXaWR0aCA+IDY1NTM2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNrZXRjaFdpZHRoIG11c3QgYmUgYmV0d2VlbiAxNiBhbmQgNjU1MzYsIGdvdCAke2NvbmZpZy5za2V0Y2hXaWR0aH1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuc2tldGNoRGVwdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcuc2tldGNoRGVwdGgsIFwic2tldGNoRGVwdGhcIik7XG4gICAgaWYgKGNvbmZpZy5za2V0Y2hEZXB0aCA8IDEgfHwgY29uZmlnLnNrZXRjaERlcHRoID4gMTYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2tldGNoRGVwdGggbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE2LCBnb3QgJHtjb25maWcuc2tldGNoRGVwdGh9YCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgY29uZmlnLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5taW5GcmVxdWVuY3lUaHJlc2hvbGQsIFwibWluRnJlcXVlbmN5VGhyZXNob2xkXCIpO1xuICB9XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUFSQ0NvbmZpZyhjb25maWcpIHtcbiAgY29uc3Qgc2FuaXRpemVkID0geyAuLi5jb25maWcgfTtcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQubWF4Q2FjaGVTaXplID09PSBcIm51bWJlclwiICYmIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgbWF4Q2FjaGVTaXplIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5tYXhDYWNoZVNpemV9LiBDb3JyZWN0aW5nIHRvIDEwMDAuYCk7XG4gICAgc2FuaXRpemVkLm1heENhY2hlU2l6ZSA9IDFlMztcbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5mcmVxdWVuY3lUaHJlc2hvbGQgPT09IFwibnVtYmVyXCIgJiYgc2FuaXRpemVkLmZyZXF1ZW5jeVRocmVzaG9sZCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBmcmVxdWVuY3lUaHJlc2hvbGQgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLmZyZXF1ZW5jeVRocmVzaG9sZH0uIENvcnJlY3RpbmcgdG8gMi5gKTtcbiAgICBzYW5pdGl6ZWQuZnJlcXVlbmN5VGhyZXNob2xkID0gMjtcbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUZhY3RvciA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeURlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKGBmcmVxdWVuY3lEZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yfS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgICAgc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yID0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA9PT0gXCJudW1iZXJcIiAmJiBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBmcmVxdWVuY3lEZWNheUludGVydmFsIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5mcmVxdWVuY3lEZWNheUludGVydmFsfS4gQ29ycmVjdGluZyB0byA2MDAwMC5gKTtcbiAgICBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA9IDZlNDtcbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGUgPCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGFkYXB0aXZlTGVhcm5pbmdSYXRlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMCwgZ290ICR7c2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlfS4gQ29ycmVjdGluZyB0byAwLmApO1xuICAgICAgc2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlID0gMDtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA+IDEwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGFkYXB0aXZlTGVhcm5pbmdSYXRlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMCwgZ290ICR7c2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlfS4gQ29ycmVjdGluZyB0byAxMC5gKTtcbiAgICAgIHNhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA9IDEwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBUkNDb25maWcoY29uZmlnKSB7XG4gIGlmICh0eXBlb2YgY29uZmlnLm1heENhY2hlU2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5tYXhDYWNoZVNpemUsIFwibWF4Q2FjaGVTaXplXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgY29uZmlnLmZyZXF1ZW5jeVRocmVzaG9sZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5mcmVxdWVuY3lUaHJlc2hvbGQsIFwiZnJlcXVlbmN5VGhyZXNob2xkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVOdW1iZXJSYW5nZShjb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IsIDAsIDEsIFwiZnJlcXVlbmN5RGVjYXlGYWN0b3JcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5mcmVxdWVuY3lEZWNheUludGVydmFsLCBcImZyZXF1ZW5jeURlY2F5SW50ZXJ2YWxcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuYWRhcHRpdmVMZWFybmluZ1JhdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZU51bWJlclJhbmdlKGNvbmZpZy5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSwgMCwgMTAsIFwiYWRhcHRpdmVMZWFybmluZ1JhdGVcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhbml0aXplVHdvUXVldWVDb25maWcoY29uZmlnKSB7XG4gIGNvbnN0IHNhbml0aXplZCA9IHsgLi4uY29uZmlnIH07XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLm1heENhY2hlU2l6ZSA9PT0gXCJudW1iZXJcIiAmJiBzYW5pdGl6ZWQubWF4Q2FjaGVTaXplIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYG1heENhY2hlU2l6ZSBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQubWF4Q2FjaGVTaXplfS4gQ29ycmVjdGluZyB0byAxMDAwLmApO1xuICAgIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPSAxZTM7XG4gIH1cbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQucHJvbW90aW9uVGhyZXNob2xkID09PSBcIm51bWJlclwiICYmIHNhbml0aXplZC5wcm9tb3Rpb25UaHJlc2hvbGQgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgcHJvbW90aW9uVGhyZXNob2xkIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5wcm9tb3Rpb25UaHJlc2hvbGR9LiBDb3JyZWN0aW5nIHRvIDIuYCk7XG4gICAgc2FuaXRpemVkLnByb21vdGlvblRocmVzaG9sZCA9IDI7XG4gIH1cbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgaG90UXVldWVEZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA9IDA7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihgaG90UXVldWVEZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDEuYCk7XG4gICAgICBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA9IDE7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA9PT0gXCJudW1iZXJcIiAmJiBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUludGVydmFsIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYGhvdFF1ZXVlRGVjYXlJbnRlcnZhbCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuaG90UXVldWVEZWNheUludGVydmFsfS4gQ29ycmVjdGluZyB0byAzMDAwMDAuYCk7XG4gICAgc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA9IDNlNTtcbiAgfVxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUd29RdWV1ZUNvbmZpZyhjb25maWcpIHtcbiAgaWYgKHR5cGVvZiBjb25maWcubWF4Q2FjaGVTaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLm1heENhY2hlU2l6ZSwgXCJtYXhDYWNoZVNpemVcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcucHJvbW90aW9uVGhyZXNob2xkID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLnByb21vdGlvblRocmVzaG9sZCwgXCJwcm9tb3Rpb25UaHJlc2hvbGRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuaG90UXVldWVEZWNheUZhY3RvciA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlTnVtYmVyUmFuZ2UoY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IsIDAsIDEsIFwiaG90UXVldWVEZWNheUZhY3RvclwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcuaG90UXVldWVEZWNheUludGVydmFsLCBcImhvdFF1ZXVlRGVjYXlJbnRlcnZhbFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmljdGlvblN0cmF0ZWd5Q29uZmlnKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlndXJhdGlvbiBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0XCIpO1xuICB9XG4gIGlmICghY29uZmlnLnR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWd1cmF0aW9uIG11c3Qgc3BlY2lmeSBhIHR5cGVcIik7XG4gIH1cbiAgY29uc3QgdmFsaWRUeXBlcyA9IFtcImxmdVwiLCBcImxydVwiLCBcImZpZm9cIiwgXCJtcnVcIiwgXCJyYW5kb21cIiwgXCJhcmNcIiwgXCIycVwiXTtcbiAgaWYgKCF2YWxpZFR5cGVzLmluY2x1ZGVzKGNvbmZpZy50eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmljdGlvbiBzdHJhdGVneSB0eXBlOiAke2NvbmZpZy50eXBlfS4gTXVzdCBiZSBvbmUgb2Y6ICR7dmFsaWRUeXBlcy5qb2luKFwiLCBcIil9YCk7XG4gIH1cbiAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgIGNhc2UgXCJsZnVcIjpcbiAgICAgIHZhbGlkYXRlTEZVQ29uZmlnKGNvbmZpZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJjXCI6XG4gICAgICB2YWxpZGF0ZUFSQ0NvbmZpZyhjb25maWcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIjJxXCI6XG4gICAgICB2YWxpZGF0ZVR3b1F1ZXVlQ29uZmlnKGNvbmZpZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibHJ1XCI6XG4gICAgY2FzZSBcImZpZm9cIjpcbiAgICBjYXNlIFwibXJ1XCI6XG4gICAgY2FzZSBcInJhbmRvbVwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZXZpY3Rpb24gc3RyYXRlZ3kgdHlwZTogJHtjb25maWcudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVDb25maWdCeVR5cGUoY29uZmlnKSB7XG4gIGlmICghY29uZmlnLnR5cGUpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICBjYXNlIFwibGZ1XCI6XG4gICAgICByZXR1cm4gc2FuaXRpemVMRlVDb25maWcoY29uZmlnKTtcbiAgICBjYXNlIFwiYXJjXCI6XG4gICAgICByZXR1cm4gc2FuaXRpemVBUkNDb25maWcoY29uZmlnKTtcbiAgICBjYXNlIFwiMnFcIjpcbiAgICAgIHJldHVybiBzYW5pdGl6ZVR3b1F1ZXVlQ29uZmlnKGNvbmZpZyk7XG4gICAgY2FzZSBcImxydVwiOlxuICAgIGNhc2UgXCJmaWZvXCI6XG4gICAgY2FzZSBcIm1ydVwiOlxuICAgIGNhc2UgXCJyYW5kb21cIjpcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRlZENvbmZpZyhiYXNlQ29uZmlnLCB1c2VyQ29uZmlnKSB7XG4gIGNvbnN0IG1lcmdlZENvbmZpZyA9IHsgLi4uYmFzZUNvbmZpZywgLi4udXNlckNvbmZpZyB9O1xuICBjb25zdCBzYW5pdGl6ZWRDb25maWcgPSBzYW5pdGl6ZUNvbmZpZ0J5VHlwZShtZXJnZWRDb25maWcpO1xuICB2YWxpZGF0ZUV2aWN0aW9uU3RyYXRlZ3lDb25maWcoc2FuaXRpemVkQ29uZmlnKTtcbiAgcmV0dXJuIHNhbml0aXplZENvbmZpZztcbn1cblxuLy8gc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvTEZVRXZpY3Rpb25TdHJhdGVneS50c1xuZnVuY3Rpb24gZm52MWFIYXNoKGtleSwgc2VlZCkge1xuICBjb25zdCBGTlZfT0ZGU0VUX0JBU0lTID0gMjE2NjEzNjI2MTtcbiAgY29uc3QgRk5WX1BSSU1FID0gMTY3Nzc2MTk7XG4gIGxldCBoYXNoID0gKEZOVl9PRkZTRVRfQkFTSVMgXiBzZWVkKSA+Pj4gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICBoYXNoIF49IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSBoYXNoICogRk5WX1BSSU1FID4+PiAwO1xuICB9XG4gIGhhc2ggXj0gaGFzaCA+Pj4gMTY7XG4gIGhhc2ggPSBoYXNoICogMjI0NjgyMjUwNyA+Pj4gMDtcbiAgaGFzaCBePSBoYXNoID4+PiAxMztcbiAgaGFzaCA9IGhhc2ggKiAzMjY2NDg5OTA5ID4+PiAwO1xuICBoYXNoIF49IGhhc2ggPj4+IDE2O1xuICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbnZhciBDb3VudE1pblNrZXRjaCA9IGNsYXNzIHtcbiAgc2tldGNoZXM7XG4gIHdpZHRoO1xuICBkZXB0aDtcbiAgc2VlZHM7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMTAyNCwgZGVwdGggPSA0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLnNrZXRjaGVzID0gQXJyYXkoZGVwdGgpLmZpbGwobnVsbCkubWFwKCgpID0+IG5ldyBBcnJheSh3aWR0aCkuZmlsbCgwKSk7XG4gICAgdGhpcy5zZWVkcyA9IEFycmF5KGRlcHRoKS5maWxsKG51bGwpLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiAyIGZvciBvcHRpbWl6ZWQgYml0IG1hc2tpbmdcbiAgICovXG4gIGlzUG93ZXJPZlR3byhuKSB7XG4gICAgcmV0dXJuIG4gPiAwICYmIChuICYgbiAtIDEpID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIGZyZXF1ZW5jeSBjb3VudCBmb3IgYSBrZXlcbiAgICovXG4gIGluY3JlbWVudChrZXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgY29uc3QgaGFzaCA9IGZudjFhSGFzaChrZXksIHRoaXMuc2VlZHNbaV0pO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlzUG93ZXJPZlR3byh0aGlzLndpZHRoKSA/IGhhc2ggJiB0aGlzLndpZHRoIC0gMSA6IGhhc2ggJSB0aGlzLndpZHRoO1xuICAgICAgdGhpcy5za2V0Y2hlc1tpXVtpbmRleF0rKztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVzdGltYXRlIHRoZSBmcmVxdWVuY3kgY291bnQgZm9yIGEga2V5XG4gICAqL1xuICBlc3RpbWF0ZShrZXkpIHtcbiAgICBsZXQgbWluQ291bnQgPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgY29uc3QgaGFzaCA9IGZudjFhSGFzaChrZXksIHRoaXMuc2VlZHNbaV0pO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlzUG93ZXJPZlR3byh0aGlzLndpZHRoKSA/IGhhc2ggJiB0aGlzLndpZHRoIC0gMSA6IGhhc2ggJSB0aGlzLndpZHRoO1xuICAgICAgbWluQ291bnQgPSBNYXRoLm1pbihtaW5Db3VudCwgdGhpcy5za2V0Y2hlc1tpXVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gbWluQ291bnQgPT09IEluZmluaXR5ID8gMCA6IG1pbkNvdW50O1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSBkZWNheSB0byBhbGwgZnJlcXVlbmNpZXNcbiAgICovXG4gIGRlY2F5KGZhY3Rvcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXB0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMud2lkdGg7IGorKykge1xuICAgICAgICB0aGlzLnNrZXRjaGVzW2ldW2pdID0gTWF0aC5mbG9vcih0aGlzLnNrZXRjaGVzW2ldW2pdICogKDEgLSBmYWN0b3IpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBmcmVxdWVuY2llcyB0byB6ZXJvXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLndpZHRoOyBqKyspIHtcbiAgICAgICAgdGhpcy5za2V0Y2hlc1tpXVtqXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIExGVUV2aWN0aW9uU3RyYXRlZ3kgPSBjbGFzcyBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBnZXRTdHJhdGVneU5hbWUoKSB7XG4gICAgcmV0dXJuIFwibGZ1XCI7XG4gIH1cbiAgY29uZmlnO1xuICBza2V0Y2g7XG4gIGxhc3REZWNheVRpbWU7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBkZWZhdWx0QmFja3dhcmRzQ29tcGF0aWJsZSA9IHtcbiAgICAgIHVzZVByb2JhYmlsaXN0aWNDb3VudGluZzogZmFsc2UsXG4gICAgICBkZWNheUZhY3RvcjogMCxcbiAgICAgIGRlY2F5SW50ZXJ2YWw6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0geyAuLi5ERUZBVUxUX0xGVV9DT05GSUcsIC4uLmRlZmF1bHRCYWNrd2FyZHNDb21wYXRpYmxlIH07XG4gICAgdGhpcy5jb25maWcgPSBjcmVhdGVWYWxpZGF0ZWRDb25maWcoYmFzZUNvbmZpZywgY29uZmlnKTtcbiAgICB0aGlzLnNrZXRjaCA9IHRoaXMuY29uZmlnLnVzZVByb2JhYmlsaXN0aWNDb3VudGluZyA/IG5ldyBDb3VudE1pblNrZXRjaCh0aGlzLmNvbmZpZy5za2V0Y2hXaWR0aCwgdGhpcy5jb25maWcuc2tldGNoRGVwdGgpIDogbnVsbDtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIHNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpIHtcbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgaWYgKGV2aWN0aW9uQ291bnQgPD0gMCkgcmV0dXJuIFtdO1xuICAgIHRoaXMuYXBwbHlQZXJpb2RpY0RlY2F5KCk7XG4gICAgY29uc3Qgc29ydGVkRW50cmllcyA9IEFycmF5LmZyb20oYWxsTWV0YWRhdGEuZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBmcmVxQSA9IHRoaXMuZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KGFbMF0sIGFbMV0pO1xuICAgICAgY29uc3QgZnJlcUIgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShiWzBdLCBiWzFdKTtcbiAgICAgIGlmIChmcmVxQSAhPT0gZnJlcUIpIHtcbiAgICAgICAgcmV0dXJuIGZyZXFBIC0gZnJlcUI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYVsxXS5sYXN0QWNjZXNzZWRBdCAtIGJbMV0ubGFzdEFjY2Vzc2VkQXQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvcnRlZEVudHJpZXMuc2xpY2UoMCwgZXZpY3Rpb25Db3VudCkubWFwKChba2V5XSkgPT4ga2V5KTtcbiAgfVxuICBvbkl0ZW1BY2Nlc3NlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhKSByZXR1cm47XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IG5vdztcbiAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgdGhpcy5za2V0Y2guaW5jcmVtZW50KGtleSk7XG4gICAgICBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgPSB0aGlzLnNrZXRjaC5lc3RpbWF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgPSBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgICB9XG4gICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUZyZXF1ZW5jeVNjb3JlKG1ldGFkYXRhLCBub3cpO1xuICAgIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPSBub3c7XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1BZGRlZChrZXksIGVzdGltYXRlZFNpemUsIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZSxcbiAgICAgIHJhd0ZyZXF1ZW5jeTogMVxuICAgIH07XG4gICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSAxO1xuICAgIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPSBub3c7XG4gICAgaWYgKHRoaXMuc2tldGNoKSB7XG4gICAgICB0aGlzLnNrZXRjaC5pbmNyZW1lbnQoa2V5KTtcbiAgICB9XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBlZmZlY3RpdmUgZnJlcXVlbmN5IGZvciBhbiBpdGVtLCBhcHBseWluZyByZWFsLXRpbWUgZGVjYXkgaWYgbmVlZGVkXG4gICAqL1xuICBnZXRFZmZlY3RpdmVGcmVxdWVuY3koX2tleSwgbWV0YWRhdGEpIHtcbiAgICBpZiAoKHRoaXMuY29uZmlnLmRlY2F5RmFjdG9yID8/IDApID09PSAwKSB7XG4gICAgICByZXR1cm4gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IG5vdyAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgICBjb25zdCBkZWNheUFtb3VudCA9IHRpbWVTaW5jZVVwZGF0ZSAvICh0aGlzLmNvbmZpZy5kZWNheUludGVydmFsID8/IDZlNCkgKiAodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMC4xKTtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmNvbmZpZy5taW5GcmVxdWVuY3lUaHJlc2hvbGQgPz8gMSwgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSBhcHBsaWVkXG4gICAqL1xuICBjYWxjdWxhdGVGcmVxdWVuY3lTY29yZShtZXRhZGF0YSwgY3VycmVudFRpbWUpIHtcbiAgICBjb25zdCByYXdGcmVxID0gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIGlmICgodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cbiAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBjdXJyZW50VGltZSAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgY29uc3QgZGVjYXlBbW91bnQgPSB0aW1lU2luY2VVcGRhdGUgLyAodGhpcy5jb25maWcuZGVjYXlJbnRlcnZhbCA/PyA2ZTQpICogKHRoaXMuY29uZmlnLmRlY2F5RmFjdG9yID8/IDAuMSk7XG4gICAgY29uc3QgcHJldmlvdXNTY29yZSA9IG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlIHx8IHJhd0ZyZXE7XG4gICAgY29uc3QgZGVjYXllZFNjb3JlID0gcHJldmlvdXNTY29yZSAqICgxIC0gZGVjYXlBbW91bnQpO1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmNvbmZpZy5taW5GcmVxdWVuY3lUaHJlc2hvbGQgPz8gMSwgZGVjYXllZFNjb3JlICsgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IHBlcmlvZGljIGRlY2F5IHRvIHRoZSBmcmVxdWVuY3kgc2tldGNoIGFuZCBtZXRhZGF0YVxuICAgKi9cbiAgYXBwbHlQZXJpb2RpY0RlY2F5KCkge1xuICAgIGlmICgodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHJldHVybjtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVTaW5jZURlY2F5ID0gbm93IC0gdGhpcy5sYXN0RGVjYXlUaW1lO1xuICAgIGlmICh0aW1lU2luY2VEZWNheSA+PSAodGhpcy5jb25maWcuZGVjYXlJbnRlcnZhbCA/PyA2ZTQpKSB7XG4gICAgICBpZiAodGhpcy5za2V0Y2gpIHtcbiAgICAgICAgdGhpcy5za2V0Y2guZGVjYXkodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMC4xKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdERlY2F5VGltZSA9IG5vdztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHN0cmF0ZWd5XG4gICAqL1xuICBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgZnJlcXVlbmN5IHRyYWNraW5nICh1c2VmdWwgZm9yIHRlc3Rpbmcgb3IgY2FjaGUgY2xlYXJpbmcpXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5za2V0Y2gpIHtcbiAgICAgIHRoaXMuc2tldGNoLnJlc2V0KCk7XG4gICAgfVxuICAgIHRoaXMubGFzdERlY2F5VGltZSA9IERhdGUubm93KCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmljdGlvbi9zdHJhdGVnaWVzL0ZJRk9FdmljdGlvblN0cmF0ZWd5LnRzXG52YXIgRklGT0V2aWN0aW9uU3RyYXRlZ3kgPSBjbGFzcyBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBzZWxlY3RGb3JFdmljdGlvbihtZXRhZGF0YVByb3ZpZGVyLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgaWYgKGFsbE1ldGFkYXRhLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBjb25zdCBrZXlzVG9FdmljdCA9IFtdO1xuICAgIGNvbnN0IHNvcnRlZEVudHJpZXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmVudHJpZXMoKSkuc29ydCgoWywgYV0sIFssIGJdKSA9PiBhLmFkZGVkQXQgLSBiLmFkZGVkQXQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oZXZpY3Rpb25Db3VudCwgc29ydGVkRW50cmllcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGtleXNUb0V2aWN0LnB1c2goc29ydGVkRW50cmllc1tpXVswXSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuICBvbkl0ZW1BY2Nlc3NlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuICBvbkl0ZW1BZGRlZChrZXksIGVzdGltYXRlZFNpemUsIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZVxuICAgIH07XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuICBnZXRTdHJhdGVneU5hbWUoKSB7XG4gICAgcmV0dXJuIFwiZmlmb1wiO1xuICB9XG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9NUlVFdmljdGlvblN0cmF0ZWd5LnRzXG52YXIgTVJVRXZpY3Rpb25TdHJhdGVneSA9IGNsYXNzIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGdldFN0cmF0ZWd5TmFtZSgpIHtcbiAgICByZXR1cm4gXCJNUlVcIjtcbiAgfVxuICBzZWxlY3RGb3JFdmljdGlvbihtZXRhZGF0YVByb3ZpZGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgaWYgKGFsbE1ldGFkYXRhLnNpemUgPT09IDApIHJldHVybiBbXTtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGlmIChldmljdGlvbkNvdW50IDw9IDApIHJldHVybiBbXTtcbiAgICBjb25zdCBzb3J0ZWRFbnRyaWVzID0gQXJyYXkuZnJvbShhbGxNZXRhZGF0YS5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBiWzFdLmxhc3RBY2Nlc3NlZEF0IC0gYVsxXS5sYXN0QWNjZXNzZWRBdDtcbiAgICB9KTtcbiAgICByZXR1cm4gc29ydGVkRW50cmllcy5zbGljZSgwLCBldmljdGlvbkNvdW50KS5tYXAoKFtrZXldKSA9PiBrZXkpO1xuICB9XG4gIG9uSXRlbUFjY2Vzc2VkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHJldHVybjtcbiAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbUFkZGVkKGtleSwgZXN0aW1hdGVkU2l6ZSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICBrZXksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplXG4gICAgfTtcbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbVJlbW92ZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9SYW5kb21FdmljdGlvblN0cmF0ZWd5LnRzXG52YXIgUmFuZG9tRXZpY3Rpb25TdHJhdGVneSA9IGNsYXNzIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIHNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmtleXMoKSk7XG4gICAgY29uc3Qga2V5c1RvRXZpY3QgPSBbXTtcbiAgICBjb25zdCBhdmFpbGFibGVLZXlzID0gWy4uLmtleXNdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oZXZpY3Rpb25Db3VudCwgYXZhaWxhYmxlS2V5cy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXZhaWxhYmxlS2V5cy5sZW5ndGgpO1xuICAgICAga2V5c1RvRXZpY3QucHVzaChhdmFpbGFibGVLZXlzLnNwbGljZShyYW5kb21JbmRleCwgMSlbMF0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5c1RvRXZpY3Q7XG4gIH1cbiAgb25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gIH1cbiAgb25JdGVtQWRkZWQoa2V5LCBlc3RpbWF0ZWRTaXplLCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemVcbiAgICB9O1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cbiAgb25JdGVtUmVtb3ZlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cbiAgZ2V0U3RyYXRlZ3lOYW1lKCkge1xuICAgIHJldHVybiBcInJhbmRvbVwiO1xuICB9XG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9BUkNFdmljdGlvblN0cmF0ZWd5LnRzXG52YXIgQVJDRXZpY3Rpb25TdHJhdGVneSA9IGNsYXNzIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGdldFN0cmF0ZWd5TmFtZSgpIHtcbiAgICByZXR1cm4gXCJBUkNcIjtcbiAgfVxuICByZWNlbnRHaG9zdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAvLyBUMSBnaG9zdCBlbnRyaWVzXG4gIGZyZXF1ZW50R2hvc3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgLy8gVDIgZ2hvc3QgZW50cmllc1xuICB0YXJnZXRSZWNlbnRTaXplID0gMDtcbiAgLy8gVGFyZ2V0IHNpemUgZm9yIFQxIChyZWNlbnQgZW50cmllcylcbiAgY29uZmlnO1xuICBtYXhHaG9zdFNpemU7XG4gIGxhc3REZWNheVRpbWU7XG4gIGNvbnN0cnVjdG9yKG1heENhY2hlU2l6ZSA9IDFlMywgY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSB7IC4uLkRFRkFVTFRfQVJDX0NPTkZJRywgbWF4Q2FjaGVTaXplIH07XG4gICAgdGhpcy5jb25maWcgPSBjcmVhdGVWYWxpZGF0ZWRDb25maWcoYmFzZUNvbmZpZywgY29uZmlnKTtcbiAgICB0aGlzLm1heEdob3N0U2l6ZSA9IHRoaXMuY29uZmlnLm1heENhY2hlU2l6ZTtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIHNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpIHtcbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgaWYgKGV2aWN0aW9uQ291bnQgPD0gMCkgcmV0dXJuIFtdO1xuICAgIHRoaXMuYXBwbHlQZXJpb2RpY0RlY2F5KGFsbE1ldGFkYXRhKTtcbiAgICBjb25zdCByZWNlbnRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgZnJlcXVlbnRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCBtZXRhZGF0YV0gb2YgYWxsTWV0YWRhdGEpIHtcbiAgICAgIGlmICh0aGlzLmlzRnJlcXVlbnRJdGVtKG1ldGFkYXRhKSkge1xuICAgICAgICBmcmVxdWVudEl0ZW1zLnNldChrZXksIG1ldGFkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2VudEl0ZW1zLnNldChrZXksIG1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2V5c1RvRXZpY3QgPSBbXTtcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gcmVjZW50SXRlbXMuc2l6ZSArIGZyZXF1ZW50SXRlbXMuc2l6ZTtcbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gTWF0aC5taW4oZXZpY3Rpb25Db3VudCwgdG90YWxJdGVtcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgIGxldCBrZXlUb0V2aWN0ID0gbnVsbDtcbiAgICAgIGxldCBzb3VyY2VMaXN0ID0gbnVsbDtcbiAgICAgIGlmIChyZWNlbnRJdGVtcy5zaXplID4gdGhpcy50YXJnZXRSZWNlbnRTaXplICYmIHJlY2VudEl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgIGtleVRvRXZpY3QgPSB0aGlzLmNvbmZpZy51c2VGcmVxdWVuY3lXZWlnaHRlZFNlbGVjdGlvbiA/IHRoaXMuc2VsZWN0RnJlcXVlbmN5V2VpZ2h0ZWRGcm9tSXRlbXMocmVjZW50SXRlbXMsIFwicmVjZW50XCIpIDogdGhpcy5zZWxlY3RMUlVGcm9tSXRlbXMocmVjZW50SXRlbXMpO1xuICAgICAgICBzb3VyY2VMaXN0ID0gcmVjZW50SXRlbXM7XG4gICAgICB9IGVsc2UgaWYgKGZyZXF1ZW50SXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAga2V5VG9FdmljdCA9IHRoaXMuY29uZmlnLnVzZUZyZXF1ZW5jeVdlaWdodGVkU2VsZWN0aW9uID8gdGhpcy5zZWxlY3RGcmVxdWVuY3lXZWlnaHRlZEZyb21JdGVtcyhmcmVxdWVudEl0ZW1zLCBcImZyZXF1ZW50XCIpIDogdGhpcy5zZWxlY3RMUlVGcm9tSXRlbXMoZnJlcXVlbnRJdGVtcyk7XG4gICAgICAgIHNvdXJjZUxpc3QgPSBmcmVxdWVudEl0ZW1zO1xuICAgICAgfSBlbHNlIGlmIChyZWNlbnRJdGVtcy5zaXplID4gMCkge1xuICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5jb25maWcudXNlRnJlcXVlbmN5V2VpZ2h0ZWRTZWxlY3Rpb24gPyB0aGlzLnNlbGVjdEZyZXF1ZW5jeVdlaWdodGVkRnJvbUl0ZW1zKHJlY2VudEl0ZW1zLCBcInJlY2VudFwiKSA6IHRoaXMuc2VsZWN0TFJVRnJvbUl0ZW1zKHJlY2VudEl0ZW1zKTtcbiAgICAgICAgc291cmNlTGlzdCA9IHJlY2VudEl0ZW1zO1xuICAgICAgfVxuICAgICAgaWYgKGtleVRvRXZpY3QgJiYgc291cmNlTGlzdCkge1xuICAgICAgICBrZXlzVG9FdmljdC5wdXNoKGtleVRvRXZpY3QpO1xuICAgICAgICBzb3VyY2VMaXN0LmRlbGV0ZShrZXlUb0V2aWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHJlY2VudEl0ZW1zLnNpemUgPT09IDAgJiYgZnJlcXVlbnRJdGVtcy5zaXplID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5c1RvRXZpY3Q7XG4gIH1cbiAgc2VsZWN0TFJVRnJvbUl0ZW1zKGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgb2xkZXN0S2V5ID0gbnVsbDtcbiAgICBsZXQgb2xkZXN0VGltZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChjb25zdCBba2V5LCBtZXRhZGF0YV0gb2YgaXRlbXMpIHtcbiAgICAgIGlmICghbWV0YWRhdGEgfHwgdHlwZW9mIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ICE9PSBcIm51bWJlclwiIHx8IG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID4gbm93KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0IDwgb2xkZXN0VGltZSkge1xuICAgICAgICBvbGRlc3RUaW1lID0gbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQ7XG4gICAgICAgIG9sZGVzdEtleSA9IGtleTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZGVzdEtleSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9sZGVzdEtleTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdEtleSA9IGl0ZW1zLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gZmlyc3RLZXkgPz8gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgb25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdXBkYXRlZE1ldGFkYXRhID0ge1xuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IG1ldGFkYXRhLmFjY2Vzc0NvdW50ICsgMVxuICAgIH07XG4gICAgdXBkYXRlZE1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSA9IHVwZGF0ZWRNZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgICBpZiAodGhpcy5jb25maWcudXNlRW5oYW5jZWRGcmVxdWVuY3kgJiYgKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDApID4gMCkge1xuICAgICAgdXBkYXRlZE1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gdGhpcy5jYWxjdWxhdGVGcmVxdWVuY3lTY29yZSh1cGRhdGVkTWV0YWRhdGEsIG5vdyk7XG4gICAgICB1cGRhdGVkTWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgbGVhcm5pbmdSYXRlID0gdGhpcy5jb25maWcuYWRhcHRpdmVMZWFybmluZ1JhdGUgPz8gMTtcbiAgICBsZXQgdGFyZ2V0QWRqdXN0ZWQgPSBmYWxzZTtcbiAgICBpZiAobGVhcm5pbmdSYXRlID4gMCkge1xuICAgICAgaWYgKHRoaXMucmVjZW50R2hvc3RzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwobGVhcm5pbmdSYXRlKSk7XG4gICAgICAgIHRoaXMudGFyZ2V0UmVjZW50U2l6ZSA9IE1hdGgubWluKHRoaXMudGFyZ2V0UmVjZW50U2l6ZSArIGFkanVzdG1lbnQsIHRoaXMubWF4R2hvc3RTaXplKTtcbiAgICAgICAgdGhpcy5yZWNlbnRHaG9zdHMuZGVsZXRlKGtleSk7XG4gICAgICAgIHRhcmdldEFkanVzdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmVxdWVudEdob3N0cy5oYXMoa2V5KSkge1xuICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICB0aGlzLnRhcmdldFJlY2VudFNpemUgPSBNYXRoLm1heCh0aGlzLnRhcmdldFJlY2VudFNpemUgLSBhZGp1c3RtZW50LCAwKTtcbiAgICAgICAgdGhpcy5mcmVxdWVudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICAgICAgdGFyZ2V0QWRqdXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5yZWNlbnRHaG9zdHMuaGFzKGtleSkpIHtcbiAgICAgICAgdGhpcy5yZWNlbnRHaG9zdHMuZGVsZXRlKGtleSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZnJlcXVlbnRHaG9zdHMuaGFzKGtleSkpIHtcbiAgICAgICAgdGhpcy5mcmVxdWVudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldEFkanVzdGVkKSB7XG4gICAgICB0aGlzLmNsZWFudXBHaG9zdExpc3RzKCk7XG4gICAgfVxuICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCB1cGRhdGVkTWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbUFkZGVkKGtleSwgZXN0aW1hdGVkU2l6ZSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICBrZXksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplLFxuICAgICAgcmF3RnJlcXVlbmN5OiAxXG4gICAgfTtcbiAgICBpZiAodGhpcy5jb25maWcudXNlRW5oYW5jZWRGcmVxdWVuY3kgJiYgKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDApID4gMCkge1xuICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSAxO1xuICAgICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICB9XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmIChtZXRhZGF0YSAmJiB0aGlzLmlzRnJlcXVlbnRJdGVtKG1ldGFkYXRhKSkge1xuICAgICAgdGhpcy5hZGRUb0ZyZXF1ZW50R2hvc3RzKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVG9SZWNlbnRHaG9zdHMoa2V5KTtcbiAgICB9XG4gICAgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICAgIHRoaXMuY2xlYW51cEdob3N0TGlzdHMoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGtleSB0byByZWNlbnQgZ2hvc3QgbGlzdCB3aXRoIHByb3BlciBzaXplIG1hbmFnZW1lbnRcbiAgICovXG4gIGFkZFRvUmVjZW50R2hvc3RzKGtleSkge1xuICAgIHRoaXMuZnJlcXVlbnRHaG9zdHMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5yZWNlbnRHaG9zdHMuYWRkKGtleSk7XG4gICAgdGhpcy5lbmZvcmNlR2hvc3RMaXN0U2l6ZUxpbWl0KHRoaXMucmVjZW50R2hvc3RzLCB0aGlzLm1heEdob3N0U2l6ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBrZXkgdG8gZnJlcXVlbnQgZ2hvc3QgbGlzdCB3aXRoIHByb3BlciBzaXplIG1hbmFnZW1lbnRcbiAgICovXG4gIGFkZFRvRnJlcXVlbnRHaG9zdHMoa2V5KSB7XG4gICAgdGhpcy5yZWNlbnRHaG9zdHMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5mcmVxdWVudEdob3N0cy5hZGQoa2V5KTtcbiAgICB0aGlzLmVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQodGhpcy5mcmVxdWVudEdob3N0cywgdGhpcy5tYXhHaG9zdFNpemUpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbnVwIGdob3N0IGxpc3RzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAqL1xuICBjbGVhbnVwR2hvc3RMaXN0cygpIHtcbiAgICB0aGlzLmVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQodGhpcy5yZWNlbnRHaG9zdHMsIHRoaXMubWF4R2hvc3RTaXplKTtcbiAgICB0aGlzLmVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQodGhpcy5mcmVxdWVudEdob3N0cywgdGhpcy5tYXhHaG9zdFNpemUpO1xuICB9XG4gIC8qKlxuICAgKiBFbmZvcmNlIHNpemUgbGltaXQgb24gYSBnaG9zdCBsaXN0IGJ5IHJlbW92aW5nIG9sZGVzdCBlbnRyaWVzXG4gICAqL1xuICBlbmZvcmNlR2hvc3RMaXN0U2l6ZUxpbWl0KGdob3N0TGlzdCwgbWF4U2l6ZSkge1xuICAgIGlmIChtYXhTaXplIDw9IDApIHtcbiAgICAgIGdob3N0TGlzdC5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVyYXRvciA9IGdob3N0TGlzdC52YWx1ZXMoKTtcbiAgICB3aGlsZSAoZ2hvc3RMaXN0LnNpemUgPiBtYXhTaXplKSB7XG4gICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGdob3N0TGlzdC5kZWxldGUobmV4dC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYW4gaXRlbSBzaG91bGQgYmUgY2xhc3NpZmllZCBhcyBmcmVxdWVudCB2cyByZWNlbnRcbiAgICovXG4gIGlzRnJlcXVlbnRJdGVtKG1ldGFkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSkge1xuICAgICAgcmV0dXJuIG1ldGFkYXRhLmFjY2Vzc0NvdW50ID4gMTtcbiAgICB9XG4gICAgY29uc3QgZnJlcXVlbmN5ID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGEpO1xuICAgIHJldHVybiBmcmVxdWVuY3kgPj0gKHRoaXMuY29uZmlnLmZyZXF1ZW5jeVRocmVzaG9sZCA/PyAyKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGVmZmVjdGl2ZSBmcmVxdWVuY3kgZm9yIGFuIGl0ZW0sIGFwcGx5aW5nIGRlY2F5IGlmIGVuYWJsZWRcbiAgICovXG4gIGdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YSkge1xuICAgIGlmICghdGhpcy5jb25maWcudXNlRW5oYW5jZWRGcmVxdWVuY3kgfHwgKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDApID09PSAwKSB7XG4gICAgICByZXR1cm4gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IG5vdyAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgICBjb25zdCBkZWNheUludGVydmFsID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA/PyA2ZTU7XG4gICAgICBpZiAodGltZVNpbmNlVXBkYXRlID4gZGVjYXlJbnRlcnZhbCAvIDEwKSB7XG4gICAgICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gTWF0aC5taW4oMC45LCB0aW1lU2luY2VVcGRhdGUgLyBkZWNheUludGVydmFsICogKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDAuMDUpKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZnJlcXVlbmN5IHNjb3JlIHdpdGggZGVjYXkgYXBwbGllZFxuICAgKi9cbiAgY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGEsIGN1cnJlbnRUaW1lKSB7XG4gICAgY29uc3QgcmF3RnJlcSA9IG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cbiAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBjdXJyZW50VGltZSAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgY29uc3QgZGVjYXlJbnRlcnZhbCA9IHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgPz8gNmU1O1xuICAgIGNvbnN0IGRlY2F5RmFjdG9yID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMC4wNTtcbiAgICBjb25zdCBkZWNheUFtb3VudCA9IE1hdGgubWluKDAuOSwgdGltZVNpbmNlVXBkYXRlIC8gZGVjYXlJbnRlcnZhbCAqIGRlY2F5RmFjdG9yKTtcbiAgICBjb25zdCBwcmV2aW91c1Njb3JlID0gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgfHwgcmF3RnJlcTtcbiAgICBjb25zdCBkZWNheWVkU2NvcmUgPSBNYXRoLm1heCgxLCBwcmV2aW91c1Njb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgIHJldHVybiBNYXRoLm1heCgxLCBkZWNheWVkU2NvcmUgKyAxKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IGV2aWN0aW9uIGNhbmRpZGF0ZSB1c2luZyBmcmVxdWVuY3ktd2VpZ2h0ZWQgYXBwcm9hY2hcbiAgICovXG4gIHNlbGVjdEZyZXF1ZW5jeVdlaWdodGVkRnJvbUl0ZW1zKGl0ZW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKGl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgYmVzdEtleSA9IG51bGw7XG4gICAgbGV0IGJlc3RTY29yZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChjb25zdCBba2V5LCBtZXRhZGF0YV0gb2YgaXRlbXMpIHtcbiAgICAgIGlmICghbWV0YWRhdGEgfHwgdHlwZW9mIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ICE9PSBcIm51bWJlclwiIHx8IG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID4gbm93KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJlcXVlbmN5ID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGEpO1xuICAgICAgY29uc3QgdGltZUZhY3RvciA9IE1hdGgubWF4KDAsIG5vdyAtIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0KTtcbiAgICAgIGxldCBzY29yZTtcbiAgICAgIGlmIChjb250ZXh0ID09PSBcInJlY2VudFwiKSB7XG4gICAgICAgIHNjb3JlID0gdGltZUZhY3RvciArIDFlMyAvIE1hdGgubWF4KDEsIGZyZXF1ZW5jeSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IFwiZnJlcXVlbnRcIikge1xuICAgICAgICBzY29yZSA9IHRpbWVGYWN0b3IgLyAxZTMgKyAxMCAvIE1hdGgubWF4KDEsIGZyZXF1ZW5jeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29yZSA9IHRpbWVGYWN0b3IgLyAxZTMgLyBNYXRoLm1heCgxLCBmcmVxdWVuY3kpO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG4gICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICBiZXN0S2V5ID0ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdEtleSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJlc3RLZXk7XG4gICAgfVxuICAgIGlmIChpdGVtcy5zaXplID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RLZXkgPSBpdGVtcy5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIGZpcnN0S2V5ID8/IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSBwZXJpb2RpYyBkZWNheSB0byBmcmVxdWVuY3kgc2NvcmVzXG4gICAqL1xuICBhcHBseVBlcmlvZGljRGVjYXkoaXRlbXMpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnVzZUVuaGFuY2VkRnJlcXVlbmN5IHx8ICh0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciA/PyAwKSA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZVNpbmNlRGVjYXkgPSBub3cgLSB0aGlzLmxhc3REZWNheVRpbWU7XG4gICAgY29uc3QgZGVjYXlJbnRlcnZhbCA9IHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgPz8gNmU1O1xuICAgIGlmICh0aW1lU2luY2VEZWNheSA+PSBkZWNheUludGVydmFsICYmIGl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBkZWNheUZhY3RvciA9IHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDAuMDU7XG4gICAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIGl0ZW1zLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb25zdCBpbnRlcnZhbHNQYXNzZWQgPSB0aW1lU2luY2VEZWNheSAvIGRlY2F5SW50ZXJ2YWw7XG4gICAgICAgICAgY29uc3QgdG90YWxEZWNheSA9IE1hdGgubWluKDAuOSwgZGVjYXlGYWN0b3IgKiBpbnRlcnZhbHNQYXNzZWQpO1xuICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIHRvdGFsRGVjYXkpO1xuICAgICAgICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gTWF0aC5tYXgoMSwgbmV3U2NvcmUpO1xuICAgICAgICAgIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPSBub3c7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdERlY2F5VGltZSA9IG5vdztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHN0cmF0ZWd5XG4gICAqL1xuICBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgaW50ZXJuYWwgc3RhdGUgKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmVjZW50R2hvc3RzLmNsZWFyKCk7XG4gICAgdGhpcy5mcmVxdWVudEdob3N0cy5jbGVhcigpO1xuICAgIHRoaXMudGFyZ2V0UmVjZW50U2l6ZSA9IDA7XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgYWRhcHRpdmUgc3RhdGUgZm9yIG1vbml0b3JpbmcvZGVidWdnaW5nXG4gICAqL1xuICBnZXRBZGFwdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXRSZWNlbnRTaXplOiB0aGlzLnRhcmdldFJlY2VudFNpemUsXG4gICAgICByZWNlbnRHaG9zdFNpemU6IHRoaXMucmVjZW50R2hvc3RzLnNpemUsXG4gICAgICBmcmVxdWVudEdob3N0U2l6ZTogdGhpcy5mcmVxdWVudEdob3N0cy5zaXplXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvVHdvUXVldWVFdmljdGlvblN0cmF0ZWd5LnRzXG52YXIgVHdvUXVldWVFdmljdGlvblN0cmF0ZWd5ID0gY2xhc3MgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgZ2V0U3RyYXRlZ3lOYW1lKCkge1xuICAgIHJldHVybiBcIjJRXCI7XG4gIH1cbiAgcmVjZW50UXVldWUgPSBbXTtcbiAgLy8gQTEgcXVldWUgZm9yIHJlY2VudCBpdGVtc1xuICBob3RRdWV1ZSA9IFtdO1xuICAvLyBBbSBxdWV1ZSBmb3IgaG90IGl0ZW1zXG4gIGdob3N0UXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAvLyBBMW91dCBnaG9zdCBxdWV1ZVxuICBjb25maWc7XG4gIG1heFJlY2VudFNpemU7XG4gIG1heEdob3N0U2l6ZTtcbiAgbGFzdERlY2F5VGltZTtcbiAgY29uc3RydWN0b3IobWF4Q2FjaGVTaXplID0gMWUzLCBjb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHsgLi4uREVGQVVMVF9UV09fUVVFVUVfQ09ORklHLCBtYXhDYWNoZVNpemUgfTtcbiAgICB0aGlzLmNvbmZpZyA9IGNyZWF0ZVZhbGlkYXRlZENvbmZpZyhiYXNlQ29uZmlnLCBjb25maWcpO1xuICAgIHRoaXMubWF4UmVjZW50U2l6ZSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGhpcy5jb25maWcubWF4Q2FjaGVTaXplICogMC4yNSkpO1xuICAgIHRoaXMubWF4R2hvc3RTaXplID0gdGhpcy5jb25maWcubWF4Q2FjaGVTaXplO1xuICAgIHRoaXMubGFzdERlY2F5VGltZSA9IERhdGUubm93KCk7XG4gIH1cbiAgc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSByZXR1cm4gW107XG4gICAgaWYgKCF0aGlzLmlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBpZiAoZXZpY3Rpb25Db3VudCA8PSAwKSByZXR1cm4gW107XG4gICAgdGhpcy5hcHBseVBlcmlvZGljRGVjYXkoYWxsTWV0YWRhdGEpO1xuICAgIGNvbnN0IGtleXNUb0V2aWN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmljdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGxldCBrZXlUb0V2aWN0ID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGogPSB0aGlzLnJlY2VudFF1ZXVlLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMucmVjZW50UXVldWVbal07XG4gICAgICAgIGlmIChhbGxNZXRhZGF0YS5oYXMoa2V5KSAmJiAha2V5c1RvRXZpY3QuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGtleVRvRXZpY3QgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgha2V5VG9FdmljdCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcudXNlRnJlcXVlbmN5V2VpZ2h0ZWRMUlUpIHtcbiAgICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5zZWxlY3RGcm9tSG90UXVldWVGcmVxdWVuY3lXZWlnaHRlZChhbGxNZXRhZGF0YSwga2V5c1RvRXZpY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleVRvRXZpY3QgPSB0aGlzLnNlbGVjdEZyb21Ib3RRdWV1ZUxSVShhbGxNZXRhZGF0YSwga2V5c1RvRXZpY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5VG9FdmljdCkge1xuICAgICAgICBrZXlzVG9FdmljdC5wdXNoKGtleVRvRXZpY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IGV2aWN0aW9uIGNhbmRpZGF0ZSBmcm9tIGhvdCBxdWV1ZSB1c2luZyB0cmFkaXRpb25hbCBMUlVcbiAgICovXG4gIHNlbGVjdEZyb21Ib3RRdWV1ZUxSVShpdGVtcywgZXhjbHVkZUtleXMgPSBbXSkge1xuICAgIGxldCBvbGRlc3RLZXkgPSBudWxsO1xuICAgIGxldCBvbGRlc3RUaW1lID0gSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5ob3RRdWV1ZSkge1xuICAgICAgaWYgKGV4Y2x1ZGVLZXlzLmluY2x1ZGVzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBpdGVtcy5nZXQoa2V5KTtcbiAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA8IG9sZGVzdFRpbWUpIHtcbiAgICAgICAgb2xkZXN0VGltZSA9IG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0O1xuICAgICAgICBvbGRlc3RLZXkgPSBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbGRlc3RLZXkgfHwgKGl0ZW1zLnNpemUgPiAwID8gaXRlbXMua2V5cygpLm5leHQoKS52YWx1ZSA/PyBudWxsIDogbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBldmljdGlvbiBjYW5kaWRhdGUgZnJvbSBob3QgcXVldWUgdXNpbmcgZnJlcXVlbmN5LXdlaWdodGVkIExSVVxuICAgKi9cbiAgc2VsZWN0RnJvbUhvdFF1ZXVlRnJlcXVlbmN5V2VpZ2h0ZWQoaXRlbXMsIGV4Y2x1ZGVLZXlzID0gW10pIHtcbiAgICBsZXQgYmVzdEtleSA9IG51bGw7XG4gICAgbGV0IGxvd2VzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5ob3RRdWV1ZSkge1xuICAgICAgaWYgKGV4Y2x1ZGVLZXlzLmluY2x1ZGVzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBpdGVtcy5nZXQoa2V5KTtcbiAgICAgIGlmICghbWV0YWRhdGEpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZnJlcXVlbmN5ID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGEpO1xuICAgICAgY29uc3QgdGltZUZhY3RvciA9IERhdGUubm93KCkgLSBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdDtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lRmFjdG9yID0gdGltZUZhY3RvciAvICgxZTMgKiA2MCk7XG4gICAgICBjb25zdCBzY29yZSA9IG5vcm1hbGl6ZWRUaW1lRmFjdG9yIC8gTWF0aC5tYXgoMSwgZnJlcXVlbmN5KTtcbiAgICAgIGlmIChzY29yZSA8IGxvd2VzdFNjb3JlKSB7XG4gICAgICAgIGxvd2VzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgIGJlc3RLZXkgPSBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0S2V5IHx8IChpdGVtcy5zaXplID4gMCA/IGl0ZW1zLmtleXMoKS5uZXh0KCkudmFsdWUgPz8gbnVsbCA6IG51bGwpO1xuICB9XG4gIG9uSXRlbUFjY2Vzc2VkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHJldHVybjtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gbm93O1xuICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgbWV0YWRhdGEucmF3RnJlcXVlbmN5ID0gbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDApID4gMCkge1xuICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUZyZXF1ZW5jeVNjb3JlKG1ldGFkYXRhLCBub3cpO1xuICAgICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgcmVjZW50SW5kZXggPSB0aGlzLnJlY2VudFF1ZXVlLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAocmVjZW50SW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRQcm9tb3RlVG9Ib3RRdWV1ZShtZXRhZGF0YSkpIHtcbiAgICAgICAgdGhpcy5yZWNlbnRRdWV1ZS5zcGxpY2UocmVjZW50SW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmhvdFF1ZXVlLnVuc2hpZnQoa2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaG90SW5kZXggPSB0aGlzLmhvdFF1ZXVlLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChob3RJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5ob3RRdWV1ZS5zcGxpY2UoaG90SW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmhvdFF1ZXVlLnVuc2hpZnQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1BZGRlZChrZXksIGVzdGltYXRlZFNpemUsIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGxldCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICBtZXRhZGF0YSA9IHtcbiAgICAgICAga2V5LFxuICAgICAgICBhZGRlZEF0OiBub3csXG4gICAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgICBlc3RpbWF0ZWRTaXplLFxuICAgICAgICByYXdGcmVxdWVuY3k6IDFcbiAgICAgIH07XG4gICAgICBpZiAoKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gMTtcbiAgICAgICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZ2hvc3RRdWV1ZS5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5naG9zdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgdGhpcy5ob3RRdWV1ZS51bnNoaWZ0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVjZW50UXVldWUudW5zaGlmdChrZXkpO1xuICAgICAgaWYgKHRoaXMucmVjZW50UXVldWUubGVuZ3RoID4gdGhpcy5tYXhSZWNlbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IGV2aWN0ZWQgPSB0aGlzLnJlY2VudFF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAoZXZpY3RlZCkge1xuICAgICAgICAgIHRoaXMuZ2hvc3RRdWV1ZS5hZGQoZXZpY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZ2hvc3RRdWV1ZS5zaXplID4gdGhpcy5tYXhHaG9zdFNpemUpIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5naG9zdFF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgIGlmIChmaXJzdEtleSkge1xuICAgICAgICB0aGlzLmdob3N0UXVldWUuZGVsZXRlKGZpcnN0S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IHJlY2VudEluZGV4ID0gdGhpcy5yZWNlbnRRdWV1ZS5pbmRleE9mKGtleSk7XG4gICAgaWYgKHJlY2VudEluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5yZWNlbnRRdWV1ZS5zcGxpY2UocmVjZW50SW5kZXgsIDEpO1xuICAgIH1cbiAgICBjb25zdCBob3RJbmRleCA9IHRoaXMuaG90UXVldWUuaW5kZXhPZihrZXkpO1xuICAgIGlmIChob3RJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuaG90UXVldWUuc3BsaWNlKGhvdEluZGV4LCAxKTtcbiAgICB9XG4gICAgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYW4gaXRlbSBzaG91bGQgYmUgcHJvbW90ZWQgZnJvbSByZWNlbnQgdG8gaG90IHF1ZXVlXG4gICAqL1xuICBzaG91bGRQcm9tb3RlVG9Ib3RRdWV1ZShtZXRhZGF0YSkge1xuICAgIGlmICghdGhpcy5jb25maWcudXNlRnJlcXVlbmN5UHJvbW90aW9uKSB7XG4gICAgICByZXR1cm4gbWV0YWRhdGEuYWNjZXNzQ291bnQgPj0gMjtcbiAgICB9XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5jb25maWcucHJvbW90aW9uVGhyZXNob2xkID8/IDI7XG4gICAgY29uc3QgZnJlcXVlbmN5ID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGEpO1xuICAgIHJldHVybiBmcmVxdWVuY3kgPj0gdGhyZXNob2xkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZWZmZWN0aXZlIGZyZXF1ZW5jeSBmb3IgYW4gaXRlbSwgYXBwbHlpbmcgZGVjYXkgaWYgZW5hYmxlZFxuICAgKi9cbiAgZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KG1ldGFkYXRhKSB7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDApID09PSAwKSB7XG4gICAgICByZXR1cm4gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IG5vdyAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgICBjb25zdCBkZWNheUFtb3VudCA9IHRpbWVTaW5jZVVwZGF0ZSAvICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPz8gM2U1KSAqICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDAuMDUpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZnJlcXVlbmN5IHNjb3JlIHdpdGggZGVjYXkgYXBwbGllZFxuICAgKi9cbiAgY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGEsIGN1cnJlbnRUaW1lKSB7XG4gICAgY29uc3QgcmF3RnJlcSA9IG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cbiAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBjdXJyZW50VGltZSAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgY29uc3QgZGVjYXlBbW91bnQgPSB0aW1lU2luY2VVcGRhdGUgLyAodGhpcy5jb25maWcuaG90UXVldWVEZWNheUludGVydmFsID8/IDNlNSkgKiAodGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwLjA1KTtcbiAgICBjb25zdCBwcmV2aW91c1Njb3JlID0gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgfHwgcmF3RnJlcTtcbiAgICBjb25zdCBkZWNheWVkU2NvcmUgPSBwcmV2aW91c1Njb3JlICogKDEgLSBkZWNheUFtb3VudCk7XG4gICAgcmV0dXJuIE1hdGgubWF4KDEsIGRlY2F5ZWRTY29yZSArIDEpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSBwZXJpb2RpYyBkZWNheSB0byBob3QgcXVldWUgaXRlbXNcbiAgICovXG4gIGFwcGx5UGVyaW9kaWNEZWNheShpdGVtcykge1xuICAgIGlmICgodGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwKSA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZVNpbmNlRGVjYXkgPSBub3cgLSB0aGlzLmxhc3REZWNheVRpbWU7XG4gICAgaWYgKHRpbWVTaW5jZURlY2F5ID49ICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPz8gM2U1KSkge1xuICAgICAgaWYgKHRoaXMuaG90UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmhvdFF1ZXVlKSB7XG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBpdGVtcy5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAobWV0YWRhdGEgJiYgdHlwZW9mIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNheUFtb3VudCA9IHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMC4wNTtcbiAgICAgICAgICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gTWF0aC5tYXgoMSwgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdERlY2F5VGltZSA9IG5vdztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHN0cmF0ZWd5XG4gICAqL1xuICBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgaW50ZXJuYWwgc3RhdGUgKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmVjZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLmhvdFF1ZXVlID0gW107XG4gICAgdGhpcy5naG9zdFF1ZXVlLmNsZWFyKCk7XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lGYWN0b3J5LnRzXG5mdW5jdGlvbiBjcmVhdGVFdmljdGlvblN0cmF0ZWd5KHBvbGljeSwgbWF4Q2FjaGVTaXplLCBjb25maWcpIHtcbiAgY29uc3Qgc2FmZU1heENhY2hlU2l6ZSA9IHR5cGVvZiBtYXhDYWNoZVNpemUgPT09IFwibnVtYmVyXCIgJiYgbWF4Q2FjaGVTaXplID4gMCA/IG1heENhY2hlU2l6ZSA6IDFlMztcbiAgc3dpdGNoIChwb2xpY3kpIHtcbiAgICBjYXNlIFwibHJ1XCI6XG4gICAgICByZXR1cm4gbmV3IExSVUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICBjYXNlIFwibGZ1XCI6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxmdUNvbmZpZyA9IGNvbmZpZz8udHlwZSA9PT0gXCJsZnVcIiA/IGNvbmZpZyA6IHsgdHlwZTogXCJsZnVcIiB9O1xuICAgICAgICByZXR1cm4gbmV3IExGVUV2aWN0aW9uU3RyYXRlZ3kobGZ1Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY3JlYXRlIGxmdSBzdHJhdGVneSB3aXRoIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24sIGZhbGxpbmcgYmFjayB0byBMUlU6YCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlVFdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhc2UgXCJmaWZvXCI6XG4gICAgICByZXR1cm4gbmV3IEZJRk9FdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgY2FzZSBcIm1ydVwiOlxuICAgICAgcmV0dXJuIG5ldyBNUlVFdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgY2FzZSBcInJhbmRvbVwiOlxuICAgICAgcmV0dXJuIG5ldyBSYW5kb21FdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgY2FzZSBcImFyY1wiOiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcmNDb25maWcgPSBjb25maWc/LnR5cGUgPT09IFwiYXJjXCIgPyBjb25maWcgOiB7IC4uLkRFRkFVTFRfQVJDX0NPTkZJRywgbWF4Q2FjaGVTaXplOiBzYWZlTWF4Q2FjaGVTaXplIH07XG4gICAgICAgIGNvbnN0IGZpbmFsTWF4U2l6ZSA9IGFyY0NvbmZpZy5tYXhDYWNoZVNpemUgJiYgYXJjQ29uZmlnLm1heENhY2hlU2l6ZSA+IDAgPyBhcmNDb25maWcubWF4Q2FjaGVTaXplIDogc2FmZU1heENhY2hlU2l6ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBUkNFdmljdGlvblN0cmF0ZWd5KGZpbmFsTWF4U2l6ZSwgeyAuLi5hcmNDb25maWcsIG1heENhY2hlU2l6ZTogZmluYWxNYXhTaXplIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjcmVhdGUgYXJjIHN0cmF0ZWd5IHdpdGggcHJvdmlkZWQgY29uZmlndXJhdGlvbiwgZmFsbGluZyBiYWNrIHRvIExSVTpgLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IExSVUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSBcIjJxXCI6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHR3b1FDb25maWcgPSBjb25maWc/LnR5cGUgPT09IFwiMnFcIiA/IGNvbmZpZyA6IHsgLi4uREVGQVVMVF9UV09fUVVFVUVfQ09ORklHLCBtYXhDYWNoZVNpemU6IHNhZmVNYXhDYWNoZVNpemUgfTtcbiAgICAgICAgY29uc3QgZmluYWxNYXhTaXplID0gdHdvUUNvbmZpZy5tYXhDYWNoZVNpemUgJiYgdHdvUUNvbmZpZy5tYXhDYWNoZVNpemUgPiAwID8gdHdvUUNvbmZpZy5tYXhDYWNoZVNpemUgOiBzYWZlTWF4Q2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gbmV3IFR3b1F1ZXVlRXZpY3Rpb25TdHJhdGVneShmaW5hbE1heFNpemUsIHsgLi4udHdvUUNvbmZpZywgbWF4Q2FjaGVTaXplOiBmaW5hbE1heFNpemUgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNyZWF0ZSAycSBzdHJhdGVneSB3aXRoIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24sIGZhbGxpbmcgYmFjayB0byBMUlU6YCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlVFdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGV2aWN0aW9uIHBvbGljeTogJHtwb2xpY3l9YCk7XG4gIH1cbn1cblxuLy8gc3JjL3R0bC9UVExNYW5hZ2VyLnRzXG52YXIgbG9nZ2VyMjEgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJUVExNYW5hZ2VyXCIpO1xudmFyIFRUTE1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbmZpZztcbiAgY2xlYW51cFRpbWVyO1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgYXV0b0NsZWFudXA6IHRydWUsXG4gICAgICBjbGVhbnVwSW50ZXJ2YWw6IDZlNCxcbiAgICAgIC8vIDEgbWludXRlIGRlZmF1bHRcbiAgICAgIHZhbGlkYXRlT25BY2Nlc3M6IHRydWUsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICAgIGlmICh0aGlzLmNvbmZpZy5hdXRvQ2xlYW51cCAmJiB0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuc3RhcnRBdXRvQ2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgVFRMIGlzIGVuYWJsZWRcbiAgICovXG4gIGlzVFRMRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuY29uZmlnLmRlZmF1bHRUVEwgPT09IFwibnVtYmVyXCIgJiYgdGhpcy5jb25maWcuZGVmYXVsdFRUTCA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBUVEwgdmFsdWVcbiAgICovXG4gIGdldERlZmF1bHRUVEwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRlZmF1bHRUVEw7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBUVEwgY29uZmlndXJhdGlvblxuICAgKi9cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IG9sZENvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH07XG4gICAgaWYgKG9sZENvbmZpZy5hdXRvQ2xlYW51cCAhPT0gdGhpcy5jb25maWcuYXV0b0NsZWFudXAgfHwgb2xkQ29uZmlnLmNsZWFudXBJbnRlcnZhbCAhPT0gdGhpcy5jb25maWcuY2xlYW51cEludGVydmFsKSB7XG4gICAgICB0aGlzLnN0b3BBdXRvQ2xlYW51cCgpO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9DbGVhbnVwICYmIHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnN0YXJ0QXV0b0NsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyMjEuZGVidWcoXCJUVEwgY29uZmlndXJhdGlvbiB1cGRhdGVkXCIsIHsgY29uZmlnOiB0aGlzLmNvbmZpZyB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0IFRUTCBtZXRhZGF0YSBmb3IgYW4gaXRlbSB3aGVuIGl0J3MgYWRkZWRcbiAgICovXG4gIG9uSXRlbUFkZGVkKGtleSwgbWV0YWRhdGFQcm92aWRlciwgaXRlbVRUTCkge1xuICAgIGlmICghdGhpcy5pc1RUTEVuYWJsZWQoKSAmJiAhaXRlbVRUTCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICBsb2dnZXIyMS53YXJuaW5nKFwiTm8gbWV0YWRhdGEgZm91bmQgZm9yIGl0ZW0gd2hlbiBzZXR0aW5nIFRUTFwiLCB7IGtleSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHRsID0gaXRlbVRUTCB8fCB0aGlzLmNvbmZpZy5kZWZhdWx0VFRMO1xuICAgIGlmICh0dGwgJiYgdHRsID4gMCkge1xuICAgICAgY29uc3QgdHRsTWV0YWRhdGEgPSB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBleHBpcmVzQXQ6IG1ldGFkYXRhLmFkZGVkQXQgKyB0dGwsXG4gICAgICAgIHR0bFxuICAgICAgfTtcbiAgICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCB0dGxNZXRhZGF0YSk7XG4gICAgICBsb2dnZXIyMS50cmFjZShcIlRUTCBzZXQgZm9yIGl0ZW1cIiwgeyBrZXksIHR0bCwgZXhwaXJlc0F0OiB0dGxNZXRhZGF0YS5leHBpcmVzQXQgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBpdGVtIGhhcyBleHBpcmVkXG4gICAqL1xuICBpc0V4cGlyZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSB8fCAhbWV0YWRhdGEuZXhwaXJlc0F0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IG5vdyA+PSBtZXRhZGF0YS5leHBpcmVzQXQ7XG4gICAgaWYgKGV4cGlyZWQpIHtcbiAgICAgIGxvZ2dlcjIxLnRyYWNlKFwiSXRlbSBleHBpcmVkXCIsIHsga2V5LCBleHBpcmVzQXQ6IG1ldGFkYXRhLmV4cGlyZXNBdCwgbm93IH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwaXJlZDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gaXRlbSBpcyB2YWxpZCAobm90IGV4cGlyZWQpIGJlZm9yZSByZXR1cm5pbmcgaXRcbiAgICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgdmFsaWQsIGZhbHNlIGlmIGV4cGlyZWRcbiAgICovXG4gIHZhbGlkYXRlSXRlbShrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnZhbGlkYXRlT25BY2Nlc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNFeHBpcmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBUVEwgaW5mb3JtYXRpb24gZm9yIGFuIGl0ZW1cbiAgICovXG4gIGdldEl0ZW1UVExJbmZvKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEgfHwgIW1ldGFkYXRhLmV4cGlyZXNBdCkge1xuICAgICAgcmV0dXJuIHsgaGFzVFRMOiBmYWxzZSwgaXNFeHBpcmVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGlzRXhwaXJlZCA9IG5vdyA+PSBtZXRhZGF0YS5leHBpcmVzQXQ7XG4gICAgY29uc3QgcmVtYWluaW5nVFRMID0gaXNFeHBpcmVkID8gMCA6IG1ldGFkYXRhLmV4cGlyZXNBdCAtIG5vdztcbiAgICByZXR1cm4ge1xuICAgICAgaGFzVFRMOiB0cnVlLFxuICAgICAgdHRsOiBtZXRhZGF0YS50dGwsXG4gICAgICBleHBpcmVzQXQ6IG1ldGFkYXRhLmV4cGlyZXNBdCxcbiAgICAgIHJlbWFpbmluZ1RUTCxcbiAgICAgIGlzRXhwaXJlZFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGV4cGlyZWQgaXRlbXNcbiAgICovXG4gIGZpbmRFeHBpcmVkSXRlbXMobWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IGV4cGlyZWRLZXlzID0gW107XG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIG1ldGFkYXRhXSBvZiBhbGxNZXRhZGF0YSkge1xuICAgICAgY29uc3QgdHRsTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgIGlmICh0dGxNZXRhZGF0YS5leHBpcmVzQXQgJiYgbm93ID49IHR0bE1ldGFkYXRhLmV4cGlyZXNBdCkge1xuICAgICAgICBleHBpcmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHBpcmVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2dnZXIyMS5kZWJ1ZyhcIkZvdW5kIGV4cGlyZWQgaXRlbXNcIiwgeyBjb3VudDogZXhwaXJlZEtleXMubGVuZ3RoLCBrZXlzOiBleHBpcmVkS2V5cyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGlyZWRLZXlzO1xuICB9XG4gIC8qKlxuICAgKiBNYW51YWxseSBjbGVhbiB1cCBleHBpcmVkIGl0ZW1zXG4gICAqIFJldHVybnMgdGhlIGtleXMgb2YgaXRlbXMgdGhhdCB3ZXJlIGV4cGlyZWRcbiAgICovXG4gIGNsZWFudXBFeHBpcmVkSXRlbXMobWV0YWRhdGFQcm92aWRlcikge1xuICAgIHJldHVybiB0aGlzLmZpbmRFeHBpcmVkSXRlbXMobWV0YWRhdGFQcm92aWRlcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCByZW1haW5pbmcgVFRMIGZvciBhbiBpdGVtIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgZ2V0UmVtYWluaW5nVFRMKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldEl0ZW1UVExJbmZvKGtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgcmV0dXJuIGluZm8uaGFzVFRMID8gaW5mby5yZW1haW5pbmdUVEwgfHwgMCA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEV4dGVuZCBUVEwgZm9yIGFuIGl0ZW1cbiAgICovXG4gIGV4dGVuZFRUTChrZXksIG1ldGFkYXRhUHJvdmlkZXIsIGFkZGl0aW9uYWxUVEwpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhIHx8ICFtZXRhZGF0YS5leHBpcmVzQXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWV0YWRhdGEuZXhwaXJlc0F0ICs9IGFkZGl0aW9uYWxUVEw7XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgICBsb2dnZXIyMS50cmFjZShcIlRUTCBleHRlbmRlZCBmb3IgaXRlbVwiLCB7IGtleSwgYWRkaXRpb25hbFRUTCwgbmV3RXhwaXJlc0F0OiBtZXRhZGF0YS5leHBpcmVzQXQgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IFRUTCBmb3IgYW4gaXRlbSAocmVmcmVzaCBleHBpcmF0aW9uKVxuICAgKi9cbiAgcmVmcmVzaFRUTChrZXksIG1ldGFkYXRhUHJvdmlkZXIsIG5ld1RUTCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHRsID0gbmV3VFRMIHx8IG1ldGFkYXRhLnR0bCB8fCB0aGlzLmNvbmZpZy5kZWZhdWx0VFRMO1xuICAgIGlmICghdHRsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdHRsTWV0YWRhdGEgPSB7XG4gICAgICAuLi5tZXRhZGF0YSxcbiAgICAgIGV4cGlyZXNBdDogbm93ICsgdHRsLFxuICAgICAgdHRsXG4gICAgfTtcbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgdHRsTWV0YWRhdGEpO1xuICAgIGxvZ2dlcjIxLnRyYWNlKFwiVFRMIHJlZnJlc2hlZCBmb3IgaXRlbVwiLCB7IGtleSwgdHRsLCBleHBpcmVzQXQ6IHR0bE1ldGFkYXRhLmV4cGlyZXNBdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYXV0b21hdGljIGNsZWFudXAgb2YgZXhwaXJlZCBpdGVtc1xuICAgKi9cbiAgc3RhcnRBdXRvQ2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIHRoaXMuc3RvcEF1dG9DbGVhbnVwKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBsb2dnZXIyMS50cmFjZShcIkF1dG8gY2xlYW51cCB0aW1lciB0cmlnZ2VyZWRcIik7XG4gICAgICB9LCB0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwpO1xuICAgICAgbG9nZ2VyMjEuZGVidWcoXCJBdXRvIGNsZWFudXAgc3RhcnRlZFwiLCB7IGludGVydmFsOiB0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdG9wIGF1dG9tYXRpYyBjbGVhbnVwXG4gICAqL1xuICBzdG9wQXV0b0NsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICAgIGxvZ2dlcjIxLmRlYnVnKFwiQXV0byBjbGVhbnVwIHN0b3BwZWRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDbGVhbnVwIHJlc291cmNlc1xuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BBdXRvQ2xlYW51cCgpO1xuICAgIGxvZ2dlcjIxLmRlYnVnKFwiVFRMIG1hbmFnZXIgZGVzdHJveWVkXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL0NhY2hlRXZlbnRFbWl0dGVyLnRzXG52YXIgQ2FjaGVFdmVudEVtaXR0ZXIgPSBjbGFzcyB7XG4gIHN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBuZXh0U3Vic2NyaXB0aW9uSWQgPSAxO1xuICBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICBjbGVhbnVwSW50ZXJ2YWwgPSBudWxsO1xuICBDTEVBTlVQX0lOVEVSVkFMX01TID0gM2U0O1xuICAvLyAzMCBzZWNvbmRzXG4gIE1BWF9JTkFDVElWRV9USU1FX01TID0gM2U1O1xuICAvLyA1IG1pbnV0ZXNcbiAgV0VBS19SRUZfRU5BQkxFRCA9IHR5cGVvZiBXZWFrUmVmICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXJ0UGVyaW9kaWNDbGVhbnVwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHBlcmlvZGljIGNsZWFudXAgb2YgaW5hY3RpdmUgc3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgc3RhcnRQZXJpb2RpY0NsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsKSByZXR1cm47XG4gICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnBlcmZvcm1QZXJpb2RpY0NsZWFudXAoKTtcbiAgICB9LCB0aGlzLkNMRUFOVVBfSU5URVJWQUxfTVMpO1xuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbC51bnJlZikge1xuICAgICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwudW5yZWYoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gcGVyaW9kaWMgY2xlYW51cCBvZiBpbmFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAqL1xuICBwZXJmb3JtUGVyaW9kaWNDbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0b1JlbW92ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgW2lkLCBzdWJzY3JpcHRpb25dIG9mIHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgaWYgKCFzdWJzY3JpcHRpb24uaXNBY3RpdmUgfHwgbm93IC0gc3Vic2NyaXB0aW9uLmxhc3RBY2Nlc3NUaW1lID4gdGhpcy5NQVhfSU5BQ1RJVkVfVElNRV9NUykge1xuICAgICAgICB0b1JlbW92ZS5wdXNoKGlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5XRUFLX1JFRl9FTkFCTEVEICYmIHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZi5kZXJlZigpO1xuICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgdG9SZW1vdmUucHVzaChpZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdG9SZW1vdmUuZm9yRWFjaCgoaWQpID0+IHRoaXMudW5zdWJzY3JpYmUoaWQpKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGNhY2hlIGV2ZW50c1xuICAgKi9cbiAgc3Vic2NyaWJlKGxpc3RlbmVyLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1YnNjcmliZSB0byBkZXN0cm95ZWQgZXZlbnQgZW1pdHRlclwiKTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgc3Vic2NyaXB0aW9uXyR7dGhpcy5uZXh0U3Vic2NyaXB0aW9uSWQrK31gO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgaWQsXG4gICAgICBsaXN0ZW5lcixcbiAgICAgIGxpc3RlbmVyUmVmOiB0aGlzLldFQUtfUkVGX0VOQUJMRUQgJiYgb3B0aW9ucy51c2VXZWFrUmVmICE9PSBmYWxzZSA/IG5ldyBXZWFrUmVmKGxpc3RlbmVyKSA6IHZvaWQgMCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc1RpbWU6IG5vd1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4gdGhpcy51bnN1YnNjcmliZShpZCksXG4gICAgICBpc0FjdGl2ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgIHN1Yi5sYXN0QWNjZXNzVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Yj8uaXNBY3RpdmUgPz8gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZ2V0T3B0aW9uczogKCkgPT4gKHsgLi4ub3B0aW9ucyB9KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gZXZlbnRzXG4gICAqL1xuICB1bnN1YnNjcmliZShzdWJzY3JpcHRpb25JZCkge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoc3Vic2NyaXB0aW9uSWQpO1xuICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgc3Vic2NyaXB0aW9uLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJzY3JpcHRpb25JZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnQgdG8gYWxsIG1hdGNoaW5nIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIGVtaXQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgIGlmICghc3Vic2NyaXB0aW9uLmlzQWN0aXZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2hvdWxkRW1pdFRvU3Vic2NyaXB0aW9uKGV2ZW50LCBzdWJzY3JpcHRpb24pKSB7XG4gICAgICAgIHRoaXMuZW1pdFRvU3Vic2NyaXB0aW9uKGV2ZW50LCBzdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IGNvdW50IG9mIGFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAqL1xuICBnZXRTdWJzY3JpcHRpb25Db3VudCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCkpLmZpbHRlcigocykgPT4gcy5pc0FjdGl2ZSkubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc3Vic2NyaXB0aW9uIGRldGFpbHMgKGZvciBkZWJ1Z2dpbmcpXG4gICAqL1xuICBnZXRTdWJzY3JpcHRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKChzKSA9PiBzLmlzQWN0aXZlKS5tYXAoKHMpID0+ICh7IGlkOiBzLmlkLCBvcHRpb25zOiB7IC4uLnMub3B0aW9ucyB9IH0pKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZXZlbnQgZW1pdHRlciBhbmQgY2xlYW4gdXAgYWxsIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cEludGVydmFsKTtcbiAgICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2YgdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBldmVudCBzaG91bGQgYmUgZW1pdHRlZCB0byBhIHNwZWNpZmljIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgc2hvdWxkRW1pdFRvU3Vic2NyaXB0aW9uKGV2ZW50LCBzdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICBpZiAob3B0aW9ucy5ldmVudFR5cGVzICYmICFvcHRpb25zLmV2ZW50VHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMua2V5cyAmJiBvcHRpb25zLmtleXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKFwia2V5XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRLZXlTdHIgPSB0aGlzLm5vcm1hbGl6ZUtleShldmVudC5rZXkpO1xuICAgICAgICBjb25zdCBtYXRjaGVzS2V5ID0gb3B0aW9ucy5rZXlzLnNvbWUoXG4gICAgICAgICAgKGtleSkgPT4gdGhpcy5ub3JtYWxpemVLZXkoa2V5KSA9PT0gZXZlbnRLZXlTdHJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFwiYWZmZWN0ZWRLZXlzXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRLZXlTdHJzID0gZXZlbnQuYWZmZWN0ZWRLZXlzLm1hcCgoa2V5KSA9PiB0aGlzLm5vcm1hbGl6ZUtleShrZXkpKTtcbiAgICAgICAgY29uc3QgaGFzTWF0Y2hpbmdLZXkgPSBvcHRpb25zLmtleXMuc29tZShcbiAgICAgICAgICAoa2V5KSA9PiBldmVudEtleVN0cnMuaW5jbHVkZXModGhpcy5ub3JtYWxpemVLZXkoa2V5KSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFoYXNNYXRjaGluZ0tleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMgJiYgb3B0aW9ucy5sb2NhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKFwiYWZmZWN0ZWRMb2NhdGlvbnNcIiBpbiBldmVudCAmJiBldmVudC5hZmZlY3RlZExvY2F0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMubG9jYXRpb25zTWF0Y2gob3B0aW9ucy5sb2NhdGlvbnMsIGV2ZW50LmFmZmVjdGVkTG9jYXRpb25zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcImxvY2F0aW9uc1wiIGluIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5sb2NhdGlvbnNNYXRjaChvcHRpb25zLmxvY2F0aW9ucywgZXZlbnQubG9jYXRpb25zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcImtleVwiIGluIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5rZXlNYXRjaGVzTG9jYXRpb25zKGV2ZW50LmtleSwgb3B0aW9ucy5sb2NhdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgICBpZiAoXCJxdWVyeVwiIGluIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5xdWVyaWVzTWF0Y2gob3B0aW9ucy5xdWVyeSwgZXZlbnQucXVlcnkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgZXZlbnQgdG8gYSBzcGVjaWZpYyBzdWJzY3JpcHRpb24sIGhhbmRsaW5nIGRlYm91bmNpbmdcbiAgICovXG4gIGVtaXRUb1N1YnNjcmlwdGlvbihldmVudCwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3Vic2NyaXB0aW9uLmxhc3RBY2Nlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgbGlzdGVuZXIgPSBzdWJzY3JpcHRpb24ubGlzdGVuZXI7XG4gICAgaWYgKHRoaXMuV0VBS19SRUZfRU5BQkxFRCAmJiBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYpIHtcbiAgICAgIGNvbnN0IHdlYWtMaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZi5kZXJlZigpO1xuICAgICAgaWYgKCF3ZWFrTGlzdGVuZXIpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyID0gd2Vha0xpc3RlbmVyO1xuICAgIH1cbiAgICBpZiAoIXN1YnNjcmlwdGlvbi5vcHRpb25zLmRlYm91bmNlTXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTGlzdGVuZXJFcnJvcihlcnJvciwgZXZlbnQsIHN1YnNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uaXNBY3RpdmUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRMaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lcjtcbiAgICAgICAgaWYgKHRoaXMuV0VBS19SRUZfRU5BQkxFRCAmJiBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYpIHtcbiAgICAgICAgICBjb25zdCB3ZWFrTGlzdGVuZXIgPSBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYuZGVyZWYoKTtcbiAgICAgICAgICBpZiAoIXdlYWtMaXN0ZW5lcikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRMaXN0ZW5lciA9IHdlYWtMaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLmxhc3RFbWl0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVMaXN0ZW5lckVycm9yKGVycm9yLCBldmVudCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgIH0sIHN1YnNjcmlwdGlvbi5vcHRpb25zLmRlYm91bmNlTXMpO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBrZXkgZm9yIGNvbXBhcmlzb25cbiAgICovXG4gIG5vcm1hbGl6ZUtleShrZXkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5LCAoaywgdikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVLZXlWYWx1ZSh2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBsb2NhdGlvbiBrZXkgZm9yIGNvbXBhcmlzb25cbiAgICovXG4gIG5vcm1hbGl6ZUxvY0tleShrZXkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5LCAoaywgdikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVLZXlWYWx1ZSh2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gbG9jYXRpb24gYXJyYXlzIG1hdGNoXG4gICAqL1xuICBsb2NhdGlvbnNNYXRjaChmaWx0ZXIsIGV2ZW50TG9jYXRpb25zKSB7XG4gICAgaWYgKGZpbHRlci5sZW5ndGggPT09IDAgJiYgZXZlbnRMb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5sZW5ndGggIT09IGV2ZW50TG9jYXRpb25zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyLmV2ZXJ5KChmaWx0ZXJMb2MsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBldmVudExvYyA9IGV2ZW50TG9jYXRpb25zW2luZGV4XTtcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUtleShmaWx0ZXJMb2MpID09PSB0aGlzLm5vcm1hbGl6ZUtleShldmVudExvYyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IG1hdGNoZXMgbG9jYXRpb24gZmlsdGVyc1xuICAgKi9cbiAga2V5TWF0Y2hlc0xvY2F0aW9ucyhrZXksIGZpbHRlckxvY2F0aW9ucykge1xuICAgIGlmIChcImxvY1wiIGluIGtleSAmJiBrZXkubG9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbnNNYXRjaChmaWx0ZXJMb2NhdGlvbnMsIGtleS5sb2MpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyTG9jYXRpb25zLmxlbmd0aCA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIHF1ZXJpZXMgbWF0Y2ggKGltcHJvdmVkIGNvbXBhcmlzb24pXG4gICAqL1xuICBxdWVyaWVzTWF0Y2goZmlsdGVyUXVlcnksIGV2ZW50UXVlcnkpIHtcbiAgICBjb25zdCBub3JtYWxpemUgPSAob2JqKSA9PiB7XG4gICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBvYmo7XG4gICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIG9iajtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKG5vcm1hbGl6ZSkuc29ydCgpO1xuICAgICAgY29uc3Qgc29ydGVkID0ge307XG4gICAgICBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgc29ydGVkW2tleV0gPSBub3JtYWxpemUob2JqW2tleV0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydGVkO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZShmaWx0ZXJRdWVyeSkpID09PSBKU09OLnN0cmluZ2lmeShub3JtYWxpemUoZXZlbnRRdWVyeSkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgZXJyb3JzIHRoYXQgb2NjdXIgaW4gZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBoYW5kbGVMaXN0ZW5lckVycm9yKGVycm9yLCBldmVudCwgc3Vic2NyaXB0aW9uKSB7XG4gICAgY29uc3QgZXJyb3JPYmogPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSk7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vcHRpb25zLm9uRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5vcHRpb25zLm9uRXJyb3IoZXJyb3JPYmosIGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGhhbmRsZXJFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2FjaGUgZXZlbnQgbGlzdGVuZXI6XCIsIGVycm9yT2JqKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGVycm9yIGhhbmRsZXI6XCIsIGhhbmRsZXJFcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjYWNoZSBldmVudCBsaXN0ZW5lcjpcIiwgZXJyb3JPYmopO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL0NhY2hlU3RhdHMudHNcbnZhciBDYWNoZVN0YXRzTWFuYWdlciA9IGNsYXNzIHtcbiAgc3RhdHMgPSB7XG4gICAgbnVtUmVxdWVzdHM6IDAsXG4gICAgbnVtTWlzc2VzOiAwLFxuICAgIG51bUhpdHM6IDAsXG4gICAgbnVtU3Vic2NyaXB0aW9uczogMCxcbiAgICBudW1VbnN1YnNjcmlwdGlvbnM6IDAsXG4gICAgYWN0aXZlU3Vic2NyaXB0aW9uczogMFxuICB9O1xuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSByZXF1ZXN0IGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudFJlcXVlc3RzKCkge1xuICAgIHRoaXMuc3RhdHMubnVtUmVxdWVzdHMrKztcbiAgfVxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBjYWNoZSBoaXQgY291bnRlclxuICAgKi9cbiAgaW5jcmVtZW50SGl0cygpIHtcbiAgICB0aGlzLnN0YXRzLm51bUhpdHMrKztcbiAgfVxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBjYWNoZSBtaXNzIGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudE1pc3NlcygpIHtcbiAgICB0aGlzLnN0YXRzLm51bU1pc3NlcysrO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHN1YnNjcmlwdGlvbiBjb3VudGVyXG4gICAqL1xuICBpbmNyZW1lbnRTdWJzY3JpcHRpb25zKCkge1xuICAgIHRoaXMuc3RhdHMubnVtU3Vic2NyaXB0aW9ucysrO1xuICAgIHRoaXMuc3RhdHMuYWN0aXZlU3Vic2NyaXB0aW9ucysrO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHVuc3Vic2NyaXB0aW9uIGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudFVuc3Vic2NyaXB0aW9ucygpIHtcbiAgICB0aGlzLnN0YXRzLm51bVVuc3Vic2NyaXB0aW9ucysrO1xuICAgIGlmICh0aGlzLnN0YXRzLmFjdGl2ZVN1YnNjcmlwdGlvbnMgPiAwKSB7XG4gICAgICB0aGlzLnN0YXRzLmFjdGl2ZVN1YnNjcmlwdGlvbnMtLTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgc3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5zdGF0cyB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBhbGwgc3RhdGlzdGljcyB0byB6ZXJvXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgbnVtUmVxdWVzdHM6IDAsXG4gICAgICBudW1NaXNzZXM6IDAsXG4gICAgICBudW1IaXRzOiAwLFxuICAgICAgbnVtU3Vic2NyaXB0aW9uczogMCxcbiAgICAgIG51bVVuc3Vic2NyaXB0aW9uczogMCxcbiAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnM6IDBcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvQ2FjaGUudHNcbnZhciBsb2dnZXIyMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkNhY2hlXCIpO1xudmFyIGNyZWF0ZUNhY2hlID0gKGFwaSwgY29vcmRpbmF0ZSwgcmVnaXN0cnksIG9wdGlvbnMpID0+IHtcbiAgbG9nZ2VyMjIuZGVidWcoXCJjcmVhdGVDYWNoZVwiLCB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5LCBvcHRpb25zIH0pO1xuICBjb25zdCBjb21wbGV0ZU9wdGlvbnMgPSBjcmVhdGVPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBjYWNoZU1hcCA9IGNyZWF0ZUNhY2hlTWFwKGNvb3JkaW5hdGUua3RhLCBjb21wbGV0ZU9wdGlvbnMpO1xuICBjb25zdCBwa1R5cGUgPSBjb29yZGluYXRlLmt0YVswXTtcbiAgY29uc3QgZXZlbnRFbWl0dGVyID0gbmV3IENhY2hlRXZlbnRFbWl0dGVyKCk7XG4gIGNvbnN0IGV2aWN0aW9uTWFuYWdlciA9IG5ldyBFdmljdGlvbk1hbmFnZXIoKTtcbiAgY29uc3QgZXZpY3Rpb25Db25maWcgPSBjb21wbGV0ZU9wdGlvbnMuZXZpY3Rpb25Db25maWc7XG4gIGlmICghZXZpY3Rpb25Db25maWcgJiYgY29tcGxldGVPcHRpb25zLm1lbW9yeUNvbmZpZz8uc2l6ZT8uZXZpY3Rpb25Qb2xpY3kgJiYgKGNvbXBsZXRlT3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZS5tYXhJdGVtcyB8fCBjb21wbGV0ZU9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4U2l6ZUJ5dGVzKSkge1xuICB9XG4gIGlmIChldmljdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY3JlYXRlRXZpY3Rpb25TdHJhdGVneShcbiAgICAgIGV2aWN0aW9uQ29uZmlnLnR5cGUgfHwgXCJscnVcIixcbiAgICAgIGNvbXBsZXRlT3B0aW9ucy5tZW1vcnlDb25maWc/Lm1heEl0ZW1zLFxuICAgICAgZXZpY3Rpb25Db25maWdcbiAgICApO1xuICAgIGV2aWN0aW9uTWFuYWdlci5zZXRFdmljdGlvblN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgfVxuICBjb25zdCB0dGxNYW5hZ2VyID0gbmV3IFRUTE1hbmFnZXIoe1xuICAgIGRlZmF1bHRUVEw6IGNvbXBsZXRlT3B0aW9ucy50dGwsXG4gICAgYXV0b0NsZWFudXA6IHRydWUsXG4gICAgdmFsaWRhdGVPbkFjY2VzczogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgc3RhdHNNYW5hZ2VyID0gbmV3IENhY2hlU3RhdHNNYW5hZ2VyKCk7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVPcGVyYXRpb25zKGFwaSwgY29vcmRpbmF0ZSwgY2FjaGVNYXAsIHBrVHlwZSwgY29tcGxldGVPcHRpb25zLCBldmVudEVtaXR0ZXIsIHR0bE1hbmFnZXIsIGV2aWN0aW9uTWFuYWdlciwgc3RhdHNNYW5hZ2VyKTtcbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgY29vcmRpbmF0ZSxcbiAgICByZWdpc3RyeSxcbiAgICBhcGksXG4gICAgY2FjaGVNYXAsXG4gICAgb3BlcmF0aW9ucyxcbiAgICBvcHRpb25zOiBjb21wbGV0ZU9wdGlvbnMsXG4gICAgZXZlbnRFbWl0dGVyLFxuICAgIGV2aWN0aW9uTWFuYWdlcixcbiAgICB0dGxNYW5hZ2VyLFxuICAgIHN0YXRzTWFuYWdlcixcbiAgICBnZXRDYWNoZUluZm86ICgpID0+IHtcbiAgICAgIGNvbnN0IGV2aWN0aW9uU3RyYXRlZ3lOYW1lID0gZXZpY3Rpb25NYW5hZ2VyLmdldEV2aWN0aW9uU3RyYXRlZ3lOYW1lKCk7XG4gICAgICBjb25zdCBjYWNoZUluZm8gPSB7XG4gICAgICAgIGltcGxlbWVudGF0aW9uVHlwZTogY2FjaGVNYXAuaW1wbGVtZW50YXRpb25UeXBlLFxuICAgICAgICBkZWZhdWx0VFRMOiB0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSxcbiAgICAgICAgLy8gQ2FjaGUgc3VwcG9ydHMgVFRMIGlmIHRoZSBDYWNoZU1hcCBzdXBwb3J0cyBpdCBPUiBpZiBUVEwgaXMgY29uZmlndXJlZFxuICAgICAgICBzdXBwb3J0c1RUTDogY2FjaGVNYXAuc3VwcG9ydHNUVEw/LigpIHx8ICEhdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCksXG4gICAgICAgIHN1cHBvcnRzRXZpY3Rpb246IGV2aWN0aW9uTWFuYWdlci5pc0V2aWN0aW9uU3VwcG9ydGVkKClcbiAgICAgIH07XG4gICAgICBpZiAoZXZpY3Rpb25TdHJhdGVneU5hbWUpIHtcbiAgICAgICAgY2FjaGVJbmZvLmV2aWN0aW9uUG9saWN5ID0gZXZpY3Rpb25TdHJhdGVneU5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVJbmZvO1xuICAgIH0sXG4gICAgZ2V0U3RhdHM6ICgpID0+IHN0YXRzTWFuYWdlci5nZXRTdGF0cygpLFxuICAgIHN1YnNjcmliZTogKGxpc3RlbmVyLCBvcHRpb25zMikgPT4ge1xuICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHJldHVybiBldmVudEVtaXR0ZXIuc3Vic2NyaWJlKGxpc3RlbmVyLCBvcHRpb25zMik7XG4gICAgfSxcbiAgICB1bnN1YnNjcmliZTogKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXZlbnRFbWl0dGVyLnVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbi5pZCk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRVbnN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBldmVudEVtaXR0ZXIuZGVzdHJveSgpO1xuICAgICAgaWYgKHR0bE1hbmFnZXIgJiYgdHlwZW9mIHR0bE1hbmFnZXIuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHR0bE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhY2hlTWFwICYmIHR5cGVvZiBjYWNoZU1hcC5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FjaGVNYXAuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgQ2FjaGVFdmVudEZhY3RvcnkuZGVzdHJveUluc3RhbmNlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gY2FjaGU7XG59O1xudmFyIGlzQ2FjaGUgPSAoY2FjaGUpID0+IHtcbiAgcmV0dXJuIGNhY2hlICE9PSBudWxsICYmIHR5cGVvZiBjYWNoZSA9PT0gXCJvYmplY3RcIiAmJiBcImNvb3JkaW5hdGVcIiBpbiBjYWNoZSAmJiBcInJlZ2lzdHJ5XCIgaW4gY2FjaGUgJiYgXCJhcGlcIiBpbiBjYWNoZSAmJiBcImNhY2hlTWFwXCIgaW4gY2FjaGUgJiYgXCJvcGVyYXRpb25zXCIgaW4gY2FjaGU7XG59O1xuXG4vLyBzcmMvSW5zdGFuY2VGYWN0b3J5LnRzXG52YXIgbG9nZ2VyMjMgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJbnN0YW5jZUZhY3RvcnlcIik7XG52YXIgY3JlYXRlSW5zdGFuY2VGYWN0b3J5ID0gKGFwaSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZU9wdGlvbnMgPSBjcmVhdGVPcHRpb25zKG9wdGlvbnMpO1xuICB2YWxpZGF0ZU9wdGlvbnModGVtcGxhdGVPcHRpb25zKTtcbiAgcmV0dXJuIChjb29yZGluYXRlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2VPcHRpb25zID0gY3JlYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBsb2dnZXIyMy5kZWJ1ZyhcIkNyZWF0aW5nIGNhY2hlIGluc3RhbmNlXCIsIHtcbiAgICAgIGNvb3JkaW5hdGUsXG4gICAgICByZWdpc3RyeTogY29udGV4dC5yZWdpc3RyeSxcbiAgICAgIGFwaSxcbiAgICAgIGNhY2hlVHlwZTogaW5zdGFuY2VPcHRpb25zLmNhY2hlVHlwZSxcbiAgICAgIG9wdGlvbnM6IGluc3RhbmNlT3B0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IGNhY2hlTWFwID0gY3JlYXRlQ2FjaGVNYXAoY29vcmRpbmF0ZS5rdGEsIGluc3RhbmNlT3B0aW9ucyk7XG4gICAgY29uc3QgcGtUeXBlID0gY29vcmRpbmF0ZS5rdGFbMF07XG4gICAgY29uc3QgZXZlbnRFbWl0dGVyID0gbmV3IENhY2hlRXZlbnRFbWl0dGVyKCk7XG4gICAgY29uc3QgdHRsTWFuYWdlciA9IG5ldyBUVExNYW5hZ2VyKHtcbiAgICAgIGRlZmF1bHRUVEw6IGluc3RhbmNlT3B0aW9ucy50dGwsXG4gICAgICBhdXRvQ2xlYW51cDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlT25BY2Nlc3M6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBldmljdGlvbk1hbmFnZXIgPSBuZXcgRXZpY3Rpb25NYW5hZ2VyKCk7XG4gICAgY29uc3Qgc3RhdHNNYW5hZ2VyID0gbmV3IENhY2hlU3RhdHNNYW5hZ2VyKCk7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IGNyZWF0ZU9wZXJhdGlvbnMoXG4gICAgICBhcGksXG4gICAgICBjb29yZGluYXRlLFxuICAgICAgY2FjaGVNYXAsXG4gICAgICBwa1R5cGUsXG4gICAgICBpbnN0YW5jZU9wdGlvbnMsXG4gICAgICBldmVudEVtaXR0ZXIsXG4gICAgICB0dGxNYW5hZ2VyLFxuICAgICAgZXZpY3Rpb25NYW5hZ2VyLFxuICAgICAgc3RhdHNNYW5hZ2VyXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHJlZ2lzdHJ5OiBjb250ZXh0LnJlZ2lzdHJ5LFxuICAgICAgYXBpLFxuICAgICAgY2FjaGVNYXAsXG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgb3B0aW9uczogaW5zdGFuY2VPcHRpb25zLFxuICAgICAgZXZlbnRFbWl0dGVyLFxuICAgICAgdHRsTWFuYWdlcixcbiAgICAgIGV2aWN0aW9uTWFuYWdlcixcbiAgICAgIGdldENhY2hlSW5mbzogKCkgPT4ge1xuICAgICAgICBjb25zdCBldmljdGlvblN0cmF0ZWd5TmFtZSA9IGV2aWN0aW9uTWFuYWdlci5nZXRFdmljdGlvblN0cmF0ZWd5TmFtZSgpO1xuICAgICAgICBjb25zdCBjYWNoZUluZm8gPSB7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25UeXBlOiBjYWNoZU1hcC5pbXBsZW1lbnRhdGlvblR5cGUsXG4gICAgICAgICAgZGVmYXVsdFRUTDogdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCksXG4gICAgICAgICAgc3VwcG9ydHNUVEw6IGNhY2hlTWFwLnN1cHBvcnRzVFRMPy4oKSB8fCAhIXR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpLFxuICAgICAgICAgIHN1cHBvcnRzRXZpY3Rpb246IGV2aWN0aW9uTWFuYWdlci5pc0V2aWN0aW9uU3VwcG9ydGVkKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2aWN0aW9uU3RyYXRlZ3lOYW1lKSB7XG4gICAgICAgICAgY2FjaGVJbmZvLmV2aWN0aW9uUG9saWN5ID0gZXZpY3Rpb25TdHJhdGVneU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlSW5mbztcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmU6IChsaXN0ZW5lciwgb3B0aW9uczIpID0+IGV2ZW50RW1pdHRlci5zdWJzY3JpYmUobGlzdGVuZXIsIG9wdGlvbnMyKSxcbiAgICAgIHVuc3Vic2NyaWJlOiAoc3Vic2NyaXB0aW9uKSA9PiBldmVudEVtaXR0ZXIudW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uLmlkKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0dGxNYW5hZ2VyLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHR0bE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50RW1pdHRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHNyYy9JbnN0YW5jZS50c1xudmFyIGxvZ2dlcjI0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSW5zdGFuY2VcIik7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAocmVnaXN0cnksIGNvb3JkaW5hdGUsIGFwaSwgb3B0aW9ucykgPT4ge1xuICBsb2dnZXIyNC5kZWJ1ZyhcImNyZWF0ZUluc3RhbmNlXCIsIHsgY29vcmRpbmF0ZSwgYXBpLCByZWdpc3RyeSwgb3B0aW9ucyB9KTtcbiAgcmV0dXJuIGNyZWF0ZUNhY2hlKGFwaSwgY29vcmRpbmF0ZSwgcmVnaXN0cnksIG9wdGlvbnMpO1xufTtcbnZhciBpc0luc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIHJldHVybiBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UgPT09IFwib2JqZWN0XCIgJiYgXCJjb29yZGluYXRlXCIgaW4gaW5zdGFuY2UgJiYgXCJyZWdpc3RyeVwiIGluIGluc3RhbmNlICYmIFwiYXBpXCIgaW4gaW5zdGFuY2UgJiYgXCJjYWNoZU1hcFwiIGluIGluc3RhbmNlICYmIFwib3BlcmF0aW9uc1wiIGluIGluc3RhbmNlO1xufTtcblxuLy8gc3JjL0FnZ3JlZ2F0b3IudHNcbnZhciBsb2dnZXIyNSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkl0ZW1BZ2dyZWdhdG9yXCIpO1xudmFyIHRvQ2FjaGVDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gIGxldCBjYWNoZUNvbmZpZztcbiAgaWYgKGNvbmZpZy5vcHRpb25hbCA9PT0gdm9pZCAwKSB7XG4gICAgY2FjaGVDb25maWcgPSB7IGNhY2hlOiBjb25maWcsIG9wdGlvbmFsOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNhY2hlQ29uZmlnID0gY29uZmlnO1xuICB9XG4gIHJldHVybiBjYWNoZUNvbmZpZztcbn07XG52YXIgY3JlYXRlQWdncmVnYXRvciA9IGFzeW5jIChjYWNoZSwgeyBhZ2dyZWdhdGVzID0ge30sIGV2ZW50cyA9IHt9IH0pID0+IHtcbiAgY29uc3QgcG9wdWxhdGUgPSBhc3luYyAoaXRlbSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJwb3B1bGF0ZVwiLCB7IGl0ZW0gfSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWdncmVnYXRlcykge1xuICAgICAgYXdhaXQgcG9wdWxhdGVBZ2dyZWdhdGUoa2V5LCBpdGVtKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICBhd2FpdCBwb3B1bGF0ZUV2ZW50KGtleSwgaXRlbSk7XG4gICAgfVxuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJwb3B1bGF0ZSBkb25lXCIsIHsgaXRlbSB9KTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcbiAgY29uc3QgcG9wdWxhdGVBZ2dyZWdhdGUgPSBhc3luYyAoa2V5LCBpdGVtKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcInBvcHVsYXRlIGFnZ3JlZ2F0ZSBrZXlcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgY2FjaGVDb25maWcgPSB0b0NhY2hlQ29uZmlnKGFnZ3JlZ2F0ZXNba2V5XSk7XG4gICAgaWYgKGl0ZW0ucmVmcyA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoY2FjaGVDb25maWcub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ2dlcjI1LmVycm9yKFwiSXRlbSBkb2VzIG5vdCBoYXZlIHJlZnMgYW4gaXMgbm90IG9wdGlvbmFsIFwiLCB7IGl0ZW0gfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0ZW0gZG9lcyBub3QgaGF2ZSByZWZzIGFuIGlzIG5vdCBvcHRpb25hbCBcIiArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtLmV2ZW50cyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlbS5ldmVudHMsIGtleSkpIHtcbiAgICAgICAgICBkZWxldGUgaXRlbS5ldmVudHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbS5yZWZzW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGNhY2hlQ29uZmlnLm9wdGlvbmFsID09PSBmYWxzZSkge1xuICAgICAgICBsb2dnZXIyNS5lcnJvcihcIkl0ZW0gZG9lcyBub3QgaGF2ZSBtYW5kYXRvcnkgcmVmIHdpdGgga2V5LCBub3Qgb3B0aW9uYWwgXCIsIHsga2V5LCBpdGVtIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdGVtIGRvZXMgbm90IGhhdmUgbWFuZGF0b3J5IHJlZiB3aXRoIGtleSwgbm90IG9wdGlvbmFsIFwiICsga2V5ICsgXCIgXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbS5ldmVudHMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZW0uZXZlbnRzLCBrZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIGl0ZW0uZXZlbnRzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVmID0gaXRlbS5yZWZzW2tleV07XG4gICAgICBsb2dnZXIyNS5kZWZhdWx0KFwiQUdHIFJldHJpZXZpbmcgSXRlbSBpbiBQb3B1bGF0ZVwiLCB7IGtleTogcmVmIH0pO1xuICAgICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNhY2hlQ29uZmlnLmNhY2hlLm9wZXJhdGlvbnMucmV0cmlldmUocmVmKTtcbiAgICAgIGlmIChuZXdJdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLmFnZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGl0ZW0uYWdncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0uYWdnc1trZXldID0ge1xuICAgICAgICAgIGtleTogcmVmLFxuICAgICAgICAgIGl0ZW06IG5ld0l0ZW1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHBvcHVsYXRlRXZlbnQgPSBhc3luYyAoa2V5LCBpdGVtKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcInBvcHVsYXRlIGV2ZW50IGtleVwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBjYWNoZUNvbmZpZyA9IHRvQ2FjaGVDb25maWcoZXZlbnRzW2tleV0pO1xuICAgIGlmIChpdGVtLmV2ZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdGVtIGRvZXMgbm90IGhhdmUgZXZlbnRzIFwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICAgIH0gZWxzZSBpZiAoaXRlbS5ldmVudHNba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoY2FjaGVDb25maWcub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ2dlcjI1LmVycm9yKFwiSXRlbSBkb2VzIG5vdCBoYXZlIG1hbmRhdG9yeSBldmVudCB3aXRoIGtleVwiLCB7IGtleSwgaXRlbSB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXRlbSBkb2VzIG5vdCBoYXZlIG1hbmRhdG9yeSBldmVudCB3aXRoIGtleSBcIiArIGtleSArIFwiIFwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBldmVudCA9IGl0ZW0uZXZlbnRzW2tleV07XG4gICAgICBpZiAoZXZlbnQuYnkgPT09IHZvaWQgMCkge1xuICAgICAgICBsb2dnZXIyNS5lcnJvcihcbiAgICAgICAgICBcInBvcHVsYXRlRXZlbnQgd2l0aCBhbiBFdmVudCB0aGF0IGRvZXMgbm90IGhhdmUgYnlcIixcbiAgICAgICAgICB7IGV2ZW50LCBpazogaXRlbS5rZXksIGV2ZW50S2V5OiBrZXkgfVxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3B1bGF0ZUV2ZW50IHdpdGggYW4gRXZlbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGJ5OiBcIiArIEpTT04uc3RyaW5naWZ5KHsga2V5IH0pKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJFVkVOVCBSZXRyaWV2aW5nIEl0ZW0gaW4gUG9wdWxhdGVcIiwgeyBrZXk6IGV2ZW50LmJ5IH0pO1xuICAgICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNhY2hlQ29uZmlnLmNhY2hlLm9wZXJhdGlvbnMucmV0cmlldmUoZXZlbnQuYnkpO1xuICAgICAgaWYgKG5ld0l0ZW0pIHtcbiAgICAgICAgZXZlbnQuYWdnID0gbmV3SXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IGFsbDIgPSBhc3luYyAocXVlcnkgPSB7fSwgbG9jYXRpb25zID0gW10pID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwiYWxsXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWxsKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtKSA9PiBwb3B1bGF0ZShpdGVtKSkpO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtcztcbiAgfTtcbiAgY29uc3Qgb25lMiA9IGFzeW5jIChxdWVyeSA9IHt9LCBsb2NhdGlvbnMgPSBbXSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJvbmVcIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLm9uZShxdWVyeSwgbG9jYXRpb25zKTtcbiAgICBsZXQgcG9wdWxhdGVkSXRlbSA9IG51bGw7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH07XG4gIGNvbnN0IGFjdGlvbjIgPSBhc3luYyAoa2V5LCBhY3Rpb24zLCBib2R5ID0ge30pID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwiYWN0aW9uXCIsIHsga2V5LCBhY3Rpb246IGFjdGlvbjMsIGJvZHkgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWN0aW9uKGtleSwgYWN0aW9uMywgYm9keSk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9O1xuICBjb25zdCBhbGxBY3Rpb24yID0gYXN5bmMgKGFjdGlvbjMsIGJvZHkgPSB7fSwgbG9jYXRpb25zID0gW10pID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwiYWN0aW9uXCIsIHsgYWN0aW9uOiBhY3Rpb24zLCBib2R5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmFsbEFjdGlvbihhY3Rpb24zLCBib2R5LCBsb2NhdGlvbnMpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtKSA9PiBwb3B1bGF0ZShpdGVtKSkpO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtcztcbiAgfTtcbiAgY29uc3QgYWxsRmFjZXQyID0gYXN5bmMgKGZhY2V0MywgcGFyYW1zID0ge30sIGxvY2F0aW9ucyA9IFtdKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcImFsbEZhY2V0XCIsIHsgZmFjZXQ6IGZhY2V0MywgcGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmFsbEZhY2V0KGZhY2V0MywgcGFyYW1zLCBsb2NhdGlvbnMpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlMiA9IGFzeW5jICh2LCBsb2NhdGlvbnMgPSBbXSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJjcmVhdGVcIiwgeyB2LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuY3JlYXRlKHYsIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9O1xuICBjb25zdCBnZXQyID0gYXN5bmMgKGtleSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZ2V0KGtleSk7XG4gICAgbGV0IHBvcHVsYXRlZEl0ZW0gPSBudWxsO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9O1xuICBjb25zdCByZXRyaWV2ZTIgPSBhc3luYyAoa2V5KSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcInJldHJpZXZlXCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJldHJpZXZlKGtleSk7XG4gICAgbGV0IHBvcHVsYXRlZEl0ZW0gPSBudWxsO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9O1xuICBjb25zdCByZW1vdmUyID0gYXN5bmMgKGtleSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJyZW1vdmVcIiwgeyBrZXkgfSk7XG4gICAgYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5yZW1vdmUoa2V5KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlMiA9IGFzeW5jIChrZXksIHYpID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwidXBkYXRlXCIsIHsga2V5LCB2IH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnVwZGF0ZShrZXksIHYpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfTtcbiAgY29uc3QgZmFjZXQyID0gYXN5bmMgKGtleSwgZmFjZXQzKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcImZhY2V0XCIsIHsga2V5LCBmYWNldDogZmFjZXQzIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5mYWNldChrZXksIGZhY2V0Myk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuICBjb25zdCBmaW5kMiA9IGFzeW5jIChmaW5kZXIsIGZpbmRlclBhcmFtcyA9IHt9LCBsb2NhdGlvbnMgPSBbXSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJmaW5kXCIsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZmluZChmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zKTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbSkgPT4gcG9wdWxhdGUoaXRlbSkpKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbXM7XG4gIH07XG4gIGNvbnN0IGZpbmRPbmUyID0gYXN5bmMgKGZpbmRlciwgZmluZGVyUGFyYW1zID0ge30sIGxvY2F0aW9ucyA9IFtdKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcImZpbmRcIiwgeyBmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmZpbmRPbmUoZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9O1xuICBjb25zdCBzZXQyID0gYXN5bmMgKGtleSwgdikgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJzZXRcIiwgeyBrZXksIHYgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuc2V0KGtleSwgdik7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9O1xuICBjb25zdCByZXNldDIgPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5yZXNldCgpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIC8vIENhY2hlIHByb3BlcnRpZXNcbiAgICBjb29yZGluYXRlOiBjYWNoZS5jb29yZGluYXRlLFxuICAgIHJlZ2lzdHJ5OiBjYWNoZS5yZWdpc3RyeSxcbiAgICBhcGk6IGNhY2hlLmFwaSxcbiAgICBjYWNoZU1hcDogY2FjaGUuY2FjaGVNYXAsXG4gICAgb3BlcmF0aW9uczogY2FjaGUub3BlcmF0aW9ucyxcbiAgICBldmljdGlvbk1hbmFnZXI6IGNhY2hlLmV2aWN0aW9uTWFuYWdlcixcbiAgICB0dGxNYW5hZ2VyOiBjYWNoZS50dGxNYW5hZ2VyLFxuICAgIHN0YXRzTWFuYWdlcjogY2FjaGUuc3RhdHNNYW5hZ2VyLFxuICAgIGdldFN0YXRzOiBjYWNoZS5nZXRTdGF0cy5iaW5kKGNhY2hlKSxcbiAgICBnZXRDYWNoZUluZm86IGNhY2hlLmdldENhY2hlSW5mby5iaW5kKGNhY2hlKSxcbiAgICAvLyBDYWNoZSBvcGVyYXRpb25zIGV4cG9zZWQgZGlyZWN0bHlcbiAgICBhbGw6IGFsbDIsXG4gICAgb25lOiBvbmUyLFxuICAgIGFjdGlvbjogYWN0aW9uMixcbiAgICBhbGxBY3Rpb246IGFsbEFjdGlvbjIsXG4gICAgYWxsRmFjZXQ6IGFsbEZhY2V0MixcbiAgICBjcmVhdGU6IGNyZWF0ZTIsXG4gICAgZ2V0OiBnZXQyLFxuICAgIHJldHJpZXZlOiByZXRyaWV2ZTIsXG4gICAgcmVtb3ZlOiByZW1vdmUyLFxuICAgIHVwZGF0ZTogdXBkYXRlMixcbiAgICBmYWNldDogZmFjZXQyLFxuICAgIGZpbmQ6IGZpbmQyLFxuICAgIGZpbmRPbmU6IGZpbmRPbmUyLFxuICAgIHJlc2V0OiByZXNldDIsXG4gICAgc2V0OiBzZXQyLFxuICAgIC8vIEFnZ3JlZ2F0b3Itc3BlY2lmaWMgb3BlcmF0aW9uc1xuICAgIHBvcHVsYXRlLFxuICAgIHBvcHVsYXRlQWdncmVnYXRlLFxuICAgIHBvcHVsYXRlRXZlbnQsXG4gICAgLy8gRXZlbnQgc3lzdGVtXG4gICAgZXZlbnRFbWl0dGVyOiBjYWNoZS5ldmVudEVtaXR0ZXIsXG4gICAgc3Vic2NyaWJlOiAobGlzdGVuZXIsIG9wdGlvbnMpID0+IGNhY2hlLnN1YnNjcmliZShsaXN0ZW5lciwgb3B0aW9ucyksXG4gICAgdW5zdWJzY3JpYmU6IChzdWJzY3JpcHRpb24pID0+IGNhY2hlLnVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbiksXG4gICAgZGVzdHJveTogKCkgPT4gY2FjaGUuZGVzdHJveSgpXG4gIH07XG59O1xuXG4vLyBzcmMvUmVnaXN0cnkudHNcbmltcG9ydCB7XG4gIGNyZWF0ZVJlZ2lzdHJ5IGFzIGNyZWF0ZUJhc2VSZWdpc3RyeVxufSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG52YXIgbG9nZ2VyMjYgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJSZWdpc3RyeVwiKTtcbnZhciBjcmVhdGVSZWdpc3RyeUZhY3RvcnkgPSAoKSA9PiB7XG4gIHJldHVybiAodHlwZSwgcmVnaXN0cnlIdWIpID0+IHtcbiAgICBpZiAodHlwZSAhPT0gXCJjYWNoZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhY2hlIHJlZ2lzdHJ5IGZhY3RvcnkgY2FuIG9ubHkgY3JlYXRlICdjYWNoZScgdHlwZSByZWdpc3RyaWVzLCBnb3Q6ICR7dHlwZX1gKTtcbiAgICB9XG4gICAgbG9nZ2VyMjYuZGVidWcoXCJDcmVhdGluZyBjYWNoZSByZWdpc3RyeVwiLCB7IHR5cGUsIHJlZ2lzdHJ5SHViIH0pO1xuICAgIGNvbnN0IGJhc2VSZWdpc3RyeSA9IGNyZWF0ZUJhc2VSZWdpc3RyeSh0eXBlLCByZWdpc3RyeUh1Yik7XG4gICAgcmV0dXJuIGJhc2VSZWdpc3RyeTtcbiAgfTtcbn07XG52YXIgY3JlYXRlUmVnaXN0cnkgPSAocmVnaXN0cnlIdWIpID0+IHtcbiAgY29uc3QgYmFzZVJlZ2lzdHJ5ID0gY3JlYXRlQmFzZVJlZ2lzdHJ5KFwiY2FjaGVcIiwgcmVnaXN0cnlIdWIpO1xuICByZXR1cm4ge1xuICAgIC4uLmJhc2VSZWdpc3RyeVxuICB9O1xufTtcbmV4cG9ydCB7XG4gIEFzeW5jSW5kZXhEQkNhY2hlTWFwLFxuICBDYWNoZUV2ZW50RW1pdHRlcixcbiAgQ2FjaGVFdmVudEZhY3RvcnksXG4gIENhY2hlTWFwLFxuICBDYWNoZVN0YXRzTWFuYWdlcixcbiAgRW5oYW5jZWRNZW1vcnlDYWNoZU1hcCxcbiAgRXZpY3Rpb25NYW5hZ2VyLFxuICBJbmRleERCQ2FjaGVNYXAsXG4gIExvY2FsU3RvcmFnZUNhY2hlTWFwLFxuICBNZW1vcnlDYWNoZU1hcCxcbiAgU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcCxcbiAgVFRMTWFuYWdlcixcbiAgY3JlYXRlQWdncmVnYXRvcixcbiAgY3JlYXRlQ2FjaGUsXG4gIGNyZWF0ZUNhY2hlTWFwLFxuICBjcmVhdGVFdmljdGlvblN0cmF0ZWd5LFxuICBjcmVhdGVJbnN0YW5jZSxcbiAgY3JlYXRlSW5zdGFuY2VGYWN0b3J5LFxuICBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uLFxuICBjcmVhdGVPcGVyYXRpb25zLFxuICBjcmVhdGVPcHRpb25zLFxuICBjcmVhdGVSZWdpc3RyeSxcbiAgY3JlYXRlUmVnaXN0cnlGYWN0b3J5LFxuICBjcmVhdGVWYWxpZGF0ZWRDb25maWcsXG4gIGVzdGltYXRlVmFsdWVTaXplLFxuICBmb3JtYXRCeXRlcyxcbiAgaXNDYWNoZSxcbiAgaXNJbnN0YW5jZSxcbiAgaXNMb2NLZXlBcnJheUVxdWFsLFxuICBub3JtYWxpemVLZXlWYWx1ZSxcbiAgbm9ybWFsaXplTG9jS2V5SXRlbSxcbiAgcGFyc2VTaXplU3RyaW5nLFxuICB0b0NhY2hlQ29uZmlnLFxuICB2YWxpZGF0ZUFSQ0NvbmZpZyxcbiAgdmFsaWRhdGVFdmljdGlvblN0cmF0ZWd5Q29uZmlnLFxuICB2YWxpZGF0ZUxGVUNvbmZpZyxcbiAgdmFsaWRhdGVPcHRpb25zLFxuICB2YWxpZGF0ZVNpemVDb25maWcsXG4gIHZhbGlkYXRlVHdvUXVldWVDb25maWdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../fjell-providers/node_modules/@fjell/cache/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-providers/node_modules/@fjell/core/dist/index.js":
/*!*****************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/core/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItemService: () => (/* binding */ AItemService),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   IFactory: () => (/* binding */ IFactory),\n/* harmony export */   IQFactory: () => (/* binding */ IQFactory),\n/* harmony export */   abbrevAgg: () => (/* binding */ abbrevAgg),\n/* harmony export */   abbrevCompoundCondition: () => (/* binding */ abbrevCompoundCondition),\n/* harmony export */   abbrevCondition: () => (/* binding */ abbrevCondition),\n/* harmony export */   abbrevIK: () => (/* binding */ abbrevIK),\n/* harmony export */   abbrevLKA: () => (/* binding */ abbrevLKA),\n/* harmony export */   abbrevQuery: () => (/* binding */ abbrevQuery),\n/* harmony export */   abbrevRef: () => (/* binding */ abbrevRef),\n/* harmony export */   cPK: () => (/* binding */ cPK),\n/* harmony export */   constructPriKey: () => (/* binding */ constructPriKey),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   generateKeyArray: () => (/* binding */ generateKeyArray),\n/* harmony export */   ikToLKA: () => (/* binding */ ikToLKA),\n/* harmony export */   isComItem: () => (/* binding */ isComItem),\n/* harmony export */   isComKey: () => (/* binding */ isComKey),\n/* harmony export */   isComKeyEqual: () => (/* binding */ isComKeyEqual),\n/* harmony export */   isComKeyEqualNormalized: () => (/* binding */ isComKeyEqualNormalized),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isItemKey: () => (/* binding */ isItemKey),\n/* harmony export */   isItemKeyEqual: () => (/* binding */ isItemKeyEqual),\n/* harmony export */   isItemKeyEqualNormalized: () => (/* binding */ isItemKeyEqualNormalized),\n/* harmony export */   isLocKey: () => (/* binding */ isLocKey),\n/* harmony export */   isLocKeyEqual: () => (/* binding */ isLocKeyEqual),\n/* harmony export */   isLocKeyEqualNormalized: () => (/* binding */ isLocKeyEqualNormalized),\n/* harmony export */   isPriItem: () => (/* binding */ isPriItem),\n/* harmony export */   isPriKey: () => (/* binding */ isPriKey),\n/* harmony export */   isPriKeyEqual: () => (/* binding */ isPriKeyEqual),\n/* harmony export */   isPriKeyEqualNormalized: () => (/* binding */ isPriKeyEqualNormalized),\n/* harmony export */   isQueryMatch: () => (/* binding */ isQueryMatch),\n/* harmony export */   isValidComKey: () => (/* binding */ isValidComKey),\n/* harmony export */   isValidItemKey: () => (/* binding */ isValidItemKey),\n/* harmony export */   isValidLocKey: () => (/* binding */ isValidLocKey),\n/* harmony export */   isValidLocKeyArray: () => (/* binding */ isValidLocKeyArray),\n/* harmony export */   isValidPriKey: () => (/* binding */ isValidPriKey),\n/* harmony export */   itemKeyToLocKeyArray: () => (/* binding */ itemKeyToLocKeyArray),\n/* harmony export */   lkaToIK: () => (/* binding */ lkaToIK),\n/* harmony export */   locKeyArrayToItemKey: () => (/* binding */ locKeyArrayToItemKey),\n/* harmony export */   paramsToQuery: () => (/* binding */ paramsToQuery),\n/* harmony export */   primaryType: () => (/* binding */ primaryType),\n/* harmony export */   queryToParams: () => (/* binding */ queryToParams),\n/* harmony export */   toKeyTypeArray: () => (/* binding */ toKeyTypeArray),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys),\n/* harmony export */   validatePK: () => (/* binding */ validatePK)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../fjell-providers/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! luxon */ \"(ssr)/../fjell-providers/node_modules/luxon/src/luxon.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/core\");\nvar logger_default = LibLogger;\n\n// src/dictionary.ts\nvar logger = logger_default.get(\"Dictionary\");\nvar Dictionary = class _Dictionary {\n  map = {};\n  hashFunction = (key) => JSON.stringify(key);\n  constructor(map, hashFunction) {\n    if (hashFunction) {\n      this.hashFunction = hashFunction;\n    }\n    if (map) {\n      Object.entries(map).forEach(([hashedKey, value]) => {\n        try {\n          const originalKey = JSON.parse(hashedKey);\n          this.map[hashedKey] = { originalKey, value };\n        } catch {\n          logger.warning(\"Cannot recover original key from legacy map entry\", { hashedKey });\n        }\n      });\n    }\n  }\n  set(key, item) {\n    logger.trace(\"set\", { key, item });\n    const hashedKey = this.hashFunction(key);\n    this.map[hashedKey] = { originalKey: key, value: item };\n  }\n  get(key) {\n    logger.trace(\"get\", { key });\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry && this.keysEqual(entry.originalKey, key) ? entry.value : null;\n  }\n  keysEqual(key1, key2) {\n    return key1 === key2;\n  }\n  delete(key) {\n    logger.trace(\"delete\", { key });\n    const hashedKey = this.hashFunction(key);\n    delete this.map[hashedKey];\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  includesKey(key) {\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry ? this.keysEqual(entry.originalKey, key) : false;\n  }\n  clone() {\n    const clonedMap = {};\n    Object.entries(this.map).forEach(([hashedKey, entry]) => {\n      clonedMap[hashedKey] = entry.value;\n    });\n    const clone = new _Dictionary(clonedMap, this.hashFunction);\n    clone.map = Object.assign({}, this.map);\n    return clone;\n  }\n};\n\n// src/item/IFactory.ts\n\n\n// src/key/KUtils.ts\nvar logger2 = logger_default.get(\"KUtils\");\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && (normalizedKey.pk !== void 0 && normalizedKey.pk !== null)) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && (normalizedKey.lk !== void 0 && normalizedKey.lk !== null)) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && (locItem.lk !== void 0 && locItem.lk !== null)) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return JSON.stringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isPriKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isPriKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.pk) === normalizeKeyValue(b.pk) && a.kt === b.kt;\n};\nvar isLocKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isLocKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.lk) === normalizeKeyValue(b.lk) && a.kt === b.kt;\n};\nvar isComKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isComKeyEqualNormalized\", { a, b });\n  if (a && b && isPriKeyEqualNormalized({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqualNormalized(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isItemKeyEqualNormalized\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqualNormalized(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqualNormalized(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqual = (a, b) => {\n  logger2.trace(\"isKeyEqual\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqual(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqual(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isPriKeyEqual = (a, b) => {\n  logger2.trace(\"isPriKeyEqual\", { a, b });\n  return a && b && a.pk === b.pk && a.kt === b.kt;\n};\nvar isLocKeyEqual = (a, b) => {\n  logger2.trace(\"isLocKeyEqual\", { a, b });\n  return a && b && a.lk === b.lk && a.kt === b.kt;\n};\nvar isComKeyEqual = (a, b) => {\n  logger2.trace(\"isComKeyEqual\", { a, b });\n  if (a && b && isPriKeyEqual({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqual(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKey = (key) => {\n  logger2.trace(\"isItemKey\", { key });\n  return key !== void 0 && (isComKey(key) || isPriKey(key));\n};\nvar isComKey = (key) => {\n  logger2.trace(\"isComKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc !== void 0 && key.loc.length > 0);\n};\nvar isPriKey = (key) => {\n  logger2.trace(\"isPriKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc === void 0 || key.loc.length === 0);\n};\nvar isLocKey = (key) => {\n  logger2.trace(\"isLocKey\", { key });\n  return key !== void 0 && (key.lk !== void 0 && key.kt !== void 0);\n};\nvar generateKeyArray = (key) => {\n  logger2.trace(\"generateKeyArray\", { key });\n  const keys = [];\n  if (isComKey(key) || isPriKey(key)) {\n    if (isComKey(key)) {\n      const comKey = key;\n      keys.push({ pk: comKey.pk, kt: comKey.kt });\n      for (let i = 0; i < comKey.loc.length; i++) {\n        keys.push(comKey.loc[i]);\n      }\n    } else {\n      keys.push(key);\n    }\n  } else {\n    const locKeys = key;\n    for (let i = 0; i < locKeys.length; i++) {\n      keys.push(locKeys[i]);\n    }\n  }\n  return keys;\n};\nvar constructPriKey = (pk, kt) => {\n  logger2.trace(\"constructPriKey\", { pk, kt });\n  let pri;\n  if (typeof pk === \"string\" || typeof pk === \"number\") {\n    pri = { kt, pk };\n  } else {\n    pri = pk;\n  }\n  return pri;\n};\nvar cPK = constructPriKey;\nvar toKeyTypeArray = (ik) => {\n  logger2.trace(\"toKeyTypeArray\", { ik });\n  if (isComKey(ik)) {\n    const ck = ik;\n    return [ck.kt, ...ck.loc.map((l) => l.kt)];\n  } else {\n    return [ik.kt];\n  }\n};\nvar abbrevIK = (ik) => {\n  logger2.trace(\"abbrevIK\", { ik });\n  if (ik) {\n    if (isComKey(ik)) {\n      const ck = ik;\n      return `${ck.kt}:${ck.pk}:${ck.loc.map((l) => `${l.kt}:${l.lk}`).join(\",\")}`;\n    } else {\n      return `${ik.kt}:${ik.pk}`;\n    }\n  } else {\n    return \"null IK\";\n  }\n};\nvar abbrevLKA = (keyArray) => {\n  logger2.trace(\"abbrevLKA\", { keyArray });\n  if (keyArray === void 0 || keyArray === null) {\n    return \"null LKA\";\n  } else {\n    return keyArray.map((key) => {\n      if (key) {\n        return `${key.kt}:${key.lk}`;\n      } else {\n        return key;\n      }\n    }).join(\",\");\n  }\n};\nvar primaryType = (ik) => {\n  logger2.trace(\"primaryType\", { ik });\n  if (isComKey(ik)) {\n    return ik.kt;\n  } else {\n    return ik.kt;\n  }\n};\nvar itemKeyToLocKeyArray = (ik) => {\n  logger2.trace(\"itemKeyToLocKeyArray\", { ik: abbrevIK(ik) });\n  let lka = [];\n  if (isComKey(ik)) {\n    const ck = ik;\n    lka = [{ kt: ck.kt, lk: ck.pk }, ...ck.loc];\n  } else {\n    const pk = ik;\n    lka = [{ kt: pk.kt, lk: pk.pk }];\n  }\n  logger2.trace(\"itemKeyToLocKeyArray Results\", { ik: abbrevIK(ik), lka: abbrevLKA(lka) });\n  return lka;\n};\nvar ikToLKA = itemKeyToLocKeyArray;\nvar locKeyArrayToItemKey = (lka) => {\n  logger2.trace(\"locKeyArrayToItemKey\", { lka: abbrevLKA(lka) });\n  if (lka && lka.length === 1) {\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    return priKey;\n  } else if (lka && lka.length > 1 && lka[0] !== void 0) {\n    const locs = lka.slice(1);\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    const comKey = { kt: priKey.kt, pk: priKey.pk, loc: locs };\n    return comKey;\n  } else {\n    throw new Error(\"locKeyArrayToItemKey: lka is undefined or empty\");\n  }\n};\nvar isValidPriKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.pk !== void 0 && key.pk !== null && key.pk !== \"\" && key.pk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.lk !== void 0 && key.lk !== null && key.lk !== \"\" && key.lk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKeyArray = (keyArray) => {\n  return keyArray !== void 0 && keyArray !== null && keyArray.every(isValidLocKey);\n};\nvar isValidComKey = (key) => {\n  return key !== void 0 && key !== null && isValidPriKey(key) && isValidLocKeyArray(key.loc);\n};\nvar isValidItemKey = (key) => {\n  return isComKey(key) && isValidComKey(key) || isPriKey(key) && isValidPriKey(key);\n};\nvar lkaToIK = locKeyArrayToItemKey;\n\n// src/item/IFactory.ts\nvar IFactory = class _IFactory {\n  item = {};\n  constructor(props = {}) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n  }\n  addRef(i, name) {\n    const ik = i.key;\n    const refName = name || primaryType(ik);\n    if (!this.item.refs) {\n      this.item.refs = {};\n    }\n    this.item.refs[refName] = ik;\n    return this;\n  }\n  static addRef(i, name) {\n    return new _IFactory().addRef(i, name);\n  }\n  addDefaultEvents() {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    const now = /* @__PURE__ */ new Date();\n    if (!this.item.events.created) {\n      this.item.events.created = { at: now };\n    }\n    if (!this.item.events.updated) {\n      this.item.events.updated = { at: now };\n    }\n    if (!this.item.events.deleted) {\n      this.item.events.deleted = { at: null };\n    }\n    return this;\n  }\n  addEvent(name, at, by) {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    this.item.events[name] = { at, by };\n    return this;\n  }\n  static addEvent(name, at, by) {\n    return new _IFactory().addEvent(name, at, by);\n  }\n  addProp(name, value) {\n    this.item[name] = value;\n    return this;\n  }\n  static addProp(name, value) {\n    return new _IFactory().addProp(name, value);\n  }\n  addProps(props) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n    return this;\n  }\n  static addProps(props) {\n    return new _IFactory().addProps(props);\n  }\n  toItem() {\n    return this.item;\n  }\n};\n\n// src/AItemService.ts\nvar AItemService = class {\n  pkType;\n  parentService = null;\n  constructor(pkType, parentService) {\n    this.pkType = pkType;\n    if (parentService) {\n      this.parentService = parentService;\n    }\n  }\n  getPkType = () => {\n    return this.pkType;\n  };\n  getKeyTypes = () => {\n    let keyTypes = [this.getPkType()];\n    if (this.parentService) {\n      keyTypes = keyTypes.concat(this.parentService.getKeyTypes());\n    }\n    return keyTypes;\n  };\n};\n\n// src/item/ItemQuery.ts\nvar isCondition = (condition) => {\n  return (typeof condition.column === \"string\" && (Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"string\")) || Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"number\") || typeof condition.value === \"string\" || typeof condition.value === \"number\" || typeof condition.value === \"boolean\" || condition.value instanceof Date) && (condition.operator ? typeof condition.operator === \"string\" : true);\n};\n\n// src/item/IQFactory.ts\nvar IQFactory = class _IQFactory {\n  query = {};\n  constructor(query = {}) {\n    this.query = query;\n  }\n  orderBy(field, direction = \"asc\") {\n    if (!this.query.orderBy) {\n      this.query.orderBy = [];\n    }\n    this.query.orderBy.push({ field, direction });\n    return this;\n  }\n  agg(name, query) {\n    if (!this.query.aggs) {\n      this.query.aggs = {};\n    }\n    this.query.aggs[name] = query;\n    return this;\n  }\n  event(name, query) {\n    if (!this.query.events) {\n      this.query.events = {};\n    }\n    this.query.events[name] = query;\n    return this;\n  }\n  conditions(conditions, compoundType = \"AND\") {\n    for (const condition of conditions) {\n      if (!isCondition(condition)) {\n        throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n      }\n    }\n    if (!this.query.compoundCondition) {\n      this.query.compoundCondition = {\n        compoundType,\n        conditions\n      };\n    } else {\n      const compoundCondition = {\n        compoundType,\n        conditions\n      };\n      this.query.compoundCondition.conditions.push(compoundCondition);\n    }\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  // TODO: right now, we're only supporting PK refs for queries.  Should add support for CKs\n  pk(kt, pk, name) {\n    if (!this.query.refs) {\n      this.query.refs = {};\n    }\n    const refName = name || kt;\n    this.query.refs[refName] = cPK(pk, kt);\n    return this;\n  }\n  condition(column, value, operator = \"==\") {\n    const condition = { column, value, operator };\n    if (isCondition(condition)) {\n      if (!this.query.compoundCondition) {\n        this.query.compoundCondition = {\n          compoundType: \"AND\",\n          conditions: []\n        };\n      }\n      this.query.compoundCondition.conditions.push(condition);\n      return this;\n    } else {\n      throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n    }\n  }\n  static all() {\n    const iqFactory = new _IQFactory();\n    return iqFactory;\n  }\n  static orderBy(field, direction = \"asc\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.orderBy(field, direction);\n  }\n  static agg(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.agg(name, query);\n  }\n  static event(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.event(name, query);\n  }\n  static limit(limit) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.limit(limit);\n  }\n  static offset(offset) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.offset(offset);\n  }\n  static pk(kt, pk, name) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.pk(kt, pk, name);\n  }\n  static condition(column, value, operator = \"==\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.condition(column, value, operator);\n  }\n  static conditions(conditions, compoundType = \"AND\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.conditions(conditions, compoundType);\n  }\n  toQuery() {\n    return this.query;\n  }\n};\n\n// src/item/IQUtils.ts\n\nvar logger3 = logger_default.get(\"IQUtils\");\nvar queryToParams = (query) => {\n  const params = {};\n  if (query.compoundCondition) {\n    params.compoundCondition = JSON.stringify(query.compoundCondition);\n  }\n  if (query.refs) {\n    params.refs = JSON.stringify(query.refs);\n  }\n  if (query.limit) {\n    params.limit = query.limit;\n  }\n  if (query.offset) {\n    params.offset = query.offset;\n  }\n  if (query.aggs) {\n    params.aggs = JSON.stringify(query.aggs);\n  }\n  if (query.events) {\n    params.events = JSON.stringify(query.events);\n  }\n  return params;\n};\nvar dateTimeReviver = function(key, value) {\n  if (typeof value === \"string\") {\n    const parsedDate = luxon__WEBPACK_IMPORTED_MODULE_2__.DateTime.fromISO(value);\n    if (parsedDate.isValid) {\n      return parsedDate.toJSDate();\n      ;\n    }\n  }\n  return value;\n};\nvar paramsToQuery = (params) => {\n  const query = {};\n  if (params.compoundCondition) {\n    query.compoundCondition = JSON.parse(params.compoundCondition);\n  }\n  if (params.refs) {\n    query.refs = JSON.parse(params.refs);\n  }\n  if (params.limit) {\n    query.limit = Number(params.limit);\n  }\n  if (params.offset) {\n    query.offset = Number(params.offset);\n  }\n  if (params.aggs) {\n    query.aggs = JSON.parse(params.aggs);\n  }\n  if (params.events) {\n    query.events = JSON.parse(params.events, dateTimeReviver);\n  }\n  return query;\n};\nvar isRefQueryMatch = (refKey, queryRef, references) => {\n  logger3.trace(\"doesRefMatch\", { queryRef, references });\n  logger3.debug(\"Comparing Ref\", { refKey, itemRef: references[refKey], queryRef });\n  return isItemKeyEqual(queryRef, references[refKey]);\n};\nvar isCompoundConditionQueryMatch = (queryCondition, item) => {\n  if (queryCondition.compoundType === \"AND\") {\n    return queryCondition.conditions.every(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  } else {\n    return queryCondition.conditions.some(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  }\n};\nvar isConditionQueryMatch = (queryCondition, item) => {\n  const propKey = queryCondition.column;\n  logger3.trace(\"doesConditionMatch\", { propKey, queryCondition, item });\n  if (item[propKey] === void 0) {\n    logger3.debug(\"Item does not contain prop under key\", { propKey, item });\n    return false;\n  }\n  logger3.debug(\"Comparing Condition\", { propKey, itemProp: item[propKey], queryCondition });\n  let result = false;\n  switch (queryCondition.operator) {\n    case \"==\":\n      result = item[propKey] === queryCondition.value;\n      break;\n    case \"!=\":\n      result = item[propKey] !== queryCondition.value;\n      break;\n    case \">\":\n      result = item[propKey] > queryCondition.value;\n      break;\n    case \">=\":\n      result = item[propKey] >= queryCondition.value;\n      break;\n    case \"<\":\n      result = item[propKey] < queryCondition.value;\n      break;\n    case \"<=\":\n      result = item[propKey] <= queryCondition.value;\n      break;\n    case \"in\":\n      result = queryCondition.value.includes(item[propKey]);\n      break;\n    case \"not-in\":\n      result = !queryCondition.value.includes(item[propKey]);\n      break;\n    case \"array-contains\":\n      result = item[propKey].includes(queryCondition.value);\n      break;\n    case \"array-contains-any\":\n      result = queryCondition.value.some((value) => item[propKey].includes(value));\n      break;\n  }\n  return result;\n};\nvar isAggQueryMatch = (aggKey, aggQuery, agg) => {\n  const aggItem = agg.item;\n  logger3.debug(\"Comparing Agg\", { aggKey, aggItem, aggQuery });\n  return isQueryMatch(aggItem, aggQuery);\n};\nvar isEventQueryMatch = (eventKey, eventQuery, item) => {\n  if (!item.events[eventKey]) {\n    logger3.debug(\"Item does not contain event under key\", { eventKey, events: item.events });\n    return false;\n  } else {\n    const itemEvent = item.events[eventKey];\n    if (itemEvent.at !== null) {\n      if (eventQuery.start && !(eventQuery.start.getTime() <= itemEvent.at.getTime())) {\n        logger3.debug(\"Item date before event start query\", { eventQuery, itemEvent });\n        return false;\n      }\n      if (eventQuery.end && !(eventQuery.end.getTime() > itemEvent.at.getTime())) {\n        logger3.debug(\"Item date after event end query\", { eventQuery, itemEvent });\n        return false;\n      }\n    } else {\n      logger3.debug(\"Item event does contains a null at\", { itemEvent });\n      return false;\n    }\n    return true;\n  }\n};\nvar isQueryMatch = (item, query) => {\n  logger3.trace(\"isMatch\", { item, query });\n  if (query.refs && item.refs) {\n    for (const key in query.refs) {\n      const queryRef = query.refs[key];\n      if (!isRefQueryMatch(key, queryRef, item.refs)) return false;\n    }\n  } else if (query.refs && !item.refs) {\n    logger3.debug(\"Query contains refs but item does not have refs\", { query, item });\n    return false;\n  }\n  if (query.compoundCondition && item) {\n    if (!isCompoundConditionQueryMatch(query.compoundCondition, item)) return false;\n  }\n  if (query.events && item.events) {\n    for (const key in query.events) {\n      const queryEvent = query.events[key];\n      if (!isEventQueryMatch(key, queryEvent, item)) return false;\n    }\n    return true;\n  }\n  if (query.aggs && item.aggs) {\n    for (const key in query.aggs) {\n      const aggQuery = query.aggs[key];\n      if (item.aggs[key] && !isAggQueryMatch(key, aggQuery, item.aggs[key])) return false;\n    }\n  }\n  if (query.aggs && !item.aggs) {\n    logger3.debug(\"Query contains aggs but item does not have aggs\", { query, item });\n    return false;\n  }\n  return true;\n};\nvar abbrevQuery = (query) => {\n  const abbrev = [\"IQ\"];\n  if (query) {\n    if (query.refs) {\n      for (const key in query.refs) {\n        const ref = abbrevRef(key, query.refs[key]);\n        abbrev.push(ref);\n      }\n    }\n    if (query.compoundCondition) {\n      const props = abbrevCompoundCondition(query.compoundCondition);\n      abbrev.push(props);\n    }\n    if (query.aggs) {\n      for (const key in query.aggs) {\n        const agg = abbrevAgg(key, query.aggs[key]);\n        abbrev.push(agg);\n      }\n    }\n    if (query.events) {\n      const events = `(E${Object.keys(query.events).join(\",\")})`;\n      abbrev.push(events);\n    }\n    if (query.limit) {\n      abbrev.push(`L${query.limit}`);\n    }\n    if (query.offset) {\n      abbrev.push(`O${query.offset}`);\n    }\n  } else {\n    abbrev.push(\"(empty)\");\n  }\n  return abbrev.join(\" \");\n};\nvar abbrevRef = (key, ref) => {\n  if (isPriKey(ref)) {\n    const priKey = ref;\n    return `R(${key},${priKey.kt},${priKey.pk})`;\n  } else {\n    const comKey = ref;\n    return `R(${key},${JSON.stringify(comKey)})`;\n  }\n};\nvar abbrevAgg = (key, agg) => {\n  return `A(${key},${abbrevQuery(agg)})`;\n};\nvar abbrevCompoundCondition = (compoundCondition) => {\n  return `CC(${compoundCondition.compoundType},${compoundCondition.conditions ? compoundCondition.conditions.map(abbrevCondition).join(\",\") : \"No Conditions\"})`;\n};\nvar abbrevCondition = (condition) => {\n  if (isCondition(condition)) {\n    return `(${condition.column},${condition.value},${condition.operator})`;\n  } else {\n    return abbrevCompoundCondition(condition);\n  }\n};\n\n// src/item/IUtils.ts\nvar logger4 = logger_default.get(\"IUtils\");\nvar validatePKForItem = (item, pkType) => {\n  if (!item) {\n    logger4.error(\"Validating PK, Item is undefined\", { item });\n    throw new Error(\"Validating PK, Item is undefined\");\n  }\n  if (!item.key) {\n    logger4.error(\"Validating PK, Item does not have a key\", { item });\n    throw new Error(\"Validating PK, Item does not have a key\");\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray[0] !== pkType) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, pkType });\n    throw new Error(`Item does not have the correct primary key type. Expected ${pkType}, got ${keyTypeArray[0]}`);\n  }\n  return item;\n};\nvar validatePK = (input, pkType) => {\n  logger4.trace(\"Checking Return Type\", { input });\n  if (Array.isArray(input)) {\n    return input.map((item) => validatePKForItem(item, pkType));\n  }\n  return validatePKForItem(input, pkType);\n};\nvar validateKeys = (item, keyTypes) => {\n  logger4.trace(\"Checking Return Type\", { item });\n  if (!item) {\n    throw new Error(\"validating keys, item is undefined\");\n  }\n  if (!item.key) {\n    throw new Error(\"validating keys, item does not have a key: \" + JSON.stringify(item));\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray.length !== keyTypes.length) {\n    throw new Error(`Item does not have the correct number of keys. Expected ${keyTypes.length}, but got ${keyTypeArray.length}`);\n  }\n  const match = JSON.stringify(keyTypeArray) === JSON.stringify(keyTypes);\n  if (!match) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, thisKeyTypes: keyTypes });\n    throw new Error(`Item does not have the correct key types. Expected [${keyTypes.join(\", \")}], but got [${keyTypeArray.join(\", \")}]`);\n  }\n  return item;\n};\nvar isPriItem = (item) => {\n  return !!(item && item.key && isPriKey(item.key));\n};\nvar isComItem = (item) => {\n  return !!(item && item.key && isComKey(item.key));\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9AZmplbGwvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNxQztBQUNyQyxnQkFBZ0IsZ0VBQWlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFVBQVU7QUFDVixnRkFBZ0YsV0FBVztBQUMzRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQsMENBQTBDLG9CQUFvQixJQUFJLG9CQUFvQjtBQUN0RjtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFD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QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQy9IO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzQ0FBc0M7QUFDckYsMkVBQTJFLG9CQUFvQixjQUFjLHdCQUF3QjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnREU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9jb3JlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xvZ2dlci50c1xuaW1wb3J0IExvZ2dpbmcgZnJvbSBcIkBmamVsbC9sb2dnaW5nXCI7XG52YXIgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoXCJAZmplbGwvY29yZVwiKTtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExpYkxvZ2dlcjtcblxuLy8gc3JjL2RpY3Rpb25hcnkudHNcbnZhciBsb2dnZXIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJEaWN0aW9uYXJ5XCIpO1xudmFyIERpY3Rpb25hcnkgPSBjbGFzcyBfRGljdGlvbmFyeSB7XG4gIG1hcCA9IHt9O1xuICBoYXNoRnVuY3Rpb24gPSAoa2V5KSA9PiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICBjb25zdHJ1Y3RvcihtYXAsIGhhc2hGdW5jdGlvbikge1xuICAgIGlmIChoYXNoRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuaGFzaEZ1bmN0aW9uID0gaGFzaEZ1bmN0aW9uO1xuICAgIH1cbiAgICBpZiAobWFwKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhtYXApLmZvckVhY2goKFtoYXNoZWRLZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsS2V5ID0gSlNPTi5wYXJzZShoYXNoZWRLZXkpO1xuICAgICAgICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7IG9yaWdpbmFsS2V5LCB2YWx1ZSB9O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBsb2dnZXIud2FybmluZyhcIkNhbm5vdCByZWNvdmVyIG9yaWdpbmFsIGtleSBmcm9tIGxlZ2FjeSBtYXAgZW50cnlcIiwgeyBoYXNoZWRLZXkgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzZXQoa2V5LCBpdGVtKSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwic2V0XCIsIHsga2V5LCBpdGVtIH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHsgb3JpZ2luYWxLZXk6IGtleSwgdmFsdWU6IGl0ZW0gfTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiZ2V0XCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiBlbnRyeSAmJiB0aGlzLmtleXNFcXVhbChlbnRyeS5vcmlnaW5hbEtleSwga2V5KSA/IGVudHJ5LnZhbHVlIDogbnVsbDtcbiAgfVxuICBrZXlzRXF1YWwoa2V5MSwga2V5Mikge1xuICAgIHJldHVybiBrZXkxID09PSBrZXkyO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICBsb2dnZXIudHJhY2UoXCJkZWxldGVcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBkZWxldGUgdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS5vcmlnaW5hbEtleSk7XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSk7XG4gIH1cbiAgaW5jbHVkZXNLZXkoa2V5KSB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgcmV0dXJuIGVudHJ5ID8gdGhpcy5rZXlzRXF1YWwoZW50cnkub3JpZ2luYWxLZXksIGtleSkgOiBmYWxzZTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZWRNYXAgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLm1hcCkuZm9yRWFjaCgoW2hhc2hlZEtleSwgZW50cnldKSA9PiB7XG4gICAgICBjbG9uZWRNYXBbaGFzaGVkS2V5XSA9IGVudHJ5LnZhbHVlO1xuICAgIH0pO1xuICAgIGNvbnN0IGNsb25lID0gbmV3IF9EaWN0aW9uYXJ5KGNsb25lZE1hcCwgdGhpcy5oYXNoRnVuY3Rpb24pO1xuICAgIGNsb25lLm1hcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWFwKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn07XG5cbi8vIHNyYy9pdGVtL0lGYWN0b3J5LnRzXG5pbXBvcnQgZGVlcG1lcmdlIGZyb20gXCJkZWVwbWVyZ2VcIjtcblxuLy8gc3JjL2tleS9LVXRpbHMudHNcbnZhciBsb2dnZXIyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiS1V0aWxzXCIpO1xudmFyIG5vcm1hbGl6ZUtleVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufTtcbnZhciBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gKCkgPT4ge1xuICByZXR1cm4gKGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG4gICAgICBpZiAoXCJwa1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgKG5vcm1hbGl6ZWRLZXkucGsgIT09IHZvaWQgMCAmJiBub3JtYWxpemVkS2V5LnBrICE9PSBudWxsKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LnBrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5wayk7XG4gICAgICB9XG4gICAgICBpZiAoXCJsa1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgKG5vcm1hbGl6ZWRLZXkubGsgIT09IHZvaWQgMCAmJiBub3JtYWxpemVkS2V5LmxrICE9PSBudWxsKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5sayk7XG4gICAgICB9XG4gICAgICBpZiAoXCJsb2NcIiBpbiBub3JtYWxpemVkS2V5ICYmIEFycmF5LmlzQXJyYXkobm9ybWFsaXplZEtleS5sb2MpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubG9jID0gbm9ybWFsaXplZEtleS5sb2MubWFwKChsb2NJdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGxvY0l0ZW0gJiYgXCJsa1wiIGluIGxvY0l0ZW0gJiYgKGxvY0l0ZW0ubGsgIT09IHZvaWQgMCAmJiBsb2NJdGVtLmxrICE9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubG9jSXRlbSwgbGs6IG5vcm1hbGl6ZUtleVZhbHVlKGxvY0l0ZW0ubGspIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NJdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIH07XG59O1xudmFyIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzUHJpS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBub3JtYWxpemVLZXlWYWx1ZShhLnBrKSA9PT0gbm9ybWFsaXplS2V5VmFsdWUoYi5waykgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIG5vcm1hbGl6ZUtleVZhbHVlKGEubGspID09PSBub3JtYWxpemVLZXlWYWx1ZShiLmxrKSAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0NvbUtleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0NvbUtleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIGlmIChhICYmIGIgJiYgaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQoeyBrdDogYS5rdCwgcGs6IGEucGsgfSwgeyBrdDogYi5rdCwgcGs6IGIucGsgfSkpIHtcbiAgICBpZiAoYS5sb2MubGVuZ3RoID09PSBiLmxvYy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0xvY0tleUVxdWFsTm9ybWFsaXplZChhLmxvY1tpXSwgYi5sb2NbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzSXRlbUtleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIGlmIChpc0NvbUtleShhKSAmJiBpc0NvbUtleShiKSkge1xuICAgIHJldHVybiBpc0NvbUtleUVxdWFsTm9ybWFsaXplZChhLCBiKTtcbiAgfSBlbHNlIGlmIChpc1ByaUtleShhKSAmJiBpc1ByaUtleShiKSkge1xuICAgIGlmIChpc0NvbUtleShhKSB8fCBpc0NvbUtleShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQoYSwgYik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0l0ZW1LZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0tleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGlzQ29tS2V5KGEpICYmIGlzQ29tS2V5KGIpKSB7XG4gICAgcmV0dXJuIGlzQ29tS2V5RXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoaXNQcmlLZXkoYSkgJiYgaXNQcmlLZXkoYikpIHtcbiAgICBpZiAoaXNDb21LZXkoYSkgfHwgaXNDb21LZXkoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlzUHJpS2V5RXF1YWwoYSwgYik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc1ByaUtleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzUHJpS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIGEucGsgPT09IGIucGsgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNMb2NLZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0xvY0tleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBhLmxrID09PSBiLmxrICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzQ29tS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNDb21LZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIGlmIChhICYmIGIgJiYgaXNQcmlLZXlFcXVhbCh7IGt0OiBhLmt0LCBwazogYS5wayB9LCB7IGt0OiBiLmt0LCBwazogYi5wayB9KSkge1xuICAgIGlmIChhLmxvYy5sZW5ndGggPT09IGIubG9jLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTG9jS2V5RXF1YWwoYS5sb2NbaV0sIGIubG9jW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzSXRlbUtleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzSXRlbUtleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChpc0NvbUtleShrZXkpIHx8IGlzUHJpS2V5KGtleSkpO1xufTtcbnZhciBpc0NvbUtleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzQ29tS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGtleS5wayAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gdm9pZCAwKSAmJiAoa2V5LmxvYyAhPT0gdm9pZCAwICYmIGtleS5sb2MubGVuZ3RoID4gMCk7XG59O1xudmFyIGlzUHJpS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNQcmlLZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoa2V5LnBrICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSB2b2lkIDApICYmIChrZXkubG9jID09PSB2b2lkIDAgfHwga2V5LmxvYy5sZW5ndGggPT09IDApO1xufTtcbnZhciBpc0xvY0tleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzTG9jS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGtleS5sayAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gdm9pZCAwKTtcbn07XG52YXIgZ2VuZXJhdGVLZXlBcnJheSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImdlbmVyYXRlS2V5QXJyYXlcIiwgeyBrZXkgfSk7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgaWYgKGlzQ29tS2V5KGtleSkgfHwgaXNQcmlLZXkoa2V5KSkge1xuICAgIGlmIChpc0NvbUtleShrZXkpKSB7XG4gICAgICBjb25zdCBjb21LZXkgPSBrZXk7XG4gICAgICBrZXlzLnB1c2goeyBwazogY29tS2V5LnBrLCBrdDogY29tS2V5Lmt0IH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21LZXkubG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleXMucHVzaChjb21LZXkubG9jW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxvY0tleXMgPSBrZXk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2gobG9jS2V5c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciBjb25zdHJ1Y3RQcmlLZXkgPSAocGssIGt0KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJjb25zdHJ1Y3RQcmlLZXlcIiwgeyBwaywga3QgfSk7XG4gIGxldCBwcmk7XG4gIGlmICh0eXBlb2YgcGsgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBrID09PSBcIm51bWJlclwiKSB7XG4gICAgcHJpID0geyBrdCwgcGsgfTtcbiAgfSBlbHNlIHtcbiAgICBwcmkgPSBwaztcbiAgfVxuICByZXR1cm4gcHJpO1xufTtcbnZhciBjUEsgPSBjb25zdHJ1Y3RQcmlLZXk7XG52YXIgdG9LZXlUeXBlQXJyYXkgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcInRvS2V5VHlwZUFycmF5XCIsIHsgaWsgfSk7XG4gIGlmIChpc0NvbUtleShpaykpIHtcbiAgICBjb25zdCBjayA9IGlrO1xuICAgIHJldHVybiBbY2sua3QsIC4uLmNrLmxvYy5tYXAoKGwpID0+IGwua3QpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2lrLmt0XTtcbiAgfVxufTtcbnZhciBhYmJyZXZJSyA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiYWJicmV2SUtcIiwgeyBpayB9KTtcbiAgaWYgKGlrKSB7XG4gICAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgICAgY29uc3QgY2sgPSBpaztcbiAgICAgIHJldHVybiBgJHtjay5rdH06JHtjay5wa306JHtjay5sb2MubWFwKChsKSA9PiBgJHtsLmt0fToke2wubGt9YCkuam9pbihcIixcIil9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke2lrLmt0fToke2lrLnBrfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm51bGwgSUtcIjtcbiAgfVxufTtcbnZhciBhYmJyZXZMS0EgPSAoa2V5QXJyYXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImFiYnJldkxLQVwiLCB7IGtleUFycmF5IH0pO1xuICBpZiAoa2V5QXJyYXkgPT09IHZvaWQgMCB8fCBrZXlBcnJheSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGwgTEtBXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUFycmF5Lm1hcCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBgJHtrZXkua3R9OiR7a2V5LmxrfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgIH0pLmpvaW4oXCIsXCIpO1xuICB9XG59O1xudmFyIHByaW1hcnlUeXBlID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJwcmltYXJ5VHlwZVwiLCB7IGlrIH0pO1xuICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgcmV0dXJuIGlrLmt0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpay5rdDtcbiAgfVxufTtcbnZhciBpdGVtS2V5VG9Mb2NLZXlBcnJheSA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXRlbUtleVRvTG9jS2V5QXJyYXlcIiwgeyBpazogYWJicmV2SUsoaWspIH0pO1xuICBsZXQgbGthID0gW107XG4gIGlmIChpc0NvbUtleShpaykpIHtcbiAgICBjb25zdCBjayA9IGlrO1xuICAgIGxrYSA9IFt7IGt0OiBjay5rdCwgbGs6IGNrLnBrIH0sIC4uLmNrLmxvY107XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcGsgPSBpaztcbiAgICBsa2EgPSBbeyBrdDogcGsua3QsIGxrOiBway5wayB9XTtcbiAgfVxuICBsb2dnZXIyLnRyYWNlKFwiaXRlbUtleVRvTG9jS2V5QXJyYXkgUmVzdWx0c1wiLCB7IGlrOiBhYmJyZXZJSyhpayksIGxrYTogYWJicmV2TEtBKGxrYSkgfSk7XG4gIHJldHVybiBsa2E7XG59O1xudmFyIGlrVG9MS0EgPSBpdGVtS2V5VG9Mb2NLZXlBcnJheTtcbnZhciBsb2NLZXlBcnJheVRvSXRlbUtleSA9IChsa2EpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImxvY0tleUFycmF5VG9JdGVtS2V5XCIsIHsgbGthOiBhYmJyZXZMS0EobGthKSB9KTtcbiAgaWYgKGxrYSAmJiBsa2EubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgcHJpS2V5ID0gY1BLKGxrYVswXS5saywgbGthWzBdLmt0KTtcbiAgICByZXR1cm4gcHJpS2V5O1xuICB9IGVsc2UgaWYgKGxrYSAmJiBsa2EubGVuZ3RoID4gMSAmJiBsa2FbMF0gIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGxvY3MgPSBsa2Euc2xpY2UoMSk7XG4gICAgY29uc3QgcHJpS2V5ID0gY1BLKGxrYVswXS5saywgbGthWzBdLmt0KTtcbiAgICBjb25zdCBjb21LZXkgPSB7IGt0OiBwcmlLZXkua3QsIHBrOiBwcmlLZXkucGssIGxvYzogbG9jcyB9O1xuICAgIHJldHVybiBjb21LZXk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9jS2V5QXJyYXlUb0l0ZW1LZXk6IGxrYSBpcyB1bmRlZmluZWQgb3IgZW1wdHlcIik7XG4gIH1cbn07XG52YXIgaXNWYWxpZFByaUtleSA9IChrZXkpID0+IHtcbiAgY29uc3QgdmFsaWQgPSBrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IG51bGwgJiYgKGtleS5wayAhPT0gdm9pZCAwICYmIGtleS5wayAhPT0gbnVsbCAmJiBrZXkucGsgIT09IFwiXCIgJiYga2V5LnBrICE9PSBcIm51bGxcIikgJiYgKGtleS5rdCAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gbnVsbCAmJiBrZXkua3QgIT09IFwiXCIgJiYga2V5Lmt0ICE9PSBcIm51bGxcIik7XG4gIHJldHVybiB2YWxpZDtcbn07XG52YXIgaXNWYWxpZExvY0tleSA9IChrZXkpID0+IHtcbiAgY29uc3QgdmFsaWQgPSBrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IG51bGwgJiYgKGtleS5sayAhPT0gdm9pZCAwICYmIGtleS5sayAhPT0gbnVsbCAmJiBrZXkubGsgIT09IFwiXCIgJiYga2V5LmxrICE9PSBcIm51bGxcIikgJiYgKGtleS5rdCAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gbnVsbCAmJiBrZXkua3QgIT09IFwiXCIgJiYga2V5Lmt0ICE9PSBcIm51bGxcIik7XG4gIHJldHVybiB2YWxpZDtcbn07XG52YXIgaXNWYWxpZExvY0tleUFycmF5ID0gKGtleUFycmF5KSA9PiB7XG4gIHJldHVybiBrZXlBcnJheSAhPT0gdm9pZCAwICYmIGtleUFycmF5ICE9PSBudWxsICYmIGtleUFycmF5LmV2ZXJ5KGlzVmFsaWRMb2NLZXkpO1xufTtcbnZhciBpc1ZhbGlkQ29tS2V5ID0gKGtleSkgPT4ge1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSBudWxsICYmIGlzVmFsaWRQcmlLZXkoa2V5KSAmJiBpc1ZhbGlkTG9jS2V5QXJyYXkoa2V5LmxvYyk7XG59O1xudmFyIGlzVmFsaWRJdGVtS2V5ID0gKGtleSkgPT4ge1xuICByZXR1cm4gaXNDb21LZXkoa2V5KSAmJiBpc1ZhbGlkQ29tS2V5KGtleSkgfHwgaXNQcmlLZXkoa2V5KSAmJiBpc1ZhbGlkUHJpS2V5KGtleSk7XG59O1xudmFyIGxrYVRvSUsgPSBsb2NLZXlBcnJheVRvSXRlbUtleTtcblxuLy8gc3JjL2l0ZW0vSUZhY3RvcnkudHNcbnZhciBJRmFjdG9yeSA9IGNsYXNzIF9JRmFjdG9yeSB7XG4gIGl0ZW0gPSB7fTtcbiAgY29uc3RydWN0b3IocHJvcHMgPSB7fSkge1xuICAgIHRoaXMuaXRlbSA9IGRlZXBtZXJnZSh0aGlzLml0ZW0sIHByb3BzKTtcbiAgfVxuICBhZGRSZWYoaSwgbmFtZSkge1xuICAgIGNvbnN0IGlrID0gaS5rZXk7XG4gICAgY29uc3QgcmVmTmFtZSA9IG5hbWUgfHwgcHJpbWFyeVR5cGUoaWspO1xuICAgIGlmICghdGhpcy5pdGVtLnJlZnMpIHtcbiAgICAgIHRoaXMuaXRlbS5yZWZzID0ge307XG4gICAgfVxuICAgIHRoaXMuaXRlbS5yZWZzW3JlZk5hbWVdID0gaWs7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZFJlZihpLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRSZWYoaSwgbmFtZSk7XG4gIH1cbiAgYWRkRGVmYXVsdEV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzLmNyZWF0ZWQpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMuY3JlYXRlZCA9IHsgYXQ6IG5vdyB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMudXBkYXRlZCkge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cy51cGRhdGVkID0geyBhdDogbm93IH07XG4gICAgfVxuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cy5kZWxldGVkKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzLmRlbGV0ZWQgPSB7IGF0OiBudWxsIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZEV2ZW50KG5hbWUsIGF0LCBieSkge1xuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cykge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLml0ZW0uZXZlbnRzW25hbWVdID0geyBhdCwgYnkgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkRXZlbnQobmFtZSwgYXQsIGJ5KSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRFdmVudChuYW1lLCBhdCwgYnkpO1xuICB9XG4gIGFkZFByb3AobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLml0ZW1bbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkUHJvcChuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkUHJvcChuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgYWRkUHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLml0ZW0gPSBkZWVwbWVyZ2UodGhpcy5pdGVtLCBwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRQcm9wcyhwcm9wcyk7XG4gIH1cbiAgdG9JdGVtKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cbn07XG5cbi8vIHNyYy9BSXRlbVNlcnZpY2UudHNcbnZhciBBSXRlbVNlcnZpY2UgPSBjbGFzcyB7XG4gIHBrVHlwZTtcbiAgcGFyZW50U2VydmljZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBrVHlwZSwgcGFyZW50U2VydmljZSkge1xuICAgIHRoaXMucGtUeXBlID0gcGtUeXBlO1xuICAgIGlmIChwYXJlbnRTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnBhcmVudFNlcnZpY2UgPSBwYXJlbnRTZXJ2aWNlO1xuICAgIH1cbiAgfVxuICBnZXRQa1R5cGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMucGtUeXBlO1xuICB9O1xuICBnZXRLZXlUeXBlcyA9ICgpID0+IHtcbiAgICBsZXQga2V5VHlwZXMgPSBbdGhpcy5nZXRQa1R5cGUoKV07XG4gICAgaWYgKHRoaXMucGFyZW50U2VydmljZSkge1xuICAgICAga2V5VHlwZXMgPSBrZXlUeXBlcy5jb25jYXQodGhpcy5wYXJlbnRTZXJ2aWNlLmdldEtleVR5cGVzKCkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VHlwZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvaXRlbS9JdGVtUXVlcnkudHNcbnZhciBpc0NvbmRpdGlvbiA9IChjb25kaXRpb24pID0+IHtcbiAgcmV0dXJuICh0eXBlb2YgY29uZGl0aW9uLmNvbHVtbiA9PT0gXCJzdHJpbmdcIiAmJiAoQXJyYXkuaXNBcnJheShjb25kaXRpb24udmFsdWUpICYmIGNvbmRpdGlvbi52YWx1ZS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpKSB8fCBBcnJheS5pc0FycmF5KGNvbmRpdGlvbi52YWx1ZSkgJiYgY29uZGl0aW9uLnZhbHVlLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIikgfHwgdHlwZW9mIGNvbmRpdGlvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY29uZGl0aW9uLnZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb25kaXRpb24udmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IGNvbmRpdGlvbi52YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmIChjb25kaXRpb24ub3BlcmF0b3IgPyB0eXBlb2YgY29uZGl0aW9uLm9wZXJhdG9yID09PSBcInN0cmluZ1wiIDogdHJ1ZSk7XG59O1xuXG4vLyBzcmMvaXRlbS9JUUZhY3RvcnkudHNcbnZhciBJUUZhY3RvcnkgPSBjbGFzcyBfSVFGYWN0b3J5IHtcbiAgcXVlcnkgPSB7fTtcbiAgY29uc3RydWN0b3IocXVlcnkgPSB7fSkge1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfVxuICBvcmRlckJ5KGZpZWxkLCBkaXJlY3Rpb24gPSBcImFzY1wiKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5Lm9yZGVyQnkpIHtcbiAgICAgIHRoaXMucXVlcnkub3JkZXJCeSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5Lm9yZGVyQnkucHVzaCh7IGZpZWxkLCBkaXJlY3Rpb24gfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWdnKG5hbWUsIHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LmFnZ3MpIHtcbiAgICAgIHRoaXMucXVlcnkuYWdncyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5LmFnZ3NbbmFtZV0gPSBxdWVyeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBldmVudChuYW1lLCBxdWVyeSkge1xuICAgIGlmICghdGhpcy5xdWVyeS5ldmVudHMpIHtcbiAgICAgIHRoaXMucXVlcnkuZXZlbnRzID0ge307XG4gICAgfVxuICAgIHRoaXMucXVlcnkuZXZlbnRzW25hbWVdID0gcXVlcnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29uZGl0aW9ucyhjb25kaXRpb25zLCBjb21wb3VuZFR5cGUgPSBcIkFORFwiKSB7XG4gICAgZm9yIChjb25zdCBjb25kaXRpb24gb2YgY29uZGl0aW9ucykge1xuICAgICAgaWYgKCFpc0NvbmRpdGlvbihjb25kaXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb25kaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoY29uZGl0aW9uKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICBjb21wb3VuZFR5cGUsXG4gICAgICAgIGNvbmRpdGlvbnNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICBjb21wb3VuZFR5cGUsXG4gICAgICAgIGNvbmRpdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMucHVzaChjb21wb3VuZENvbmRpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpbWl0KGxpbWl0KSB7XG4gICAgdGhpcy5xdWVyeS5saW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLnF1ZXJ5Lm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvLyBUT0RPOiByaWdodCBub3csIHdlJ3JlIG9ubHkgc3VwcG9ydGluZyBQSyByZWZzIGZvciBxdWVyaWVzLiAgU2hvdWxkIGFkZCBzdXBwb3J0IGZvciBDS3NcbiAgcGsoa3QsIHBrLCBuYW1lKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LnJlZnMpIHtcbiAgICAgIHRoaXMucXVlcnkucmVmcyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCByZWZOYW1lID0gbmFtZSB8fCBrdDtcbiAgICB0aGlzLnF1ZXJ5LnJlZnNbcmVmTmFtZV0gPSBjUEsocGssIGt0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb25kaXRpb24oY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IgPSBcIj09XCIpIHtcbiAgICBjb25zdCBjb25kaXRpb24gPSB7IGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yIH07XG4gICAgaWYgKGlzQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgIGlmICghdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICAgIGNvbXBvdW5kVHlwZTogXCJBTkRcIixcbiAgICAgICAgICBjb25kaXRpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29uZGl0aW9uOiAke0pTT04uc3RyaW5naWZ5KGNvbmRpdGlvbil9YCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhbGwoKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5O1xuICB9XG4gIHN0YXRpYyBvcmRlckJ5KGZpZWxkLCBkaXJlY3Rpb24gPSBcImFzY1wiKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5Lm9yZGVyQnkoZmllbGQsIGRpcmVjdGlvbik7XG4gIH1cbiAgc3RhdGljIGFnZyhuYW1lLCBxdWVyeSkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5hZ2cobmFtZSwgcXVlcnkpO1xuICB9XG4gIHN0YXRpYyBldmVudChuYW1lLCBxdWVyeSkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5ldmVudChuYW1lLCBxdWVyeSk7XG4gIH1cbiAgc3RhdGljIGxpbWl0KGxpbWl0KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmxpbWl0KGxpbWl0KTtcbiAgfVxuICBzdGF0aWMgb2Zmc2V0KG9mZnNldCkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5vZmZzZXQob2Zmc2V0KTtcbiAgfVxuICBzdGF0aWMgcGsoa3QsIHBrLCBuYW1lKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LnBrKGt0LCBwaywgbmFtZSk7XG4gIH1cbiAgc3RhdGljIGNvbmRpdGlvbihjb2x1bW4sIHZhbHVlLCBvcGVyYXRvciA9IFwiPT1cIikge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5jb25kaXRpb24oY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IpO1xuICB9XG4gIHN0YXRpYyBjb25kaXRpb25zKGNvbmRpdGlvbnMsIGNvbXBvdW5kVHlwZSA9IFwiQU5EXCIpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuY29uZGl0aW9ucyhjb25kaXRpb25zLCBjb21wb3VuZFR5cGUpO1xuICB9XG4gIHRvUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cbn07XG5cbi8vIHNyYy9pdGVtL0lRVXRpbHMudHNcbmltcG9ydCAqIGFzIGx1eG9uIGZyb20gXCJsdXhvblwiO1xudmFyIGxvZ2dlcjMgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJUVV0aWxzXCIpO1xudmFyIHF1ZXJ5VG9QYXJhbXMgPSAocXVlcnkpID0+IHtcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIGlmIChxdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgIHBhcmFtcy5jb21wb3VuZENvbmRpdGlvbiA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgfVxuICBpZiAocXVlcnkucmVmcykge1xuICAgIHBhcmFtcy5yZWZzID0gSlNPTi5zdHJpbmdpZnkocXVlcnkucmVmcyk7XG4gIH1cbiAgaWYgKHF1ZXJ5LmxpbWl0KSB7XG4gICAgcGFyYW1zLmxpbWl0ID0gcXVlcnkubGltaXQ7XG4gIH1cbiAgaWYgKHF1ZXJ5Lm9mZnNldCkge1xuICAgIHBhcmFtcy5vZmZzZXQgPSBxdWVyeS5vZmZzZXQ7XG4gIH1cbiAgaWYgKHF1ZXJ5LmFnZ3MpIHtcbiAgICBwYXJhbXMuYWdncyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LmFnZ3MpO1xuICB9XG4gIGlmIChxdWVyeS5ldmVudHMpIHtcbiAgICBwYXJhbXMuZXZlbnRzID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuZXZlbnRzKTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcbnZhciBkYXRlVGltZVJldml2ZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBwYXJzZWREYXRlID0gbHV4b24uRGF0ZVRpbWUuZnJvbUlTTyh2YWx1ZSk7XG4gICAgaWYgKHBhcnNlZERhdGUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERhdGUudG9KU0RhdGUoKTtcbiAgICAgIDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBwYXJhbXNUb1F1ZXJ5ID0gKHBhcmFtcykgPT4ge1xuICBjb25zdCBxdWVyeSA9IHt9O1xuICBpZiAocGFyYW1zLmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgcXVlcnkuY29tcG91bmRDb25kaXRpb24gPSBKU09OLnBhcnNlKHBhcmFtcy5jb21wb3VuZENvbmRpdGlvbik7XG4gIH1cbiAgaWYgKHBhcmFtcy5yZWZzKSB7XG4gICAgcXVlcnkucmVmcyA9IEpTT04ucGFyc2UocGFyYW1zLnJlZnMpO1xuICB9XG4gIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICBxdWVyeS5saW1pdCA9IE51bWJlcihwYXJhbXMubGltaXQpO1xuICB9XG4gIGlmIChwYXJhbXMub2Zmc2V0KSB7XG4gICAgcXVlcnkub2Zmc2V0ID0gTnVtYmVyKHBhcmFtcy5vZmZzZXQpO1xuICB9XG4gIGlmIChwYXJhbXMuYWdncykge1xuICAgIHF1ZXJ5LmFnZ3MgPSBKU09OLnBhcnNlKHBhcmFtcy5hZ2dzKTtcbiAgfVxuICBpZiAocGFyYW1zLmV2ZW50cykge1xuICAgIHF1ZXJ5LmV2ZW50cyA9IEpTT04ucGFyc2UocGFyYW1zLmV2ZW50cywgZGF0ZVRpbWVSZXZpdmVyKTtcbiAgfVxuICByZXR1cm4gcXVlcnk7XG59O1xudmFyIGlzUmVmUXVlcnlNYXRjaCA9IChyZWZLZXksIHF1ZXJ5UmVmLCByZWZlcmVuY2VzKSA9PiB7XG4gIGxvZ2dlcjMudHJhY2UoXCJkb2VzUmVmTWF0Y2hcIiwgeyBxdWVyeVJlZiwgcmVmZXJlbmNlcyB9KTtcbiAgbG9nZ2VyMy5kZWJ1ZyhcIkNvbXBhcmluZyBSZWZcIiwgeyByZWZLZXksIGl0ZW1SZWY6IHJlZmVyZW5jZXNbcmVmS2V5XSwgcXVlcnlSZWYgfSk7XG4gIHJldHVybiBpc0l0ZW1LZXlFcXVhbChxdWVyeVJlZiwgcmVmZXJlbmNlc1tyZWZLZXldKTtcbn07XG52YXIgaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2ggPSAocXVlcnlDb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgaWYgKHF1ZXJ5Q29uZGl0aW9uLmNvbXBvdW5kVHlwZSA9PT0gXCJBTkRcIikge1xuICAgIHJldHVybiBxdWVyeUNvbmRpdGlvbi5jb25kaXRpb25zLmV2ZXJ5KFxuICAgICAgKGNvbmRpdGlvbikgPT4gaXNDb25kaXRpb24oY29uZGl0aW9uKSA/IGlzQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pIDogaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHF1ZXJ5Q29uZGl0aW9uLmNvbmRpdGlvbnMuc29tZShcbiAgICAgIChjb25kaXRpb24pID0+IGlzQ29uZGl0aW9uKGNvbmRpdGlvbikgPyBpc0NvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKSA6IGlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSlcbiAgICApO1xuICB9XG59O1xudmFyIGlzQ29uZGl0aW9uUXVlcnlNYXRjaCA9IChxdWVyeUNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICBjb25zdCBwcm9wS2V5ID0gcXVlcnlDb25kaXRpb24uY29sdW1uO1xuICBsb2dnZXIzLnRyYWNlKFwiZG9lc0NvbmRpdGlvbk1hdGNoXCIsIHsgcHJvcEtleSwgcXVlcnlDb25kaXRpb24sIGl0ZW0gfSk7XG4gIGlmIChpdGVtW3Byb3BLZXldID09PSB2b2lkIDApIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkb2VzIG5vdCBjb250YWluIHByb3AgdW5kZXIga2V5XCIsIHsgcHJvcEtleSwgaXRlbSB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbG9nZ2VyMy5kZWJ1ZyhcIkNvbXBhcmluZyBDb25kaXRpb25cIiwgeyBwcm9wS2V5LCBpdGVtUHJvcDogaXRlbVtwcm9wS2V5XSwgcXVlcnlDb25kaXRpb24gfSk7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgc3dpdGNoIChxdWVyeUNvbmRpdGlvbi5vcGVyYXRvcikge1xuICAgIGNhc2UgXCI9PVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA9PT0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiIT1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gIT09IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIj5cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPiBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI+PVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA+PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI8XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldIDwgcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPD1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPD0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5cIjpcbiAgICAgIHJlc3VsdCA9IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlLmluY2x1ZGVzKGl0ZW1bcHJvcEtleV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vdC1pblwiOlxuICAgICAgcmVzdWx0ID0gIXF1ZXJ5Q29uZGl0aW9uLnZhbHVlLmluY2x1ZGVzKGl0ZW1bcHJvcEtleV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFycmF5LWNvbnRhaW5zXCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldLmluY2x1ZGVzKHF1ZXJ5Q29uZGl0aW9uLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhcnJheS1jb250YWlucy1hbnlcIjpcbiAgICAgIHJlc3VsdCA9IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlLnNvbWUoKHZhbHVlKSA9PiBpdGVtW3Byb3BLZXldLmluY2x1ZGVzKHZhbHVlKSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBpc0FnZ1F1ZXJ5TWF0Y2ggPSAoYWdnS2V5LCBhZ2dRdWVyeSwgYWdnKSA9PiB7XG4gIGNvbnN0IGFnZ0l0ZW0gPSBhZ2cuaXRlbTtcbiAgbG9nZ2VyMy5kZWJ1ZyhcIkNvbXBhcmluZyBBZ2dcIiwgeyBhZ2dLZXksIGFnZ0l0ZW0sIGFnZ1F1ZXJ5IH0pO1xuICByZXR1cm4gaXNRdWVyeU1hdGNoKGFnZ0l0ZW0sIGFnZ1F1ZXJ5KTtcbn07XG52YXIgaXNFdmVudFF1ZXJ5TWF0Y2ggPSAoZXZlbnRLZXksIGV2ZW50UXVlcnksIGl0ZW0pID0+IHtcbiAgaWYgKCFpdGVtLmV2ZW50c1tldmVudEtleV0pIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkb2VzIG5vdCBjb250YWluIGV2ZW50IHVuZGVyIGtleVwiLCB7IGV2ZW50S2V5LCBldmVudHM6IGl0ZW0uZXZlbnRzIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpdGVtRXZlbnQgPSBpdGVtLmV2ZW50c1tldmVudEtleV07XG4gICAgaWYgKGl0ZW1FdmVudC5hdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV2ZW50UXVlcnkuc3RhcnQgJiYgIShldmVudFF1ZXJ5LnN0YXJ0LmdldFRpbWUoKSA8PSBpdGVtRXZlbnQuYXQuZ2V0VGltZSgpKSkge1xuICAgICAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkYXRlIGJlZm9yZSBldmVudCBzdGFydCBxdWVyeVwiLCB7IGV2ZW50UXVlcnksIGl0ZW1FdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50UXVlcnkuZW5kICYmICEoZXZlbnRRdWVyeS5lbmQuZ2V0VGltZSgpID4gaXRlbUV2ZW50LmF0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZGF0ZSBhZnRlciBldmVudCBlbmQgcXVlcnlcIiwgeyBldmVudFF1ZXJ5LCBpdGVtRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZXZlbnQgZG9lcyBjb250YWlucyBhIG51bGwgYXRcIiwgeyBpdGVtRXZlbnQgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIGlzUXVlcnlNYXRjaCA9IChpdGVtLCBxdWVyeSkgPT4ge1xuICBsb2dnZXIzLnRyYWNlKFwiaXNNYXRjaFwiLCB7IGl0ZW0sIHF1ZXJ5IH0pO1xuICBpZiAocXVlcnkucmVmcyAmJiBpdGVtLnJlZnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5yZWZzKSB7XG4gICAgICBjb25zdCBxdWVyeVJlZiA9IHF1ZXJ5LnJlZnNba2V5XTtcbiAgICAgIGlmICghaXNSZWZRdWVyeU1hdGNoKGtleSwgcXVlcnlSZWYsIGl0ZW0ucmVmcykpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocXVlcnkucmVmcyAmJiAhaXRlbS5yZWZzKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIlF1ZXJ5IGNvbnRhaW5zIHJlZnMgYnV0IGl0ZW0gZG9lcyBub3QgaGF2ZSByZWZzXCIsIHsgcXVlcnksIGl0ZW0gfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChxdWVyeS5jb21wb3VuZENvbmRpdGlvbiAmJiBpdGVtKSB7XG4gICAgaWYgKCFpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChxdWVyeS5jb21wb3VuZENvbmRpdGlvbiwgaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocXVlcnkuZXZlbnRzICYmIGl0ZW0uZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkuZXZlbnRzKSB7XG4gICAgICBjb25zdCBxdWVyeUV2ZW50ID0gcXVlcnkuZXZlbnRzW2tleV07XG4gICAgICBpZiAoIWlzRXZlbnRRdWVyeU1hdGNoKGtleSwgcXVlcnlFdmVudCwgaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHF1ZXJ5LmFnZ3MgJiYgaXRlbS5hZ2dzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkuYWdncykge1xuICAgICAgY29uc3QgYWdnUXVlcnkgPSBxdWVyeS5hZ2dzW2tleV07XG4gICAgICBpZiAoaXRlbS5hZ2dzW2tleV0gJiYgIWlzQWdnUXVlcnlNYXRjaChrZXksIGFnZ1F1ZXJ5LCBpdGVtLmFnZ3Nba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHF1ZXJ5LmFnZ3MgJiYgIWl0ZW0uYWdncykge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJRdWVyeSBjb250YWlucyBhZ2dzIGJ1dCBpdGVtIGRvZXMgbm90IGhhdmUgYWdnc1wiLCB7IHF1ZXJ5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgYWJicmV2UXVlcnkgPSAocXVlcnkpID0+IHtcbiAgY29uc3QgYWJicmV2ID0gW1wiSVFcIl07XG4gIGlmIChxdWVyeSkge1xuICAgIGlmIChxdWVyeS5yZWZzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5yZWZzKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IGFiYnJldlJlZihrZXksIHF1ZXJ5LnJlZnNba2V5XSk7XG4gICAgICAgIGFiYnJldi5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgICAgY29uc3QgcHJvcHMgPSBhYmJyZXZDb21wb3VuZENvbmRpdGlvbihxdWVyeS5jb21wb3VuZENvbmRpdGlvbik7XG4gICAgICBhYmJyZXYucHVzaChwcm9wcyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5hZ2dzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5hZ2dzKSB7XG4gICAgICAgIGNvbnN0IGFnZyA9IGFiYnJldkFnZyhrZXksIHF1ZXJ5LmFnZ3Nba2V5XSk7XG4gICAgICAgIGFiYnJldi5wdXNoKGFnZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeS5ldmVudHMpIHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGAoRSR7T2JqZWN0LmtleXMocXVlcnkuZXZlbnRzKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIGFiYnJldi5wdXNoKGV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5saW1pdCkge1xuICAgICAgYWJicmV2LnB1c2goYEwke3F1ZXJ5LmxpbWl0fWApO1xuICAgIH1cbiAgICBpZiAocXVlcnkub2Zmc2V0KSB7XG4gICAgICBhYmJyZXYucHVzaChgTyR7cXVlcnkub2Zmc2V0fWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhYmJyZXYucHVzaChcIihlbXB0eSlcIik7XG4gIH1cbiAgcmV0dXJuIGFiYnJldi5qb2luKFwiIFwiKTtcbn07XG52YXIgYWJicmV2UmVmID0gKGtleSwgcmVmKSA9PiB7XG4gIGlmIChpc1ByaUtleShyZWYpKSB7XG4gICAgY29uc3QgcHJpS2V5ID0gcmVmO1xuICAgIHJldHVybiBgUigke2tleX0sJHtwcmlLZXkua3R9LCR7cHJpS2V5LnBrfSlgO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbUtleSA9IHJlZjtcbiAgICByZXR1cm4gYFIoJHtrZXl9LCR7SlNPTi5zdHJpbmdpZnkoY29tS2V5KX0pYDtcbiAgfVxufTtcbnZhciBhYmJyZXZBZ2cgPSAoa2V5LCBhZ2cpID0+IHtcbiAgcmV0dXJuIGBBKCR7a2V5fSwke2FiYnJldlF1ZXJ5KGFnZyl9KWA7XG59O1xudmFyIGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uID0gKGNvbXBvdW5kQ29uZGl0aW9uKSA9PiB7XG4gIHJldHVybiBgQ0MoJHtjb21wb3VuZENvbmRpdGlvbi5jb21wb3VuZFR5cGV9LCR7Y29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucyA/IGNvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMubWFwKGFiYnJldkNvbmRpdGlvbikuam9pbihcIixcIikgOiBcIk5vIENvbmRpdGlvbnNcIn0pYDtcbn07XG52YXIgYWJicmV2Q29uZGl0aW9uID0gKGNvbmRpdGlvbikgPT4ge1xuICBpZiAoaXNDb25kaXRpb24oY29uZGl0aW9uKSkge1xuICAgIHJldHVybiBgKCR7Y29uZGl0aW9uLmNvbHVtbn0sJHtjb25kaXRpb24udmFsdWV9LCR7Y29uZGl0aW9uLm9wZXJhdG9yfSlgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhYmJyZXZDb21wb3VuZENvbmRpdGlvbihjb25kaXRpb24pO1xuICB9XG59O1xuXG4vLyBzcmMvaXRlbS9JVXRpbHMudHNcbnZhciBsb2dnZXI0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSVV0aWxzXCIpO1xudmFyIHZhbGlkYXRlUEtGb3JJdGVtID0gKGl0ZW0sIHBrVHlwZSkgPT4ge1xuICBpZiAoIWl0ZW0pIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBpcyB1bmRlZmluZWRcIiwgeyBpdGVtIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gaXMgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICghaXRlbS5rZXkpIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5XCIsIHsgaXRlbSB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGRvZXMgbm90IGhhdmUgYSBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5VHlwZUFycmF5ID0gdG9LZXlUeXBlQXJyYXkoaXRlbS5rZXkpO1xuICBpZiAoa2V5VHlwZUFycmF5WzBdICE9PSBwa1R5cGUpIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiS2V5IFR5cGUgQXJyYXkgTWlzbWF0Y2hcIiwgeyBrZXlUeXBlQXJyYXksIHBrVHlwZSB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBwcmltYXJ5IGtleSB0eXBlLiBFeHBlY3RlZCAke3BrVHlwZX0sIGdvdCAke2tleVR5cGVBcnJheVswXX1gKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG52YXIgdmFsaWRhdGVQSyA9IChpbnB1dCwgcGtUeXBlKSA9PiB7XG4gIGxvZ2dlcjQudHJhY2UoXCJDaGVja2luZyBSZXR1cm4gVHlwZVwiLCB7IGlucHV0IH0pO1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiB2YWxpZGF0ZVBLRm9ySXRlbShpdGVtLCBwa1R5cGUpKTtcbiAgfVxuICByZXR1cm4gdmFsaWRhdGVQS0Zvckl0ZW0oaW5wdXQsIHBrVHlwZSk7XG59O1xudmFyIHZhbGlkYXRlS2V5cyA9IChpdGVtLCBrZXlUeXBlcykgPT4ge1xuICBsb2dnZXI0LnRyYWNlKFwiQ2hlY2tpbmcgUmV0dXJuIFR5cGVcIiwgeyBpdGVtIH0pO1xuICBpZiAoIWl0ZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWxpZGF0aW5nIGtleXMsIGl0ZW0gaXMgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICghaXRlbS5rZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWxpZGF0aW5nIGtleXMsIGl0ZW0gZG9lcyBub3QgaGF2ZSBhIGtleTogXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gIH1cbiAgY29uc3Qga2V5VHlwZUFycmF5ID0gdG9LZXlUeXBlQXJyYXkoaXRlbS5rZXkpO1xuICBpZiAoa2V5VHlwZUFycmF5Lmxlbmd0aCAhPT0ga2V5VHlwZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGtleXMuIEV4cGVjdGVkICR7a2V5VHlwZXMubGVuZ3RofSwgYnV0IGdvdCAke2tleVR5cGVBcnJheS5sZW5ndGh9YCk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBKU09OLnN0cmluZ2lmeShrZXlUeXBlQXJyYXkpID09PSBKU09OLnN0cmluZ2lmeShrZXlUeXBlcyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiS2V5IFR5cGUgQXJyYXkgTWlzbWF0Y2hcIiwgeyBrZXlUeXBlQXJyYXksIHRoaXNLZXlUeXBlczoga2V5VHlwZXMgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3Qga2V5IHR5cGVzLiBFeHBlY3RlZCBbJHtrZXlUeXBlcy5qb2luKFwiLCBcIil9XSwgYnV0IGdvdCBbJHtrZXlUeXBlQXJyYXkuam9pbihcIiwgXCIpfV1gKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG52YXIgaXNQcmlJdGVtID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuICEhKGl0ZW0gJiYgaXRlbS5rZXkgJiYgaXNQcmlLZXkoaXRlbS5rZXkpKTtcbn07XG52YXIgaXNDb21JdGVtID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuICEhKGl0ZW0gJiYgaXRlbS5rZXkgJiYgaXNDb21LZXkoaXRlbS5rZXkpKTtcbn07XG5leHBvcnQge1xuICBBSXRlbVNlcnZpY2UsXG4gIERpY3Rpb25hcnksXG4gIElGYWN0b3J5LFxuICBJUUZhY3RvcnksXG4gIGFiYnJldkFnZyxcbiAgYWJicmV2Q29tcG91bmRDb25kaXRpb24sXG4gIGFiYnJldkNvbmRpdGlvbixcbiAgYWJicmV2SUssXG4gIGFiYnJldkxLQSxcbiAgYWJicmV2UXVlcnksXG4gIGFiYnJldlJlZixcbiAgY1BLLFxuICBjb25zdHJ1Y3RQcmlLZXksXG4gIGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sXG4gIGdlbmVyYXRlS2V5QXJyYXksXG4gIGlrVG9MS0EsXG4gIGlzQ29tSXRlbSxcbiAgaXNDb21LZXksXG4gIGlzQ29tS2V5RXF1YWwsXG4gIGlzQ29tS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc0NvbmRpdGlvbixcbiAgaXNJdGVtS2V5LFxuICBpc0l0ZW1LZXlFcXVhbCxcbiAgaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc0xvY0tleSxcbiAgaXNMb2NLZXlFcXVhbCxcbiAgaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzUHJpSXRlbSxcbiAgaXNQcmlLZXksXG4gIGlzUHJpS2V5RXF1YWwsXG4gIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc1F1ZXJ5TWF0Y2gsXG4gIGlzVmFsaWRDb21LZXksXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBpc1ZhbGlkTG9jS2V5LFxuICBpc1ZhbGlkTG9jS2V5QXJyYXksXG4gIGlzVmFsaWRQcmlLZXksXG4gIGl0ZW1LZXlUb0xvY0tleUFycmF5LFxuICBsa2FUb0lLLFxuICBsb2NLZXlBcnJheVRvSXRlbUtleSxcbiAgcGFyYW1zVG9RdWVyeSxcbiAgcHJpbWFyeVR5cGUsXG4gIHF1ZXJ5VG9QYXJhbXMsXG4gIHRvS2V5VHlwZUFycmF5LFxuICB2YWxpZGF0ZUtleXMsXG4gIHZhbGlkYXRlUEtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../fjell-providers/node_modules/@fjell/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-providers/node_modules/@fjell/http-api/dist/index.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/http-api/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   ForbiddenError: () => (/* binding */ ForbiddenError),\n/* harmony export */   GoneError: () => (/* binding */ GoneError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   MethodNotAllowedError: () => (/* binding */ MethodNotAllowedError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),\n/* harmony export */   RequestTimeoutError: () => (/* binding */ RequestTimeoutError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   ServiceUnavailableError: () => (/* binding */ ServiceUnavailableError),\n/* harmony export */   TooManyRequestsError: () => (/* binding */ TooManyRequestsError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   connectMethod: () => (/* binding */ connectMethod),\n/* harmony export */   deleteMethod: () => (/* binding */ deleteMethod2),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getHttp: () => (/* binding */ getHttp),\n/* harmony export */   getHttpApi: () => (/* binding */ getHttpApi),\n/* harmony export */   getHttpFile: () => (/* binding */ getHttpFile),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   optionsMethod: () => (/* binding */ optionsMethod),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   patchMethod: () => (/* binding */ patchMethod),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   postFileMethod: () => (/* binding */ postFileMethod2),\n/* harmony export */   postMethod: () => (/* binding */ postMethod),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   putMethod: () => (/* binding */ putMethod),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   traceMethod: () => (/* binding */ traceMethod),\n/* harmony export */   uploadAsyncMethod: () => (/* binding */ uploadAsyncMethod2)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n// src/errors.ts\nvar APIError = class _APIError extends Error {\n  httpResponseCode;\n  path;\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, options2);\n    this.httpResponseCode = httpResponseCode;\n    this.path = path;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, _APIError);\n    }\n  }\n};\nvar ClientError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar BadRequestError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 400, options2);\n  }\n};\nvar UnauthorizedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 401, options2);\n  }\n};\nvar ForbiddenError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 403, options2);\n  }\n};\nvar NotFoundError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 404, options2);\n  }\n};\nvar MethodNotAllowedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 405, options2);\n  }\n};\nvar RequestTimeoutError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 408, options2);\n  }\n};\nvar ConflictError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 409, options2);\n  }\n};\nvar GoneError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 410, options2);\n  }\n};\nvar TooManyRequestsError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 429, options2);\n  }\n};\nvar ServerError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar InternalServerError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 500, options2);\n  }\n};\nvar NotImplementedError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 501, options2);\n  }\n};\nvar ServiceUnavailableError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 503, options2);\n  }\n};\n\n// src/api/util.ts\nvar getParameterValue = (value) => {\n  if (value) {\n    return value instanceof Date ? value.toISOString() : value.toString();\n  } else {\n    return \"\";\n  }\n};\nvar generateQueryParameters = (params) => Object.keys(params).length > 0 ? \"?\" + Object.keys(params).filter(\n  (key) => params[key] !== void 0 && (typeof params[key] === \"string\" && params[key].length === 0) === false\n).map((key) => {\n  let value;\n  if (params[key] === false) {\n    value = \"false\";\n  } else {\n    value = params[key];\n  }\n  return `${key}=${encodeURIComponent(getParameterValue(value))}`;\n}).join(\"&\") : \"\";\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/http-api\");\nvar logger_default = LibLogger;\n\n// src/api/http.ts\nvar logger = logger_default.get(\"api\", \"http\");\nfunction getHttp(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, body = {}, httpOptions = {}) => {\n    logger.trace(\"http\", { method, path, body, httpOptions });\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const headers = {};\n    if (!options2.skipContentType) {\n      headers[\"Content-Type\"] = options2.contentType;\n    }\n    headers[\"Accept\"] = options2.accept;\n    headers[\"X-Client-Name\"] = config.clientName;\n    const debugOptions = {\n      ...options2,\n      method,\n      path,\n      body\n    };\n    await populateAuthHeader(options2.isAuthenticated, headers);\n    logger.debug(\"http Request: %j, %j\", method, path);\n    const fetchOptions = {\n      method,\n      headers,\n      credentials: options2.requestCredentials\n    };\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      fetchOptions.body = body ? options2.isJsonBody ? JSON.stringify(body) : body : null;\n    }\n    const response = await fetch(\n      `${config.url}${path}${generateQueryParameters(options2.params)}`,\n      fetchOptions\n    );\n    let returnValue;\n    returnValue = await response.text();\n    if (response.status >= 400) {\n      let error;\n      if (response.status >= 500) {\n        if (response.status === 500) {\n          error = new InternalServerError(response.statusText, path, debugOptions);\n        } else if (response.status === 501) {\n          error = new NotImplementedError(response.statusText, path, debugOptions);\n        } else if (response.status === 503) {\n          error = new ServiceUnavailableError(response.statusText, path, debugOptions);\n        } else {\n          error = new ServerError(response.statusText, path, response.status, debugOptions);\n        }\n      } else {\n        if (response.status === 400) {\n          error = new BadRequestError(response.statusText, path, debugOptions);\n        } else if (response.status === 401) {\n          error = new UnauthorizedError(response.statusText, path, debugOptions);\n        } else if (response.status === 403) {\n          error = new ForbiddenError(response.statusText, path, debugOptions);\n        } else if (response.status === 404) {\n          error = new NotFoundError(response.statusText, path, debugOptions);\n        } else if (response.status === 405) {\n          error = new MethodNotAllowedError(response.statusText, path, debugOptions);\n        } else if (response.status === 408) {\n          error = new RequestTimeoutError(response.statusText, path, debugOptions);\n        } else if (response.status === 409) {\n          error = new ConflictError(response.statusText, path, debugOptions);\n        } else if (response.status === 410) {\n          error = new GoneError(response.statusText, path, debugOptions);\n        } else if (response.status === 429) {\n          error = new TooManyRequestsError(response.statusText, path, debugOptions);\n        } else {\n          error = new ClientError(response.statusText, path, response.status, debugOptions);\n        }\n      }\n      throw error;\n    }\n    if (options2.isJson) {\n      try {\n        returnValue = JSON.parse(returnValue);\n        logger.default(\"API RESPONSE JSON: %j\", { status: response.status, body: returnValue });\n      } catch (e) {\n        logger.error(\"Error parsing JSON\", { message: e.message, stack: e.stack, returnValue });\n        throw e;\n      }\n    } else {\n      logger.default(\"API RESPONSE TEXT: %j\", { status: response.status, body: returnValue });\n    }\n    return returnValue;\n  };\n}\n\n// src/api/deleteMethod.ts\nvar logger2 = logger_default.get(\"api\", \"deleteMethod\");\nfunction deleteMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, deleteOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...deleteOptions\n    };\n    logger2.debug(\"httpDelete Request: %j, %j\", path, options2);\n    const s = await http(\n      \"DELETE\",\n      path,\n      body,\n      options2\n    );\n    logger2.default(\"httpDelete Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/getMethod.ts\nvar logger3 = logger_default.get(\"api\", \"getMethod\");\nfunction getMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger3.debug(\"httpGet Request: %j, %j\", path, options2);\n    const s = await http(\"GET\", path, null, options2);\n    logger3.default(\"httpGet Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/postMethod.ts\nvar logger4 = logger_default.get(\"api\", \"postMethod\");\nfunction postMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger4.debug(\"httpPost Request: %j, %j\", path, options2);\n    const s = await http(\"POST\", path, body, options2);\n    logger4.default(\"httpPost Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/putMethod.ts\nvar logger5 = logger_default.get(\"api\", \"putMethod\");\nfunction putMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger5.debug(\"httpPut Request: %j, %j\", path, options2);\n    const s = await http(\"PUT\", path, body, options2);\n    logger5.default(\"httpPut Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/optionsMethod.ts\nvar logger6 = logger_default.get(\"api\", \"optionsMethod\");\nfunction optionsMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger6.debug(\"httpOptions Request: %j, %j\", path, opts);\n    const s = await http(\"OPTIONS\", path, null, opts);\n    logger6.default(\"httpOptions Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/connectMethod.ts\nvar logger7 = logger_default.get(\"api\", \"connectMethod\");\nfunction connectMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger7.debug(\"httpConnect Request: %j, %j\", path, opts);\n    const s = await http(\"CONNECT\", path, null, opts);\n    logger7.default(\"httpConnect Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/traceMethod.ts\nvar logger8 = logger_default.get(\"api\", \"traceMethod\");\nfunction traceMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger8.debug(\"httpTrace Request: %j, %j\", path, opts);\n    const s = await http(\"TRACE\", path, null, opts);\n    logger8.default(\"httpTrace Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/patchMethod.ts\nvar logger9 = logger_default.get(\"api\", \"patchMethod\");\nfunction patchMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger9.debug(\"httpPatch Request: %j, %j\", path, opts);\n    const s = await http(\"PATCH\", path, body, opts);\n    logger9.default(\"httpPatch Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/httpFile.ts\nfunction getHttpFile(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, file, httpFileOptions = {}, body = {}, headers = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpFileOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    try {\n      headers[\"Accept\"] = options2.accept;\n      headers[\"X-Client-Name\"] = config.clientName;\n      await populateAuthHeader(options2.isAuthenticated, headers);\n      const bodyData = new FormData();\n      Object.keys(body).forEach((key) => {\n        bodyData.set(key, body[key]);\n      });\n      bodyData.set(\"file\", new Blob([new Uint8Array(file.buffer)]), file.bufferName);\n      const response = await fetch(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        {\n          method,\n          headers,\n          body: bodyData,\n          credentials: options2.requestCredentials\n        }\n      );\n      const returnValue = options2.isJson ? await response.json() : await response.text();\n      if (response.status >= 400) {\n        console.error(\n          `Error executing API request httpFile, status: ${response.status}: ` + JSON.stringify({ method, path, params: options2.params, body, returnValue })\n        );\n        throw new Error(options2.isJson ? returnValue.message : returnValue);\n      }\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api/postFileMethod.ts\nvar logger10 = logger_default.get(\"api\", \"postFileMethod\");\nfunction postFileMethod(apiParams) {\n  const httpFile = getHttpFile(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, headers = {}, file, postFileOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...postFileOptions\n    };\n    logger10.debug(\"httpPostFileData Request: %s, %j\", path, options2);\n    logger10.default(\"httpPostFileData Request Body: %j\", body);\n    const s = await httpFile(\n      \"POST\",\n      path,\n      file,\n      options2,\n      body,\n      headers\n    );\n    logger10.default(\"httpPostFileData Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/uploadAsyncMethod.ts\nfunction uploadAsyncMethod(apiParams) {\n  const getOptionDefaults = () => ({\n    method: \"POST\",\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    fieldName: \"file\",\n    headers: {}\n  });\n  return async (path, uri, uploadAsyncOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(),\n      ...uploadAsyncOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const uploadAsyncFile = apiParams.uploadAsyncFile;\n    try {\n      options2.headers[\"Accept\"] = options2.accept;\n      await populateAuthHeader(options2.isAuthenticated, options2.headers);\n      const result = await uploadAsyncFile(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        uri,\n        options2.method,\n        \"multipart\",\n        options2.fieldName,\n        options2.headers\n      );\n      const returnValue = options2.isJson ? JSON.parse(result.body) : result.body;\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${options2.method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api.ts\nvar getHttpApi = (apiParams) => {\n  const httpDelete = deleteMethod(apiParams);\n  const httpGet = getMethod(apiParams);\n  const httpPost = postMethod(apiParams);\n  const httpPut = putMethod(apiParams);\n  const httpOptions = optionsMethod(apiParams);\n  const httpConnect = connectMethod(apiParams);\n  const httpTrace = traceMethod(apiParams);\n  const httpPatch = patchMethod(apiParams);\n  const httpPostFile = postFileMethod(apiParams);\n  const uploadAsync = uploadAsyncMethod(apiParams);\n  return {\n    httpDelete,\n    httpGet,\n    httpPut,\n    httpPost,\n    httpPostFile,\n    uploadAsync,\n    httpOptions,\n    httpConnect,\n    httpTrace,\n    httpPatch\n  };\n};\n\n// src/simple-api.ts\nvar defaultApiParams = {\n  config: {\n    url: \"\",\n    requestCredentials: \"same-origin\",\n    clientName: \"fjell-http-api-examples\"\n  },\n  populateAuthHeader: async (isAuthenticated, headers) => {\n    if (isAuthenticated) {\n      headers[\"Authorization\"] = \"Bearer example-token\";\n    }\n  },\n  uploadAsyncFile: async () => {\n    return {\n      headers: {},\n      status: 200,\n      mimeType: \"application/json\",\n      body: JSON.stringify({ success: true })\n    };\n  }\n};\nvar getImpl = getMethod(defaultApiParams);\nvar postImpl = postMethod(defaultApiParams);\nvar putImpl = putMethod(defaultApiParams);\nvar optionsImpl = optionsMethod(defaultApiParams);\nvar connectImpl = connectMethod(defaultApiParams);\nvar traceImpl = traceMethod(defaultApiParams);\nvar patchImpl = patchMethod(defaultApiParams);\nvar deleteImpl = deleteMethod(defaultApiParams);\nvar postFileImpl = postFileMethod(defaultApiParams);\nvar uploadAsyncImpl = uploadAsyncMethod(defaultApiParams);\nvar get = (path, options2) => {\n  return getImpl(path, options2);\n};\nvar post = (path, body, options2) => {\n  return postImpl(path, body, options2);\n};\nvar put = (path, body, options2) => {\n  return putImpl(path, body, options2);\n};\nvar deleteMethod2 = (path, body, options2) => {\n  return deleteImpl(path, body, options2);\n};\nvar options = (path, opts) => {\n  return optionsImpl(path, opts);\n};\nvar connect = (path, opts) => {\n  return connectImpl(path, opts);\n};\nvar trace = (path, opts) => {\n  return traceImpl(path, opts);\n};\nvar patch = (path, body, opts) => {\n  return patchImpl(path, body, opts);\n};\nvar postFileMethod2 = (path, file, options2) => {\n  const fileBuffer = {\n    buffer: Buffer.from([]),\n    // Placeholder - would need proper File reading in browser\n    bufferName: file.name\n  };\n  return postFileImpl(path, {}, {}, fileBuffer, options2);\n};\nvar uploadAsyncMethod2 = (path, uri, options2) => {\n  return uploadAsyncImpl(path, uri, options2);\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9AZmplbGwvaHR0cC1hcGkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSxJQUFJLEdBQUcsNkNBQTZDO0FBQ2hFLENBQUM7O0FBRUQ7QUFDcUM7QUFDckMsZ0JB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O0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0Q0FBNEMsaUJBQWlCLEVBQUUsTUFBTSxFQUFFO0FBQ3ZFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQXFDRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvQGZqZWxsL2h0dHAtYXBpL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy50c1xudmFyIEFQSUVycm9yID0gY2xhc3MgX0FQSUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBodHRwUmVzcG9uc2VDb2RlO1xuICBwYXRoO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMyKTtcbiAgICB0aGlzLmh0dHBSZXNwb25zZUNvZGUgPSBodHRwUmVzcG9uc2VDb2RlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBfQVBJRXJyb3IpO1xuICAgIH1cbiAgfVxufTtcbnZhciBDbGllbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBCYWRSZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAwLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgVW5hdXRob3JpemVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAxLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgRm9yYmlkZGVuRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAzLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDQsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBNZXRob2ROb3RBbGxvd2VkRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA1LCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgUmVxdWVzdFRpbWVvdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDgsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBDb25mbGljdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwOSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIEdvbmVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MTAsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBUb29NYW55UmVxdWVzdHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MjksIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBTZXJ2ZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBJbnRlcm5hbFNlcnZlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAwLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgTm90SW1wbGVtZW50ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIDUwMSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAzLCBvcHRpb25zMik7XG4gIH1cbn07XG5cbi8vIHNyYy9hcGkvdXRpbC50c1xudmFyIGdldFBhcmFtZXRlclZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyB2YWx1ZS50b0lTT1N0cmluZygpIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcbnZhciBnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyA9IChwYXJhbXMpID0+IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMCA/IFwiP1wiICsgT2JqZWN0LmtleXMocGFyYW1zKS5maWx0ZXIoXG4gIChrZXkpID0+IHBhcmFtc1trZXldICE9PSB2b2lkIDAgJiYgKHR5cGVvZiBwYXJhbXNba2V5XSA9PT0gXCJzdHJpbmdcIiAmJiBwYXJhbXNba2V5XS5sZW5ndGggPT09IDApID09PSBmYWxzZVxuKS5tYXAoKGtleSkgPT4ge1xuICBsZXQgdmFsdWU7XG4gIGlmIChwYXJhbXNba2V5XSA9PT0gZmFsc2UpIHtcbiAgICB2YWx1ZSA9IFwiZmFsc2VcIjtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICB9XG4gIHJldHVybiBgJHtrZXl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtZXRlclZhbHVlKHZhbHVlKSl9YDtcbn0pLmpvaW4oXCImXCIpIDogXCJcIjtcblxuLy8gc3JjL2xvZ2dlci50c1xuaW1wb3J0IExvZ2dpbmcgZnJvbSBcIkBmamVsbC9sb2dnaW5nXCI7XG52YXIgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoXCJAZmplbGwvaHR0cC1hcGlcIik7XG52YXIgbG9nZ2VyX2RlZmF1bHQgPSBMaWJMb2dnZXI7XG5cbi8vIHNyYy9hcGkvaHR0cC50c1xudmFyIGxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcImh0dHBcIik7XG5mdW5jdGlvbiBnZXRIdHRwKGFwaVBhcmFtcykge1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAobWV0aG9kLCBwYXRoLCBib2R5ID0ge30sIGh0dHBPcHRpb25zID0ge30pID0+IHtcbiAgICBsb2dnZXIudHJhY2UoXCJodHRwXCIsIHsgbWV0aG9kLCBwYXRoLCBib2R5LCBodHRwT3B0aW9ucyB9KTtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5odHRwT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgY29uZmlnID0gYXBpUGFyYW1zLmNvbmZpZztcbiAgICBjb25zdCBwb3B1bGF0ZUF1dGhIZWFkZXIgPSBhcGlQYXJhbXMucG9wdWxhdGVBdXRoSGVhZGVyO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAoIW9wdGlvbnMyLnNraXBDb250ZW50VHlwZSkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IG9wdGlvbnMyLmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gb3B0aW9uczIuYWNjZXB0O1xuICAgIGhlYWRlcnNbXCJYLUNsaWVudC1OYW1lXCJdID0gY29uZmlnLmNsaWVudE5hbWU7XG4gICAgY29uc3QgZGVidWdPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9uczIsXG4gICAgICBtZXRob2QsXG4gICAgICBwYXRoLFxuICAgICAgYm9keVxuICAgIH07XG4gICAgYXdhaXQgcG9wdWxhdGVBdXRoSGVhZGVyKG9wdGlvbnMyLmlzQXV0aGVudGljYXRlZCwgaGVhZGVycyk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cCBSZXF1ZXN0OiAlaiwgJWpcIiwgbWV0aG9kLCBwYXRoKTtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMyLnJlcXVlc3RDcmVkZW50aWFsc1xuICAgIH07XG4gICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBmZXRjaE9wdGlvbnMuYm9keSA9IGJvZHkgPyBvcHRpb25zMi5pc0pzb25Cb2R5ID8gSlNPTi5zdHJpbmdpZnkoYm9keSkgOiBib2R5IDogbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke2NvbmZpZy51cmx9JHtwYXRofSR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMob3B0aW9uczIucGFyYW1zKX1gLFxuICAgICAgZmV0Y2hPcHRpb25zXG4gICAgKTtcbiAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgcmV0dXJuVmFsdWUgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEludGVybmFsU2VydmVyRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IE5vdEltcGxlbWVudGVkRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMykge1xuICAgICAgICAgIGVycm9yID0gbmV3IFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgU2VydmVyRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgcmVzcG9uc2Uuc3RhdHVzLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBCYWRSZXF1ZXN0RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFVuYXV0aG9yaXplZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBGb3JiaWRkZW5FcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgTm90Rm91bmRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgTWV0aG9kTm90QWxsb3dlZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDgpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBSZXF1ZXN0VGltZW91dEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBDb25mbGljdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MTApIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBHb25lRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFRvb01hbnlSZXF1ZXN0c0Vycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgQ2xpZW50RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgcmVzcG9uc2Uuc3RhdHVzLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMyLmlzSnNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBKU09OLnBhcnNlKHJldHVyblZhbHVlKTtcbiAgICAgICAgbG9nZ2VyLmRlZmF1bHQoXCJBUEkgUkVTUE9OU0UgSlNPTjogJWpcIiwgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgYm9keTogcmV0dXJuVmFsdWUgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHBhcnNpbmcgSlNPTlwiLCB7IG1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2ssIHJldHVyblZhbHVlIH0pO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVmYXVsdChcIkFQSSBSRVNQT05TRSBURVhUOiAlalwiLCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBib2R5OiByZXR1cm5WYWx1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL2RlbGV0ZU1ldGhvZC50c1xudmFyIGxvZ2dlcjIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJkZWxldGVNZXRob2RcIik7XG5mdW5jdGlvbiBkZWxldGVNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBib2R5ID0ge30sIGRlbGV0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmRlbGV0ZU9wdGlvbnNcbiAgICB9O1xuICAgIGxvZ2dlcjIuZGVidWcoXCJodHRwRGVsZXRlIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXG4gICAgICBcIkRFTEVURVwiLFxuICAgICAgcGF0aCxcbiAgICAgIGJvZHksXG4gICAgICBvcHRpb25zMlxuICAgICk7XG4gICAgbG9nZ2VyMi5kZWZhdWx0KFwiaHR0cERlbGV0ZSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL2dldE1ldGhvZC50c1xudmFyIGxvZ2dlcjMgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJnZXRNZXRob2RcIik7XG5mdW5jdGlvbiBnZXRNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBnZXRPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5nZXRPcHRpb25zXG4gICAgfTtcbiAgICBsb2dnZXIzLmRlYnVnKFwiaHR0cEdldCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9uczIpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiR0VUXCIsIHBhdGgsIG51bGwsIG9wdGlvbnMyKTtcbiAgICBsb2dnZXIzLmRlZmF1bHQoXCJodHRwR2V0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvcG9zdE1ldGhvZC50c1xudmFyIGxvZ2dlcjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwb3N0TWV0aG9kXCIpO1xuZnVuY3Rpb24gcG9zdE1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIGJvZHkgPSB7fSwgZ2V0T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uZ2V0T3B0aW9uc1xuICAgIH07XG4gICAgbG9nZ2VyNC5kZWJ1ZyhcImh0dHBQb3N0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJQT1NUXCIsIHBhdGgsIGJvZHksIG9wdGlvbnMyKTtcbiAgICBsb2dnZXI0LmRlZmF1bHQoXCJodHRwUG9zdCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3B1dE1ldGhvZC50c1xudmFyIGxvZ2dlcjUgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwdXRNZXRob2RcIik7XG5mdW5jdGlvbiBwdXRNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBib2R5ID0ge30sIGdldE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmdldE9wdGlvbnNcbiAgICB9O1xuICAgIGxvZ2dlcjUuZGVidWcoXCJodHRwUHV0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJQVVRcIiwgcGF0aCwgYm9keSwgb3B0aW9uczIpO1xuICAgIGxvZ2dlcjUuZGVmYXVsdChcImh0dHBQdXQgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9vcHRpb25zTWV0aG9kLnRzXG52YXIgbG9nZ2VyNiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcIm9wdGlvbnNNZXRob2RcIik7XG5mdW5jdGlvbiBvcHRpb25zTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgb3B0aW9uczIgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9O1xuICAgIGxvZ2dlcjYuZGVidWcoXCJodHRwT3B0aW9ucyBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJPUFRJT05TXCIsIHBhdGgsIG51bGwsIG9wdHMpO1xuICAgIGxvZ2dlcjYuZGVmYXVsdChcImh0dHBPcHRpb25zIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvY29ubmVjdE1ldGhvZC50c1xudmFyIGxvZ2dlcjcgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJjb25uZWN0TWV0aG9kXCIpO1xuZnVuY3Rpb24gY29ubmVjdE1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIG9wdGlvbnMyID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLm9wdGlvbnMyXG4gICAgfTtcbiAgICBsb2dnZXI3LmRlYnVnKFwiaHR0cENvbm5lY3QgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiQ09OTkVDVFwiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXI3LmRlZmF1bHQoXCJodHRwQ29ubmVjdCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3RyYWNlTWV0aG9kLnRzXG52YXIgbG9nZ2VyOCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcInRyYWNlTWV0aG9kXCIpO1xuZnVuY3Rpb24gdHJhY2VNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBvcHRpb25zMiA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH07XG4gICAgbG9nZ2VyOC5kZWJ1ZyhcImh0dHBUcmFjZSBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJUUkFDRVwiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXI4LmRlZmF1bHQoXCJodHRwVHJhY2UgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9wYXRjaE1ldGhvZC50c1xudmFyIGxvZ2dlcjkgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwYXRjaE1ldGhvZFwiKTtcbmZ1bmN0aW9uIHBhdGNoTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgYm9keSA9IHt9LCBvcHRpb25zMiA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH07XG4gICAgbG9nZ2VyOS5kZWJ1ZyhcImh0dHBQYXRjaCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJQQVRDSFwiLCBwYXRoLCBib2R5LCBvcHRzKTtcbiAgICBsb2dnZXI5LmRlZmF1bHQoXCJodHRwUGF0Y2ggUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9odHRwRmlsZS50c1xuZnVuY3Rpb24gZ2V0SHR0cEZpbGUoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAobWV0aG9kLCBwYXRoLCBmaWxlLCBodHRwRmlsZU9wdGlvbnMgPSB7fSwgYm9keSA9IHt9LCBoZWFkZXJzID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5odHRwRmlsZU9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IGFwaVBhcmFtcy5jb25maWc7XG4gICAgY29uc3QgcG9wdWxhdGVBdXRoSGVhZGVyID0gYXBpUGFyYW1zLnBvcHVsYXRlQXV0aEhlYWRlcjtcbiAgICB0cnkge1xuICAgICAgaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMyLmFjY2VwdDtcbiAgICAgIGhlYWRlcnNbXCJYLUNsaWVudC1OYW1lXCJdID0gY29uZmlnLmNsaWVudE5hbWU7XG4gICAgICBhd2FpdCBwb3B1bGF0ZUF1dGhIZWFkZXIob3B0aW9uczIuaXNBdXRoZW50aWNhdGVkLCBoZWFkZXJzKTtcbiAgICAgIGNvbnN0IGJvZHlEYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBPYmplY3Qua2V5cyhib2R5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgYm9keURhdGEuc2V0KGtleSwgYm9keVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgYm9keURhdGEuc2V0KFwiZmlsZVwiLCBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoZmlsZS5idWZmZXIpXSksIGZpbGUuYnVmZmVyTmFtZSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMyLnBhcmFtcyl9YCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGJvZHlEYXRhLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zMi5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3B0aW9uczIuaXNKc29uID8gYXdhaXQgcmVzcG9uc2UuanNvbigpIDogYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIEFQSSByZXF1ZXN0IGh0dHBGaWxlLCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfTogYCArIEpTT04uc3RyaW5naWZ5KHsgbWV0aG9kLCBwYXRoLCBwYXJhbXM6IG9wdGlvbnMyLnBhcmFtcywgYm9keSwgcmV0dXJuVmFsdWUgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMyLmlzSnNvbiA/IHJldHVyblZhbHVlLm1lc3NhZ2UgOiByZXR1cm5WYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdCBodHRwICR7bWV0aG9kfSAke3BhdGh9ICR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMoXG4gICAgICAgICAgb3B0aW9uczIucGFyYW1zXG4gICAgICAgICl9YCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYXBpL3Bvc3RGaWxlTWV0aG9kLnRzXG52YXIgbG9nZ2VyMTAgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwb3N0RmlsZU1ldGhvZFwiKTtcbmZ1bmN0aW9uIHBvc3RGaWxlTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwRmlsZSA9IGdldEh0dHBGaWxlKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgYm9keSA9IHt9LCBoZWFkZXJzID0ge30sIGZpbGUsIHBvc3RGaWxlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ucG9zdEZpbGVPcHRpb25zXG4gICAgfTtcbiAgICBsb2dnZXIxMC5kZWJ1ZyhcImh0dHBQb3N0RmlsZURhdGEgUmVxdWVzdDogJXMsICVqXCIsIHBhdGgsIG9wdGlvbnMyKTtcbiAgICBsb2dnZXIxMC5kZWZhdWx0KFwiaHR0cFBvc3RGaWxlRGF0YSBSZXF1ZXN0IEJvZHk6ICVqXCIsIGJvZHkpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwRmlsZShcbiAgICAgIFwiUE9TVFwiLFxuICAgICAgcGF0aCxcbiAgICAgIGZpbGUsXG4gICAgICBvcHRpb25zMixcbiAgICAgIGJvZHksXG4gICAgICBoZWFkZXJzXG4gICAgKTtcbiAgICBsb2dnZXIxMC5kZWZhdWx0KFwiaHR0cFBvc3RGaWxlRGF0YSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3VwbG9hZEFzeW5jTWV0aG9kLnRzXG5mdW5jdGlvbiB1cGxvYWRBc3luY01ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoKSA9PiAoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgZmllbGROYW1lOiBcImZpbGVcIixcbiAgICBoZWFkZXJzOiB7fVxuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCB1cmksIHVwbG9hZEFzeW5jT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cygpLFxuICAgICAgLi4udXBsb2FkQXN5bmNPcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBhcGlQYXJhbXMuY29uZmlnO1xuICAgIGNvbnN0IHBvcHVsYXRlQXV0aEhlYWRlciA9IGFwaVBhcmFtcy5wb3B1bGF0ZUF1dGhIZWFkZXI7XG4gICAgY29uc3QgdXBsb2FkQXN5bmNGaWxlID0gYXBpUGFyYW1zLnVwbG9hZEFzeW5jRmlsZTtcbiAgICB0cnkge1xuICAgICAgb3B0aW9uczIuaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMyLmFjY2VwdDtcbiAgICAgIGF3YWl0IHBvcHVsYXRlQXV0aEhlYWRlcihvcHRpb25zMi5pc0F1dGhlbnRpY2F0ZWQsIG9wdGlvbnMyLmhlYWRlcnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkQXN5bmNGaWxlKFxuICAgICAgICBgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMyLnBhcmFtcyl9YCxcbiAgICAgICAgdXJpLFxuICAgICAgICBvcHRpb25zMi5tZXRob2QsXG4gICAgICAgIFwibXVsdGlwYXJ0XCIsXG4gICAgICAgIG9wdGlvbnMyLmZpZWxkTmFtZSxcbiAgICAgICAgb3B0aW9uczIuaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3B0aW9uczIuaXNKc29uID8gSlNPTi5wYXJzZShyZXN1bHQuYm9keSkgOiByZXN1bHQuYm9keTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIEFQSSByZXF1ZXN0IGh0dHAgJHtvcHRpb25zMi5tZXRob2R9ICR7cGF0aH0gJHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhcbiAgICAgICAgICBvcHRpb25zMi5wYXJhbXNcbiAgICAgICAgKX1gLFxuICAgICAgICBlXG4gICAgICApO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hcGkudHNcbnZhciBnZXRIdHRwQXBpID0gKGFwaVBhcmFtcykgPT4ge1xuICBjb25zdCBodHRwRGVsZXRlID0gZGVsZXRlTWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBHZXQgPSBnZXRNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cFBvc3QgPSBwb3N0TWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBQdXQgPSBwdXRNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cE9wdGlvbnMgPSBvcHRpb25zTWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBDb25uZWN0ID0gY29ubmVjdE1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwVHJhY2UgPSB0cmFjZU1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwUGF0Y2ggPSBwYXRjaE1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwUG9zdEZpbGUgPSBwb3N0RmlsZU1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCB1cGxvYWRBc3luYyA9IHVwbG9hZEFzeW5jTWV0aG9kKGFwaVBhcmFtcyk7XG4gIHJldHVybiB7XG4gICAgaHR0cERlbGV0ZSxcbiAgICBodHRwR2V0LFxuICAgIGh0dHBQdXQsXG4gICAgaHR0cFBvc3QsXG4gICAgaHR0cFBvc3RGaWxlLFxuICAgIHVwbG9hZEFzeW5jLFxuICAgIGh0dHBPcHRpb25zLFxuICAgIGh0dHBDb25uZWN0LFxuICAgIGh0dHBUcmFjZSxcbiAgICBodHRwUGF0Y2hcbiAgfTtcbn07XG5cbi8vIHNyYy9zaW1wbGUtYXBpLnRzXG52YXIgZGVmYXVsdEFwaVBhcmFtcyA9IHtcbiAgY29uZmlnOiB7XG4gICAgdXJsOiBcIlwiLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgIGNsaWVudE5hbWU6IFwiZmplbGwtaHR0cC1hcGktZXhhbXBsZXNcIlxuICB9LFxuICBwb3B1bGF0ZUF1dGhIZWFkZXI6IGFzeW5jIChpc0F1dGhlbnRpY2F0ZWQsIGhlYWRlcnMpID0+IHtcbiAgICBpZiAoaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmVhcmVyIGV4YW1wbGUtdG9rZW5cIjtcbiAgICB9XG4gIH0sXG4gIHVwbG9hZEFzeW5jRmlsZTogYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzdWNjZXNzOiB0cnVlIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBnZXRJbXBsID0gZ2V0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIHBvc3RJbXBsID0gcG9zdE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBwdXRJbXBsID0gcHV0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIG9wdGlvbnNJbXBsID0gb3B0aW9uc01ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBjb25uZWN0SW1wbCA9IGNvbm5lY3RNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgdHJhY2VJbXBsID0gdHJhY2VNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgcGF0Y2hJbXBsID0gcGF0Y2hNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgZGVsZXRlSW1wbCA9IGRlbGV0ZU1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBwb3N0RmlsZUltcGwgPSBwb3N0RmlsZU1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciB1cGxvYWRBc3luY0ltcGwgPSB1cGxvYWRBc3luY01ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBnZXQgPSAocGF0aCwgb3B0aW9uczIpID0+IHtcbiAgcmV0dXJuIGdldEltcGwocGF0aCwgb3B0aW9uczIpO1xufTtcbnZhciBwb3N0ID0gKHBhdGgsIGJvZHksIG9wdGlvbnMyKSA9PiB7XG4gIHJldHVybiBwb3N0SW1wbChwYXRoLCBib2R5LCBvcHRpb25zMik7XG59O1xudmFyIHB1dCA9IChwYXRoLCBib2R5LCBvcHRpb25zMikgPT4ge1xuICByZXR1cm4gcHV0SW1wbChwYXRoLCBib2R5LCBvcHRpb25zMik7XG59O1xudmFyIGRlbGV0ZU1ldGhvZDIgPSAocGF0aCwgYm9keSwgb3B0aW9uczIpID0+IHtcbiAgcmV0dXJuIGRlbGV0ZUltcGwocGF0aCwgYm9keSwgb3B0aW9uczIpO1xufTtcbnZhciBvcHRpb25zID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgcmV0dXJuIG9wdGlvbnNJbXBsKHBhdGgsIG9wdHMpO1xufTtcbnZhciBjb25uZWN0ID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgcmV0dXJuIGNvbm5lY3RJbXBsKHBhdGgsIG9wdHMpO1xufTtcbnZhciB0cmFjZSA9IChwYXRoLCBvcHRzKSA9PiB7XG4gIHJldHVybiB0cmFjZUltcGwocGF0aCwgb3B0cyk7XG59O1xudmFyIHBhdGNoID0gKHBhdGgsIGJvZHksIG9wdHMpID0+IHtcbiAgcmV0dXJuIHBhdGNoSW1wbChwYXRoLCBib2R5LCBvcHRzKTtcbn07XG52YXIgcG9zdEZpbGVNZXRob2QyID0gKHBhdGgsIGZpbGUsIG9wdGlvbnMyKSA9PiB7XG4gIGNvbnN0IGZpbGVCdWZmZXIgPSB7XG4gICAgYnVmZmVyOiBCdWZmZXIuZnJvbShbXSksXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3b3VsZCBuZWVkIHByb3BlciBGaWxlIHJlYWRpbmcgaW4gYnJvd3NlclxuICAgIGJ1ZmZlck5hbWU6IGZpbGUubmFtZVxuICB9O1xuICByZXR1cm4gcG9zdEZpbGVJbXBsKHBhdGgsIHt9LCB7fSwgZmlsZUJ1ZmZlciwgb3B0aW9uczIpO1xufTtcbnZhciB1cGxvYWRBc3luY01ldGhvZDIgPSAocGF0aCwgdXJpLCBvcHRpb25zMikgPT4ge1xuICByZXR1cm4gdXBsb2FkQXN5bmNJbXBsKHBhdGgsIHVyaSwgb3B0aW9uczIpO1xufTtcbmV4cG9ydCB7XG4gIEFQSUVycm9yLFxuICBCYWRSZXF1ZXN0RXJyb3IsXG4gIENsaWVudEVycm9yLFxuICBDb25mbGljdEVycm9yLFxuICBGb3JiaWRkZW5FcnJvcixcbiAgR29uZUVycm9yLFxuICBJbnRlcm5hbFNlcnZlckVycm9yLFxuICBNZXRob2ROb3RBbGxvd2VkRXJyb3IsXG4gIE5vdEZvdW5kRXJyb3IsXG4gIE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIFJlcXVlc3RUaW1lb3V0RXJyb3IsXG4gIFNlcnZlckVycm9yLFxuICBTZXJ2aWNlVW5hdmFpbGFibGVFcnJvcixcbiAgVG9vTWFueVJlcXVlc3RzRXJyb3IsXG4gIFVuYXV0aG9yaXplZEVycm9yLFxuICBjb25uZWN0LFxuICBjb25uZWN0TWV0aG9kLFxuICBkZWxldGVNZXRob2QyIGFzIGRlbGV0ZU1ldGhvZCxcbiAgZ2V0LFxuICBnZXRIdHRwLFxuICBnZXRIdHRwQXBpLFxuICBnZXRIdHRwRmlsZSxcbiAgZ2V0TWV0aG9kLFxuICBvcHRpb25zLFxuICBvcHRpb25zTWV0aG9kLFxuICBwYXRjaCxcbiAgcGF0Y2hNZXRob2QsXG4gIHBvc3QsXG4gIHBvc3RGaWxlTWV0aG9kMiBhcyBwb3N0RmlsZU1ldGhvZCxcbiAgcG9zdE1ldGhvZCxcbiAgcHV0LFxuICBwdXRNZXRob2QsXG4gIHRyYWNlLFxuICB0cmFjZU1ldGhvZCxcbiAgdXBsb2FkQXN5bmNNZXRob2QyIGFzIHVwbG9hZEFzeW5jTWV0aG9kXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../fjell-providers/node_modules/@fjell/http-api/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-providers/node_modules/@fjell/logging/dist/index.js":
/*!********************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/logging/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9AZmplbGwvbG9nZ2luZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsS0FBSztBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEtBQUs7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkIsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQU1wQjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvQGZqZWxsL2xvZ2dpbmcvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvTG9nRm9ybWF0LnRzXG52YXIgTG9nRm9ybWF0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KExvZ0Zvcm1hdF9leHBvcnRzLCB7XG4gIExvZ0Zvcm1hdHM6ICgpID0+IExvZ0Zvcm1hdHMsXG4gIFNUUlVDVFVSRUQ6ICgpID0+IFNUUlVDVFVSRUQsXG4gIFRFWFQ6ICgpID0+IFRFWFQsXG4gIGdldENvbmZpZzogKCkgPT4gZ2V0Q29uZmlnXG59KTtcbnZhciBURVhUID0ge1xuICBuYW1lOiBcIlRFWFRcIixcbiAgZGVzY3JpcHRpb246IFwiVGV4dCBmb3JtYXRcIlxufTtcbnZhciBTVFJVQ1RVUkVEID0ge1xuICBuYW1lOiBcIlNUUlVDVFVSRURcIixcbiAgZGVzY3JpcHRpb246IFwiU3RydWN0dXJlZCBmb3JtYXRcIlxufTtcbnZhciBMb2dGb3JtYXRzID0gW1xuICBURVhULFxuICBTVFJVQ1RVUkVEXG5dO1xudmFyIGdldENvbmZpZyA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0Zvcm1hdHMuZmluZCgoY29uZmlnMikgPT4gY29uZmlnMi5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG9nIEZvcm1hdCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8vIHNyYy9Mb2dMZXZlbC50c1xudmFyIExvZ0xldmVsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KExvZ0xldmVsX2V4cG9ydHMsIHtcbiAgQUxFUlQ6ICgpID0+IEFMRVJULFxuICBDUklUSUNBTDogKCkgPT4gQ1JJVElDQUwsXG4gIERFQlVHOiAoKSA9PiBERUJVRyxcbiAgREVGQVVMVDogKCkgPT4gREVGQVVMVCxcbiAgRU1FUkdFTkNZOiAoKSA9PiBFTUVSR0VOQ1ksXG4gIEVSUk9SOiAoKSA9PiBFUlJPUixcbiAgSU5GTzogKCkgPT4gSU5GTyxcbiAgTG9nTGV2ZWxzOiAoKSA9PiBMb2dMZXZlbHMsXG4gIE5PVElDRTogKCkgPT4gTk9USUNFLFxuICBUUkFDRTogKCkgPT4gVFJBQ0UsXG4gIFdBUk5JTkc6ICgpID0+IFdBUk5JTkcsXG4gIGdldENvbmZpZzogKCkgPT4gZ2V0Q29uZmlnMlxufSk7XG52YXIgRU1FUkdFTkNZID0ge1xuICBuYW1lOiBcIkVNRVJHRU5DWVwiLFxuICB2YWx1ZTogMFxufTtcbnZhciBBTEVSVCA9IHtcbiAgbmFtZTogXCJBTEVSVFwiLFxuICB2YWx1ZTogMVxufTtcbnZhciBDUklUSUNBTCA9IHtcbiAgbmFtZTogXCJDUklUSUNBTFwiLFxuICB2YWx1ZTogMlxufTtcbnZhciBFUlJPUiA9IHtcbiAgbmFtZTogXCJFUlJPUlwiLFxuICB2YWx1ZTogM1xufTtcbnZhciBXQVJOSU5HID0ge1xuICBuYW1lOiBcIldBUk5JTkdcIixcbiAgdmFsdWU6IDRcbn07XG52YXIgTk9USUNFID0ge1xuICBuYW1lOiBcIk5PVElDRVwiLFxuICB2YWx1ZTogNVxufTtcbnZhciBJTkZPID0ge1xuICBuYW1lOiBcIklORk9cIixcbiAgdmFsdWU6IDZcbn07XG52YXIgREVCVUcgPSB7XG4gIG5hbWU6IFwiREVCVUdcIixcbiAgdmFsdWU6IDdcbn07XG52YXIgVFJBQ0UgPSB7XG4gIG5hbWU6IFwiVFJBQ0VcIixcbiAgdmFsdWU6IDhcbn07XG52YXIgREVGQVVMVCA9IHtcbiAgbmFtZTogXCJERUZBVUxUXCIsXG4gIHZhbHVlOiA5XG59O1xudmFyIExvZ0xldmVscyA9IFtcbiAgRU1FUkdFTkNZLFxuICBBTEVSVCxcbiAgQ1JJVElDQUwsXG4gIEVSUk9SLFxuICBXQVJOSU5HLFxuICBOT1RJQ0UsXG4gIElORk8sXG4gIERFQlVHLFxuICBUUkFDRSxcbiAgREVGQVVMVFxuXTtcbnZhciBnZXRDb25maWcyID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gTG9nTGV2ZWxzLmZpbmQoKGNvbmZpZzIpID0+IGNvbmZpZzIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBMZXZlbCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8vIHNyYy9jb25maWcudHNcbnZhciBkZWZhdWx0TG9nTGV2ZWwgPSBJTkZPO1xudmFyIGRlZmF1bHRMb2dGb3JtYXQgPSBURVhUO1xudmFyIGRlZmF1bHRMb2dnaW5nQ29uZmlnID0ge1xuICBsb2dMZXZlbDogZGVmYXVsdExvZ0xldmVsLFxuICBsb2dGb3JtYXQ6IGRlZmF1bHRMb2dGb3JtYXQsXG4gIG92ZXJyaWRlczoge30sXG4gIGZsb29kQ29udHJvbDoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHRocmVzaG9sZDogMTAsXG4gICAgdGltZWZyYW1lOiAxZTNcbiAgICAvLyAxIHNlY29uZFxuICB9XG59O1xudmFyIGNvbnZlcnRPdmVycmlkZXMgPSAob3ZlcnJpZGVzKSA9PiB7XG4gIGNvbnN0IGNvbnZlcnRlZE92ZXJyaWRlcyA9IHt9O1xuICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMob3ZlcnJpZGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGNvbnZlcnRlZE92ZXJyaWRlc1trZXldID0geyBsb2dMZXZlbDogdmFsdWUubG9nTGV2ZWwgPyBnZXRDb25maWcyKHZhbHVlLmxvZ0xldmVsKSA6IGRlZmF1bHRMb2dMZXZlbCB9O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPdmVycmlkZXM7XG59O1xudmFyIGNvbnZlcnRDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbG9nTGV2ZWw6IGNvbmZpZy5sb2dMZXZlbCA/IGdldENvbmZpZzIoY29uZmlnLmxvZ0xldmVsKSA6IGRlZmF1bHRMb2dMZXZlbCxcbiAgICBsb2dGb3JtYXQ6IGNvbmZpZy5sb2dGb3JtYXQgPyBnZXRDb25maWcoY29uZmlnLmxvZ0Zvcm1hdCkgOiBkZWZhdWx0TG9nRm9ybWF0LFxuICAgIG92ZXJyaWRlczogY29udmVydE92ZXJyaWRlcyhjb25maWcub3ZlcnJpZGVzKSxcbiAgICBmbG9vZENvbnRyb2w6IHtcbiAgICAgIC4uLmRlZmF1bHRMb2dnaW5nQ29uZmlnLmZsb29kQ29udHJvbCxcbiAgICAgIC4uLmNvbmZpZy5mbG9vZENvbnRyb2wgfHwge31cbiAgICB9XG4gIH07XG59O1xudmFyIGNvbmZpZ3VyZUxvZ2dpbmcgPSAoKSA9PiB7XG4gIGxldCBjb25maWcgPSB7fTtcbiAgY29uc3QgbG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkxPR0dJTkdfQ09ORklHO1xuICBjb25zdCBleHBvTG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBjb25zdCBuZXh0TG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBsZXQgbG9nTGV2ZWxFbnYgPSBwcm9jZXNzLmVudi5MT0dfTEVWRUw7XG4gIGxldCBsb2dGb3JtYXRFbnYgPSBwcm9jZXNzLmVudi5MT0dfRk9STUFUO1xuICBpZiAobG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKGxvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIExPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwb0xvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShleHBvTG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gRVhQT19QVUJMSUNfTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0TG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKG5leHRMb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnZlcnRlZENvbmZpZyA9IGNvbnZlcnRDb25maWcoY29uZmlnKTtcbiAgaWYgKGxvZ0xldmVsRW52KSB7XG4gICAgbG9nTGV2ZWxFbnYgPSBsb2dMZXZlbEVudj8udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBsb2dMZXZlbENvbmZpZyA9IGdldENvbmZpZzIobG9nTGV2ZWxFbnYpO1xuICAgIGNvbnZlcnRlZENvbmZpZy5sb2dMZXZlbCA9IGxvZ0xldmVsQ29uZmlnO1xuICB9XG4gIGlmIChsb2dGb3JtYXRFbnYpIHtcbiAgICBsb2dGb3JtYXRFbnYgPSBsb2dGb3JtYXRFbnYudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBsb2dGb3JtYXRDb25maWcgPSBnZXRDb25maWcobG9nRm9ybWF0RW52KTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nRm9ybWF0ID0gbG9nRm9ybWF0Q29uZmlnO1xuICB9XG4gIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZywgLi4uY29udmVydGVkQ29uZmlnIH07XG4gIHJldHVybiBmaW5hbENvbmZpZztcbn07XG5cbi8vIHNyYy9Xcml0ZXIudHNcbnZhciBjcmVhdGVXcml0ZXIgPSAoZm9ybWF0dGVyLCBsb2dNZXRob2QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVzcGVjdEluamVjdGVkTWV0aG9kID0gZmFsc2UsXG4gICAgZXJyb3JNZXRob2QgPSBjb25zb2xlLmVycm9yLFxuICAgIHdhcm5pbmdNZXRob2QgPSBjb25zb2xlLndhcm4sXG4gICAgaW5mb01ldGhvZCA9IGNvbnNvbGUubG9nXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4ge1xuICAgIHdyaXRlOiAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgICBsZXQgZmluYWxMb2dNZXRob2QgPSBsb2dNZXRob2Q7XG4gICAgICBpZiAoIXJlc3BlY3RJbmplY3RlZE1ldGhvZCkge1xuICAgICAgICBpZiAobGV2ZWwubmFtZSA9PT0gRVJST1IubmFtZSB8fCBsZXZlbC5uYW1lID09PSBDUklUSUNBTC5uYW1lIHx8IGxldmVsLm5hbWUgPT09IEFMRVJULm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gRU1FUkdFTkNZLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGVycm9yTWV0aG9kO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsLm5hbWUgPT09IFdBUk5JTkcubmFtZSkge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gd2FybmluZ01ldGhvZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGluZm9NZXRob2Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmFsTG9nTWV0aG9kKGZvcm1hdHRlci5mb3JtYXRMb2cobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2Zvcm1hdHRlci50c1xuaW1wb3J0IHV0aWwgZnJvbSBcInV0aWxcIjtcbnZhciBzYWZlSW5zcGVjdCA9IChvYmopID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KG9iaik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgW09iamVjdDogJHt0eXBlb2Ygb2JqfV1gO1xuICB9XG59O1xudmFyIHNhZmVGb3JtYXQgPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1dGlsLmZvcm1hdChtZXNzYWdlLCAuLi5hcmdzKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGAke21lc3NhZ2V9ICR7c2FmZUluc3BlY3QoYXJncyl9YDtcbiAgfVxufTtcbnZhciBjcmVhdGVGb3JtYXR0ZXIgPSAobG9nRm9ybWF0KSA9PiB7XG4gIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJURVhUXCIpIHtcbiAgICByZXR1cm4gZ2V0VGV4dEZvcm1hdHRlcigpO1xuICB9IGVsc2UgaWYgKGxvZ0Zvcm1hdC5uYW1lID09PSBcIlNUUlVDVFVSRURcIikge1xuICAgIHJldHVybiBnZXRTdHJ1Y3R1cmVkRm9ybWF0dGVyKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxvZyBmb3JtYXQ6ICR7bG9nRm9ybWF0Lm5hbWV9YCk7XG59O1xudmFyIGdldFRleHRGb3JtYXR0ZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGZvcm1hdExvZyA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG4gICAgbGV0IGxvZ01lc3NhZ2U7XG4gICAgaWYgKHBheWxvYWQuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBwYXlsb2FkLm1lc3NhZ2U7XG4gICAgfSBlbHNlIGlmIChoYXNTcGVjaWZpZXJzKSB7XG4gICAgICBsb2dNZXNzYWdlID0gc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBgJHtwYXlsb2FkLm1lc3NhZ2V9ICR7c2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCgkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpfSkgWyR7bGV2ZWwubmFtZX1dIC0gWyR7Y29vcmRpbmF0ZXMuY2F0ZWdvcnl9XSAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9ICR7bG9nTWVzc2FnZX1gO1xuICB9O1xuICBjb25zdCB0aW1lck1lc3NhZ2UgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgcmFuZG9tSW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU2KTtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UyID0gYCgkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpfSkgWyR7bGV2ZWwubmFtZX1dIC0gWyR7Y29vcmRpbmF0ZXMuY2F0ZWdvcnl9XSAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9ICR7c2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSl9ICR7c2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKX0gJHtyYW5kb21JbnR9YDtcbiAgICByZXR1cm4gdGltZXJNZXNzYWdlMjtcbiAgfTtcbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gVEVYVCB9O1xufTtcbnZhciBnZXRTdHJ1Y3R1cmVkRm9ybWF0dGVyID0gKCkgPT4ge1xuICBjb25zdCBmb3JtYXRMb2cgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3Qgc2V2ZXJpdHkgPSBsZXZlbC5uYW1lO1xuICAgIGNvbnN0IGhhc1NwZWNpZmllcnMgPSAvJVtzZGppZm9PJV0vLnRlc3QocGF5bG9hZC5tZXNzYWdlKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc2V2ZXJpdHksXG4gICAgICBtZXNzYWdlOiBoYXNTcGVjaWZpZXJzID8gc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSkgOiBwYXlsb2FkLm1lc3NhZ2UsXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vbGFiZWxzXCI6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBgJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfWBcbiAgICAgIH0sXG4gICAgICAuLi4haGFzU3BlY2lmaWVycyAmJiBwYXlsb2FkLmRhdGEubGVuZ3RoID4gMCAmJiB7IGRhdGE6IHNhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSkgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB0aW1lck1lc3NhZ2UgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3Qgc2V2ZXJpdHkgPSBsZXZlbC5uYW1lO1xuICAgIGNvbnN0IHJhbmRvbUludCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSksXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vbGFiZWxzXCI6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBgJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfWBcbiAgICAgIH0sXG4gICAgICBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL3NwYW5JZFwiOiBTdHJpbmcocmFuZG9tSW50KVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4geyBmb3JtYXRMb2csIHRpbWVyTWVzc2FnZSwgZ2V0TG9nRm9ybWF0OiAoKSA9PiBTVFJVQ1RVUkVEIH07XG59O1xuXG4vLyBzcmMvRmxvb2RDb250cm9sLnRzXG5pbXBvcnQgdXRpbDIgZnJvbSBcInV0aWxcIjtcbnZhciBoYXNoID0gKG1lc3NhZ2UsIGRhdGEpID0+IHtcbiAgY29uc3QgZGF0YVN0cmluZyA9IGRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB1dGlsMi5pbnNwZWN0KGl0ZW0pO1xuICAgIH1cbiAgfSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGAke21lc3NhZ2V9JHtkYXRhU3RyaW5nfWA7XG59O1xudmFyIEZsb29kQ29udHJvbCA9IGNsYXNzIHtcbiAgY29uZmlnO1xuICBoaXN0b3J5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3VwcHJlc3NlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNsZWFudXBUaW1lciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuY2xlYW51cCgpLCB0aGlzLmNvbmZpZy50aW1lZnJhbWUgKiAyKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChjb25zdCBbaGFzaDIsIHRpbWVzdGFtcHNdIG9mIHRoaXMuaGlzdG9yeS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHJlY2VudFRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmZpbHRlcihcbiAgICAgICAgKHRpbWVzdGFtcCkgPT4gbm93IC0gdGltZXN0YW1wIDwgdGhpcy5jb25maWcudGltZWZyYW1lXG4gICAgICApO1xuICAgICAgaWYgKHJlY2VudFRpbWVzdGFtcHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmhpc3Rvcnkuc2V0KGhhc2gyLCByZWNlbnRUaW1lc3RhbXBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5kZWxldGUoaGFzaDIpO1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuZGVsZXRlKGhhc2gyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2sobWVzc2FnZSwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIFwibG9nXCI7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSAodGhpcy5oaXN0b3J5LmdldChtZXNzYWdlSGFzaCkgfHwgW10pLmZpbHRlcihcbiAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICk7XG4gICAgdGltZXN0YW1wcy5wdXNoKG5vdyk7XG4gICAgdGhpcy5oaXN0b3J5LnNldChtZXNzYWdlSGFzaCwgdGltZXN0YW1wcyk7XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID4gdGhpcy5jb25maWcudGhyZXNob2xkKSB7XG4gICAgICBjb25zdCBzdXBwcmVzc2VkSW5mbyA9IHRoaXMuc3VwcHJlc3NlZC5nZXQobWVzc2FnZUhhc2gpO1xuICAgICAgaWYgKHN1cHByZXNzZWRJbmZvKSB7XG4gICAgICAgIHN1cHByZXNzZWRJbmZvLmNvdW50Kys7XG4gICAgICAgIHJldHVybiBcInN1cHByZXNzXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuc2V0KG1lc3NhZ2VIYXNoLCB7IGNvdW50OiAxLCBmaXJzdFRpbWVzdGFtcDogdGltZXN0YW1wc1swXSwgc3VtbWFyeUxvZ2dlZDogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiBcInN1cHByZXNzXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnN1cHByZXNzZWQuaGFzKG1lc3NhZ2VIYXNoKSkge1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuZGVsZXRlKG1lc3NhZ2VIYXNoKTtcbiAgICAgICAgcmV0dXJuIFwicmVzdW1lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcImxvZ1wiO1xuICB9XG4gIGdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSB7XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBoYXNoKG1lc3NhZ2UsIGRhdGEpO1xuICAgIHJldHVybiB0aGlzLnN1cHByZXNzZWQuZ2V0KG1lc3NhZ2VIYXNoKT8uY291bnQgfHwgMDtcbiAgfVxufTtcblxuLy8gc3JjL0xvZ2dlci50c1xudmFyIGNyZWF0ZUxvZ2dlciA9IChsb2dGb3JtYXQsIGxvZ0xldmVsLCBjb29yZGluYXRlcywgZmxvb2RDb250cm9sQ29uZmlnLCB3cml0ZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihsb2dGb3JtYXQpO1xuICBjb25zdCBmbG9vZENvbnRyb2wgPSBmbG9vZENvbnRyb2xDb25maWcuZW5hYmxlZCA/IG5ldyBGbG9vZENvbnRyb2woZmxvb2RDb250cm9sQ29uZmlnKSA6IG51bGw7XG4gIGNvbnN0IGxvZ0Z1bmN0aW9uID0gY29uc29sZS5sb2c7XG4gIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlcihmb3JtYXR0ZXIsIGxvZ0Z1bmN0aW9uLCB3cml0ZXJPcHRpb25zKTtcbiAgY29uc3Qgd3JpdGUgPSAobGV2ZWwsIG1lc3NhZ2UsIGRhdGEpID0+IHtcbiAgICBpZiAobG9nTGV2ZWwudmFsdWUgPCBsZXZlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGVjayA9IGZsb29kQ29udHJvbCA/IGZsb29kQ29udHJvbC5jaGVjayhtZXNzYWdlLCBkYXRhKSA6IFwibG9nXCI7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgbWVzc2FnZSwgZGF0YSB9O1xuICAgIHN3aXRjaCAoY2hlY2spIHtcbiAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN1cHByZXNzXCI6XG4gICAgICAgIGlmIChmbG9vZENvbnRyb2wgJiYgZmxvb2RDb250cm9sLmdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICBjb25zdCBuZXdQYXlsb2FkID0geyBtZXNzYWdlOiBgU3RhcnRlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZWAsIGRhdGE6IFtdIH07XG4gICAgICAgICAgd3JpdGVyLndyaXRlKG9yaWdpbmFsTGV2ZWwsIGNvb3JkaW5hdGVzLCBuZXdQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZXN1bWVcIjoge1xuICAgICAgICBjb25zdCBjb3VudCA9IGZsb29kQ29udHJvbCA/IGZsb29kQ29udHJvbC5nZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkgOiAwO1xuICAgICAgICBjb25zdCByZXN1bWVQYXlsb2FkID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IGBTdG9wcGVkIHN1cHByZXNzaW5nIHJlcGVhdGVkIGxvZyBtZXNzYWdlLiBTdXBwcmVzc2VkICR7Y291bnR9IHRpbWVzLmAsXG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcmVzdW1lUGF5bG9hZCk7XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXJ0VGltZUxvZ2dlciA9IChsb2dMZXZlbDIsIGNvb3JkaW5hdGVzMiwgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHRpbWVyTWVzc2FnZSA9IGZvcm1hdHRlci50aW1lck1lc3NhZ2UobG9nTGV2ZWwyLCBjb29yZGluYXRlczIsIHBheWxvYWQpO1xuICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWUodGltZXJNZXNzYWdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWVFbmQodGltZXJNZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgICBsb2c6ICguLi5kYXRhKSA9PiB7XG4gICAgICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWVMb2codGltZXJNZXNzYWdlLCAuLi5kYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGVtZXJnZW5jeTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEVNRVJHRU5DWSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBhbGVydDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEFMRVJULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGNyaXRpY2FsOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoQ1JJVElDQUwsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShFUlJPUiwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB3YXJuaW5nOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoV0FSTklORywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBub3RpY2U6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShOT1RJQ0UsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgaW5mbzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKElORk8sIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShERUJVRywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0cmFjZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKFRSQUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlZmF1bHQ6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShERUZBVUxULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHRpbWU6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG4gICAgICByZXR1cm4gc3RhcnRUaW1lTG9nZ2VyKGxvZ0xldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgfSxcbiAgICBnZXQ6ICguLi5hZGRpdGlvbmFsQ29tcG9uZW50cykgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihsb2dGb3JtYXQsIGxvZ0xldmVsLCB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogWy4uLmNvb3JkaW5hdGVzLmNvbXBvbmVudHMsIC4uLmFkZGl0aW9uYWxDb21wb25lbnRzXVxuICAgICAgfSwgZmxvb2RDb250cm9sQ29uZmlnLCB3cml0ZXJPcHRpb25zKTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgIGlmIChmbG9vZENvbnRyb2wpIHtcbiAgICAgICAgZmxvb2RDb250cm9sLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbG9nZ2luZy50c1xudmFyIGdldExvZ2dlciA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ3VyZUxvZ2dpbmcoKTtcbiAgY29uc3QgbG9nZ2VyID0gY3JlYXRlQmFzZUxvZ2dlcihuYW1lLCBjb25maWcpO1xuICByZXR1cm4gbG9nZ2VyO1xufTtcbnZhciBjcmVhdGVCYXNlTG9nZ2VyID0gKG5hbWUsIGNvbmZpZykgPT4ge1xuICBsZXQgeyBsb2dMZXZlbCB9ID0gY29uZmlnO1xuICBjb25zdCB7IGxvZ0Zvcm1hdCwgZmxvb2RDb250cm9sIH0gPSBjb25maWc7XG4gIGNvbnN0IG92ZXJyaWRlcyA9IGNvbmZpZy5vdmVycmlkZXM7XG4gIGlmIChvdmVycmlkZXMgJiYgb3ZlcnJpZGVzW25hbWVdKSB7XG4gICAgbG9nTGV2ZWwgPSBvdmVycmlkZXNbbmFtZV0ubG9nTGV2ZWw7XG4gIH1cbiAgY29uc3QgY29vcmRpbmF0ZXMgPSB7IGNhdGVnb3J5OiBuYW1lLCBjb21wb25lbnRzOiBbXSB9O1xuICByZXR1cm4gY3JlYXRlTG9nZ2VyKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBmbG9vZENvbnRyb2wpO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IHsgZ2V0TG9nZ2VyIH07XG5leHBvcnQge1xuICBMb2dGb3JtYXRfZXhwb3J0cyBhcyBMb2dGb3JtYXQsXG4gIExvZ0xldmVsX2V4cG9ydHMgYXMgTG9nTGV2ZWwsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZ2V0TG9nZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-providers/node_modules/@fjell/registry/dist/index.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/registry/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = (kta, scopes = []) => {\n  const ktArray = Array.isArray(kta) ? kta : [kta];\n  const toString = () => {\n    logger.debug(\"toString\", { kta, scopes });\n    return `${ktArray.join(\", \")} - ${scopes.join(\", \")}`;\n  };\n  logger.debug(\"createCoordinate\", { kta: ktArray, scopes, toString });\n  return { kta: ktArray, scopes, toString };\n};\n\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate) => {\n  logger2.debug(\"createInstance\", { coordinate, registry });\n  return { coordinate, registry };\n};\nvar isInstance = (instance) => {\n  return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n\n// src/RegistryStats.ts\nvar RegistryStats = class {\n  totalCalls = 0;\n  // Map structure: ktaKey -> scopeKey -> clientKey -> count\n  coordinateCalls = /* @__PURE__ */ new Map();\n  /**\n   * Records a get() call for the specified coordinate and client\n   */\n  recordGetCall(kta, scopes, client) {\n    this.totalCalls++;\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    if (!this.coordinateCalls.has(ktaKey)) {\n      this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n    }\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap.has(scopeKey)) {\n      scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n    }\n    const clientMap = scopeMap.get(scopeKey);\n    const currentCount = clientMap.get(clientKey) || 0;\n    clientMap.set(clientKey, currentCount + 1);\n  }\n  /**\n   * Gets the current statistics snapshot\n   */\n  getStatistics() {\n    const coordinateCallRecords = [];\n    let serviceCalls = 0;\n    let applicationCalls = 0;\n    let unidentifiedCalls = 0;\n    for (const [ktaKey, scopeMap] of this.coordinateCalls) {\n      for (const [scopeKey, clientMap] of scopeMap) {\n        const clientCalls = [];\n        let totalCount = 0;\n        for (const [clientKey, count] of clientMap) {\n          const client = this.parseClientKey(clientKey);\n          if (client !== null) {\n            clientCalls.push({ client, count });\n          }\n          totalCount += count;\n          if (clientKey === \"__no_client__\") {\n            unidentifiedCalls += count;\n          } else if (typeof client === \"string\") {\n            applicationCalls += count;\n          } else if (client !== null) {\n            serviceCalls += count;\n          }\n        }\n        coordinateCallRecords.push({\n          kta: ktaKey.split(\".\"),\n          scopes: this.parseScopeKey(scopeKey),\n          count: totalCount,\n          clientCalls: [...clientCalls]\n          // Return a copy\n        });\n      }\n    }\n    return {\n      totalGetCalls: this.totalCalls,\n      coordinateCallRecords: [...coordinateCallRecords],\n      // Return a copy\n      clientSummary: {\n        serviceCalls,\n        applicationCalls,\n        unidentifiedCalls\n      }\n    };\n  }\n  /**\n   * Gets call count for a specific coordinate combination\n   */\n  getCallCount(kta, scopes) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    let total = 0;\n    for (const count of clientMap.values()) {\n      total += count;\n    }\n    return total;\n  }\n  /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */\n  getCallCountByClient(kta, scopes, client) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    return clientMap.get(clientKey) || 0;\n  }\n  /**\n   * Gets total calls for a specific kta (across all scopes)\n   */\n  getTotalCallsForKta(kta) {\n    const ktaKey = kta.join(\".\");\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    let total = 0;\n    for (const clientMap of scopeMap.values()) {\n      for (const count of clientMap.values()) {\n        total += count;\n      }\n    }\n    return total;\n  }\n  /**\n   * Gets all unique kta paths that have been called\n   */\n  getCalledKtaPaths() {\n    const ktaPaths = [];\n    for (const ktaKey of this.coordinateCalls.keys()) {\n      ktaPaths.push(ktaKey.split(\".\"));\n    }\n    return ktaPaths;\n  }\n  /**\n   * Creates a normalized scope key from scopes array\n   */\n  createScopeKey(scopes) {\n    if (scopes.length === 0) return \"__no_scopes__\";\n    return [...scopes].sort().join(\",\");\n  }\n  /**\n   * Parses a scope key back to scopes array\n   */\n  parseScopeKey(scopeKey) {\n    if (scopeKey === \"__no_scopes__\") return [];\n    return scopeKey.split(\",\");\n  }\n  /**\n   * Creates a normalized client key from client identifier\n   */\n  createClientKey(client) {\n    if (!client) return \"__no_client__\";\n    if (typeof client === \"string\") {\n      return `app:${client}`;\n    }\n    const coordKey = `${client.coordinate.kta.join(\".\")};${this.createScopeKey(client.coordinate.scopes)}`;\n    return `service:${client.registryType}:${coordKey}`;\n  }\n  /**\n   * Parses a client key back to client identifier\n   */\n  parseClientKey(clientKey) {\n    if (clientKey === \"__no_client__\") return null;\n    if (clientKey.startsWith(\"app:\")) {\n      return clientKey.substring(4);\n    }\n    if (clientKey.startsWith(\"service:\")) {\n      const parts = clientKey.substring(8).split(\":\");\n      if (parts.length !== 2) return null;\n      const registryType = parts[0];\n      const coordParts = parts[1].split(\";\");\n      if (coordParts.length !== 2) return null;\n      const kta = coordParts[0].split(\".\");\n      const scopes = this.parseScopeKey(coordParts[1]);\n      return {\n        registryType,\n        coordinate: { kta, scopes }\n      };\n    }\n    return null;\n  }\n};\n\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes) => {\n  if (!requestedScopes || requestedScopes.length === 0) {\n    const firstInstance = scopedInstances[0]?.instance;\n    if (!firstInstance) {\n      throw new Error(\"No instances available\");\n    }\n    return firstInstance;\n  }\n  const matchingInstance = scopedInstances.find((scopedInstance) => {\n    if (!scopedInstance.scopes) return false;\n    return requestedScopes.every(\n      (scope) => scopedInstance.scopes && scopedInstance.scopes.includes(scope)\n    );\n  });\n  if (!matchingInstance) {\n    throw new Error(`No instance found matching scopes: ${requestedScopes.join(\", \")}`);\n  }\n  return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub) => {\n  const instanceTree = {};\n  const registryStats = new RegistryStats();\n  const createProxiedRegistry = (callingCoordinate) => {\n    const serviceClient = {\n      registryType: type,\n      coordinate: {\n        kta: callingCoordinate.kta,\n        scopes: callingCoordinate.scopes\n      }\n    };\n    return {\n      ...registry,\n      get: (kta, options) => {\n        const clientToUse = options?.client || serviceClient;\n        return registry.get(kta, { ...options, client: clientToUse });\n      }\n    };\n  };\n  const createInstance2 = (kta, scopes, factory) => {\n    logger3.debug(`Creating and registering instance for key path and scopes`, kta, scopes, `in registry type: ${type}`);\n    const coordinate = createCoordinate(kta, scopes);\n    const proxiedRegistry = createProxiedRegistry(coordinate);\n    const instance = factory(coordinate, {\n      registry: proxiedRegistry,\n      registryHub\n    });\n    if (!isInstance(instance)) {\n      throw new Error(`Factory did not return a valid instance for: ${kta.join(\".\")}`);\n    }\n    registerInternal(kta, instance, { scopes });\n    return instance;\n  };\n  const registerInternal = (kta, instance, options) => {\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    logger3.debug(`Registering instance for key path and scopes`, keyPath, options?.scopes, `in registry type: ${type}`);\n    if (!isInstance(instance)) {\n      throw new Error(`Attempting to register a non-instance: ${kta.join(\".\")}`);\n    }\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        currentLevel[keyType] = {\n          instances: [],\n          children: isLeaf ? null : {}\n        };\n      }\n      if (isLeaf) {\n        currentLevel[keyType].instances.push({\n          scopes: options?.scopes,\n          instance\n        });\n      } else {\n        if (!currentLevel[keyType].children) {\n          currentLevel[keyType].children = {};\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n  };\n  const register = (kta, instance, options) => {\n    logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n    registerInternal(kta, instance, options);\n  };\n  const get = (kta, options) => {\n    registryStats.recordGetCall(kta, options?.scopes, options?.client);\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        throw new Error(`Instance not found for key path: ${kta.join(\".\")}, Missing key: ${keyType}`);\n      }\n      if (isLeaf) {\n        const scopedInstances = currentLevel[keyType].instances;\n        if (scopedInstances.length === 0) {\n          throw new Error(`No instances registered for key path: ${kta.join(\".\")}`);\n        }\n        return findScopedInstance(scopedInstances, options?.scopes);\n      } else {\n        if (!currentLevel[keyType].children) {\n          throw new Error(`Instance not found for key path: ${kta.join(\".\")}, No children for: ${keyType}`);\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n    return null;\n  };\n  const getCoordinates = () => {\n    const coordinates = [];\n    const traverseTree = (node) => {\n      for (const keyType in node) {\n        const treeNode = node[keyType];\n        for (const scopedInstance of treeNode.instances) {\n          coordinates.push(scopedInstance.instance.coordinate);\n        }\n        if (treeNode.children) {\n          traverseTree(treeNode.children);\n        }\n      }\n    };\n    traverseTree(instanceTree);\n    return coordinates;\n  };\n  const getStatistics = () => {\n    return registryStats.getStatistics();\n  };\n  const registry = {\n    type,\n    registryHub,\n    createInstance: createInstance2,\n    register,\n    get,\n    getCoordinates,\n    getStatistics,\n    instanceTree\n  };\n  return registry;\n};\n\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n  registryType;\n  context;\n  constructor(message, registryType, context) {\n    super(message);\n    this.name = this.constructor.name;\n    this.registryType = registryType;\n    this.context = context;\n    const ErrorConstructor = Error;\n    if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n      ErrorConstructor.captureStackTrace(this, this.constructor);\n    }\n  }\n  getDetails() {\n    const details = [this.message];\n    if (this.registryType) {\n      details.push(`Registry Type: ${this.registryType}`);\n    }\n    if (this.context) {\n      details.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n    }\n    return details.join(\"\\n\");\n  }\n};\nvar RegistryCreationError = class extends RegistryError {\n  constructor(type, reason, context) {\n    super(`Failed to create registry of type '${type}': ${reason}`, type, context);\n  }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n  keyPath;\n  factoryResult;\n  constructor(keyPath, factoryResult, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Factory did not return a valid instance for: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof factoryResult}`,\n      registryType,\n      { keyPath, factoryResult: typeof factoryResult }\n    );\n    this.keyPath = keyPath;\n    this.factoryResult = factoryResult;\n  }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n  keyPath;\n  attemptedRegistration;\n  constructor(keyPath, attemptedRegistration, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Attempting to register a non-instance: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof attemptedRegistration}`,\n      registryType,\n      { keyPath, attemptedRegistration: typeof attemptedRegistration }\n    );\n    this.keyPath = keyPath;\n    this.attemptedRegistration = attemptedRegistration;\n  }\n};\n\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n  hubType;\n  constructor(message, hubType, context) {\n    const enrichedContext = hubType ? { ...context, hubType } : context;\n    super(message, \"\", enrichedContext);\n    this.hubType = hubType;\n  }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n  duplicateType;\n  constructor(type, context) {\n    super(\n      `Registry already registered under type: ${type}. Each registry type must be unique within a registry hub.`,\n      \"\",\n      { ...context, duplicateType: type }\n    );\n    this.duplicateType = type;\n  }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n  requestedType;\n  availableTypes;\n  constructor(requestedType, availableTypes = [], context) {\n    let message = `No registry registered under type: ${requestedType}`;\n    if (availableTypes.length > 0) {\n      message += `. Available types: [${availableTypes.join(\", \")}]`;\n    }\n    super(message, \"\", { ...context, requestedType, availableTypes });\n    this.requestedType = requestedType;\n    this.availableTypes = availableTypes;\n  }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n  factoryError;\n  attemptedType;\n  constructor(type, factoryError, context) {\n    super(\n      `Registry factory failed to create registry of type '${type}': ${factoryError.message}`,\n      \"\",\n      { ...context, attemptedType: type, originalError: factoryError.message }\n    );\n    this.factoryError = factoryError;\n    this.attemptedType = type;\n  }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n  factoryResult;\n  attemptedType;\n  constructor(type, factoryResult, context) {\n    super(\n      `Registry factory returned invalid registry for type '${type}'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: ${typeof factoryResult}`,\n      \"\",\n      { ...context, attemptedType: type, factoryResult: typeof factoryResult }\n    );\n    this.factoryResult = factoryResult;\n    this.attemptedType = type;\n  }\n};\n\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = () => {\n  const registries = {};\n  const createRegistry2 = (type, factory) => {\n    logger4.debug(`Creating new registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    const registry = factory(type, hub);\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    registries[type] = registry;\n    logger4.debug(`Successfully created and registered new registry with type: ${type}`);\n    return registry;\n  };\n  const registerRegistry = (registry) => {\n    const type = registry.type;\n    logger4.debug(`Registering registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    registries[type] = registry;\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    logger4.debug(`Successfully registered registry with type: ${type}`);\n  };\n  const get = (type, kta, options) => {\n    logger4.debug(`Looking up instance for type: ${type}, kta: ${kta.join(\".\")}, scopes: ${options?.scopes?.join(\",\") || \"none\"}`);\n    const registry = registries[type];\n    if (!registry) {\n      const availableTypes = Object.keys(registries);\n      throw new RegistryTypeNotFoundError(type, availableTypes);\n    }\n    return registry.get(kta, options);\n  };\n  const getRegistry = (type) => {\n    return registries[type] || null;\n  };\n  const getRegisteredTypes = () => {\n    return Object.keys(registries);\n  };\n  const unregisterRegistry = (type) => {\n    if (registries[type]) {\n      delete registries[type];\n      logger4.debug(`Unregistered registry under type: ${type}`);\n      return true;\n    }\n    return false;\n  };\n  const getAllCoordinates = () => {\n    const allCoordinates = [];\n    for (const registryType in registries) {\n      const registry = registries[registryType];\n      const coordinates = registry.getCoordinates();\n      coordinates.forEach((coordinate) => {\n        allCoordinates.push({\n          coordinate,\n          registryType\n        });\n      });\n    }\n    logger4.debug(`Retrieved ${allCoordinates.length} total coordinates from ${Object.keys(registries).length} registries`);\n    return allCoordinates;\n  };\n  const hub = {\n    createRegistry: createRegistry2,\n    registerRegistry,\n    get,\n    getRegistry,\n    getRegisteredTypes,\n    getAllCoordinates,\n    unregisterRegistry\n  };\n  return hub;\n};\n\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n  keyPath;\n  constructor(message, keyPath, registryType, context) {\n    super(message, registryType, { ...context, keyPath });\n    this.keyPath = keyPath;\n  }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n  missingKey;\n  constructor(keyPath, missingKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    let message = `Instance not found for key path: ${keyPathStr}`;\n    if (missingKey) {\n      message += `, Missing key: ${missingKey}`;\n    }\n    super(message, keyPath, registryType, { ...context, missingKey });\n    this.missingKey = missingKey;\n  }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances registered for key path: ${keyPathStr}. The key path exists in the registry tree but contains no instances.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances available for key path: ${keyPathStr}. This typically indicates an internal registry state issue.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n  requestedScopes;\n  availableScopes;\n  constructor(keyPath, requestedScopes, availableScopes = [], registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    const scopesStr = requestedScopes.join(\", \");\n    const availableScopesStr = availableScopes.map((scopes) => `[${scopes.join(\", \")}]`).join(\", \");\n    let message = `No instance found matching scopes: ${scopesStr} for key path: ${keyPathStr}`;\n    if (availableScopes.length > 0) {\n      message += `. Available scopes: ${availableScopesStr}`;\n    }\n    super(message, keyPath, registryType, { requestedScopes, availableScopes });\n    this.requestedScopes = requestedScopes;\n    this.availableScopes = availableScopes;\n  }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n  parentKey;\n  constructor(keyPath, parentKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Instance not found for key path: ${keyPathStr}, No children for: ${parentKey}. The path cannot be traversed further as '${parentKey}' has no child nodes.`,\n      keyPath,\n      registryType,\n      { ...context, parentKey }\n    );\n    this.parentKey = parentKey;\n  }\n};\n\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n  kta;\n  scopes;\n  constructor(message, kta, scopes, context) {\n    super(message, \"\", { ...context, kta, scopes });\n    this.kta = kta;\n    this.scopes = scopes;\n  }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n  constructor(kta, scopes, reason, context) {\n    super(\n      `Invalid coordinate parameters: ${reason}. KTA: ${JSON.stringify(kta)}, Scopes: [${scopes.join(\", \")}]`,\n      kta,\n      scopes,\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidKTAError = class extends CoordinateError {\n  constructor(kta, reason, context) {\n    super(\n      `Invalid KTA (Key Type Array): ${reason}. Expected string or array of strings, got: ${JSON.stringify(kta)}`,\n      kta,\n      [],\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidScopesError = class extends CoordinateError {\n  invalidScopes;\n  constructor(scopes, invalidScopes, reason, context) {\n    super(\n      `Invalid scopes: ${reason}. Invalid scope values: ${JSON.stringify(invalidScopes)}`,\n      null,\n      scopes.filter((s) => typeof s === \"string\"),\n      { ...context, reason, invalidScopes }\n    );\n    this.invalidScopes = invalidScopes;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9AZmplbGwvcmVnaXN0cnkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDO0FBQ3JDLGdCQUFnQixnRUFBaUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDLGNBQWMsb0JBQW9CLElBQUksa0JBQWtCO0FBQ3hEO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUEyQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9yZWdpc3RyeS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9sb2dnZXIudHNcbmltcG9ydCBMb2dnaW5nIGZyb20gXCJAZmplbGwvbG9nZ2luZ1wiO1xudmFyIExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKFwiQGZqZWxsL3JlZ2lzdHJ5XCIpO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTGliTG9nZ2VyO1xuXG4vLyBzcmMvQ29vcmRpbmF0ZS50c1xudmFyIGxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkNvb3JkaW5hdGVcIik7XG52YXIgY3JlYXRlQ29vcmRpbmF0ZSA9IChrdGEsIHNjb3BlcyA9IFtdKSA9PiB7XG4gIGNvbnN0IGt0QXJyYXkgPSBBcnJheS5pc0FycmF5KGt0YSkgPyBrdGEgOiBba3RhXTtcbiAgY29uc3QgdG9TdHJpbmcgPSAoKSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKFwidG9TdHJpbmdcIiwgeyBrdGEsIHNjb3BlcyB9KTtcbiAgICByZXR1cm4gYCR7a3RBcnJheS5qb2luKFwiLCBcIil9IC0gJHtzY29wZXMuam9pbihcIiwgXCIpfWA7XG4gIH07XG4gIGxvZ2dlci5kZWJ1ZyhcImNyZWF0ZUNvb3JkaW5hdGVcIiwgeyBrdGE6IGt0QXJyYXksIHNjb3BlcywgdG9TdHJpbmcgfSk7XG4gIHJldHVybiB7IGt0YToga3RBcnJheSwgc2NvcGVzLCB0b1N0cmluZyB9O1xufTtcblxuLy8gc3JjL0luc3RhbmNlLnRzXG52YXIgbG9nZ2VyMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkluc3RhbmNlXCIpO1xudmFyIGNyZWF0ZUluc3RhbmNlID0gKHJlZ2lzdHJ5LCBjb29yZGluYXRlKSA9PiB7XG4gIGxvZ2dlcjIuZGVidWcoXCJjcmVhdGVJbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5IH0pO1xuICByZXR1cm4geyBjb29yZGluYXRlLCByZWdpc3RyeSB9O1xufTtcbnZhciBpc0luc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIHJldHVybiBpbnN0YW5jZSAhPT0gbnVsbCAmJiBpbnN0YW5jZSAhPT0gdm9pZCAwICYmIGluc3RhbmNlLmNvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBpbnN0YW5jZS5yZWdpc3RyeSAhPT0gdm9pZCAwO1xufTtcblxuLy8gc3JjL1JlZ2lzdHJ5U3RhdHMudHNcbnZhciBSZWdpc3RyeVN0YXRzID0gY2xhc3Mge1xuICB0b3RhbENhbGxzID0gMDtcbiAgLy8gTWFwIHN0cnVjdHVyZToga3RhS2V5IC0+IHNjb3BlS2V5IC0+IGNsaWVudEtleSAtPiBjb3VudFxuICBjb29yZGluYXRlQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogUmVjb3JkcyBhIGdldCgpIGNhbGwgZm9yIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBhbmQgY2xpZW50XG4gICAqL1xuICByZWNvcmRHZXRDYWxsKGt0YSwgc2NvcGVzLCBjbGllbnQpIHtcbiAgICB0aGlzLnRvdGFsQ2FsbHMrKztcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG4gICAgY29uc3QgY2xpZW50S2V5ID0gdGhpcy5jcmVhdGVDbGllbnRLZXkoY2xpZW50KTtcbiAgICBpZiAoIXRoaXMuY29vcmRpbmF0ZUNhbGxzLmhhcyhrdGFLZXkpKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVDYWxscy5zZXQoa3RhS2V5LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwLmhhcyhzY29wZUtleSkpIHtcbiAgICAgIHNjb3BlTWFwLnNldChzY29wZUtleSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgY29uc3QgY3VycmVudENvdW50ID0gY2xpZW50TWFwLmdldChjbGllbnRLZXkpIHx8IDA7XG4gICAgY2xpZW50TWFwLnNldChjbGllbnRLZXksIGN1cnJlbnRDb3VudCArIDEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRpc3RpY3Mgc25hcHNob3RcbiAgICovXG4gIGdldFN0YXRpc3RpY3MoKSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZUNhbGxSZWNvcmRzID0gW107XG4gICAgbGV0IHNlcnZpY2VDYWxscyA9IDA7XG4gICAgbGV0IGFwcGxpY2F0aW9uQ2FsbHMgPSAwO1xuICAgIGxldCB1bmlkZW50aWZpZWRDYWxscyA9IDA7XG4gICAgZm9yIChjb25zdCBba3RhS2V5LCBzY29wZU1hcF0gb2YgdGhpcy5jb29yZGluYXRlQ2FsbHMpIHtcbiAgICAgIGZvciAoY29uc3QgW3Njb3BlS2V5LCBjbGllbnRNYXBdIG9mIHNjb3BlTWFwKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudENhbGxzID0gW107XG4gICAgICAgIGxldCB0b3RhbENvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBbY2xpZW50S2V5LCBjb3VudF0gb2YgY2xpZW50TWFwKSB7XG4gICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5wYXJzZUNsaWVudEtleShjbGllbnRLZXkpO1xuICAgICAgICAgIGlmIChjbGllbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsaWVudENhbGxzLnB1c2goeyBjbGllbnQsIGNvdW50IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbENvdW50ICs9IGNvdW50O1xuICAgICAgICAgIGlmIChjbGllbnRLZXkgPT09IFwiX19ub19jbGllbnRfX1wiKSB7XG4gICAgICAgICAgICB1bmlkZW50aWZpZWRDYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjbGllbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZpY2VDYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRpbmF0ZUNhbGxSZWNvcmRzLnB1c2goe1xuICAgICAgICAgIGt0YToga3RhS2V5LnNwbGl0KFwiLlwiKSxcbiAgICAgICAgICBzY29wZXM6IHRoaXMucGFyc2VTY29wZUtleShzY29wZUtleSksXG4gICAgICAgICAgY291bnQ6IHRvdGFsQ291bnQsXG4gICAgICAgICAgY2xpZW50Q2FsbHM6IFsuLi5jbGllbnRDYWxsc11cbiAgICAgICAgICAvLyBSZXR1cm4gYSBjb3B5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxHZXRDYWxsczogdGhpcy50b3RhbENhbGxzLFxuICAgICAgY29vcmRpbmF0ZUNhbGxSZWNvcmRzOiBbLi4uY29vcmRpbmF0ZUNhbGxSZWNvcmRzXSxcbiAgICAgIC8vIFJldHVybiBhIGNvcHlcbiAgICAgIGNsaWVudFN1bW1hcnk6IHtcbiAgICAgICAgc2VydmljZUNhbGxzLFxuICAgICAgICBhcHBsaWNhdGlvbkNhbGxzLFxuICAgICAgICB1bmlkZW50aWZpZWRDYWxsc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgY2FsbCBjb3VudCBmb3IgYSBzcGVjaWZpYyBjb29yZGluYXRlIGNvbWJpbmF0aW9uXG4gICAqL1xuICBnZXRDYWxsQ291bnQoa3RhLCBzY29wZXMpIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcbiAgICBjb25zdCBjbGllbnRNYXAgPSBzY29wZU1hcC5nZXQoc2NvcGVLZXkpO1xuICAgIGlmICghY2xpZW50TWFwKSByZXR1cm4gMDtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgY291bnQgb2YgY2xpZW50TWFwLnZhbHVlcygpKSB7XG4gICAgICB0b3RhbCArPSBjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGNhbGwgY291bnQgZm9yIGEgc3BlY2lmaWMgY29vcmRpbmF0ZSBjb21iaW5hdGlvbiBmcm9tIGEgc3BlY2lmaWMgY2xpZW50XG4gICAqL1xuICBnZXRDYWxsQ291bnRCeUNsaWVudChrdGEsIHNjb3BlcywgY2xpZW50KSB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IGNsaWVudEtleSA9IHRoaXMuY3JlYXRlQ2xpZW50S2V5KGNsaWVudCk7XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcbiAgICBjb25zdCBjbGllbnRNYXAgPSBzY29wZU1hcC5nZXQoc2NvcGVLZXkpO1xuICAgIGlmICghY2xpZW50TWFwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gY2xpZW50TWFwLmdldChjbGllbnRLZXkpIHx8IDA7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdG90YWwgY2FsbHMgZm9yIGEgc3BlY2lmaWMga3RhIChhY3Jvc3MgYWxsIHNjb3BlcylcbiAgICovXG4gIGdldFRvdGFsQ2FsbHNGb3JLdGEoa3RhKSB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcCkgcmV0dXJuIDA7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IGNsaWVudE1hcCBvZiBzY29wZU1hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjb3VudCBvZiBjbGllbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgdG90YWwgKz0gY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbGwgdW5pcXVlIGt0YSBwYXRocyB0aGF0IGhhdmUgYmVlbiBjYWxsZWRcbiAgICovXG4gIGdldENhbGxlZEt0YVBhdGhzKCkge1xuICAgIGNvbnN0IGt0YVBhdGhzID0gW107XG4gICAgZm9yIChjb25zdCBrdGFLZXkgb2YgdGhpcy5jb29yZGluYXRlQ2FsbHMua2V5cygpKSB7XG4gICAgICBrdGFQYXRocy5wdXNoKGt0YUtleS5zcGxpdChcIi5cIikpO1xuICAgIH1cbiAgICByZXR1cm4ga3RhUGF0aHM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBub3JtYWxpemVkIHNjb3BlIGtleSBmcm9tIHNjb3BlcyBhcnJheVxuICAgKi9cbiAgY3JlYXRlU2NvcGVLZXkoc2NvcGVzKSB7XG4gICAgaWYgKHNjb3Blcy5sZW5ndGggPT09IDApIHJldHVybiBcIl9fbm9fc2NvcGVzX19cIjtcbiAgICByZXR1cm4gWy4uLnNjb3Blc10uc29ydCgpLmpvaW4oXCIsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBzY29wZSBrZXkgYmFjayB0byBzY29wZXMgYXJyYXlcbiAgICovXG4gIHBhcnNlU2NvcGVLZXkoc2NvcGVLZXkpIHtcbiAgICBpZiAoc2NvcGVLZXkgPT09IFwiX19ub19zY29wZXNfX1wiKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHNjb3BlS2V5LnNwbGl0KFwiLFwiKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5vcm1hbGl6ZWQgY2xpZW50IGtleSBmcm9tIGNsaWVudCBpZGVudGlmaWVyXG4gICAqL1xuICBjcmVhdGVDbGllbnRLZXkoY2xpZW50KSB7XG4gICAgaWYgKCFjbGllbnQpIHJldHVybiBcIl9fbm9fY2xpZW50X19cIjtcbiAgICBpZiAodHlwZW9mIGNsaWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGBhcHA6JHtjbGllbnR9YDtcbiAgICB9XG4gICAgY29uc3QgY29vcmRLZXkgPSBgJHtjbGllbnQuY29vcmRpbmF0ZS5rdGEuam9pbihcIi5cIil9OyR7dGhpcy5jcmVhdGVTY29wZUtleShjbGllbnQuY29vcmRpbmF0ZS5zY29wZXMpfWA7XG4gICAgcmV0dXJuIGBzZXJ2aWNlOiR7Y2xpZW50LnJlZ2lzdHJ5VHlwZX06JHtjb29yZEtleX1gO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBjbGllbnQga2V5IGJhY2sgdG8gY2xpZW50IGlkZW50aWZpZXJcbiAgICovXG4gIHBhcnNlQ2xpZW50S2V5KGNsaWVudEtleSkge1xuICAgIGlmIChjbGllbnRLZXkgPT09IFwiX19ub19jbGllbnRfX1wiKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoY2xpZW50S2V5LnN0YXJ0c1dpdGgoXCJhcHA6XCIpKSB7XG4gICAgICByZXR1cm4gY2xpZW50S2V5LnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgaWYgKGNsaWVudEtleS5zdGFydHNXaXRoKFwic2VydmljZTpcIikpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gY2xpZW50S2V5LnN1YnN0cmluZyg4KS5zcGxpdChcIjpcIik7XG4gICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5VHlwZSA9IHBhcnRzWzBdO1xuICAgICAgY29uc3QgY29vcmRQYXJ0cyA9IHBhcnRzWzFdLnNwbGl0KFwiO1wiKTtcbiAgICAgIGlmIChjb29yZFBhcnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBrdGEgPSBjb29yZFBhcnRzWzBdLnNwbGl0KFwiLlwiKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMucGFyc2VTY29wZUtleShjb29yZFBhcnRzWzFdKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgICAgY29vcmRpbmF0ZTogeyBrdGEsIHNjb3BlcyB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gc3JjL1JlZ2lzdHJ5LnRzXG52YXIgbG9nZ2VyMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIlJlZ2lzdHJ5XCIpO1xudmFyIGZpbmRTY29wZWRJbnN0YW5jZSA9IChzY29wZWRJbnN0YW5jZXMsIHJlcXVlc3RlZFNjb3BlcykgPT4ge1xuICBpZiAoIXJlcXVlc3RlZFNjb3BlcyB8fCByZXF1ZXN0ZWRTY29wZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgZmlyc3RJbnN0YW5jZSA9IHNjb3BlZEluc3RhbmNlc1swXT8uaW5zdGFuY2U7XG4gICAgaWYgKCFmaXJzdEluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBpbnN0YW5jZXMgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RJbnN0YW5jZTtcbiAgfVxuICBjb25zdCBtYXRjaGluZ0luc3RhbmNlID0gc2NvcGVkSW5zdGFuY2VzLmZpbmQoKHNjb3BlZEluc3RhbmNlKSA9PiB7XG4gICAgaWYgKCFzY29wZWRJbnN0YW5jZS5zY29wZXMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVxdWVzdGVkU2NvcGVzLmV2ZXJ5KFxuICAgICAgKHNjb3BlKSA9PiBzY29wZWRJbnN0YW5jZS5zY29wZXMgJiYgc2NvcGVkSW5zdGFuY2Uuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKVxuICAgICk7XG4gIH0pO1xuICBpZiAoIW1hdGNoaW5nSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluc3RhbmNlIGZvdW5kIG1hdGNoaW5nIHNjb3BlczogJHtyZXF1ZXN0ZWRTY29wZXMuam9pbihcIiwgXCIpfWApO1xuICB9XG4gIHJldHVybiBtYXRjaGluZ0luc3RhbmNlLmluc3RhbmNlO1xufTtcbnZhciBjcmVhdGVSZWdpc3RyeSA9ICh0eXBlLCByZWdpc3RyeUh1YikgPT4ge1xuICBjb25zdCBpbnN0YW5jZVRyZWUgPSB7fTtcbiAgY29uc3QgcmVnaXN0cnlTdGF0cyA9IG5ldyBSZWdpc3RyeVN0YXRzKCk7XG4gIGNvbnN0IGNyZWF0ZVByb3hpZWRSZWdpc3RyeSA9IChjYWxsaW5nQ29vcmRpbmF0ZSkgPT4ge1xuICAgIGNvbnN0IHNlcnZpY2VDbGllbnQgPSB7XG4gICAgICByZWdpc3RyeVR5cGU6IHR5cGUsXG4gICAgICBjb29yZGluYXRlOiB7XG4gICAgICAgIGt0YTogY2FsbGluZ0Nvb3JkaW5hdGUua3RhLFxuICAgICAgICBzY29wZXM6IGNhbGxpbmdDb29yZGluYXRlLnNjb3Blc1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlZ2lzdHJ5LFxuICAgICAgZ2V0OiAoa3RhLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudFRvVXNlID0gb3B0aW9ucz8uY2xpZW50IHx8IHNlcnZpY2VDbGllbnQ7XG4gICAgICAgIHJldHVybiByZWdpc3RyeS5nZXQoa3RhLCB7IC4uLm9wdGlvbnMsIGNsaWVudDogY2xpZW50VG9Vc2UgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlSW5zdGFuY2UyID0gKGt0YSwgc2NvcGVzLCBmYWN0b3J5KSA9PiB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhgQ3JlYXRpbmcgYW5kIHJlZ2lzdGVyaW5nIGluc3RhbmNlIGZvciBrZXkgcGF0aCBhbmQgc2NvcGVzYCwga3RhLCBzY29wZXMsIGBpbiByZWdpc3RyeSB0eXBlOiAke3R5cGV9YCk7XG4gICAgY29uc3QgY29vcmRpbmF0ZSA9IGNyZWF0ZUNvb3JkaW5hdGUoa3RhLCBzY29wZXMpO1xuICAgIGNvbnN0IHByb3hpZWRSZWdpc3RyeSA9IGNyZWF0ZVByb3hpZWRSZWdpc3RyeShjb29yZGluYXRlKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZhY3RvcnkoY29vcmRpbmF0ZSwge1xuICAgICAgcmVnaXN0cnk6IHByb3hpZWRSZWdpc3RyeSxcbiAgICAgIHJlZ2lzdHJ5SHViXG4gICAgfSk7XG4gICAgaWYgKCFpc0luc3RhbmNlKGluc3RhbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWN0b3J5IGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2UgZm9yOiAke2t0YS5qb2luKFwiLlwiKX1gKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJJbnRlcm5hbChrdGEsIGluc3RhbmNlLCB7IHNjb3BlcyB9KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG4gIGNvbnN0IHJlZ2lzdGVySW50ZXJuYWwgPSAoa3RhLCBpbnN0YW5jZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGtleVBhdGggPSBbLi4ua3RhXS5yZXZlcnNlKCk7XG4gICAgbGV0IGN1cnJlbnRMZXZlbCA9IGluc3RhbmNlVHJlZTtcbiAgICBsb2dnZXIzLmRlYnVnKGBSZWdpc3RlcmluZyBpbnN0YW5jZSBmb3Iga2V5IHBhdGggYW5kIHNjb3Blc2AsIGtleVBhdGgsIG9wdGlvbnM/LnNjb3BlcywgYGluIHJlZ2lzdHJ5IHR5cGU6ICR7dHlwZX1gKTtcbiAgICBpZiAoIWlzSW5zdGFuY2UoaW5zdGFuY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBub24taW5zdGFuY2U6ICR7a3RhLmpvaW4oXCIuXCIpfWApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleVBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleVR5cGUgPSBrZXlQYXRoW2ldO1xuICAgICAgY29uc3QgaXNMZWFmID0gaSA9PT0ga2V5UGF0aC5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0pIHtcbiAgICAgICAgY3VycmVudExldmVsW2tleVR5cGVdID0ge1xuICAgICAgICAgIGluc3RhbmNlczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IGlzTGVhZiA/IG51bGwgOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0uaW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgIHNjb3Blczogb3B0aW9ucz8uc2NvcGVzLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZWdpc3RlciA9IChrdGEsIGluc3RhbmNlLCBvcHRpb25zKSA9PiB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIlVzaW5nIGRlcHJlY2F0ZWQgcmVnaXN0ZXIgbWV0aG9kLiBDb25zaWRlciB1c2luZyBjcmVhdGVJbnN0YW5jZSBpbnN0ZWFkLlwiKTtcbiAgICByZWdpc3RlckludGVybmFsKGt0YSwgaW5zdGFuY2UsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBnZXQgPSAoa3RhLCBvcHRpb25zKSA9PiB7XG4gICAgcmVnaXN0cnlTdGF0cy5yZWNvcmRHZXRDYWxsKGt0YSwgb3B0aW9ucz8uc2NvcGVzLCBvcHRpb25zPy5jbGllbnQpO1xuICAgIGNvbnN0IGtleVBhdGggPSBbLi4ua3RhXS5yZXZlcnNlKCk7XG4gICAgbGV0IGN1cnJlbnRMZXZlbCA9IGluc3RhbmNlVHJlZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleVBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleVR5cGUgPSBrZXlQYXRoW2ldO1xuICAgICAgY29uc3QgaXNMZWFmID0gaSA9PT0ga2V5UGF0aC5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKFwiLlwiKX0sIE1pc3Npbmcga2V5OiAke2tleVR5cGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZEluc3RhbmNlcyA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5pbnN0YW5jZXM7XG4gICAgICAgIGlmIChzY29wZWRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnN0YW5jZXMgcmVnaXN0ZXJlZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oXCIuXCIpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kU2NvcGVkSW5zdGFuY2Uoc2NvcGVkSW5zdGFuY2VzLCBvcHRpb25zPy5zY29wZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oXCIuXCIpfSwgTm8gY2hpbGRyZW4gZm9yOiAke2tleVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgZ2V0Q29vcmRpbmF0ZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICBjb25zdCB0cmF2ZXJzZVRyZWUgPSAobm9kZSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXlUeXBlIGluIG5vZGUpIHtcbiAgICAgICAgY29uc3QgdHJlZU5vZGUgPSBub2RlW2tleVR5cGVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlZEluc3RhbmNlIG9mIHRyZWVOb2RlLmluc3RhbmNlcykge1xuICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goc2NvcGVkSW5zdGFuY2UuaW5zdGFuY2UuY29vcmRpbmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdHJhdmVyc2VUcmVlKHRyZWVOb2RlLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdHJhdmVyc2VUcmVlKGluc3RhbmNlVHJlZSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9O1xuICBjb25zdCBnZXRTdGF0aXN0aWNzID0gKCkgPT4ge1xuICAgIHJldHVybiByZWdpc3RyeVN0YXRzLmdldFN0YXRpc3RpY3MoKTtcbiAgfTtcbiAgY29uc3QgcmVnaXN0cnkgPSB7XG4gICAgdHlwZSxcbiAgICByZWdpc3RyeUh1YixcbiAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2UyLFxuICAgIHJlZ2lzdGVyLFxuICAgIGdldCxcbiAgICBnZXRDb29yZGluYXRlcyxcbiAgICBnZXRTdGF0aXN0aWNzLFxuICAgIGluc3RhbmNlVHJlZVxuICB9O1xuICByZXR1cm4gcmVnaXN0cnk7XG59O1xuXG4vLyBzcmMvZXJyb3JzL1JlZ2lzdHJ5RXJyb3IudHNcbnZhciBSZWdpc3RyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIHJlZ2lzdHJ5VHlwZTtcbiAgY29udGV4dDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMucmVnaXN0cnlUeXBlID0gcmVnaXN0cnlUeXBlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29uc3QgRXJyb3JDb25zdHJ1Y3RvciA9IEVycm9yO1xuICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3Rvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBFcnJvckNvbnN0cnVjdG9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgfVxuICBnZXREZXRhaWxzKCkge1xuICAgIGNvbnN0IGRldGFpbHMgPSBbdGhpcy5tZXNzYWdlXTtcbiAgICBpZiAodGhpcy5yZWdpc3RyeVR5cGUpIHtcbiAgICAgIGRldGFpbHMucHVzaChgUmVnaXN0cnkgVHlwZTogJHt0aGlzLnJlZ2lzdHJ5VHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgZGV0YWlscy5wdXNoKGBDb250ZXh0OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY29udGV4dCwgbnVsbCwgMil9YCk7XG4gICAgfVxuICAgIHJldHVybiBkZXRhaWxzLmpvaW4oXCJcXG5cIik7XG4gIH1cbn07XG52YXIgUmVnaXN0cnlDcmVhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAgY29uc3RydWN0b3IodHlwZSwgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoYEZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cnkgb2YgdHlwZSAnJHt0eXBlfSc6ICR7cmVhc29ufWAsIHR5cGUsIGNvbnRleHQpO1xuICB9XG59O1xudmFyIEludmFsaWRGYWN0b3J5UmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrZXlQYXRoO1xuICBmYWN0b3J5UmVzdWx0O1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBmYWN0b3J5UmVzdWx0LCByZWdpc3RyeVR5cGUpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBGYWN0b3J5IGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2UgZm9yOiAke2tleVBhdGhTdHJ9LiBFeHBlY3RlZCBpbnN0YW5jZSB3aXRoICdjb29yZGluYXRlJyBhbmQgJ3JlZ2lzdHJ5JyBwcm9wZXJ0aWVzLCBnb3Q6ICR7dHlwZW9mIGZhY3RvcnlSZXN1bHR9YCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsga2V5UGF0aCwgZmFjdG9yeVJlc3VsdDogdHlwZW9mIGZhY3RvcnlSZXN1bHQgfVxuICAgICk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICB0aGlzLmZhY3RvcnlSZXN1bHQgPSBmYWN0b3J5UmVzdWx0O1xuICB9XG59O1xudmFyIEludmFsaWRJbnN0YW5jZVJlZ2lzdHJhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga2V5UGF0aDtcbiAgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uO1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBhdHRlbXB0ZWRSZWdpc3RyYXRpb24sIHJlZ2lzdHJ5VHlwZSkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBub24taW5zdGFuY2U6ICR7a2V5UGF0aFN0cn0uIEV4cGVjdGVkIGluc3RhbmNlIHdpdGggJ2Nvb3JkaW5hdGUnIGFuZCAncmVnaXN0cnknIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgYXR0ZW1wdGVkUmVnaXN0cmF0aW9ufWAsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IGtleVBhdGgsIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjogdHlwZW9mIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbiB9XG4gICAgKTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaXN0cmF0aW9uID0gYXR0ZW1wdGVkUmVnaXN0cmF0aW9uO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL1JlZ2lzdHJ5SHViRXJyb3IudHNcbnZhciBSZWdpc3RyeUh1YkVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAgaHViVHlwZTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaHViVHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGVucmljaGVkQ29udGV4dCA9IGh1YlR5cGUgPyB7IC4uLmNvbnRleHQsIGh1YlR5cGUgfSA6IGNvbnRleHQ7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJcIiwgZW5yaWNoZWRDb250ZXh0KTtcbiAgICB0aGlzLmh1YlR5cGUgPSBodWJUeXBlO1xuICB9XG59O1xudmFyIER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgZHVwbGljYXRlVHlwZTtcbiAgY29uc3RydWN0b3IodHlwZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGFscmVhZHkgcmVnaXN0ZXJlZCB1bmRlciB0eXBlOiAke3R5cGV9LiBFYWNoIHJlZ2lzdHJ5IHR5cGUgbXVzdCBiZSB1bmlxdWUgd2l0aGluIGEgcmVnaXN0cnkgaHViLmAsXG4gICAgICBcIlwiLFxuICAgICAgeyAuLi5jb250ZXh0LCBkdXBsaWNhdGVUeXBlOiB0eXBlIH1cbiAgICApO1xuICAgIHRoaXMuZHVwbGljYXRlVHlwZSA9IHR5cGU7XG4gIH1cbn07XG52YXIgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIHJlcXVlc3RlZFR5cGU7XG4gIGF2YWlsYWJsZVR5cGVzO1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0ZWRUeXBlLCBhdmFpbGFibGVUeXBlcyA9IFtdLCBjb250ZXh0KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgTm8gcmVnaXN0cnkgcmVnaXN0ZXJlZCB1bmRlciB0eXBlOiAke3JlcXVlc3RlZFR5cGV9YDtcbiAgICBpZiAoYXZhaWxhYmxlVHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZSArPSBgLiBBdmFpbGFibGUgdHlwZXM6IFske2F2YWlsYWJsZVR5cGVzLmpvaW4oXCIsIFwiKX1dYDtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSwgXCJcIiwgeyAuLi5jb250ZXh0LCByZXF1ZXN0ZWRUeXBlLCBhdmFpbGFibGVUeXBlcyB9KTtcbiAgICB0aGlzLnJlcXVlc3RlZFR5cGUgPSByZXF1ZXN0ZWRUeXBlO1xuICAgIHRoaXMuYXZhaWxhYmxlVHlwZXMgPSBhdmFpbGFibGVUeXBlcztcbiAgfVxufTtcbnZhciBSZWdpc3RyeUZhY3RvcnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIGZhY3RvcnlFcnJvcjtcbiAgYXR0ZW1wdGVkVHlwZTtcbiAgY29uc3RydWN0b3IodHlwZSwgZmFjdG9yeUVycm9yLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVnaXN0cnkgZmFjdG9yeSBmYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJ5IG9mIHR5cGUgJyR7dHlwZX0nOiAke2ZhY3RvcnlFcnJvci5tZXNzYWdlfWAsXG4gICAgICBcIlwiLFxuICAgICAgeyAuLi5jb250ZXh0LCBhdHRlbXB0ZWRUeXBlOiB0eXBlLCBvcmlnaW5hbEVycm9yOiBmYWN0b3J5RXJyb3IubWVzc2FnZSB9XG4gICAgKTtcbiAgICB0aGlzLmZhY3RvcnlFcnJvciA9IGZhY3RvcnlFcnJvcjtcbiAgICB0aGlzLmF0dGVtcHRlZFR5cGUgPSB0eXBlO1xuICB9XG59O1xudmFyIEludmFsaWRSZWdpc3RyeUZhY3RvcnlSZXN1bHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIGZhY3RvcnlSZXN1bHQ7XG4gIGF0dGVtcHRlZFR5cGU7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGZhY3RvcnlSZXN1bHQsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBmYWN0b3J5IHJldHVybmVkIGludmFsaWQgcmVnaXN0cnkgZm9yIHR5cGUgJyR7dHlwZX0nLiBFeHBlY3RlZCByZWdpc3RyeSB3aXRoICd0eXBlJywgJ2dldCcsICdyZWdpc3RlcicsIGFuZCAnY3JlYXRlSW5zdGFuY2UnIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgZmFjdG9yeVJlc3VsdH1gLFxuICAgICAgXCJcIixcbiAgICAgIHsgLi4uY29udGV4dCwgYXR0ZW1wdGVkVHlwZTogdHlwZSwgZmFjdG9yeVJlc3VsdDogdHlwZW9mIGZhY3RvcnlSZXN1bHQgfVxuICAgICk7XG4gICAgdGhpcy5mYWN0b3J5UmVzdWx0ID0gZmFjdG9yeVJlc3VsdDtcbiAgICB0aGlzLmF0dGVtcHRlZFR5cGUgPSB0eXBlO1xuICB9XG59O1xuXG4vLyBzcmMvUmVnaXN0cnlIdWIudHNcbnZhciBsb2dnZXI0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiUmVnaXN0cnlIdWJcIik7XG52YXIgY3JlYXRlUmVnaXN0cnlIdWIgPSAoKSA9PiB7XG4gIGNvbnN0IHJlZ2lzdHJpZXMgPSB7fTtcbiAgY29uc3QgY3JlYXRlUmVnaXN0cnkyID0gKHR5cGUsIGZhY3RvcnkpID0+IHtcbiAgICBsb2dnZXI0LmRlYnVnKGBDcmVhdGluZyBuZXcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gICAgaWYgKHJlZ2lzdHJpZXNbdHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG4gICAgY29uc3QgcmVnaXN0cnkgPSBmYWN0b3J5KHR5cGUsIGh1Yik7XG4gICAgaWYgKCEoXCJyZWdpc3RyeUh1YlwiIGluIHJlZ2lzdHJ5KSB8fCByZWdpc3RyeS5yZWdpc3RyeUh1YiAhPT0gaHViKSB7XG4gICAgICByZWdpc3RyeS5yZWdpc3RyeUh1YiA9IGh1YjtcbiAgICB9XG4gICAgcmVnaXN0cmllc1t0eXBlXSA9IHJlZ2lzdHJ5O1xuICAgIGxvZ2dlcjQuZGVidWcoYFN1Y2Nlc3NmdWxseSBjcmVhdGVkIGFuZCByZWdpc3RlcmVkIG5ldyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH07XG4gIGNvbnN0IHJlZ2lzdGVyUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcbiAgICBjb25zdCB0eXBlID0gcmVnaXN0cnkudHlwZTtcbiAgICBsb2dnZXI0LmRlYnVnKGBSZWdpc3RlcmluZyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yKHR5cGUpO1xuICAgIH1cbiAgICByZWdpc3RyaWVzW3R5cGVdID0gcmVnaXN0cnk7XG4gICAgaWYgKCEoXCJyZWdpc3RyeUh1YlwiIGluIHJlZ2lzdHJ5KSB8fCByZWdpc3RyeS5yZWdpc3RyeUh1YiAhPT0gaHViKSB7XG4gICAgICByZWdpc3RyeS5yZWdpc3RyeUh1YiA9IGh1YjtcbiAgICB9XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gIH07XG4gIGNvbnN0IGdldCA9ICh0eXBlLCBrdGEsIG9wdGlvbnMpID0+IHtcbiAgICBsb2dnZXI0LmRlYnVnKGBMb29raW5nIHVwIGluc3RhbmNlIGZvciB0eXBlOiAke3R5cGV9LCBrdGE6ICR7a3RhLmpvaW4oXCIuXCIpfSwgc2NvcGVzOiAke29wdGlvbnM/LnNjb3Blcz8uam9pbihcIixcIikgfHwgXCJub25lXCJ9YCk7XG4gICAgY29uc3QgcmVnaXN0cnkgPSByZWdpc3RyaWVzW3R5cGVdO1xuICAgIGlmICghcmVnaXN0cnkpIHtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVR5cGVzID0gT2JqZWN0LmtleXMocmVnaXN0cmllcyk7XG4gICAgICB0aHJvdyBuZXcgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvcih0eXBlLCBhdmFpbGFibGVUeXBlcyk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3RyeS5nZXQoa3RhLCBvcHRpb25zKTtcbiAgfTtcbiAgY29uc3QgZ2V0UmVnaXN0cnkgPSAodHlwZSkgPT4ge1xuICAgIHJldHVybiByZWdpc3RyaWVzW3R5cGVdIHx8IG51bGw7XG4gIH07XG4gIGNvbnN0IGdldFJlZ2lzdGVyZWRUeXBlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cmllcyk7XG4gIH07XG4gIGNvbnN0IHVucmVnaXN0ZXJSZWdpc3RyeSA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHJlZ2lzdHJpZXNbdHlwZV0pIHtcbiAgICAgIGRlbGV0ZSByZWdpc3RyaWVzW3R5cGVdO1xuICAgICAgbG9nZ2VyNC5kZWJ1ZyhgVW5yZWdpc3RlcmVkIHJlZ2lzdHJ5IHVuZGVyIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGdldEFsbENvb3JkaW5hdGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGFsbENvb3JkaW5hdGVzID0gW107XG4gICAgZm9yIChjb25zdCByZWdpc3RyeVR5cGUgaW4gcmVnaXN0cmllcykge1xuICAgICAgY29uc3QgcmVnaXN0cnkgPSByZWdpc3RyaWVzW3JlZ2lzdHJ5VHlwZV07XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IHJlZ2lzdHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBjb29yZGluYXRlcy5mb3JFYWNoKChjb29yZGluYXRlKSA9PiB7XG4gICAgICAgIGFsbENvb3JkaW5hdGVzLnB1c2goe1xuICAgICAgICAgIGNvb3JkaW5hdGUsXG4gICAgICAgICAgcmVnaXN0cnlUeXBlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxvZ2dlcjQuZGVidWcoYFJldHJpZXZlZCAke2FsbENvb3JkaW5hdGVzLmxlbmd0aH0gdG90YWwgY29vcmRpbmF0ZXMgZnJvbSAke09iamVjdC5rZXlzKHJlZ2lzdHJpZXMpLmxlbmd0aH0gcmVnaXN0cmllc2ApO1xuICAgIHJldHVybiBhbGxDb29yZGluYXRlcztcbiAgfTtcbiAgY29uc3QgaHViID0ge1xuICAgIGNyZWF0ZVJlZ2lzdHJ5OiBjcmVhdGVSZWdpc3RyeTIsXG4gICAgcmVnaXN0ZXJSZWdpc3RyeSxcbiAgICBnZXQsXG4gICAgZ2V0UmVnaXN0cnksXG4gICAgZ2V0UmVnaXN0ZXJlZFR5cGVzLFxuICAgIGdldEFsbENvb3JkaW5hdGVzLFxuICAgIHVucmVnaXN0ZXJSZWdpc3RyeVxuICB9O1xuICByZXR1cm4gaHViO1xufTtcblxuLy8gc3JjL2Vycm9ycy9JbnN0YW5jZUVycm9yLnRzXG52YXIgSW5zdGFuY2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGtleVBhdGg7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHJlZ2lzdHJ5VHlwZSwgeyAuLi5jb250ZXh0LCBrZXlQYXRoIH0pO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gIH1cbn07XG52YXIgSW5zdGFuY2VOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgbWlzc2luZ0tleTtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgbWlzc2luZ0tleSwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgbGV0IG1lc3NhZ2UgPSBgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfWA7XG4gICAgaWYgKG1pc3NpbmdLZXkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCwgTWlzc2luZyBrZXk6ICR7bWlzc2luZ0tleX1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBrZXlQYXRoLCByZWdpc3RyeVR5cGUsIHsgLi4uY29udGV4dCwgbWlzc2luZ0tleSB9KTtcbiAgICB0aGlzLm1pc3NpbmdLZXkgPSBtaXNzaW5nS2V5O1xuICB9XG59O1xudmFyIE5vSW5zdGFuY2VzUmVnaXN0ZXJlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgTm8gaW5zdGFuY2VzIHJlZ2lzdGVyZWQgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9LiBUaGUga2V5IHBhdGggZXhpc3RzIGluIHRoZSByZWdpc3RyeSB0cmVlIGJ1dCBjb250YWlucyBubyBpbnN0YW5jZXMuYCxcbiAgICAgIGtleVBhdGgsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxufTtcbnZhciBOb0luc3RhbmNlc0F2YWlsYWJsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgTm8gaW5zdGFuY2VzIGF2YWlsYWJsZSBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0uIFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyBhbiBpbnRlcm5hbCByZWdpc3RyeSBzdGF0ZSBpc3N1ZS5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG59O1xudmFyIFNjb3BlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIHJlcXVlc3RlZFNjb3BlcztcbiAgYXZhaWxhYmxlU2NvcGVzO1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCByZXF1ZXN0ZWRTY29wZXMsIGF2YWlsYWJsZVNjb3BlcyA9IFtdLCByZWdpc3RyeVR5cGUpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZXNTdHIgPSByZXF1ZXN0ZWRTY29wZXMuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVNjb3Blc1N0ciA9IGF2YWlsYWJsZVNjb3Blcy5tYXAoKHNjb3BlcykgPT4gYFske3Njb3Blcy5qb2luKFwiLCBcIil9XWApLmpvaW4oXCIsIFwiKTtcbiAgICBsZXQgbWVzc2FnZSA9IGBObyBpbnN0YW5jZSBmb3VuZCBtYXRjaGluZyBzY29wZXM6ICR7c2NvcGVzU3RyfSBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn1gO1xuICAgIGlmIChhdmFpbGFibGVTY29wZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZSArPSBgLiBBdmFpbGFibGUgc2NvcGVzOiAke2F2YWlsYWJsZVNjb3Blc1N0cn1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBrZXlQYXRoLCByZWdpc3RyeVR5cGUsIHsgcmVxdWVzdGVkU2NvcGVzLCBhdmFpbGFibGVTY29wZXMgfSk7XG4gICAgdGhpcy5yZXF1ZXN0ZWRTY29wZXMgPSByZXF1ZXN0ZWRTY29wZXM7XG4gICAgdGhpcy5hdmFpbGFibGVTY29wZXMgPSBhdmFpbGFibGVTY29wZXM7XG4gIH1cbn07XG52YXIgTm9DaGlsZHJlbkF2YWlsYWJsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgcGFyZW50S2V5O1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBwYXJlbnRLZXksIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0sIE5vIGNoaWxkcmVuIGZvcjogJHtwYXJlbnRLZXl9LiBUaGUgcGF0aCBjYW5ub3QgYmUgdHJhdmVyc2VkIGZ1cnRoZXIgYXMgJyR7cGFyZW50S2V5fScgaGFzIG5vIGNoaWxkIG5vZGVzLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyAuLi5jb250ZXh0LCBwYXJlbnRLZXkgfVxuICAgICk7XG4gICAgdGhpcy5wYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvQ29vcmRpbmF0ZUVycm9yLnRzXG52YXIgQ29vcmRpbmF0ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga3RhO1xuICBzY29wZXM7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGt0YSwgc2NvcGVzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJcIiwgeyAuLi5jb250ZXh0LCBrdGEsIHNjb3BlcyB9KTtcbiAgICB0aGlzLmt0YSA9IGt0YTtcbiAgICB0aGlzLnNjb3BlcyA9IHNjb3BlcztcbiAgfVxufTtcbnZhciBJbnZhbGlkQ29vcmRpbmF0ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrdGEsIHNjb3BlcywgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBjb29yZGluYXRlIHBhcmFtZXRlcnM6ICR7cmVhc29ufS4gS1RBOiAke0pTT04uc3RyaW5naWZ5KGt0YSl9LCBTY29wZXM6IFske3Njb3Blcy5qb2luKFwiLCBcIil9XWAsXG4gICAgICBrdGEsXG4gICAgICBzY29wZXMsXG4gICAgICB7IC4uLmNvbnRleHQsIHJlYXNvbiB9XG4gICAgKTtcbiAgfVxufTtcbnZhciBJbnZhbGlkS1RBRXJyb3IgPSBjbGFzcyBleHRlbmRzIENvb3JkaW5hdGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGt0YSwgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBLVEEgKEtleSBUeXBlIEFycmF5KTogJHtyZWFzb259LiBFeHBlY3RlZCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncywgZ290OiAke0pTT04uc3RyaW5naWZ5KGt0YSl9YCxcbiAgICAgIGt0YSxcbiAgICAgIFtdLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24gfVxuICAgICk7XG4gIH1cbn07XG52YXIgSW52YWxpZFNjb3Blc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBpbnZhbGlkU2NvcGVzO1xuICBjb25zdHJ1Y3RvcihzY29wZXMsIGludmFsaWRTY29wZXMsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgc2NvcGVzOiAke3JlYXNvbn0uIEludmFsaWQgc2NvcGUgdmFsdWVzOiAke0pTT04uc3RyaW5naWZ5KGludmFsaWRTY29wZXMpfWAsXG4gICAgICBudWxsLFxuICAgICAgc2NvcGVzLmZpbHRlcigocykgPT4gdHlwZW9mIHMgPT09IFwic3RyaW5nXCIpLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24sIGludmFsaWRTY29wZXMgfVxuICAgICk7XG4gICAgdGhpcy5pbnZhbGlkU2NvcGVzID0gaW52YWxpZFNjb3BlcztcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENvb3JkaW5hdGVFcnJvcixcbiAgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IsXG4gIEluc3RhbmNlRXJyb3IsXG4gIEluc3RhbmNlTm90Rm91bmRFcnJvcixcbiAgSW52YWxpZENvb3JkaW5hdGVFcnJvcixcbiAgSW52YWxpZEZhY3RvcnlSZXN1bHRFcnJvcixcbiAgSW52YWxpZEluc3RhbmNlUmVnaXN0cmF0aW9uRXJyb3IsXG4gIEludmFsaWRLVEFFcnJvcixcbiAgSW52YWxpZFJlZ2lzdHJ5RmFjdG9yeVJlc3VsdEVycm9yLFxuICBJbnZhbGlkU2NvcGVzRXJyb3IsXG4gIE5vQ2hpbGRyZW5BdmFpbGFibGVFcnJvcixcbiAgTm9JbnN0YW5jZXNBdmFpbGFibGVFcnJvcixcbiAgTm9JbnN0YW5jZXNSZWdpc3RlcmVkRXJyb3IsXG4gIFJlZ2lzdHJ5Q3JlYXRpb25FcnJvcixcbiAgUmVnaXN0cnlFcnJvcixcbiAgUmVnaXN0cnlGYWN0b3J5RXJyb3IsXG4gIFJlZ2lzdHJ5SHViRXJyb3IsXG4gIFJlZ2lzdHJ5U3RhdHMsXG4gIFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IsXG4gIFNjb3BlTm90Rm91bmRFcnJvcixcbiAgY3JlYXRlQ29vcmRpbmF0ZSxcbiAgY3JlYXRlSW5zdGFuY2UsXG4gIGNyZWF0ZVJlZ2lzdHJ5LFxuICBjcmVhdGVSZWdpc3RyeUh1YixcbiAgaXNJbnN0YW5jZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../fjell-providers/node_modules/@fjell/registry/dist/index.js\n");

/***/ })

};
;