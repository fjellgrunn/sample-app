"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_src_client_cache_WidgetCache_ts";
exports.ids = ["_ssr_src_client_cache_WidgetCache_ts"];
exports.modules = {

/***/ "(ssr)/../fjell-cache/dist/index.js":
/*!************************************!*\
  !*** ../fjell-cache/dist/index.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncIndexDBCacheMap: () => (/* binding */ AsyncIndexDBCacheMap),\n/* harmony export */   CacheEventEmitter: () => (/* binding */ CacheEventEmitter),\n/* harmony export */   CacheEventFactory: () => (/* binding */ CacheEventFactory),\n/* harmony export */   CacheMap: () => (/* binding */ CacheMap),\n/* harmony export */   CacheStatsManager: () => (/* binding */ CacheStatsManager),\n/* harmony export */   EnhancedMemoryCacheMap: () => (/* binding */ EnhancedMemoryCacheMap),\n/* harmony export */   EvictionManager: () => (/* binding */ EvictionManager),\n/* harmony export */   IndexDBCacheMap: () => (/* binding */ IndexDBCacheMap),\n/* harmony export */   LocalStorageCacheMap: () => (/* binding */ LocalStorageCacheMap),\n/* harmony export */   MemoryCacheMap: () => (/* binding */ MemoryCacheMap),\n/* harmony export */   SessionStorageCacheMap: () => (/* binding */ SessionStorageCacheMap),\n/* harmony export */   TTLManager: () => (/* binding */ TTLManager),\n/* harmony export */   createAggregator: () => (/* binding */ createAggregator),\n/* harmony export */   createCache: () => (/* binding */ createCache),\n/* harmony export */   createCacheMap: () => (/* binding */ createCacheMap),\n/* harmony export */   createEvictionStrategy: () => (/* binding */ createEvictionStrategy),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createInstanceFactory: () => (/* binding */ createInstanceFactory),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   createOperations: () => (/* binding */ createOperations),\n/* harmony export */   createOptions: () => (/* binding */ createOptions),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryFactory: () => (/* binding */ createRegistryFactory),\n/* harmony export */   createValidatedConfig: () => (/* binding */ createValidatedConfig),\n/* harmony export */   estimateValueSize: () => (/* binding */ estimateValueSize),\n/* harmony export */   formatBytes: () => (/* binding */ formatBytes),\n/* harmony export */   isCache: () => (/* binding */ isCache),\n/* harmony export */   isInstance: () => (/* binding */ isInstance),\n/* harmony export */   isLocKeyArrayEqual: () => (/* binding */ isLocKeyArrayEqual),\n/* harmony export */   normalizeKeyValue: () => (/* binding */ normalizeKeyValue),\n/* harmony export */   normalizeLocKeyItem: () => (/* binding */ normalizeLocKeyItem),\n/* harmony export */   parseSizeString: () => (/* binding */ parseSizeString),\n/* harmony export */   toCacheConfig: () => (/* binding */ toCacheConfig),\n/* harmony export */   validateARCConfig: () => (/* binding */ validateARCConfig),\n/* harmony export */   validateEvictionStrategyConfig: () => (/* binding */ validateEvictionStrategyConfig),\n/* harmony export */   validateLFUConfig: () => (/* binding */ validateLFUConfig),\n/* harmony export */   validateOptions: () => (/* binding */ validateOptions),\n/* harmony export */   validateSizeConfig: () => (/* binding */ validateSizeConfig),\n/* harmony export */   validateTwoQueueConfig: () => (/* binding */ validateTwoQueueConfig)\n/* harmony export */ });\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/core */ \"(ssr)/../fjell-cache/node_modules/@fjell/core/dist/index.js\");\n/* harmony import */ var _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/http-api */ \"(ssr)/../fjell-cache/node_modules/@fjell/http-api/dist/index.js\");\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/../fjell-cache/node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fjell/registry */ \"(ssr)/../fjell-cache/node_modules/@fjell/registry/dist/index.js\");\n// src/CacheContext.ts\nvar createCacheContext = (api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager)=>{\n    return {\n        api,\n        cacheMap,\n        pkType,\n        options,\n        eventEmitter,\n        ttlManager,\n        evictionManager,\n        statsManager\n    };\n};\n// src/ops/all.ts\n\n\n// src/normalization.ts\nvar normalizeKeyValue = (value)=>{\n    return String(value);\n};\nvar deterministicStringify = (obj)=>{\n    if (obj === null || typeof obj !== \"object\") {\n        return JSON.stringify(obj);\n    }\n    if (Array.isArray(obj)) {\n        return \"[\" + obj.map(deterministicStringify).join(\",\") + \"]\";\n    }\n    const sortedKeys = Object.keys(obj).sort();\n    const keyValuePairs = sortedKeys.map((key)=>{\n        return JSON.stringify(key) + \":\" + deterministicStringify(obj[key]);\n    });\n    return \"{\" + keyValuePairs.join(\",\") + \"}\";\n};\nvar createNormalizedHashFunction = ()=>{\n    return (key)=>{\n        if (typeof key === \"object\" && key !== null) {\n            const normalizedKey = JSON.parse(JSON.stringify(key));\n            if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n                normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n            }\n            if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n                normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n            }\n            if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n                normalizedKey.loc = normalizedKey.loc.map((locItem)=>{\n                    if (typeof locItem === \"object\" && locItem !== null && \"lk\" in locItem && locItem.lk !== null) {\n                        return {\n                            ...locItem,\n                            lk: normalizeKeyValue(locItem.lk)\n                        };\n                    }\n                    return locItem;\n                });\n            }\n            return deterministicStringify(normalizedKey);\n        }\n        return JSON.stringify(key);\n    };\n};\nvar isLocKeyArrayEqual = (a, b)=>{\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        const normalizedA = normalizeLocKeyItem(a[i]);\n        const normalizedB = normalizeLocKeyItem(b[i]);\n        if (deterministicStringify(normalizedA) !== deterministicStringify(normalizedB)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar normalizeLocKeyItem = (item)=>{\n    if (typeof item === \"object\" && item !== null) {\n        const normalized = {\n            ...item\n        };\n        if (\"lk\" in normalized && normalized.lk !== null) {\n            normalized.lk = normalizeKeyValue(normalized.lk);\n        }\n        return normalized;\n    }\n    return item;\n};\nvar createQueryHash = (pkType, query, locations)=>{\n    const normalizedQuery = JSON.parse(JSON.stringify(query || {}));\n    const sortedQueryKeys = Object.keys(normalizedQuery).sort();\n    const sortedQuery = {};\n    sortedQueryKeys.forEach((key)=>{\n        sortedQuery[key] = normalizedQuery[key];\n    });\n    const locationsArray = Array.isArray(locations) ? locations : [];\n    const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n    const hashInput = {\n        type: \"query\",\n        pkType,\n        query: sortedQuery,\n        locations: normalizedLocations\n    };\n    return deterministicStringify(hashInput);\n};\nvar createFinderHash = (finder, params, locations)=>{\n    const normalizedParams = JSON.parse(JSON.stringify(params || {}));\n    const sortedParamKeys = Object.keys(normalizedParams).sort();\n    const sortedParams = {};\n    sortedParamKeys.forEach((key)=>{\n        sortedParams[key] = normalizedParams[key];\n    });\n    const locationsArray = Array.isArray(locations) ? locations : [];\n    const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n    const hashInput = {\n        type: \"finder\",\n        finder,\n        params: sortedParams,\n        locations: normalizedLocations\n    };\n    return deterministicStringify(hashInput);\n};\n// src/events/CacheEventFactory.ts\nvar CacheEventFactory = class {\n    static{\n        this.lastTimestamp = 0;\n    }\n    static{\n        this.cleanupInterval = null;\n    }\n    static{\n        this.instanceCount = 0;\n    }\n    static{\n        this.CLEANUP_INTERVAL_MS = 6e4;\n    }\n    static{\n        // 1 minute\n        this.MAX_TIMESTAMP_AGE_MS = 3e5;\n    }\n    // 5 minutes\n    /**\n   * Initialize cleanup mechanism when first instance is created\n   */ static initializeCleanup() {\n        if (this.cleanupInterval === null && this.instanceCount === 0) {\n            this.startCleanupTimer();\n        }\n        this.instanceCount++;\n    }\n    /**\n   * Cleanup mechanism when instance is destroyed\n   */ static destroyInstance() {\n        this.instanceCount = Math.max(0, this.instanceCount - 1);\n        if (this.instanceCount === 0) {\n            this.stopCleanupTimer();\n            this.resetTimestamp();\n        }\n    }\n    /**\n   * Start automatic cleanup timer\n   */ static startCleanupTimer() {\n        this.cleanupInterval = setInterval(()=>{\n            this.performCleanup();\n        }, this.CLEANUP_INTERVAL_MS);\n        if (this.cleanupInterval.unref) {\n            this.cleanupInterval.unref();\n        }\n    }\n    /**\n   * Stop automatic cleanup timer\n   */ static stopCleanupTimer() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n            this.cleanupInterval = null;\n        }\n    }\n    /**\n   * Perform periodic cleanup of stale timestamp state\n   */ static performCleanup() {\n        const now = Date.now();\n        if (now - this.lastTimestamp > this.MAX_TIMESTAMP_AGE_MS) {\n            this.lastTimestamp = 0;\n        }\n    }\n    /**\n   * Reset the timestamp state (useful for testing)\n   */ static resetTimestamp() {\n        this.lastTimestamp = 0;\n    }\n    /**\n   * Generate a unique timestamp that is always greater than the previous one\n   */ static generateTimestamp() {\n        this.initializeCleanup();\n        const now = Date.now();\n        if (now > this.lastTimestamp) {\n            this.lastTimestamp = now;\n        } else {\n            this.lastTimestamp = this.lastTimestamp + 1;\n        }\n        return this.lastTimestamp;\n    }\n    /**\n   * Extract affected locations from an item key\n   */ static extractAffectedLocations(key) {\n        if (\"loc\" in key && key.loc) {\n            return key.loc;\n        }\n        return [];\n    }\n    /**\n   * Create an item-related event\n   */ static createItemEvent(type, key, item, options = {}) {\n        const affectedLocations = options.affectedLocations !== void 0 ? options.affectedLocations : this.extractAffectedLocations(key);\n        return {\n            type,\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            key,\n            item,\n            previousItem: options.previousItem,\n            affectedLocations\n        };\n    }\n    /**\n   * Create a query event\n   */ static createQueryEvent(query, locations, items, options = {}) {\n        const affectedKeys = items.map((item)=>item.key);\n        return {\n            type: \"items_queried\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            query,\n            locations,\n            items,\n            affectedKeys\n        };\n    }\n    /**\n   * Create a cache cleared event\n   */ static createCacheClearedEvent(itemsCleared, queryCacheCleared = true, options = {}) {\n        return {\n            type: \"cache_cleared\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            itemsCleared,\n            queryCacheCleared\n        };\n    }\n    /**\n   * Create a location invalidated event\n   */ static createLocationInvalidatedEvent(locations, affectedKeys, options = {}) {\n        return {\n            type: \"location_invalidated\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            locations,\n            affectedKeys\n        };\n    }\n    /**\n   * Create a query invalidated event\n   */ static createQueryInvalidatedEvent(invalidatedQueries, reason, options = {}) {\n        return {\n            type: \"query_invalidated\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            invalidatedQueries,\n            reason\n        };\n    }\n    /**\n   * Create an item created event\n   */ static itemCreated(key, item, source = \"api\") {\n        return this.createItemEvent(\"item_created\", key, item, {\n            source\n        });\n    }\n    /**\n   * Create an item updated event\n   */ static itemUpdated(key, item, previousItem, source = \"api\") {\n        return this.createItemEvent(\"item_updated\", key, item, {\n            previousItem,\n            source\n        });\n    }\n    /**\n   * Create an item removed event\n   */ static itemRemoved(key, previousItem, source = \"api\") {\n        return this.createItemEvent(\"item_removed\", key, null, {\n            previousItem,\n            source\n        });\n    }\n    /**\n   * Create an item retrieved event\n   */ static itemRetrieved(key, item, source = \"api\") {\n        return this.createItemEvent(\"item_retrieved\", key, item, {\n            source\n        });\n    }\n    /**\n   * Create an item set event (direct cache operation)\n   */ static itemSet(key, item, previousItem) {\n        return this.createItemEvent(\"item_set\", key, item, {\n            previousItem,\n            source: \"cache\"\n        });\n    }\n};\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLogger(\"@fjell/cache\");\nvar logger_default = LibLogger;\n// src/ops/all.ts\nvar logger = logger_default.get(\"all\");\nvar all = async (query = {}, locations = [], context)=>{\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger.default(\"all\", {\n        query,\n        locations\n    });\n    const queryHash = createQueryHash(pkType, query, locations);\n    logger.debug(\"Generated query hash for all\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys) {\n        logger.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        const cachedItems = [];\n        let allItemsAvailable = true;\n        for (const itemKey of cachedItemKeys){\n            const item = await cacheMap.get(itemKey);\n            if (item) {\n                cachedItems.push(item);\n            } else {\n                allItemsAvailable = false;\n                break;\n            }\n        }\n        if (allItemsAvailable) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)\n            ];\n        } else {\n            logger.debug(\"Some cached items missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    try {\n        const directCachedItems = await cacheMap.queryIn(query, locations);\n        if (directCachedItems && directCachedItems.length > 0) {\n            logger.debug(\"Found items directly in cache, skipping API call\", {\n                itemCount: directCachedItems.length\n            });\n            const itemKeys = directCachedItems.map((item)=>item.key);\n            await cacheMap.setQueryResult(queryHash, itemKeys);\n            logger.debug(\"Cached query result from direct cache hit\", {\n                queryHash,\n                itemKeyCount: itemKeys.length\n            });\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(directCachedItems, pkType)\n            ];\n        }\n    } catch (error) {\n        logger.debug(\"Error querying cache directly, proceeding to API\", {\n            error\n        });\n    }\n    let ret = [];\n    try {\n        ret = await api.all(query, locations);\n        for (const v of ret){\n            await cacheMap.set(v.key, v);\n            const keyStr = JSON.stringify(v.key);\n            ttlManager.onItemAdded(keyStr, cacheMap);\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n        }\n        const itemKeys = ret.map((item)=>item.key);\n        cacheMap.setQueryResult(queryHash, itemKeys);\n        logger.debug(\"Cached query result\", {\n            queryHash,\n            itemKeyCount: itemKeys.length\n        });\n        const event = CacheEventFactory.createQueryEvent(query, locations, ret);\n        context.eventEmitter.emit(event);\n    } catch (e) {\n        if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n            cacheMap.setQueryResult(queryHash, []);\n            logger.debug(\"Cached empty query result for not found\", {\n                queryHash\n            });\n        } else {\n            throw e;\n        }\n    }\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/one.ts\n\n\n// src/utils/CacheSize.ts\n\nvar SIZE_UNITS = {\n    // Decimal units (powers of 1000)\n    \"b\": 1,\n    \"byte\": 1,\n    \"bytes\": 1,\n    \"kb\": 1e3,\n    \"kilobyte\": 1e3,\n    \"kilobytes\": 1e3,\n    \"mb\": 1e3 * 1e3,\n    \"megabyte\": 1e3 * 1e3,\n    \"megabytes\": 1e3 * 1e3,\n    \"gb\": 1e3 * 1e3 * 1e3,\n    \"gigabyte\": 1e3 * 1e3 * 1e3,\n    \"gigabytes\": 1e3 * 1e3 * 1e3,\n    \"tb\": 1e3 * 1e3 * 1e3 * 1e3,\n    \"terabyte\": 1e3 * 1e3 * 1e3 * 1e3,\n    \"terabytes\": 1e3 * 1e3 * 1e3 * 1e3,\n    // Binary units (powers of 1024)\n    \"kib\": 1024,\n    \"kibibyte\": 1024,\n    \"kibibytes\": 1024,\n    \"mib\": 1024 * 1024,\n    \"mebibyte\": 1024 * 1024,\n    \"mebibytes\": 1024 * 1024,\n    \"gib\": 1024 * 1024 * 1024,\n    \"gibibyte\": 1024 * 1024 * 1024,\n    \"gibibytes\": 1024 * 1024 * 1024,\n    \"tib\": 1024 * 1024 * 1024 * 1024,\n    \"tebibyte\": 1024 * 1024 * 1024 * 1024,\n    \"tebibytes\": 1024 * 1024 * 1024 * 1024\n};\nfunction parseSizeString(sizeStr) {\n    if (!sizeStr || typeof sizeStr !== \"string\") {\n        throw new Error(\"Size string must be a non-empty string\");\n    }\n    const trimmed = sizeStr.trim();\n    if (/^\\d+(\\.\\d+)?$/.test(trimmed)) {\n        const bytes = parseFloat(trimmed);\n        if (isNaN(bytes) || bytes < 0) {\n            throw new Error(`Invalid size value: ${sizeStr}`);\n        }\n        return Math.floor(bytes);\n    }\n    const match = trimmed.match(/^(\\d+(?:\\.\\d+)?)\\s*([a-zA-Z]+)$/);\n    if (!match) {\n        throw new Error(`Invalid size format: ${sizeStr}. Expected format: '100', '5KB', '10MB', etc.`);\n    }\n    const [, valueStr, unitStr] = match;\n    const value = parseFloat(valueStr);\n    const unit = unitStr.toLowerCase();\n    if (isNaN(value) || value < 0) {\n        throw new Error(`Invalid size value: ${valueStr}`);\n    }\n    const multiplier = SIZE_UNITS[unit];\n    if (!(unit in SIZE_UNITS)) {\n        const supportedUnits = Object.keys(SIZE_UNITS).filter((u)=>u.length <= 3).join(\", \");\n        throw new Error(`Unsupported size unit: ${unitStr}. Supported units: ${supportedUnits}`);\n    }\n    return Math.floor(value * multiplier);\n}\nfunction formatBytes(bytes, binary = false) {\n    if (bytes === 0) return \"0 B\";\n    if (bytes < 0) return `${bytes} B`;\n    const k = binary ? 1024 : 1e3;\n    const sizes = binary ? [\n        \"B\",\n        \"KiB\",\n        \"MiB\",\n        \"GiB\",\n        \"TiB\",\n        \"PiB\"\n    ] : [\n        \"B\",\n        \"KB\",\n        \"MB\",\n        \"GB\",\n        \"TB\",\n        \"PB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    const size = bytes / Math.pow(k, i);\n    const formatted = size % 1 === 0 ? size.toString() : size.toFixed(1);\n    return `${formatted} ${sizes[i]}`;\n}\nfunction estimateValueSize(value) {\n    if (value === null || typeof value === \"undefined\") {\n        return 8;\n    }\n    switch(typeof value){\n        case \"boolean\":\n            return 4;\n        case \"number\":\n            return 8;\n        case \"string\":\n            return value.length * 2;\n        case \"object\":\n            if (Array.isArray(value)) {\n                return value.reduce((total, item)=>total + estimateValueSize(item), 24);\n            }\n            const hasCircularReference = (obj, ancestors = /* @__PURE__ */ new WeakSet(), checked = /* @__PURE__ */ new WeakSet())=>{\n                if (obj === null || typeof obj !== \"object\") {\n                    return false;\n                }\n                const asObject = obj;\n                if (checked.has(asObject)) {\n                    return false;\n                }\n                if (ancestors.has(asObject)) {\n                    return true;\n                }\n                ancestors.add(asObject);\n                try {\n                    if (Array.isArray(asObject)) {\n                        for (const item of asObject){\n                            if (hasCircularReference(item, ancestors, checked)) {\n                                return true;\n                            }\n                        }\n                    } else {\n                        for (const key of Object.keys(asObject)){\n                            let child;\n                            try {\n                                child = asObject[key];\n                            } catch  {\n                                continue;\n                            }\n                            if (hasCircularReference(child, ancestors, checked)) {\n                                return true;\n                            }\n                        }\n                    }\n                } finally{\n                    ancestors.delete(asObject);\n                    checked.add(asObject);\n                }\n                return false;\n            };\n            try {\n                if (hasCircularReference(value)) {\n                    return 64;\n                }\n            } catch  {\n                return 64;\n            }\n            try {\n                const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(value);\n                return jsonString.length * 2 + 16;\n            } catch  {\n                return 64;\n            }\n        default:\n            return 32;\n    }\n}\nfunction validateSizeConfig(config) {\n    if (typeof config.maxSizeBytes !== \"undefined\") {\n        try {\n            const bytes = parseSizeString(config.maxSizeBytes);\n            if (bytes <= 0) {\n                throw new Error(\"maxSizeBytes must be positive\");\n            }\n        } catch (error) {\n            throw new Error(`Invalid maxSizeBytes: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n        }\n    }\n    if (typeof config.maxItems !== \"undefined\") {\n        if (!Number.isInteger(config.maxItems) || config.maxItems <= 0) {\n            throw new Error(\"maxItems must be a positive integer\");\n        }\n    }\n}\n// src/ops/one.ts\nvar logger2 = logger_default.get(\"one\");\nvar one = async (query = {}, locations = [], context)=>{\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger2.default(\"one\", {\n        query,\n        locations\n    });\n    const queryHash = createQueryHash(pkType, query, locations);\n    logger2.debug(\"Generated query hash for one\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys) {\n        logger2.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        if (cachedItemKeys.length === 0) {\n            return [\n                context,\n                null\n            ];\n        }\n        const item = await cacheMap.get(cachedItemKeys[0]);\n        if (item) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)\n            ];\n        } else {\n            logger2.debug(\"Cached item missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    let retItem = null;\n    try {\n        retItem = await api.one(query, locations);\n        if (retItem) {\n            await cacheMap.set(retItem.key, retItem);\n            const keyStr = JSON.stringify(retItem.key);\n            const metadata = await cacheMap.getMetadata(keyStr);\n            if (!metadata) {\n                const now = Date.now();\n                const baseMetadata = {\n                    key: keyStr,\n                    addedAt: now,\n                    lastAccessedAt: now,\n                    accessCount: 1,\n                    estimatedSize: estimateValueSize(retItem)\n                };\n                await cacheMap.setMetadata(keyStr, baseMetadata);\n            }\n            await ttlManager.onItemAdded(keyStr, cacheMap);\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr, retItem, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n            await cacheMap.setQueryResult(queryHash, [\n                retItem.key\n            ]);\n            logger2.debug(\"Cached query result\", {\n                queryHash,\n                itemKey: retItem.key\n            });\n        } else {\n            await cacheMap.setQueryResult(queryHash, []);\n            logger2.debug(\"Cached empty query result\", {\n                queryHash\n            });\n        }\n    } catch (e) {\n        if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n            cacheMap.setQueryResult(queryHash, []);\n            logger2.debug(\"Cached empty query result for not found\", {\n                queryHash\n            });\n        } else {\n            throw e;\n        }\n    }\n    return [\n        context,\n        retItem ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retItem, pkType) : null\n    ];\n};\n// src/ops/create.ts\n\nvar logger3 = logger_default.get(\"create\");\nvar create = async (v, locations = [], context)=>{\n    const { api, cacheMap, pkType, eventEmitter, ttlManager, evictionManager } = context;\n    logger3.default(\"create\", {\n        v,\n        locations\n    });\n    const created = await api.create(v, locations);\n    cacheMap.set(created.key, created);\n    const keyStr = JSON.stringify(created.key);\n    ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await evictionManager.onItemAdded(keyStr, created, cacheMap);\n    for (const evictedKey of evictedKeys){\n        const parsedKey = JSON.parse(evictedKey);\n        await cacheMap.delete(parsedKey);\n    }\n    const event = CacheEventFactory.itemCreated(created.key, created, \"api\");\n    eventEmitter.emit(event);\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(created, pkType)\n    ];\n};\n// src/ops/get.ts\n\nvar logger4 = logger_default.get(\"get\");\nvar inFlightRequests = /* @__PURE__ */ new Map();\nvar CLEANUP_TIMEOUT = 5 * 60 * 1e3;\nvar cleanupStaleRequests = ()=>{\n    const now = Date.now();\n    const keysToDelete = [];\n    inFlightRequests.forEach((request, key)=>{\n        if (now - request.timestamp > CLEANUP_TIMEOUT) {\n            keysToDelete.push(key);\n        }\n    });\n    keysToDelete.forEach((key)=>{\n        logger4.debug(\"Cleaning up stale in-flight request\", {\n            key\n        });\n        inFlightRequests.delete(key);\n    });\n};\nvar cleanupInterval = setInterval(cleanupStaleRequests, 60 * 1e3);\nvar keyToString = createNormalizedHashFunction();\nvar get = async (key, context)=>{\n    const { api, cacheMap, pkType, ttlManager, statsManager } = context;\n    logger4.default(\"get\", {\n        key,\n        defaultTTL: ttlManager.getDefaultTTL()\n    });\n    statsManager.incrementRequests();\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger4.error(\"Key for Get is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Get is not a valid ItemKey\");\n    }\n    if (ttlManager.isTTLEnabled()) {\n        const keyStr2 = JSON.stringify(key);\n        const cachedItem = await cacheMap.get(key);\n        if (cachedItem) {\n            const isValid = await ttlManager.validateItem(keyStr2, cacheMap);\n            if (isValid) {\n                logger4.debug(\"Cache hit with valid TTL\", {\n                    key,\n                    defaultTTL: ttlManager.getDefaultTTL()\n                });\n                statsManager.incrementHits();\n                return [\n                    context,\n                    (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)\n                ];\n            } else {\n                logger4.debug(\"Cache item expired, removing\", {\n                    key\n                });\n                cacheMap.delete(key);\n                statsManager.incrementMisses();\n            }\n        } else {\n            statsManager.incrementMisses();\n        }\n        logger4.debug(\"Cache miss or expired\", {\n            key,\n            defaultTTL: ttlManager.getDefaultTTL()\n        });\n    } else {\n        const cachedItem = await cacheMap.get(key);\n        if (cachedItem) {\n            logger4.debug(\"Cache hit (TTL disabled)\", {\n                key\n            });\n            statsManager.incrementHits();\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)\n            ];\n        } else {\n            statsManager.incrementMisses();\n        }\n    }\n    let ret;\n    const keyStr = keyToString(key);\n    try {\n        const requestEntry = inFlightRequests.get(keyStr);\n        let apiRequest;\n        if (!requestEntry) {\n            apiRequest = api.get(key);\n            if (apiRequest && typeof apiRequest.then === \"function\") {\n                const timestamp = Date.now();\n                inFlightRequests.set(keyStr, {\n                    promise: apiRequest,\n                    timestamp\n                });\n                const cleanup = ()=>inFlightRequests.delete(keyStr);\n                if (typeof apiRequest.finally === \"function\") {\n                    apiRequest.finally(cleanup);\n                } else {\n                    apiRequest.then(cleanup, cleanup);\n                }\n            }\n        } else {\n            logger4.debug(\"Using in-flight request for key\", {\n                key\n            });\n            apiRequest = requestEntry.promise;\n        }\n        ret = await apiRequest;\n        if (ret) {\n            await cacheMap.set(ret.key, ret);\n            const keyStr2 = JSON.stringify(ret.key);\n            const metadata = await cacheMap.getMetadata(keyStr2);\n            if (!metadata) {\n                const now = Date.now();\n                const baseMetadata = {\n                    key: keyStr2,\n                    addedAt: now,\n                    lastAccessedAt: now,\n                    accessCount: 1,\n                    estimatedSize: estimateValueSize(ret)\n                };\n                await cacheMap.setMetadata(keyStr2, baseMetadata);\n            }\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr2, ret, cacheMap);\n            await ttlManager.onItemAdded(keyStr2, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n            const event = CacheEventFactory.itemRetrieved(ret.key, ret, \"api\");\n            context.eventEmitter.emit(event);\n        }\n    } catch (e) {\n        inFlightRequests.delete(keyStr);\n        logger4.error(\"Error getting item for key\", {\n            key,\n            message: e.message,\n            stack: e.stack\n        });\n        throw e;\n    }\n    return [\n        context,\n        ret ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType) : null\n    ];\n};\n// src/ops/retrieve.ts\n\nvar logger5 = logger_default.get(\"retrieve\");\nvar retrieve = async (key, context)=>{\n    const { cacheMap, pkType, statsManager } = context;\n    logger5.default(\"retrieve\", {\n        key\n    });\n    statsManager.incrementRequests();\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger5.error(\"Key for Retrieve is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Retrieve is not a valid ItemKey\");\n    }\n    const containsItemKey = await cacheMap.includesKey(key);\n    let retrieved;\n    let contextToReturn;\n    if (containsItemKey) {\n        logger5.default(\"Looking for Object in Cache\", key);\n        retrieved = await cacheMap.get(key);\n        contextToReturn = null;\n        statsManager.incrementHits();\n    } else {\n        logger5.default(\"Object Not Found in Cache, Retrieving from Server API\", {\n            key\n        });\n        statsManager.incrementMisses();\n        [contextToReturn, retrieved] = await get(key, context);\n    }\n    const retValue = [\n        contextToReturn,\n        retrieved ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retrieved, pkType) : null\n    ];\n    return retValue;\n};\n// src/ops/remove.ts\n\nvar logger6 = logger_default.get(\"remove\");\nvar remove = async (key, context)=>{\n    const { api, cacheMap } = context;\n    logger6.default(\"remove\", {\n        key\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger6.error(\"Key for Remove is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Remove is not a valid ItemKey\");\n    }\n    try {\n        const previousItem = await cacheMap.get(key);\n        await api.remove(key);\n        cacheMap.delete(key);\n        if (previousItem) {\n            const event = CacheEventFactory.itemRemoved(key, previousItem, \"api\");\n            context.eventEmitter.emit(event);\n        }\n        logger6.debug(\"Successfully removed item from API and cache\", {\n            key\n        });\n    } catch (e) {\n        logger6.error(\"Error deleting item\", {\n            error: e\n        });\n        throw e;\n    }\n    return context;\n};\n// src/ops/update.ts\n\nvar logger7 = logger_default.get(\"update\");\nvar update = async (key, v, context)=>{\n    const { api, cacheMap, pkType } = context;\n    logger7.default(\"update\", {\n        key,\n        v\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger7.error(\"Key for Update is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Update is not a valid ItemKey\");\n    }\n    logger7.debug(\"Invalidating item key before update\", {\n        key\n    });\n    cacheMap.invalidateItemKeys([\n        key\n    ]);\n    try {\n        const previousItem = await cacheMap.get(key);\n        const updated = await api.update(key, v);\n        logger7.debug(\"Caching update result\", {\n            updatedKey: updated.key\n        });\n        await cacheMap.set(updated.key, updated);\n        const keyStr = JSON.stringify(updated.key);\n        const metadata = await cacheMap.getMetadata(keyStr);\n        if (!metadata) {\n            const now = Date.now();\n            const baseMetadata = {\n                key: keyStr,\n                addedAt: now,\n                lastAccessedAt: now,\n                accessCount: 1,\n                estimatedSize: estimateValueSize(updated)\n            };\n            await cacheMap.setMetadata(keyStr, baseMetadata);\n        }\n        await context.ttlManager.onItemAdded(keyStr, cacheMap);\n        const evictedKeys = await context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n        for (const evictedKey of evictedKeys){\n            const parsedKey = JSON.parse(evictedKey);\n            await cacheMap.delete(parsedKey);\n        }\n        const event = CacheEventFactory.itemUpdated(updated.key, updated, previousItem, \"api\");\n        context.eventEmitter.emit(event);\n        return [\n            context,\n            (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)\n        ];\n    } catch (e) {\n        logger7.error(\"Error updating item\", {\n            error: e\n        });\n        throw e;\n    }\n};\n// src/ops/action.ts\n\nvar logger8 = logger_default.get(\"action\");\nvar action = async (key, action2, body = {}, context)=>{\n    const { api, cacheMap, pkType } = context;\n    logger8.default(\"action\", {\n        key,\n        action: action2,\n        body\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger8.error(\"Key for Action is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Action is not a valid ItemKey\");\n    }\n    logger8.debug(\"Invalidating item key before action\", {\n        key\n    });\n    cacheMap.invalidateItemKeys([\n        key\n    ]);\n    const updated = await api.action(key, action2, body);\n    logger8.debug(\"Caching action result\", {\n        updatedKey: updated.key\n    });\n    cacheMap.set(updated.key, updated);\n    const keyStr = JSON.stringify(updated.key);\n    context.ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n    for (const evictedKey of evictedKeys){\n        try {\n            const parsedKey = JSON.parse(evictedKey);\n            await cacheMap.delete(parsedKey);\n        } catch (error) {\n            logger8.error(\"Failed to parse evicted key during deletion\", {\n                evictedKey,\n                error: error instanceof Error ? error.message : String(error)\n            });\n        }\n    }\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)\n    ];\n};\n// src/ops/allAction.ts\n\n\nvar logger9 = logger_default.get(\"allAction\");\nvar allAction = async (action2, body = {}, locations = [], context)=>{\n    const { api, cacheMap, pkType } = context;\n    logger9.default(\"allAction\", {\n        action: action2,\n        body,\n        locations\n    });\n    logger9.debug(\"Invalidating location before allAction\", {\n        locations\n    });\n    cacheMap.invalidateLocation(locations);\n    let ret = [];\n    try {\n        ret = await api.allAction(action2, body, locations);\n        logger9.debug(\"Caching allAction results\", {\n            resultCount: ret.length\n        });\n        for (const v of ret){\n            await cacheMap.set(v.key, v);\n            const keyStr = JSON.stringify(v.key);\n            context.ttlManager.onItemAdded(keyStr, cacheMap);\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n        }\n    } catch (e) {\n        if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {} else {\n            throw e;\n        }\n    }\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/facet.ts\nvar logger10 = logger_default.get(\"facet\");\nvar facet = async (key, facet2, params = {}, context)=>{\n    const { api } = context;\n    logger10.default(\"facet\", {\n        key,\n        facet: facet2\n    });\n    const ret = await api.facet(key, facet2, params);\n    return ret;\n};\n// src/ops/allFacet.ts\nvar logger11 = logger_default.get(\"allFacet\");\nvar allFacet = async (facet2, params = {}, locations = [], context)=>{\n    const { api } = context;\n    logger11.default(\"allFacet\", {\n        facet: facet2,\n        params,\n        locations\n    });\n    const ret = await api.allFacet(facet2, params, locations);\n    return ret;\n};\n// src/ops/find.ts\n\nvar logger12 = logger_default.get(\"find\");\nvar find = async (finder, params = {}, locations = [], context)=>{\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger12.default(\"find\", {\n        finder,\n        params,\n        locations\n    });\n    const queryHash = createFinderHash(finder, params, locations);\n    logger12.debug(\"Generated query hash for find\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys) {\n        logger12.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        const cachedItems = [];\n        let allItemsAvailable = true;\n        for (const itemKey of cachedItemKeys){\n            const item = await cacheMap.get(itemKey);\n            if (item) {\n                cachedItems.push(item);\n            } else {\n                allItemsAvailable = false;\n                break;\n            }\n        }\n        if (allItemsAvailable) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)\n            ];\n        } else {\n            logger12.debug(\"Some cached items missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    const ret = await api.find(finder, params, locations);\n    for (const v of ret){\n        await cacheMap.set(v.key, v);\n        const keyStr = JSON.stringify(v.key);\n        ttlManager.onItemAdded(keyStr, cacheMap);\n        const evictedKeys = await context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n        for (const evictedKey of evictedKeys){\n            const parsedKey = JSON.parse(evictedKey);\n            await cacheMap.delete(parsedKey);\n        }\n    }\n    const itemKeys = ret.map((item)=>item.key);\n    cacheMap.setQueryResult(queryHash, itemKeys);\n    logger12.debug(\"Cached query result\", {\n        queryHash,\n        itemKeyCount: itemKeys.length\n    });\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/findOne.ts\n\nvar logger13 = logger_default.get(\"findOne\");\nvar findOne = async (finder, finderParams = {}, locations = [], context)=>{\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger13.default(\"findOne\", {\n        finder,\n        finderParams,\n        locations\n    });\n    const queryHash = createFinderHash(finder, finderParams, locations);\n    logger13.debug(\"Generated query hash for findOne\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys && cachedItemKeys.length > 0) {\n        logger13.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        const item = await cacheMap.get(cachedItemKeys[0]);\n        if (item) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)\n            ];\n        } else {\n            logger13.debug(\"Cached item missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    const ret = await api.findOne(finder, finderParams, locations);\n    cacheMap.set(ret.key, ret);\n    const keyStr = JSON.stringify(ret.key);\n    ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await context.evictionManager.onItemAdded(keyStr, ret, cacheMap);\n    for (const evictedKey of evictedKeys){\n        const parsedKey = JSON.parse(evictedKey);\n        await cacheMap.delete(parsedKey);\n    }\n    cacheMap.setQueryResult(queryHash, [\n        ret.key\n    ]);\n    logger13.debug(\"Cached query result\", {\n        queryHash,\n        itemKey: ret.key\n    });\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/set.ts\n\nvar logger14 = logger_default.get(\"set\");\nvar normalizeKeyValue2 = (value)=>{\n    return String(value);\n};\nvar isItemKeyEqualNormalized = (a, b)=>{\n    const normalizedA = normalizeKey(a);\n    const normalizedB = normalizeKey(b);\n    return (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isItemKeyEqual)(normalizedA, normalizedB);\n};\nvar normalizeKey = (key)=>{\n    if (typeof key === \"object\" && key !== null) {\n        let needsNormalization = false;\n        let normalizedKey = key;\n        if (\"pk\" in key && key.pk !== null && typeof key.pk !== \"string\") {\n            needsNormalization = true;\n        }\n        if (\"lk\" in key && key.lk !== null && typeof key.lk !== \"string\") {\n            needsNormalization = true;\n        }\n        if (\"loc\" in key && Array.isArray(key.loc)) {\n            for (const locItem of key.loc){\n                if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n                    needsNormalization = true;\n                    break;\n                }\n            }\n        }\n        if (needsNormalization) {\n            normalizedKey = {\n                ...key\n            };\n            if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n                normalizedKey.pk = normalizeKeyValue2(normalizedKey.pk);\n            }\n            if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n                normalizedKey.lk = normalizeKeyValue2(normalizedKey.lk);\n            }\n            if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n                normalizedKey.loc = normalizedKey.loc.map((locItem)=>{\n                    if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n                        return {\n                            ...locItem,\n                            lk: normalizeKeyValue2(locItem.lk)\n                        };\n                    }\n                    return locItem;\n                });\n            }\n        }\n        return normalizedKey;\n    }\n    return key;\n};\nvar set = async (key, v, context)=>{\n    const { cacheMap, pkType, ttlManager, evictionManager, eventEmitter } = context;\n    logger14.default(\"set\", {\n        key,\n        v\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger14.error(\"Key for Set is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Set is not a valid ItemKey\");\n    }\n    (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType);\n    if (!isItemKeyEqualNormalized(key, v.key)) {\n        logger14.error(\"Key does not match item key: %j != %j\", key, v.key);\n        throw new Error(\"Key does not match item key\");\n    }\n    const previousItem = await cacheMap.get(key);\n    await cacheMap.set(key, v);\n    const keyStr = JSON.stringify(key);\n    const metadata = await cacheMap.getMetadata(keyStr);\n    if (!metadata) {\n        const now = Date.now();\n        const baseMetadata = {\n            key: keyStr,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize: estimateValueSize(v)\n        };\n        await cacheMap.setMetadata(keyStr, baseMetadata);\n    }\n    await ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await evictionManager.onItemAdded(keyStr, v, cacheMap);\n    for (const evictedKey of evictedKeys){\n        const parsedKey = JSON.parse(evictedKey);\n        await cacheMap.delete(parsedKey);\n    }\n    const event = CacheEventFactory.itemSet(key, v, previousItem);\n    eventEmitter.emit(event);\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType)\n    ];\n};\n// src/memory/MemoryCacheMap.ts\n\n// src/CacheMap.ts\nvar CacheMap = class {\n    constructor(types){\n        this.types = types;\n    }\n};\n// src/memory/MemoryCacheMap.ts\nvar logger15 = logger_default.get(\"MemoryCacheMap\");\nvar MemoryCacheMap = class _MemoryCacheMap extends CacheMap {\n    constructor(types, initialData){\n        super(types), this.implementationType = \"memory/memory\", this.map = {}, // Query result cache: maps query hash to cache entry\n        this.queryResultCache = {}, // Metadata storage for eviction strategies\n        this.metadataMap = /* @__PURE__ */ new Map();\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        if (initialData) {\n            for (const [keyStr, value] of Object.entries(initialData)){\n                try {\n                    const key = JSON.parse(keyStr);\n                    this.set(key, value);\n                } catch (error) {\n                    logger15.error(\"Failed to parse initial data key\", {\n                        keyStr,\n                        error\n                    });\n                }\n            }\n        }\n    }\n    async get(key) {\n        logger15.trace(\"get\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            const keyStr = JSON.stringify(key);\n            const metadata = this.metadataMap.get(keyStr);\n            if (metadata) {\n                metadata.lastAccessedAt = Date.now();\n                metadata.accessCount++;\n            }\n            return entry.value;\n        }\n        return null;\n    }\n    async set(key, value) {\n        logger15.trace(\"set\", {\n            key,\n            value\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const keyStr = JSON.stringify(key);\n        this.map[hashedKey] = {\n            originalKey: key,\n            value\n        };\n        if (!this.metadataMap.has(keyStr)) {\n            const now = Date.now();\n            const metadata = {\n                key: keyStr,\n                addedAt: now,\n                lastAccessedAt: now,\n                accessCount: 1,\n                estimatedSize: estimateValueSize(value)\n            };\n            this.metadataMap.set(keyStr, metadata);\n        } else {\n            const metadata = this.metadataMap.get(keyStr);\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            metadata.estimatedSize = estimateValueSize(value);\n        }\n    }\n    async includesKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey;\n    }\n    async delete(key) {\n        logger15.trace(\"delete\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            const keyStr = JSON.stringify(entry.originalKey);\n            this.metadataMap.delete(keyStr);\n            delete this.map[hashedKey];\n            for (const [queryHash, cacheEntry] of Object.entries(this.queryResultCache)){\n                cacheEntry.itemKeys = cacheEntry.itemKeys.filter((k)=>this.normalizedHashFunction(k) !== hashedKey);\n                if (cacheEntry.itemKeys.length === 0) {\n                    delete this.queryResultCache[queryHash];\n                }\n            }\n        }\n    }\n    async keys() {\n        return Object.values(this.map).map((entry)=>entry.originalKey);\n    }\n    async values() {\n        return Object.values(this.map).map((entry)=>entry.value);\n    }\n    async clear() {\n        this.map = {};\n        this.metadataMap.clear();\n        this.queryResultCache = {};\n    }\n    async allIn(locations) {\n        const allValues = await this.values();\n        if (locations.length === 0) {\n            logger15.debug(\"Returning all items, LocKeys is empty\");\n            return allValues;\n        } else {\n            logger15.debug(\"allIn\", {\n                locations,\n                count: allValues.length\n            });\n            return allValues.filter((item)=>{\n                const key = item.key;\n                if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n                    const comKey = key;\n                    return isLocKeyArrayEqual(locations, comKey.loc);\n                }\n                return false;\n            });\n        }\n    }\n    async contains(query, locations) {\n        logger15.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query, locations = []) {\n        logger15.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        const clone = new _MemoryCacheMap(this.types);\n        const keys = await this.keys();\n        for (const key of keys){\n            const value = await this.get(key);\n            if (value) {\n                await clone.set(key, value);\n            }\n        }\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            clone.queryResultCache[queryHash] = {\n                itemKeys: [\n                    ...entry.itemKeys\n                ]\n            };\n        }\n        return clone;\n    }\n    // Query result caching methods implementation\n    async setQueryResult(queryHash, itemKeys) {\n        logger15.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        const entry = {\n            itemKeys: [\n                ...itemKeys\n            ]\n        };\n        this.queryResultCache[queryHash] = entry;\n    }\n    async getQueryResult(queryHash) {\n        logger15.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const entry = this.queryResultCache[queryHash];\n        if (!entry) {\n            return null;\n        }\n        return [\n            ...entry.itemKeys\n        ];\n    }\n    async hasQueryResult(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        return !!entry;\n    }\n    async deleteQueryResult(queryHash) {\n        logger15.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        delete this.queryResultCache[queryHash];\n    }\n    async invalidateItemKeys(keys) {\n        logger15.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            await this.delete(key);\n        }\n    }\n    async invalidateLocation(locations) {\n        logger15.debug(\"invalidateLocation\", {\n            locations\n        });\n        if (locations.length === 0) {\n            const allKeys = await this.keys();\n            const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n            await this.invalidateItemKeys(primaryKeys);\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            const keysToInvalidate = itemsInLocation.map((item)=>item.key);\n            await this.invalidateItemKeys(keysToInvalidate);\n        }\n        await this.clearQueryResults();\n    }\n    async clearQueryResults() {\n        logger15.trace(\"clearQueryResults\");\n        this.queryResultCache = {};\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        return this.metadataMap.get(key) || null;\n    }\n    async setMetadata(key, metadata) {\n        this.metadataMap.set(key, metadata);\n    }\n    async deleteMetadata(key) {\n        this.metadataMap.delete(key);\n    }\n    async getAllMetadata() {\n        return new Map(this.metadataMap);\n    }\n    async clearMetadata() {\n        this.metadataMap.clear();\n    }\n    async getCurrentSize() {\n        let sizeBytes = 0;\n        for (const entry of Object.values(this.map)){\n            sizeBytes += estimateValueSize(entry.value);\n        }\n        return {\n            itemCount: Object.keys(this.map).length,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            maxSizeBytes: null\n        };\n    }\n};\n// src/memory/EnhancedMemoryCacheMap.ts\n\nvar logger16 = logger_default.get(\"EnhancedMemoryCacheMap\");\nvar EnhancedMemoryCacheMap = class _EnhancedMemoryCacheMap extends CacheMap {\n    constructor(types, sizeConfig, initialData){\n        super(types), this.implementationType = \"memory/enhanced\", this.map = {}, // Query result cache: maps query hash to cache entry\n        this.queryResultCache = {}, // Size tracking\n        this.currentSizeBytes = 0, this.currentItemCount = 0, this.queryResultsCacheSize = 0;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        if (sizeConfig?.maxSizeBytes) {\n            this.maxSizeBytes = parseSizeString(sizeConfig.maxSizeBytes);\n            logger16.debug(\"Cache size limit set\", {\n                maxSizeBytes: this.maxSizeBytes\n            });\n        }\n        if (sizeConfig?.maxItems) {\n            this.maxItems = sizeConfig.maxItems;\n            logger16.debug(\"Cache item limit set\", {\n                maxItems: this.maxItems\n            });\n        }\n        if (initialData) {\n            for (const [keyStr, value] of Object.entries(initialData)){\n                try {\n                    const key = JSON.parse(keyStr);\n                    this.set(key, value);\n                } catch (error) {\n                    logger16.error(\"Failed to parse initial data key\", {\n                        keyStr,\n                        error\n                    });\n                }\n            }\n        }\n    }\n    async get(key) {\n        logger16.trace(\"get\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null) {\n            return entry.value;\n        }\n        return null;\n    }\n    async set(key, value) {\n        logger16.trace(\"set\", {\n            key,\n            value\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const estimatedSize = estimateValueSize(value);\n        const existingEntry = this.map[hashedKey];\n        const isUpdate = existingEntry && this.normalizedHashFunction(existingEntry.originalKey) === hashedKey;\n        if (isUpdate) {\n            const sizeDiff = estimatedSize - existingEntry.metadata.estimatedSize;\n            this.currentSizeBytes += sizeDiff;\n            const oldValue = existingEntry.value;\n            existingEntry.value = value;\n            existingEntry.metadata.estimatedSize = estimatedSize;\n            logger16.trace(\"Updated existing cache entry\", {\n                key: hashedKey,\n                sizeDiff,\n                currentSize: this.currentSizeBytes,\n                oldValue: oldValue !== value\n            });\n        } else {\n            const metadata = {\n                addedAt: Date.now(),\n                lastAccessedAt: Date.now(),\n                accessCount: 0,\n                estimatedSize,\n                key: hashedKey\n            };\n            this.map[hashedKey] = {\n                originalKey: key,\n                value,\n                metadata\n            };\n            this.currentSizeBytes += estimatedSize;\n            this.currentItemCount++;\n            logger16.trace(\"Added new cache entry\", {\n                key: hashedKey,\n                size: estimatedSize,\n                currentSize: this.currentSizeBytes,\n                currentCount: this.currentItemCount\n            });\n        }\n    }\n    async includesKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null;\n    }\n    async delete(key) {\n        this.deleteInternal(key, true, \"filter\");\n    }\n    deleteInternal(key, invalidateQueries = false, invalidationMode = \"remove\") {\n        logger16.trace(\"delete\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            this.currentSizeBytes -= entry.metadata.estimatedSize;\n            this.currentItemCount--;\n            delete this.map[hashedKey];\n            logger16.trace(\"Deleted cache entry\", {\n                key: hashedKey,\n                freedSize: entry.metadata.estimatedSize,\n                currentSize: this.currentSizeBytes,\n                currentCount: this.currentItemCount\n            });\n            if (invalidateQueries) {\n                if (invalidationMode === \"filter\") {\n                    this.filterQueriesReferencingKeys([\n                        key\n                    ]);\n                } else {\n                    this.invalidateQueriesReferencingKeys([\n                        key\n                    ]);\n                }\n            }\n        }\n    }\n    async keys() {\n        return Object.values(this.map).filter((entry)=>entry.value !== null).map((entry)=>entry.originalKey);\n    }\n    async values() {\n        return Object.values(this.map).filter((entry)=>entry.value !== null).map((entry)=>entry.value);\n    }\n    async clear() {\n        logger16.debug(\"Clearing cache\", {\n            itemsCleared: this.currentItemCount,\n            bytesFreed: this.currentSizeBytes\n        });\n        this.map = {};\n        this.currentSizeBytes = 0;\n        this.currentItemCount = 0;\n    }\n    async allIn(locations) {\n        const allValues = await this.values();\n        if (locations.length === 0) {\n            logger16.debug(\"Returning all items, LocKeys is empty\");\n            return allValues;\n        } else {\n            logger16.debug(\"allIn\", {\n                locations,\n                count: allValues.length\n            });\n            return allValues.filter((item)=>{\n                const key = item.key;\n                if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n                    return isLocKeyArrayEqual(locations, key.loc);\n                }\n                return false;\n            });\n        }\n    }\n    async contains(query, locations) {\n        logger16.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query, locations = []) {\n        logger16.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        const sizeConfig = {};\n        if (this.maxSizeBytes) {\n            sizeConfig.maxSizeBytes = this.maxSizeBytes.toString();\n        }\n        if (this.maxItems) {\n            sizeConfig.maxItems = this.maxItems;\n        }\n        const clone = new _EnhancedMemoryCacheMap(this.types, sizeConfig);\n        const keys = await this.keys();\n        for (const key of keys){\n            const value = await this.get(key);\n            if (value) {\n                await clone.set(key, value);\n            }\n        }\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            await clone.setQueryResult(queryHash, entry.itemKeys);\n        }\n        return clone;\n    }\n    /**\n   * Get current cache statistics\n   */ getStats() {\n        const stats = {\n            currentSizeBytes: this.currentSizeBytes,\n            currentItemCount: this.currentItemCount,\n            maxSizeBytes: this.maxSizeBytes,\n            maxItems: this.maxItems,\n            utilizationPercent: {}\n        };\n        if (this.maxSizeBytes) {\n            stats.utilizationPercent.bytes = this.currentSizeBytes / this.maxSizeBytes * 100;\n        }\n        if (this.maxItems) {\n            stats.utilizationPercent.items = this.currentItemCount / this.maxItems * 100;\n        }\n        return stats;\n    }\n    // Query result caching methods\n    async setQueryResult(queryHash, itemKeys) {\n        logger16.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        if (queryHash in this.queryResultCache) {\n            this.removeQueryResultFromSizeTracking(queryHash);\n        }\n        const entry = {\n            itemKeys: [\n                ...itemKeys\n            ]\n        };\n        this.queryResultCache[queryHash] = entry;\n        this.addQueryResultToSizeTracking(queryHash, entry);\n    }\n    async getQueryResult(queryHash) {\n        logger16.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const entry = this.queryResultCache[queryHash];\n        if (!entry) {\n            return null;\n        }\n        return [\n            ...entry.itemKeys\n        ];\n    }\n    async hasQueryResult(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        return !!entry;\n    }\n    async deleteQueryResult(queryHash) {\n        if (queryHash in this.queryResultCache) {\n            this.removeQueryResultFromSizeTracking(queryHash);\n            delete this.queryResultCache[queryHash];\n        }\n    }\n    async clearQueryResults() {\n        this.queryResultCache = {};\n        this.queryResultsCacheSize = 0;\n    }\n    async invalidateItemKeys(keys) {\n        logger16.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        if (keys.length === 0) {\n            return;\n        }\n        for (const key of keys){\n            this.deleteInternal(key, false);\n        }\n        this.invalidateQueriesReferencingKeys(keys);\n    }\n    filterQueriesReferencingKeys(keys) {\n        if (keys.length === 0) {\n            return;\n        }\n        const hashedKeysToInvalidate = new Set(keys.map((key)=>this.normalizedHashFunction(key)));\n        const queriesToRemove = [];\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            const filteredKeys = entry.itemKeys.filter((itemKey)=>{\n                const hashedItemKey = this.normalizedHashFunction(itemKey);\n                return !hashedKeysToInvalidate.has(hashedItemKey);\n            });\n            if (filteredKeys.length === 0) {\n                queriesToRemove.push(queryHash);\n            } else if (filteredKeys.length !== entry.itemKeys.length) {\n                this.setQueryResult(queryHash, filteredKeys);\n            }\n        }\n        queriesToRemove.forEach((queryHash)=>{\n            this.deleteQueryResult(queryHash);\n        });\n    }\n    invalidateQueriesReferencingKeys(keys) {\n        if (keys.length === 0) {\n            return;\n        }\n        const hashedKeysToInvalidate = new Set(keys.map((key)=>this.normalizedHashFunction(key)));\n        const queriesToRemove = [];\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            const queryReferencesInvalidatedKey = entry.itemKeys.some((itemKey)=>{\n                const hashedItemKey = this.normalizedHashFunction(itemKey);\n                return hashedKeysToInvalidate.has(hashedItemKey);\n            });\n            if (queryReferencesInvalidatedKey) {\n                queriesToRemove.push(queryHash);\n            }\n        }\n        queriesToRemove.forEach((queryHash)=>{\n            this.deleteQueryResult(queryHash);\n        });\n    }\n    async invalidateLocation(locations) {\n        logger16.debug(\"invalidateLocation\", {\n            locations\n        });\n        let keysToInvalidate = [];\n        if (locations.length === 0) {\n            const allKeys = await this.keys();\n            const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n            keysToInvalidate = primaryKeys;\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            keysToInvalidate = itemsInLocation.map((item)=>item.key);\n        }\n        await this.invalidateItemKeys(keysToInvalidate);\n    }\n    /**\n   * Add query result to size tracking\n   */ addQueryResultToSizeTracking(queryHash, entry) {\n        const hashSize = estimateValueSize(queryHash);\n        const itemKeysSize = estimateValueSize(entry.itemKeys);\n        const totalSize = hashSize + itemKeysSize;\n        this.queryResultsCacheSize += totalSize;\n        logger16.trace(\"Added query result to size tracking\", {\n            queryHash,\n            estimatedSize: totalSize,\n            totalQueryCacheSize: this.queryResultsCacheSize\n        });\n    }\n    /**\n   * Remove query result from size tracking\n   */ removeQueryResultFromSizeTracking(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        if (entry) {\n            const hashSize = estimateValueSize(queryHash);\n            const itemKeysSize = estimateValueSize(entry.itemKeys);\n            const totalSize = hashSize + itemKeysSize;\n            this.queryResultsCacheSize = Math.max(0, this.queryResultsCacheSize - totalSize);\n            logger16.trace(\"Removed query result from size tracking\", {\n                queryHash,\n                estimatedSize: totalSize,\n                totalQueryCacheSize: this.queryResultsCacheSize\n            });\n        }\n    }\n    /**\n   * Get total cache size including query results\n   */ getTotalSizeBytes() {\n        return this.currentSizeBytes + this.queryResultsCacheSize;\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        const entry = this.map[key];\n        if (entry && !entry.metadataCleared) {\n            return entry.metadata;\n        }\n        return null;\n    }\n    async setMetadata(key, metadata) {\n        const entry = this.map[key];\n        if (entry) {\n            entry.metadata = metadata;\n            entry.metadataCleared = false;\n        } else {\n            let originalKey;\n            try {\n                originalKey = JSON.parse(key);\n            } catch  {\n                originalKey = {\n                    kt: \"metadata-only\",\n                    pk: key\n                };\n            }\n            this.map[key] = {\n                originalKey,\n                value: null,\n                // Placeholder value\n                metadata,\n                metadataCleared: false\n            };\n        }\n    }\n    async deleteMetadata(_key) {}\n    async getAllMetadata() {\n        const metadata = /* @__PURE__ */ new Map();\n        for (const [hashedKey, entry] of Object.entries(this.map)){\n            if (!entry.metadataCleared) {\n                metadata.set(hashedKey, entry.metadata);\n            }\n        }\n        return metadata;\n    }\n    async clearMetadata() {\n        const keysToRemove = [];\n        for (const [hashedKey, entry] of Object.entries(this.map)){\n            if (entry.value === null) {\n                keysToRemove.push(hashedKey);\n            } else {\n                entry.metadataCleared = true;\n            }\n        }\n        for (const key of keysToRemove){\n            delete this.map[key];\n        }\n    }\n    async getCurrentSize() {\n        return {\n            itemCount: this.currentItemCount,\n            sizeBytes: this.currentSizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: this.maxItems ?? null,\n            maxSizeBytes: this.maxSizeBytes ?? null\n        };\n    }\n};\n// src/browser/LocalStorageCacheMap.ts\n\nvar logger17 = logger_default.get(\"LocalStorageCacheMap\");\nvar LocalStorageCacheMap = class _LocalStorageCacheMap extends CacheMap {\n    // Remove 50% of entries when quota exceeded\n    constructor(types, keyPrefix = \"fjell-cache\"){\n        super(types), this.implementationType = \"browser/localStorage\", this.MAX_RETRY_ATTEMPTS = 3, this.AGGRESSIVE_CLEANUP_PERCENTAGE = 0.5;\n        this.keyPrefix = keyPrefix;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n    }\n    getStorageKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        return `${this.keyPrefix}:${hashedKey}`;\n    }\n    isQuotaExceededError(error) {\n        return error && (error.name === \"QuotaExceededError\" || error.name === \"NS_ERROR_DOM_QUOTA_REACHED\" || error.code === 22 || error.code === 1014);\n    }\n    getAllKeysStartingWith(prefix) {\n        const keys = [];\n        try {\n            for(let i = 0; i < localStorage.length; i++){\n                const key = localStorage.key(i);\n                if (key && key.startsWith(prefix)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        } catch (error) {\n            logger17.error(\"Error getting keys by prefix from localStorage\", {\n                prefix,\n                error\n            });\n            throw error;\n        }\n    }\n    tryCleanupOldEntries(aggressive = false) {\n        try {\n            const allEntries = this.collectCacheEntries();\n            if (allEntries.length === 0) {\n                logger17.debug(\"No entries to clean up\");\n                return false;\n            }\n            return this.removeOldestEntries(allEntries, aggressive);\n        } catch (error) {\n            logger17.error(\"Failed to cleanup old localStorage entries\", {\n                error\n            });\n            return false;\n        }\n    }\n    collectCacheEntries() {\n        const allEntries = [];\n        const keys = this.getAllStorageKeys();\n        for (const key of keys){\n            if (key.includes(\":metadata:\") || key.includes(\":query:\")) {\n                continue;\n            }\n            try {\n                const stored = localStorage.getItem(key);\n                if (stored) {\n                    const parsed = JSON.parse(stored);\n                    if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed) {\n                        allEntries.push({\n                            key,\n                            timestamp: parsed.timestamp || Date.now(),\n                            size: stored.length\n                        });\n                    } else {\n                        allEntries.push({\n                            key,\n                            timestamp: 0,\n                            size: stored.length\n                        });\n                    }\n                }\n            } catch (error) {\n                logger17.debug(\"Found corrupted entry during cleanup\", {\n                    key,\n                    error\n                });\n                allEntries.push({\n                    key,\n                    timestamp: 0,\n                    size: 0\n                });\n            }\n        }\n        return allEntries;\n    }\n    removeOldestEntries(allEntries, aggressive = false) {\n        allEntries.sort((a, b)=>a.timestamp - b.timestamp);\n        const cleanupPercentage = aggressive ? this.AGGRESSIVE_CLEANUP_PERCENTAGE : 0.25;\n        const toRemove = Math.max(1, Math.ceil(allEntries.length * cleanupPercentage));\n        let removedCount = 0;\n        let removedSize = 0;\n        for(let i = 0; i < toRemove && i < allEntries.length; i++){\n            try {\n                const key = allEntries[i].key;\n                localStorage.removeItem(key);\n                removedCount++;\n                removedSize += allEntries[i].size;\n            } catch (error) {\n                logger17.error(\"Failed to remove entry during cleanup\", {\n                    key: allEntries[i].key,\n                    error\n                });\n            }\n        }\n        if (removedCount > 0) {\n            const cleanupType = aggressive ? \"aggressive\" : \"normal\";\n            logger17.info(`Cleaned up ${removedCount} old localStorage entries (${removedSize} bytes) using ${cleanupType} cleanup to free space`);\n        }\n        return removedCount > 0;\n    }\n    getAllStorageKeys() {\n        return this.getAllKeysStartingWith(`${this.keyPrefix}:`);\n    }\n    async get(key) {\n        logger17.trace(\"get\", {\n            key\n        });\n        try {\n            const storageKey = this.getStorageKey(key);\n            let stored = localStorage.getItem(storageKey);\n            if (!stored && typeof key?.kt === \"string\" && key?.pk) {\n                const legacyKey = `${this.keyPrefix}:${key.kt}:${key.pk}`;\n                stored = localStorage.getItem(legacyKey);\n            }\n            if (stored) {\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key)) {\n                        return parsed.value;\n                    }\n                } catch (parseError) {\n                    logger17.debug(\"Failed to parse stored value\", {\n                        key,\n                        error: parseError\n                    });\n                    return null;\n                }\n            }\n            return null;\n        } catch (error) {\n            logger17.error(\"Error retrieving from localStorage\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    async set(key, value) {\n        logger17.trace(\"set\", {\n            key,\n            value\n        });\n        for(let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++){\n            try {\n                const storageKey = this.getStorageKey(key);\n                const toStore = {\n                    originalKey: key,\n                    value,\n                    timestamp: Date.now()\n                };\n                localStorage.setItem(storageKey, JSON.stringify(toStore));\n                if (attempt > 0) {\n                    logger17.info(`Successfully stored item after ${attempt} retries`);\n                }\n                return;\n            } catch (error) {\n                const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n                logger17.error(`Error storing to localStorage (attempt ${attempt + 1}/${this.MAX_RETRY_ATTEMPTS})`, {\n                    key,\n                    value,\n                    error,\n                    isLastAttempt\n                });\n                if (this.isQuotaExceededError(error)) {\n                    const useAggressiveCleanup = attempt > 0;\n                    this.tryCleanupOldEntries(useAggressiveCleanup);\n                    if (isLastAttempt) {\n                        throw new Error(\"Failed to store item in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n                    }\n                    continue;\n                }\n                throw new Error(`Failed to store item in localStorage: ${error instanceof Error ? error.message : String(error)}`);\n            }\n        }\n    }\n    async includesKey(key) {\n        try {\n            const storageKey = this.getStorageKey(key);\n            const stored = localStorage.getItem(storageKey);\n            if (stored) {\n                try {\n                    const parsed = JSON.parse(stored);\n                    return this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key);\n                } catch (parseError) {\n                    logger17.debug(\"Failed to parse stored value in includesKey\", {\n                        key,\n                        error: parseError\n                    });\n                    return false;\n                }\n            }\n            return false;\n        } catch (error) {\n            logger17.error(\"Error checking key in localStorage\", {\n                key,\n                error\n            });\n            return false;\n        }\n    }\n    async delete(key) {\n        logger17.trace(\"delete\", {\n            key\n        });\n        try {\n            const storageKey = this.getStorageKey(key);\n            localStorage.removeItem(storageKey);\n        } catch (error) {\n            logger17.error(\"Error deleting from localStorage\", {\n                key,\n                error\n            });\n            throw error;\n        }\n    }\n    async allIn(locations) {\n        const allKeys = this.keys();\n        if (locations.length === 0) {\n            logger17.debug(\"Returning all items, LocKeys is empty\");\n            const items = [];\n            for (const key of (await allKeys)){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        } else {\n            const locKeys = locations;\n            const resolvedKeys = await allKeys;\n            logger17.debug(\"allIn\", {\n                locKeys,\n                keys: resolvedKeys.length\n            });\n            const filteredKeys = resolvedKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                const ComKey13 = key;\n                logger17.debug(\"Comparing Location Keys\", {\n                    locKeys,\n                    ComKey: ComKey13\n                });\n                return isLocKeyArrayEqual(locKeys, ComKey13.loc);\n            });\n            const items = [];\n            for (const key of filteredKeys){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        }\n    }\n    async contains(query, locations) {\n        logger17.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query, locations = []) {\n        logger17.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        return new _LocalStorageCacheMap(this.types, this.keyPrefix);\n    }\n    parseStorageEntry(storageKey) {\n        try {\n            const stored = localStorage.getItem(storageKey);\n            if (stored) {\n                return JSON.parse(stored);\n            }\n        } catch (parseError) {\n            logger17.debug(\"Skipping corrupted localStorage entry\", {\n                storageKey,\n                error: parseError\n            });\n        }\n        return null;\n    }\n    async keys() {\n        const keys = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const parsed = this.parseStorageEntry(storageKey);\n                if (parsed?.originalKey) {\n                    keys.push(parsed.originalKey);\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error getting keys from localStorage\", {\n                error\n            });\n        }\n        return keys;\n    }\n    async values() {\n        const values = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const parsed = this.parseStorageEntry(storageKey);\n                if (parsed?.value) {\n                    values.push(parsed.value);\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error getting values from localStorage\", {\n                error\n            });\n        }\n        return values;\n    }\n    async clear() {\n        logger17.debug(\"Clearing localStorage cache\");\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                localStorage.removeItem(storageKey);\n            }\n        } catch (error) {\n            logger17.error(\"Error clearing localStorage cache\", {\n                error\n            });\n            throw error;\n        }\n    }\n    // Query result caching methods implementation\n    async setQueryResult(queryHash, itemKeys) {\n        logger17.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        const entry = {\n            itemKeys\n        };\n        try {\n            localStorage.setItem(queryKey, JSON.stringify(entry));\n        } catch (error) {\n            logger17.error(\"Failed to store query result in localStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async getQueryResult(queryHash) {\n        logger17.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        try {\n            const data = localStorage.getItem(queryKey);\n            if (!data) {\n                return null;\n            }\n            const entry = JSON.parse(data);\n            if (Array.isArray(entry)) {\n                return entry;\n            }\n            return entry.itemKeys || null;\n        } catch (error) {\n            logger17.error(\"Failed to retrieve query result from localStorage\", {\n                queryHash,\n                error\n            });\n            return null;\n        }\n    }\n    async hasQueryResult(queryHash) {\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        try {\n            return localStorage.getItem(queryKey) !== null;\n        } catch (error) {\n            logger17.error(\"Failed to check query result in localStorage\", {\n                queryHash,\n                error\n            });\n            return false;\n        }\n    }\n    async deleteQueryResult(queryHash) {\n        logger17.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        try {\n            localStorage.removeItem(queryKey);\n        } catch (error) {\n            logger17.error(\"Failed to delete query result from localStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async invalidateItemKeys(keys) {\n        logger17.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            try {\n                await this.delete(key);\n            } catch (error) {\n                logger17.error(\"Failed to delete key during invalidation\", {\n                    key,\n                    error\n                });\n            }\n        }\n    }\n    async invalidateLocation(locations) {\n        logger17.debug(\"invalidateLocation\", {\n            locations\n        });\n        try {\n            if (locations.length === 0) {\n                const allKeys = await this.keys();\n                const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n                await this.invalidateItemKeys(primaryKeys);\n            } else {\n                const allKeys = await this.keys();\n                const keysToInvalidate = allKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                    const compositeKey = key;\n                    return isLocKeyArrayEqual(locations, compositeKey.loc);\n                });\n                await this.invalidateItemKeys(keysToInvalidate);\n            }\n            await this.clearQueryResults();\n        } catch (error) {\n            logger17.error(\"Error in invalidateLocation\", {\n                locations,\n                error\n            });\n        }\n    }\n    async clearQueryResults() {\n        logger17.trace(\"clearQueryResults\");\n        const queryPrefix = `${this.keyPrefix}:query:`;\n        try {\n            const keysToRemove = this.getAllKeysStartingWith(queryPrefix);\n            for (const key of keysToRemove){\n                try {\n                    localStorage.removeItem(key);\n                } catch (error) {\n                    logger17.error(\"Failed to remove query result from localStorage\", {\n                        key,\n                        error\n                    });\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Failed to clear query results from localStorage\", {\n                error\n            });\n        }\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        try {\n            const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n            const stored = localStorage.getItem(metadataKey);\n            if (stored) {\n                try {\n                    return JSON.parse(stored);\n                } catch (e) {\n                    logger17.debug(\"Invalid metadata JSON, treating as null\", {\n                        key,\n                        error: e\n                    });\n                    return null;\n                }\n            }\n            return null;\n        } catch (error) {\n            logger17.error(\"Error getting metadata from localStorage\", {\n                key,\n                error\n            });\n            throw error;\n        }\n    }\n    async setMetadata(key, metadata) {\n        for(let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++){\n            try {\n                const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n                localStorage.setItem(metadataKey, JSON.stringify(metadata));\n                if (attempt > 0) {\n                    logger17.info(`Successfully stored metadata after ${attempt} retries`);\n                }\n                return;\n            } catch (error) {\n                const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n                logger17.error(`Error storing metadata to localStorage (attempt ${attempt + 1}/${this.MAX_RETRY_ATTEMPTS})`, {\n                    key,\n                    error,\n                    isLastAttempt\n                });\n                if (this.isQuotaExceededError(error)) {\n                    const useAggressiveCleanup = attempt > 0;\n                    this.tryCleanupOldEntries(useAggressiveCleanup);\n                    if (isLastAttempt) {\n                        throw new Error(\"Failed to store metadata in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n                    }\n                    continue;\n                }\n                throw new Error(`Failed to store metadata in localStorage: ${error instanceof Error ? error.message : String(error)}`);\n            }\n        }\n    }\n    async deleteMetadata(key) {\n        try {\n            const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n            localStorage.removeItem(metadataKey);\n        } catch (error) {\n            logger17.error(\"Error deleting metadata from localStorage\", {\n                key,\n                error\n            });\n            throw error;\n        }\n    }\n    async getAllMetadata() {\n        const metadata = /* @__PURE__ */ new Map();\n        try {\n            const metadataPrefix = `${this.keyPrefix}:metadata:`;\n            const metaKeys = this.getAllKeysStartingWith(metadataPrefix);\n            for (const key of metaKeys){\n                const metadataKey = key.substring(metadataPrefix.length);\n                const stored = localStorage.getItem(key);\n                if (!stored) continue;\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (parsed && typeof parsed === \"object\") {\n                        metadata.set(metadataKey, parsed);\n                    }\n                } catch (error) {\n                    logger17.debug(\"Skipping invalid metadata entry\", {\n                        key,\n                        error\n                    });\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error getting metadata from localStorage\", {\n                error\n            });\n            throw error;\n        }\n        return metadata;\n    }\n    async clearMetadata() {\n        try {\n            const metadataPrefix = `${this.keyPrefix}:metadata:`;\n            const keysToDelete = this.getAllKeysStartingWith(metadataPrefix);\n            keysToDelete.forEach((key)=>localStorage.removeItem(key));\n        } catch (error) {\n            logger17.error(\"Error clearing metadata from localStorage\", {\n                error\n            });\n            throw error;\n        }\n    }\n    async getCurrentSize() {\n        let itemCount = 0;\n        let sizeBytes = 0;\n        try {\n            const keys = this.getAllStorageKeys();\n            for (const key of keys){\n                const value = localStorage.getItem(key);\n                if (!value) continue;\n                try {\n                    if (typeof Blob !== \"undefined\") {\n                        sizeBytes += new Blob([\n                            value\n                        ]).size;\n                    } else if (typeof TextEncoder !== \"undefined\") {\n                        sizeBytes += new TextEncoder().encode(value).length;\n                    } else if (typeof globalThis.Buffer !== \"undefined\") {\n                        sizeBytes += globalThis.Buffer.byteLength(value, \"utf8\");\n                    } else {\n                        sizeBytes += value.length;\n                    }\n                    if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n                        try {\n                            const parsed = JSON.parse(value);\n                            if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed && \"value\" in parsed) {\n                                itemCount++;\n                            }\n                        } catch (error) {\n                            logger17.debug(\"Invalid entry in getCurrentSize\", {\n                                key,\n                                error\n                            });\n                        }\n                    }\n                } catch (error) {\n                    logger17.debug(\"Size calculation failed, using string length\", {\n                        key,\n                        error\n                    });\n                    sizeBytes += value.length;\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error calculating size from localStorage\", {\n                error\n            });\n            throw error;\n        }\n        return {\n            itemCount,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            // No specific item limit\n            maxSizeBytes: 5 * 1024 * 1024\n        };\n    }\n};\n// src/browser/SessionStorageCacheMap.ts\n\n\nvar logger18 = logger_default.get(\"SessionStorageCacheMap\");\nvar SessionStorageCacheMap = class _SessionStorageCacheMap extends CacheMap {\n    constructor(types, keyPrefix = \"fjell-session-cache\"){\n        super(types), this.implementationType = \"browser/sessionStorage\";\n        this.keyPrefix = keyPrefix;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        this.verificationHashFunction = createNormalizedHashFunction();\n    }\n    getStorageKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        return `${this.keyPrefix}:${hashedKey}`;\n    }\n    // Using flatted for safe circular serialization; no manual replacer needed\n    getAllStorageKeys() {\n        const keys = [];\n        try {\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (key && key.startsWith(`${this.keyPrefix}:`)) {\n                    keys.push(key);\n                }\n            }\n        } catch (error) {\n            logger18.error(\"Error getting keys from sessionStorage\", {\n                error\n            });\n        }\n        return keys;\n    }\n    // Detect if current normalized hash function collapses multiple stored items into the same hash\n    hasCollisionForHash(targetHash) {\n        try {\n            const storageKey = `${this.keyPrefix}:${targetHash}`;\n            const raw = sessionStorage.getItem(storageKey);\n            if (!raw) return false;\n            const parsed = JSON.parse(raw);\n            if (!parsed?.originalKey) return false;\n            const storedVerificationHash = parsed.originalVerificationHash;\n            const currentVerificationHash = this.verificationHashFunction(parsed.originalKey);\n            if (storedVerificationHash === currentVerificationHash) {\n                return false;\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    async get(key) {\n        logger18.trace(\"get\", {\n            key\n        });\n        try {\n            const currentHash = this.normalizedHashFunction(key);\n            if (this.hasCollisionForHash(currentHash)) {\n                return null;\n            }\n            const storageKey = this.getStorageKey(key);\n            const stored = sessionStorage.getItem(storageKey);\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                const storedVerificationHash = parsed.originalVerificationHash;\n                const currentVerificationHash = this.verificationHashFunction(key);\n                const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n                if (storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey) {\n                    if (parsed.value == null) return null;\n                    return parsed.value;\n                }\n            }\n            return null;\n        } catch (error) {\n            logger18.error(\"Error retrieving from sessionStorage\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    async set(key, value) {\n        try {\n            const storageKey = this.getStorageKey(key);\n            logger18.trace(\"set\", {\n                storageKey\n            });\n            const toStore = {\n                originalKey: key,\n                value,\n                timestamp: Date.now(),\n                originalVerificationHash: this.verificationHashFunction(key)\n            };\n            const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(toStore);\n            sessionStorage.setItem(storageKey, jsonString);\n        } catch (error) {\n            logger18.error(\"Error storing to sessionStorage\", {\n                errorMessage: error?.message\n            });\n            throw new Error(`Failed to store item in sessionStorage: ${error}`);\n        }\n    }\n    async includesKey(key) {\n        try {\n            const currentHash = this.normalizedHashFunction(key);\n            if (this.hasCollisionForHash(currentHash)) {\n                return false;\n            }\n            const storageKey = this.getStorageKey(key);\n            const stored = sessionStorage.getItem(storageKey);\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                const storedVerificationHash = parsed.originalVerificationHash;\n                const currentVerificationHash = this.verificationHashFunction(key);\n                const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n                return !!storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey;\n            }\n            return false;\n        } catch (error) {\n            logger18.error(\"Error checking key in sessionStorage\", {\n                key,\n                error\n            });\n            return false;\n        }\n    }\n    async delete(key) {\n        logger18.trace(\"delete\", {\n            key\n        });\n        try {\n            const storageKey = this.getStorageKey(key);\n            sessionStorage.removeItem(storageKey);\n        } catch (error) {\n            logger18.error(\"Error deleting from sessionStorage\", {\n                key,\n                error\n            });\n        }\n    }\n    async allIn(locations) {\n        const allKeys = this.keys();\n        if (locations.length === 0) {\n            logger18.debug(\"Returning all items, LocKeys is empty\");\n            const items = [];\n            for (const key of (await allKeys)){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        } else {\n            const locKeys = locations;\n            const resolvedKeys = await allKeys;\n            logger18.debug(\"allIn\", {\n                locKeys,\n                keys: resolvedKeys.length\n            });\n            const filteredKeys = resolvedKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                const ComKey13 = key;\n                logger18.debug(\"Comparing Location Keys\", {\n                    locKeys,\n                    ComKey: ComKey13\n                });\n                return isLocKeyArrayEqual(locKeys, ComKey13.loc);\n            });\n            const items = [];\n            for (const key of filteredKeys){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        }\n    }\n    async contains(query, locations) {\n        logger18.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query, locations = []) {\n        logger18.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        return new _SessionStorageCacheMap(this.types, this.keyPrefix);\n    }\n    async keys() {\n        const keys = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const stored = sessionStorage.getItem(storageKey);\n                if (!stored) continue;\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (parsed.originalKey) {\n                        keys.push(parsed.originalKey);\n                    }\n                } catch (itemError) {\n                    logger18.trace(\"Skipping invalid storage item\", {\n                        storageKey,\n                        error: itemError\n                    });\n                }\n            }\n        } catch (error) {\n            logger18.error(\"Error getting keys from sessionStorage\", {\n                error\n            });\n        }\n        return keys;\n    }\n    async values() {\n        const values = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const stored = sessionStorage.getItem(storageKey);\n                if (!stored) continue;\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (parsed.value != null) {\n                        values.push(parsed.value);\n                    }\n                } catch (itemError) {\n                    logger18.trace(\"Skipping invalid storage item for values\", {\n                        storageKey,\n                        error: itemError\n                    });\n                }\n            }\n        } catch (error) {\n            logger18.error(\"Error getting values from sessionStorage\", {\n                error\n            });\n        }\n        return values;\n    }\n    async clear() {\n        logger18.debug(\"Clearing sessionStorage cache\");\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                sessionStorage.removeItem(storageKey);\n            }\n        } catch (error) {\n            logger18.error(\"Error clearing sessionStorage cache\", {\n                error\n            });\n        }\n    }\n    // Query result caching methods implementation\n    async setQueryResult(queryHash, itemKeys) {\n        logger18.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        const entry = {\n            itemKeys\n        };\n        try {\n            const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry);\n            sessionStorage.setItem(queryKey, jsonString);\n        } catch (error) {\n            logger18.error(\"Failed to store query result in sessionStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async getQueryResult(queryHash) {\n        logger18.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        try {\n            const data = sessionStorage.getItem(queryKey);\n            if (!data) {\n                return null;\n            }\n            const entry = JSON.parse(data);\n            if (Array.isArray(entry)) {\n                return entry;\n            }\n            return entry.itemKeys || null;\n        } catch (error) {\n            logger18.error(\"Failed to retrieve query result from sessionStorage\", {\n                queryHash,\n                error\n            });\n            return null;\n        }\n    }\n    async hasQueryResult(queryHash) {\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        try {\n            return sessionStorage.getItem(queryKey) !== null;\n        } catch (error) {\n            logger18.error(\"Failed to check query result in sessionStorage\", {\n                queryHash,\n                error\n            });\n            return false;\n        }\n    }\n    async deleteQueryResult(queryHash) {\n        logger18.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n        try {\n            sessionStorage.removeItem(queryKey);\n        } catch (error) {\n            logger18.error(\"Failed to delete query result from sessionStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async invalidateItemKeys(keys) {\n        logger18.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            await this.delete(key);\n        }\n    }\n    async invalidateLocation(locations) {\n        logger18.debug(\"invalidateLocation\", {\n            locations\n        });\n        if (locations.length === 0) {\n            const allKeys = await this.keys();\n            const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n            await this.invalidateItemKeys(primaryKeys);\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            const keysToInvalidate = itemsInLocation.map((item)=>item.key);\n            await this.invalidateItemKeys(keysToInvalidate);\n        }\n        await this.clearQueryResults();\n    }\n    async clearQueryResults() {\n        logger18.trace(\"clearQueryResults\");\n        const queryPrefix = `${this.keyPrefix}:query:`;\n        try {\n            const keysToRemove = [];\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (key && key.startsWith(queryPrefix)) {\n                    keysToRemove.push(key);\n                }\n            }\n            keysToRemove.forEach((key)=>sessionStorage.removeItem(key));\n        } catch (error) {\n            logger18.error(\"Failed to clear query results from sessionStorage\", {\n                error\n            });\n        }\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        try {\n            const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n            const stored = sessionStorage.getItem(metadataKey);\n            return stored ? JSON.parse(stored) : null;\n        } catch  {\n            return null;\n        }\n    }\n    async setMetadata(key, metadata) {\n        try {\n            const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n            const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(metadata);\n            sessionStorage.setItem(metadataKey, jsonString);\n        } catch  {}\n    }\n    async deleteMetadata(key) {\n        try {\n            const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n            sessionStorage.removeItem(metadataKey);\n        } catch  {}\n    }\n    async getAllMetadata() {\n        const metadata = /* @__PURE__ */ new Map();\n        const metadataPrefix = `${this.keyPrefix}:metadata:`;\n        try {\n            let foundAny = false;\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (!key || !key.startsWith(metadataPrefix)) continue;\n                foundAny = true;\n                const metadataKey = key.substring(metadataPrefix.length);\n                const stored = sessionStorage.getItem(key);\n                if (!stored) continue;\n                try {\n                    metadata.set(metadataKey, JSON.parse(stored));\n                } catch  {}\n            }\n            return metadata;\n        } catch (error) {\n            logger18.error(\"Error getting all metadata from sessionStorage\", {\n                error\n            });\n            return metadata;\n        }\n    }\n    async clearMetadata() {\n        try {\n            const metadataPrefix = `${this.keyPrefix}:metadata:`;\n            const keysToDelete = [];\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (key && key.startsWith(metadataPrefix)) {\n                    keysToDelete.push(key);\n                }\n            }\n            keysToDelete.forEach((key)=>sessionStorage.removeItem(key));\n        } catch  {}\n    }\n    async getCurrentSize() {\n        let itemCount = 0;\n        let sizeBytes = 0;\n        try {\n            sessionStorage.key(0);\n        } catch  {\n            return {\n                itemCount: 0,\n                sizeBytes: 0\n            };\n        }\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const key of storageKeys){\n                if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n                    try {\n                        const value = sessionStorage.getItem(key);\n                        if (value) {\n                            const parsed = JSON.parse(value);\n                            if (parsed?.originalKey && parsed?.originalVerificationHash === this.verificationHashFunction(parsed.originalKey)) {\n                                itemCount++;\n                                sizeBytes += new Blob([\n                                    value\n                                ]).size;\n                            }\n                        }\n                    } catch  {}\n                }\n            }\n        } catch  {\n            return {\n                itemCount: 0,\n                sizeBytes: 0\n            };\n        }\n        return {\n            itemCount,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            // No specific item limit\n            maxSizeBytes: 5 * 1024 * 1024\n        };\n    }\n};\n// src/browser/IndexDBCacheMap.ts\n\n// src/browser/AsyncIndexDBCacheMap.ts\n\n\nvar logger19 = logger_default.get(\"AsyncIndexDBCacheMap\");\nvar AsyncIndexDBCacheMap = class _AsyncIndexDBCacheMap {\n    static{\n        // Current storage format version\n        this.CURRENT_VERSION = 1;\n    }\n    constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1){\n        this.dbPromise = null;\n        this.types = types;\n        this.dbName = dbName;\n        this.storeName = storeName;\n        this.version = version;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n    }\n    async getDB() {\n        if (!this.dbPromise) {\n            this.dbPromise = new Promise((resolve, reject)=>{\n                if (typeof indexedDB === \"undefined\") {\n                    reject(new Error(\"IndexedDB is not available in this environment\"));\n                    return;\n                }\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Error opening IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    logger19.debug(\"IndexedDB opened successfully\");\n                    resolve(request.result);\n                };\n                request.onupgradeneeded = (event)=>{\n                    logger19.debug(\"IndexedDB upgrade needed\");\n                    const db = event.target.result;\n                    if (!db.objectStoreNames.contains(this.storeName)) {\n                        db.createObjectStore(this.storeName);\n                        logger19.debug(\"Created object store\", {\n                            storeName: this.storeName\n                        });\n                    }\n                };\n            });\n        }\n        return this.dbPromise;\n    }\n    getStorageKey(key) {\n        return this.normalizedHashFunction(key);\n    }\n    async get(key) {\n        logger19.trace(\"get\", {\n            key\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.get(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting from IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const stored = request.result;\n                    if (stored && this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key)) {\n                        resolve(stored.value);\n                    } else {\n                        resolve(null);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB get operation\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    /**\n   * Get both the value and metadata for an item\n   */ async getWithMetadata(key) {\n        logger19.trace(\"getWithMetadata\", {\n            key\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.get(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting from IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const stored = request.result;\n                    if (stored && this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key)) {\n                        resolve({\n                            value: stored.value,\n                            metadata: stored.metadata\n                        });\n                    } else {\n                        resolve(null);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB getWithMetadata operation\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    async set(key, value, metadata) {\n        logger19.trace(\"set\", {\n            key,\n            value,\n            hasMetadata: !!metadata\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readwrite\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            const storedItem = {\n                originalKey: key,\n                value,\n                metadata,\n                version: _AsyncIndexDBCacheMap.CURRENT_VERSION\n            };\n            return new Promise((resolve, reject)=>{\n                const request = store.put(storedItem, storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error setting in IndexedDB\", {\n                        key,\n                        value,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    resolve();\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB set operation\", {\n                key,\n                value,\n                error\n            });\n            throw new Error(`Failed to store item in IndexedDB: ${error}`);\n        }\n    }\n    /**\n   * Update only the metadata for an existing item\n   */ async setMetadata(key, metadata) {\n        logger19.trace(\"setMetadata\", {\n            key,\n            metadata\n        });\n        try {\n            const existing = await this.getWithMetadata(key);\n            if (existing) {\n                await this.set(key, existing.value, metadata);\n            } else {\n                logger19.warning(\"Attempted to set metadata for non-existent item\", {\n                    key\n                });\n            }\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB setMetadata operation\", {\n                key,\n                error\n            });\n            throw new Error(`Failed to update metadata in IndexedDB: ${error}`);\n        }\n    }\n    async includesKey(key) {\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.get(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error checking key in IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const stored = request.result;\n                    if (stored) {\n                        const matches = this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key);\n                        resolve(matches);\n                    } else {\n                        resolve(false);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB includesKey operation\", {\n                key,\n                error\n            });\n            return false;\n        }\n    }\n    async delete(key) {\n        logger19.trace(\"delete\", {\n            key\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readwrite\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.delete(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error deleting from IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    resolve();\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB delete operation\", {\n                key,\n                error\n            });\n        }\n    }\n    async allIn(locations) {\n        const allKeys = await this.keys();\n        if (locations.length === 0) {\n            logger19.debug(\"Returning all items, LocKeys is empty\");\n            const promises = allKeys.map((key)=>this.get(key));\n            const results = await Promise.all(promises);\n            return results.filter((item)=>item !== null);\n        } else {\n            const locKeys = locations;\n            logger19.debug(\"allIn\", {\n                locKeys,\n                keys: allKeys.length\n            });\n            const filteredKeys = allKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                const ComKey13 = key;\n                logger19.debug(\"Comparing Location Keys\", {\n                    locKeys,\n                    ComKey: ComKey13\n                });\n                return isLocKeyArrayEqual(locKeys, ComKey13.loc);\n            });\n            const promises = filteredKeys.map((key)=>this.get(key));\n            const results = await Promise.all(promises);\n            return results.filter((item)=>item !== null);\n        }\n    }\n    async contains(query, locations) {\n        logger19.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query, locations = []) {\n        logger19.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    clone() {\n        return new _AsyncIndexDBCacheMap(this.types, this.dbName, this.storeName, this.version);\n    }\n    async keys() {\n        const keys = [];\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.openCursor();\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting keys from IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = (event)=>{\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        const stored = cursor.value;\n                        keys.push(stored.originalKey);\n                        cursor.continue();\n                    } else {\n                        resolve(keys);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB keys operation\", {\n                error\n            });\n            return [];\n        }\n    }\n    /**\n   * Get all metadata entries from IndexedDB\n   */ async getAllMetadata() {\n        const metadataMap = /* @__PURE__ */ new Map();\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.openCursor();\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting metadata from IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = (event)=>{\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        const stored = cursor.value;\n                        if (stored.metadata) {\n                            const keyStr = JSON.stringify(stored.originalKey);\n                            metadataMap.set(keyStr, stored.metadata);\n                        }\n                        cursor.continue();\n                    } else {\n                        resolve(metadataMap);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB getAllMetadata operation\", {\n                error\n            });\n            return metadataMap;\n        }\n    }\n    async values() {\n        const values = [];\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.openCursor();\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting values from IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = (event)=>{\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        const stored = cursor.value;\n                        values.push(stored.value);\n                        cursor.continue();\n                    } else {\n                        resolve(values);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB values operation\", {\n                error\n            });\n            return [];\n        }\n    }\n    async clear() {\n        logger19.debug(\"Clearing IndexedDB cache\");\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readwrite\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.clear();\n                request.onerror = ()=>{\n                    logger19.error(\"Error clearing IndexedDB cache\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    resolve();\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB clear operation\", {\n                error\n            });\n        }\n    }\n    // Async Query result caching methods\n    async setQueryResult(queryHash, itemKeys) {\n        logger19.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for setQueryResult\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readwrite\");\n                    const store = transaction.objectStore(this.storeName);\n                    const entry = {\n                        itemKeys\n                    };\n                    const queryKey = `query:${queryHash}`;\n                    const putRequest = store.put(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry), queryKey);\n                    putRequest.onerror = ()=>{\n                        logger19.error(\"Failed to store query result\", {\n                            queryHash,\n                            error: putRequest.error\n                        });\n                        reject(putRequest.error);\n                    };\n                    putRequest.onsuccess = ()=>{\n                        resolve();\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in setQueryResult\", {\n                queryHash,\n                error\n            });\n            throw error;\n        }\n    }\n    async getQueryResult(queryHash) {\n        logger19.trace(\"getQueryResult\", {\n            queryHash\n        });\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for getQueryResult\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readonly\");\n                    const store = transaction.objectStore(this.storeName);\n                    const queryKey = `query:${queryHash}`;\n                    const getRequest = store.get(queryKey);\n                    getRequest.onerror = ()=>{\n                        logger19.error(\"Failed to retrieve query result\", {\n                            queryHash,\n                            error: getRequest.error\n                        });\n                        reject(getRequest.error);\n                    };\n                    getRequest.onsuccess = ()=>{\n                        try {\n                            const result = getRequest.result;\n                            if (!result) {\n                                resolve(null);\n                                return;\n                            }\n                            const entry = JSON.parse(result);\n                            if (Array.isArray(entry)) {\n                                resolve(entry);\n                                return;\n                            }\n                            resolve(entry.itemKeys || null);\n                        } catch (parseError) {\n                            logger19.error(\"Failed to parse query result\", {\n                                queryHash,\n                                error: parseError\n                            });\n                            resolve(null);\n                        }\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in getQueryResult\", {\n                queryHash,\n                error\n            });\n            return null;\n        }\n    }\n    async hasQueryResult(queryHash) {\n        logger19.trace(\"hasQueryResult\", {\n            queryHash\n        });\n        try {\n            const result = await this.getQueryResult(queryHash);\n            return result !== null;\n        } catch (error) {\n            logger19.error(\"Error in hasQueryResult\", {\n                queryHash,\n                error\n            });\n            return false;\n        }\n    }\n    async deleteQueryResult(queryHash) {\n        logger19.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for deleteQueryResult\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readwrite\");\n                    const store = transaction.objectStore(this.storeName);\n                    const queryKey = `query:${queryHash}`;\n                    const deleteRequest = store.delete(queryKey);\n                    deleteRequest.onerror = ()=>{\n                        logger19.error(\"Failed to delete query result\", {\n                            queryHash,\n                            error: deleteRequest.error\n                        });\n                        reject(deleteRequest.error);\n                    };\n                    deleteRequest.onsuccess = ()=>{\n                        resolve();\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in deleteQueryResult\", {\n                queryHash,\n                error\n            });\n            throw error;\n        }\n    }\n    async invalidateItemKeys(keys) {\n        logger19.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            await this.delete(key);\n        }\n    }\n    async invalidateLocation(locations) {\n        logger19.debug(\"invalidateLocation\", {\n            locations\n        });\n        if (locations.length === 0) {\n            await this.clearQueryResults();\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            const keysToInvalidate = itemsInLocation.map((item)=>item.key);\n            await this.invalidateItemKeys(keysToInvalidate);\n        }\n        await this.clearQueryResults();\n    }\n    async clearQueryResults() {\n        logger19.trace(\"clearQueryResults\");\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for clearQueryResults\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readwrite\");\n                    const store = transaction.objectStore(this.storeName);\n                    const cursorRequest = store.openCursor();\n                    const keysToDelete = [];\n                    cursorRequest.onerror = ()=>{\n                        logger19.error(\"Failed to open cursor for clearQueryResults\", {\n                            error: cursorRequest.error\n                        });\n                        reject(cursorRequest.error);\n                    };\n                    cursorRequest.onsuccess = ()=>{\n                        const cursor = cursorRequest.result;\n                        if (cursor) {\n                            const key = cursor.key;\n                            if (typeof key === \"string\" && key.startsWith(\"query:\")) {\n                                keysToDelete.push(key);\n                            }\n                            cursor.continue();\n                        } else {\n                            if (keysToDelete.length === 0) {\n                                resolve();\n                                return;\n                            }\n                            let deletedCount = 0;\n                            const totalToDelete = keysToDelete.length;\n                            keysToDelete.forEach((queryKey)=>{\n                                const deleteRequest = store.delete(queryKey);\n                                deleteRequest.onerror = ()=>{\n                                    logger19.error(\"Failed to delete query key\", {\n                                        queryKey,\n                                        error: deleteRequest.error\n                                    });\n                                    deletedCount++;\n                                    if (deletedCount === totalToDelete) {\n                                        resolve();\n                                    }\n                                };\n                                deleteRequest.onsuccess = ()=>{\n                                    deletedCount++;\n                                    if (deletedCount === totalToDelete) {\n                                        resolve();\n                                    }\n                                };\n                            });\n                        }\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in clearQueryResults\", {\n                error\n            });\n            throw error;\n        }\n    }\n};\n// src/browser/IndexDBCacheMap.ts\nvar logger20 = logger_default.get(\"IndexDBCacheMap\");\nvar IndexDBCacheMap = class _IndexDBCacheMap extends CacheMap {\n    constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1){\n        super(types), this.implementationType = \"browser/indexedDB\", // Memory storage\n        this.memoryMap = {}, this.queryResultCache = {}, this.metadataMap = /* @__PURE__ */ new Map(), // Background sync management\n        this.syncInterval = null, this.pendingOperations = [], this.sequenceCounter = 0;\n        this.types = types;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        this.asyncCache = new AsyncIndexDBCacheMap(types, dbName, storeName, version);\n        this.initializeFromIndexedDB();\n        this.startPeriodicSync();\n    }\n    async initializeFromIndexedDB() {\n        try {\n            const keys = await this.asyncCache.keys();\n            for (const key of keys){\n                const hashedKey = this.normalizedHashFunction(key);\n                if (!this.memoryMap[hashedKey]) {\n                    const value = await this.asyncCache.get(key);\n                    if (value) {\n                        this.memoryMap[hashedKey] = {\n                            originalKey: key,\n                            value\n                        };\n                    }\n                }\n            }\n        } catch (error) {\n            console.warn(\"Failed to initialize from IndexedDB, using memory-only mode:\", error);\n        }\n    }\n    startPeriodicSync() {\n        this.syncInterval = setInterval(()=>{\n            this.processPendingOperations();\n        }, 10);\n    }\n    async processPendingOperations() {\n        if (this.pendingOperations.length === 0) return;\n        const operations = [\n            ...this.pendingOperations\n        ];\n        this.pendingOperations = [];\n        for (const op of operations){\n            try {\n                switch(op.type){\n                    case \"set\":\n                        if (op.key && op.value) {\n                            await this.asyncCache.set(op.key, op.value, op.metadata);\n                        }\n                        break;\n                    case \"delete\":\n                        if (op.key) {\n                            await this.asyncCache.delete(op.key);\n                        }\n                        break;\n                    case \"clear\":\n                        await this.asyncCache.clear();\n                        break;\n                }\n            } catch (error) {\n                console.warn(\"Failed to sync operation to IndexedDB:\", error);\n            }\n        }\n    }\n    // Synchronous memory operations\n    async get(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.memoryMap[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            return entry.value;\n        }\n        return null;\n    }\n    async set(key, value) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const now = Date.now();\n        const metadata = {\n            key: JSON.stringify(key),\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize: JSON.stringify(value).length\n        };\n        this.memoryMap[hashedKey] = {\n            originalKey: key,\n            value\n        };\n        this.pendingOperations.push({\n            type: \"set\",\n            key,\n            value,\n            metadata,\n            sequenceId: ++this.sequenceCounter\n        });\n        this.processPendingOperations();\n    }\n    async includesKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.memoryMap[hashedKey];\n        return !!(entry && this.normalizedHashFunction(entry.originalKey) === hashedKey);\n    }\n    async delete(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        delete this.memoryMap[hashedKey];\n        this.metadataMap.delete(hashedKey);\n        this.pendingOperations.push({\n            type: \"delete\",\n            key,\n            sequenceId: ++this.sequenceCounter\n        });\n        this.processPendingOperations();\n    }\n    async keys() {\n        return Object.values(this.memoryMap).map((entry)=>entry.originalKey);\n    }\n    async values() {\n        return Object.values(this.memoryMap).map((entry)=>entry.value);\n    }\n    async clear() {\n        this.memoryMap = {};\n        this.queryResultCache = {};\n        this.metadataMap.clear();\n        this.pendingOperations.push({\n            type: \"clear\",\n            sequenceId: ++this.sequenceCounter\n        });\n        this.processPendingOperations();\n    }\n    async allIn(locations) {\n        const result = [];\n        for (const entry of Object.values(this.memoryMap)){\n            const key = entry.originalKey;\n            if (locations.length === 0) {\n                result.push(entry.value);\n            } else if ((0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n                if (isLocKeyArrayEqual(key.loc, locations)) {\n                    result.push(entry.value);\n                }\n            }\n        }\n        return result;\n    }\n    async contains(query, locations) {\n        const items = await this.queryIn(query, locations);\n        return items.length > 0;\n    }\n    async queryIn(query, locations) {\n        const candidates = await this.allIn(locations);\n        if (!query.compoundCondition) {\n            return candidates;\n        }\n        return candidates.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    // Query result caching methods\n    async setQueryResult(queryHash, itemKeys) {\n        this.queryResultCache[queryHash] = {\n            itemKeys\n        };\n    }\n    async getQueryResult(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        return entry ? entry.itemKeys : null;\n    }\n    async hasQueryResult(queryHash) {\n        return queryHash in this.queryResultCache;\n    }\n    async deleteQueryResult(queryHash) {\n        delete this.queryResultCache[queryHash];\n    }\n    async clearQueryResults() {\n        this.queryResultCache = {};\n    }\n    // Invalidation methods\n    async invalidateItemKeys(keys) {\n        for(const queryHash in this.queryResultCache){\n            const entry = this.queryResultCache[queryHash];\n            if (entry && entry.itemKeys.some((key)=>keys.some((affectedKey)=>this.normalizedHashFunction(affectedKey) === this.normalizedHashFunction(key)))) {\n                delete this.queryResultCache[queryHash];\n            }\n        }\n    }\n    async invalidateLocation(locations) {\n        const itemsToDelete = [];\n        for (const entry of Object.values(this.memoryMap)){\n            const key = entry.originalKey;\n            if ((0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key) && isLocKeyArrayEqual(key.loc, locations)) {\n                itemsToDelete.push(key);\n            }\n        }\n        this.invalidateItemKeys(itemsToDelete);\n    }\n    // Metadata operations\n    async getMetadata(key) {\n        return this.metadataMap.get(key) || null;\n    }\n    async setMetadata(key, metadata) {\n        this.metadataMap.set(key, metadata);\n    }\n    async deleteMetadata(key) {\n        this.metadataMap.delete(key);\n    }\n    async getAllMetadata() {\n        return new Map(this.metadataMap);\n    }\n    async clearMetadata() {\n        this.metadataMap.clear();\n    }\n    // Size operations\n    async getCurrentSize() {\n        const itemCount = Object.keys(this.memoryMap).length;\n        let sizeBytes = 0;\n        for (const entry of Object.values(this.memoryMap)){\n            sizeBytes += JSON.stringify(entry.value).length;\n        }\n        return {\n            itemCount,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            maxSizeBytes: null\n        };\n    }\n    // Clone operation\n    async clone() {\n        const cloned = new _IndexDBCacheMap(this.types, \"fjell-indexdb-cache-clone\", \"cache-clone\", 1);\n        cloned.memoryMap = {\n            ...this.memoryMap\n        };\n        cloned.queryResultCache = {\n            ...this.queryResultCache\n        };\n        cloned.metadataMap = new Map(this.metadataMap);\n        return cloned;\n    }\n    /**\n   * Clean up resources when the cache is no longer needed\n   */ destroy() {\n        if (this.syncInterval) {\n            clearInterval(this.syncInterval);\n            this.syncInterval = null;\n        }\n    }\n};\n// src/Options.ts\nvar DEFAULT_CACHE_OPTIONS = {\n    cacheType: \"memory\",\n    enableDebugLogging: false,\n    autoSync: true,\n    maxRetries: 3,\n    retryDelay: 1e3,\n    indexedDBConfig: {\n        dbName: \"fjell-cache\",\n        version: 1,\n        storeName: \"cache\",\n        size: {\n            evictionPolicy: \"lru\"\n        }\n    },\n    webStorageConfig: {\n        keyPrefix: \"fjell-cache:\",\n        compress: false,\n        size: {\n            evictionPolicy: \"lru\"\n        }\n    },\n    memoryConfig: {\n        // No limits by default\n        size: {\n            evictionPolicy: \"lru\"\n        }\n    }\n};\nvar createOptions = (cacheOptions)=>{\n    const indexedDBConfig = cacheOptions?.indexedDBConfig ? {\n        ...DEFAULT_CACHE_OPTIONS.indexedDBConfig,\n        ...cacheOptions.indexedDBConfig,\n        size: cacheOptions.indexedDBConfig.size ? {\n            ...DEFAULT_CACHE_OPTIONS.indexedDBConfig?.size,\n            ...cacheOptions.indexedDBConfig.size\n        } : DEFAULT_CACHE_OPTIONS.indexedDBConfig?.size\n    } : {\n        ...DEFAULT_CACHE_OPTIONS.indexedDBConfig\n    };\n    const webStorageConfig = cacheOptions?.webStorageConfig ? {\n        ...DEFAULT_CACHE_OPTIONS.webStorageConfig,\n        ...cacheOptions.webStorageConfig,\n        size: cacheOptions.webStorageConfig.size ? {\n            ...DEFAULT_CACHE_OPTIONS.webStorageConfig?.size,\n            ...cacheOptions.webStorageConfig.size\n        } : DEFAULT_CACHE_OPTIONS.webStorageConfig?.size\n    } : {\n        ...DEFAULT_CACHE_OPTIONS.webStorageConfig\n    };\n    const memoryConfig = cacheOptions?.memoryConfig ? {\n        ...DEFAULT_CACHE_OPTIONS.memoryConfig,\n        ...cacheOptions.memoryConfig,\n        size: cacheOptions.memoryConfig.size ? {\n            ...DEFAULT_CACHE_OPTIONS.memoryConfig?.size,\n            ...cacheOptions.memoryConfig.size\n        } : DEFAULT_CACHE_OPTIONS.memoryConfig?.size\n    } : {\n        ...DEFAULT_CACHE_OPTIONS.memoryConfig\n    };\n    return {\n        ...DEFAULT_CACHE_OPTIONS,\n        ...cacheOptions,\n        indexedDBConfig,\n        webStorageConfig,\n        memoryConfig\n    };\n};\nvar createCacheMap = (kta, options)=>{\n    switch(options.cacheType){\n        case \"memory\":\n            if (options.memoryConfig?.size && (options.memoryConfig.size.maxSizeBytes || options.memoryConfig.size.maxItems)) {\n                const sizeConfig = {\n                    maxSizeBytes: options.memoryConfig.size.maxSizeBytes,\n                    maxItems: options.memoryConfig.size.maxItems\n                };\n                return new EnhancedMemoryCacheMap(kta, sizeConfig);\n            }\n            return new MemoryCacheMap(kta);\n        case \"localStorage\":\n            return new LocalStorageCacheMap(kta, options.webStorageConfig?.keyPrefix);\n        case \"sessionStorage\":\n            return new SessionStorageCacheMap(kta, options.webStorageConfig?.keyPrefix);\n        case \"indexedDB\":\n            return new IndexDBCacheMap(kta, options.indexedDBConfig?.dbName, options.indexedDBConfig?.storeName, options.indexedDBConfig?.version);\n        case \"custom\":\n            if (!options.customCacheMapFactory) {\n                throw new Error('Custom cache map factory is required when cacheType is \"custom\"');\n            }\n            return options.customCacheMapFactory(kta);\n        default:\n            throw new Error(`Unsupported cache type: ${options.cacheType}`);\n    }\n};\nvar validateOptions = (options)=>{\n    if (options.cacheType === \"custom\" && !options.customCacheMapFactory) {\n        throw new Error('customCacheMapFactory is required when cacheType is \"custom\"');\n    }\n    if (typeof options.maxRetries === \"number\" && options.maxRetries < 0) {\n        throw new Error(\"maxRetries must be non-negative\");\n    }\n    if (typeof options.retryDelay === \"number\" && options.retryDelay < 0) {\n        throw new Error(\"retryDelay must be non-negative\");\n    }\n    if (typeof options.ttl === \"number\" && options.ttl <= 0) {\n        throw new Error(\"ttl must be positive\");\n    }\n    if (typeof options.memoryConfig?.maxItems === \"number\" && options.memoryConfig.maxItems <= 0) {\n        throw new Error(\"memoryConfig.maxItems must be positive\");\n    }\n    if (options.memoryConfig?.size) {\n        validateSizeConfig(options.memoryConfig.size);\n    }\n    if (options.webStorageConfig?.size) {\n        validateSizeConfig(options.webStorageConfig.size);\n    }\n    if (options.indexedDBConfig?.size) {\n        validateSizeConfig(options.indexedDBConfig.size);\n    }\n    if ([\n        \"localStorage\",\n        \"sessionStorage\"\n    ].includes(options.cacheType)) {\n        const isRealBrowser =  false && 0;\n        if (!isRealBrowser) {\n            throw new Error(`${options.cacheType} is not available in non-browser environments`);\n        }\n    }\n    if (options.cacheType === \"indexedDB\") {\n        if (true) {\n            throw new Error(`${options.cacheType} is not available in this environment`);\n        }\n    }\n    if (options.cacheType === \"asyncIndexedDB\") {\n        throw new Error(\"asyncIndexedDB cannot be used with synchronous cache factory. Use AsyncIndexDBCacheMap directly for async operations.\");\n    }\n};\n// src/ops/reset.ts\nvar reset = async (coordinate, options)=>{\n    try {\n        validateOptions(options);\n        const cacheMap = createCacheMap(coordinate.kta, options);\n        return [\n            cacheMap\n        ];\n    } catch (error) {\n        throw error;\n    }\n};\n// src/Operations.ts\nvar createOperations = (api, coordinate, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager)=>{\n    const context = createCacheContext(api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager);\n    return {\n        all: (query, locations)=>all(query, locations, context).then(([ctx, result])=>result),\n        one: (query, locations)=>one(query, locations, context).then(([ctx, result])=>result),\n        create: (item, locations)=>create(item, locations, context).then(([ctx, result])=>result),\n        get: (key)=>get(key, context).then(([ctx, result])=>result),\n        retrieve: (key)=>retrieve(key, context).then(([ctx, result])=>result),\n        remove: (key)=>remove(key, context).then((ctx)=>void 0),\n        update: (key, item)=>update(key, item, context).then(([ctx, result])=>result),\n        action: (key, actionName, body)=>action(key, actionName, body, context).then(([ctx, result])=>result),\n        allAction: (actionName, body, locations)=>allAction(actionName, body, locations, context).then(([ctx, result])=>result),\n        facet: (key, facetName, params)=>facet(key, facetName, params, context).then((result)=>result),\n        allFacet: (facetName, params, locations)=>allFacet(facetName, params, locations, context).then((result)=>result),\n        find: (finder, params, locations)=>find(finder, params, locations, context).then(([ctx, result])=>result),\n        findOne: (finder, params, locations)=>findOne(finder, params, locations, context).then(([ctx, result])=>result),\n        set: (key, item)=>set(key, item, context).then(([ctx, result])=>result),\n        reset: ()=>reset(coordinate, options).then(()=>void 0)\n    };\n};\n// src/eviction/EvictionManager.ts\nvar logger21 = logger_default.get(\"EvictionManager\");\nvar EvictionManager = class {\n    constructor(evictionStrategy){\n        this.evictionStrategy = evictionStrategy || null;\n    }\n    /**\n   * Set or update the eviction strategy\n   * @param strategy - The eviction strategy to use\n   */ setEvictionStrategy(strategy) {\n        this.evictionStrategy = strategy;\n        logger21.debug(\"Eviction strategy updated\", {\n            strategy: strategy?.getStrategyName() || \"none\"\n        });\n    }\n    /**\n   * Get the current eviction strategy name\n   * @returns Strategy name or null if no eviction\n   */ getEvictionStrategyName() {\n        return this.evictionStrategy?.getStrategyName() || null;\n    }\n    /**\n   * Handle item access - update metadata for eviction strategy\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */ async onItemAccessed(key, metadataProvider) {\n        if (!this.evictionStrategy) {\n            return;\n        }\n        try {\n            await this.evictionStrategy.onItemAccessed(key, metadataProvider);\n        } catch (error) {\n            logger21.error(\"Error in eviction strategy onItemAccessed\", {\n                key,\n                error\n            });\n        }\n    }\n    /**\n   * Handle item addition - update metadata and perform eviction if needed\n   * @param key - Item key\n   * @param value - Item value (for size estimation)\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */ async onItemAdded(key, value, metadataProvider) {\n        const evictedKeys = [];\n        if (!this.evictionStrategy) {\n            return evictedKeys;\n        }\n        try {\n            const estimatedSize = estimateValueSize(value);\n            const context = await this.createEvictionContext(metadataProvider, estimatedSize);\n            const keysToEvict = await this.evictionStrategy.selectForEviction(metadataProvider, context);\n            for (const evictKey of keysToEvict){\n                await this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n                evictedKeys.push(evictKey);\n            }\n            await this.evictionStrategy.onItemAdded(key, estimatedSize, metadataProvider);\n            if (evictedKeys.length > 0) {\n                logger21.debug(\"Items evicted during addition\", {\n                    newKey: key,\n                    evictedKeys,\n                    strategy: this.evictionStrategy.getStrategyName()\n                });\n            }\n        } catch (error) {\n            logger21.error(\"Error in eviction strategy onItemAdded\", {\n                key,\n                error\n            });\n        }\n        return evictedKeys;\n    }\n    /**\n   * Handle item removal - clean up metadata\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */ onItemRemoved(key, metadataProvider) {\n        if (!this.evictionStrategy) {\n            return;\n        }\n        try {\n            this.evictionStrategy.onItemRemoved(key, metadataProvider);\n        } catch (error) {\n            logger21.error(\"Error in eviction strategy onItemRemoved\", {\n                key,\n                error\n            });\n        }\n    }\n    /**\n   * Perform manual eviction check\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */ async performEviction(metadataProvider) {\n        const evictedKeys = [];\n        if (!this.evictionStrategy) {\n            return evictedKeys;\n        }\n        try {\n            const context = await this.createEvictionContext(metadataProvider);\n            const keysToEvict = await this.evictionStrategy.selectForEviction(metadataProvider, context);\n            for (const evictKey of keysToEvict){\n                await this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n                evictedKeys.push(evictKey);\n            }\n            if (evictedKeys.length > 0) {\n                logger21.debug(\"Manual eviction performed\", {\n                    evictedKeys,\n                    strategy: this.evictionStrategy.getStrategyName()\n                });\n            }\n        } catch (error) {\n            logger21.error(\"Error in manual eviction\", {\n                error\n            });\n        }\n        return evictedKeys;\n    }\n    /**\n   * Check if eviction is supported (i.e., strategy is set)\n   * @returns True if eviction is supported\n   */ isEvictionSupported() {\n        return this.evictionStrategy !== null;\n    }\n    /**\n   * Create eviction context from current cache state\n   * @param metadataProvider - Cache metadata provider\n   * @param newItemSize - Size of item being added (optional)\n   * @returns Eviction context\n   */ async createEvictionContext(metadataProvider, newItemSize) {\n        const currentSize = await metadataProvider.getCurrentSize();\n        const limits = await metadataProvider.getSizeLimits();\n        return {\n            currentSize,\n            limits,\n            newItemSize\n        };\n    }\n};\n// src/eviction/EvictionStrategyConfig.ts\nvar DEFAULT_LFU_CONFIG = {\n    type: \"lfu\",\n    decayFactor: 0.1,\n    decayInterval: 6e4,\n    // 1 minute\n    sketchWidth: 1024,\n    sketchDepth: 4,\n    useProbabilisticCounting: true,\n    minFrequencyThreshold: 1\n};\nvar DEFAULT_ARC_CONFIG = {\n    type: \"arc\",\n    maxCacheSize: 1e3,\n    frequencyThreshold: 2,\n    useEnhancedFrequency: true,\n    frequencyDecayFactor: 0.05,\n    frequencyDecayInterval: 6e5,\n    // 10 minutes\n    useFrequencyWeightedSelection: true,\n    adaptiveLearningRate: 1\n};\nvar DEFAULT_TWO_QUEUE_CONFIG = {\n    type: \"2q\",\n    maxCacheSize: 1e3,\n    useFrequencyPromotion: true,\n    promotionThreshold: 2,\n    hotQueueDecayFactor: 0.05,\n    hotQueueDecayInterval: 3e5,\n    // 5 minutes\n    useFrequencyWeightedLRU: true\n};\n// src/eviction/EvictionStrategy.ts\nvar EvictionStrategy = class {\n    /**\n   * Determine if eviction is needed based on current context\n   * @param context - Current cache state and limits\n   * @returns True if eviction should occur\n   */ isEvictionNeeded(context) {\n        const { currentSize, limits, newItemSize = 0 } = context;\n        if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n            return true;\n        }\n        if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Calculate how many items need to be evicted\n   * @param context - Current cache state and limits\n   * @returns Number of items that should be evicted\n   */ calculateEvictionCount(context) {\n        const { currentSize, limits, newItemSize = 0 } = context;\n        let evictionCount = 0;\n        if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n            evictionCount = Math.max(evictionCount, currentSize.itemCount - limits.maxItems + 1);\n        }\n        if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n            const excessBytes = currentSize.sizeBytes + newItemSize - limits.maxSizeBytes;\n            const avgItemSize = currentSize.itemCount > 0 ? currentSize.sizeBytes / currentSize.itemCount : 1024;\n            const estimatedEvictionCount = Math.ceil(excessBytes / avgItemSize);\n            evictionCount = Math.max(evictionCount, estimatedEvictionCount);\n        }\n        return evictionCount;\n    }\n};\n// src/eviction/strategies/LRUEvictionStrategy.ts\nvar LRUEvictionStrategy = class extends EvictionStrategy {\n    async selectForEviction(metadataProvider, context) {\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        const keysToEvict = [];\n        const sortedEntries = Array.from(allMetadata.entries()).sort(([, a], [, b])=>a.lastAccessedAt - b.lastAccessedAt);\n        for(let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++){\n            keysToEvict.push(sortedEntries[i][0]);\n        }\n        return keysToEvict;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata) {\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            await metadataProvider.setMetadata(key, metadata);\n        }\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    getStrategyName() {\n        return \"lru\";\n    }\n};\n// src/eviction/EvictionStrategyValidation.ts\nfunction validateNumberRange(value, min, max, fieldName) {\n    if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n        throw new Error(`${fieldName} must be a finite number`);\n    }\n    if (value < min || value > max) {\n        throw new Error(`${fieldName} must be between ${min} and ${max}, got ${value}`);\n    }\n}\nfunction validatePositiveInteger(value, fieldName) {\n    if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n        throw new Error(`${fieldName} must be a finite number`);\n    }\n    if (!Number.isInteger(value) || value <= 0) {\n        throw new Error(`${fieldName} must be a positive integer, got ${value}`);\n    }\n}\nfunction sanitizeLFUConfig(config) {\n    const sanitized = {\n        ...config\n    };\n    if (typeof sanitized.decayFactor === \"number\") {\n        if (sanitized.decayFactor < 0) {\n            console.warn(`decayFactor must be between 0 and 1, got ${sanitized.decayFactor}. Correcting to 0.`);\n            sanitized.decayFactor = 0;\n        } else if (sanitized.decayFactor > 1) {\n            console.warn(`decayFactor must be between 0 and 1, got ${sanitized.decayFactor}. Correcting to 1.`);\n            sanitized.decayFactor = 1;\n        }\n    }\n    if (typeof sanitized.decayInterval === \"number\" && sanitized.decayInterval <= 0) {\n        console.warn(`decayInterval must be positive, got ${sanitized.decayInterval}. Correcting to 300000.`);\n        sanitized.decayInterval = 3e5;\n    }\n    if (typeof sanitized.sketchWidth === \"number\") {\n        if (sanitized.sketchWidth <= 0) {\n            console.warn(`sketchWidth must be positive, got ${sanitized.sketchWidth}. Correcting to 1024.`);\n            sanitized.sketchWidth = 1024;\n        } else if (sanitized.sketchWidth < 16) {\n            console.warn(`sketchWidth should be at least 16 for optimal performance, got ${sanitized.sketchWidth}. Correcting to 16.`);\n            sanitized.sketchWidth = 16;\n        } else if (sanitized.sketchWidth > 65536) {\n            console.warn(`sketchWidth should not exceed 65536 for optimal performance, got ${sanitized.sketchWidth}. Correcting to 65536.`);\n            sanitized.sketchWidth = 65536;\n        }\n    }\n    if (typeof sanitized.sketchDepth === \"number\") {\n        if (sanitized.sketchDepth <= 0) {\n            console.warn(`sketchDepth must be positive, got ${sanitized.sketchDepth}. Correcting to 4.`);\n            sanitized.sketchDepth = 4;\n        } else if (sanitized.sketchDepth < 1) {\n            console.warn(`sketchDepth should be at least 1 for optimal accuracy, got ${sanitized.sketchDepth}. Correcting to 1.`);\n            sanitized.sketchDepth = 1;\n        } else if (sanitized.sketchDepth > 16) {\n            console.warn(`sketchDepth should not exceed 16 for optimal accuracy, got ${sanitized.sketchDepth}. Correcting to 16.`);\n            sanitized.sketchDepth = 16;\n        }\n    }\n    if (typeof sanitized.minFrequencyThreshold === \"number\" && sanitized.minFrequencyThreshold <= 0) {\n        console.warn(`minFrequencyThreshold must be positive, got ${sanitized.minFrequencyThreshold}. Correcting to 1.`);\n        sanitized.minFrequencyThreshold = 1;\n    }\n    return sanitized;\n}\nfunction validateLFUConfig(config) {\n    if (typeof config.decayFactor === \"number\") {\n        validateNumberRange(config.decayFactor, 0, 1, \"decayFactor\");\n    }\n    if (typeof config.decayInterval === \"number\") {\n        validatePositiveInteger(config.decayInterval, \"decayInterval\");\n    }\n    if (typeof config.sketchWidth === \"number\") {\n        validatePositiveInteger(config.sketchWidth, \"sketchWidth\");\n        if (config.sketchWidth < 16 || config.sketchWidth > 65536) {\n            throw new Error(`sketchWidth must be between 16 and 65536, got ${config.sketchWidth}`);\n        }\n    }\n    if (typeof config.sketchDepth === \"number\") {\n        validatePositiveInteger(config.sketchDepth, \"sketchDepth\");\n        if (config.sketchDepth < 1 || config.sketchDepth > 16) {\n            throw new Error(`sketchDepth must be between 1 and 16, got ${config.sketchDepth}`);\n        }\n    }\n    if (typeof config.minFrequencyThreshold === \"number\") {\n        validatePositiveInteger(config.minFrequencyThreshold, \"minFrequencyThreshold\");\n    }\n}\nfunction sanitizeARCConfig(config) {\n    const sanitized = {\n        ...config\n    };\n    if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n        console.warn(`maxCacheSize must be positive, got ${sanitized.maxCacheSize}. Correcting to 1000.`);\n        sanitized.maxCacheSize = 1e3;\n    }\n    if (typeof sanitized.frequencyThreshold === \"number\" && sanitized.frequencyThreshold <= 0) {\n        console.warn(`frequencyThreshold must be positive, got ${sanitized.frequencyThreshold}. Correcting to 2.`);\n        sanitized.frequencyThreshold = 2;\n    }\n    if (typeof sanitized.frequencyDecayFactor === \"number\") {\n        if (sanitized.frequencyDecayFactor < 0) {\n            console.warn(`frequencyDecayFactor must be between 0 and 1, got ${sanitized.frequencyDecayFactor}. Correcting to 0.`);\n            sanitized.frequencyDecayFactor = 0;\n        } else if (sanitized.frequencyDecayFactor > 1) {\n            console.warn(`frequencyDecayFactor must be between 0 and 1, got ${sanitized.frequencyDecayFactor}. Correcting to 1.`);\n            sanitized.frequencyDecayFactor = 1;\n        }\n    }\n    if (typeof sanitized.frequencyDecayInterval === \"number\" && sanitized.frequencyDecayInterval <= 0) {\n        console.warn(`frequencyDecayInterval must be positive, got ${sanitized.frequencyDecayInterval}. Correcting to 60000.`);\n        sanitized.frequencyDecayInterval = 6e4;\n    }\n    if (typeof sanitized.adaptiveLearningRate === \"number\") {\n        if (sanitized.adaptiveLearningRate < 0) {\n            console.warn(`adaptiveLearningRate must be between 0 and 10, got ${sanitized.adaptiveLearningRate}. Correcting to 0.`);\n            sanitized.adaptiveLearningRate = 0;\n        } else if (sanitized.adaptiveLearningRate > 10) {\n            console.warn(`adaptiveLearningRate must be between 0 and 10, got ${sanitized.adaptiveLearningRate}. Correcting to 10.`);\n            sanitized.adaptiveLearningRate = 10;\n        }\n    }\n    return sanitized;\n}\nfunction validateARCConfig(config) {\n    if (typeof config.maxCacheSize === \"number\") {\n        validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n    }\n    if (typeof config.frequencyThreshold === \"number\") {\n        validatePositiveInteger(config.frequencyThreshold, \"frequencyThreshold\");\n    }\n    if (typeof config.frequencyDecayFactor === \"number\") {\n        validateNumberRange(config.frequencyDecayFactor, 0, 1, \"frequencyDecayFactor\");\n    }\n    if (typeof config.frequencyDecayInterval === \"number\") {\n        validatePositiveInteger(config.frequencyDecayInterval, \"frequencyDecayInterval\");\n    }\n    if (typeof config.adaptiveLearningRate === \"number\") {\n        validateNumberRange(config.adaptiveLearningRate, 0, 10, \"adaptiveLearningRate\");\n    }\n}\nfunction sanitizeTwoQueueConfig(config) {\n    const sanitized = {\n        ...config\n    };\n    if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n        console.warn(`maxCacheSize must be positive, got ${sanitized.maxCacheSize}. Correcting to 1000.`);\n        sanitized.maxCacheSize = 1e3;\n    }\n    if (typeof sanitized.promotionThreshold === \"number\" && sanitized.promotionThreshold <= 0) {\n        console.warn(`promotionThreshold must be positive, got ${sanitized.promotionThreshold}. Correcting to 2.`);\n        sanitized.promotionThreshold = 2;\n    }\n    if (typeof sanitized.hotQueueDecayFactor === \"number\") {\n        if (sanitized.hotQueueDecayFactor < 0) {\n            console.warn(`hotQueueDecayFactor must be between 0 and 1, got ${sanitized.hotQueueDecayFactor}. Correcting to 0.`);\n            sanitized.hotQueueDecayFactor = 0;\n        } else if (sanitized.hotQueueDecayFactor > 1) {\n            console.warn(`hotQueueDecayFactor must be between 0 and 1, got ${sanitized.hotQueueDecayFactor}. Correcting to 1.`);\n            sanitized.hotQueueDecayFactor = 1;\n        }\n    }\n    if (typeof sanitized.hotQueueDecayInterval === \"number\" && sanitized.hotQueueDecayInterval <= 0) {\n        console.warn(`hotQueueDecayInterval must be positive, got ${sanitized.hotQueueDecayInterval}. Correcting to 300000.`);\n        sanitized.hotQueueDecayInterval = 3e5;\n    }\n    return sanitized;\n}\nfunction validateTwoQueueConfig(config) {\n    if (typeof config.maxCacheSize === \"number\") {\n        validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n    }\n    if (typeof config.promotionThreshold === \"number\") {\n        validatePositiveInteger(config.promotionThreshold, \"promotionThreshold\");\n    }\n    if (typeof config.hotQueueDecayFactor === \"number\") {\n        validateNumberRange(config.hotQueueDecayFactor, 0, 1, \"hotQueueDecayFactor\");\n    }\n    if (typeof config.hotQueueDecayInterval === \"number\") {\n        validatePositiveInteger(config.hotQueueDecayInterval, \"hotQueueDecayInterval\");\n    }\n}\nfunction validateEvictionStrategyConfig(config) {\n    if (!config || typeof config !== \"object\") {\n        throw new Error(\"Configuration must be a non-null object\");\n    }\n    if (!config.type) {\n        throw new Error(\"Configuration must specify a type\");\n    }\n    const validTypes = [\n        \"lfu\",\n        \"lru\",\n        \"fifo\",\n        \"mru\",\n        \"random\",\n        \"arc\",\n        \"2q\"\n    ];\n    if (!validTypes.includes(config.type)) {\n        throw new Error(`Invalid eviction strategy type: ${config.type}. Must be one of: ${validTypes.join(\", \")}`);\n    }\n    switch(config.type){\n        case \"lfu\":\n            validateLFUConfig(config);\n            break;\n        case \"arc\":\n            validateARCConfig(config);\n            break;\n        case \"2q\":\n            validateTwoQueueConfig(config);\n            break;\n        case \"lru\":\n        case \"fifo\":\n        case \"mru\":\n        case \"random\":\n            break;\n        default:\n            throw new Error(`Unsupported eviction strategy type: ${config.type}`);\n    }\n}\nfunction sanitizeConfigByType(config) {\n    if (!config.type) {\n        return config;\n    }\n    switch(config.type){\n        case \"lfu\":\n            return sanitizeLFUConfig(config);\n        case \"arc\":\n            return sanitizeARCConfig(config);\n        case \"2q\":\n            return sanitizeTwoQueueConfig(config);\n        case \"lru\":\n        case \"fifo\":\n        case \"mru\":\n        case \"random\":\n            return config;\n        default:\n            return config;\n    }\n}\nfunction createValidatedConfig(baseConfig, userConfig) {\n    const mergedConfig = {\n        ...baseConfig,\n        ...userConfig\n    };\n    const sanitizedConfig = sanitizeConfigByType(mergedConfig);\n    validateEvictionStrategyConfig(sanitizedConfig);\n    return sanitizedConfig;\n}\n// src/eviction/strategies/LFUEvictionStrategy.ts\nfunction fnv1aHash(key, seed) {\n    const FNV_OFFSET_BASIS = 2166136261;\n    const FNV_PRIME = 16777619;\n    let hash = (FNV_OFFSET_BASIS ^ seed) >>> 0;\n    for(let i = 0; i < key.length; i++){\n        hash ^= key.charCodeAt(i);\n        hash = hash * FNV_PRIME >>> 0;\n    }\n    hash ^= hash >>> 16;\n    hash = hash * 2246822507 >>> 0;\n    hash ^= hash >>> 13;\n    hash = hash * 3266489909 >>> 0;\n    hash ^= hash >>> 16;\n    return hash >>> 0;\n}\nvar CountMinSketch = class {\n    constructor(width = 1024, depth = 4){\n        this.width = width;\n        this.depth = depth;\n        this.sketches = Array(depth).fill(null).map(()=>new Array(width).fill(0));\n        this.seeds = Array(depth).fill(null).map(()=>Math.floor(Math.random() * 1e6));\n    }\n    /**\n   * Check if a number is a power of 2 for optimized bit masking\n   */ isPowerOfTwo(n) {\n        return n > 0 && (n & n - 1) === 0;\n    }\n    /**\n   * Increment the frequency count for a key\n   */ increment(key) {\n        for(let i = 0; i < this.depth; i++){\n            const hash = fnv1aHash(key, this.seeds[i]);\n            const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n            this.sketches[i][index]++;\n        }\n    }\n    /**\n   * Estimate the frequency count for a key\n   */ estimate(key) {\n        let minCount = Infinity;\n        for(let i = 0; i < this.depth; i++){\n            const hash = fnv1aHash(key, this.seeds[i]);\n            const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n            minCount = Math.min(minCount, this.sketches[i][index]);\n        }\n        return minCount === Infinity ? 0 : minCount;\n    }\n    /**\n   * Apply decay to all frequencies\n   */ decay(factor) {\n        for(let i = 0; i < this.depth; i++){\n            for(let j = 0; j < this.width; j++){\n                this.sketches[i][j] = Math.floor(this.sketches[i][j] * (1 - factor));\n            }\n        }\n    }\n    /**\n   * Reset all frequencies to zero\n   */ reset() {\n        for(let i = 0; i < this.depth; i++){\n            for(let j = 0; j < this.width; j++){\n                this.sketches[i][j] = 0;\n            }\n        }\n    }\n};\nvar LFUEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"lfu\";\n    }\n    constructor(config = {}){\n        super();\n        const defaultBackwardsCompatible = {\n            useProbabilisticCounting: false,\n            decayFactor: 0,\n            decayInterval: Number.MAX_SAFE_INTEGER\n        };\n        const baseConfig = {\n            ...DEFAULT_LFU_CONFIG,\n            ...defaultBackwardsCompatible\n        };\n        this.config = createValidatedConfig(baseConfig, config);\n        this.sketch = this.config.useProbabilisticCounting ? new CountMinSketch(this.config.sketchWidth, this.config.sketchDepth) : null;\n        this.lastDecayTime = Date.now();\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        this.applyPeriodicDecay();\n        const sortedEntries = Array.from(allMetadata.entries()).sort((a, b)=>{\n            const freqA = this.getEffectiveFrequency(a[0], a[1]);\n            const freqB = this.getEffectiveFrequency(b[0], b[1]);\n            if (freqA !== freqB) {\n                return freqA - freqB;\n            }\n            return a[1].lastAccessedAt - b[1].lastAccessedAt;\n        });\n        return sortedEntries.slice(0, evictionCount).map(([key])=>key);\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        const now = Date.now();\n        metadata.lastAccessedAt = now;\n        metadata.accessCount++;\n        if (this.sketch) {\n            this.sketch.increment(key);\n            metadata.rawFrequency = this.sketch.estimate(key);\n        } else {\n            metadata.rawFrequency = metadata.accessCount;\n        }\n        metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n        metadata.lastFrequencyUpdate = now;\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize,\n            rawFrequency: 1\n        };\n        metadata.frequencyScore = 1;\n        metadata.lastFrequencyUpdate = now;\n        if (this.sketch) {\n            this.sketch.increment(key);\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    /**\n   * Get the effective frequency for an item, applying real-time decay if needed\n   */ getEffectiveFrequency(_key, metadata) {\n        if ((this.config.decayFactor ?? 0) === 0) {\n            return metadata.rawFrequency || metadata.accessCount;\n        }\n        const now = Date.now();\n        if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n            const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n            const decayAmount = timeSinceUpdate / (this.config.decayInterval ?? 6e4) * (this.config.decayFactor ?? 0.1);\n            return Math.max(this.config.minFrequencyThreshold ?? 1, metadata.frequencyScore * (1 - decayAmount));\n        }\n        return metadata.rawFrequency || metadata.accessCount;\n    }\n    /**\n   * Calculate frequency score with decay applied\n   */ calculateFrequencyScore(metadata, currentTime) {\n        const rawFreq = metadata.rawFrequency || metadata.accessCount;\n        if ((this.config.decayFactor ?? 0) === 0) {\n            return rawFreq;\n        }\n        if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n            return rawFreq;\n        }\n        const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n        const decayAmount = timeSinceUpdate / (this.config.decayInterval ?? 6e4) * (this.config.decayFactor ?? 0.1);\n        const previousScore = metadata.frequencyScore || rawFreq;\n        const decayedScore = previousScore * (1 - decayAmount);\n        return Math.max(this.config.minFrequencyThreshold ?? 1, decayedScore + 1);\n    }\n    /**\n   * Apply periodic decay to the frequency sketch and metadata\n   */ applyPeriodicDecay() {\n        if ((this.config.decayFactor ?? 0) === 0) return;\n        const now = Date.now();\n        const timeSinceDecay = now - this.lastDecayTime;\n        if (timeSinceDecay >= (this.config.decayInterval ?? 6e4)) {\n            if (this.sketch) {\n                this.sketch.decay(this.config.decayFactor ?? 0.1);\n            }\n            this.lastDecayTime = now;\n        }\n    }\n    /**\n   * Get configuration for this strategy\n   */ getConfig() {\n        return {\n            ...this.config\n        };\n    }\n    /**\n   * Reset frequency tracking (useful for testing or cache clearing)\n   */ reset() {\n        if (this.sketch) {\n            this.sketch.reset();\n        }\n        this.lastDecayTime = Date.now();\n    }\n};\n// src/eviction/strategies/FIFOEvictionStrategy.ts\nvar FIFOEvictionStrategy = class extends EvictionStrategy {\n    async selectForEviction(metadataProvider, context) {\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        const keysToEvict = [];\n        const sortedEntries = Array.from(allMetadata.entries()).sort(([, a], [, b])=>a.addedAt - b.addedAt);\n        for(let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++){\n            keysToEvict.push(sortedEntries[i][0]);\n        }\n        return keysToEvict;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata) {\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            await metadataProvider.setMetadata(key, metadata);\n        }\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    getStrategyName() {\n        return \"fifo\";\n    }\n};\n// src/eviction/strategies/MRUEvictionStrategy.ts\nvar MRUEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"MRU\";\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        const sortedEntries = Array.from(allMetadata.entries()).sort((a, b)=>{\n            return b[1].lastAccessedAt - a[1].lastAccessedAt;\n        });\n        return sortedEntries.slice(0, evictionCount).map(([key])=>key);\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        metadata.lastAccessedAt = Date.now();\n        metadata.accessCount++;\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n};\n// src/eviction/strategies/RandomEvictionStrategy.ts\nvar RandomEvictionStrategy = class extends EvictionStrategy {\n    async selectForEviction(metadataProvider, context) {\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        const keys = Array.from(allMetadata.keys());\n        const keysToEvict = [];\n        const availableKeys = [\n            ...keys\n        ];\n        for(let i = 0; i < Math.min(evictionCount, availableKeys.length); i++){\n            const randomIndex = Math.floor(Math.random() * availableKeys.length);\n            keysToEvict.push(availableKeys.splice(randomIndex, 1)[0]);\n        }\n        return keysToEvict;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata) {\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            await metadataProvider.setMetadata(key, metadata);\n        }\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    getStrategyName() {\n        return \"random\";\n    }\n};\n// src/eviction/strategies/ARCEvictionStrategy.ts\nvar ARCEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"ARC\";\n    }\n    constructor(maxCacheSize = 1e3, config = {}){\n        super(), this.recentGhosts = /* @__PURE__ */ new Set(), // T1 ghost entries\n        this.frequentGhosts = /* @__PURE__ */ new Set(), // T2 ghost entries\n        this.targetRecentSize = 0;\n        const baseConfig = {\n            ...DEFAULT_ARC_CONFIG,\n            maxCacheSize\n        };\n        this.config = createValidatedConfig(baseConfig, config);\n        this.maxGhostSize = this.config.maxCacheSize;\n        this.lastDecayTime = Date.now();\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        this.applyPeriodicDecay(allMetadata);\n        const recentItems = /* @__PURE__ */ new Map();\n        const frequentItems = /* @__PURE__ */ new Map();\n        for (const [key, metadata] of allMetadata){\n            if (this.isFrequentItem(metadata)) {\n                frequentItems.set(key, metadata);\n            } else {\n                recentItems.set(key, metadata);\n            }\n        }\n        const keysToEvict = [];\n        const totalItems = recentItems.size + frequentItems.size;\n        const maxIterations = Math.min(evictionCount, totalItems);\n        for(let i = 0; i < maxIterations; i++){\n            let keyToEvict = null;\n            let sourceList = null;\n            if (recentItems.size > this.targetRecentSize && recentItems.size > 0) {\n                keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n                sourceList = recentItems;\n            } else if (frequentItems.size > 0) {\n                keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(frequentItems, \"frequent\") : this.selectLRUFromItems(frequentItems);\n                sourceList = frequentItems;\n            } else if (recentItems.size > 0) {\n                keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n                sourceList = recentItems;\n            }\n            if (keyToEvict && sourceList) {\n                keysToEvict.push(keyToEvict);\n                sourceList.delete(keyToEvict);\n            } else {\n                break;\n            }\n            if (recentItems.size === 0 && frequentItems.size === 0) {\n                break;\n            }\n        }\n        return keysToEvict;\n    }\n    selectLRUFromItems(items) {\n        if (items.size === 0) {\n            return null;\n        }\n        let oldestKey = null;\n        let oldestTime = Infinity;\n        const now = Date.now();\n        for (const [key, metadata] of items){\n            if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n                continue;\n            }\n            if (metadata.lastAccessedAt < oldestTime) {\n                oldestTime = metadata.lastAccessedAt;\n                oldestKey = key;\n            }\n        }\n        if (oldestKey !== null) {\n            return oldestKey;\n        }\n        if (items.size > 0) {\n            const firstKey = items.keys().next().value;\n            return firstKey ?? null;\n        }\n        return null;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        const now = Date.now();\n        const updatedMetadata = {\n            ...metadata,\n            lastAccessedAt: now,\n            accessCount: metadata.accessCount + 1\n        };\n        updatedMetadata.rawFrequency = updatedMetadata.accessCount;\n        if (this.config.useEnhancedFrequency && (this.config.frequencyDecayFactor ?? 0) > 0) {\n            updatedMetadata.frequencyScore = this.calculateFrequencyScore(updatedMetadata, now);\n            updatedMetadata.lastFrequencyUpdate = now;\n        }\n        const learningRate = this.config.adaptiveLearningRate ?? 1;\n        let targetAdjusted = false;\n        if (learningRate > 0) {\n            if (this.recentGhosts.has(key)) {\n                const adjustment = Math.max(1, Math.ceil(learningRate));\n                this.targetRecentSize = Math.min(this.targetRecentSize + adjustment, this.maxGhostSize);\n                this.recentGhosts.delete(key);\n                targetAdjusted = true;\n            } else if (this.frequentGhosts.has(key)) {\n                const adjustment = Math.max(1, Math.ceil(learningRate));\n                this.targetRecentSize = Math.max(this.targetRecentSize - adjustment, 0);\n                this.frequentGhosts.delete(key);\n                targetAdjusted = true;\n            }\n        } else {\n            if (this.recentGhosts.has(key)) {\n                this.recentGhosts.delete(key);\n            } else if (this.frequentGhosts.has(key)) {\n                this.frequentGhosts.delete(key);\n            }\n        }\n        if (targetAdjusted) {\n            this.cleanupGhostLists();\n        }\n        await metadataProvider.setMetadata(key, updatedMetadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize,\n            rawFrequency: 1\n        };\n        if (this.config.useEnhancedFrequency && (this.config.frequencyDecayFactor ?? 0) > 0) {\n            metadata.frequencyScore = 1;\n            metadata.lastFrequencyUpdate = now;\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata && this.isFrequentItem(metadata)) {\n            this.addToFrequentGhosts(key);\n        } else {\n            this.addToRecentGhosts(key);\n        }\n        await metadataProvider.deleteMetadata(key);\n        this.cleanupGhostLists();\n    }\n    /**\n   * Add key to recent ghost list with proper size management\n   */ addToRecentGhosts(key) {\n        this.frequentGhosts.delete(key);\n        this.recentGhosts.add(key);\n        this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n    }\n    /**\n   * Add key to frequent ghost list with proper size management\n   */ addToFrequentGhosts(key) {\n        this.recentGhosts.delete(key);\n        this.frequentGhosts.add(key);\n        this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n    }\n    /**\n   * Cleanup ghost lists to prevent memory leaks\n   */ cleanupGhostLists() {\n        this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n        this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n    }\n    /**\n   * Enforce size limit on a ghost list by removing oldest entries\n   */ enforceGhostListSizeLimit(ghostList, maxSize) {\n        if (maxSize <= 0) {\n            ghostList.clear();\n            return;\n        }\n        const iterator = ghostList.values();\n        while(ghostList.size > maxSize){\n            const next = iterator.next();\n            if (next.done) {\n                break;\n            }\n            ghostList.delete(next.value);\n        }\n    }\n    /**\n   * Determine if an item should be classified as frequent vs recent\n   */ isFrequentItem(metadata) {\n        if (!this.config.useEnhancedFrequency) {\n            return metadata.accessCount > 1;\n        }\n        const frequency = this.getEffectiveFrequency(metadata);\n        return frequency >= (this.config.frequencyThreshold ?? 2);\n    }\n    /**\n   * Get effective frequency for an item, applying decay if enabled\n   */ getEffectiveFrequency(metadata) {\n        if (!this.config.useEnhancedFrequency || (this.config.frequencyDecayFactor ?? 0) === 0) {\n            return metadata.rawFrequency || metadata.accessCount;\n        }\n        const now = Date.now();\n        if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n            const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n            const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n            if (timeSinceUpdate > decayInterval / 10) {\n                const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * (this.config.frequencyDecayFactor ?? 0.05));\n                return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n            }\n            return metadata.frequencyScore;\n        }\n        return metadata.rawFrequency || metadata.accessCount;\n    }\n    /**\n   * Calculate frequency score with decay applied\n   */ calculateFrequencyScore(metadata, currentTime) {\n        const rawFreq = metadata.rawFrequency || metadata.accessCount;\n        if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n            return rawFreq;\n        }\n        const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n        const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n        const decayFactor = this.config.frequencyDecayFactor ?? 0.05;\n        const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * decayFactor);\n        const previousScore = metadata.frequencyScore || rawFreq;\n        const decayedScore = Math.max(1, previousScore * (1 - decayAmount));\n        return Math.max(1, decayedScore + 1);\n    }\n    /**\n   * Select eviction candidate using frequency-weighted approach\n   */ selectFrequencyWeightedFromItems(items, context) {\n        if (items.size === 0) {\n            return null;\n        }\n        let bestKey = null;\n        let bestScore = Infinity;\n        const now = Date.now();\n        for (const [key, metadata] of items){\n            if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n                continue;\n            }\n            const frequency = this.getEffectiveFrequency(metadata);\n            const timeFactor = Math.max(0, now - metadata.lastAccessedAt);\n            let score;\n            if (context === \"recent\") {\n                score = timeFactor + 1e3 / Math.max(1, frequency);\n            } else if (context === \"frequent\") {\n                score = timeFactor / 1e3 + 10 / Math.max(1, frequency);\n            } else {\n                score = timeFactor / 1e3 / Math.max(1, frequency);\n            }\n            if (score < bestScore) {\n                bestScore = score;\n                bestKey = key;\n            }\n        }\n        if (bestKey !== null) {\n            return bestKey;\n        }\n        if (items.size > 0) {\n            const firstKey = items.keys().next().value;\n            return firstKey ?? null;\n        }\n        return null;\n    }\n    /**\n   * Apply periodic decay to frequency scores\n   */ applyPeriodicDecay(items) {\n        if (!this.config.useEnhancedFrequency || (this.config.frequencyDecayFactor ?? 0) === 0) return;\n        const now = Date.now();\n        const timeSinceDecay = now - this.lastDecayTime;\n        const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n        if (timeSinceDecay >= decayInterval && items.size > 0) {\n            const decayFactor = this.config.frequencyDecayFactor ?? 0.05;\n            for (const metadata of items.values()){\n                if (typeof metadata.frequencyScore === \"number\") {\n                    const intervalsPassed = timeSinceDecay / decayInterval;\n                    const totalDecay = Math.min(0.9, decayFactor * intervalsPassed);\n                    const newScore = metadata.frequencyScore * (1 - totalDecay);\n                    metadata.frequencyScore = Math.max(1, newScore);\n                    metadata.lastFrequencyUpdate = now;\n                }\n            }\n            this.lastDecayTime = now;\n        }\n    }\n    /**\n   * Get configuration for this strategy\n   */ getConfig() {\n        return {\n            ...this.config\n        };\n    }\n    /**\n   * Reset internal state (useful for testing)\n   */ reset() {\n        this.recentGhosts.clear();\n        this.frequentGhosts.clear();\n        this.targetRecentSize = 0;\n        this.lastDecayTime = Date.now();\n    }\n    /**\n   * Get current adaptive state for monitoring/debugging\n   */ getAdaptiveState() {\n        return {\n            targetRecentSize: this.targetRecentSize,\n            recentGhostSize: this.recentGhosts.size,\n            frequentGhostSize: this.frequentGhosts.size\n        };\n    }\n};\n// src/eviction/strategies/TwoQueueEvictionStrategy.ts\nvar TwoQueueEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"2Q\";\n    }\n    constructor(maxCacheSize = 1e3, config = {}){\n        super(), this.recentQueue = [], // A1 queue for recent items\n        this.hotQueue = [], // Am queue for hot items\n        this.ghostQueue = /* @__PURE__ */ new Set();\n        const baseConfig = {\n            ...DEFAULT_TWO_QUEUE_CONFIG,\n            maxCacheSize\n        };\n        this.config = createValidatedConfig(baseConfig, config);\n        this.maxRecentSize = Math.max(1, Math.floor(this.config.maxCacheSize * 0.25));\n        this.maxGhostSize = this.config.maxCacheSize;\n        this.lastDecayTime = Date.now();\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        await this.applyPeriodicDecay(allMetadata);\n        const keysToEvict = [];\n        for(let i = 0; i < evictionCount; i++){\n            let keyToEvict = null;\n            for(let j = this.recentQueue.length - 1; j >= 0; j--){\n                const key = this.recentQueue[j];\n                if (allMetadata.has(key) && !keysToEvict.includes(key)) {\n                    keyToEvict = key;\n                    break;\n                }\n            }\n            if (!keyToEvict) {\n                if (this.config.useFrequencyWeightedLRU) {\n                    keyToEvict = this.selectFromHotQueueFrequencyWeighted(allMetadata, keysToEvict);\n                } else {\n                    keyToEvict = this.selectFromHotQueueLRU(allMetadata, keysToEvict);\n                }\n            }\n            if (keyToEvict) {\n                keysToEvict.push(keyToEvict);\n            } else {\n                break;\n            }\n        }\n        return keysToEvict;\n    }\n    /**\n   * Select eviction candidate from hot queue using traditional LRU\n   */ selectFromHotQueueLRU(items, excludeKeys = []) {\n        let oldestKey = null;\n        let oldestTime = Infinity;\n        for (const key of this.hotQueue){\n            if (excludeKeys.includes(key)) continue;\n            const metadata = items.get(key);\n            if (metadata && metadata.lastAccessedAt < oldestTime) {\n                oldestTime = metadata.lastAccessedAt;\n                oldestKey = key;\n            }\n        }\n        return oldestKey || (items.size > 0 ? items.keys().next().value ?? null : null);\n    }\n    /**\n   * Select eviction candidate from hot queue using frequency-weighted LRU\n   */ selectFromHotQueueFrequencyWeighted(items, excludeKeys = []) {\n        let bestKey = null;\n        let lowestScore = Infinity;\n        for (const key of this.hotQueue){\n            if (excludeKeys.includes(key)) continue;\n            const metadata = items.get(key);\n            if (!metadata) continue;\n            const frequency = this.getEffectiveFrequency(metadata);\n            const timeFactor = Date.now() - metadata.lastAccessedAt;\n            const normalizedTimeFactor = timeFactor / (1e3 * 60);\n            const score = normalizedTimeFactor / Math.max(1, frequency);\n            if (score < lowestScore) {\n                lowestScore = score;\n                bestKey = key;\n            }\n        }\n        return bestKey || (items.size > 0 ? items.keys().next().value ?? null : null);\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        const now = Date.now();\n        metadata.lastAccessedAt = now;\n        metadata.accessCount++;\n        metadata.rawFrequency = metadata.accessCount;\n        if ((this.config.hotQueueDecayFactor ?? 0) > 0) {\n            metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n            metadata.lastFrequencyUpdate = now;\n        }\n        const recentIndex = this.recentQueue.indexOf(key);\n        if (recentIndex !== -1) {\n            if (this.shouldPromoteToHotQueue(metadata)) {\n                this.recentQueue.splice(recentIndex, 1);\n                this.hotQueue.unshift(key);\n            }\n        } else {\n            const hotIndex = this.hotQueue.indexOf(key);\n            if (hotIndex !== -1) {\n                this.hotQueue.splice(hotIndex, 1);\n                this.hotQueue.unshift(key);\n            }\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        let metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) {\n            metadata = {\n                key,\n                addedAt: now,\n                lastAccessedAt: now,\n                accessCount: 1,\n                estimatedSize,\n                rawFrequency: 1\n            };\n            if ((this.config.hotQueueDecayFactor ?? 0) > 0) {\n                metadata.frequencyScore = 1;\n                metadata.lastFrequencyUpdate = now;\n            }\n        }\n        if (this.ghostQueue.has(key)) {\n            this.ghostQueue.delete(key);\n            this.hotQueue.unshift(key);\n        } else {\n            this.recentQueue.unshift(key);\n            if (this.recentQueue.length > this.maxRecentSize) {\n                const evicted = this.recentQueue.pop();\n                if (evicted) {\n                    this.ghostQueue.add(evicted);\n                }\n            }\n        }\n        if (this.ghostQueue.size > this.maxGhostSize) {\n            const firstKey = this.ghostQueue.values().next().value;\n            if (firstKey) {\n                this.ghostQueue.delete(firstKey);\n            }\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        const recentIndex = this.recentQueue.indexOf(key);\n        if (recentIndex !== -1) {\n            this.recentQueue.splice(recentIndex, 1);\n        }\n        const hotIndex = this.hotQueue.indexOf(key);\n        if (hotIndex !== -1) {\n            this.hotQueue.splice(hotIndex, 1);\n        }\n        await metadataProvider.deleteMetadata(key);\n    }\n    /**\n   * Determine if an item should be promoted from recent to hot queue\n   */ shouldPromoteToHotQueue(metadata) {\n        if (!this.config.useFrequencyPromotion) {\n            return metadata.accessCount >= 2;\n        }\n        const threshold = this.config.promotionThreshold ?? 2;\n        const frequency = this.getEffectiveFrequency(metadata);\n        return frequency >= threshold;\n    }\n    /**\n   * Get effective frequency for an item, applying decay if enabled\n   */ getEffectiveFrequency(metadata) {\n        if ((this.config.hotQueueDecayFactor ?? 0) === 0) {\n            return metadata.rawFrequency || metadata.accessCount;\n        }\n        const now = Date.now();\n        if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n            const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n            const decayAmount = timeSinceUpdate / (this.config.hotQueueDecayInterval ?? 3e5) * (this.config.hotQueueDecayFactor ?? 0.05);\n            return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n        }\n        return metadata.rawFrequency || metadata.accessCount;\n    }\n    /**\n   * Calculate frequency score with decay applied\n   */ calculateFrequencyScore(metadata, currentTime) {\n        const rawFreq = metadata.rawFrequency || metadata.accessCount;\n        if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n            return rawFreq;\n        }\n        const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n        const decayAmount = timeSinceUpdate / (this.config.hotQueueDecayInterval ?? 3e5) * (this.config.hotQueueDecayFactor ?? 0.05);\n        const previousScore = metadata.frequencyScore || rawFreq;\n        const decayedScore = previousScore * (1 - decayAmount);\n        return Math.max(1, decayedScore + 1);\n    }\n    /**\n   * Apply periodic decay to hot queue items\n   */ async applyPeriodicDecay(items) {\n        if ((this.config.hotQueueDecayFactor ?? 0) === 0) return;\n        const now = Date.now();\n        const timeSinceDecay = now - this.lastDecayTime;\n        if (timeSinceDecay >= (this.config.hotQueueDecayInterval ?? 3e5)) {\n            if (this.hotQueue.length > 0) {\n                for (const key of this.hotQueue){\n                    const metadata = items.get(key);\n                    if (metadata && typeof metadata.frequencyScore === \"number\") {\n                        const decayAmount = this.config.hotQueueDecayFactor ?? 0.05;\n                        metadata.frequencyScore = Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n                    }\n                }\n                this.lastDecayTime = now;\n            }\n        }\n    }\n    /**\n   * Get configuration for this strategy\n   */ getConfig() {\n        return {\n            ...this.config\n        };\n    }\n    /**\n   * Reset internal state (useful for testing)\n   */ reset() {\n        this.recentQueue = [];\n        this.hotQueue = [];\n        this.ghostQueue.clear();\n        this.lastDecayTime = Date.now();\n    }\n};\n// src/eviction/EvictionStrategyFactory.ts\nfunction createEvictionStrategy(policy, maxCacheSize, config) {\n    const safeMaxCacheSize = typeof maxCacheSize === \"number\" && maxCacheSize > 0 ? maxCacheSize : 1e3;\n    switch(policy){\n        case \"lru\":\n            return new LRUEvictionStrategy();\n        case \"lfu\":\n            {\n                try {\n                    const lfuConfig = config?.type === \"lfu\" ? config : {\n                        type: \"lfu\"\n                    };\n                    return new LFUEvictionStrategy(lfuConfig);\n                } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    console.warn(`Failed to create lfu strategy with provided configuration, falling back to LRU:`, errorMessage);\n                    return new LRUEvictionStrategy();\n                }\n            }\n        case \"fifo\":\n            return new FIFOEvictionStrategy();\n        case \"mru\":\n            return new MRUEvictionStrategy();\n        case \"random\":\n            return new RandomEvictionStrategy();\n        case \"arc\":\n            {\n                try {\n                    const arcConfig = config?.type === \"arc\" ? config : {\n                        ...DEFAULT_ARC_CONFIG,\n                        maxCacheSize: safeMaxCacheSize\n                    };\n                    const finalMaxSize = arcConfig.maxCacheSize && arcConfig.maxCacheSize > 0 ? arcConfig.maxCacheSize : safeMaxCacheSize;\n                    return new ARCEvictionStrategy(finalMaxSize, {\n                        ...arcConfig,\n                        maxCacheSize: finalMaxSize\n                    });\n                } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    console.warn(`Failed to create arc strategy with provided configuration, falling back to LRU:`, errorMessage);\n                    return new LRUEvictionStrategy();\n                }\n            }\n        case \"2q\":\n            {\n                try {\n                    const twoQConfig = config?.type === \"2q\" ? config : {\n                        ...DEFAULT_TWO_QUEUE_CONFIG,\n                        maxCacheSize: safeMaxCacheSize\n                    };\n                    const finalMaxSize = twoQConfig.maxCacheSize && twoQConfig.maxCacheSize > 0 ? twoQConfig.maxCacheSize : safeMaxCacheSize;\n                    return new TwoQueueEvictionStrategy(finalMaxSize, {\n                        ...twoQConfig,\n                        maxCacheSize: finalMaxSize\n                    });\n                } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    console.warn(`Failed to create 2q strategy with provided configuration, falling back to LRU:`, errorMessage);\n                    return new LRUEvictionStrategy();\n                }\n            }\n        default:\n            throw new Error(`Unsupported eviction policy: ${policy}`);\n    }\n}\n// src/ttl/TTLManager.ts\nvar logger22 = logger_default.get(\"TTLManager\");\nvar TTLManager = class {\n    constructor(config = {}){\n        this.config = {\n            autoCleanup: true,\n            cleanupInterval: 6e4,\n            // 1 minute default\n            validateOnAccess: true,\n            ...config\n        };\n        if (this.config.autoCleanup && this.config.cleanupInterval) {\n            this.startAutoCleanup();\n        }\n    }\n    /**\n   * Check if TTL is enabled\n   */ isTTLEnabled() {\n        return typeof this.config.defaultTTL === \"number\" && this.config.defaultTTL > 0;\n    }\n    /**\n   * Get the default TTL value\n   */ getDefaultTTL() {\n        return this.config.defaultTTL;\n    }\n    /**\n   * Update TTL configuration\n   */ updateConfig(config) {\n        const oldConfig = this.config;\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        if (oldConfig.autoCleanup !== this.config.autoCleanup || oldConfig.cleanupInterval !== this.config.cleanupInterval) {\n            this.stopAutoCleanup();\n            if (this.config.autoCleanup && this.config.cleanupInterval) {\n                this.startAutoCleanup();\n            }\n        }\n        logger22.debug(\"TTL configuration updated\", {\n            config: this.config\n        });\n    }\n    /**\n   * Set TTL metadata for an item when it's added\n   */ async onItemAdded(key, metadataProvider, itemTTL) {\n        if (!this.isTTLEnabled() && !itemTTL) {\n            return;\n        }\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) {\n            logger22.warning(\"No metadata found for item when setting TTL\", {\n                key\n            });\n            return;\n        }\n        const ttl = itemTTL || this.config.defaultTTL;\n        if (ttl && ttl > 0) {\n            const ttlMetadata = {\n                ...metadata,\n                expiresAt: metadata.addedAt + ttl,\n                ttl\n            };\n            await metadataProvider.setMetadata(key, ttlMetadata);\n            logger22.trace(\"TTL set for item\", {\n                key,\n                ttl,\n                expiresAt: ttlMetadata.expiresAt\n            });\n        }\n    }\n    /**\n   * Check if an item has expired\n   */ async isExpired(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata || !metadata.expiresAt) {\n            return false;\n        }\n        const now = Date.now();\n        const expired = now >= metadata.expiresAt;\n        if (expired) {\n            logger22.trace(\"Item expired\", {\n                key,\n                expiresAt: metadata.expiresAt,\n                now\n            });\n        }\n        return expired;\n    }\n    /**\n   * Check if an item is valid (not expired) before returning it\n   * Returns true if item is valid, false if expired\n   */ async validateItem(key, metadataProvider) {\n        if (!this.config.validateOnAccess) {\n            return true;\n        }\n        return !await this.isExpired(key, metadataProvider);\n    }\n    /**\n   * Get TTL information for an item\n   */ async getItemTTLInfo(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata || !metadata.expiresAt) {\n            return {\n                hasTTL: false,\n                isExpired: false\n            };\n        }\n        const now = Date.now();\n        const isExpired = now >= metadata.expiresAt;\n        const remainingTTL = isExpired ? 0 : metadata.expiresAt - now;\n        return {\n            hasTTL: true,\n            ttl: metadata.ttl,\n            expiresAt: metadata.expiresAt,\n            remainingTTL,\n            isExpired\n        };\n    }\n    /**\n   * Find all expired items\n   */ async findExpiredItems(metadataProvider) {\n        const expiredKeys = [];\n        const allMetadata = await metadataProvider.getAllMetadata();\n        const now = Date.now();\n        for (const [key, metadata] of allMetadata){\n            const ttlMetadata = metadata;\n            if (ttlMetadata.expiresAt && now >= ttlMetadata.expiresAt) {\n                expiredKeys.push(key);\n            }\n        }\n        if (expiredKeys.length > 0) {\n            logger22.debug(\"Found expired items\", {\n                count: expiredKeys.length,\n                keys: expiredKeys\n            });\n        }\n        return expiredKeys;\n    }\n    /**\n   * Manually clean up expired items\n   * Returns the keys of items that were expired\n   */ async cleanupExpiredItems(metadataProvider) {\n        return await this.findExpiredItems(metadataProvider);\n    }\n    /**\n   * Get remaining TTL for an item in milliseconds\n   */ async getRemainingTTL(key, metadataProvider) {\n        const info = await this.getItemTTLInfo(key, metadataProvider);\n        return info.hasTTL ? info.remainingTTL || 0 : null;\n    }\n    /**\n   * Extend TTL for an item\n   */ async extendTTL(key, metadataProvider, additionalTTL) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata || !metadata.expiresAt) {\n            return false;\n        }\n        metadata.expiresAt += additionalTTL;\n        await metadataProvider.setMetadata(key, metadata);\n        logger22.trace(\"TTL extended for item\", {\n            key,\n            additionalTTL,\n            newExpiresAt: metadata.expiresAt\n        });\n        return true;\n    }\n    /**\n   * Reset TTL for an item (refresh expiration)\n   */ async refreshTTL(key, metadataProvider, newTTL) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) {\n            return false;\n        }\n        const ttl = newTTL || metadata.ttl || this.config.defaultTTL;\n        if (!ttl) {\n            return false;\n        }\n        const now = Date.now();\n        const ttlMetadata = {\n            ...metadata,\n            expiresAt: now + ttl,\n            ttl\n        };\n        await metadataProvider.setMetadata(key, ttlMetadata);\n        logger22.trace(\"TTL refreshed for item\", {\n            key,\n            ttl,\n            expiresAt: ttlMetadata.expiresAt\n        });\n        return true;\n    }\n    /**\n   * Start automatic cleanup of expired items\n   */ startAutoCleanup() {\n        if (this.cleanupTimer) {\n            this.stopAutoCleanup();\n        }\n        if (this.config.cleanupInterval) {\n            this.cleanupTimer = setInterval(()=>{\n                logger22.trace(\"Auto cleanup timer triggered\");\n            }, this.config.cleanupInterval);\n            logger22.debug(\"Auto cleanup started\", {\n                interval: this.config.cleanupInterval\n            });\n        }\n    }\n    /**\n   * Stop automatic cleanup\n   */ stopAutoCleanup() {\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n            logger22.debug(\"Auto cleanup stopped\");\n        }\n    }\n    /**\n   * Cleanup resources\n   */ destroy() {\n        this.stopAutoCleanup();\n        logger22.debug(\"TTL manager destroyed\");\n    }\n};\n// src/events/CacheEventEmitter.ts\nvar CacheEventEmitter = class {\n    constructor(){\n        this.subscriptions = /* @__PURE__ */ new Map();\n        this.nextSubscriptionId = 1;\n        this.isDestroyed = false;\n        this.cleanupInterval = null;\n        this.CLEANUP_INTERVAL_MS = 3e4;\n        // 30 seconds\n        this.MAX_INACTIVE_TIME_MS = 3e5;\n        // 5 minutes\n        this.WEAK_REF_ENABLED = typeof WeakRef !== \"undefined\";\n        this.startPeriodicCleanup();\n    }\n    /**\n   * Start periodic cleanup of inactive subscriptions\n   */ startPeriodicCleanup() {\n        if (this.cleanupInterval) return;\n        this.cleanupInterval = setInterval(()=>{\n            this.performPeriodicCleanup();\n        }, this.CLEANUP_INTERVAL_MS);\n        if (this.cleanupInterval.unref) {\n            this.cleanupInterval.unref();\n        }\n    }\n    /**\n   * Perform periodic cleanup of inactive subscriptions\n   */ performPeriodicCleanup() {\n        if (this.isDestroyed) return;\n        const now = Date.now();\n        const toRemove = [];\n        for (const [id, subscription] of this.subscriptions){\n            if (!subscription.isActive || now - subscription.lastAccessTime > this.MAX_INACTIVE_TIME_MS) {\n                toRemove.push(id);\n                continue;\n            }\n            if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n                const listener = subscription.listenerRef.deref();\n                if (!listener) {\n                    toRemove.push(id);\n                    continue;\n                }\n            }\n        }\n        toRemove.forEach((id)=>this.unsubscribe(id));\n    }\n    /**\n   * Subscribe to cache events\n   */ subscribe(listener, options = {}) {\n        if (this.isDestroyed) {\n            throw new Error(\"Cannot subscribe to destroyed event emitter\");\n        }\n        const id = `subscription_${this.nextSubscriptionId++}`;\n        const now = Date.now();\n        const subscription = {\n            id,\n            listener,\n            listenerRef: this.WEAK_REF_ENABLED && options.useWeakRef !== false ? new WeakRef(listener) : void 0,\n            options,\n            isActive: true,\n            createdAt: now,\n            lastAccessTime: now\n        };\n        this.subscriptions.set(id, subscription);\n        return {\n            id,\n            unsubscribe: ()=>this.unsubscribe(id),\n            isActive: ()=>{\n                const sub = this.subscriptions.get(id);\n                if (sub) {\n                    sub.lastAccessTime = Date.now();\n                }\n                return sub?.isActive ?? false;\n            },\n            getOptions: ()=>({\n                    ...options\n                })\n        };\n    }\n    /**\n   * Unsubscribe from events\n   */ unsubscribe(subscriptionId) {\n        const subscription = this.subscriptions.get(subscriptionId);\n        if (!subscription) {\n            return false;\n        }\n        if (subscription.debounceTimer) {\n            clearTimeout(subscription.debounceTimer);\n            subscription.debounceTimer = null;\n        }\n        subscription.isActive = false;\n        this.subscriptions.delete(subscriptionId);\n        return true;\n    }\n    /**\n   * Emit an event to all matching subscriptions\n   */ emit(event) {\n        if (this.isDestroyed) {\n            return;\n        }\n        for (const subscription of this.subscriptions.values()){\n            if (!subscription.isActive) {\n                continue;\n            }\n            if (this.shouldEmitToSubscription(event, subscription)) {\n                this.emitToSubscription(event, subscription);\n            }\n        }\n    }\n    /**\n   * Get count of active subscriptions\n   */ getSubscriptionCount() {\n        return Array.from(this.subscriptions.values()).filter((s)=>s.isActive).length;\n    }\n    /**\n   * Get subscription details (for debugging)\n   */ getSubscriptions() {\n        return Array.from(this.subscriptions.values()).filter((s)=>s.isActive).map((s)=>({\n                id: s.id,\n                options: {\n                    ...s.options\n                }\n            }));\n    }\n    /**\n   * Destroy the event emitter and clean up all subscriptions\n   */ destroy() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n            this.cleanupInterval = null;\n        }\n        for (const subscription of this.subscriptions.values()){\n            if (subscription.debounceTimer) {\n                clearTimeout(subscription.debounceTimer);\n                subscription.debounceTimer = null;\n            }\n            subscription.isActive = false;\n        }\n        this.subscriptions.clear();\n        this.isDestroyed = true;\n    }\n    /**\n   * Check if an event should be emitted to a specific subscription\n   */ shouldEmitToSubscription(event, subscription) {\n        const { options } = subscription;\n        if (options.eventTypes && !options.eventTypes.includes(event.type)) {\n            return false;\n        }\n        if (options.keys && options.keys.length > 0) {\n            if (\"key\" in event) {\n                const eventKeyStr = this.normalizeKey(event.key);\n                const matchesKey = options.keys.some((key)=>this.normalizeKey(key) === eventKeyStr);\n                if (!matchesKey) {\n                    return false;\n                }\n            } else if (\"affectedKeys\" in event) {\n                const eventKeyStrs = event.affectedKeys.map((key)=>this.normalizeKey(key));\n                const hasMatchingKey = options.keys.some((key)=>eventKeyStrs.includes(this.normalizeKey(key)));\n                if (!hasMatchingKey) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        if (options.locations && options.locations.length > 0) {\n            if (\"affectedLocations\" in event && event.affectedLocations) {\n                if (!this.locationsMatch(options.locations, event.affectedLocations)) {\n                    return false;\n                }\n            } else if (\"locations\" in event) {\n                if (!this.locationsMatch(options.locations, event.locations)) {\n                    return false;\n                }\n            } else if (\"key\" in event) {\n                if (!this.keyMatchesLocations(event.key, options.locations)) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        if (options.query) {\n            if (\"query\" in event) {\n                if (!this.queriesMatch(options.query, event.query)) {\n                    return false;\n                }\n            } else {\n                return true;\n            }\n        }\n        return true;\n    }\n    /**\n   * Emit event to a specific subscription, handling debouncing\n   */ emitToSubscription(event, subscription) {\n        subscription.lastAccessTime = Date.now();\n        let listener = subscription.listener;\n        if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n            const weakListener = subscription.listenerRef.deref();\n            if (!weakListener) {\n                subscription.isActive = false;\n                return;\n            }\n            listener = weakListener;\n        }\n        if (!subscription.options.debounceMs) {\n            try {\n                listener(event);\n            } catch (error) {\n                this.handleListenerError(error, event, subscription);\n            }\n            return;\n        }\n        if (subscription.debounceTimer) {\n            clearTimeout(subscription.debounceTimer);\n            subscription.debounceTimer = null;\n        }\n        subscription.debounceTimer = setTimeout(()=>{\n            if (subscription.isActive) {\n                let currentListener = subscription.listener;\n                if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n                    const weakListener = subscription.listenerRef.deref();\n                    if (!weakListener) {\n                        subscription.isActive = false;\n                        subscription.debounceTimer = null;\n                        return;\n                    }\n                    currentListener = weakListener;\n                }\n                try {\n                    currentListener(event);\n                    subscription.lastEmitTime = Date.now();\n                } catch (error) {\n                    this.handleListenerError(error, event, subscription);\n                }\n            }\n            subscription.debounceTimer = null;\n        }, subscription.options.debounceMs);\n    }\n    /**\n   * Normalize a key for comparison\n   */ normalizeKey(key) {\n        return JSON.stringify(key, (k, v)=>{\n            if (typeof v === \"string\" || typeof v === \"number\") {\n                return normalizeKeyValue(v);\n            }\n            return v;\n        });\n    }\n    /**\n   * Normalize a location key for comparison\n   */ normalizeLocKey(key) {\n        return JSON.stringify(key, (k, v)=>{\n            if (typeof v === \"string\" || typeof v === \"number\") {\n                return normalizeKeyValue(v);\n            }\n            return v;\n        });\n    }\n    /**\n   * Check if two location arrays match\n   * Filter locations must be a prefix of event locations (in order)\n   */ locationsMatch(filter, eventLocations) {\n        if (filter.length === 0) {\n            return eventLocations.length === 0;\n        }\n        if (filter.length > eventLocations.length) {\n            return false;\n        }\n        return filter.every((filterLoc, index)=>{\n            const eventLoc = eventLocations[index];\n            return this.normalizeKey(filterLoc) === this.normalizeKey(eventLoc);\n        });\n    }\n    /**\n   * Check if a key matches location filters\n   */ keyMatchesLocations(key, filterLocations) {\n        if (\"loc\" in key && key.loc) {\n            return this.locationsMatch(filterLocations, key.loc);\n        }\n        return filterLocations.length === 0;\n    }\n    /**\n   * Check if two queries match (improved comparison)\n   */ queriesMatch(filterQuery, eventQuery) {\n        const normalize = (obj)=>{\n            if (obj === null || typeof obj === \"undefined\") return obj;\n            if (typeof obj !== \"object\") return obj;\n            if (Array.isArray(obj)) return obj.map(normalize).sort();\n            const sorted = {};\n            Object.keys(obj).sort().forEach((key)=>{\n                sorted[key] = normalize(obj[key]);\n            });\n            return sorted;\n        };\n        return JSON.stringify(normalize(filterQuery)) === JSON.stringify(normalize(eventQuery));\n    }\n    /**\n   * Handle errors that occur in event listeners\n   */ handleListenerError(error, event, subscription) {\n        const errorObj = error instanceof Error ? error : new Error(String(error));\n        if (subscription.options.onError) {\n            try {\n                subscription.options.onError(errorObj, event);\n            } catch (handlerError) {\n                console.error(\"Error in cache event listener:\", errorObj);\n                console.error(\"Error in error handler:\", handlerError);\n            }\n        } else {\n            console.error(\"Error in cache event listener:\", errorObj);\n        }\n    }\n};\n// src/CacheStats.ts\nvar CacheStatsManager = class {\n    /**\n   * Increment the request counter\n   */ incrementRequests() {\n        this.stats.numRequests++;\n    }\n    /**\n   * Increment the cache hit counter\n   */ incrementHits() {\n        this.stats.numHits++;\n    }\n    /**\n   * Increment the cache miss counter\n   */ incrementMisses() {\n        this.stats.numMisses++;\n    }\n    /**\n   * Increment the subscription counter\n   */ incrementSubscriptions() {\n        this.stats.numSubscriptions++;\n        this.stats.activeSubscriptions++;\n    }\n    /**\n   * Increment the unsubscription counter\n   */ incrementUnsubscriptions() {\n        this.stats.numUnsubscriptions++;\n        if (this.stats.activeSubscriptions > 0) {\n            this.stats.activeSubscriptions--;\n        }\n    }\n    /**\n   * Get a copy of the current statistics\n   */ getStats() {\n        return {\n            ...this.stats\n        };\n    }\n    /**\n   * Reset all statistics to zero\n   */ reset() {\n        this.stats = {\n            numRequests: 0,\n            numMisses: 0,\n            numHits: 0,\n            numSubscriptions: 0,\n            numUnsubscriptions: 0,\n            activeSubscriptions: 0\n        };\n    }\n    constructor(){\n        this.stats = {\n            numRequests: 0,\n            numMisses: 0,\n            numHits: 0,\n            numSubscriptions: 0,\n            numUnsubscriptions: 0,\n            activeSubscriptions: 0\n        };\n    }\n};\n// src/Cache.ts\nvar logger23 = logger_default.get(\"Cache\");\nvar createCache = (api, coordinate, registry, options)=>{\n    logger23.debug(\"createCache\", {\n        coordinate,\n        registry,\n        options\n    });\n    const completeOptions = createOptions(options);\n    const cacheMap = createCacheMap(coordinate.kta, completeOptions);\n    const pkType = coordinate.kta[0];\n    const eventEmitter = new CacheEventEmitter();\n    const evictionManager = new EvictionManager();\n    const evictionConfig = completeOptions.evictionConfig;\n    if (!evictionConfig && completeOptions.memoryConfig?.size?.evictionPolicy && (completeOptions.memoryConfig.size.maxItems || completeOptions.memoryConfig.size.maxSizeBytes)) {}\n    if (evictionConfig) {\n        const strategy = createEvictionStrategy(evictionConfig.type || \"lru\", completeOptions.memoryConfig?.maxItems, evictionConfig);\n        evictionManager.setEvictionStrategy(strategy);\n    }\n    const ttlManager = new TTLManager({\n        defaultTTL: completeOptions.ttl,\n        autoCleanup: true,\n        validateOnAccess: true\n    });\n    const statsManager = new CacheStatsManager();\n    const operations = createOperations(api, coordinate, cacheMap, pkType, completeOptions, eventEmitter, ttlManager, evictionManager, statsManager);\n    const cache = {\n        coordinate,\n        registry,\n        api,\n        cacheMap,\n        operations,\n        options: completeOptions,\n        eventEmitter,\n        evictionManager,\n        ttlManager,\n        statsManager,\n        getCacheInfo: ()=>{\n            const evictionStrategyName = evictionManager.getEvictionStrategyName();\n            const cacheInfo = {\n                implementationType: cacheMap.implementationType,\n                defaultTTL: ttlManager.getDefaultTTL(),\n                // Cache supports TTL if the CacheMap supports it OR if TTL is configured\n                supportsTTL: cacheMap.supportsTTL?.() || !!ttlManager.getDefaultTTL(),\n                supportsEviction: evictionManager.isEvictionSupported()\n            };\n            if (evictionStrategyName) {\n                cacheInfo.evictionPolicy = evictionStrategyName;\n            }\n            return cacheInfo;\n        },\n        getStats: ()=>statsManager.getStats(),\n        subscribe: (listener, options2)=>{\n            statsManager.incrementSubscriptions();\n            return eventEmitter.subscribe(listener, options2);\n        },\n        unsubscribe: (subscription)=>{\n            const result = eventEmitter.unsubscribe(subscription.id);\n            if (result) {\n                statsManager.incrementUnsubscriptions();\n            }\n            return result;\n        },\n        destroy: ()=>{\n            eventEmitter.destroy();\n            if (ttlManager && typeof ttlManager.destroy === \"function\") {\n                ttlManager.destroy();\n            }\n            if (cacheMap && typeof cacheMap.destroy === \"function\") {\n                cacheMap.destroy();\n            }\n            CacheEventFactory.destroyInstance();\n        }\n    };\n    return cache;\n};\nvar isCache = (cache)=>{\n    return cache !== null && typeof cache === \"object\" && \"coordinate\" in cache && \"registry\" in cache && \"api\" in cache && \"cacheMap\" in cache && \"operations\" in cache;\n};\n// src/InstanceFactory.ts\nvar logger24 = logger_default.get(\"InstanceFactory\");\nvar createInstanceFactory = (api, options)=>{\n    const templateOptions = createOptions(options);\n    validateOptions(templateOptions);\n    return (coordinate, context)=>{\n        const instanceOptions = createOptions(options);\n        logger24.debug(\"Creating cache instance\", {\n            coordinate,\n            registry: context.registry,\n            api,\n            cacheType: instanceOptions.cacheType,\n            options: instanceOptions\n        });\n        const cacheMap = createCacheMap(coordinate.kta, instanceOptions);\n        const pkType = coordinate.kta[0];\n        const eventEmitter = new CacheEventEmitter();\n        const ttlManager = new TTLManager({\n            defaultTTL: instanceOptions.ttl,\n            autoCleanup: true,\n            validateOnAccess: true\n        });\n        const evictionManager = new EvictionManager();\n        const statsManager = new CacheStatsManager();\n        const operations = createOperations(api, coordinate, cacheMap, pkType, instanceOptions, eventEmitter, ttlManager, evictionManager, statsManager);\n        return {\n            coordinate,\n            registry: context.registry,\n            api,\n            cacheMap,\n            operations,\n            options: instanceOptions,\n            eventEmitter,\n            ttlManager,\n            evictionManager,\n            getCacheInfo: ()=>{\n                const evictionStrategyName = evictionManager.getEvictionStrategyName();\n                const cacheInfo = {\n                    implementationType: cacheMap.implementationType,\n                    defaultTTL: ttlManager.getDefaultTTL(),\n                    supportsTTL: cacheMap.supportsTTL?.() || !!ttlManager.getDefaultTTL(),\n                    supportsEviction: evictionManager.isEvictionSupported()\n                };\n                if (evictionStrategyName) {\n                    cacheInfo.evictionPolicy = evictionStrategyName;\n                }\n                return cacheInfo;\n            },\n            subscribe: (listener, options2)=>eventEmitter.subscribe(listener, options2),\n            unsubscribe: (subscription)=>eventEmitter.unsubscribe(subscription.id),\n            destroy: ()=>{\n                if (typeof ttlManager.destroy === \"function\") {\n                    ttlManager.destroy();\n                }\n                eventEmitter.destroy();\n            }\n        };\n    };\n};\n// src/Instance.ts\nvar logger25 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate, api, options)=>{\n    logger25.debug(\"createInstance\", {\n        coordinate,\n        api,\n        registry,\n        options\n    });\n    return createCache(api, coordinate, registry, options);\n};\nvar isInstance = (instance)=>{\n    return instance !== null && typeof instance === \"object\" && \"coordinate\" in instance && \"registry\" in instance && \"api\" in instance && \"cacheMap\" in instance && \"operations\" in instance;\n};\n// src/Aggregator.ts\nvar logger26 = logger_default.get(\"ItemAggregator\");\nvar toCacheConfig = (config)=>{\n    let cacheConfig;\n    if (config.optional === void 0) {\n        cacheConfig = {\n            cache: config,\n            optional: false\n        };\n    } else {\n        cacheConfig = config;\n    }\n    return cacheConfig;\n};\nvar createAggregator = async (cache, { aggregates = {}, events = {} })=>{\n    const populate = async (item)=>{\n        logger26.default(\"populate\", {\n            item\n        });\n        for(const key in aggregates){\n            await populateAggregate(key, item);\n        }\n        for(const key in events){\n            await populateEvent(key, item);\n        }\n        logger26.default(\"populate done\", {\n            item\n        });\n        return item;\n    };\n    const populateAggregate = async (key, item)=>{\n        logger26.default(\"populate aggregate key\", {\n            key\n        });\n        const cacheConfig = toCacheConfig(aggregates[key]);\n        if (item.refs === void 0) {\n            if (cacheConfig.optional === false) {\n                logger26.error(\"Item does not have refs an is not optional \", {\n                    item\n                });\n                throw new Error(\"Item does not have refs an is not optional \" + JSON.stringify(item));\n            } else {\n                if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n                    delete item.events[key];\n                }\n            }\n        } else if (item.refs[key] === void 0) {\n            if (cacheConfig.optional === false) {\n                logger26.error(\"Item does not have mandatory ref with key, not optional \", {\n                    key,\n                    item\n                });\n                throw new Error(\"Item does not have mandatory ref with key, not optional \" + key + \" \" + JSON.stringify(item));\n            } else {\n                if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n                    delete item.events[key];\n                }\n            }\n        } else {\n            const ref = item.refs[key];\n            logger26.default(\"AGG Retrieving Item in Populate\", {\n                key: ref\n            });\n            const newItem = await cacheConfig.cache.operations.retrieve(ref);\n            if (newItem) {\n                if (item.aggs === void 0) {\n                    item.aggs = {};\n                }\n                item.aggs[key] = {\n                    key: ref,\n                    item: newItem\n                };\n            }\n        }\n    };\n    const populateEvent = async (key, item)=>{\n        logger26.default(\"populate event key\", {\n            key\n        });\n        const cacheConfig = toCacheConfig(events[key]);\n        if (item.events === void 0) {\n            throw new Error(\"Item does not have events \" + JSON.stringify(item));\n        } else if (item.events[key] === void 0) {\n            if (cacheConfig.optional === false) {\n                logger26.error(\"Item does not have mandatory event with key\", {\n                    key,\n                    item\n                });\n                throw new Error(\"Item does not have mandatory event with key \" + key + \" \" + JSON.stringify(item));\n            }\n        } else {\n            const event = item.events[key];\n            if (event.by === void 0) {\n                logger26.error(\"populateEvent with an Event that does not have by\", {\n                    event,\n                    ik: item.key,\n                    eventKey: key\n                });\n                throw new Error(\"populateEvent with an Event that does not have by: \" + JSON.stringify({\n                    key\n                }));\n            }\n            logger26.default(\"EVENT Retrieving Item in Populate\", {\n                key: event.by\n            });\n            const newItem = await cacheConfig.cache.operations.retrieve(event.by);\n            if (newItem) {\n                event.agg = newItem;\n            }\n        }\n    };\n    const all2 = async (query = {}, locations = [])=>{\n        logger26.default(\"all\", {\n            query,\n            locations\n        });\n        const items = await cache.operations.all(query, locations);\n        const populatedItems = await Promise.all(items.map(async (item)=>populate(item)));\n        return populatedItems;\n    };\n    const one2 = async (query = {}, locations = [])=>{\n        logger26.default(\"one\", {\n            query,\n            locations\n        });\n        const item = await cache.operations.one(query, locations);\n        let populatedItem = null;\n        if (item) {\n            populatedItem = await populate(item);\n        }\n        return populatedItem;\n    };\n    const action2 = async (key, action3, body = {})=>{\n        logger26.default(\"action\", {\n            key,\n            action: action3,\n            body\n        });\n        const item = await cache.operations.action(key, action3, body);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const allAction2 = async (action3, body = {}, locations = [])=>{\n        logger26.default(\"action\", {\n            action: action3,\n            body,\n            locations\n        });\n        const items = await cache.operations.allAction(action3, body, locations);\n        const populatedItems = await Promise.all(items.map(async (item)=>populate(item)));\n        return populatedItems;\n    };\n    const allFacet2 = async (facet3, params = {}, locations = [])=>{\n        logger26.default(\"allFacet\", {\n            facet: facet3,\n            params,\n            locations\n        });\n        const response = await cache.operations.allFacet(facet3, params, locations);\n        return response;\n    };\n    const create2 = async (v, locations = [])=>{\n        logger26.default(\"create\", {\n            v,\n            locations\n        });\n        const item = await cache.operations.create(v, locations);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const get2 = async (key)=>{\n        logger26.default(\"get\", {\n            key\n        });\n        const item = await cache.operations.get(key);\n        let populatedItem = null;\n        if (item) {\n            populatedItem = await populate(item);\n        }\n        return populatedItem;\n    };\n    const retrieve2 = async (key)=>{\n        logger26.default(\"retrieve\", {\n            key\n        });\n        const item = await cache.operations.retrieve(key);\n        let populatedItem = null;\n        if (item) {\n            populatedItem = await populate(item);\n        }\n        return populatedItem;\n    };\n    const remove2 = async (key)=>{\n        logger26.default(\"remove\", {\n            key\n        });\n        await cache.operations.remove(key);\n    };\n    const update2 = async (key, v)=>{\n        logger26.default(\"update\", {\n            key,\n            v\n        });\n        const item = await cache.operations.update(key, v);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const facet2 = async (key, facet3)=>{\n        logger26.default(\"facet\", {\n            key,\n            facet: facet3\n        });\n        const response = await cache.operations.facet(key, facet3);\n        return response;\n    };\n    const find2 = async (finder, finderParams = {}, locations = [])=>{\n        logger26.default(\"find\", {\n            finder,\n            finderParams,\n            locations\n        });\n        const items = await cache.operations.find(finder, finderParams, locations);\n        const populatedItems = await Promise.all(items.map(async (item)=>populate(item)));\n        return populatedItems;\n    };\n    const findOne2 = async (finder, finderParams = {}, locations = [])=>{\n        logger26.default(\"find\", {\n            finder,\n            finderParams,\n            locations\n        });\n        const item = await cache.operations.findOne(finder, finderParams, locations);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const set2 = async (key, v)=>{\n        logger26.default(\"set\", {\n            key,\n            v\n        });\n        const item = await cache.operations.set(key, v);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const reset2 = async ()=>{\n        await cache.operations.reset();\n    };\n    return {\n        // Cache properties\n        coordinate: cache.coordinate,\n        registry: cache.registry,\n        api: cache.api,\n        cacheMap: cache.cacheMap,\n        operations: cache.operations,\n        evictionManager: cache.evictionManager,\n        ttlManager: cache.ttlManager,\n        statsManager: cache.statsManager,\n        getStats: cache.getStats.bind(cache),\n        getCacheInfo: cache.getCacheInfo.bind(cache),\n        // Cache operations exposed directly\n        all: all2,\n        one: one2,\n        action: action2,\n        allAction: allAction2,\n        allFacet: allFacet2,\n        create: create2,\n        get: get2,\n        retrieve: retrieve2,\n        remove: remove2,\n        update: update2,\n        facet: facet2,\n        find: find2,\n        findOne: findOne2,\n        reset: reset2,\n        set: set2,\n        // Aggregator-specific operations\n        populate,\n        populateAggregate,\n        populateEvent,\n        // Event system\n        eventEmitter: cache.eventEmitter,\n        subscribe: (listener, options)=>cache.subscribe(listener, options),\n        unsubscribe: (subscription)=>cache.unsubscribe(subscription),\n        destroy: ()=>cache.destroy()\n    };\n};\n// src/Registry.ts\n\nvar logger27 = logger_default.get(\"Registry\");\nvar createRegistryFactory = ()=>{\n    return (type, registryHub)=>{\n        if (type !== \"cache\") {\n            throw new Error(`Cache registry factory can only create 'cache' type registries, got: ${type}`);\n        }\n        logger27.debug(\"Creating cache registry\", {\n            type,\n            registryHub\n        });\n        const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(type, registryHub);\n        return baseRegistry;\n    };\n};\nvar createRegistry = (registryHub)=>{\n    const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(\"cache\", registryHub);\n    return {\n        ...baseRegistry\n    };\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WCxVQUFVLE1BQU07UUFDaEIsWUFBWSxNQUFNO1FBQ2xCLGlCQUFpQixNQUFNO1FBQ3ZCLFlBQVksTUFBTTtRQUNsQixjQUFjLE1BQU07UUFDcEIsVUFBVSxNQUFNLFNBQVMsS0FBSyxLQUFLO1FBQ25DLGNBQWMsTUFBTSxhQUFhLEtBQUssS0FBSztRQUFBO1FBRTNDLEtBQUFaO1FBQ0EsS0FBQUM7UUFDQSxRQUFBVDtRQUNBLFdBQUFVO1FBQ0EsVUFBQUM7UUFDQSxRQUFBQztRQUNBLEtBQUFDO1FBQ0EsVUFBQUM7UUFDQSxRQUFBQztRQUNBLFFBQUFDO1FBQ0EsT0FBQWY7UUFDQSxNQUFBZ0I7UUFDQSxTQUFBQztRQUNBLE9BQUFFO1FBQ0EsS0FBQUQ7UUFBQTtRQUVBO1FBQ0E7UUFDQTtRQUFBO1FBRUEsY0FBYyxNQUFNO1FBQ3BCLFdBQVcsQ0FBQyxVQUFVLFVBQVksTUFBTSxVQUFVLFVBQVUsT0FBTztRQUNuRSxhQUFhLENBQUMsZUFBaUIsTUFBTSxZQUFZLFlBQVk7UUFDN0QsU0FBUyxJQUFNLE1BQU0sUUFBUTtJQUMvQjtBQUNGOztBQzlhTztBQUVQLElBQU10QixXQUFTLGVBQVUsSUFBSSxVQUFVO0FBWWhDLElBQU0sd0JBQXdCO0lBQ25DLE9BQU8sQ0FBQyxNQUFjO1FBQ3BCLElBQUksU0FBUyxTQUFTO1lBQ3BCLE1BQU0sSUFBSSxNQUFNLHdFQUF3RSxJQUFJLEVBQUU7UUFDaEc7UUFFQUEsU0FBTyxNQUFNLDJCQUEyQjtZQUFFO1lBQU07UUFBWSxDQUFDO1FBRTdELE1BQU0sZUFBZSwrREFBa0IsQ0FBQyxNQUFNLFdBQVc7UUFHekQsT0FBTztJQUNUO0FBQ0Y7QUFLTyxJQUFNLGlCQUFpQixDQUFDO0lBQzdCLE1BQU0sZUFBZSwrREFBa0IsQ0FBQyxTQUFTLFdBQVc7SUFFNUQsT0FBTztRQUNMLEdBQUc7SUFDTDtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9DYWNoZUNvbnRleHQudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvYWxsLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvbm9ybWFsaXphdGlvbi50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2ZW50cy9DYWNoZUV2ZW50RmFjdG9yeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9vbmUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy91dGlscy9DYWNoZVNpemUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvY3JlYXRlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2dldC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9yZXRyaWV2ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9yZW1vdmUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvdXBkYXRlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2FjdGlvbi50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9hbGxBY3Rpb24udHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvZmFjZXQudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvYWxsRmFjZXQudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvZmluZC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9maW5kT25lLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL3NldC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL21lbW9yeS9NZW1vcnlDYWNoZU1hcC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0NhY2hlTWFwLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvbWVtb3J5L0VuaGFuY2VkTWVtb3J5Q2FjaGVNYXAudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9icm93c2VyL0xvY2FsU3RvcmFnZUNhY2hlTWFwLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYnJvd3Nlci9TZXNzaW9uU3RvcmFnZUNhY2hlTWFwLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYnJvd3Nlci9JbmRleERCQ2FjaGVNYXAudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9icm93c2VyL0FzeW5jSW5kZXhEQkNhY2hlTWFwLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvT3B0aW9ucy50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9yZXNldC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL09wZXJhdGlvbnMudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ldmljdGlvbi9FdmljdGlvbk1hbmFnZXIudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5Q29uZmlnLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvTFJVRXZpY3Rpb25TdHJhdGVneS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lWYWxpZGF0aW9uLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9MRlVFdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9GSUZPRXZpY3Rpb25TdHJhdGVneS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvTVJVRXZpY3Rpb25TdHJhdGVneS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvUmFuZG9tRXZpY3Rpb25TdHJhdGVneS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvQVJDRXZpY3Rpb25TdHJhdGVneS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvVHdvUXVldWVFdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneUZhY3RvcnkudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy90dGwvVFRMTWFuYWdlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2ZW50cy9DYWNoZUV2ZW50RW1pdHRlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0NhY2hlU3RhdHMudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9DYWNoZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0luc3RhbmNlRmFjdG9yeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0luc3RhbmNlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvQWdncmVnYXRvci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL1JlZ2lzdHJ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZW0gfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCJAZmplbGwvY2xpZW50LWFwaVwiO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tIFwiLi9DYWNoZU1hcFwiO1xuaW1wb3J0IHsgT3B0aW9ucyB9IGZyb20gXCIuL09wdGlvbnNcIjtcbmltcG9ydCB7IENhY2hlRXZlbnRFbWl0dGVyIH0gZnJvbSBcIi4vZXZlbnRzL0NhY2hlRXZlbnRFbWl0dGVyXCI7XG5pbXBvcnQgeyBUVExNYW5hZ2VyIH0gZnJvbSBcIi4vdHRsL1RUTE1hbmFnZXJcIjtcbmltcG9ydCB7IEV2aWN0aW9uTWFuYWdlciB9IGZyb20gXCIuL2V2aWN0aW9uL0V2aWN0aW9uTWFuYWdlclwiO1xuaW1wb3J0IHsgQ2FjaGVTdGF0c01hbmFnZXIgfSBmcm9tIFwiLi9DYWNoZVN0YXRzXCI7XG5cbi8qKlxuICogQ29udGV4dCBvYmplY3QgdGhhdCBjb25zb2xpZGF0ZXMgYWxsIGNhY2hlLXJlbGF0ZWQgcGFyYW1ldGVyc1xuICogcGFzc2VkIHRvIGNhY2hlIG9wZXJhdGlvbnMuIFRoaXMgcHJldmVudHMgY2FjaGUgY29uY2VybnMgZnJvbVxuICogcG9sbHV0aW5nIG9wZXJhdGlvbiBzaWduYXR1cmVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlQ29udGV4dDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiB7XG4gIC8qKiBUaGUgY2xpZW50IEFQSSBmb3IgbWFraW5nIHJlcXVlc3RzICovXG4gIGFwaTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLyoqIFRoZSBjYWNoZSBtYXAgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgY2FjaGVkIGl0ZW1zICovXG4gIGNhY2hlTWFwOiBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKiBUaGUgcHJpbWFyeSBrZXkgdHlwZSAqL1xuICBwa1R5cGU6IFM7XG5cbiAgLyoqIENhY2hlIG9wdGlvbnMgaW5jbHVkaW5nIFRUTCBjb25maWd1cmF0aW9uICovXG4gIG9wdGlvbnM6IE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogRXZlbnQgZW1pdHRlciBmb3IgY2FjaGUgZXZlbnRzICovXG4gIGV2ZW50RW1pdHRlcjogQ2FjaGVFdmVudEVtaXR0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogVFRMIG1hbmFnZXIgZm9yIGhhbmRsaW5nIHRpbWUtdG8tbGl2ZSBpbmRlcGVuZGVudGx5IG9mIHN0b3JhZ2UgKi9cbiAgdHRsTWFuYWdlcjogVFRMTWFuYWdlcjtcblxuICAvKiogRXZpY3Rpb24gbWFuYWdlciBmb3IgaGFuZGxpbmcgY2FjaGUgZXZpY3Rpb24gaW5kZXBlbmRlbnRseSBvZiBzdG9yYWdlICovXG4gIGV2aWN0aW9uTWFuYWdlcjogRXZpY3Rpb25NYW5hZ2VyO1xuXG4gIC8qKiBTdGF0aXN0aWNzIG1hbmFnZXIgZm9yIHRyYWNraW5nIGNhY2hlIG1ldHJpY3MgKi9cbiAgc3RhdHNNYW5hZ2VyOiBDYWNoZVN0YXRzTWFuYWdlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgQ2FjaGVDb250ZXh0IGZyb20gdGhlIGluZGl2aWR1YWwgY2FjaGUtcmVsYXRlZCBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDYWNoZUNvbnRleHQgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgYXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBjYWNoZU1hcDogQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBwa1R5cGU6IFMsXG4gICAgb3B0aW9uczogT3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGV2ZW50RW1pdHRlcjogQ2FjaGVFdmVudEVtaXR0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICB0dGxNYW5hZ2VyOiBUVExNYW5hZ2VyLFxuICAgIGV2aWN0aW9uTWFuYWdlcjogRXZpY3Rpb25NYW5hZ2VyLFxuICAgIHN0YXRzTWFuYWdlcjogQ2FjaGVTdGF0c01hbmFnZXJcbiAgKTogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICByZXR1cm4ge1xuICAgIGFwaSxcbiAgICBjYWNoZU1hcCxcbiAgICBwa1R5cGUsXG4gICAgb3B0aW9ucyxcbiAgICBldmVudEVtaXR0ZXIsXG4gICAgdHRsTWFuYWdlcixcbiAgICBldmljdGlvbk1hbmFnZXIsXG4gICAgc3RhdHNNYW5hZ2VyXG4gIH07XG59O1xuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IE5vdEZvdW5kRXJyb3IgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBjcmVhdGVRdWVyeUhhc2ggfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnYWxsJyk7XG5cbmV4cG9ydCBjb25zdCBhbGwgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSxcbiAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXSxcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWW11dPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgnYWxsJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuXG4gIC8vIEdlbmVyYXRlIHF1ZXJ5IGhhc2ggZm9yIGNhY2hpbmdcbiAgY29uc3QgcXVlcnlIYXNoID0gY3JlYXRlUXVlcnlIYXNoKHBrVHlwZSwgcXVlcnksIGxvY2F0aW9ucyk7XG4gIGxvZ2dlci5kZWJ1ZygnR2VuZXJhdGVkIHF1ZXJ5IGhhc2ggZm9yIGFsbCcsIHsgcXVlcnlIYXNoIH0pO1xuXG4gIC8vIENoZWNrIGlmIHdlIGhhdmUgY2FjaGVkIHF1ZXJ5IHJlc3VsdHNcbiAgY29uc3QgY2FjaGVkSXRlbUtleXMgPSBhd2FpdCBjYWNoZU1hcC5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICBpZiAoY2FjaGVkSXRlbUtleXMpIHtcbiAgICBsb2dnZXIuZGVidWcoJ1VzaW5nIGNhY2hlZCBxdWVyeSByZXN1bHRzJywgeyBjYWNoZWRLZXlDb3VudDogY2FjaGVkSXRlbUtleXMubGVuZ3RoIH0pO1xuXG4gICAgLy8gUmV0cmlldmUgYWxsIGNhY2hlZCBpdGVtcyAtIGlmIGFueSBhcmUgbWlzc2luZywgaW52YWxpZGF0ZSB0aGUgcXVlcnkgY2FjaGVcbiAgICBjb25zdCBjYWNoZWRJdGVtczogVltdID0gW107XG4gICAgbGV0IGFsbEl0ZW1zQXZhaWxhYmxlID0gdHJ1ZTtcblxuICAgIGZvciAoY29uc3QgaXRlbUtleSBvZiBjYWNoZWRJdGVtS2V5cykge1xuICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChpdGVtS2V5KTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNhY2hlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxJdGVtc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsSXRlbXNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhjYWNoZWRJdGVtcywgcGtUeXBlKSBhcyBWW11dO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1NvbWUgY2FjaGVkIGl0ZW1zIG1pc3NpbmcsIGludmFsaWRhdGluZyBxdWVyeSBjYWNoZScpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBubyBjYWNoZWQgcXVlcnkgcmVzdWx0cywgdHJ5IHRvIGZpbmQgaXRlbXMgZGlyZWN0bHkgaW4gY2FjaGUgdXNpbmcgcXVlcnlJblxuICAvLyBUaGlzIGhhbmRsZXMgY2FzZXMgd2hlcmUgaW5kaXZpZHVhbCBpdGVtcyBhcmUgY2FjaGVkIGJ1dCBxdWVyeSByZXN1bHRzIGFyZSBub3QgeWV0IGNhY2hlZFxuICB0cnkge1xuICAgIGNvbnN0IGRpcmVjdENhY2hlZEl0ZW1zID0gYXdhaXQgY2FjaGVNYXAucXVlcnlJbihxdWVyeSwgbG9jYXRpb25zKTtcbiAgICBpZiAoZGlyZWN0Q2FjaGVkSXRlbXMgJiYgZGlyZWN0Q2FjaGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdGb3VuZCBpdGVtcyBkaXJlY3RseSBpbiBjYWNoZSwgc2tpcHBpbmcgQVBJIGNhbGwnLCB7IGl0ZW1Db3VudDogZGlyZWN0Q2FjaGVkSXRlbXMubGVuZ3RoIH0pO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgcXVlcnkgcmVzdWx0IGZvciBmdXR1cmUgdXNlXG4gICAgICBjb25zdCBpdGVtS2V5cyA9IGRpcmVjdENhY2hlZEl0ZW1zLm1hcChpdGVtID0+IGl0ZW0ua2V5KTtcbiAgICAgIGF3YWl0IGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgcXVlcnkgcmVzdWx0IGZyb20gZGlyZWN0IGNhY2hlIGhpdCcsIHsgcXVlcnlIYXNoLCBpdGVtS2V5Q291bnQ6IGl0ZW1LZXlzLmxlbmd0aCB9KTtcblxuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKGRpcmVjdENhY2hlZEl0ZW1zLCBwa1R5cGUpIGFzIFZbXV07XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5kZWJ1ZygnRXJyb3IgcXVlcnlpbmcgY2FjaGUgZGlyZWN0bHksIHByb2NlZWRpbmcgdG8gQVBJJywgeyBlcnJvciB9KTtcbiAgfVxuXG4gIC8vIEZldGNoIGZyb20gQVBJXG4gIGxldCByZXQ6IFZbXSA9IFtdO1xuICB0cnkge1xuICAgIHJldCA9IGF3YWl0IGFwaS5hbGwocXVlcnksIGxvY2F0aW9ucyk7XG5cbiAgICAvLyBTdG9yZSBpbmRpdmlkdWFsIGl0ZW1zIGluIGNhY2hlXG4gICAgZm9yIChjb25zdCB2IG9mIHJldCkge1xuICAgICAgYXdhaXQgY2FjaGVNYXAuc2V0KHYua2V5LCB2KTtcblxuICAgICAgLy8gU2V0IFRUTCBtZXRhZGF0YSBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeSh2LmtleSk7XG4gICAgICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gICAgICAvLyBIYW5kbGUgZXZpY3Rpb24gZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHYsIGNhY2hlTWFwKTtcbiAgICAgIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgICAgIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdG9yZSBxdWVyeSByZXN1bHQgKGl0ZW0ga2V5cykgaW4gcXVlcnkgY2FjaGVcbiAgICBjb25zdCBpdGVtS2V5cyA9IHJldC5tYXAoaXRlbSA9PiBpdGVtLmtleSk7XG4gICAgY2FjaGVNYXAuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cyk7XG4gICAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgcXVlcnkgcmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXlDb3VudDogaXRlbUtleXMubGVuZ3RoIH0pO1xuXG4gICAgLy8gRW1pdCBxdWVyeSBldmVudFxuICAgIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuY3JlYXRlUXVlcnlFdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KHF1ZXJ5LCBsb2NhdGlvbnMsIHJldCk7XG4gICAgY29udGV4dC5ldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG5cbiAgfSBjYXRjaCAoZTogdW5rbm93bikge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikge1xuICAgICAgLy8gSGFuZGxlIG5vdCBmb3VuZCBncmFjZWZ1bGx5IC0gY2FjaGUgZW1wdHkgcmVzdWx0XG4gICAgICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtdKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGVkIGVtcHR5IHF1ZXJ5IHJlc3VsdCBmb3Igbm90IGZvdW5kJywgeyBxdWVyeUhhc2ggfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhyZXQsIHBrVHlwZSkgYXMgVltdXTtcbn07XG4iLCIvLyBOb3JtYWxpemF0aW9uIHV0aWxpdGllcyBmb3IgY2FjaGUga2V5c1xuaW1wb3J0IHsgSXRlbVF1ZXJ5LCBMb2NLZXlBcnJheSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuXG4vLyBOb3JtYWxpemUgYSBrZXkgdmFsdWUgdG8gc3RyaW5nIGZvciBjb25zaXN0ZW50IGNvbXBhcmlzb24gYW5kIGhhc2hpbmdcbmV4cG9ydCBjb25zdCBub3JtYWxpemVLZXlWYWx1ZSA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGRldGVybWluaXN0aWMgSlNPTiBzdHJpbmcgd2l0aCBzb3J0ZWQga2V5c1xuY29uc3QgZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSA9IChvYmo6IGFueSk6IHN0cmluZyA9PiB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gJ1snICsgb2JqLm1hcChkZXRlcm1pbmlzdGljU3RyaW5naWZ5KS5qb2luKCcsJykgKyAnXSc7XG4gIH1cblxuICBjb25zdCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KCk7XG4gIGNvbnN0IGtleVZhbHVlUGFpcnMgPSBzb3J0ZWRLZXlzLm1hcChrZXkgPT4ge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpICsgJzonICsgZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShvYmpba2V5XSk7XG4gIH0pO1xuXG4gIHJldHVybiAneycgKyBrZXlWYWx1ZVBhaXJzLmpvaW4oJywnKSArICd9Jztcbn07XG5cbi8vIE5vcm1hbGl6ZWQgaGFzaCBmdW5jdGlvbiBmb3IgRGljdGlvbmFyeSB0aGF0IGNvbnZlcnRzIHBrL2xrIHZhbHVlcyB0byBzdHJpbmdzXG5leHBvcnQgY29uc3QgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IDxUPigpID0+IHtcbiAgcmV0dXJuIChrZXk6IFQpOiBzdHJpbmcgPT4ge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUga2V5IHdpdGggc3RyaW5nIHZhbHVlc1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBwayB2YWx1ZXNcbiAgICAgIGlmICgncGsnIGluIG5vcm1hbGl6ZWRLZXkgJiYgbm9ybWFsaXplZEtleS5wayAhPT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkS2V5LnBrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5wayk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBsayB2YWx1ZXNcbiAgICAgIGlmICgnbGsnIGluIG5vcm1hbGl6ZWRLZXkgJiYgbm9ybWFsaXplZEtleS5sayAhPT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5sayk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBsb2MgYXJyYXkgbGsgdmFsdWVzXG4gICAgICBpZiAoJ2xvYycgaW4gbm9ybWFsaXplZEtleSAmJiBBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRLZXkubG9jKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxvYyA9IG5vcm1hbGl6ZWRLZXkubG9jLm1hcCgobG9jSXRlbTogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsb2NJdGVtID09PSAnb2JqZWN0JyAmJiBsb2NJdGVtICE9PSBudWxsICYmICdsaycgaW4gbG9jSXRlbSAmJiAobG9jSXRlbSBhcyBhbnkpLmxrICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5sb2NJdGVtLCBsazogbm9ybWFsaXplS2V5VmFsdWUoKGxvY0l0ZW0gYXMgYW55KS5saykgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY0l0ZW07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgZGV0ZXJtaW5pc3RpYyBzdHJpbmdpZnkgdG8gZW5zdXJlIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nXG4gICAgICByZXR1cm4gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShub3JtYWxpemVkS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIH07XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGFuZCBjb21wYXJlIGxvY2F0aW9uIGtleSBhcnJheXNcbmV4cG9ydCBjb25zdCBpc0xvY0tleUFycmF5RXF1YWwgPSAoYTogYW55W10sIGI6IGFueVtdKTogYm9vbGVhbiA9PiB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub3JtYWxpemVkQSA9IG5vcm1hbGl6ZUxvY0tleUl0ZW0oYVtpXSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEIgPSBub3JtYWxpemVMb2NLZXlJdGVtKGJbaV0pO1xuXG4gICAgaWYgKGRldGVybWluaXN0aWNTdHJpbmdpZnkobm9ybWFsaXplZEEpICE9PSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG5vcm1hbGl6ZWRCKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSBhIGxvY2F0aW9uIGtleSBpdGVtXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplTG9jS2V5SXRlbSA9IChpdGVtOiBhbnkpOiBhbnkgPT4ge1xuICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gIT09IG51bGwpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0geyAuLi5pdGVtIH07XG5cbiAgICBpZiAoJ2xrJyBpbiBub3JtYWxpemVkICYmIG5vcm1hbGl6ZWQubGsgIT09IG51bGwpIHtcbiAgICAgIG5vcm1hbGl6ZWQubGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkLmxrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufTtcblxuLy8gUXVlcnkgcmVzdWx0IGNhY2hlIHV0aWxpdGllc1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3Igc3RvcmluZyBxdWVyeSByZXN1bHRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlDYWNoZUVudHJ5IHtcbiAgaXRlbUtleXM6IChhbnkpW107XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzYWZlIGhhc2ggZm9yIGFsbC9vbmUgcXVlcnkgcGFyYW1ldGVyc1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUXVlcnlIYXNoID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIHBrVHlwZTogUyxcbiAgICBxdWVyeTogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IHN0cmluZyA9PiB7XG4gIC8vIE5vcm1hbGl6ZSB0aGUgcXVlcnkgb2JqZWN0IGZvciBjb25zaXN0ZW50IG9yZGVyaW5nXG4gIGNvbnN0IG5vcm1hbGl6ZWRRdWVyeSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocXVlcnkgfHwge30pKTtcblxuICAvLyBTb3J0IGtleXMgdG8gZW5zdXJlIGNvbnNpc3RlbnQgaGFzaFxuICBjb25zdCBzb3J0ZWRRdWVyeUtleXMgPSBPYmplY3Qua2V5cyhub3JtYWxpemVkUXVlcnkpLnNvcnQoKTtcbiAgY29uc3Qgc29ydGVkUXVlcnk6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgc29ydGVkUXVlcnlLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICBzb3J0ZWRRdWVyeVtrZXldID0gbm9ybWFsaXplZFF1ZXJ5W2tleV07XG4gIH0pO1xuXG4gIC8vIE5vcm1hbGl6ZSBsb2NhdGlvbnMgdXNpbmcgZXhpc3RpbmcgdXRpbGl0eSAtIGVuc3VyZSBsb2NhdGlvbnMgaXMgYW4gYXJyYXlcbiAgY29uc3QgbG9jYXRpb25zQXJyYXkgPSBBcnJheS5pc0FycmF5KGxvY2F0aW9ucykgPyBsb2NhdGlvbnMgOiBbXTtcbiAgY29uc3Qgbm9ybWFsaXplZExvY2F0aW9ucyA9IGxvY2F0aW9uc0FycmF5Lm1hcChub3JtYWxpemVMb2NLZXlJdGVtKTtcblxuICAvLyBDcmVhdGUgdGhlIGhhc2ggaW5wdXQgb2JqZWN0XG4gIGNvbnN0IGhhc2hJbnB1dCA9IHtcbiAgICB0eXBlOiAncXVlcnknLFxuICAgIHBrVHlwZSxcbiAgICBxdWVyeTogc29ydGVkUXVlcnksXG4gICAgbG9jYXRpb25zOiBub3JtYWxpemVkTG9jYXRpb25zXG4gIH07XG5cbiAgcmV0dXJuIGRldGVybWluaXN0aWNTdHJpbmdpZnkoaGFzaElucHV0KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzYWZlIGhhc2ggZm9yIGZpbmQvZmluZE9uZSBxdWVyeSBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVGaW5kZXJIYXNoID0gPFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IHN0cmluZyA9PiB7XG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGFyYW1zIG9iamVjdCBmb3IgY29uc2lzdGVudCBvcmRlcmluZ1xuICBjb25zdCBub3JtYWxpemVkUGFyYW1zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXJhbXMgfHwge30pKTtcblxuICAvLyBTb3J0IGtleXMgdG8gZW5zdXJlIGNvbnNpc3RlbnQgaGFzaFxuICBjb25zdCBzb3J0ZWRQYXJhbUtleXMgPSBPYmplY3Qua2V5cyhub3JtYWxpemVkUGFyYW1zKS5zb3J0KCk7XG4gIGNvbnN0IHNvcnRlZFBhcmFtczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICBzb3J0ZWRQYXJhbUtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgIHNvcnRlZFBhcmFtc1trZXldID0gbm9ybWFsaXplZFBhcmFtc1trZXldO1xuICB9KTtcblxuICAvLyBOb3JtYWxpemUgbG9jYXRpb25zIHVzaW5nIGV4aXN0aW5nIHV0aWxpdHkgLSBlbnN1cmUgbG9jYXRpb25zIGlzIGFuIGFycmF5XG4gIGNvbnN0IGxvY2F0aW9uc0FycmF5ID0gQXJyYXkuaXNBcnJheShsb2NhdGlvbnMpID8gbG9jYXRpb25zIDogW107XG4gIGNvbnN0IG5vcm1hbGl6ZWRMb2NhdGlvbnMgPSBsb2NhdGlvbnNBcnJheS5tYXAobm9ybWFsaXplTG9jS2V5SXRlbSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBoYXNoIGlucHV0IG9iamVjdFxuICBjb25zdCBoYXNoSW5wdXQgPSB7XG4gICAgdHlwZTogJ2ZpbmRlcicsXG4gICAgZmluZGVyLFxuICAgIHBhcmFtczogc29ydGVkUGFyYW1zLFxuICAgIGxvY2F0aW9uczogbm9ybWFsaXplZExvY2F0aW9uc1xuICB9O1xuXG4gIHJldHVybiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KGhhc2hJbnB1dCk7XG59O1xuIiwiXG5pbXBvcnQgeyBDb21LZXksIEl0ZW0sIEl0ZW1RdWVyeSwgTG9jS2V5QXJyYXksIFByaUtleSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHtcbiAgQ2FjaGVDbGVhcmVkRXZlbnQsXG4gIEl0ZW1FdmVudCxcbiAgTG9jYXRpb25JbnZhbGlkYXRlZEV2ZW50LFxuICBRdWVyeUV2ZW50LFxuICBRdWVyeUludmFsaWRhdGVkRXZlbnRcbn0gZnJvbSBcIi4vQ2FjaGVFdmVudFR5cGVzXCI7XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbnMgZm9yIGNyZWF0aW5nIGNhY2hlIGV2ZW50c1xuICovXG5leHBvcnQgY2xhc3MgQ2FjaGVFdmVudEZhY3Rvcnkge1xuICBwcml2YXRlIHN0YXRpYyBsYXN0VGltZXN0YW1wID0gMDtcbiAgcHJpdmF0ZSBzdGF0aWMgY2xlYW51cEludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZUNvdW50ID0gMDtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ0xFQU5VUF9JTlRFUlZBTF9NUyA9IDYwMDAwOyAvLyAxIG1pbnV0ZVxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBNQVhfVElNRVNUQU1QX0FHRV9NUyA9IDMwMDAwMDsgLy8gNSBtaW51dGVzXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgY2xlYW51cCBtZWNoYW5pc20gd2hlbiBmaXJzdCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBpbml0aWFsaXplQ2xlYW51cCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwgPT09IG51bGwgJiYgdGhpcy5pbnN0YW5jZUNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXJ0Q2xlYW51cFRpbWVyKCk7XG4gICAgfVxuICAgIHRoaXMuaW5zdGFuY2VDb3VudCsrO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFudXAgbWVjaGFuaXNtIHdoZW4gaW5zdGFuY2UgaXMgZGVzdHJveWVkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRlc3Ryb3lJbnN0YW5jZSgpOiB2b2lkIHtcbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBNYXRoLm1heCgwLCB0aGlzLmluc3RhbmNlQ291bnQgLSAxKTtcbiAgICBpZiAodGhpcy5pbnN0YW5jZUNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnN0b3BDbGVhbnVwVGltZXIoKTtcbiAgICAgIHRoaXMucmVzZXRUaW1lc3RhbXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYXV0b21hdGljIGNsZWFudXAgdGltZXJcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHN0YXJ0Q2xlYW51cFRpbWVyKCk6IHZvaWQge1xuICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5wZXJmb3JtQ2xlYW51cCgpO1xuICAgIH0sIHRoaXMuQ0xFQU5VUF9JTlRFUlZBTF9NUyk7XG5cbiAgICAvLyBEb24ndCBrZWVwIHRoZSBwcm9jZXNzIGFsaXZlIGp1c3QgZm9yIGNsZWFudXBcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwudW5yZWYpIHtcbiAgICAgIHRoaXMuY2xlYW51cEludGVydmFsLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYXV0b21hdGljIGNsZWFudXAgdGltZXJcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHN0b3BDbGVhbnVwVGltZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cEludGVydmFsKTtcbiAgICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBwZXJpb2RpYyBjbGVhbnVwIG9mIHN0YWxlIHRpbWVzdGFtcCBzdGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgcGVyZm9ybUNsZWFudXAoKTogdm9pZCB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAvLyBSZXNldCB0aW1lc3RhbXAgaWYgaXQncyB0b28gb2xkIHRvIHByZXZlbnQgbWVtb3J5IGlzc3Vlc1xuICAgIGlmIChub3cgLSB0aGlzLmxhc3RUaW1lc3RhbXAgPiB0aGlzLk1BWF9USU1FU1RBTVBfQUdFX01TKSB7XG4gICAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGltZXN0YW1wIHN0YXRlICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlc2V0VGltZXN0YW1wKCk6IHZvaWQge1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUgdGltZXN0YW1wIHRoYXQgaXMgYWx3YXlzIGdyZWF0ZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVRpbWVzdGFtcCgpOiBudW1iZXIge1xuICAgIHRoaXMuaW5pdGlhbGl6ZUNsZWFudXAoKTtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgLy8gSWYgY3VycmVudCB0aW1lIGlzIGdyZWF0ZXIgdGhhbiBsYXN0IHRpbWVzdGFtcCwgdXNlIGN1cnJlbnQgdGltZVxuICAgIC8vIE90aGVyd2lzZSwgaW5jcmVtZW50IGxhc3QgdGltZXN0YW1wIHRvIGVuc3VyZSB1bmlxdWVuZXNzXG4gICAgaWYgKG5vdyA+IHRoaXMubGFzdFRpbWVzdGFtcCkge1xuICAgICAgdGhpcy5sYXN0VGltZXN0YW1wID0gbm93O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSB0aGlzLmxhc3RUaW1lc3RhbXAgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sYXN0VGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgYWZmZWN0ZWQgbG9jYXRpb25zIGZyb20gYW4gaXRlbSBrZXlcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGV4dHJhY3RBZmZlY3RlZExvY2F0aW9uczxcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10ge1xuICAgIGlmICgnbG9jJyBpbiBrZXkgJiYga2V5LmxvYykge1xuICAgICAgcmV0dXJuIGtleS5sb2M7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbS1yZWxhdGVkIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUl0ZW1FdmVudDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4oXG4gICAgdHlwZTogJ2l0ZW1fY3JlYXRlZCcgfCAnaXRlbV91cGRhdGVkJyB8ICdpdGVtX3JlbW92ZWQnIHwgJ2l0ZW1fcmV0cmlldmVkJyB8ICdpdGVtX3NldCcsXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBWIHwgbnVsbCxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwcmV2aW91c0l0ZW0/OiBWIHwgbnVsbCB8IG51bGw7XG4gICAgICBzb3VyY2U/OiAnYXBpJyB8ICdjYWNoZScgfCAnb3BlcmF0aW9uJztcbiAgICAgIGFmZmVjdGVkTG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdO1xuICAgICAgY29udGV4dD86IHtcbiAgICAgICAgb3BlcmF0aW9uPzogc3RyaW5nO1xuICAgICAgICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gICAgICAgIHVzZXJJZD86IHN0cmluZztcbiAgICAgIH07XG4gICAgfSA9IHt9XG4gICk6IEl0ZW1FdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcbiAgICAvLyBBdXRvLWNhbGN1bGF0ZSBhZmZlY3RlZCBsb2NhdGlvbnMgaWYgbm90IHByb3ZpZGVkXG4gICAgY29uc3QgYWZmZWN0ZWRMb2NhdGlvbnMgPSBvcHRpb25zLmFmZmVjdGVkTG9jYXRpb25zICE9PSB1bmRlZmluZWRcbiAgICAgID8gb3B0aW9ucy5hZmZlY3RlZExvY2F0aW9uc1xuICAgICAgOiB0aGlzLmV4dHJhY3RBZmZlY3RlZExvY2F0aW9ucyhrZXkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgJ29wZXJhdGlvbicsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBrZXksXG4gICAgICBpdGVtLFxuICAgICAgcHJldmlvdXNJdGVtOiBvcHRpb25zLnByZXZpb3VzSXRlbSxcbiAgICAgIGFmZmVjdGVkTG9jYXRpb25zXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBxdWVyeSBldmVudFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVRdWVyeUV2ZW50PFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihcbiAgICBxdWVyeTogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdLFxuICAgIGl0ZW1zOiBWW10sXG4gICAgb3B0aW9uczoge1xuICAgICAgc291cmNlPzogJ2FwaScgfCAnY2FjaGUnIHwgJ29wZXJhdGlvbic7XG4gICAgICBjb250ZXh0Pzoge1xuICAgICAgICBvcGVyYXRpb24/OiBzdHJpbmc7XG4gICAgICAgIHJlcXVlc3RJZD86IHN0cmluZztcbiAgICAgICAgdXNlcklkPzogc3RyaW5nO1xuICAgICAgfTtcbiAgICB9ID0ge31cbiAgKTogUXVlcnlFdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcbiAgICBjb25zdCBhZmZlY3RlZEtleXMgPSBpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmtleSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2l0ZW1zX3F1ZXJpZWQnLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLmdlbmVyYXRlVGltZXN0YW1wKCksXG4gICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlIHx8ICdvcGVyYXRpb24nLFxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgcXVlcnksXG4gICAgICBsb2NhdGlvbnMsXG4gICAgICBpdGVtcyxcbiAgICAgIGFmZmVjdGVkS2V5c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2FjaGUgY2xlYXJlZCBldmVudFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDYWNoZUNsZWFyZWRFdmVudChcbiAgICBpdGVtc0NsZWFyZWQ6IG51bWJlcixcbiAgICBxdWVyeUNhY2hlQ2xlYXJlZDogYm9vbGVhbiA9IHRydWUsXG4gICAgb3B0aW9uczoge1xuICAgICAgc291cmNlPzogJ2FwaScgfCAnY2FjaGUnIHwgJ29wZXJhdGlvbic7XG4gICAgICBjb250ZXh0Pzoge1xuICAgICAgICBvcGVyYXRpb24/OiBzdHJpbmc7XG4gICAgICAgIHJlcXVlc3RJZD86IHN0cmluZztcbiAgICAgICAgdXNlcklkPzogc3RyaW5nO1xuICAgICAgfTtcbiAgICB9ID0ge31cbiAgKTogQ2FjaGVDbGVhcmVkRXZlbnQge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnY2FjaGVfY2xlYXJlZCcsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgJ29wZXJhdGlvbicsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBpdGVtc0NsZWFyZWQsXG4gICAgICBxdWVyeUNhY2hlQ2xlYXJlZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbG9jYXRpb24gaW52YWxpZGF0ZWQgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlTG9jYXRpb25JbnZhbGlkYXRlZEV2ZW50PFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4oXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10sXG4gICAgYWZmZWN0ZWRLZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10sXG4gICAgb3B0aW9uczoge1xuICAgICAgc291cmNlPzogJ2FwaScgfCAnY2FjaGUnIHwgJ29wZXJhdGlvbic7XG4gICAgICBjb250ZXh0Pzoge1xuICAgICAgICBvcGVyYXRpb24/OiBzdHJpbmc7XG4gICAgICAgIHJlcXVlc3RJZD86IHN0cmluZztcbiAgICAgICAgdXNlcklkPzogc3RyaW5nO1xuICAgICAgfTtcbiAgICB9ID0ge31cbiAgKTogTG9jYXRpb25JbnZhbGlkYXRlZEV2ZW50PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbG9jYXRpb25faW52YWxpZGF0ZWQnLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLmdlbmVyYXRlVGltZXN0YW1wKCksXG4gICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlIHx8ICdvcGVyYXRpb24nLFxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgbG9jYXRpb25zLFxuICAgICAgYWZmZWN0ZWRLZXlzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBxdWVyeSBpbnZhbGlkYXRlZCBldmVudFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVRdWVyeUludmFsaWRhdGVkRXZlbnQoXG4gICAgaW52YWxpZGF0ZWRRdWVyaWVzOiBzdHJpbmdbXSxcbiAgICByZWFzb246ICdtYW51YWwnIHwgJ2l0ZW1fY2hhbmdlZCcgfCAnbG9jYXRpb25fY2hhbmdlZCcgfCAndHRsX2V4cGlyZWQnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHNvdXJjZT86ICdhcGknIHwgJ2NhY2hlJyB8ICdvcGVyYXRpb24nO1xuICAgICAgY29udGV4dD86IHtcbiAgICAgICAgb3BlcmF0aW9uPzogc3RyaW5nO1xuICAgICAgICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gICAgICAgIHVzZXJJZD86IHN0cmluZztcbiAgICAgIH07XG4gICAgfSA9IHt9XG4gICk6IFF1ZXJ5SW52YWxpZGF0ZWRFdmVudCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdxdWVyeV9pbnZhbGlkYXRlZCcsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgJ29wZXJhdGlvbicsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBpbnZhbGlkYXRlZFF1ZXJpZXMsXG4gICAgICByZWFzb25cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtIGNyZWF0ZWQgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXRlbUNyZWF0ZWQ8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogVixcbiAgICBzb3VyY2U6ICdhcGknIHwgJ2NhY2hlJyB8ICdvcGVyYXRpb24nID0gJ2FwaSdcbiAgKTogSXRlbUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUl0ZW1FdmVudCgnaXRlbV9jcmVhdGVkJywga2V5LCBpdGVtLCB7IHNvdXJjZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbSB1cGRhdGVkIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGl0ZW1VcGRhdGVkPFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IFYsXG4gICAgcHJldmlvdXNJdGVtPzogViB8IG51bGwsXG4gICAgc291cmNlOiAnYXBpJyB8ICdjYWNoZScgfCAnb3BlcmF0aW9uJyA9ICdhcGknXG4gICk6IEl0ZW1FdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJdGVtRXZlbnQoJ2l0ZW1fdXBkYXRlZCcsIGtleSwgaXRlbSwgeyBwcmV2aW91c0l0ZW0sIHNvdXJjZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbSByZW1vdmVkIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGl0ZW1SZW1vdmVkPFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIHByZXZpb3VzSXRlbT86IFYgfCBudWxsLFxuICAgIHNvdXJjZTogJ2FwaScgfCAnY2FjaGUnIHwgJ29wZXJhdGlvbicgPSAnYXBpJ1xuICApOiBJdGVtRXZlbnQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlSXRlbUV2ZW50KCdpdGVtX3JlbW92ZWQnLCBrZXksIG51bGwsIHsgcHJldmlvdXNJdGVtLCBzb3VyY2UgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0gcmV0cmlldmVkIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGl0ZW1SZXRyaWV2ZWQ8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogVixcbiAgICBzb3VyY2U6ICdhcGknIHwgJ2NhY2hlJyB8ICdvcGVyYXRpb24nID0gJ2FwaSdcbiAgKTogSXRlbUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUl0ZW1FdmVudCgnaXRlbV9yZXRyaWV2ZWQnLCBrZXksIGl0ZW0sIHsgc291cmNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtIHNldCBldmVudCAoZGlyZWN0IGNhY2hlIG9wZXJhdGlvbilcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXRlbVNldDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4oXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBWLFxuICAgIHByZXZpb3VzSXRlbT86IFYgfCBudWxsXG4gICk6IEl0ZW1FdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJdGVtRXZlbnQoJ2l0ZW1fc2V0Jywga2V5LCBpdGVtLCB7XG4gICAgICBwcmV2aW91c0l0ZW0sXG4gICAgICBzb3VyY2U6ICdjYWNoZSdcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IExvZ2dpbmcgZnJvbSAnQGZqZWxsL2xvZ2dpbmcnO1xuXG5jb25zdCBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcignQGZqZWxsL2NhY2hlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IExpYkxvZ2dlcjtcbiIsImltcG9ydCB7XG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBOb3RGb3VuZEVycm9yIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuaW1wb3J0IHsgQ2FjaGVDb250ZXh0IH0gZnJvbSBcIi4uL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IHsgY3JlYXRlUXVlcnlIYXNoIH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IGVzdGltYXRlVmFsdWVTaXplIH0gZnJvbSBcIi4uL3V0aWxzL0NhY2hlU2l6ZVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ29uZScpO1xuXG5leHBvcnQgY29uc3Qgb25lID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBxdWVyeTogSXRlbVF1ZXJ5ID0ge30sXG4gIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW10sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgViB8IG51bGxdPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgnb25lJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuXG4gIC8vIEdlbmVyYXRlIHF1ZXJ5IGhhc2ggZm9yIGNhY2hpbmdcbiAgY29uc3QgcXVlcnlIYXNoID0gY3JlYXRlUXVlcnlIYXNoKHBrVHlwZSwgcXVlcnksIGxvY2F0aW9ucyk7XG4gIGxvZ2dlci5kZWJ1ZygnR2VuZXJhdGVkIHF1ZXJ5IGhhc2ggZm9yIG9uZScsIHsgcXVlcnlIYXNoIH0pO1xuXG4gIC8vIENoZWNrIGlmIHdlIGhhdmUgY2FjaGVkIHF1ZXJ5IHJlc3VsdHNcbiAgY29uc3QgY2FjaGVkSXRlbUtleXMgPSBhd2FpdCBjYWNoZU1hcC5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICBpZiAoY2FjaGVkSXRlbUtleXMpIHtcbiAgICBsb2dnZXIuZGVidWcoJ1VzaW5nIGNhY2hlZCBxdWVyeSByZXN1bHRzJywgeyBjYWNoZWRLZXlDb3VudDogY2FjaGVkSXRlbUtleXMubGVuZ3RoIH0pO1xuXG4gICAgaWYgKGNhY2hlZEl0ZW1LZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQ2FjaGVkIGVtcHR5IHJlc3VsdCAobm90IGZvdW5kKVxuICAgICAgcmV0dXJuIFtjb250ZXh0LCBudWxsXTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZSB0aGUgZmlyc3QgY2FjaGVkIGl0ZW0gLSBpZiBtaXNzaW5nLCBpbnZhbGlkYXRlIHRoZSBxdWVyeSBjYWNoZVxuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoY2FjaGVkSXRlbUtleXNbMF0pO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsoaXRlbSwgcGtUeXBlKSBhcyBWXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgaXRlbSBtaXNzaW5nLCBpbnZhbGlkYXRpbmcgcXVlcnkgY2FjaGUnKTtcbiAgICAgIGNhY2hlTWFwLmRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJldEl0ZW06IFYgfCBudWxsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXRJdGVtID0gYXdhaXQgYXBpLm9uZShxdWVyeSwgbG9jYXRpb25zKTtcbiAgICBpZiAocmV0SXRlbSkge1xuICAgICAgLy8gU3RvcmUgaW5kaXZpZHVhbCBpdGVtIGluIGNhY2hlXG4gICAgICBhd2FpdCBjYWNoZU1hcC5zZXQocmV0SXRlbS5rZXksIHJldEl0ZW0pO1xuXG4gICAgICAvLyBDcmVhdGUgYmFzZSBtZXRhZGF0YSBpZiBpdCBkb2Vzbid0IGV4aXN0IChuZWVkZWQgZm9yIFRUTCBhbmQgZXZpY3Rpb24pXG4gICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShyZXRJdGVtLmtleSk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhY2hlTWFwLmdldE1ldGFkYXRhKGtleVN0cik7XG4gICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGJhc2VNZXRhZGF0YSA9IHtcbiAgICAgICAgICBrZXk6IGtleVN0cixcbiAgICAgICAgICBhZGRlZEF0OiBub3csXG4gICAgICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgICAgICBlc3RpbWF0ZWRTaXplOiBlc3RpbWF0ZVZhbHVlU2l6ZShyZXRJdGVtKVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBjYWNoZU1hcC5zZXRNZXRhZGF0YShrZXlTdHIsIGJhc2VNZXRhZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBUVEwgbWV0YWRhdGEgZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgICAgYXdhaXQgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcblxuICAgICAgLy8gSGFuZGxlIGV2aWN0aW9uIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gYXdhaXQgY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCByZXRJdGVtLCBjYWNoZU1hcCk7XG4gICAgICAvLyBSZW1vdmUgZXZpY3RlZCBpdGVtcyBmcm9tIGNhY2hlXG4gICAgICBmb3IgKGNvbnN0IGV2aWN0ZWRLZXkgb2YgZXZpY3RlZEtleXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgICAgYXdhaXQgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHF1ZXJ5IHJlc3VsdCAoc2luZ2xlIGl0ZW0ga2V5KSBpbiBxdWVyeSBjYWNoZVxuICAgICAgYXdhaXQgY2FjaGVNYXAuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBbcmV0SXRlbS5rZXldKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGVkIHF1ZXJ5IHJlc3VsdCcsIHsgcXVlcnlIYXNoLCBpdGVtS2V5OiByZXRJdGVtLmtleSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RvcmUgZW1wdHkgcmVzdWx0IGluIHF1ZXJ5IGNhY2hlXG4gICAgICBhd2FpdCBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtdKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGVkIGVtcHR5IHF1ZXJ5IHJlc3VsdCcsIHsgcXVlcnlIYXNoIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZTogdW5rbm93bikge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikge1xuICAgICAgLy8gSGFuZGxlIG5vdCBmb3VuZCBncmFjZWZ1bGx5IC0gY2FjaGUgZW1wdHkgcmVzdWx0XG4gICAgICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtdKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGVkIGVtcHR5IHF1ZXJ5IHJlc3VsdCBmb3Igbm90IGZvdW5kJywgeyBxdWVyeUhhc2ggfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBbXG4gICAgY29udGV4dCxcbiAgICByZXRJdGVtID9cbiAgICAgIHZhbGlkYXRlUEsocmV0SXRlbSwgcGtUeXBlKSBhcyBWIDpcbiAgICAgIG51bGxcbiAgXTtcbn07XG4iLCIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBwYXJzaW5nIGFuZCBtYW5hZ2luZyBjYWNoZSBzaXplc1xuICovXG5cbi8qKlxuICogU2l6ZSB1bml0IG11bHRpcGxpZXJzIChkZWNpbWFsIGFuZCBiaW5hcnkpXG4gKi9cbmNvbnN0IFNJWkVfVU5JVFM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gIC8vIERlY2ltYWwgdW5pdHMgKHBvd2VycyBvZiAxMDAwKVxuICAnYic6IDEsXG4gICdieXRlJzogMSxcbiAgJ2J5dGVzJzogMSxcbiAgJ2tiJzogMTAwMCxcbiAgJ2tpbG9ieXRlJzogMTAwMCxcbiAgJ2tpbG9ieXRlcyc6IDEwMDAsXG4gICdtYic6IDEwMDAgKiAxMDAwLFxuICAnbWVnYWJ5dGUnOiAxMDAwICogMTAwMCxcbiAgJ21lZ2FieXRlcyc6IDEwMDAgKiAxMDAwLFxuICAnZ2InOiAxMDAwICogMTAwMCAqIDEwMDAsXG4gICdnaWdhYnl0ZSc6IDEwMDAgKiAxMDAwICogMTAwMCxcbiAgJ2dpZ2FieXRlcyc6IDEwMDAgKiAxMDAwICogMTAwMCxcbiAgJ3RiJzogMTAwMCAqIDEwMDAgKiAxMDAwICogMTAwMCxcbiAgJ3RlcmFieXRlJzogMTAwMCAqIDEwMDAgKiAxMDAwICogMTAwMCxcbiAgJ3RlcmFieXRlcyc6IDEwMDAgKiAxMDAwICogMTAwMCAqIDEwMDAsXG5cbiAgLy8gQmluYXJ5IHVuaXRzIChwb3dlcnMgb2YgMTAyNClcbiAgJ2tpYic6IDEwMjQsXG4gICdraWJpYnl0ZSc6IDEwMjQsXG4gICdraWJpYnl0ZXMnOiAxMDI0LFxuICAnbWliJzogMTAyNCAqIDEwMjQsXG4gICdtZWJpYnl0ZSc6IDEwMjQgKiAxMDI0LFxuICAnbWViaWJ5dGVzJzogMTAyNCAqIDEwMjQsXG4gICdnaWInOiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gICdnaWJpYnl0ZSc6IDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgJ2dpYmlieXRlcyc6IDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgJ3RpYic6IDEwMjQgKiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gICd0ZWJpYnl0ZSc6IDEwMjQgKiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gICd0ZWJpYnl0ZXMnOiAxMDI0ICogMTAyNCAqIDEwMjQgKiAxMDI0LFxufTtcblxuLyoqXG4gKiBQYXJzZSBhIHNpemUgc3RyaW5nIGFuZCByZXR1cm4gdGhlIHNpemUgaW4gYnl0ZXNcbiAqXG4gKiBAcGFyYW0gc2l6ZVN0ciAtIFNpemUgc3RyaW5nIChlLmcuLCAnMzAwJywgJzNrYicsICc1TUInLCAnMkdpQicpXG4gKiBAcmV0dXJucyBTaXplIGluIGJ5dGVzXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBzaXplIHN0cmluZyBpcyBpbnZhbGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNpemVTdHJpbmcoc2l6ZVN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKCFzaXplU3RyIHx8IHR5cGVvZiBzaXplU3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBzdHJpbmcgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgfVxuXG4gIGNvbnN0IHRyaW1tZWQgPSBzaXplU3RyLnRyaW0oKTtcblxuICAvLyBIYW5kbGUgcHVyZSBudW1lcmljIHZhbHVlcyAoYXNzdW1lIGJ5dGVzKVxuICBpZiAoL15cXGQrKFxcLlxcZCspPyQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICBjb25zdCBieXRlcyA9IHBhcnNlRmxvYXQodHJpbW1lZCk7XG4gICAgaWYgKGlzTmFOKGJ5dGVzKSB8fCBieXRlcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaXplIHZhbHVlOiAke3NpemVTdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKGJ5dGVzKTtcbiAgfVxuXG4gIC8vIFBhcnNlIHdpdGggdW5pdFxuICBjb25zdCBtYXRjaCA9IHRyaW1tZWQubWF0Y2goL14oXFxkKyg/OlxcLlxcZCspPylcXHMqKFthLXpBLVpdKykkLyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2l6ZSBmb3JtYXQ6ICR7c2l6ZVN0cn0uIEV4cGVjdGVkIGZvcm1hdDogJzEwMCcsICc1S0InLCAnMTBNQicsIGV0Yy5gKTtcbiAgfVxuXG4gIGNvbnN0IFssIHZhbHVlU3RyLCB1bml0U3RyXSA9IG1hdGNoO1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWVTdHIpO1xuICBjb25zdCB1bml0ID0gdW5pdFN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemUgdmFsdWU6ICR7dmFsdWVTdHJ9YCk7XG4gIH1cblxuICBjb25zdCBtdWx0aXBsaWVyID0gU0laRV9VTklUU1t1bml0XTtcbiAgaWYgKCEodW5pdCBpbiBTSVpFX1VOSVRTKSkge1xuICAgIGNvbnN0IHN1cHBvcnRlZFVuaXRzID0gT2JqZWN0LmtleXMoU0laRV9VTklUUykuZmlsdGVyKHUgPT4gdS5sZW5ndGggPD0gMykuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNpemUgdW5pdDogJHt1bml0U3RyfS4gU3VwcG9ydGVkIHVuaXRzOiAke3N1cHBvcnRlZFVuaXRzfWApO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKiBtdWx0aXBsaWVyKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYnl0ZXMgYXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBTaXplIGluIGJ5dGVzXG4gKiBAcGFyYW0gYmluYXJ5IC0gVXNlIGJpbmFyeSB1bml0cyAoMTAyNCkgaW5zdGVhZCBvZiBkZWNpbWFsICgxMDAwKVxuICogQHJldHVybnMgRm9ybWF0dGVkIHNpemUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlczogbnVtYmVyLCBiaW5hcnk6IGJvb2xlYW4gPSBmYWxzZSk6IHN0cmluZyB7XG4gIGlmIChieXRlcyA9PT0gMCkgcmV0dXJuICcwIEInO1xuICBpZiAoYnl0ZXMgPCAwKSByZXR1cm4gYCR7Ynl0ZXN9IEJgO1xuXG4gIGNvbnN0IGsgPSBiaW5hcnkgPyAxMDI0IDogMTAwMDtcbiAgY29uc3Qgc2l6ZXMgPSBiaW5hcnlcbiAgICA/IFsnQicsICdLaUInLCAnTWlCJywgJ0dpQicsICdUaUInLCAnUGlCJ11cbiAgICA6IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQiddO1xuXG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgY29uc3Qgc2l6ZSA9IGJ5dGVzIC8gTWF0aC5wb3coaywgaSk7XG5cbiAgLy8gU2hvdyBkZWNpbWFscyBvbmx5IGlmIG5lZWRlZFxuICBjb25zdCBmb3JtYXR0ZWQgPSBzaXplICUgMSA9PT0gMCA/IHNpemUudG9TdHJpbmcoKSA6IHNpemUudG9GaXhlZCgxKTtcblxuICByZXR1cm4gYCR7Zm9ybWF0dGVkfSAke3NpemVzW2ldfWA7XG59XG5cbi8qKlxuICogRXN0aW1hdGUgdGhlIHNlcmlhbGl6ZWQgc2l6ZSBvZiBhIHZhbHVlIGluIGJ5dGVzXG4gKiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gZm9yIGNhY2hlIHNpemUgY2FsY3VsYXRpb25zXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVzdGltYXRlIHNpemUgZm9yXG4gKiBAcmV0dXJucyBFc3RpbWF0ZWQgc2l6ZSBpbiBieXRlc1xuICovXG5pbXBvcnQgc2FmZVN0cmluZ2lmeSBmcm9tICdmYXN0LXNhZmUtc3RyaW5naWZ5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGVzdGltYXRlVmFsdWVTaXplKHZhbHVlOiBhbnkpOiBudW1iZXIge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiA4OyAvLyBBcHByb3hpbWF0ZSBvdmVyaGVhZFxuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gODtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gVVRGLTggZW5jb2Rpbmc6IG1vc3QgY2hhcmFjdGVycyBhcmUgMSBieXRlLCBzb21lIGFyZSAyLTQgYnl0ZXNcbiAgICAgIC8vIFVzZSBhIHNpbXBsZSBhcHByb3hpbWF0aW9uIG9mIDIgYnl0ZXMgcGVyIGNoYXJhY3RlciBmb3Igc2FmZXR5XG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoICogMjtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiB0b3RhbCArIGVzdGltYXRlVmFsdWVTaXplKGl0ZW0pLCAyNCk7IC8vIEFycmF5IG92ZXJoZWFkXG4gICAgICB9XG5cbiAgICAgIC8vIERldGVjdCBjaXJjdWxhciByZWZlcmVuY2VzIGV4cGxpY2l0bHkgdG8gcmVzcGVjdCBmYWxsYmFjayBiZWhhdmlvclxuICAgICAgY29uc3QgaGFzQ2lyY3VsYXJSZWZlcmVuY2UgPSAob2JqOiB1bmtub3duLCBhbmNlc3RvcnM6IFdlYWtTZXQ8b2JqZWN0PiA9IG5ldyBXZWFrU2V0KCksIGNoZWNrZWQ6IFdlYWtTZXQ8b2JqZWN0PiA9IG5ldyBXZWFrU2V0KCkpOiBib29sZWFuID0+IHtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFzT2JqZWN0ID0gb2JqIGFzIG9iamVjdDtcblxuICAgICAgICBpZiAoY2hlY2tlZC5oYXMoYXNPYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuY2VzdG9ycy5oYXMoYXNPYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhbmNlc3RvcnMuYWRkKGFzT2JqZWN0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhc09iamVjdCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhc09iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoaGFzQ2lyY3VsYXJSZWZlcmVuY2UoaXRlbSwgYW5jZXN0b3JzLCBjaGVja2VkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFzT2JqZWN0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSkge1xuICAgICAgICAgICAgICAvLyBBY2Nlc3MgdmFsdWUgZGVmZW5zaXZlbHkgaW4gY2FzZSBvZiBnZXR0ZXJzIHRocm93aW5nXG4gICAgICAgICAgICAgIGxldCBjaGlsZDogdW5rbm93bjtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IChhc09iamVjdCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilba2V5IGFzIGtleW9mIHR5cGVvZiBhc09iamVjdF07XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIFRyZWF0IHByb3BlcnR5IGFjY2VzcyBlcnJvcnMgYXMgbm9uLWZhdGFsIGZvciB0cmF2ZXJzYWxcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGFzQ2lyY3VsYXJSZWZlcmVuY2UoY2hpbGQsIGFuY2VzdG9ycywgY2hlY2tlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhbmNlc3RvcnMuZGVsZXRlKGFzT2JqZWN0KTtcbiAgICAgICAgICBjaGVja2VkLmFkZChhc09iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFzQ2lyY3VsYXJSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIDY0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIDY0O1xuICAgICAgfVxuXG4gICAgICAvLyBGb3Igb2JqZWN0cywgZXN0aW1hdGUgYmFzZWQgb24gc2FmZSBzZXJpYWxpemF0aW9uIHRoYXQgc3VwcG9ydHMgY2lyY3VsYXIgcmVmc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QganNvblN0cmluZyA9IHNhZmVTdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICByZXR1cm4ganNvblN0cmluZy5sZW5ndGggKiAyICsgMTY7IC8vIEpTT04gc3RyaW5nIHNpemUgKyBvYmplY3Qgb3ZlcmhlYWRcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3Igb2JqZWN0cyB0aGF0IGNhbid0IGJlIHNlcmlhbGl6ZWRcbiAgICAgICAgcmV0dXJuIDY0O1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMzI7IC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc2l6ZSBjb25maWd1cmF0aW9uIGlzIHZhbGlkXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIFNpemUgY29uZmlndXJhdGlvbiB0byB2YWxpZGF0ZVxuICogQHRocm93cyBFcnJvciBpZiBjb25maWd1cmF0aW9uIGlzIGludmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2l6ZUNvbmZpZyhjb25maWc6IHsgbWF4U2l6ZUJ5dGVzPzogc3RyaW5nOyBtYXhJdGVtcz86IG51bWJlciB9KTogdm9pZCB7XG4gIGlmICh0eXBlb2YgY29uZmlnLm1heFNpemVCeXRlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBwYXJzZVNpemVTdHJpbmcoY29uZmlnLm1heFNpemVCeXRlcyk7XG4gICAgICBpZiAoYnl0ZXMgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFNpemVCeXRlcyBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtYXhTaXplQnl0ZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcubWF4SXRlbXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvbmZpZy5tYXhJdGVtcykgfHwgY29uZmlnLm1heEl0ZW1zIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWF4SXRlbXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEl0ZW0sXG4gIExvY0tleUFycmF5LFxuICB2YWxpZGF0ZVBLXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVDb250ZXh0IH0gZnJvbSBcIi4uL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnY3JlYXRlJyk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIHY6IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PixcbiAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXSxcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWXT4gPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdjcmVhdGUnLCB7IHYsIGxvY2F0aW9ucyB9KTtcbiAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IGFwaS5jcmVhdGUodiwgbG9jYXRpb25zKTtcbiAgY2FjaGVNYXAuc2V0KGNyZWF0ZWQua2V5LCBjcmVhdGVkKTtcblxuICAvLyBTZXQgVFRMIG1ldGFkYXRhIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoY3JlYXRlZC5rZXkpO1xuICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gIC8vIEhhbmRsZSBldmljdGlvbiBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gIGNvbnN0IGV2aWN0ZWRLZXlzID0gYXdhaXQgZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY3JlYXRlZCwgY2FjaGVNYXApO1xuICAvLyBSZW1vdmUgZXZpY3RlZCBpdGVtcyBmcm9tIGNhY2hlXG4gIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgYXdhaXQgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gIH1cblxuICAvLyBFbWl0IGV2ZW50XG4gIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuaXRlbUNyZWF0ZWQoY3JlYXRlZC5rZXksIGNyZWF0ZWQgYXMgViwgJ2FwaScpO1xuICBldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG5cbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKGNyZWF0ZWQsIHBrVHlwZSkgYXMgVl07XG59O1xuIiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBpc1ZhbGlkSXRlbUtleSxcbiAgSXRlbSxcbiAgUHJpS2V5LFxuICB2YWxpZGF0ZVBLXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVDb250ZXh0IH0gZnJvbSBcIi4uL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uIH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IGVzdGltYXRlVmFsdWVTaXplIH0gZnJvbSBcIi4uL3V0aWxzL0NhY2hlU2l6ZVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2dldCcpO1xuXG4vLyBUcmFjayBpbi1mbGlnaHQgQVBJIHJlcXVlc3RzIHRvIHByZXZlbnQgZHVwbGljYXRlIGNhbGxzIGZvciB0aGUgc2FtZSBrZXlcbmNvbnN0IGluRmxpZ2h0UmVxdWVzdHMgPSBuZXcgTWFwPHN0cmluZywgeyBwcm9taXNlOiBQcm9taXNlPGFueT47IHRpbWVzdGFtcDogbnVtYmVyIH0+KCk7XG5cbi8vIENsZWFudXAgdGltZW91dCBmb3IgaGFuZ2luZyByZXF1ZXN0cyAoZGVmYXVsdCA1IG1pbnV0ZXMpXG5jb25zdCBDTEVBTlVQX1RJTUVPVVQgPSA1ICogNjAgKiAxMDAwOyAvLyA1IG1pbnV0ZXNcblxuLy8gUGVyaW9kaWMgY2xlYW51cCBvZiBzdGFsZSBpbi1mbGlnaHQgcmVxdWVzdHNcbmNvbnN0IGNsZWFudXBTdGFsZVJlcXVlc3RzID0gKCkgPT4ge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCBrZXlzVG9EZWxldGU6IHN0cmluZ1tdID0gW107XG5cbiAgaW5GbGlnaHRSZXF1ZXN0cy5mb3JFYWNoKChyZXF1ZXN0LCBrZXkpID0+IHtcbiAgICBpZiAobm93IC0gcmVxdWVzdC50aW1lc3RhbXAgPiBDTEVBTlVQX1RJTUVPVVQpIHtcbiAgICAgIGtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XG4gICAgfVxuICB9KTtcblxuICBrZXlzVG9EZWxldGUuZm9yRWFjaChrZXkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnQ2xlYW5pbmcgdXAgc3RhbGUgaW4tZmxpZ2h0IHJlcXVlc3QnLCB7IGtleSB9KTtcbiAgICBpbkZsaWdodFJlcXVlc3RzLmRlbGV0ZShrZXkpO1xuICB9KTtcbn07XG5cbi8vIFJ1biBjbGVhbnVwIGV2ZXJ5IG1pbnV0ZVxuY29uc3QgY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWwoY2xlYW51cFN0YWxlUmVxdWVzdHMsIDYwICogMTAwMCk7XG5cbi8vIEV4cG9ydCBjbGVhbnVwIGZ1bmN0aW9uIGZvciBncmFjZWZ1bCBzaHV0ZG93blxuZXhwb3J0IGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gIGNsZWFySW50ZXJ2YWwoY2xlYW51cEludGVydmFsKTtcbiAgaW5GbGlnaHRSZXF1ZXN0cy5jbGVhcigpO1xufTtcblxuLy8gTm9ybWFsaXplZCBrZXkgc3RyaW5naWZpY2F0aW9uIGZvciB0cmFja2luZyBwdXJwb3NlcyAtIHVzZXMgc2FtZSBub3JtYWxpemF0aW9uIGFzIGNhY2hlIG1hcHNcbmNvbnN0IGtleVRvU3RyaW5nID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbjxhbnk+KCk7XG5cbmV4cG9ydCBjb25zdCBnZXQgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgViB8IG51bGxdPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyLCBzdGF0c01hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdnZXQnLCB7IGtleSwgZGVmYXVsdFRUTDogdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCkgfSk7XG5cbiAgLy8gVHJhY2sgY2FjaGUgcmVxdWVzdFxuICBzdGF0c01hbmFnZXIuaW5jcmVtZW50UmVxdWVzdHMoKTtcblxuICBpZiAoIWlzVmFsaWRJdGVtS2V5KGtleSkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0tleSBmb3IgR2V0IGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqJywga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBmb3IgR2V0IGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXknKTtcbiAgfVxuXG4gIC8vIENoZWNrIGNhY2hlIGZpcnN0IGlmIFRUTCBpcyBlbmFibGVkXG4gIGlmICh0dGxNYW5hZ2VyLmlzVFRMRW5hYmxlZCgpKSB7XG4gICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICBjb25zdCBjYWNoZWRJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgaWYgKGNhY2hlZEl0ZW0pIHtcbiAgICAgIC8vIENoZWNrIFRUTCB2YWxpZGl0eSB1c2luZyBUVExNYW5hZ2VyXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdHRsTWFuYWdlci52YWxpZGF0ZUl0ZW0oa2V5U3RyLCBjYWNoZU1hcCk7XG4gICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlIGhpdCB3aXRoIHZhbGlkIFRUTCcsIHsga2V5LCBkZWZhdWx0VFRMOiB0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSB9KTtcbiAgICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudEhpdHMoKTtcbiAgICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKGNhY2hlZEl0ZW0sIHBrVHlwZSkgYXMgVl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJdGVtIGV4cGlyZWQsIHJlbW92ZSBpdCBmcm9tIGNhY2hlXG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGUgaXRlbSBleHBpcmVkLCByZW1vdmluZycsIHsga2V5IH0pO1xuICAgICAgICBjYWNoZU1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudE1pc3NlcygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjYWNoZWQgaXRlbSBmb3VuZFxuICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudE1pc3NlcygpO1xuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoJ0NhY2hlIG1pc3Mgb3IgZXhwaXJlZCcsIHsga2V5LCBkZWZhdWx0VFRMOiB0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUVEwgbm90IGVuYWJsZWQsIGNoZWNrIGNhY2hlIGRpcmVjdGx5XG4gICAgY29uc3QgY2FjaGVkSXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuICAgIGlmIChjYWNoZWRJdGVtKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlIGhpdCAoVFRMIGRpc2FibGVkKScsIHsga2V5IH0pO1xuICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudEhpdHMoKTtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhjYWNoZWRJdGVtLCBwa1R5cGUpIGFzIFZdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50TWlzc2VzKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgVFRMIGlzIDAgb3IgY2FjaGUgbWlzcy9leHBpcmVkLCBmZXRjaCBmcm9tIEFQSVxuICBsZXQgcmV0OiBWIHwgbnVsbDtcbiAgY29uc3Qga2V5U3RyID0ga2V5VG9TdHJpbmcoa2V5KTtcblxuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYWxyZWFkeSBhbiBpbi1mbGlnaHQgcmVxdWVzdCBmb3IgdGhpcyBrZXlcbiAgICBjb25zdCByZXF1ZXN0RW50cnkgPSBpbkZsaWdodFJlcXVlc3RzLmdldChrZXlTdHIpO1xuICAgIGxldCBhcGlSZXF1ZXN0OiBQcm9taXNlPGFueT47XG5cbiAgICBpZiAoIXJlcXVlc3RFbnRyeSkge1xuICAgICAgLy8gQ3JlYXRlIG5ldyBBUEkgcmVxdWVzdFxuICAgICAgYXBpUmVxdWVzdCA9IGFwaS5nZXQoa2V5KTtcblxuICAgICAgLy8gT25seSB0cmFjayBzdWNjZXNzZnVsIHByb21pc2UgY3JlYXRpb25cbiAgICAgIGlmIChhcGlSZXF1ZXN0ICYmIHR5cGVvZiBhcGlSZXF1ZXN0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaW5GbGlnaHRSZXF1ZXN0cy5zZXQoa2V5U3RyLCB7IHByb21pc2U6IGFwaVJlcXVlc3QsIHRpbWVzdGFtcCB9KTtcblxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgdHJhY2tpbmcgd2hlbiByZXF1ZXN0IGNvbXBsZXRlcyAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4gaW5GbGlnaHRSZXF1ZXN0cy5kZWxldGUoa2V5U3RyKTtcblxuICAgICAgICBpZiAodHlwZW9mIGFwaVJlcXVlc3QuZmluYWxseSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGFwaVJlcXVlc3QuZmluYWxseShjbGVhbnVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGYWxsYmFjayBjbGVhbnVwIGZvciBwcm9taXNlcyB3aXRob3V0IC5maW5hbGx5KClcbiAgICAgICAgICBhcGlSZXF1ZXN0LnRoZW4oY2xlYW51cCwgY2xlYW51cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdVc2luZyBpbi1mbGlnaHQgcmVxdWVzdCBmb3Iga2V5JywgeyBrZXkgfSk7XG4gICAgICBhcGlSZXF1ZXN0ID0gcmVxdWVzdEVudHJ5LnByb21pc2U7XG4gICAgfVxuXG4gICAgcmV0ID0gYXdhaXQgYXBpUmVxdWVzdDtcbiAgICBpZiAocmV0KSB7XG4gICAgICBhd2FpdCBjYWNoZU1hcC5zZXQocmV0LmtleSwgcmV0KTtcblxuICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkocmV0LmtleSk7XG5cbiAgICAgIC8vIENyZWF0ZSBiYXNlIG1ldGFkYXRhIGlmIGl0IGRvZXNuJ3QgZXhpc3QgKG5lZWRlZCBmb3IgVFRMIGFuZCBldmljdGlvbilcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2FjaGVNYXAuZ2V0TWV0YWRhdGEoa2V5U3RyKTtcbiAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgYmFzZU1ldGFkYXRhID0ge1xuICAgICAgICAgIGtleToga2V5U3RyLFxuICAgICAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgICAgIGVzdGltYXRlZFNpemU6IGVzdGltYXRlVmFsdWVTaXplKHJldClcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgY2FjaGVNYXAuc2V0TWV0YWRhdGEoa2V5U3RyLCBiYXNlTWV0YWRhdGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgZXZpY3Rpb24gZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHJldCwgY2FjaGVNYXApO1xuXG4gICAgICAvLyBTZXQgVFRMIG1ldGFkYXRhIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICAgIGF3YWl0IHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG5cbiAgICAgIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgICAgIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gRW1pdCBldmVudCBmb3IgaXRlbSByZXRyaWV2ZWQgZnJvbSBBUElcbiAgICAgIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuaXRlbVJldHJpZXZlZChyZXQua2V5LCByZXQgYXMgViwgJ2FwaScpO1xuICAgICAgY29udGV4dC5ldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG4gICAgfVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAvLyBFbnN1cmUgd2UgY2xlYW4gdXAgdGhlIGluLWZsaWdodCByZXF1ZXN0IG9uIGVycm9yXG4gICAgaW5GbGlnaHRSZXF1ZXN0cy5kZWxldGUoa2V5U3RyKTtcbiAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGl0ZW0gZm9yIGtleVwiLCB7IGtleSwgbWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjayB9KTtcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICBjb250ZXh0LFxuICAgIHJldCA/XG4gICAgICB2YWxpZGF0ZVBLKHJldCwgcGtUeXBlKSBhcyBWIDpcbiAgICAgIG51bGxcbiAgXTtcbn07XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBJdGVtLFxuICBQcmlLZXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7IGdldCB9IGZyb20gXCIuL2dldFwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdyZXRyaWV2ZScpO1xuXG5leHBvcnQgY29uc3QgcmV0cmlldmUgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IG51bGwsIFYgfCBudWxsXT4gPT4ge1xuICBjb25zdCB7IGNhY2hlTWFwLCBwa1R5cGUsIHN0YXRzTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ3JldHJpZXZlJywgeyBrZXkgfSk7XG5cbiAgLy8gVHJhY2sgY2FjaGUgcmVxdWVzdFxuICBzdGF0c01hbmFnZXIuaW5jcmVtZW50UmVxdWVzdHMoKTtcblxuICBpZiAoIWlzVmFsaWRJdGVtS2V5KGtleSkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0tleSBmb3IgUmV0cmlldmUgaXMgbm90IGEgdmFsaWQgSXRlbUtleTogJWonLCBrZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IGZvciBSZXRyaWV2ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5Jyk7XG4gIH1cblxuICBjb25zdCBjb250YWluc0l0ZW1LZXkgPSBhd2FpdCBjYWNoZU1hcC5pbmNsdWRlc0tleShrZXkpO1xuXG4gIGxldCByZXRyaWV2ZWQ6IFYgfCBudWxsO1xuICBsZXQgY29udGV4dFRvUmV0dXJuOiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IG51bGw7XG5cbiAgaWYgKGNvbnRhaW5zSXRlbUtleSkge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdMb29raW5nIGZvciBPYmplY3QgaW4gQ2FjaGUnLCBrZXkpO1xuICAgIHJldHJpZXZlZCA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuICAgIGNvbnRleHRUb1JldHVybiA9IG51bGw7XG4gICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudEhpdHMoKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnT2JqZWN0IE5vdCBGb3VuZCBpbiBDYWNoZSwgUmV0cmlldmluZyBmcm9tIFNlcnZlciBBUEknLCB7IGtleSB9KTtcbiAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50TWlzc2VzKCk7XG4gICAgW2NvbnRleHRUb1JldHVybiwgcmV0cmlldmVkXSA9IGF3YWl0IGdldChrZXksIGNvbnRleHQpO1xuICB9XG5cbiAgY29uc3QgcmV0VmFsdWU6IFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IG51bGwsIFYgfCBudWxsXSA9IFtcbiAgICBjb250ZXh0VG9SZXR1cm4sXG4gICAgcmV0cmlldmVkID9cbiAgICAgIHZhbGlkYXRlUEsocmV0cmlldmVkLCBwa1R5cGUpIGFzIFYgOlxuICAgICAgbnVsbFxuICBdO1xuXG4gIHJldHVybiByZXRWYWx1ZTtcbn07XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBJdGVtLFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RmFjdG9yeSB9IGZyb20gXCIuLi9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnlcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdyZW1vdmUnKTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8Q2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+ID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgncmVtb3ZlJywgeyBrZXkgfSk7XG5cbiAgaWYgKCFpc1ZhbGlkSXRlbUtleShrZXkpKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdLZXkgZm9yIFJlbW92ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlaicsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZm9yIFJlbW92ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5Jyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIEdldCBpdGVtIGJlZm9yZSByZW1vdmFsIGZvciBldmVudFxuICAgIGNvbnN0IHByZXZpb3VzSXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuXG4gICAgLy8gRmlyc3QgcmVtb3ZlIGZyb20gQVBJLCB0aGVuIGZyb20gY2FjaGUgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3lcbiAgICBhd2FpdCBhcGkucmVtb3ZlKGtleSk7XG4gICAgY2FjaGVNYXAuZGVsZXRlKGtleSk7XG5cbiAgICAvLyBFbWl0IGV2ZW50XG4gICAgaWYgKHByZXZpb3VzSXRlbSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtUmVtb3ZlZChrZXksIHByZXZpb3VzSXRlbSwgJ2FwaScpO1xuICAgICAgY29udGV4dC5ldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKCdTdWNjZXNzZnVsbHkgcmVtb3ZlZCBpdGVtIGZyb20gQVBJIGFuZCBjYWNoZScsIHsga2V5IH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgZGVsZXRpbmcgaXRlbVwiLCB7IGVycm9yOiBlIH0pO1xuICAgIC8vIERvbid0IGRlbGV0ZSBmcm9tIGNhY2hlIGlmIEFQSSBkZWxldGlvbiBmYWlsZWRcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuIiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBpc1ZhbGlkSXRlbUtleSxcbiAgSXRlbSxcbiAgUHJpS2V5LFxuICB2YWxpZGF0ZVBLXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVDb250ZXh0IH0gZnJvbSBcIi4uL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBlc3RpbWF0ZVZhbHVlU2l6ZSB9IGZyb20gXCIuLi91dGlscy9DYWNoZVNpemVcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCd1cGRhdGUnKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZSA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgdjogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxbQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIFZdPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgndXBkYXRlJywgeyBrZXksIHYgfSk7XG5cbiAgaWYgKCFpc1ZhbGlkSXRlbUtleShrZXkpKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdLZXkgZm9yIFVwZGF0ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlaicsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZm9yIFVwZGF0ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5Jyk7XG4gIH1cblxuICAvLyBJbnZhbGlkYXRlIHRoZSBpdGVtIGtleSBiZWZvcmUgZXhlY3V0aW5nIHRoZSB1cGRhdGVcbiAgbG9nZ2VyLmRlYnVnKCdJbnZhbGlkYXRpbmcgaXRlbSBrZXkgYmVmb3JlIHVwZGF0ZScsIHsga2V5IH0pO1xuICBjYWNoZU1hcC5pbnZhbGlkYXRlSXRlbUtleXMoW2tleV0pO1xuXG4gIHRyeSB7XG4gICAgLy8gR2V0IHByZXZpb3VzIGl0ZW0gZm9yIGV2ZW50XG4gICAgY29uc3QgcHJldmlvdXNJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG5cbiAgICBjb25zdCB1cGRhdGVkID0gYXdhaXQgYXBpLnVwZGF0ZShrZXksIHYpO1xuXG4gICAgLy8gQ2FjaGUgdGhlIHJlc3VsdCBhZnRlciB0aGUgdXBkYXRlXG4gICAgbG9nZ2VyLmRlYnVnKCdDYWNoaW5nIHVwZGF0ZSByZXN1bHQnLCB7IHVwZGF0ZWRLZXk6IHVwZGF0ZWQua2V5IH0pO1xuICAgIGF3YWl0IGNhY2hlTWFwLnNldCh1cGRhdGVkLmtleSwgdXBkYXRlZCk7XG5cbiAgICAvLyBDcmVhdGUgYmFzZSBtZXRhZGF0YSBpZiBpdCBkb2Vzbid0IGV4aXN0IChuZWVkZWQgZm9yIFRUTCBhbmQgZXZpY3Rpb24pXG4gICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkodXBkYXRlZC5rZXkpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2FjaGVNYXAuZ2V0TWV0YWRhdGEoa2V5U3RyKTtcbiAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgYmFzZU1ldGFkYXRhID0ge1xuICAgICAgICBrZXk6IGtleVN0cixcbiAgICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgICAgZXN0aW1hdGVkU2l6ZTogZXN0aW1hdGVWYWx1ZVNpemUodXBkYXRlZClcbiAgICAgIH07XG4gICAgICBhd2FpdCBjYWNoZU1hcC5zZXRNZXRhZGF0YShrZXlTdHIsIGJhc2VNZXRhZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IFRUTCBtZXRhZGF0YSBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gICAgYXdhaXQgY29udGV4dC50dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gICAgLy8gSGFuZGxlIGV2aWN0aW9uIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICBjb25zdCBldmljdGVkS2V5cyA9IGF3YWl0IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdXBkYXRlZCwgY2FjaGVNYXApO1xuICAgIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgICBmb3IgKGNvbnN0IGV2aWN0ZWRLZXkgb2YgZXZpY3RlZEtleXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICB9XG5cbiAgICAvLyBFbWl0IGV2ZW50XG4gICAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtVXBkYXRlZCh1cGRhdGVkLmtleSwgdXBkYXRlZCBhcyBWLCBwcmV2aW91c0l0ZW0sICdhcGknKTtcbiAgICBjb250ZXh0LmV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcblxuICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyh1cGRhdGVkLCBwa1R5cGUpIGFzIFZdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgaXRlbVwiLCB7IGVycm9yOiBlIH0pO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBJdGVtLFxuICBQcmlLZXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnYWN0aW9uJyk7XG5cbmV4cG9ydCBjb25zdCBhY3Rpb24gPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gIGFjdGlvbjogc3RyaW5nLFxuICBib2R5OiBhbnkgPSB7fSxcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWXT4gPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2FjdGlvbicsIHsga2V5LCBhY3Rpb24sIGJvZHkgfSk7XG5cbiAgaWYgKCFpc1ZhbGlkSXRlbUtleShrZXkpKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdLZXkgZm9yIEFjdGlvbiBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlaicsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZm9yIEFjdGlvbiBpcyBub3QgYSB2YWxpZCBJdGVtS2V5Jyk7XG4gIH1cblxuICAvLyBJbnZhbGlkYXRlIHRoZSBpdGVtIGtleSBiZWZvcmUgZXhlY3V0aW5nIHRoZSBhY3Rpb25cbiAgbG9nZ2VyLmRlYnVnKCdJbnZhbGlkYXRpbmcgaXRlbSBrZXkgYmVmb3JlIGFjdGlvbicsIHsga2V5IH0pO1xuICBjYWNoZU1hcC5pbnZhbGlkYXRlSXRlbUtleXMoW2tleV0pO1xuXG4gIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCBhcGkuYWN0aW9uKGtleSwgYWN0aW9uLCBib2R5KTtcblxuICAvLyBDYWNoZSB0aGUgcmVzdWx0IGFmdGVyIHRoZSBhY3Rpb25cbiAgbG9nZ2VyLmRlYnVnKCdDYWNoaW5nIGFjdGlvbiByZXN1bHQnLCB7IHVwZGF0ZWRLZXk6IHVwZGF0ZWQua2V5IH0pO1xuICBjYWNoZU1hcC5zZXQodXBkYXRlZC5rZXksIHVwZGF0ZWQpO1xuXG4gIC8vIFNldCBUVEwgbWV0YWRhdGEgZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeSh1cGRhdGVkLmtleSk7XG4gIGNvbnRleHQudHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcblxuICAvLyBIYW5kbGUgZXZpY3Rpb24gZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICBjb25zdCBldmljdGVkS2V5cyA9IGF3YWl0IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdXBkYXRlZCwgY2FjaGVNYXApO1xuICAvLyBSZW1vdmUgZXZpY3RlZCBpdGVtcyBmcm9tIGNhY2hlXG4gIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgYXdhaXQgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGV2aWN0ZWQga2V5IGR1cmluZyBkZWxldGlvbicsIHtcbiAgICAgICAgZXZpY3RlZEtleSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICAvLyBDb250aW51ZSBwcm9jZXNzaW5nIG90aGVyIGtleXMgcmF0aGVyIHRoYW4gZmFpbGluZyBjb21wbGV0ZWx5XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKHVwZGF0ZWQsIHBrVHlwZSkgYXMgVl07XG59O1xuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgTG9jS2V5QXJyYXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBOb3RGb3VuZEVycm9yIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuaW1wb3J0IHsgQ2FjaGVDb250ZXh0IH0gZnJvbSBcIi4uL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2FsbEFjdGlvbicpO1xuXG5leHBvcnQgY29uc3QgYWxsQWN0aW9uID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBhY3Rpb246IHN0cmluZyxcbiAgYm9keTogYW55ID0ge30sXG4gIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW10sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgVltdXT4gPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2FsbEFjdGlvbicsIHsgYWN0aW9uLCBib2R5LCBsb2NhdGlvbnMgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBhbGwgaXRlbXMgaW4gdGhlIHNwZWNpZmllZCBsb2NhdGlvbnMgYmVmb3JlIGV4ZWN1dGluZyB0aGUgYWN0aW9uXG4gIGxvZ2dlci5kZWJ1ZygnSW52YWxpZGF0aW5nIGxvY2F0aW9uIGJlZm9yZSBhbGxBY3Rpb24nLCB7IGxvY2F0aW9ucyB9KTtcbiAgY2FjaGVNYXAuaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9ucyk7XG5cbiAgbGV0IHJldDogVltdID0gW107XG4gIHRyeSB7XG4gICAgcmV0ID0gYXdhaXQgYXBpLmFsbEFjdGlvbihhY3Rpb24sIGJvZHksIGxvY2F0aW9ucyk7XG5cbiAgICAvLyBDYWNoZSBhbGwgcmVzdWx0cyBhZnRlciB0aGUgYWN0aW9uXG4gICAgbG9nZ2VyLmRlYnVnKCdDYWNoaW5nIGFsbEFjdGlvbiByZXN1bHRzJywgeyByZXN1bHRDb3VudDogcmV0Lmxlbmd0aCB9KTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgcmV0KSB7XG4gICAgICBhd2FpdCBjYWNoZU1hcC5zZXQodi5rZXksIHYpO1xuXG4gICAgICAvLyBTZXQgVFRMIG1ldGFkYXRhIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHYua2V5KTtcbiAgICAgIGNvbnRleHQudHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcblxuICAgICAgLy8gSGFuZGxlIGV2aWN0aW9uIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gYXdhaXQgY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB2LCBjYWNoZU1hcCk7XG4gICAgICAvLyBSZW1vdmUgZXZpY3RlZCBpdGVtcyBmcm9tIGNhY2hlXG4gICAgICBmb3IgKGNvbnN0IGV2aWN0ZWRLZXkgb2YgZXZpY3RlZEtleXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgICAgYXdhaXQgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgIC8vIEhhbmRsZSBub3QgZm91bmQgZ3JhY2VmdWxseVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsocmV0LCBwa1R5cGUpIGFzIFZbXV07XG59O1xuIiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBJdGVtLFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnZmFjZXQnKTtcblxuZXhwb3J0IGNvbnN0IGZhY2V0ID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICBmYWNldDogc3RyaW5nLFxuICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgY29uc3QgeyBhcGkgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdmYWNldCcsIHsga2V5LCBmYWNldCB9KTtcbiAgY29uc3QgcmV0ID0gYXdhaXQgYXBpLmZhY2V0KGtleSwgZmFjZXQsIHBhcmFtcyk7XG4gIHJldHVybiByZXQ7XG59O1xuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgTG9jS2V5QXJyYXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnYWxsRmFjZXQnKTtcblxuZXhwb3J0IGNvbnN0IGFsbEZhY2V0ID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBmYWNldDogc3RyaW5nLFxuICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdLFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgY29uc3QgeyBhcGkgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdhbGxGYWNldCcsIHsgZmFjZXQsIHBhcmFtcywgbG9jYXRpb25zIH0pO1xuICBjb25zdCByZXQgPSBhd2FpdCBhcGkuYWxsRmFjZXQoZmFjZXQsIHBhcmFtcywgbG9jYXRpb25zKTtcbiAgcmV0dXJuIHJldDtcbn07XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheSxcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCB7IGNyZWF0ZUZpbmRlckhhc2ggfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2ZpbmQnKTtcblxuZXhwb3J0IGNvbnN0IGZpbmQgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGZpbmRlcjogc3RyaW5nLFxuICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdLFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxbQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIFZbXV0+ID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUsIHR0bE1hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdmaW5kJywgeyBmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zIH0pO1xuXG4gIC8vIEdlbmVyYXRlIHF1ZXJ5IGhhc2ggZm9yIGNhY2hpbmdcbiAgY29uc3QgcXVlcnlIYXNoID0gY3JlYXRlRmluZGVySGFzaChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zKTtcbiAgbG9nZ2VyLmRlYnVnKCdHZW5lcmF0ZWQgcXVlcnkgaGFzaCBmb3IgZmluZCcsIHsgcXVlcnlIYXNoIH0pO1xuXG4gIC8vIENoZWNrIGlmIHdlIGhhdmUgY2FjaGVkIHF1ZXJ5IHJlc3VsdHNcbiAgY29uc3QgY2FjaGVkSXRlbUtleXMgPSBhd2FpdCBjYWNoZU1hcC5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICBpZiAoY2FjaGVkSXRlbUtleXMpIHtcbiAgICBsb2dnZXIuZGVidWcoJ1VzaW5nIGNhY2hlZCBxdWVyeSByZXN1bHRzJywgeyBjYWNoZWRLZXlDb3VudDogY2FjaGVkSXRlbUtleXMubGVuZ3RoIH0pO1xuXG4gICAgLy8gUmV0cmlldmUgYWxsIGNhY2hlZCBpdGVtcyAtIGlmIGFueSBhcmUgbWlzc2luZywgaW52YWxpZGF0ZSB0aGUgcXVlcnkgY2FjaGVcbiAgICBjb25zdCBjYWNoZWRJdGVtczogVltdID0gW107XG4gICAgbGV0IGFsbEl0ZW1zQXZhaWxhYmxlID0gdHJ1ZTtcblxuICAgIGZvciAoY29uc3QgaXRlbUtleSBvZiBjYWNoZWRJdGVtS2V5cykge1xuICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChpdGVtS2V5KTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNhY2hlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxJdGVtc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsSXRlbXNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhjYWNoZWRJdGVtcywgcGtUeXBlKSBhcyBWW11dO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1NvbWUgY2FjaGVkIGl0ZW1zIG1pc3NpbmcsIGludmFsaWRhdGluZyBxdWVyeSBjYWNoZScpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCBmcm9tIEFQSVxuICBjb25zdCByZXQ6IFZbXSA9IGF3YWl0IGFwaS5maW5kKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMpO1xuXG4gIC8vIFN0b3JlIGluZGl2aWR1YWwgaXRlbXMgaW4gY2FjaGVcbiAgZm9yIChjb25zdCB2IG9mIHJldCkge1xuICAgIGF3YWl0IGNhY2hlTWFwLnNldCh2LmtleSwgdik7XG5cbiAgICAvLyBTZXQgVFRMIG1ldGFkYXRhIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeSh2LmtleSk7XG4gICAgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcblxuICAgIC8vIEhhbmRsZSBldmljdGlvbiBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gICAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHYsIGNhY2hlTWFwKTtcbiAgICAvLyBSZW1vdmUgZXZpY3RlZCBpdGVtcyBmcm9tIGNhY2hlXG4gICAgZm9yIChjb25zdCBldmljdGVkS2V5IG9mIGV2aWN0ZWRLZXlzKSB7XG4gICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgYXdhaXQgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RvcmUgcXVlcnkgcmVzdWx0IChpdGVtIGtleXMpIGluIHF1ZXJ5IGNhY2hlXG4gIGNvbnN0IGl0ZW1LZXlzID0gcmV0Lm1hcChpdGVtID0+IGl0ZW0ua2V5KTtcbiAgY2FjaGVNYXAuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cyk7XG4gIGxvZ2dlci5kZWJ1ZygnQ2FjaGVkIHF1ZXJ5IHJlc3VsdCcsIHsgcXVlcnlIYXNoLCBpdGVtS2V5Q291bnQ6IGl0ZW1LZXlzLmxlbmd0aCB9KTtcblxuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsocmV0LCBwa1R5cGUpIGFzIFZbXV07XG59O1xuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgTG9jS2V5QXJyYXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBjcmVhdGVGaW5kZXJIYXNoIH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdmaW5kT25lJyk7XG5cbmV4cG9ydCBjb25zdCBmaW5kT25lID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBmaW5kZXI6IHN0cmluZyxcbiAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXSxcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWXT4gPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgdHRsTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2ZpbmRPbmUnLCB7IGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMgfSk7XG5cbiAgLy8gR2VuZXJhdGUgcXVlcnkgaGFzaCBmb3IgY2FjaGluZ1xuICBjb25zdCBxdWVyeUhhc2ggPSBjcmVhdGVGaW5kZXJIYXNoKGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMpO1xuICBsb2dnZXIuZGVidWcoJ0dlbmVyYXRlZCBxdWVyeSBoYXNoIGZvciBmaW5kT25lJywgeyBxdWVyeUhhc2ggfSk7XG5cbiAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBjYWNoZWQgcXVlcnkgcmVzdWx0c1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cyAmJiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdVc2luZyBjYWNoZWQgcXVlcnkgcmVzdWx0cycsIHsgY2FjaGVkS2V5Q291bnQ6IGNhY2hlZEl0ZW1LZXlzLmxlbmd0aCB9KTtcblxuICAgIC8vIFJldHJpZXZlIHRoZSBmaXJzdCBjYWNoZWQgaXRlbSAtIGlmIG1pc3NpbmcsIGludmFsaWRhdGUgdGhlIHF1ZXJ5IGNhY2hlXG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChjYWNoZWRJdGVtS2V5c1swXSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhpdGVtLCBwa1R5cGUpIGFzIFZdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlZCBpdGVtIG1pc3NpbmcsIGludmFsaWRhdGluZyBxdWVyeSBjYWNoZScpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCBmcm9tIEFQSVxuICBjb25zdCByZXQgPSBhd2FpdCBhcGkuZmluZE9uZShmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zKTtcblxuICAvLyBTdG9yZSBpbmRpdmlkdWFsIGl0ZW0gaW4gY2FjaGVcbiAgY2FjaGVNYXAuc2V0KHJldC5rZXksIHJldCk7XG5cbiAgLy8gU2V0IFRUTCBtZXRhZGF0YSBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHJldC5rZXkpO1xuICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gIC8vIEhhbmRsZSBldmljdGlvbiBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gIGNvbnN0IGV2aWN0ZWRLZXlzID0gYXdhaXQgY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCByZXQsIGNhY2hlTWFwKTtcbiAgLy8gUmVtb3ZlIGV2aWN0ZWQgaXRlbXMgZnJvbSBjYWNoZVxuICBmb3IgKGNvbnN0IGV2aWN0ZWRLZXkgb2YgZXZpY3RlZEtleXMpIHtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgIGF3YWl0IGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICB9XG5cbiAgLy8gU3RvcmUgcXVlcnkgcmVzdWx0IChzaW5nbGUgaXRlbSBrZXkpIGluIHF1ZXJ5IGNhY2hlXG4gIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW3JldC5rZXldKTtcbiAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgcXVlcnkgcmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXk6IHJldC5rZXkgfSk7XG5cbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKHJldCwgcGtUeXBlKSBhcyBWXTtcbn07XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIGlzSXRlbUtleUVxdWFsLFxuICBpc1ZhbGlkSXRlbUtleSxcbiAgSXRlbSxcbiAgUHJpS2V5LFxuICB2YWxpZGF0ZVBLXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVDb250ZXh0IH0gZnJvbSBcIi4uL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBlc3RpbWF0ZVZhbHVlU2l6ZSB9IGZyb20gXCIuLi91dGlscy9DYWNoZVNpemVcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdzZXQnKTtcblxuLy8gTm9ybWFsaXplIGEga2V5IHZhbHVlIHRvIHN0cmluZyBmb3IgY29uc2lzdGVudCBjb21wYXJpc29uXG5jb25zdCBub3JtYWxpemVLZXlWYWx1ZSA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xuXG4vLyBOb3JtYWxpemVkIGtleSBjb21wYXJpc29uIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBzdHJpbmcvbnVtYmVyIGRpZmZlcmVuY2VzXG5jb25zdCBpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWQgPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oYTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIGI6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogYm9vbGVhbiA9PiB7XG4gIC8vIEZvciBub3csIGp1c3Qgbm9ybWFsaXplIHRoZSBrZXlzIHRvIHN0cmluZ3MgYW5kIHVzZSB0aGUgb3JpZ2luYWwgY29tcGFyaXNvblxuICBjb25zdCBub3JtYWxpemVkQSA9IG5vcm1hbGl6ZUtleShhKTtcbiAgY29uc3Qgbm9ybWFsaXplZEIgPSBub3JtYWxpemVLZXkoYik7XG4gIHJldHVybiBpc0l0ZW1LZXlFcXVhbChub3JtYWxpemVkQSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgbm9ybWFsaXplZEIgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSBhIGtleSBlZmZpY2llbnRseSB3aXRob3V0IGRlZXAgY2xvbmluZ1xuY29uc3Qgbm9ybWFsaXplS2V5ID0gKGtleTogYW55KTogYW55ID0+IHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgIGxldCBuZWVkc05vcm1hbGl6YXRpb24gPSBmYWxzZTtcbiAgICBsZXQgbm9ybWFsaXplZEtleSA9IGtleTtcblxuICAgIC8vIENoZWNrIGlmIHBrIG5lZWRzIG5vcm1hbGl6YXRpb25cbiAgICBpZiAoJ3BrJyBpbiBrZXkgJiYga2V5LnBrICE9PSBudWxsICYmIHR5cGVvZiBrZXkucGsgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuZWVkc05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGxrIG5lZWRzIG5vcm1hbGl6YXRpb25cbiAgICBpZiAoJ2xrJyBpbiBrZXkgJiYga2V5LmxrICE9PSBudWxsICYmIHR5cGVvZiBrZXkubGsgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuZWVkc05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGxvYyBhcnJheSBoYXMgbGsgdmFsdWVzIHRoYXQgbmVlZCBub3JtYWxpemF0aW9uXG4gICAgaWYgKCdsb2MnIGluIGtleSAmJiBBcnJheS5pc0FycmF5KGtleS5sb2MpKSB7XG4gICAgICBmb3IgKGNvbnN0IGxvY0l0ZW0gb2Yga2V5LmxvYykge1xuICAgICAgICBpZiAobG9jSXRlbSAmJiAnbGsnIGluIGxvY0l0ZW0gJiYgbG9jSXRlbS5sayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9jSXRlbS5sayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBuZWVkc05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSBjcmVhdGUgYSBuZXcgb2JqZWN0IGlmIG5vcm1hbGl6YXRpb24gaXMgYWN0dWFsbHkgbmVlZGVkXG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbikge1xuICAgICAgbm9ybWFsaXplZEtleSA9IHsgLi4ua2V5IH07XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBwayB2YWx1ZXNcbiAgICAgIGlmICgncGsnIGluIG5vcm1hbGl6ZWRLZXkgJiYgbm9ybWFsaXplZEtleS5wayAhPT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkS2V5LnBrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5wayk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBsayB2YWx1ZXNcbiAgICAgIGlmICgnbGsnIGluIG5vcm1hbGl6ZWRLZXkgJiYgbm9ybWFsaXplZEtleS5sayAhPT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5sayk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBsb2MgYXJyYXkgbGsgdmFsdWVzXG4gICAgICBpZiAoJ2xvYycgaW4gbm9ybWFsaXplZEtleSAmJiBBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRLZXkubG9jKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxvYyA9IG5vcm1hbGl6ZWRLZXkubG9jLm1hcCgobG9jSXRlbTogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKGxvY0l0ZW0gJiYgJ2xrJyBpbiBsb2NJdGVtICYmIGxvY0l0ZW0ubGsgIT09IG51bGwgJiYgdHlwZW9mIGxvY0l0ZW0ubGsgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5sb2NJdGVtLCBsazogbm9ybWFsaXplS2V5VmFsdWUobG9jSXRlbS5saykgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY0l0ZW07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkS2V5O1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0ID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICB2OiBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgVl0+ID0+IHtcbiAgY29uc3QgeyBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIGV2ZW50RW1pdHRlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ3NldCcsIHsga2V5LCB2IH0pO1xuXG4gIGlmICghaXNWYWxpZEl0ZW1LZXkoa2V5KSkge1xuICAgIGxvZ2dlci5lcnJvcignS2V5IGZvciBTZXQgaXMgbm90IGEgdmFsaWQgSXRlbUtleTogJWonLCBrZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IGZvciBTZXQgaXMgbm90IGEgdmFsaWQgSXRlbUtleScpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgdGhlIGl0ZW0ncyBwcmltYXJ5IGtleVxuICB2YWxpZGF0ZVBLKHYsIHBrVHlwZSk7XG5cbiAgaWYgKCFpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWQoa2V5LCB2LmtleSkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0tleSBkb2VzIG5vdCBtYXRjaCBpdGVtIGtleTogJWogIT0gJWonLCBrZXksIHYua2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBkb2VzIG5vdCBtYXRjaCBpdGVtIGtleScpO1xuICB9XG5cbiAgLy8gR2V0IHByZXZpb3VzIGl0ZW0gaWYgaXQgZXhpc3RzXG4gIGNvbnN0IHByZXZpb3VzSXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuXG4gIGF3YWl0IGNhY2hlTWFwLnNldChrZXksIHYgYXMgVik7XG5cbiAgLy8gQ3JlYXRlIGJhc2UgbWV0YWRhdGEgaWYgaXQgZG9lc24ndCBleGlzdCAobmVlZGVkIGZvciBUVEwgYW5kIGV2aWN0aW9uKVxuICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhY2hlTWFwLmdldE1ldGFkYXRhKGtleVN0cik7XG4gIGlmICghbWV0YWRhdGEpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGJhc2VNZXRhZGF0YSA9IHtcbiAgICAgIGtleToga2V5U3RyLFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZTogZXN0aW1hdGVWYWx1ZVNpemUodilcbiAgICB9O1xuICAgIGF3YWl0IGNhY2hlTWFwLnNldE1ldGFkYXRhKGtleVN0ciwgYmFzZU1ldGFkYXRhKTtcbiAgfVxuXG4gIC8vIFNldCBUVEwgbWV0YWRhdGEgZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICBhd2FpdCB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gIC8vIEhhbmRsZSBldmljdGlvbiBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gIGNvbnN0IGV2aWN0ZWRLZXlzID0gYXdhaXQgZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdiwgY2FjaGVNYXApO1xuICAvLyBSZW1vdmUgZXZpY3RlZCBpdGVtcyBmcm9tIGNhY2hlXG4gIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgYXdhaXQgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gIH1cblxuICAvLyBFbWl0IGV2ZW50XG4gIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuaXRlbVNldChrZXksIHYgYXMgViwgcHJldmlvdXNJdGVtKTtcbiAgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQpO1xuXG4gIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyh2LCBwa1R5cGUpIGFzIFZdO1xufTtcbiIsImltcG9ydCB7XG4gIEFsbEl0ZW1UeXBlQXJyYXlzLFxuICBDb21LZXksXG4gIGlzQ29tS2V5LFxuICBpc1F1ZXJ5TWF0Y2gsXG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlTWFwIH0gZnJvbSBcIi4uL0NhY2hlTWFwXCI7XG5pbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSB9IGZyb20gXCIuLi9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5XCI7XG5pbXBvcnQgeyBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uLCBpc0xvY0tleUFycmF5RXF1YWwsIFF1ZXJ5Q2FjaGVFbnRyeSB9IGZyb20gXCIuLi9ub3JtYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBlc3RpbWF0ZVZhbHVlU2l6ZSB9IGZyb20gXCIuLi91dGlscy9DYWNoZVNpemVcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiTWVtb3J5Q2FjaGVNYXBcIik7XG5cbmludGVyZmFjZSBEaWN0aW9uYXJ5RW50cnk8SywgVj4ge1xuICBvcmlnaW5hbEtleTogSztcbiAgdmFsdWU6IFY7XG59XG5cbi8qKlxuICogSW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIENhY2hlTWFwIHVzaW5nIGEgcGxhaW4gb2JqZWN0IGFzIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UuXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHN0b3JlcyBhbGwgZGF0YSBpbiBtZW1vcnkgYW5kIHdpbGwgYmUgbG9zdCB3aGVuIHRoZSBhcHBsaWNhdGlvbiByZXN0YXJ0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1lbW9yeUNhY2hlTWFwPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IGV4dGVuZHMgQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG5cbiAgcHVibGljIHJlYWRvbmx5IGltcGxlbWVudGF0aW9uVHlwZSA9IFwibWVtb3J5L21lbW9yeVwiO1xuXG4gIHByaXZhdGUgbWFwOiB7IFtrZXk6IHN0cmluZ106IERpY3Rpb25hcnlFbnRyeTxDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgVj4gfSA9IHt9O1xuICBwcml2YXRlIG5vcm1hbGl6ZWRIYXNoRnVuY3Rpb246IChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KSA9PiBzdHJpbmc7XG5cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hlOiBtYXBzIHF1ZXJ5IGhhc2ggdG8gY2FjaGUgZW50cnlcbiAgcHJpdmF0ZSBxdWVyeVJlc3VsdENhY2hlOiB7IFtxdWVyeUhhc2g6IHN0cmluZ106IFF1ZXJ5Q2FjaGVFbnRyeSB9ID0ge307XG5cbiAgLy8gTWV0YWRhdGEgc3RvcmFnZSBmb3IgZXZpY3Rpb24gc3RyYXRlZ2llc1xuICBwcml2YXRlIG1ldGFkYXRhTWFwOiBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4gPSBuZXcgTWFwKCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHR5cGVzOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGluaXRpYWxEYXRhPzogeyBba2V5OiBzdHJpbmddOiBWIH1cbiAgKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb248Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4+KCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHdpdGggZGF0YSBpZiBwcm92aWRlZFxuICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgZm9yIChjb25zdCBba2V5U3RyLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdGlhbERhdGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5wYXJzZShrZXlTdHIpIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+O1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGluaXRpYWwgZGF0YSBrZXknLCB7IGtleVN0ciwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICk6IFByb21pc2U8ViB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldCcsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcblxuICAgIGlmIChlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXkpIHtcbiAgICAgIC8vIFVwZGF0ZSBtZXRhZGF0YSBmb3IgYWNjZXNzIHRyYWNraW5nXG4gICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhTWFwLmdldChrZXlTdHIpO1xuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIHZhbHVlOiBWKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXQnLCB7IGtleSwgdmFsdWUgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcblxuICAgIC8vIENyZWF0ZSBvciB1cGRhdGUgdGhlIGl0ZW0gZW50cnlcbiAgICB0aGlzLm1hcFtoYXNoZWRLZXldID0geyBvcmlnaW5hbEtleToga2V5LCB2YWx1ZTogdmFsdWUgfTtcblxuICAgIC8vIENyZWF0ZSBtZXRhZGF0YSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCF0aGlzLm1ldGFkYXRhTWFwLmhhcyhrZXlTdHIpKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhID0ge1xuICAgICAgICBrZXk6IGtleVN0cixcbiAgICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgICAgZXN0aW1hdGVkU2l6ZTogZXN0aW1hdGVWYWx1ZVNpemUodmFsdWUpXG4gICAgICB9O1xuICAgICAgdGhpcy5tZXRhZGF0YU1hcC5zZXQoa2V5U3RyLCBtZXRhZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBtZXRhZGF0YVxuICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhTWFwLmdldChrZXlTdHIpITtcbiAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICBtZXRhZGF0YS5lc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbmNsdWRlc0tleShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiAhIWVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGUoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlJywgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIGlmIChlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXkpIHtcbiAgICAgIC8vIFJlbW92ZSBhc3NvY2lhdGVkIG1ldGFkYXRhIHVzaW5nIHRoZSBvcmlnaW5hbCBrZXkgcmVwcmVzZW50YXRpb25cbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgICAgIHRoaXMubWV0YWRhdGFNYXAuZGVsZXRlKGtleVN0cik7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuXG4gICAgICAvLyBSZW1vdmUgdGhpcyBrZXkgZnJvbSBhbnkgY2FjaGVkIHF1ZXJ5IHJlc3VsdHNcbiAgICAgIGZvciAoY29uc3QgW3F1ZXJ5SGFzaCwgY2FjaGVFbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5xdWVyeVJlc3VsdENhY2hlKSkge1xuICAgICAgICBjYWNoZUVudHJ5Lml0ZW1LZXlzID0gY2FjaGVFbnRyeS5pdGVtS2V5cy5maWx0ZXIoayA9PiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oaykgIT09IGhhc2hlZEtleSk7XG4gICAgICAgIGlmIChjYWNoZUVudHJ5Lml0ZW1LZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBrZXlzKCk6IFByb21pc2U8KENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdPiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcChlbnRyeSA9PiBlbnRyeS5vcmlnaW5hbEtleSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdmFsdWVzKCk6IFByb21pc2U8VltdPiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcChlbnRyeSA9PiBlbnRyeS52YWx1ZSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICAvLyBDbGVhciByZWxhdGVkIG1ldGFkYXRhIGFuZCBxdWVyeSByZXN1bHRzIHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xuICAgIHRoaXMubWV0YWRhdGFNYXAuY2xlYXIoKTtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhbGxJbihcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApOiBQcm9taXNlPFZbXT4ge1xuICAgIGNvbnN0IGFsbFZhbHVlcyA9IGF3YWl0IHRoaXMudmFsdWVzKCk7XG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUmV0dXJuaW5nIGFsbCBpdGVtcywgTG9jS2V5cyBpcyBlbXB0eScpO1xuICAgICAgcmV0dXJuIGFsbFZhbHVlcztcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdhbGxJbicsIHsgbG9jYXRpb25zLCBjb3VudDogYWxsVmFsdWVzLmxlbmd0aCB9KTtcbiAgICAgIHJldHVybiBhbGxWYWx1ZXMuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBpdGVtLmtleTtcbiAgICAgICAgaWYgKGtleSAmJiBpc0NvbUtleShrZXkpKSB7XG4gICAgICAgICAgY29uc3QgY29tS2V5ID0ga2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jYXRpb25zLCBjb21LZXkubG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY29udGFpbnMocXVlcnk6IEl0ZW1RdWVyeSwgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2NvbnRhaW5zJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuXG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHF1ZXJ5SW4oXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdxdWVyeUluJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuXG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xvbmUoKTogUHJvbWlzZTxNZW1vcnlDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PiB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgTWVtb3J5Q2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pih0aGlzLnR5cGVzKTtcbiAgICAvLyBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY29weSBvZiB0aGUgbWFwLlxuICAgIC8vIFRoaXMgaXMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGVudHJpZXMsIHNvIGl0ZW1zIHRoZW1zZWx2ZXMgYXJlIG5vdCBkZWVwLWNsb25lZC5cbiAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5rZXlzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgLy8gZ2V0KCkgd2lsbCB1c2UgdGhlIGNvcnJlY3Qgbm9ybWFsaXplZCByZXRyaWV2YWxcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSkgeyAvLyBTaG91bGQgaGFuZGxlIG51bGwvdW5kZWZpbmVkIHZhbHVlcyBpZiB0aGV5IGNhbiBiZSBzZXRcbiAgICAgICAgYXdhaXQgY2xvbmUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvcHkgcXVlcnkgcmVzdWx0IGNhY2hlXG4gICAgZm9yIChjb25zdCBbcXVlcnlIYXNoLCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5xdWVyeVJlc3VsdENhY2hlKSkge1xuICAgICAgY2xvbmUucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdID0ge1xuICAgICAgICBpdGVtS2V5czogWy4uLmVudHJ5Lml0ZW1LZXlzXSAvLyBTaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxuICBwdWJsaWMgYXN5bmMgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcsIGl0ZW1LZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuXG4gICAgY29uc3QgZW50cnk6IFF1ZXJ5Q2FjaGVFbnRyeSA9IHtcbiAgICAgIGl0ZW1LZXlzOiBbLi4uaXRlbUtleXNdIC8vIENyZWF0ZSBhIGNvcHkgdG8gYXZvaWQgZXh0ZXJuYWwgbXV0YXRpb25zXG4gICAgfTtcblxuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdID0gZW50cnk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBbLi4uZW50cnkuaXRlbUtleXNdOyAvLyBSZXR1cm4gYSBjb3B5IHRvIGF2b2lkIGV4dGVybmFsIG11dGF0aW9uc1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICByZXR1cm4gISFlbnRyeTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlUXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBkZWxldGUgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnaW52YWxpZGF0ZUl0ZW1LZXlzJywgeyBrZXlzIH0pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGludmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnaW52YWxpZGF0ZUxvY2F0aW9uJywgeyBsb2NhdGlvbnMgfSk7XG5cbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRm9yIHByaW1hcnkgaXRlbXMgKG5vIGxvY2F0aW9uKSwgY2xlYXIgYWxsIHByaW1hcnkga2V5c1xuICAgICAgY29uc3QgYWxsS2V5cyA9IGF3YWl0IHRoaXMua2V5cygpO1xuICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBhbGxLZXlzLmZpbHRlcihrZXkgPT4gIWlzQ29tS2V5KGtleSkpO1xuICAgICAgYXdhaXQgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMocHJpbWFyeUtleXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgY29udGFpbmVkIGl0ZW1zLCBnZXQgYWxsIGl0ZW1zIGluIHRoZSBsb2NhdGlvbiBhbmQgaW52YWxpZGF0ZSB0aGVtXG4gICAgICBjb25zdCBpdGVtc0luTG9jYXRpb24gPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgICBjb25zdCBrZXlzVG9JbnZhbGlkYXRlID0gaXRlbXNJbkxvY2F0aW9uLm1hcChpdGVtID0+IGl0ZW0ua2V5KTtcbiAgICAgIGF3YWl0IHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXNUb0ludmFsaWRhdGUpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFsbCBxdWVyeSByZXN1bHRzIHRoYXQgbWlnaHQgYmUgYWZmZWN0ZWRcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBjbGVhciBhbGwgcXVlcnkgcmVzdWx0cyB0byBiZSBzYWZlXG4gICAgLy8gQSBtb3JlIHNvcGhpc3RpY2F0ZWQgYXBwcm9hY2ggd291bGQgYmUgdG8gdHJhY2sgd2hpY2ggcXVlcmllcyBhcmUgbG9jYXRpb24tc3BlY2lmaWNcbiAgICBhd2FpdCB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXJRdWVyeVJlc3VsdHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdjbGVhclF1ZXJ5UmVzdWx0cycpO1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICB9XG5cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIHB1YmxpYyBhc3luYyBnZXRNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8Q2FjaGVJdGVtTWV0YWRhdGEgfCBudWxsPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXRNZXRhZGF0YShrZXk6IHN0cmluZywgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5zZXQoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlTWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldEFsbE1ldGFkYXRhKCk6IFByb21pc2U8TWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+PiB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5tZXRhZGF0YU1hcCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXJNZXRhZGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLmNsZWFyKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0Q3VycmVudFNpemUoKTogUHJvbWlzZTx7IGl0ZW1Db3VudDogbnVtYmVyOyBzaXplQnl0ZXM6IG51bWJlciB9PiB7XG4gICAgbGV0IHNpemVCeXRlcyA9IDA7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBPYmplY3QudmFsdWVzKHRoaXMubWFwKSkge1xuICAgICAgc2l6ZUJ5dGVzICs9IGVzdGltYXRlVmFsdWVTaXplKGVudHJ5LnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUNvdW50OiBPYmplY3Qua2V5cyh0aGlzLm1hcCkubGVuZ3RoLFxuICAgICAgc2l6ZUJ5dGVzXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRTaXplTGltaXRzKCk6IFByb21pc2U8eyBtYXhJdGVtczogbnVtYmVyIHwgbnVsbDsgbWF4U2l6ZUJ5dGVzOiBudW1iZXIgfCBudWxsIH0+IHtcbiAgICAvLyBCYXNpYyBNZW1vcnlDYWNoZU1hcCBoYXMgbm8gc2l6ZSBsaW1pdHNcbiAgICByZXR1cm4ge1xuICAgICAgbWF4SXRlbXM6IG51bGwsXG4gICAgICBtYXhTaXplQnl0ZXM6IG51bGxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBBbGxJdGVtVHlwZUFycmF5cyxcbiAgQ29tS2V5LFxuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSwgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIH0gZnJvbSBcIi4vZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneVwiO1xuaW1wb3J0IHsgQ2FjaGVJbmZvIH0gZnJvbSBcIi4vQ2FjaGVcIjtcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGludGVyZmFjZSBmb3IgY2FjaGUgbWFwIGltcGxlbWVudGF0aW9ucy5cbiAqIERlZmluZXMgdGhlIGNvbnRyYWN0IHRoYXQgYWxsIGNhY2hlIG1hcCBpbXBsZW1lbnRhdGlvbnMgbXVzdCBmb2xsb3cuXG4gKlxuICogQHRlbXBsYXRlIFYgLSBUaGUgdHlwZSBvZiB0aGUgZGF0YSBtb2RlbCBpdGVtLCBleHRlbmRpbmcgSXRlbVxuICogQHRlbXBsYXRlIFMgLSBUaGUgc3RyaW5nIGxpdGVyYWwgdHlwZSByZXByZXNlbnRpbmcgdGhlIG1vZGVsJ3Mga2V5IHR5cGVcbiAqIEB0ZW1wbGF0ZSBMMS1MNSAtIE9wdGlvbmFsIHN0cmluZyBsaXRlcmFsIHR5cGVzIGZvciBsb2NhdGlvbiBoaWVyYXJjaHkgbGV2ZWxzXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYWNoZU1hcDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiBpbXBsZW1lbnRzIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciB7XG4gIHByb3RlY3RlZCB0eXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKipcbiAgICogVGhlIGltcGxlbWVudGF0aW9uIHR5cGUgaWRlbnRpZmllciBpbiB0aGUgZm9ybWF0IFwiPGNhdGVnb3J5Pi88aW1wbGVtZW50YXRpb24+XCJcbiAgICogRXhhbXBsZXM6IFwibWVtb3J5L21lbW9yeVwiLCBcIm1lbW9yeS9lbmhhbmNlZFwiLCBcImJyb3dzZXIvbG9jYWxTdG9yYWdlXCJcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBpbXBsZW1lbnRhdGlvblR5cGU6IHN0cmluZztcblxuICBwdWJsaWMgY29uc3RydWN0b3IodHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pIHtcbiAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYW4gaXRlbSBieSBpdHMga2V5XG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPFYgfCBudWxsPjtcblxuICAvKipcbiAgICogU3RvcmUgYW4gaXRlbSB3aXRoIGl0cyBrZXlcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBzZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgdmFsdWU6IFYpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtleSBleGlzdHMgaW4gdGhlIGNhY2hlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgaW5jbHVkZXNLZXkoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBpdGVtIGJ5IGl0cyBrZXlcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBkZWxldGUoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgaXRlbXMgaW4gdGhlIHNwZWNpZmllZCBsb2NhdGlvbnNcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBhbGxJbihsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8VltdPjtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW55IGl0ZW1zIG1hdGNoIHRoZSBxdWVyeSBpbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uc1xuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGNvbnRhaW5zKHF1ZXJ5OiBJdGVtUXVlcnksIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogR2V0IGFsbCBpdGVtcyB0aGF0IG1hdGNoIHRoZSBxdWVyeSBpbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uc1xuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHF1ZXJ5SW4ocXVlcnk6IEl0ZW1RdWVyeSwgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPFZbXT47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgY2FjaGUgbWFwXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgY2xvbmUoKTogUHJvbWlzZTxDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PjtcblxuICAvKipcbiAgICogR2V0IGFsbCBrZXlzIGluIHRoZSBjYWNoZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGtleXMoKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10+O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHZhbHVlcyBpbiB0aGUgY2FjaGVcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCB2YWx1ZXMoKTogUHJvbWlzZTxWW10+O1xuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSB0aGUgY2FjaGVcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBjbGVhcigpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHNcblxuICAvKipcbiAgICogU2V0IGEgcXVlcnkgcmVzdWx0IGFzIGEgY29sbGVjdGlvbiBvZiBpdGVtIGtleXNcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZywgaXRlbUtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEdldCBhIHF1ZXJ5IHJlc3VsdCBhcyBhIGNvbGxlY3Rpb24gb2YgaXRlbSBrZXlzXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSB8IG51bGw+O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHF1ZXJ5IHJlc3VsdCBleGlzdHMgaW4gY2FjaGVcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBoYXNRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHNwZWNpZmljIHF1ZXJ5IHJlc3VsdFxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogSW52YWxpZGF0ZSBhbGwgY2FjaGVkIGl0ZW1zIGJ5IHRoZWlyIGtleXNcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBpbnZhbGlkYXRlSXRlbUtleXMoa2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogSW52YWxpZGF0ZSBhbGwgaXRlbXMgaW4gc3BlY2lmaWVkIGxvY2F0aW9ucyBhbmQgY2xlYXIgcmVsYXRlZCBxdWVyeSByZXN1bHRzXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIHF1ZXJ5IHJlc3VsdCBjYWNoZSBlbnRyaWVzXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgY2xlYXJRdWVyeVJlc3VsdHMoKTogUHJvbWlzZTx2b2lkPjtcblxuICAvLyBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgLy8gVGhlc2UgbWV0aG9kcyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGFsbCBDYWNoZU1hcCBpbXBsZW1lbnRhdGlvbnMgdG8gc3VwcG9ydCBldmljdGlvblxuXG4gIC8qKlxuICAgKiBHZXQgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgaXRlbVxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHJldHVybnMgTWV0YWRhdGEgaWYgZXhpc3RzLCBudWxsIG90aGVyd2lzZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGdldE1ldGFkYXRhKGtleTogc3RyaW5nKTogUHJvbWlzZTxDYWNoZUl0ZW1NZXRhZGF0YSB8IG51bGw+O1xuXG4gIC8qKlxuICAgKiBTZXQgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgaXRlbVxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgdG8gc3RvcmVcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBzZXRNZXRhZGF0YShrZXk6IHN0cmluZywgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogRGVsZXRlIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGl0ZW1cbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZGVsZXRlTWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIG1ldGFkYXRhIGVudHJpZXNcbiAgICogQHJldHVybnMgTWFwIG9mIGFsbCBtZXRhZGF0YSBlbnRyaWVzXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0QWxsTWV0YWRhdGEoKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4+O1xuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgbWV0YWRhdGFcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBjbGVhck1ldGFkYXRhKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGNhY2hlIHNpemUgaW5mb3JtYXRpb25cbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggY3VycmVudCBzaXplIG1ldHJpY3NcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBnZXRDdXJyZW50U2l6ZSgpOiBQcm9taXNlPHtcbiAgICBpdGVtQ291bnQ6IG51bWJlcjtcbiAgICBzaXplQnl0ZXM6IG51bWJlcjtcbiAgfT47XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzaXplIGxpbWl0c1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBzaXplIGxpbWl0cyAobnVsbCBtZWFucyB1bmxpbWl0ZWQpXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0U2l6ZUxpbWl0cygpOiBQcm9taXNlPHtcbiAgICBtYXhJdGVtczogbnVtYmVyIHwgbnVsbDtcbiAgICBtYXhTaXplQnl0ZXM6IG51bWJlciB8IG51bGw7XG4gIH0+O1xufVxuIiwiaW1wb3J0IHtcbiAgQWxsSXRlbVR5cGVBcnJheXMsXG4gIENvbUtleSxcbiAgaXNDb21LZXksXG4gIGlzUXVlcnlNYXRjaCxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tIFwiLi4vQ2FjaGVNYXBcIjtcbmltcG9ydCB7IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sIGlzTG9jS2V5QXJyYXlFcXVhbCwgUXVlcnlDYWNoZUVudHJ5IH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IENhY2hlU2l6ZUNvbmZpZyB9IGZyb20gXCIuLi9PcHRpb25zXCI7XG5pbXBvcnQge1xuICBDYWNoZUl0ZW1NZXRhZGF0YVxufSBmcm9tIFwiLi4vZXZpY3Rpb25cIjtcbmltcG9ydCB7IGVzdGltYXRlVmFsdWVTaXplLCBwYXJzZVNpemVTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvQ2FjaGVTaXplXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIkVuaGFuY2VkTWVtb3J5Q2FjaGVNYXBcIik7XG5cbmludGVyZmFjZSBFbmhhbmNlZERpY3Rpb25hcnlFbnRyeTxLLCBWPiB7XG4gIG9yaWdpbmFsS2V5OiBLO1xuICB2YWx1ZTogVjtcbiAgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhO1xuICBtZXRhZGF0YUNsZWFyZWQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBDYWNoZU1hcCB3aXRoIHNpemUgbGltaXRzIGFuZCBldmljdGlvbiBwb2xpY2llcy5cbiAqIFN1cHBvcnRzIGJ5dGUtYmFzZWQgYW5kIGl0ZW0tY291bnQgbGltaXRzIHdpdGggY29uZmlndXJhYmxlIGV2aWN0aW9uIHN0cmF0ZWdpZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmhhbmNlZE1lbW9yeUNhY2hlTWFwPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IGV4dGVuZHMgQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG5cbiAgcHVibGljIHJlYWRvbmx5IGltcGxlbWVudGF0aW9uVHlwZSA9IFwibWVtb3J5L2VuaGFuY2VkXCI7XG5cbiAgcHJpdmF0ZSBtYXA6IHsgW2tleTogc3RyaW5nXTogRW5oYW5jZWREaWN0aW9uYXJ5RW50cnk8Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIFY+IH0gPSB7fTtcbiAgcHJpdmF0ZSBub3JtYWxpemVkSGFzaEZ1bmN0aW9uOiAoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPikgPT4gc3RyaW5nO1xuXG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoZTogbWFwcyBxdWVyeSBoYXNoIHRvIGNhY2hlIGVudHJ5XG4gIHByaXZhdGUgcXVlcnlSZXN1bHRDYWNoZTogeyBbcXVlcnlIYXNoOiBzdHJpbmddOiBRdWVyeUNhY2hlRW50cnkgfSA9IHt9O1xuXG4gIC8vIFNpemUgdHJhY2tpbmdcbiAgcHJpdmF0ZSBjdXJyZW50U2l6ZUJ5dGVzOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGN1cnJlbnRJdGVtQ291bnQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgcXVlcnlSZXN1bHRzQ2FjaGVTaXplOiBudW1iZXIgPSAwO1xuXG4gIC8vIFNpemUgbGltaXRzXG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4U2l6ZUJ5dGVzPzogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IG1heEl0ZW1zPzogbnVtYmVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICB0eXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBzaXplQ29uZmlnPzogQ2FjaGVTaXplQ29uZmlnLFxuICAgIGluaXRpYWxEYXRhPzogeyBba2V5OiBzdHJpbmddOiBWIH1cbiAgKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb248Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4+KCk7XG5cbiAgICAvLyBQYXJzZSBzaXplIGNvbmZpZ3VyYXRpb25cbiAgICBpZiAoc2l6ZUNvbmZpZz8ubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICB0aGlzLm1heFNpemVCeXRlcyA9IHBhcnNlU2l6ZVN0cmluZyhzaXplQ29uZmlnLm1heFNpemVCeXRlcyk7XG4gICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlIHNpemUgbGltaXQgc2V0JywgeyBtYXhTaXplQnl0ZXM6IHRoaXMubWF4U2l6ZUJ5dGVzIH0pO1xuICAgIH1cblxuICAgIGlmIChzaXplQ29uZmlnPy5tYXhJdGVtcykge1xuICAgICAgdGhpcy5tYXhJdGVtcyA9IHNpemVDb25maWcubWF4SXRlbXM7XG4gICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlIGl0ZW0gbGltaXQgc2V0JywgeyBtYXhJdGVtczogdGhpcy5tYXhJdGVtcyB9KTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiBFdmljdGlvbiBpcyBoYW5kbGVkIGV4dGVybmFsbHkgLSB0aGlzIGNhY2hlIG1hcCBvbmx5IHByb3ZpZGVzIG1ldGFkYXRhIGFjY2Vzc1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGRhdGEgaWYgcHJvdmlkZWRcbiAgICBpZiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleVN0ciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGluaXRpYWxEYXRhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IEpTT04ucGFyc2Uoa2V5U3RyKSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPjtcbiAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBpbml0aWFsIGRhdGEga2V5JywgeyBrZXlTdHIsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApOiBQcm9taXNlPFYgfCBudWxsPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdnZXQnLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG5cbiAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgQU5EIHRoZSBub3JtYWxpemVkIGtleXMgbWF0Y2ggQU5EIGhhcyBhIHJlYWwgdmFsdWVcbiAgICBpZiAoZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5ICYmIGVudHJ5LnZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIHZhbHVlOiBWKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXQnLCB7IGtleSwgdmFsdWUgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKHZhbHVlKTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gdXBkYXRlIHRvIGV4aXN0aW5nIGVudHJ5XG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgY29uc3QgaXNVcGRhdGUgPSBleGlzdGluZ0VudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihleGlzdGluZ0VudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5O1xuXG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgZW50cnlcbiAgICAgIGNvbnN0IHNpemVEaWZmID0gZXN0aW1hdGVkU2l6ZSAtIGV4aXN0aW5nRW50cnkubWV0YWRhdGEuZXN0aW1hdGVkU2l6ZTtcbiAgICAgIHRoaXMuY3VycmVudFNpemVCeXRlcyArPSBzaXplRGlmZjtcblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBleGlzdGluZ0VudHJ5LnZhbHVlO1xuICAgICAgZXhpc3RpbmdFbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgZXhpc3RpbmdFbnRyeS5tZXRhZGF0YS5lc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVkU2l6ZTtcblxuICAgICAgbG9nZ2VyLnRyYWNlKCdVcGRhdGVkIGV4aXN0aW5nIGNhY2hlIGVudHJ5Jywge1xuICAgICAgICBrZXk6IGhhc2hlZEtleSxcbiAgICAgICAgc2l6ZURpZmYsXG4gICAgICAgIGN1cnJlbnRTaXplOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXMsXG4gICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSAhPT0gdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IGVudHJ5XG4gICAgICBjb25zdCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEgPSB7XG4gICAgICAgIGFkZGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIGxhc3RBY2Nlc3NlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBhY2Nlc3NDb3VudDogMCxcbiAgICAgICAgZXN0aW1hdGVkU2l6ZTogZXN0aW1hdGVkU2l6ZSxcbiAgICAgICAga2V5OiBoYXNoZWRLZXlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7XG4gICAgICAgIG9yaWdpbmFsS2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY3VycmVudFNpemVCeXRlcyArPSBlc3RpbWF0ZWRTaXplO1xuICAgICAgdGhpcy5jdXJyZW50SXRlbUNvdW50Kys7XG5cbiAgICAgIGxvZ2dlci50cmFjZSgnQWRkZWQgbmV3IGNhY2hlIGVudHJ5Jywge1xuICAgICAgICBrZXk6IGhhc2hlZEtleSxcbiAgICAgICAgc2l6ZTogZXN0aW1hdGVkU2l6ZSxcbiAgICAgICAgY3VycmVudFNpemU6IHRoaXMuY3VycmVudFNpemVCeXRlcyxcbiAgICAgICAgY3VycmVudENvdW50OiB0aGlzLmN1cnJlbnRJdGVtQ291bnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbmNsdWRlc0tleShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiAhIWVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSAmJiBlbnRyeS52YWx1ZSAhPT0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGUoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuZGVsZXRlSW50ZXJuYWwoa2V5LCB0cnVlLCAnZmlsdGVyJyk7XG4gIH1cblxuICBwcml2YXRlIGRlbGV0ZUludGVybmFsKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIGludmFsaWRhdGVRdWVyaWVzOiBib29sZWFuID0gZmFsc2UsIGludmFsaWRhdGlvbk1vZGU6ICdmaWx0ZXInIHwgJ3JlbW92ZScgPSAncmVtb3ZlJyk6IHZvaWQge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlJywgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuXG4gICAgaWYgKGVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSkge1xuICAgICAgdGhpcy5jdXJyZW50U2l6ZUJ5dGVzIC09IGVudHJ5Lm1ldGFkYXRhLmVzdGltYXRlZFNpemU7XG4gICAgICB0aGlzLmN1cnJlbnRJdGVtQ291bnQtLTtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuXG4gICAgICBsb2dnZXIudHJhY2UoJ0RlbGV0ZWQgY2FjaGUgZW50cnknLCB7XG4gICAgICAgIGtleTogaGFzaGVkS2V5LFxuICAgICAgICBmcmVlZFNpemU6IGVudHJ5Lm1ldGFkYXRhLmVzdGltYXRlZFNpemUsXG4gICAgICAgIGN1cnJlbnRTaXplOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXMsXG4gICAgICAgIGN1cnJlbnRDb3VudDogdGhpcy5jdXJyZW50SXRlbUNvdW50XG4gICAgICB9KTtcblxuICAgICAgLy8gSW52YWxpZGF0ZSBxdWVyaWVzIHRoYXQgcmVmZXJlbmNlIHRoaXMga2V5IG9ubHkgaWYgcmVxdWVzdGVkXG4gICAgICBpZiAoaW52YWxpZGF0ZVF1ZXJpZXMpIHtcbiAgICAgICAgaWYgKGludmFsaWRhdGlvbk1vZGUgPT09ICdmaWx0ZXInKSB7XG4gICAgICAgICAgdGhpcy5maWx0ZXJRdWVyaWVzUmVmZXJlbmNpbmdLZXlzKFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGVRdWVyaWVzUmVmZXJlbmNpbmdLZXlzKFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBrZXlzKCk6IFByb21pc2U8KENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdPiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApXG4gICAgICAuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LnZhbHVlICE9PSBudWxsKVxuICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5vcmlnaW5hbEtleSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdmFsdWVzKCk6IFByb21pc2U8VltdPiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApXG4gICAgICAuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LnZhbHVlICE9PSBudWxsKVxuICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS52YWx1ZSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdDbGVhcmluZyBjYWNoZScsIHtcbiAgICAgIGl0ZW1zQ2xlYXJlZDogdGhpcy5jdXJyZW50SXRlbUNvdW50LFxuICAgICAgYnl0ZXNGcmVlZDogdGhpcy5jdXJyZW50U2l6ZUJ5dGVzXG4gICAgfSk7XG5cbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMuY3VycmVudFNpemVCeXRlcyA9IDA7XG4gICAgdGhpcy5jdXJyZW50SXRlbUNvdW50ID0gMDtcbiAgICAvLyBOb3RlOiBRdWVyeSByZXN1bHRzIGFyZSBwcmVzZXJ2ZWQgd2hlbiBjbGVhcmluZyBjYWNoZSBpdGVtc1xuICAgIC8vIFVzZSBjbGVhclF1ZXJ5UmVzdWx0cygpIHNlcGFyYXRlbHkgaWYgeW91IG5lZWQgdG8gY2xlYXIgcXVlcnkgY2FjaGUgYXMgd2VsbFxuICB9XG5cbiAgcHVibGljIGFzeW5jIGFsbEluKFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8VltdPiB7XG4gICAgY29uc3QgYWxsVmFsdWVzID0gYXdhaXQgdGhpcy52YWx1ZXMoKTtcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5Jyk7XG4gICAgICByZXR1cm4gYWxsVmFsdWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ2FsbEluJywgeyBsb2NhdGlvbnMsIGNvdW50OiBhbGxWYWx1ZXMubGVuZ3RoIH0pO1xuICAgICAgcmV0dXJuIGFsbFZhbHVlcy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgICBpZiAoa2V5ICYmIGlzQ29tS2V5KGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gaXNMb2NLZXlBcnJheUVxdWFsKGxvY2F0aW9ucywgKGtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PikubG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY29udGFpbnMocXVlcnk6IEl0ZW1RdWVyeSwgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2NvbnRhaW5zJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5zb21lKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2goaXRlbSwgcXVlcnkpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBxdWVyeUluKFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFZbXT4ge1xuICAgIGxvZ2dlci5kZWJ1ZygncXVlcnlJbicsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2goaXRlbSwgcXVlcnkpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbG9uZSgpOiBQcm9taXNlPENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+IHtcbiAgICBjb25zdCBzaXplQ29uZmlnOiBDYWNoZVNpemVDb25maWcgPSB7fTtcbiAgICBpZiAodGhpcy5tYXhTaXplQnl0ZXMpIHtcbiAgICAgIHNpemVDb25maWcubWF4U2l6ZUJ5dGVzID0gdGhpcy5tYXhTaXplQnl0ZXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4SXRlbXMpIHtcbiAgICAgIHNpemVDb25maWcubWF4SXRlbXMgPSB0aGlzLm1heEl0ZW1zO1xuICAgIH1cblxuICAgIGNvbnN0IGNsb25lID0gbmV3IEVuaGFuY2VkTWVtb3J5Q2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pih0aGlzLnR5cGVzLCBzaXplQ29uZmlnKTtcblxuICAgIC8vIENvcHkgZW50cmllcyAodGhpcyB3aWxsIHRyaWdnZXIgcHJvcGVyIHNpemUgdHJhY2tpbmcpXG4gICAgY29uc3Qga2V5cyA9IGF3YWl0IHRoaXMua2V5cygpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBhd2FpdCBjbG9uZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29weSBxdWVyeSByZXN1bHRzXG4gICAgZm9yIChjb25zdCBbcXVlcnlIYXNoLCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5xdWVyeVJlc3VsdENhY2hlKSkge1xuICAgICAgYXdhaXQgY2xvbmUuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBlbnRyeS5pdGVtS2V5cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGNhY2hlIHN0YXRpc3RpY3NcbiAgICovXG4gIHB1YmxpYyBnZXRTdGF0cygpOiB7XG4gICAgY3VycmVudFNpemVCeXRlczogbnVtYmVyO1xuICAgIGN1cnJlbnRJdGVtQ291bnQ6IG51bWJlcjtcbiAgICBtYXhTaXplQnl0ZXM/OiBudW1iZXI7XG4gICAgbWF4SXRlbXM/OiBudW1iZXI7XG4gICAgdXRpbGl6YXRpb25QZXJjZW50OiB7XG4gICAgICBieXRlcz86IG51bWJlcjtcbiAgICAgIGl0ZW1zPzogbnVtYmVyO1xuICAgIH07XG4gICAgfSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICBjdXJyZW50U2l6ZUJ5dGVzOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXMsXG4gICAgICBjdXJyZW50SXRlbUNvdW50OiB0aGlzLmN1cnJlbnRJdGVtQ291bnQsXG4gICAgICBtYXhTaXplQnl0ZXM6IHRoaXMubWF4U2l6ZUJ5dGVzLFxuICAgICAgbWF4SXRlbXM6IHRoaXMubWF4SXRlbXMsXG4gICAgICB1dGlsaXphdGlvblBlcmNlbnQ6IHt9IGFzIHsgYnl0ZXM/OiBudW1iZXI7IGl0ZW1zPzogbnVtYmVyIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICBzdGF0cy51dGlsaXphdGlvblBlcmNlbnQuYnl0ZXMgPSAodGhpcy5jdXJyZW50U2l6ZUJ5dGVzIC8gdGhpcy5tYXhTaXplQnl0ZXMpICogMTAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1heEl0ZW1zKSB7XG4gICAgICBzdGF0cy51dGlsaXphdGlvblBlcmNlbnQuaXRlbXMgPSAodGhpcy5jdXJyZW50SXRlbUNvdW50IC8gdGhpcy5tYXhJdGVtcykgKiAxMDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG5cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kc1xuICBwdWJsaWMgYXN5bmMgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcsIGl0ZW1LZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGVudHJ5IHRvIGdldCBhY2N1cmF0ZSBzaXplIHRyYWNraW5nXG4gICAgaWYgKHF1ZXJ5SGFzaCBpbiB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlUXVlcnlSZXN1bHRGcm9tU2l6ZVRyYWNraW5nKHF1ZXJ5SGFzaCk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cnk6IFF1ZXJ5Q2FjaGVFbnRyeSA9IHtcbiAgICAgIGl0ZW1LZXlzOiBbLi4uaXRlbUtleXNdIC8vIENyZWF0ZSBhIGNvcHkgdG8gYXZvaWQgZXh0ZXJuYWwgbXV0YXRpb25zXG4gICAgfTtcblxuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdID0gZW50cnk7XG4gICAgdGhpcy5hZGRRdWVyeVJlc3VsdFRvU2l6ZVRyYWNraW5nKHF1ZXJ5SGFzaCwgZW50cnkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10gfCBudWxsPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdnZXRRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoIH0pO1xuXG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBbLi4uZW50cnkuaXRlbUtleXNdOyAvLyBSZXR1cm4gYSBjb3B5IHRvIGF2b2lkIGV4dGVybmFsIG11dGF0aW9uc1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICByZXR1cm4gISFlbnRyeTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChxdWVyeUhhc2ggaW4gdGhpcy5xdWVyeVJlc3VsdENhY2hlKSB7XG4gICAgICB0aGlzLnJlbW92ZVF1ZXJ5UmVzdWx0RnJvbVNpemVUcmFja2luZyhxdWVyeUhhc2gpO1xuICAgICAgZGVsZXRlIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhclF1ZXJ5UmVzdWx0cygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZSA9IDA7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnaW52YWxpZGF0ZUl0ZW1LZXlzJywgeyBrZXlzIH0pO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBObyBrZXlzIHRvIGludmFsaWRhdGUsIHNvIG5vIHF1ZXJpZXMgc2hvdWxkIGJlIGFmZmVjdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIHRoZSBhY3R1YWwgY2FjaGUgZW50cmllcyB3aXRob3V0IHRyaWdnZXJpbmcgaW5kaXZpZHVhbCBxdWVyeSBpbnZhbGlkYXRpb25zXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgdGhpcy5kZWxldGVJbnRlcm5hbChrZXksIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYnVsayBpbnZhbGlkYXRpb24sIHJlbW92ZSBlbnRpcmUgcXVlcmllcyAoZG9uJ3QgZmlsdGVyKVxuICAgIHRoaXMuaW52YWxpZGF0ZVF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoa2V5cyk7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlclF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoa2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogdm9pZCB7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBrZXlzIHRvIHRoZWlyIGhhc2hlZCBmb3JtIGZvciBjb21wYXJpc29uXG4gICAgY29uc3QgaGFzaGVkS2V5c1RvSW52YWxpZGF0ZSA9IG5ldyBTZXQoa2V5cy5tYXAoa2V5ID0+IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSk7XG5cbiAgICAvLyBGaWx0ZXIgaW52YWxpZGF0ZWQga2V5cyBmcm9tIHF1ZXJ5IHJlc3VsdHMgaW5zdGVhZCBvZiByZW1vdmluZyBlbnRpcmUgcXVlcmllc1xuICAgIGNvbnN0IHF1ZXJpZXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtxdWVyeUhhc2gsIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpKSB7XG4gICAgICAvLyBGaWx0ZXIgb3V0IGludmFsaWRhdGVkIGtleXMgZnJvbSB0aGUgcXVlcnkgcmVzdWx0XG4gICAgICBjb25zdCBmaWx0ZXJlZEtleXMgPSBlbnRyeS5pdGVtS2V5cy5maWx0ZXIoaXRlbUtleSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZEl0ZW1LZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oaXRlbUtleSk7XG4gICAgICAgIHJldHVybiAhaGFzaGVkS2V5c1RvSW52YWxpZGF0ZS5oYXMoaGFzaGVkSXRlbUtleSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpbHRlcmVkS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgbm8ga2V5cyByZW1haW4gYWZ0ZXIgZmlsdGVyaW5nLCByZW1vdmUgdGhlIGVudGlyZSBxdWVyeVxuICAgICAgICBxdWVyaWVzVG9SZW1vdmUucHVzaChxdWVyeUhhc2gpO1xuICAgICAgfSBlbHNlIGlmIChmaWx0ZXJlZEtleXMubGVuZ3RoICE9PSBlbnRyeS5pdGVtS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgc29tZSBrZXlzIHdlcmUgZmlsdGVyZWQgb3V0LCB1cGRhdGUgdGhlIHF1ZXJ5IHdpdGggcmVtYWluaW5nIGtleXNcbiAgICAgICAgdGhpcy5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGZpbHRlcmVkS2V5cyk7XG4gICAgICB9XG4gICAgICAvLyBJZiBmaWx0ZXJlZEtleXMubGVuZ3RoID09PSBlbnRyeS5pdGVtS2V5cy5sZW5ndGgsIG5vIGNoYW5nZXMgbmVlZGVkXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHF1ZXJpZXMgdGhhdCBoYXZlIG5vIHZhbGlkIGtleXMgcmVtYWluaW5nXG4gICAgcXVlcmllc1RvUmVtb3ZlLmZvckVhY2gocXVlcnlIYXNoID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW52YWxpZGF0ZVF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoa2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogdm9pZCB7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBrZXlzIHRvIHRoZWlyIGhhc2hlZCBmb3JtIGZvciBjb21wYXJpc29uXG4gICAgY29uc3QgaGFzaGVkS2V5c1RvSW52YWxpZGF0ZSA9IG5ldyBTZXQoa2V5cy5tYXAoa2V5ID0+IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSk7XG5cbiAgICAvLyBDbGVhciBxdWVyeSByZXN1bHRzIHRoYXQgcmVmZXJlbmNlIGFueSBvZiB0aGUgaW52YWxpZGF0ZWQga2V5c1xuICAgIGNvbnN0IHF1ZXJpZXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtxdWVyeUhhc2gsIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpKSB7XG4gICAgICBjb25zdCBxdWVyeVJlZmVyZW5jZXNJbnZhbGlkYXRlZEtleSA9IGVudHJ5Lml0ZW1LZXlzLnNvbWUoaXRlbUtleSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZEl0ZW1LZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oaXRlbUtleSk7XG4gICAgICAgIHJldHVybiBoYXNoZWRLZXlzVG9JbnZhbGlkYXRlLmhhcyhoYXNoZWRJdGVtS2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocXVlcnlSZWZlcmVuY2VzSW52YWxpZGF0ZWRLZXkpIHtcbiAgICAgICAgcXVlcmllc1RvUmVtb3ZlLnB1c2gocXVlcnlIYXNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIGFmZmVjdGVkIHF1ZXJpZXNcbiAgICBxdWVyaWVzVG9SZW1vdmUuZm9yRWFjaChxdWVyeUhhc2ggPT4ge1xuICAgICAgdGhpcy5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGludmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnaW52YWxpZGF0ZUxvY2F0aW9uJywgeyBsb2NhdGlvbnMgfSk7XG5cbiAgICBsZXQga2V5c1RvSW52YWxpZGF0ZTogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdID0gW107XG5cbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRm9yIHByaW1hcnkgaXRlbXMgKG5vIGxvY2F0aW9uKSwgY2xlYXIgYWxsIHByaW1hcnkga2V5c1xuICAgICAgY29uc3QgYWxsS2V5cyA9IGF3YWl0IHRoaXMua2V5cygpO1xuICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBhbGxLZXlzLmZpbHRlcihrZXkgPT4gIWlzQ29tS2V5KGtleSkpO1xuICAgICAga2V5c1RvSW52YWxpZGF0ZSA9IHByaW1hcnlLZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgY29udGFpbmVkIGl0ZW1zLCBnZXQgYWxsIGl0ZW1zIGluIHRoZSBsb2NhdGlvbiBhbmQgaW52YWxpZGF0ZSB0aGVtXG4gICAgICBjb25zdCBpdGVtc0luTG9jYXRpb24gPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgICBrZXlzVG9JbnZhbGlkYXRlID0gaXRlbXNJbkxvY2F0aW9uLm1hcChpdGVtID0+IGl0ZW0ua2V5KTtcbiAgICB9XG5cbiAgICAvLyBVc2UgaW52YWxpZGF0ZUl0ZW1LZXlzIHdoaWNoIHdpbGwgc2VsZWN0aXZlbHkgY2xlYXIgb25seSBhZmZlY3RlZCBxdWVyaWVzXG4gICAgYXdhaXQgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMoa2V5c1RvSW52YWxpZGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHF1ZXJ5IHJlc3VsdCB0byBzaXplIHRyYWNraW5nXG4gICAqL1xuICBwcml2YXRlIGFkZFF1ZXJ5UmVzdWx0VG9TaXplVHJhY2tpbmcocXVlcnlIYXNoOiBzdHJpbmcsIGVudHJ5OiBRdWVyeUNhY2hlRW50cnkpOiB2b2lkIHtcbiAgICAvLyBFc3RpbWF0ZSBzaXplOiBxdWVyeUhhc2ggKyBpdGVtS2V5cyBhcnJheVxuICAgIGNvbnN0IGhhc2hTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUocXVlcnlIYXNoKTtcbiAgICBjb25zdCBpdGVtS2V5c1NpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZShlbnRyeS5pdGVtS2V5cyk7XG4gICAgY29uc3QgdG90YWxTaXplID0gaGFzaFNpemUgKyBpdGVtS2V5c1NpemU7XG5cbiAgICB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZSArPSB0b3RhbFNpemU7XG4gICAgbG9nZ2VyLnRyYWNlKCdBZGRlZCBxdWVyeSByZXN1bHQgdG8gc2l6ZSB0cmFja2luZycsIHtcbiAgICAgIHF1ZXJ5SGFzaCxcbiAgICAgIGVzdGltYXRlZFNpemU6IHRvdGFsU2l6ZSxcbiAgICAgIHRvdGFsUXVlcnlDYWNoZVNpemU6IHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHF1ZXJ5IHJlc3VsdCBmcm9tIHNpemUgdHJhY2tpbmdcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlUXVlcnlSZXN1bHRGcm9tU2l6ZVRyYWNraW5nKHF1ZXJ5SGFzaDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGNvbnN0IGhhc2hTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUocXVlcnlIYXNoKTtcbiAgICAgIGNvbnN0IGl0ZW1LZXlzU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKGVudHJ5Lml0ZW1LZXlzKTtcbiAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGhhc2hTaXplICsgaXRlbUtleXNTaXplO1xuXG4gICAgICB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZSA9IE1hdGgubWF4KDAsIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplIC0gdG90YWxTaXplKTtcbiAgICAgIGxvZ2dlci50cmFjZSgnUmVtb3ZlZCBxdWVyeSByZXN1bHQgZnJvbSBzaXplIHRyYWNraW5nJywge1xuICAgICAgICBxdWVyeUhhc2gsXG4gICAgICAgIGVzdGltYXRlZFNpemU6IHRvdGFsU2l6ZSxcbiAgICAgICAgdG90YWxRdWVyeUNhY2hlU2l6ZTogdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdG90YWwgY2FjaGUgc2l6ZSBpbmNsdWRpbmcgcXVlcnkgcmVzdWx0c1xuICAgKi9cbiAgcHVibGljIGdldFRvdGFsU2l6ZUJ5dGVzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNpemVCeXRlcyArIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplO1xuICB9XG5cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIHB1YmxpYyBhc3luYyBnZXRNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8Q2FjaGVJdGVtTWV0YWRhdGEgfCBudWxsPiB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtrZXldO1xuICAgIGlmIChlbnRyeSAmJiAhZW50cnkubWV0YWRhdGFDbGVhcmVkKSB7XG4gICAgICByZXR1cm4gZW50cnkubWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldE1ldGFkYXRhKGtleTogc3RyaW5nLCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2tleV07XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgZW50cnkubWV0YWRhdGFDbGVhcmVkID0gZmFsc2U7IC8vIFVuY2xlYXIgbWV0YWRhdGEgd2hlbiBzZXR0aW5nIG5ldyBtZXRhZGF0YVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSBzeW50aGV0aWMgZW50cnkgZm9yIG1ldGFkYXRhLW9ubHkgc3RvcmFnZVxuICAgICAgLy8gVGhpcyBhbGxvd3Mgc2V0dGluZyBtZXRhZGF0YSBmb3Iga2V5cyB0aGF0IGRvbid0IGV4aXN0IGluIHRoZSBjYWNoZSB5ZXRcbiAgICAgIGxldCBvcmlnaW5hbEtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz47XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBKU09OIChmb3IgcmVhbCBjYWNoZSBrZXlzKVxuICAgICAgICBvcmlnaW5hbEtleSA9IEpTT04ucGFyc2Uoa2V5KSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZiBub3QgSlNPTiwgY3JlYXRlIGEgc3ludGhldGljIHByaW1hcnkga2V5XG4gICAgICAgIG9yaWdpbmFsS2V5ID0geyBrdDogJ21ldGFkYXRhLW9ubHknIGFzIFMsIHBrOiBrZXkgfSBhcyBQcmlLZXk8Uz47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwW2tleV0gPSB7XG4gICAgICAgIG9yaWdpbmFsS2V5LFxuICAgICAgICB2YWx1ZTogbnVsbCBhcyBhbnksIC8vIFBsYWNlaG9sZGVyIHZhbHVlXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBtZXRhZGF0YUNsZWFyZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVNZXRhZGF0YShfa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBNZXRhZGF0YSBpcyBkZWxldGVkIHdoZW4gdGhlIGl0ZW0gaXMgZGVsZXRlZFxuICAgIC8vIFRoaXMgaXMgYSBuby1vcCBzaW5jZSBtZXRhZGF0YSBpcyBwYXJ0IG9mIHRoZSBpdGVtIGVudHJ5XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWxsTWV0YWRhdGEoKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4oKTtcbiAgICBmb3IgKGNvbnN0IFtoYXNoZWRLZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm1hcCkpIHtcbiAgICAgIC8vIE9ubHkgaW5jbHVkZSBtZXRhZGF0YSBpZiBpdCBoYXNuJ3QgYmVlbiBjbGVhcmVkXG4gICAgICBpZiAoIWVudHJ5Lm1ldGFkYXRhQ2xlYXJlZCkge1xuICAgICAgICBtZXRhZGF0YS5zZXQoaGFzaGVkS2V5LCBlbnRyeS5tZXRhZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhck1ldGFkYXRhKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIE1hcmsgYWxsIGVudHJpZXMgYXMgaGF2aW5nIGNsZWFyZWQgbWV0YWRhdGFcbiAgICBjb25zdCBrZXlzVG9SZW1vdmU6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtoYXNoZWRLZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm1hcCkpIHtcbiAgICAgIGlmIChlbnRyeS52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbWV0YWRhdGEtb25seSBlbnRyeSwgcmVtb3ZlIGl0IGNvbXBsZXRlbHlcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goaGFzaGVkS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSByZWFsIGNhY2hlIGVudHJ5LCBtYXJrIG1ldGFkYXRhIGFzIGNsZWFyZWRcbiAgICAgICAgZW50cnkubWV0YWRhdGFDbGVhcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgbWV0YWRhdGEtb25seSBlbnRyaWVzXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c1RvUmVtb3ZlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBba2V5XTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0Q3VycmVudFNpemUoKTogUHJvbWlzZTx7IGl0ZW1Db3VudDogbnVtYmVyOyBzaXplQnl0ZXM6IG51bWJlciB9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1Db3VudDogdGhpcy5jdXJyZW50SXRlbUNvdW50LFxuICAgICAgc2l6ZUJ5dGVzOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXNcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFNpemVMaW1pdHMoKTogUHJvbWlzZTx7IG1heEl0ZW1zOiBudW1iZXIgfCBudWxsOyBtYXhTaXplQnl0ZXM6IG51bWJlciB8IG51bGwgfT4ge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhJdGVtczogdGhpcy5tYXhJdGVtcyA/PyBudWxsLFxuICAgICAgbWF4U2l6ZUJ5dGVzOiB0aGlzLm1heFNpemVCeXRlcyA/PyBudWxsXG4gICAgfTtcbiAgfVxuXG59XG4iLCJpbXBvcnQge1xuICBBbGxJdGVtVHlwZUFycmF5cyxcbiAgQ29tS2V5LFxuICBpc0NvbUtleSxcbiAgaXNRdWVyeU1hdGNoLFxuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZU1hcCB9IGZyb20gXCIuLi9DYWNoZU1hcFwiO1xuaW1wb3J0IHsgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiwgaXNMb2NLZXlBcnJheUVxdWFsIH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhIH0gZnJvbSBcIi4uL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiTG9jYWxTdG9yYWdlQ2FjaGVNYXBcIik7XG5cbi8qKlxuICogTG9jYWxTdG9yYWdlIGltcGxlbWVudGF0aW9uIG9mIENhY2hlTWFwIGZvciBicm93c2VyIGVudmlyb25tZW50cy5cbiAqIERhdGEgcGVyc2lzdHMgYWNyb3NzIGJyb3dzZXIgc2Vzc2lvbnMgYW5kIHBhZ2UgcmVsb2Fkcy5cbiAqXG4gKiBOb3RlOiBMb2NhbFN0b3JhZ2UgaGFzIGEgfjUtMTBNQiBsaW1pdCBhbmQgc3RvcmVzIHN0cmluZ3Mgb25seS5cbiAqIERhdGEgaXMgc3luY2hyb25vdXMgYW5kIHN1cnZpdmVzIGJyb3dzZXIgcmVzdGFydHMuXG4gKiBXaWxsIHRocm93IGVycm9ycyBpZiBzdG9yYWdlIHF1b3RhIGlzIGV4Y2VlZGVkLCB0aG91Z2ggaXQgYXR0ZW1wdHNcbiAqIHRvIGNsZWFuIHVwIG9sZCBlbnRyaWVzIGZpcnN0LlxuICovXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlQ2FjaGVNYXA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcblxuICBwdWJsaWMgcmVhZG9ubHkgaW1wbGVtZW50YXRpb25UeXBlID0gXCJicm93c2VyL2xvY2FsU3RvcmFnZVwiO1xuXG4gIHByaXZhdGUga2V5UHJlZml4OiBzdHJpbmc7XG4gIHByaXZhdGUgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pID0+IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBNQVhfUkVUUllfQVRURU1QVFMgPSAzO1xuICBwcml2YXRlIHJlYWRvbmx5IEFHR1JFU1NJVkVfQ0xFQU5VUF9QRVJDRU5UQUdFID0gMC41OyAvLyBSZW1vdmUgNTAlIG9mIGVudHJpZXMgd2hlbiBxdW90YSBleGNlZWRlZFxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgdHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAga2V5UHJlZml4OiBzdHJpbmcgPSAnZmplbGwtY2FjaGUnXG4gICkge1xuICAgIHN1cGVyKHR5cGVzKTtcbiAgICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uPENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+PigpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdG9yYWdlS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBzdHJpbmcge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIHJldHVybiBgJHt0aGlzLmtleVByZWZpeH06JHtoYXNoZWRLZXl9YDtcbiAgfVxuXG4gIHByaXZhdGUgaXNRdW90YUV4Y2VlZGVkRXJyb3IoZXJyb3I6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlcnJvciAmJiAoXG4gICAgICBlcnJvci5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJyB8fFxuICAgICAgZXJyb3IubmFtZSA9PT0gJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJyB8fFxuICAgICAgZXJyb3IuY29kZSA9PT0gMjIgfHxcbiAgICAgIGVycm9yLmNvZGUgPT09IDEwMTRcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBbGxLZXlzU3RhcnRpbmdXaXRoKHByZWZpeDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIGtleXMgYnkgcHJlZml4IGZyb20gbG9jYWxTdG9yYWdlJywgeyBwcmVmaXgsIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cnlDbGVhbnVwT2xkRW50cmllcyhhZ2dyZXNzaXZlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsRW50cmllcyA9IHRoaXMuY29sbGVjdENhY2hlRW50cmllcygpO1xuICAgICAgaWYgKGFsbEVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnTm8gZW50cmllcyB0byBjbGVhbiB1cCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVPbGRlc3RFbnRyaWVzKGFsbEVudHJpZXMsIGFnZ3Jlc3NpdmUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhbnVwIG9sZCBsb2NhbFN0b3JhZ2UgZW50cmllcycsIHsgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb2xsZWN0Q2FjaGVFbnRyaWVzKCk6IHsga2V5OiBzdHJpbmc7IHRpbWVzdGFtcDogbnVtYmVyOyBzaXplOiBudW1iZXIgfVtdIHtcbiAgICBjb25zdCBhbGxFbnRyaWVzOiB7IGtleTogc3RyaW5nOyB0aW1lc3RhbXA6IG51bWJlcjsgc2l6ZTogbnVtYmVyIH1bXSA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgLy8gT25seSBjb25zaWRlciByZWd1bGFyIGNhY2hlIGVudHJpZXMsIHNraXAgbWV0YWRhdGEgYW5kIHF1ZXJ5IHJlc3VsdHNcbiAgICAgIGlmIChrZXkuaW5jbHVkZXMoJzptZXRhZGF0YTonKSB8fCBrZXkuaW5jbHVkZXMoJzpxdWVyeTonKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgaWYgKHBhcnNlZCAmJiB0eXBlb2YgcGFyc2VkID09PSAnb2JqZWN0JyAmJiAnb3JpZ2luYWxLZXknIGluIHBhcnNlZCkge1xuICAgICAgICAgICAgYWxsRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IHBhcnNlZC50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgc2l6ZTogc3RvcmVkLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIG9yaWdpbmFsS2V5LCBtYXJrIGl0IGZvciBkZWxldGlvblxuICAgICAgICAgICAgYWxsRW50cmllcy5wdXNoKHsga2V5LCB0aW1lc3RhbXA6IDAsIHNpemU6IHN0b3JlZC5sZW5ndGggfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSBpdCwgbWFyayBpdCBmb3IgZGVsZXRpb24gd2l0aCBvbGRlc3QgdGltZXN0YW1wXG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnRm91bmQgY29ycnVwdGVkIGVudHJ5IGR1cmluZyBjbGVhbnVwJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgICBhbGxFbnRyaWVzLnB1c2goeyBrZXksIHRpbWVzdGFtcDogMCwgc2l6ZTogMCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbEVudHJpZXM7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZU9sZGVzdEVudHJpZXMoYWxsRW50cmllczogeyBrZXk6IHN0cmluZzsgdGltZXN0YW1wOiBudW1iZXI7IHNpemU6IG51bWJlciB9W10sIGFnZ3Jlc3NpdmU6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIC8vIFNvcnQgYnkgdGltZXN0YW1wIChvbGRlc3QgZmlyc3QpXG4gICAgYWxsRW50cmllcy5zb3J0KChhLCBiKSA9PiBhLnRpbWVzdGFtcCAtIGIudGltZXN0YW1wKTtcblxuICAgIC8vIFVzZSBhZ2dyZXNzaXZlIGNsZWFudXAgcGVyY2VudGFnZSB3aGVuIHF1b3RhIGV4Y2VlZGVkLCBvdGhlcndpc2UgdXNlIG5vcm1hbCAyNSVcbiAgICBjb25zdCBjbGVhbnVwUGVyY2VudGFnZSA9IGFnZ3Jlc3NpdmUgPyB0aGlzLkFHR1JFU1NJVkVfQ0xFQU5VUF9QRVJDRU5UQUdFIDogMC4yNTtcbiAgICBjb25zdCB0b1JlbW92ZSA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChhbGxFbnRyaWVzLmxlbmd0aCAqIGNsZWFudXBQZXJjZW50YWdlKSk7XG4gICAgbGV0IHJlbW92ZWRDb3VudCA9IDA7XG4gICAgbGV0IHJlbW92ZWRTaXplID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUgJiYgaSA8IGFsbEVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFsbEVudHJpZXNbaV0ua2V5O1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICByZW1vdmVkQ291bnQrKztcbiAgICAgICAgcmVtb3ZlZFNpemUgKz0gYWxsRW50cmllc1tpXS5zaXplO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGVudHJ5IGR1cmluZyBjbGVhbnVwJywgeyBrZXk6IGFsbEVudHJpZXNbaV0ua2V5LCBlcnJvciB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVtb3ZlZENvdW50ID4gMCkge1xuICAgICAgY29uc3QgY2xlYW51cFR5cGUgPSBhZ2dyZXNzaXZlID8gJ2FnZ3Jlc3NpdmUnIDogJ25vcm1hbCc7XG4gICAgICBsb2dnZXIuaW5mbyhgQ2xlYW5lZCB1cCAke3JlbW92ZWRDb3VudH0gb2xkIGxvY2FsU3RvcmFnZSBlbnRyaWVzICgke3JlbW92ZWRTaXplfSBieXRlcykgdXNpbmcgJHtjbGVhbnVwVHlwZX0gY2xlYW51cCB0byBmcmVlIHNwYWNlYCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkQ291bnQgPiAwO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBbGxTdG9yYWdlS2V5cygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsS2V5c1N0YXJ0aW5nV2l0aChgJHt0aGlzLmtleVByZWZpeH06YCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPFYgfCBudWxsPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdnZXQnLCB7IGtleSB9KTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBsZXQgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAvLyBGYWxsYmFjazogYXR0ZW1wdCBsZWdhY3kga2V5IHdpdGhvdXQgaGFzaGluZyAoZm9yIHRlc3RzIHRoYXQgc2V0IHJhdyBrZXkpXG4gICAgICBpZiAoIXN0b3JlZCAmJiB0eXBlb2YgKGtleSBhcyBhbnkpPy5rdCA9PT0gJ3N0cmluZycgJiYgKGtleSBhcyBhbnkpPy5waykge1xuICAgICAgICBjb25zdCBsZWdhY3lLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06JHsoa2V5IGFzIGFueSkua3R9OiR7KGtleSBhcyBhbnkpLnBrfWA7XG4gICAgICAgIHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxlZ2FjeUtleSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgIC8vIFZlcmlmeSB0aGUgb3JpZ2luYWwga2V5IG1hdGNoZXMgKGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uKVxuICAgICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24ocGFyc2VkLm9yaWdpbmFsS2V5KSA9PT0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQudmFsdWUgYXMgVjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ0ZhaWxlZCB0byBwYXJzZSBzdG9yZWQgdmFsdWUnLCB7IGtleSwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIHZhbHVlOiBWKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXQnLCB7IGtleSwgdmFsdWUgfSk7XG5cbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHRoaXMuTUFYX1JFVFJZX0FUVEVNUFRTOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgICAgY29uc3QgdG9TdG9yZSA9IHtcbiAgICAgICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkodG9TdG9yZSkpO1xuXG4gICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBTdWNjZXNzZnVsbHkgc3RvcmVkIGl0ZW0gYWZ0ZXIgJHthdHRlbXB0fSByZXRyaWVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuOyAvLyBTdWNjZXNzLCBleGl0IHRoZSByZXRyeSBsb29wXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBpc0xhc3RBdHRlbXB0ID0gYXR0ZW1wdCA9PT0gdGhpcy5NQVhfUkVUUllfQVRURU1QVFMgLSAxO1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEVycm9yIHN0b3JpbmcgdG8gbG9jYWxTdG9yYWdlIChhdHRlbXB0ICR7YXR0ZW1wdCArIDF9LyR7dGhpcy5NQVhfUkVUUllfQVRURU1QVFN9KWAsIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgaXNMYXN0QXR0ZW1wdFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pc1F1b3RhRXhjZWVkZWRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAvLyBVc2UgaW5jcmVhc2luZ2x5IGFnZ3Jlc3NpdmUgY2xlYW51cCBvbiBlYWNoIHJldHJ5IGF0dGVtcHRcbiAgICAgICAgICBjb25zdCB1c2VBZ2dyZXNzaXZlQ2xlYW51cCA9IGF0dGVtcHQgPiAwO1xuICAgICAgICAgIHRoaXMudHJ5Q2xlYW51cE9sZEVudHJpZXModXNlQWdncmVzc2l2ZUNsZWFudXApO1xuXG4gICAgICAgICAgaWYgKGlzTGFzdEF0dGVtcHQpIHtcbiAgICAgICAgICAgIC8vIEZpbmFsIGF0dGVtcHQgZmFpbGVkXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBpdGVtIGluIGxvY2FsU3RvcmFnZTogc3RvcmFnZSBxdW90YSBleGNlZWRlZCBldmVuIGFmdGVyIG11bHRpcGxlIGNsZWFudXAgYXR0ZW1wdHMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb250aW51ZSB0byBuZXh0IHJldHJ5IGF0dGVtcHQgKG5vIGRlbGF5IG5lZWRlZCBmb3IgbG9jYWxTdG9yYWdlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG5vbi1xdW90YSBlcnJvcnMsIHRocm93IGltbWVkaWF0ZWx5IHdpdGhvdXQgcmV0cnlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RvcmUgaXRlbSBpbiBsb2NhbFN0b3JhZ2U6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbmNsdWRlc0tleShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSkgPT09IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdGYWlsZWQgdG8gcGFyc2Ugc3RvcmVkIHZhbHVlIGluIGluY2x1ZGVzS2V5JywgeyBrZXksIGVycm9yOiBwYXJzZUVycm9yIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGtleSBpbiBsb2NhbFN0b3JhZ2UnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdkZWxldGUnLCB7IGtleSB9KTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBkZWxldGluZyBmcm9tIGxvY2FsU3RvcmFnZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhbGxJbihsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8VltdPiB7XG4gICAgY29uc3QgYWxsS2V5cyA9IHRoaXMua2V5cygpO1xuXG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUmV0dXJuaW5nIGFsbCBpdGVtcywgTG9jS2V5cyBpcyBlbXB0eScpO1xuICAgICAgY29uc3QgaXRlbXM6IFZbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYXdhaXQgYWxsS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvY0tleXM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IGxvY2F0aW9ucztcbiAgICAgIGNvbnN0IHJlc29sdmVkS2V5cyA9IGF3YWl0IGFsbEtleXM7XG4gICAgICBsb2dnZXIuZGVidWcoJ2FsbEluJywgeyBsb2NLZXlzLCBrZXlzOiByZXNvbHZlZEtleXMubGVuZ3RoIH0pO1xuXG4gICAgICBjb25zdCBmaWx0ZXJlZEtleXMgPSByZXNvbHZlZEtleXNcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBrZXkgJiYgaXNDb21LZXkoa2V5KSlcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgQ29tS2V5ID0ga2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnQ29tcGFyaW5nIExvY2F0aW9uIEtleXMnLCB7XG4gICAgICAgICAgICBsb2NLZXlzLFxuICAgICAgICAgICAgQ29tS2V5LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jS2V5cywgQ29tS2V5LmxvYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCBpdGVtczogVltdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWx0ZXJlZEtleXMpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb250YWlucyhxdWVyeTogSXRlbVF1ZXJ5LCBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnY29udGFpbnMnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHF1ZXJ5SW4oXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdxdWVyeUluJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsb25lKCk6IFByb21pc2U8TG9jYWxTdG9yYWdlQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4ge1xuICAgIC8vIExvY2FsU3RvcmFnZSBpcyBzaGFyZWQgZ2xvYmFsbHksIHNvIGNsb25lIGp1c3QgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIHNhbWUgcHJlZml4XG4gICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JhZ2VDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KHRoaXMudHlwZXMsIHRoaXMua2V5UHJlZml4KTtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VTdG9yYWdlRW50cnkoc3RvcmFnZUtleTogc3RyaW5nKTogYW55IHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgIC8vIFNraXAgY29ycnVwdGVkIGVudHJpZXNcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU2tpcHBpbmcgY29ycnVwdGVkIGxvY2FsU3RvcmFnZSBlbnRyeScsIHsgc3RvcmFnZUtleSwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtleXMoKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10+IHtcbiAgICBjb25zdCBrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10gPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qgc3RvcmFnZUtleSBvZiBzdG9yYWdlS2V5cykge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlU3RvcmFnZUVudHJ5KHN0b3JhZ2VLZXkpO1xuICAgICAgICBpZiAocGFyc2VkPy5vcmlnaW5hbEtleSkge1xuICAgICAgICAgIGtleXMucHVzaChwYXJzZWQub3JpZ2luYWxLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyBrZXlzIGZyb20gbG9jYWxTdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB2YWx1ZXMoKTogUHJvbWlzZTxWW10+IHtcbiAgICBjb25zdCB2YWx1ZXM6IFZbXSA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VTdG9yYWdlRW50cnkoc3RvcmFnZUtleSk7XG4gICAgICAgIGlmIChwYXJzZWQ/LnZhbHVlKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdmFsdWVzIGZyb20gbG9jYWxTdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnQ2xlYXJpbmcgbG9jYWxTdG9yYWdlIGNhY2hlJyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGxvY2FsU3RvcmFnZSBjYWNoZScsIHsgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbiAgcHVibGljIGFzeW5jIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nLCBpdGVtS2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXRRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoLCBpdGVtS2V5cyB9KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuXG4gICAgY29uc3QgZW50cnk6IGFueSA9IHtcbiAgICAgIGl0ZW1LZXlzXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShxdWVyeUtleSwgSlNPTi5zdHJpbmdpZnkoZW50cnkpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgcXVlcnkgcmVzdWx0IGluIGxvY2FsU3RvcmFnZScsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHF1ZXJ5S2V5KTtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW50cnkgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBvbGQgZm9ybWF0IChqdXN0IGFycmF5KSBhbmQgbmV3IGZvcm1hdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgIC8vIE9sZCBmb3JtYXQgLSByZXR1cm4gYXMgaXNcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuXG4gICAgICAvLyBOZXcgZm9ybWF0XG4gICAgICByZXR1cm4gZW50cnkuaXRlbUtleXMgfHwgbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcmV0cmlldmUgcXVlcnkgcmVzdWx0IGZyb20gbG9jYWxTdG9yYWdlJywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHF1ZXJ5S2V5KSAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgcXVlcnkgcmVzdWx0IGluIGxvY2FsU3RvcmFnZScsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2RlbGV0ZVF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocXVlcnlLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgcXVlcnkgcmVzdWx0IGZyb20gbG9jYWxTdG9yYWdlJywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZhbGlkYXRlSXRlbUtleXMoa2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlSXRlbUtleXMnLCB7IGtleXMgfSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxldGUoa2V5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBrZXkgZHVyaW5nIGludmFsaWRhdGlvbicsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlTG9jYXRpb24nLCB7IGxvY2F0aW9ucyB9KTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBGb3IgcHJpbWFyeSBpdGVtcyAobm8gbG9jYXRpb24pLCBjbGVhciBhbGwgcHJpbWFyeSBrZXlzXG4gICAgICAgIGNvbnN0IGFsbEtleXMgPSBhd2FpdCB0aGlzLmtleXMoKTtcbiAgICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBhbGxLZXlzLmZpbHRlcihrZXkgPT4gIWlzQ29tS2V5KGtleSkpO1xuICAgICAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhwcmltYXJ5S2V5cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgY29udGFpbmVkIGl0ZW1zLCBjb21wdXRlIGtleXMgZGlyZWN0bHkgZnJvbSBzdG9yZWQga2V5cyB0byBhdm9pZCB2YWx1ZS1zaGFwZSBhc3N1bXB0aW9uc1xuICAgICAgICBjb25zdCBhbGxLZXlzID0gYXdhaXQgdGhpcy5rZXlzKCk7XG4gICAgICAgIGNvbnN0IGtleXNUb0ludmFsaWRhdGUgPSBhbGxLZXlzXG4gICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBrZXkgJiYgaXNDb21LZXkoa2V5KSlcbiAgICAgICAgICAuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZUtleSA9IGtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICAgICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jYXRpb25zIGFzIGFueVtdLCBjb21wb3NpdGVLZXkubG9jKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMoa2V5c1RvSW52YWxpZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGFsbCBxdWVyeSByZXN1bHRzIGFmdGVyIGludmFsaWRhdGluZyBpdGVtc1xuICAgICAgYXdhaXQgdGhpcy5jbGVhclF1ZXJ5UmVzdWx0cygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIGludmFsaWRhdGVMb2NhdGlvbicsIHsgbG9jYXRpb25zLCBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXJRdWVyeVJlc3VsdHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdjbGVhclF1ZXJ5UmVzdWx0cycpO1xuICAgIGNvbnN0IHF1ZXJ5UHJlZml4ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OmA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXNUb1JlbW92ZSA9IHRoaXMuZ2V0QWxsS2V5c1N0YXJ0aW5nV2l0aChxdWVyeVByZWZpeCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHJlbW92ZSBxdWVyeSByZXN1bHQgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY2xlYXIgcXVlcnkgcmVzdWx0cyBmcm9tIGxvY2FsU3RvcmFnZScsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIHB1YmxpYyBhc3luYyBnZXRNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8Q2FjaGVJdGVtTWV0YWRhdGEgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtZXRhZGF0YUtleSk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIEludmFsaWQgSlNPTiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhYnNlbnRcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ0ludmFsaWQgbWV0YWRhdGEgSlNPTiwgdHJlYXRpbmcgYXMgbnVsbCcsIHsga2V5LCBlcnJvcjogZSB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyBtZXRhZGF0YSBmcm9tIGxvY2FsU3RvcmFnZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXRNZXRhZGF0YShrZXk6IHN0cmluZywgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCB0aGlzLk1BWF9SRVRSWV9BVFRFTVBUUzsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YToke2tleX1gO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtZXRhZGF0YUtleSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcblxuICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgU3VjY2Vzc2Z1bGx5IHN0b3JlZCBtZXRhZGF0YSBhZnRlciAke2F0dGVtcHR9IHJldHJpZXNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47IC8vIFN1Y2Nlc3MsIGV4aXQgdGhlIHJldHJ5IGxvb3BcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdEF0dGVtcHQgPSBhdHRlbXB0ID09PSB0aGlzLk1BWF9SRVRSWV9BVFRFTVBUUyAtIDE7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRXJyb3Igc3RvcmluZyBtZXRhZGF0YSB0byBsb2NhbFN0b3JhZ2UgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHt0aGlzLk1BWF9SRVRSWV9BVFRFTVBUU30pYCwge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBpc0xhc3RBdHRlbXB0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUXVvdGFFeGNlZWRlZEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIC8vIFVzZSBpbmNyZWFzaW5nbHkgYWdncmVzc2l2ZSBjbGVhbnVwIG9uIGVhY2ggcmV0cnkgYXR0ZW1wdFxuICAgICAgICAgIGNvbnN0IHVzZUFnZ3Jlc3NpdmVDbGVhbnVwID0gYXR0ZW1wdCA+IDA7XG4gICAgICAgICAgdGhpcy50cnlDbGVhbnVwT2xkRW50cmllcyh1c2VBZ2dyZXNzaXZlQ2xlYW51cCk7XG5cbiAgICAgICAgICBpZiAoaXNMYXN0QXR0ZW1wdCkge1xuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCBmYWlsZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHN0b3JlIG1ldGFkYXRhIGluIGxvY2FsU3RvcmFnZTogc3RvcmFnZSBxdW90YSBleGNlZWRlZCBldmVuIGFmdGVyIG11bHRpcGxlIGNsZWFudXAgYXR0ZW1wdHMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb250aW51ZSB0byBuZXh0IHJldHJ5IGF0dGVtcHRcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBub24tcXVvdGEgZXJyb3JzLCB0aHJvdyBpbW1lZGlhdGVseSB3aXRob3V0IHJldHJ5XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN0b3JlIG1ldGFkYXRhIGluIGxvY2FsU3RvcmFnZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZU1ldGFkYXRhKGtleTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShtZXRhZGF0YUtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZGVsZXRpbmcgbWV0YWRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWxsTWV0YWRhdGEoKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4oKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuICAgICAgY29uc3QgbWV0YUtleXMgPSB0aGlzLmdldEFsbEtleXNTdGFydGluZ1dpdGgobWV0YWRhdGFQcmVmaXgpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgbWV0YUtleXMpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBrZXkuc3Vic3RyaW5nKG1ldGFkYXRhUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghc3RvcmVkKSBjb250aW51ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgLy8gQW55IHZhbGlkIEpTT04gb2JqZWN0IGNhbiBiZSBtZXRhZGF0YVxuICAgICAgICAgIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLnNldChtZXRhZGF0YUtleSwgcGFyc2VkIGFzIENhY2hlSXRlbU1ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gU2tpcCBpbnZhbGlkIG1ldGFkYXRhIGVudHJpZXNcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ1NraXBwaW5nIGludmFsaWQgbWV0YWRhdGEgZW50cnknLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIG1ldGFkYXRhIGZyb20gbG9jYWxTdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhck1ldGFkYXRhKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuICAgICAgY29uc3Qga2V5c1RvRGVsZXRlID0gdGhpcy5nZXRBbGxLZXlzU3RhcnRpbmdXaXRoKG1ldGFkYXRhUHJlZml4KTtcbiAgICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBjbGVhcmluZyBtZXRhZGF0YSBmcm9tIGxvY2FsU3RvcmFnZScsIHsgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0Q3VycmVudFNpemUoKTogUHJvbWlzZTx7IGl0ZW1Db3VudDogbnVtYmVyOyBzaXplQnl0ZXM6IG51bWJlciB9PiB7XG4gICAgbGV0IGl0ZW1Db3VudCA9IDA7XG4gICAgbGV0IHNpemVCeXRlcyA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc2l6ZSBmb3IgYWxsIGVudHJpZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVc2UgQmxvYiB3aGVuIGF2YWlsYWJsZSAoYnJvd3NlciksIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gVGV4dEVuY29kZXIvQnVmZmVyIChub2RlIHRlc3QgZW52KVxuICAgICAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNpemVCeXRlcyArPSBuZXcgQmxvYihbdmFsdWVdKS5zaXplO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2l6ZUJ5dGVzICs9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2l6ZUJ5dGVzICs9ICgoZ2xvYmFsVGhpcyBhcyBhbnkpLkJ1ZmZlciBhcyBhbnkpLmJ5dGVMZW5ndGgodmFsdWUsICd1dGY4Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFzIGEgbGFzdCByZXNvcnQsIGFwcHJveGltYXRlIGJ5IHN0cmluZyBsZW5ndGhcbiAgICAgICAgICAgIHNpemVCeXRlcyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT25seSBjb3VudCByZWd1bGFyIGNhY2hlIGVudHJpZXMgZm9yIGl0ZW0gY291bnRcbiAgICAgICAgICBpZiAoIWtleS5pbmNsdWRlcygnOm1ldGFkYXRhOicpICYmICFrZXkuaW5jbHVkZXMoJzpxdWVyeTonKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIC8vIE9ubHkgY291bnQgZW50cmllcyB0aGF0IGhhdmUgYm90aCBvcmlnaW5hbEtleSBhbmQgdmFsdWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICBpZiAocGFyc2VkICYmIHR5cGVvZiBwYXJzZWQgPT09ICdvYmplY3QnICYmICdvcmlnaW5hbEtleScgaW4gcGFyc2VkICYmICd2YWx1ZScgaW4gcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgaXRlbUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFNraXAgaW52YWxpZCBlbnRyaWVzIGZvciBpdGVtIGNvdW50XG4gICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnSW52YWxpZCBlbnRyeSBpbiBnZXRDdXJyZW50U2l6ZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgc2l6ZSBjYWxjdWxhdGlvbiBmYWlscywgdXNlIHN0cmluZyBsZW5ndGggYXMgZmFsbGJhY2tcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ1NpemUgY2FsY3VsYXRpb24gZmFpbGVkLCB1c2luZyBzdHJpbmcgbGVuZ3RoJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgICAgIHNpemVCeXRlcyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBjYWxjdWxhdGluZyBzaXplIGZyb20gbG9jYWxTdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiB7IGl0ZW1Db3VudCwgc2l6ZUJ5dGVzIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0U2l6ZUxpbWl0cygpOiBQcm9taXNlPHsgbWF4SXRlbXM6IG51bWJlciB8IG51bGw7IG1heFNpemVCeXRlczogbnVtYmVyIHwgbnVsbCB9PiB7XG4gICAgLy8gTG9jYWxTdG9yYWdlIHR5cGljYWxseSBoYXMgYSA1LTEwTUIgbGltaXQsIGJ1dCB3ZSBjYW4ndCBkZXRlcm1pbmUgdGhlIGV4YWN0IGxpbWl0XG4gICAgLy8gUmV0dXJuIGNvbnNlcnZhdGl2ZSBlc3RpbWF0ZXNcbiAgICByZXR1cm4ge1xuICAgICAgbWF4SXRlbXM6IG51bGwsIC8vIE5vIHNwZWNpZmljIGl0ZW0gbGltaXRcbiAgICAgIG1heFNpemVCeXRlczogNSAqIDEwMjQgKiAxMDI0IC8vIDVNQiBjb25zZXJ2YXRpdmUgZXN0aW1hdGVcbiAgICB9O1xuICB9XG5cbn1cbiIsImltcG9ydCB7XG4gIEFsbEl0ZW1UeXBlQXJyYXlzLFxuICBDb21LZXksXG4gIGlzQ29tS2V5LFxuICBpc1F1ZXJ5TWF0Y2gsXG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlTWFwIH0gZnJvbSBcIi4uL0NhY2hlTWFwXCI7XG5pbXBvcnQgc2FmZVN0cmluZ2lmeSBmcm9tICdmYXN0LXNhZmUtc3RyaW5naWZ5JztcbmltcG9ydCB7IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sIGlzTG9jS2V5QXJyYXlFcXVhbCB9IGZyb20gXCIuLi9ub3JtYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSB9IGZyb20gXCIuLi9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIlNlc3Npb25TdG9yYWdlQ2FjaGVNYXBcIik7XG5cbi8qKlxuICogU2Vzc2lvblN0b3JhZ2UgaW1wbGVtZW50YXRpb24gb2YgQ2FjaGVNYXAgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICogRGF0YSBwZXJzaXN0cyBvbmx5IGZvciB0aGUgY3VycmVudCBicm93c2VyIHRhYi9zZXNzaW9uLlxuICpcbiAqIE5vdGU6IFNlc3Npb25TdG9yYWdlIGhhcyBhIH41TUIgbGltaXQgYW5kIHN0b3JlcyBzdHJpbmdzIG9ubHkuXG4gKiBEYXRhIGlzIHN5bmNocm9ub3VzIGJ1dCBpcyBsb3N0IHdoZW4gdGhlIHRhYiBpcyBjbG9zZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXNzaW9uU3RvcmFnZUNhY2hlTWFwPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IGV4dGVuZHMgQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG5cbiAgcHVibGljIHJlYWRvbmx5IGltcGxlbWVudGF0aW9uVHlwZSA9IFwiYnJvd3Nlci9zZXNzaW9uU3RvcmFnZVwiO1xuXG4gIHByaXZhdGUga2V5UHJlZml4OiBzdHJpbmc7XG4gIHByaXZhdGUgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pID0+IHN0cmluZztcbiAgLy8gVXNlIGEgc2VwYXJhdGUsIHByaXZhdGUgdmVyaWZpZXIgdGhhdCBpcyBub3QgcmVmZXJlbmNlZCBieSB0ZXN0cyB0byBndWFyZCBhZ2FpbnN0IHRhbXBlcmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IHZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbjogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pID0+IHN0cmluZztcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgdHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAga2V5UHJlZml4OiBzdHJpbmcgPSAnZmplbGwtc2Vzc2lvbi1jYWNoZSdcbiAgKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb248Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4+KCk7XG4gICAgdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uPENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+PigpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdG9yYWdlS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBzdHJpbmcge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIHJldHVybiBgJHt0aGlzLmtleVByZWZpeH06JHtoYXNoZWRLZXl9YDtcbiAgfVxuXG4gIC8vIFVzaW5nIGZsYXR0ZWQgZm9yIHNhZmUgY2lyY3VsYXIgc2VyaWFsaXphdGlvbjsgbm8gbWFudWFsIHJlcGxhY2VyIG5lZWRlZFxuXG4gIHByaXZhdGUgZ2V0QWxsU3RvcmFnZUtleXMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXNzaW9uU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzZXNzaW9uU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoYCR7dGhpcy5rZXlQcmVmaXh9OmApKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIGtleXMgZnJvbSBzZXNzaW9uU3RvcmFnZScsIHsgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICAvLyBEZXRlY3QgaWYgY3VycmVudCBub3JtYWxpemVkIGhhc2ggZnVuY3Rpb24gY29sbGFwc2VzIG11bHRpcGxlIHN0b3JlZCBpdGVtcyBpbnRvIHRoZSBzYW1lIGhhc2hcbiAgcHJpdmF0ZSBoYXNDb2xsaXNpb25Gb3JIYXNoKHRhcmdldEhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OiR7dGFyZ2V0SGFzaH1gO1xuICAgICAgY29uc3QgcmF3ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmICghcmF3KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgIGlmICghcGFyc2VkPy5vcmlnaW5hbEtleSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJZiB2ZXJpZmljYXRpb24gaGFzaCBtYXRjaGVzLCB0aGlzIGlzIHRoZSBjb3JyZWN0IGl0ZW0gKG5vIGNvbGxpc2lvbilcbiAgICAgIGNvbnN0IHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggPSBwYXJzZWQub3JpZ2luYWxWZXJpZmljYXRpb25IYXNoO1xuICAgICAgY29uc3QgY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpO1xuICAgICAgaWYgKHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggPT09IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdmVyaWZpY2F0aW9uIGhhc2ggZG9lc24ndCBtYXRjaCwgd2UgaGF2ZSBhIGNvbGxpc2lvblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxWIHwgbnVsbD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0JywgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRIYXNoID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICBpZiAodGhpcy5oYXNDb2xsaXNpb25Gb3JIYXNoKGN1cnJlbnRIYXNoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgLy8gVmVyaWZ5IGtleSB1c2luZyBib3RoIGEgc3RhYmxlIHZlcmlmaWNhdGlvbiBoYXNoIGFuZCB0aGUgcGFyc2VkIG9yaWdpbmFsS2V5IGVxdWFsaXR5XG4gICAgICAgIGNvbnN0IHN0b3JlZFZlcmlmaWNhdGlvbkhhc2g6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBhcnNlZC5vcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2g7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoID0gdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3QgaXNTYW1lT3JpZ2luYWxLZXkgPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpID09PSBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaDtcbiAgICAgICAgaWYgKHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggJiYgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggJiYgaXNTYW1lT3JpZ2luYWxLZXkpIHtcbiAgICAgICAgICBpZiAocGFyc2VkLnZhbHVlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgIHJldHVybiBwYXJzZWQudmFsdWUgYXMgVjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgcmV0cmlldmluZyBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LCB2YWx1ZTogVik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBsb2dnZXIudHJhY2UoJ3NldCcsIHsgc3RvcmFnZUtleSB9KTtcbiAgICAgIGNvbnN0IHRvU3RvcmUgPSB7XG4gICAgICAgIG9yaWdpbmFsS2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBvcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2g6IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKGtleSlcbiAgICAgIH07XG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gc2FmZVN0cmluZ2lmeSh0b1N0b3JlKTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwganNvblN0cmluZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igc3RvcmluZyB0byBzZXNzaW9uU3RvcmFnZScsIHsgZXJyb3JNZXNzYWdlOiAoZXJyb3IgYXMgRXJyb3IpPy5tZXNzYWdlIH0pO1xuICAgICAgLy8gSGFuZGxlIHF1b3RhIGV4Y2VlZGVkIG9yIG90aGVyIHNlc3Npb25TdG9yYWdlIGVycm9yc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RvcmUgaXRlbSBpbiBzZXNzaW9uU3RvcmFnZTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5jbHVkZXNLZXkoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50SGFzaCA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgaWYgKHRoaXMuaGFzQ29sbGlzaW9uRm9ySGFzaChjdXJyZW50SGFzaCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICBjb25zdCBzdG9yZWRWZXJpZmljYXRpb25IYXNoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBwYXJzZWQub3JpZ2luYWxWZXJpZmljYXRpb25IYXNoO1xuICAgICAgICBjb25zdCBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaCA9IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICAgIGNvbnN0IGlzU2FtZU9yaWdpbmFsS2V5ID0gdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24ocGFyc2VkLm9yaWdpbmFsS2V5KSA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2g7XG4gICAgICAgIHJldHVybiAhIXN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggJiYgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggJiYgaXNTYW1lT3JpZ2luYWxLZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgY2hlY2tpbmcga2V5IGluIHNlc3Npb25TdG9yYWdlJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGUoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlJywgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZGVsZXRpbmcgZnJvbSBzZXNzaW9uU3RvcmFnZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWxsSW4obG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPFZbXT4ge1xuICAgIGNvbnN0IGFsbEtleXMgPSB0aGlzLmtleXMoKTtcblxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1JldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHknKTtcbiAgICAgIGNvbnN0IGl0ZW1zOiBWW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGF3YWl0IGFsbEtleXMpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsb2NLZXlzOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG4gICAgICBjb25zdCByZXNvbHZlZEtleXMgPSBhd2FpdCBhbGxLZXlzO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdhbGxJbicsIHsgbG9jS2V5cywga2V5czogcmVzb2x2ZWRLZXlzLmxlbmd0aCB9KTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkS2V5cyA9IHJlc29sdmVkS2V5c1xuICAgICAgICAuZmlsdGVyKChrZXkpID0+IGtleSAmJiBpc0NvbUtleShrZXkpKVxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBDb21LZXkgPSBrZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdDb21wYXJpbmcgTG9jYXRpb24gS2V5cycsIHtcbiAgICAgICAgICAgIGxvY0tleXMsXG4gICAgICAgICAgICBDb21LZXksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NLZXlzLCBDb21LZXkubG9jKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGl0ZW1zOiBWW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZpbHRlcmVkS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5OiBJdGVtUXVlcnksIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdjb250YWlucycsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcXVlcnlJbihcbiAgICBxdWVyeTogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+IHtcbiAgICBsb2dnZXIuZGVidWcoJ3F1ZXJ5SW4nLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xvbmUoKTogUHJvbWlzZTxTZXNzaW9uU3RvcmFnZUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+IHtcbiAgICAvLyBTZXNzaW9uU3RvcmFnZSBpcyBzaGFyZWQgZ2xvYmFsbHkgZm9yIHRoZSB0YWIsIHNvIGNsb25lIGp1c3QgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIHNhbWUgcHJlZml4XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uU3RvcmFnZUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4odGhpcy50eXBlcywgdGhpcy5rZXlQcmVmaXgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtleXMoKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10+IHtcbiAgICBjb25zdCBrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10gPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qgc3RvcmFnZUtleSBvZiBzdG9yYWdlS2V5cykge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICBpZiAoIXN0b3JlZCkgY29udGludWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgaWYgKHBhcnNlZC5vcmlnaW5hbEtleSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHBhcnNlZC5vcmlnaW5hbEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChpdGVtRXJyb3IpIHtcbiAgICAgICAgICAvLyBTa2lwIGl0ZW1zIHRoYXQgY2FuJ3QgYmUgcGFyc2VkIG9yIGFyZSBpbnZhbGlkXG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKCdTa2lwcGluZyBpbnZhbGlkIHN0b3JhZ2UgaXRlbScsIHsgc3RvcmFnZUtleSwgZXJyb3I6IGl0ZW1FcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcga2V5cyBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB2YWx1ZXMoKTogUHJvbWlzZTxWW10+IHtcbiAgICBjb25zdCB2YWx1ZXM6IFZbXSA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgIGlmICghc3RvcmVkKSBjb250aW51ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBpZiAocGFyc2VkLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlZC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChpdGVtRXJyb3IpIHtcbiAgICAgICAgICAvLyBTa2lwIGl0ZW1zIHRoYXQgY2FuJ3QgYmUgcGFyc2VkIG9yIGFyZSBpbnZhbGlkXG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKCdTa2lwcGluZyBpbnZhbGlkIHN0b3JhZ2UgaXRlbSBmb3IgdmFsdWVzJywgeyBzdG9yYWdlS2V5LCBlcnJvcjogaXRlbUVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBzZXNzaW9uU3RvcmFnZScsIHsgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ0NsZWFyaW5nIHNlc3Npb25TdG9yYWdlIGNhY2hlJyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgY2xlYXJpbmcgc2Vzc2lvblN0b3JhZ2UgY2FjaGUnLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxuICBwdWJsaWMgYXN5bmMgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcsIGl0ZW1LZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG5cbiAgICBjb25zdCBlbnRyeTogYW55ID0ge1xuICAgICAgaXRlbUtleXNcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBzYWZlU3RyaW5naWZ5KGVudHJ5KTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0ocXVlcnlLZXksIGpzb25TdHJpbmcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBxdWVyeSByZXN1bHQgaW4gc2Vzc2lvblN0b3JhZ2UnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10gfCBudWxsPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdnZXRRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHF1ZXJ5S2V5KTtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW50cnkgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBvbGQgZm9ybWF0IChqdXN0IGFycmF5KSBhbmQgbmV3IGZvcm1hdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgIC8vIE9sZCBmb3JtYXQgLSByZXR1cm4gYXMgaXNcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuXG4gICAgICAvLyBOZXcgZm9ybWF0XG5cbiAgICAgIHJldHVybiBlbnRyeS5pdGVtS2V5cyB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBxdWVyeSByZXN1bHQgZnJvbSBzZXNzaW9uU3RvcmFnZScsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBoYXNRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHF1ZXJ5S2V5KSAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgcXVlcnkgcmVzdWx0IGluIHNlc3Npb25TdG9yYWdlJywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlUXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgIHRyeSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHF1ZXJ5S2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIHF1ZXJ5IHJlc3VsdCBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZhbGlkYXRlSXRlbUtleXMoa2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlSXRlbUtleXMnLCB7IGtleXMgfSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlTG9jYXRpb24nLCB7IGxvY2F0aW9ucyB9KTtcblxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGb3IgcHJpbWFyeSBpdGVtcyAobm8gbG9jYXRpb24pLCBjbGVhciBhbGwgcHJpbWFyeSBrZXlzXG4gICAgICBjb25zdCBhbGxLZXlzID0gYXdhaXQgdGhpcy5rZXlzKCk7XG4gICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKGtleSA9PiAhaXNDb21LZXkoa2V5KSk7XG4gICAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhwcmltYXJ5S2V5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBjb250YWluZWQgaXRlbXMsIGdldCBhbGwgaXRlbXMgaW4gdGhlIGxvY2F0aW9uIGFuZCBpbnZhbGlkYXRlIHRoZW1cbiAgICAgIGNvbnN0IGl0ZW1zSW5Mb2NhdGlvbiA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICAgIGNvbnN0IGtleXNUb0ludmFsaWRhdGUgPSBpdGVtc0luTG9jYXRpb24ubWFwKGl0ZW0gPT4gaXRlbS5rZXkpO1xuICAgICAgYXdhaXQgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMoa2V5c1RvSW52YWxpZGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgYWxsIHF1ZXJ5IHJlc3VsdHMgdGhhdCBtaWdodCBiZSBhZmZlY3RlZFxuICAgIGF3YWl0IHRoaXMuY2xlYXJRdWVyeVJlc3VsdHMoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhclF1ZXJ5UmVzdWx0cygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2NsZWFyUXVlcnlSZXN1bHRzJyk7XG4gICAgY29uc3QgcXVlcnlQcmVmaXggPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6YDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5c1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXNzaW9uU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzZXNzaW9uU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgocXVlcnlQcmVmaXgpKSB7XG4gICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2V5c1RvUmVtb3ZlLmZvckVhY2goa2V5ID0+IHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNsZWFyIHF1ZXJ5IHJlc3VsdHMgZnJvbSBzZXNzaW9uU3RvcmFnZScsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIHB1YmxpYyBhc3luYyBnZXRNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8Q2FjaGVJdGVtTWV0YWRhdGEgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKG1ldGFkYXRhS2V5KTtcbiAgICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldE1ldGFkYXRhKGtleTogc3RyaW5nLCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBzYWZlU3RyaW5naWZ5KG1ldGFkYXRhKTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0obWV0YWRhdGFLZXksIGpzb25TdHJpbmcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIHF1b3RhIGV4Y2VlZGVkIGVycm9ycyAtIHNlc3Npb24gc3RvcmFnZSBpcyBlcGhlbWVyYWxcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlTWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obWV0YWRhdGFLZXkpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIGVycm9ycyB3aGVuIGRlbGV0aW5nXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldEFsbE1ldGFkYXRhKCk6IFByb21pc2U8TWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+PiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+KCk7XG4gICAgY29uc3QgbWV0YWRhdGFQcmVmaXggPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6YDtcblxuICAgIC8vIEZpcnN0IHRyeSBzdGFuZGFyZCBpdGVyYXRpb24gQVBJXG4gICAgdHJ5IHtcbiAgICAgIGxldCBmb3VuZEFueSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXNzaW9uU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzZXNzaW9uU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmICgha2V5IHx8ICFrZXkuc3RhcnRzV2l0aChtZXRhZGF0YVByZWZpeCkpIGNvbnRpbnVlO1xuICAgICAgICBmb3VuZEFueSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBrZXkuc3Vic3RyaW5nKG1ldGFkYXRhUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFzdG9yZWQpIGNvbnRpbnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWV0YWRhdGEuc2V0KG1ldGFkYXRhS2V5LCBKU09OLnBhcnNlKHN0b3JlZCkpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBTa2lwIGludmFsaWQgbWV0YWRhdGEgZW50cmllc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIGFsbCBtZXRhZGF0YSBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXJNZXRhZGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFQcmVmaXggPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6YDtcbiAgICAgIGNvbnN0IGtleXNUb0RlbGV0ZTogc3RyaW5nW10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXNzaW9uU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzZXNzaW9uU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgobWV0YWRhdGFQcmVmaXgpKSB7XG4gICAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBrZXlzVG9EZWxldGUuZm9yRWFjaChrZXkgPT4gc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElnbm9yZSBlcnJvcnNcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0Q3VycmVudFNpemUoKTogUHJvbWlzZTx7IGl0ZW1Db3VudDogbnVtYmVyOyBzaXplQnl0ZXM6IG51bWJlciB9PiB7XG4gICAgbGV0IGl0ZW1Db3VudCA9IDA7XG4gICAgbGV0IHNpemVCeXRlcyA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIHByb2JlIHNlc3Npb25TdG9yYWdlIGFjY2Vzc1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uua2V5KDApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWYgYmFzaWMgYWNjZXNzIGZhaWxzLCByZXR1cm4gemVyb3MgYXMgcmVxdWlyZWQgYnkgdGVzdHNcbiAgICAgIHJldHVybiB7IGl0ZW1Db3VudDogMCwgc2l6ZUJ5dGVzOiAwIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgLy8gT25seSBjb3VudCBhY3R1YWwgaXRlbXMsIG5vdCBtZXRhZGF0YSBvciBxdWVyeSByZXN1bHRzXG4gICAgICAgIGlmICgha2V5LmluY2x1ZGVzKCc6bWV0YWRhdGE6JykgJiYgIWtleS5pbmNsdWRlcygnOnF1ZXJ5OicpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAvLyBPbmx5IGNvdW50IHZhbGlkIGl0ZW1zIHdpdGggcHJvcGVyIHZlcmlmaWNhdGlvblxuICAgICAgICAgICAgICBpZiAocGFyc2VkPy5vcmlnaW5hbEtleSAmJiBwYXJzZWQ/Lm9yaWdpbmFsVmVyaWZpY2F0aW9uSGFzaCA9PT0gdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24ocGFyc2VkLm9yaWdpbmFsS2V5KSkge1xuICAgICAgICAgICAgICAgIGl0ZW1Db3VudCsrO1xuICAgICAgICAgICAgICAgIHNpemVCeXRlcyArPSBuZXcgQmxvYihbdmFsdWVdKS5zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAvLyBTa2lwIGludmFsaWQgZW50cmllc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gT24gYW55IGVycm9yIGFmdGVyIGluaXRpYWwgcHJvYmUsIHJldHVybiB6ZXJvc1xuICAgICAgcmV0dXJuIHsgaXRlbUNvdW50OiAwLCBzaXplQnl0ZXM6IDAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBpdGVtQ291bnQsIHNpemVCeXRlcyB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFNpemVMaW1pdHMoKTogUHJvbWlzZTx7IG1heEl0ZW1zOiBudW1iZXIgfCBudWxsOyBtYXhTaXplQnl0ZXM6IG51bWJlciB8IG51bGwgfT4ge1xuICAgIC8vIFNlc3Npb25TdG9yYWdlIHR5cGljYWxseSBoYXMgYSB+NU1CIGxpbWl0XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEl0ZW1zOiBudWxsLCAvLyBObyBzcGVjaWZpYyBpdGVtIGxpbWl0XG4gICAgICBtYXhTaXplQnl0ZXM6IDUgKiAxMDI0ICogMTAyNCAvLyA1TUIgY29uc2VydmF0aXZlIGVzdGltYXRlXG4gICAgfTtcbiAgfVxuXG59XG4iLCJpbXBvcnQge1xuICBBbGxJdGVtVHlwZUFycmF5cyxcbiAgQ29tS2V5LFxuICBpc0NvbUtleSxcbiAgaXNRdWVyeU1hdGNoLFxuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSB9IGZyb20gXCIuLi9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5XCI7XG5pbXBvcnQgeyBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uLCBpc0xvY0tleUFycmF5RXF1YWwsIFF1ZXJ5Q2FjaGVFbnRyeSB9IGZyb20gXCIuLi9ub3JtYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBBc3luY0luZGV4REJDYWNoZU1hcCB9IGZyb20gXCIuL0FzeW5jSW5kZXhEQkNhY2hlTWFwXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7IENhY2hlTWFwIH0gZnJvbSBcIi4uL0NhY2hlTWFwXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJJbmRleERCQ2FjaGVNYXBcIik7XG5cbmludGVyZmFjZSBNZW1vcnlFbnRyeTxLLCBWPiB7XG4gIG9yaWdpbmFsS2V5OiBLO1xuICB2YWx1ZTogVjtcbiAgbWV0YWRhdGE/OiBDYWNoZUl0ZW1NZXRhZGF0YTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyBJbmRleGVkREIgQ2FjaGVNYXAgd3JhcHBlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHByb3ZpZGVzIHN5bmNocm9ub3VzIG1lbW9yeSBvcGVyYXRpb25zIHdpdGggYmFja2dyb3VuZCBJbmRleGVkREIgcGVyc2lzdGVuY2UuXG4gKiBNZW1vcnkgb3BlcmF0aW9ucyBhcmUgaW1tZWRpYXRlIHdoaWxlIEluZGV4ZWREQiBvcGVyYXRpb25zIGhhcHBlbiBhc3luY2hyb25vdXNseSBpbiB0aGUgYmFja2dyb3VuZC5cbiAqXG4gKiBCZW5lZml0czpcbiAqIC0gRmFzdCBtZW1vcnkgYWNjZXNzIGZvciBpbW1lZGlhdGUgb3BlcmF0aW9uc1xuICogLSBCYWNrZ3JvdW5kIHBlcnNpc3RlbmNlIHRvIEluZGV4ZWREQiBmb3IgZHVyYWJpbGl0eVxuICogLSBTeW5jaHJvbm91cyBBUEkgY29tcGF0aWJsZSB3aXRoIG90aGVyIENhY2hlTWFwIGltcGxlbWVudGF0aW9uc1xuICogLSBBdXRvbWF0aWMgc3luYyBiZXR3ZWVuIG1lbW9yeSBhbmQgSW5kZXhlZERCXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleERCQ2FjaGVNYXA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcblxuICBwdWJsaWMgcmVhZG9ubHkgaW1wbGVtZW50YXRpb25UeXBlID0gXCJicm93c2VyL2luZGV4ZWREQlwiO1xuXG4gIC8vIE1lbW9yeSBzdG9yYWdlXG4gIHByaXZhdGUgbWVtb3J5TWFwOiB7IFtrZXk6IHN0cmluZ106IE1lbW9yeUVudHJ5PENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LCBWPiB9ID0ge307XG4gIHByaXZhdGUgcXVlcnlSZXN1bHRDYWNoZTogeyBbcXVlcnlIYXNoOiBzdHJpbmddOiBRdWVyeUNhY2hlRW50cnkgfSA9IHt9O1xuICBwcml2YXRlIG1ldGFkYXRhTWFwOiBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pID0+IHN0cmluZztcbiAgcHJvdGVjdGVkIHR5cGVzOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8vIEluZGV4ZWREQiBmb3IgcGVyc2lzdGVuY2VcbiAgcHVibGljIGFzeW5jQ2FjaGU6IEFzeW5jSW5kZXhEQkNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLy8gQmFja2dyb3VuZCBzeW5jIG1hbmFnZW1lbnRcbiAgcHJpdmF0ZSBzeW5jSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcGVuZGluZ09wZXJhdGlvbnM6IEFycmF5PHtcbiAgICB0eXBlOiAnc2V0JyB8ICdkZWxldGUnIHwgJ2NsZWFyJztcbiAgICBrZXk/OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPjtcbiAgICB2YWx1ZT86IFY7XG4gICAgbWV0YWRhdGE/OiBDYWNoZUl0ZW1NZXRhZGF0YTtcbiAgICBzZXF1ZW5jZUlkOiBudW1iZXI7XG4gIH0+ID0gW107XG4gIHByaXZhdGUgc2VxdWVuY2VDb3VudGVyID0gMDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgdHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgZGJOYW1lOiBzdHJpbmcgPSAnZmplbGwtaW5kZXhkYi1jYWNoZScsXG4gICAgc3RvcmVOYW1lOiBzdHJpbmcgPSAnY2FjaGUnLFxuICAgIHZlcnNpb246IG51bWJlciA9IDFcbiAgKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uPENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+PigpO1xuICAgIHRoaXMuYXN5bmNDYWNoZSA9IG5ldyBBc3luY0luZGV4REJDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KHR5cGVzLCBkYk5hbWUsIHN0b3JlTmFtZSwgdmVyc2lvbik7XG5cbiAgICAvLyBJbml0aWFsaXplIGZyb20gSW5kZXhlZERCIGFuZCBzdGFydCBiYWNrZ3JvdW5kIHN5bmNcbiAgICB0aGlzLmluaXRpYWxpemVGcm9tSW5kZXhlZERCKCk7XG4gICAgdGhpcy5zdGFydFBlcmlvZGljU3luYygpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplRnJvbUluZGV4ZWREQigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IHRoaXMuYXN5bmNDYWNoZS5rZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgICAvLyBPbmx5IGxvYWQgaWYgbm90IGFscmVhZHkgaW4gbWVtb3J5IGNhY2hlXG4gICAgICAgIGlmICghdGhpcy5tZW1vcnlNYXBbaGFzaGVkS2V5XSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5hc3luY0NhY2hlLmdldChrZXkpO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tZW1vcnlNYXBbaGFzaGVkS2V5XSA9IHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxLZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBpbml0aWFsaXplIGZyb20gSW5kZXhlZERCLCB1c2luZyBtZW1vcnktb25seSBtb2RlOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXJ0UGVyaW9kaWNTeW5jKCk6IHZvaWQge1xuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBvcGVyYXRpb25zIGV2ZXJ5IDEwbXMgZm9yIHJlc3BvbnNpdmUgc3luY2luZ1xuICAgIHRoaXMuc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ09wZXJhdGlvbnMoKTtcbiAgICB9LCAxMCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NQZW5kaW5nT3BlcmF0aW9ucygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5wZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbLi4udGhpcy5wZW5kaW5nT3BlcmF0aW9uc107XG4gICAgdGhpcy5wZW5kaW5nT3BlcmF0aW9ucyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBvcCBvZiBvcGVyYXRpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgaWYgKG9wLmtleSAmJiBvcC52YWx1ZSkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFzeW5jQ2FjaGUuc2V0KG9wLmtleSwgb3AudmFsdWUsIG9wLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICBpZiAob3Aua2V5KSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXN5bmNDYWNoZS5kZWxldGUob3Aua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NsZWFyJzpcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXN5bmNDYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHN5bmMgb3BlcmF0aW9uIHRvIEluZGV4ZWREQjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU3luY2hyb25vdXMgbWVtb3J5IG9wZXJhdGlvbnNcblxuICBwdWJsaWMgYXN5bmMgZ2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPFYgfCBudWxsPiB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1lbW9yeU1hcFtoYXNoZWRLZXldO1xuXG4gICAgaWYgKGVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSkge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LCB2YWx1ZTogVik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICAvLyBDcmVhdGUgbWV0YWRhdGFcbiAgICBjb25zdCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEgPSB7XG4gICAgICBrZXk6IEpTT04uc3RyaW5naWZ5KGtleSksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkubGVuZ3RoIC8vIHJvdWdoIGVzdGltYXRlXG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBtZW1vcnkgaW1tZWRpYXRlbHlcbiAgICB0aGlzLm1lbW9yeU1hcFtoYXNoZWRLZXldID0ge1xuICAgICAgb3JpZ2luYWxLZXk6IGtleSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG5cbiAgICAvLyBBZGQgdG8gcGVuZGluZyBvcGVyYXRpb25zIGZvciBiYWNrZ3JvdW5kIHN5bmNcbiAgICB0aGlzLnBlbmRpbmdPcGVyYXRpb25zLnB1c2goe1xuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgc2VxdWVuY2VJZDogKyt0aGlzLnNlcXVlbmNlQ291bnRlclxuICAgIH0pO1xuXG4gICAgLy8gVHJpZ2dlciBpbW1lZGlhdGUgc3luYyBmb3IgY3JpdGljYWwgb3BlcmF0aW9uc1xuICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5jbHVkZXNLZXkoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tZW1vcnlNYXBbaGFzaGVkS2V5XTtcbiAgICByZXR1cm4gISEoZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGUoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuXG4gICAgLy8gUmVtb3ZlIGZyb20gbWVtb3J5IGltbWVkaWF0ZWx5XG4gICAgZGVsZXRlIHRoaXMubWVtb3J5TWFwW2hhc2hlZEtleV07XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5kZWxldGUoaGFzaGVkS2V5KTtcblxuICAgIC8vIEFkZCB0byBwZW5kaW5nIG9wZXJhdGlvbnMgZm9yIGJhY2tncm91bmQgc3luY1xuICAgIHRoaXMucGVuZGluZ09wZXJhdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgIGtleSxcbiAgICAgIHNlcXVlbmNlSWQ6ICsrdGhpcy5zZXF1ZW5jZUNvdW50ZXJcbiAgICB9KTtcblxuICAgIC8vIFRyaWdnZXIgaW1tZWRpYXRlIHN5bmMgZm9yIGNyaXRpY2FsIG9wZXJhdGlvbnNcbiAgICB0aGlzLnByb2Nlc3NQZW5kaW5nT3BlcmF0aW9ucygpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtleXMoKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10+IHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1lbW9yeU1hcCkubWFwKGVudHJ5ID0+IGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB2YWx1ZXMoKTogUHJvbWlzZTxWW10+IHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1lbW9yeU1hcCkubWFwKGVudHJ5ID0+IGVudHJ5LnZhbHVlKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBDbGVhciBtZW1vcnkgaW1tZWRpYXRlbHlcbiAgICB0aGlzLm1lbW9yeU1hcCA9IHt9O1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICAgIHRoaXMubWV0YWRhdGFNYXAuY2xlYXIoKTtcblxuICAgIC8vIEFkZCB0byBwZW5kaW5nIG9wZXJhdGlvbnMgZm9yIGJhY2tncm91bmQgc3luY1xuICAgIHRoaXMucGVuZGluZ09wZXJhdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiAnY2xlYXInLFxuICAgICAgc2VxdWVuY2VJZDogKyt0aGlzLnNlcXVlbmNlQ291bnRlclxuICAgIH0pO1xuXG4gICAgLy8gVHJpZ2dlciBpbW1lZGlhdGUgc3luYyBmb3IgY3JpdGljYWwgb3BlcmF0aW9uc1xuICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWxsSW4obG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPFZbXT4ge1xuICAgIGNvbnN0IHJlc3VsdDogVltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXModGhpcy5tZW1vcnlNYXApKSB7XG4gICAgICBjb25zdCBrZXkgPSBlbnRyeS5vcmlnaW5hbEtleTtcblxuICAgICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gUmV0dXJuIGFsbCBpdGVtcyBpZiBubyBsb2NhdGlvbnMgc3BlY2lmaWVkXG4gICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5LnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDb21LZXkoa2V5KSkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdGVtIGlzIGluIHNwZWNpZmllZCBsb2NhdGlvbnNcbiAgICAgICAgaWYgKGlzTG9jS2V5QXJyYXlFcXVhbCgoa2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KS5sb2MsIGxvY2F0aW9ucykpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5OiBJdGVtUXVlcnksIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLnF1ZXJ5SW4ocXVlcnksIGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcXVlcnlJbihxdWVyeTogSXRlbVF1ZXJ5LCBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8VltdPiB7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcblxuICAgIGlmICghcXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICAgIH1cblxuICAgIHJldHVybiBjYW5kaWRhdGVzLmZpbHRlcihpdGVtID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kc1xuXG4gIHB1YmxpYyBhc3luYyBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZywgaXRlbUtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdID0ge1xuICAgICAgaXRlbUtleXNcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10gfCBudWxsPiB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeS5pdGVtS2V5cyA6IG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gcXVlcnlIYXNoIGluIHRoaXMucXVlcnlSZXN1bHRDYWNoZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhclF1ZXJ5UmVzdWx0cygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8vIEludmFsaWRhdGlvbiBtZXRob2RzXG5cbiAgcHVibGljIGFzeW5jIGludmFsaWRhdGVJdGVtS2V5cyhrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBJbnZhbGlkYXRlIHF1ZXJ5IHJlc3VsdHMgdGhhdCBjb250YWluIGFueSBvZiB0aGUgYWZmZWN0ZWQga2V5c1xuICAgIGZvciAoY29uc3QgcXVlcnlIYXNoIGluIHRoaXMucXVlcnlSZXN1bHRDYWNoZSkge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5pdGVtS2V5cy5zb21lKGtleSA9PiBrZXlzLnNvbWUoYWZmZWN0ZWRLZXkgPT5cbiAgICAgICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGFmZmVjdGVkS2V5KSA9PT0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSlcbiAgICAgICkpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaXRlbXNUb0RlbGV0ZTogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXModGhpcy5tZW1vcnlNYXApKSB7XG4gICAgICBjb25zdCBrZXkgPSBlbnRyeS5vcmlnaW5hbEtleTtcblxuICAgICAgaWYgKGlzQ29tS2V5KGtleSkgJiYgaXNMb2NLZXlBcnJheUVxdWFsKChrZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pLmxvYywgbG9jYXRpb25zKSkge1xuICAgICAgICBpdGVtc1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhpdGVtc1RvRGVsZXRlKTtcbiAgfVxuXG4gIC8vIE1ldGFkYXRhIG9wZXJhdGlvbnNcblxuICBwdWJsaWMgYXN5bmMgZ2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPENhY2hlSXRlbU1ldGFkYXRhIHwgbnVsbD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhTWFwLmdldChrZXkpIHx8IG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcsIG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubWV0YWRhdGFNYXAuc2V0KGtleSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZU1ldGFkYXRhKGtleTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRBbGxNZXRhZGF0YSgpOiBQcm9taXNlPE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPj4ge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMubWV0YWRhdGFNYXApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyTWV0YWRhdGEoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5jbGVhcigpO1xuICB9XG5cbiAgLy8gU2l6ZSBvcGVyYXRpb25zXG5cbiAgcHVibGljIGFzeW5jIGdldEN1cnJlbnRTaXplKCk6IFByb21pc2U8eyBpdGVtQ291bnQ6IG51bWJlcjsgc2l6ZUJ5dGVzOiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IGl0ZW1Db3VudCA9IE9iamVjdC5rZXlzKHRoaXMubWVtb3J5TWFwKS5sZW5ndGg7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIHNpemVcbiAgICBsZXQgc2l6ZUJ5dGVzID0gMDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXModGhpcy5tZW1vcnlNYXApKSB7XG4gICAgICBzaXplQnl0ZXMgKz0gSlNPTi5zdHJpbmdpZnkoZW50cnkudmFsdWUpLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4geyBpdGVtQ291bnQsIHNpemVCeXRlcyB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFNpemVMaW1pdHMoKTogUHJvbWlzZTx7IG1heEl0ZW1zOiBudW1iZXIgfCBudWxsOyBtYXhTaXplQnl0ZXM6IG51bWJlciB8IG51bGwgfT4ge1xuICAgIC8vIE1lbW9yeSBjYWNoZSBoYXMgbm8gaGFyZCBsaW1pdHMsIGJ1dCBJbmRleGVkREIgZG9lc1xuICAgIHJldHVybiB7IG1heEl0ZW1zOiBudWxsLCBtYXhTaXplQnl0ZXM6IG51bGwgfTtcbiAgfVxuXG4gIC8vIENsb25lIG9wZXJhdGlvblxuXG4gIHB1YmxpYyBhc3luYyBjbG9uZSgpOiBQcm9taXNlPENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+IHtcbiAgICBjb25zdCBjbG9uZWQgPSBuZXcgSW5kZXhEQkNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oXG4gICAgICB0aGlzLnR5cGVzLFxuICAgICAgJ2ZqZWxsLWluZGV4ZGItY2FjaGUtY2xvbmUnLFxuICAgICAgJ2NhY2hlLWNsb25lJyxcbiAgICAgIDFcbiAgICApO1xuXG4gICAgLy8gQ29weSBtZW1vcnkgc3RhdGVcbiAgICBjbG9uZWQubWVtb3J5TWFwID0geyAuLi50aGlzLm1lbW9yeU1hcCB9O1xuICAgIGNsb25lZC5xdWVyeVJlc3VsdENhY2hlID0geyAuLi50aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUgfTtcbiAgICBjbG9uZWQubWV0YWRhdGFNYXAgPSBuZXcgTWFwKHRoaXMubWV0YWRhdGFNYXApO1xuXG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCByZXNvdXJjZXMgd2hlbiB0aGUgY2FjaGUgaXMgbm8gbG9uZ2VyIG5lZWRlZFxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3luY0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0ludGVydmFsKTtcbiAgICAgIHRoaXMuc3luY0ludGVydmFsID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEFsbEl0ZW1UeXBlQXJyYXlzLFxuICBDb21LZXksXG4gIGlzQ29tS2V5LFxuICBpc1F1ZXJ5TWF0Y2gsXG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sIGlzTG9jS2V5QXJyYXlFcXVhbCB9IGZyb20gXCIuLi9ub3JtYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSB9IGZyb20gXCIuLi9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCBzYWZlU3RyaW5naWZ5IGZyb20gJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiQXN5bmNJbmRleERCQ2FjaGVNYXBcIik7XG5cbmludGVyZmFjZSBTdG9yZWRJdGVtPFY+IHtcbiAgb3JpZ2luYWxLZXk6IENvbUtleTxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55PiB8IFByaUtleTxhbnk+O1xuICB2YWx1ZTogVjtcbiAgbWV0YWRhdGE/OiBDYWNoZUl0ZW1NZXRhZGF0YTtcbiAgdmVyc2lvbjogbnVtYmVyOyAvLyBGb3IgZnV0dXJlIG1pZ3JhdGlvbiBzdXBwb3J0XG59XG5cbi8qKlxuICogSW5kZXhlZERCIGltcGxlbWVudGF0aW9uIG9mIENhY2hlTWFwIGZvciBicm93c2VyIGVudmlyb25tZW50cy5cbiAqIERhdGEgcGVyc2lzdHMgbG9uZy10ZXJtIHdpdGggbXVjaCBsYXJnZXIgc3RvcmFnZSBsaW1pdHMgdGhhbiBsb2NhbFN0b3JhZ2Uvc2Vzc2lvblN0b3JhZ2UuXG4gKlxuICogTm90ZTogSW5kZXhlZERCIGlzIGFzeW5jaHJvbm91cyBhbmQgY2FuIHN0b3JlIHN0cnVjdHVyZWQgZGF0YS5cbiAqIFN0b3JhZ2UgbGltaXQgaXMgaHVuZHJlZHMgb2YgTUIgb3IgbW9yZSBkZXBlbmRpbmcgb24gYnJvd3NlciBhbmQgdXNlci5cbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyBwcm9taXNlcyBmb3IgYWxsIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0luZGV4REJDYWNoZU1hcDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiB7XG4gIHByb3RlY3RlZCB0eXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgcHJpdmF0ZSBkYk5hbWU6IHN0cmluZztcbiAgcHJpdmF0ZSBzdG9yZU5hbWU6IHN0cmluZztcbiAgcHJpdmF0ZSB2ZXJzaW9uOiBudW1iZXI7XG4gIHByaXZhdGUgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pID0+IHN0cmluZztcbiAgcHJpdmF0ZSBkYlByb21pc2U6IFByb21pc2U8SURCRGF0YWJhc2U+IHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gQ3VycmVudCBzdG9yYWdlIGZvcm1hdCB2ZXJzaW9uXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENVUlJFTlRfVkVSU0lPTiA9IDE7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHR5cGVzOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGRiTmFtZTogc3RyaW5nID0gJ2ZqZWxsLWluZGV4ZGItY2FjaGUnLFxuICAgIHN0b3JlTmFtZTogc3RyaW5nID0gJ2NhY2hlJyxcbiAgICB2ZXJzaW9uOiBudW1iZXIgPSAxXG4gICkge1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICB0aGlzLmRiTmFtZSA9IGRiTmFtZTtcbiAgICB0aGlzLnN0b3JlTmFtZSA9IHN0b3JlTmFtZTtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb248Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4+KCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldERCKCk6IFByb21pc2U8SURCRGF0YWJhc2U+IHtcbiAgICBpZiAoIXRoaXMuZGJQcm9taXNlKSB7XG4gICAgICB0aGlzLmRiUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgSW5kZXhlZERCIGlzIGF2YWlsYWJsZSAobm90IGluIHNlcnZlci1zaWRlIGVudmlyb25tZW50KVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWREQiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdJbmRleGVkREIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50JykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBvcGVuaW5nIEluZGV4ZWREQicsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnSW5kZXhlZERCIG9wZW5lZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnSW5kZXhlZERCIHVwZ3JhZGUgbmVlZGVkJyk7XG4gICAgICAgICAgY29uc3QgZGIgPSAoZXZlbnQudGFyZ2V0IGFzIElEQk9wZW5EQlJlcXVlc3QpLnJlc3VsdDtcblxuICAgICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0aGlzLnN0b3JlTmFtZSkpIHtcbiAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnQ3JlYXRlZCBvYmplY3Qgc3RvcmUnLCB7IHN0b3JlTmFtZTogdGhpcy5zdG9yZU5hbWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGJQcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdG9yYWdlS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8ViB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldCcsIHsga2V5IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChzdG9yYWdlS2V5KTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIGZyb20gSW5kZXhlZERCJywgeyBrZXksIGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG9yZWQ6IFN0b3JlZEl0ZW08Vj4gfCB1bmRlZmluZWQgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoc3RvcmVkICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihzdG9yZWQub3JpZ2luYWxLZXkpID09PSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgcmVzb2x2ZShzdG9yZWQudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIEluZGV4ZWREQiBnZXQgb3BlcmF0aW9uJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBib3RoIHRoZSB2YWx1ZSBhbmQgbWV0YWRhdGEgZm9yIGFuIGl0ZW1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRXaXRoTWV0YWRhdGEoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8eyB2YWx1ZTogVjsgbWV0YWRhdGE/OiBDYWNoZUl0ZW1NZXRhZGF0YSB9IHwgbnVsbD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0V2l0aE1ldGFkYXRhJywgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZG9ubHknKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KHN0b3JhZ2VLZXkpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZnJvbSBJbmRleGVkREInLCB7IGtleSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlZDogU3RvcmVkSXRlbTxWPiB8IHVuZGVmaW5lZCA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGlmIChzdG9yZWQgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKHN0b3JlZC5vcmlnaW5hbEtleSkgPT09IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHN0b3JlZC52YWx1ZSxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0b3JlZC5tZXRhZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIGdldFdpdGhNZXRhZGF0YSBvcGVyYXRpb24nLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIHZhbHVlOiBWLCBtZXRhZGF0YT86IENhY2hlSXRlbU1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXQnLCB7IGtleSwgdmFsdWUsIGhhc01ldGFkYXRhOiAhIW1ldGFkYXRhIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG5cbiAgICAgIGNvbnN0IHN0b3JlZEl0ZW06IFN0b3JlZEl0ZW08Vj4gPSB7XG4gICAgICAgIG9yaWdpbmFsS2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBBc3luY0luZGV4REJDYWNoZU1hcC5DVVJSRU5UX1ZFUlNJT05cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoc3RvcmVkSXRlbSwgc3RvcmFnZUtleSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igc2V0dGluZyBpbiBJbmRleGVkREInLCB7IGtleSwgdmFsdWUsIGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBJbmRleGVkREIgc2V0IG9wZXJhdGlvbicsIHsga2V5LCB2YWx1ZSwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdG9yZSBpdGVtIGluIEluZGV4ZWREQjogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG9ubHkgdGhlIG1ldGFkYXRhIGZvciBhbiBleGlzdGluZyBpdGVtXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0TWV0YWRhdGEoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXRNZXRhZGF0YScsIHsga2V5LCBtZXRhZGF0YSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCB0aGlzLmdldFdpdGhNZXRhZGF0YShrZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0KGtleSwgZXhpc3RpbmcudmFsdWUsIG1ldGFkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuaW5nKCdBdHRlbXB0ZWQgdG8gc2V0IG1ldGFkYXRhIGZvciBub24tZXhpc3RlbnQgaXRlbScsIHsga2V5IH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIEluZGV4ZWREQiBzZXRNZXRhZGF0YSBvcGVyYXRpb24nLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgbWV0YWRhdGEgaW4gSW5kZXhlZERCOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbmNsdWRlc0tleShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZG9ubHknKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KHN0b3JhZ2VLZXkpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGtleSBpbiBJbmRleGVkREInLCB7IGtleSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlZDogU3RvcmVkSXRlbTxWPiB8IHVuZGVmaW5lZCA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oc3RvcmVkLm9yaWdpbmFsS2V5KSA9PT0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICAgICAgICByZXNvbHZlKG1hdGNoZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBJbmRleGVkREIgaW5jbHVkZXNLZXkgb3BlcmF0aW9uJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGUoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlJywgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZHdyaXRlJyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZShzdG9yYWdlS2V5KTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBkZWxldGluZyBmcm9tIEluZGV4ZWREQicsIHsga2V5LCBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIGRlbGV0ZSBvcGVyYXRpb24nLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGFsbEluKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxWW10+IHtcbiAgICBjb25zdCBhbGxLZXlzID0gYXdhaXQgdGhpcy5rZXlzKCk7XG5cbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5Jyk7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IGFsbEtleXMubWFwKGtleSA9PiB0aGlzLmdldChrZXkpKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBudWxsKSBhcyBWW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvY0tleXM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IGxvY2F0aW9ucztcbiAgICAgIGxvZ2dlci5kZWJ1ZygnYWxsSW4nLCB7IGxvY0tleXMsIGtleXM6IGFsbEtleXMubGVuZ3RoIH0pO1xuICAgICAgY29uc3QgZmlsdGVyZWRLZXlzID0gYWxsS2V5c1xuICAgICAgICAuZmlsdGVyKChrZXkpID0+IGtleSAmJiBpc0NvbUtleShrZXkpKVxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBDb21LZXkgPSBrZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdDb21wYXJpbmcgTG9jYXRpb24gS2V5cycsIHtcbiAgICAgICAgICAgIGxvY0tleXMsXG4gICAgICAgICAgICBDb21LZXksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NLZXlzLCBDb21LZXkubG9jKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gZmlsdGVyZWRLZXlzLm1hcChrZXkgPT4gdGhpcy5nZXQoa2V5KSk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdHMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gbnVsbCkgYXMgVltdO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb250YWlucyhxdWVyeTogSXRlbVF1ZXJ5LCBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnY29udGFpbnMnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHF1ZXJ5SW4oXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdxdWVyeUluJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IEFzeW5jSW5kZXhEQkNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIC8vIEluZGV4ZWREQiBpcyBzaGFyZWQgZ2xvYmFsbHksIHNvIGNsb25lIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aCBzYW1lIGRiIGNvbmZpZ1xuICAgIHJldHVybiBuZXcgQXN5bmNJbmRleERCQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pih0aGlzLnR5cGVzLCB0aGlzLmRiTmFtZSwgdGhpcy5zdG9yZU5hbWUsIHRoaXMudmVyc2lvbik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2V5cygpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXT4ge1xuICAgIGNvbnN0IGtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZG9ubHknKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUub3BlbkN1cnNvcigpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcga2V5cyBmcm9tIEluZGV4ZWREQicsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgY3Vyc29yID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0PElEQkN1cnNvcldpdGhWYWx1ZT4pLnJlc3VsdDtcbiAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWQ6IFN0b3JlZEl0ZW08Vj4gPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBrZXlzLnB1c2goc3RvcmVkLm9yaWdpbmFsS2V5KTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGtleXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIEluZGV4ZWREQiBrZXlzIG9wZXJhdGlvbicsIHsgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbWV0YWRhdGEgZW50cmllcyBmcm9tIEluZGV4ZWREQlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEFsbE1ldGFkYXRhKCk6IFByb21pc2U8TWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+PiB7XG4gICAgY29uc3QgbWV0YWRhdGFNYXAgPSBuZXcgTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+KCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkb25seScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyBtZXRhZGF0YSBmcm9tIEluZGV4ZWREQicsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgY3Vyc29yID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0PElEQkN1cnNvcldpdGhWYWx1ZT4pLnJlc3VsdDtcbiAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWQ6IFN0b3JlZEl0ZW08Vj4gPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RvcmVkLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHN0b3JlZC5vcmlnaW5hbEtleSk7XG4gICAgICAgICAgICAgIG1ldGFkYXRhTWFwLnNldChrZXlTdHIsIHN0b3JlZC5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShtZXRhZGF0YU1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIGdldEFsbE1ldGFkYXRhIG9wZXJhdGlvbicsIHsgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbWV0YWRhdGFNYXA7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHZhbHVlcygpOiBQcm9taXNlPFZbXT4ge1xuICAgIGNvbnN0IHZhbHVlczogVltdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkb25seScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBJbmRleGVkREInLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnNvciA9IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdDxJREJDdXJzb3JXaXRoVmFsdWU+KS5yZXN1bHQ7XG4gICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkOiBTdG9yZWRJdGVtPFY+ID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goc3RvcmVkLnZhbHVlKTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIHZhbHVlcyBvcGVyYXRpb24nLCB7IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ0NsZWFyaW5nIEluZGV4ZWREQiBjYWNoZScpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jbGVhcigpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIEluZGV4ZWREQiBjYWNoZScsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIEluZGV4ZWREQiBjbGVhciBvcGVyYXRpb24nLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFzeW5jIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHNcblxuICBhc3luYyBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZywgaXRlbUtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnc2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleXMgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3Igc2V0UXVlcnlSZXN1bHQnLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICBpdGVtS2V5c1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBxdWVyeUtleSA9IGBxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgICAgICAgIGNvbnN0IHB1dFJlcXVlc3QgPSBzdG9yZS5wdXQoc2FmZVN0cmluZ2lmeShlbnRyeSksIHF1ZXJ5S2V5KTtcblxuICAgICAgICAgIHB1dFJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHN0b3JlIHF1ZXJ5IHJlc3VsdCcsIHsgcXVlcnlIYXNoLCBlcnJvcjogcHV0UmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgIHJlamVjdChwdXRSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIHNldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3IgZ2V0UXVlcnlSZXN1bHQnLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICBjb25zdCBxdWVyeUtleSA9IGBxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgICAgICAgIGNvbnN0IGdldFJlcXVlc3QgPSBzdG9yZS5nZXQocXVlcnlLZXkpO1xuXG4gICAgICAgICAgZ2V0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcmV0cmlldmUgcXVlcnkgcmVzdWx0JywgeyBxdWVyeUhhc2gsIGVycm9yOiBnZXRSZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgICAgcmVqZWN0KGdldFJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBnZXRSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldFJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGJvdGggb2xkIGZvcm1hdCAoanVzdCBhcnJheSkgYW5kIG5ldyBmb3JtYXRcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2xkIGZvcm1hdCAtIHJldHVybiBhcyBpc1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE5ldyBmb3JtYXRcblxuICAgICAgICAgICAgICByZXNvbHZlKGVudHJ5Lml0ZW1LZXlzIHx8IG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBxdWVyeSByZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIGdldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2hhc1F1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICAgIHJldHVybiByZXN1bHQgIT09IG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gaGFzUXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2RlbGV0ZVF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3IgZGVsZXRlUXVlcnlSZXN1bHQnLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBgcXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICAgICAgICBjb25zdCBkZWxldGVSZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHF1ZXJ5S2V5KTtcblxuICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBxdWVyeSByZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgZXJyb3I6IGRlbGV0ZVJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgICByZWplY3QoZGVsZXRlUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBkZWxldGVRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGludmFsaWRhdGVJdGVtS2V5cyhrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2ludmFsaWRhdGVJdGVtS2V5cycsIHsga2V5cyB9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGludmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnaW52YWxpZGF0ZUxvY2F0aW9uJywgeyBsb2NhdGlvbnMgfSk7XG5cbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRm9yIHByaW1hcnkgaXRlbXMgKG5vIGxvY2F0aW9uKSwgdGhpcyB3b3VsZCByZXF1aXJlIGdldHRpbmcgYWxsIGl0ZW1zIGFuZCBmaWx0ZXJpbmdcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgY2xlYXIgYWxsIHF1ZXJ5IHJlc3VsdHNcbiAgICAgIGF3YWl0IHRoaXMuY2xlYXJRdWVyeVJlc3VsdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGNvbnRhaW5lZCBpdGVtcywgZ2V0IGFsbCBpdGVtcyBpbiB0aGUgbG9jYXRpb24gYW5kIGludmFsaWRhdGUgdGhlbVxuICAgICAgY29uc3QgaXRlbXNJbkxvY2F0aW9uID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgICAgY29uc3Qga2V5c1RvSW52YWxpZGF0ZSA9IGl0ZW1zSW5Mb2NhdGlvbi5tYXAoaXRlbSA9PiBpdGVtLmtleSk7XG4gICAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBhbGwgcXVlcnkgcmVzdWx0cyB0aGF0IG1pZ2h0IGJlIGFmZmVjdGVkXG4gICAgYXdhaXQgdGhpcy5jbGVhclF1ZXJ5UmVzdWx0cygpO1xuICB9XG5cbiAgYXN5bmMgY2xlYXJRdWVyeVJlc3VsdHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdjbGVhclF1ZXJ5UmVzdWx0cycpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMudmVyc2lvbik7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIG9wZW4gZGF0YWJhc2UgZm9yIGNsZWFyUXVlcnlSZXN1bHRzJywgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGIgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkd3JpdGUnKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgICAgIC8vIFVzZSBjdXJzb3IgdG8gaXRlcmF0ZSB0aHJvdWdoIGtleXMgYW5kIGRlbGV0ZSB0aG9zZSB0aGF0IHN0YXJ0IHdpdGggJ3F1ZXJ5OidcbiAgICAgICAgICBjb25zdCBjdXJzb3JSZXF1ZXN0ID0gc3RvcmUub3BlbkN1cnNvcigpO1xuICAgICAgICAgIGNvbnN0IGtleXNUb0RlbGV0ZTogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIG9wZW4gY3Vyc29yIGZvciBjbGVhclF1ZXJ5UmVzdWx0cycsIHsgZXJyb3I6IGN1cnNvclJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgICByZWplY3QoY3Vyc29yUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gY3Vyc29yUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuc3RhcnRzV2l0aCgncXVlcnk6JykpIHtcbiAgICAgICAgICAgICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm8gbW9yZSBlbnRyaWVzLCBub3cgZGVsZXRlIGFsbCBxdWVyeSBrZXlzXG4gICAgICAgICAgICAgIGlmIChrZXlzVG9EZWxldGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBkZWxldGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbFRvRGVsZXRlID0ga2V5c1RvRGVsZXRlLmxlbmd0aDtcblxuICAgICAgICAgICAgICBrZXlzVG9EZWxldGUuZm9yRWFjaChxdWVyeUtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVxdWVzdCA9IHN0b3JlLmRlbGV0ZShxdWVyeUtleSk7XG5cbiAgICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgcXVlcnkga2V5JywgeyBxdWVyeUtleSwgZXJyb3I6IGRlbGV0ZVJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICBkZWxldGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVkQ291bnQgPT09IHRvdGFsVG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpOyAvLyBDb250aW51ZSBldmVuIGlmIHNvbWUgZGVsZXRpb25zIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZWRDb3VudCA9PT0gdG90YWxUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIGNsZWFyUXVlcnlSZXN1bHRzJywgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgSXRlbSB9IGZyb20gJ0BmamVsbC9jb3JlJztcbmltcG9ydCB7IENhY2hlTWFwIH0gZnJvbSAnLi9DYWNoZU1hcCc7XG5pbXBvcnQgeyBNZW1vcnlDYWNoZU1hcCB9IGZyb20gJy4vbWVtb3J5L01lbW9yeUNhY2hlTWFwJztcbmltcG9ydCB7IEVuaGFuY2VkTWVtb3J5Q2FjaGVNYXAgfSBmcm9tICcuL21lbW9yeS9FbmhhbmNlZE1lbW9yeUNhY2hlTWFwJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZUNhY2hlTWFwIH0gZnJvbSAnLi9icm93c2VyL0xvY2FsU3RvcmFnZUNhY2hlTWFwJztcbmltcG9ydCB7IFNlc3Npb25TdG9yYWdlQ2FjaGVNYXAgfSBmcm9tICcuL2Jyb3dzZXIvU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcCc7XG5pbXBvcnQgeyBJbmRleERCQ2FjaGVNYXAgfSBmcm9tICcuL2Jyb3dzZXIvSW5kZXhEQkNhY2hlTWFwJztcblxuaW1wb3J0IHsgdmFsaWRhdGVTaXplQ29uZmlnIH0gZnJvbSAnLi91dGlscy9DYWNoZVNpemUnO1xuaW1wb3J0IHsgRXZpY3Rpb25TdHJhdGVneUNvbmZpZ3MgfSBmcm9tICcuL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lDb25maWcnO1xuXG4vKipcbiAqIEF2YWlsYWJsZSBjYWNoZSB0eXBlcyBmb3IgdGhlIGNhY2hlIGluc3RhbmNlXG4gKi9cbmV4cG9ydCB0eXBlIENhY2hlVHlwZSA9ICdtZW1vcnknIHwgJ2xvY2FsU3RvcmFnZScgfCAnc2Vzc2lvblN0b3JhZ2UnIHwgJ2luZGV4ZWREQicgfCAnYXN5bmNJbmRleGVkREInIHwgJ2N1c3RvbSc7XG5cbi8qKlxuICogQ2FjaGUgZXZpY3Rpb24gcG9saWNpZXMgZm9yIHdoZW4gY2FjaGUgc2l6ZSBsaW1pdHMgYXJlIHJlYWNoZWRcbiAqL1xuZXhwb3J0IHR5cGUgRXZpY3Rpb25Qb2xpY3kgPVxuICB8ICdscnUnICAgICAvLyBMZWFzdCBSZWNlbnRseSBVc2VkIC0gcmVtb3ZlcyBvbGRlc3QgcmVjZW50bHktYWNjZXNzZWQgaXRlbVxuICB8ICdsZnUnICAgICAvLyBMZWFzdCBGcmVxdWVudGx5IFVzZWQgLSByZW1vdmVzIGl0ZW0gd2l0aCBsb3dlc3QgYWNjZXNzIGZyZXF1ZW5jeVxuICB8ICdmaWZvJyAgICAvLyBGaXJzdC1JbiwgRmlyc3QtT3V0IC0gcmVtb3ZlcyBvbGRlc3QgYWRkZWQgaXRlbVxuICB8ICdtcnUnICAgICAvLyBNb3N0IFJlY2VudGx5IFVzZWQgLSByZW1vdmVzIG1vc3QgcmVjZW50bHkgdXNlZCBpdGVtXG4gIHwgJ3JhbmRvbScgIC8vIFJhbmRvbSBSZXBsYWNlbWVudCAtIGV2aWN0cyBhIHJhbmRvbSBpdGVtXG4gIHwgJ2FyYycgICAgIC8vIEFkYXB0aXZlIFJlcGxhY2VtZW50IENhY2hlIC0gYmFsYW5jZXMgcmVjZW5jeSBhbmQgZnJlcXVlbmN5XG4gIHwgJzJxJzsgICAgIC8vIFR3byBRdWV1ZXMgLSBrZWVwcyBzZXBhcmF0ZSBMUlUgbGlzdHMgZm9yIHJlY2VudCBhbmQgZnJlcXVlbnQgZW50cmllc1xuXG4vKipcbiAqIENhY2hlIHNpemUgY29uZmlndXJhdGlvbiBzdXBwb3J0aW5nIGJ5dGVzIGFuZCBpdGVtIGNvdW50IGxpbWl0c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlU2l6ZUNvbmZpZyB7XG4gIC8qKiBNYXhpbXVtIGNhY2hlIHNpemUgaW4gYnl0ZXMgKGUuZy4sICcxMDAnLCAnNUtCJywgJzEwTUInLCAnMkdCJywgJzFLaUInLCAnNTEyTWlCJykgKi9cbiAgbWF4U2l6ZUJ5dGVzPzogc3RyaW5nO1xuICAvKiogTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgaW4gY2FjaGUgKi9cbiAgbWF4SXRlbXM/OiBudW1iZXI7XG4gIC8qKiBAZGVwcmVjYXRlZCBFdmljdGlvbiBwb2xpY3kgaXMgbm93IGhhbmRsZWQgYnkgQ2FjaGUtbGV2ZWwgRXZpY3Rpb25NYW5hZ2VyIHZpYSBldmljdGlvbkNvbmZpZyAqL1xuICBldmljdGlvblBvbGljeT86IEV2aWN0aW9uUG9saWN5O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIEluZGV4ZWREQi1iYXNlZCBjYWNoZSBtYXBzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhlZERCQ29uZmlnIHtcbiAgLyoqIERhdGFiYXNlIG5hbWUgKGRlZmF1bHQ6ICdmamVsbC1jYWNoZScpICovXG4gIGRiTmFtZT86IHN0cmluZztcbiAgLyoqIERhdGFiYXNlIHZlcnNpb24gKGRlZmF1bHQ6IDEpICovXG4gIHZlcnNpb24/OiBudW1iZXI7XG4gIC8qKiBPYmplY3Qgc3RvcmUgbmFtZSAoZGVmYXVsdDogJ2NhY2hlJykgKi9cbiAgc3RvcmVOYW1lPzogc3RyaW5nO1xuICAvKiogU2l6ZSBjb25maWd1cmF0aW9uIGZvciBJbmRleGVkREIgY2FjaGUgKi9cbiAgc2l6ZT86IENhY2hlU2l6ZUNvbmZpZztcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBsb2NhbFN0b3JhZ2Uvc2Vzc2lvblN0b3JhZ2UtYmFzZWQgY2FjaGUgbWFwc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFdlYlN0b3JhZ2VDb25maWcge1xuICAvKiogS2V5IHByZWZpeCBmb3Igc3RvcmFnZSBpdGVtcyAoZGVmYXVsdDogJ2ZqZWxsLWNhY2hlOicpICovXG4gIGtleVByZWZpeD86IHN0cmluZztcbiAgLyoqIFdoZXRoZXIgdG8gY29tcHJlc3Mgc3RvcmVkIGRhdGEgKGRlZmF1bHQ6IGZhbHNlKSAqL1xuICBjb21wcmVzcz86IGJvb2xlYW47XG4gIC8qKiBTaXplIGNvbmZpZ3VyYXRpb24gZm9yIHdlYiBzdG9yYWdlIGNhY2hlICovXG4gIHNpemU/OiBDYWNoZVNpemVDb25maWc7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgbWVtb3J5LWJhc2VkIGNhY2hlIG1hcHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlDb25maWcge1xuICAvKiogTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8ga2VlcCBpbiBtZW1vcnkgKGRlZmF1bHQ6IHVubGltaXRlZCkgKi9cbiAgbWF4SXRlbXM/OiBudW1iZXI7XG4gIC8qKiBTaXplIGNvbmZpZ3VyYXRpb24gZm9yIG1lbW9yeSBjYWNoZSAqL1xuICBzaXplPzogQ2FjaGVTaXplQ29uZmlnO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGN1c3RvbSBjYWNoZSBtYXAgaW5zdGFuY2VzXG4gKi9cbmV4cG9ydCB0eXBlIENhY2hlTWFwRmFjdG9yeTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9IChrdGE6IFtTLCAuLi5zdHJpbmdbXV0pID0+IENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbi8qKlxuICogQ2FjaGUgb3B0aW9ucyBpbnRlcmZhY2UgZm9yIGNvbmZpZ3VyaW5nIGNhY2hlIGluc3RhbmNlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnM8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4ge1xuICAvKiogVGhlIHR5cGUgb2YgY2FjaGUgdG8gdXNlICovXG4gIGNhY2hlVHlwZTogQ2FjaGVUeXBlO1xuXG4gIC8qKiBDb25maWd1cmF0aW9uIGZvciBJbmRleGVkREIgY2FjaGUgdHlwZXMgKi9cbiAgaW5kZXhlZERCQ29uZmlnPzogSW5kZXhlZERCQ29uZmlnO1xuXG4gIC8qKiBDb25maWd1cmF0aW9uIGZvciB3ZWIgc3RvcmFnZSBjYWNoZSB0eXBlcyAqL1xuICB3ZWJTdG9yYWdlQ29uZmlnPzogV2ViU3RvcmFnZUNvbmZpZztcblxuICAvKiogQ29uZmlndXJhdGlvbiBmb3IgbWVtb3J5IGNhY2hlIHR5cGUgKi9cbiAgbWVtb3J5Q29uZmlnPzogTWVtb3J5Q29uZmlnO1xuXG4gIC8qKiBDdXN0b20gY2FjaGUgbWFwIGZhY3RvcnkgZm9yICdjdXN0b20nIGNhY2hlIHR5cGUgKi9cbiAgY3VzdG9tQ2FjaGVNYXBGYWN0b3J5PzogQ2FjaGVNYXBGYWN0b3J5PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLyoqIEV2aWN0aW9uIHN0cmF0ZWd5IGNvbmZpZ3VyYXRpb24gLSBpbmRlcGVuZGVudCBvZiBjYWNoZSBpbXBsZW1lbnRhdGlvbiAqL1xuICBldmljdGlvbkNvbmZpZz86IEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzO1xuXG4gIC8qKiBXaGV0aGVyIHRvIGVuYWJsZSBkZWJ1ZyBsb2dnaW5nIGZvciBjYWNoZSBvcGVyYXRpb25zICovXG4gIGVuYWJsZURlYnVnTG9nZ2luZz86IGJvb2xlYW47XG5cbiAgLyoqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBzeW5jIHdpdGggdGhlIEFQSSBvbiBjYWNoZSBtaXNzZXMgKi9cbiAgYXV0b1N5bmM/OiBib29sZWFuO1xuXG4gIC8qKiBDYWNoZSBleHBpcmF0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiB1bmxpbWl0ZWQpICovXG4gIHR0bD86IG51bWJlcjtcblxuICAvKiogTWF4aW11bSBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgZm9yIGZhaWxlZCBvcGVyYXRpb25zICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG5cbiAgLyoqIERlbGF5IGJldHdlZW4gcmV0cnkgYXR0ZW1wdHMgaW4gbWlsbGlzZWNvbmRzICovXG4gIHJldHJ5RGVsYXk/OiBudW1iZXI7XG59XG5cbi8qKlxuICogRGVmYXVsdCBjYWNoZSBvcHRpb25zXG4gKi9cbmNvbnN0IERFRkFVTFRfQ0FDSEVfT1BUSU9OUzogUGFydGlhbDxPcHRpb25zPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0ge1xuICBjYWNoZVR5cGU6ICdtZW1vcnknLFxuICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IGZhbHNlLFxuICBhdXRvU3luYzogdHJ1ZSxcbiAgbWF4UmV0cmllczogMyxcbiAgcmV0cnlEZWxheTogMTAwMCxcbiAgaW5kZXhlZERCQ29uZmlnOiB7XG4gICAgZGJOYW1lOiAnZmplbGwtY2FjaGUnLFxuICAgIHZlcnNpb246IDEsXG4gICAgc3RvcmVOYW1lOiAnY2FjaGUnLFxuICAgIHNpemU6IHtcbiAgICAgIGV2aWN0aW9uUG9saWN5OiAnbHJ1J1xuICAgIH1cbiAgfSxcbiAgd2ViU3RvcmFnZUNvbmZpZzoge1xuICAgIGtleVByZWZpeDogJ2ZqZWxsLWNhY2hlOicsXG4gICAgY29tcHJlc3M6IGZhbHNlLFxuICAgIHNpemU6IHtcbiAgICAgIGV2aWN0aW9uUG9saWN5OiAnbHJ1J1xuICAgIH1cbiAgfSxcbiAgbWVtb3J5Q29uZmlnOiB7XG4gICAgLy8gTm8gbGltaXRzIGJ5IGRlZmF1bHRcbiAgICBzaXplOiB7XG4gICAgICBldmljdGlvblBvbGljeTogJ2xydSdcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGNhY2hlIG9wdGlvbnMgd2l0aCBkZWZhdWx0c1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlT3B0aW9ucyA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihjYWNoZU9wdGlvbnM/OiBQYXJ0aWFsPE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4pOiBPcHRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICAvLyBEZWVwIGNsb25lIG5lc3RlZCBjb25maWcgb2JqZWN0cyB0byBwcmV2ZW50IG11dGF0aW9uIGJldHdlZW4gaW5zdGFuY2VzXG4gIGNvbnN0IGluZGV4ZWREQkNvbmZpZyA9IGNhY2hlT3B0aW9ucz8uaW5kZXhlZERCQ29uZmlnID8ge1xuICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5pbmRleGVkREJDb25maWcsXG4gICAgLi4uY2FjaGVPcHRpb25zLmluZGV4ZWREQkNvbmZpZyxcbiAgICBzaXplOiBjYWNoZU9wdGlvbnMuaW5kZXhlZERCQ29uZmlnLnNpemUgPyB7XG4gICAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMuaW5kZXhlZERCQ29uZmlnPy5zaXplLFxuICAgICAgLi4uY2FjaGVPcHRpb25zLmluZGV4ZWREQkNvbmZpZy5zaXplXG4gICAgfSA6IERFRkFVTFRfQ0FDSEVfT1BUSU9OUy5pbmRleGVkREJDb25maWc/LnNpemVcbiAgfSA6IHsgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLmluZGV4ZWREQkNvbmZpZyB9O1xuXG4gIGNvbnN0IHdlYlN0b3JhZ2VDb25maWcgPSBjYWNoZU9wdGlvbnM/LndlYlN0b3JhZ2VDb25maWcgPyB7XG4gICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLndlYlN0b3JhZ2VDb25maWcsXG4gICAgLi4uY2FjaGVPcHRpb25zLndlYlN0b3JhZ2VDb25maWcsXG4gICAgc2l6ZTogY2FjaGVPcHRpb25zLndlYlN0b3JhZ2VDb25maWcuc2l6ZSA/IHtcbiAgICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy53ZWJTdG9yYWdlQ29uZmlnPy5zaXplLFxuICAgICAgLi4uY2FjaGVPcHRpb25zLndlYlN0b3JhZ2VDb25maWcuc2l6ZVxuICAgIH0gOiBERUZBVUxUX0NBQ0hFX09QVElPTlMud2ViU3RvcmFnZUNvbmZpZz8uc2l6ZVxuICB9IDogeyAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMud2ViU3RvcmFnZUNvbmZpZyB9O1xuXG4gIGNvbnN0IG1lbW9yeUNvbmZpZyA9IGNhY2hlT3B0aW9ucz8ubWVtb3J5Q29uZmlnID8ge1xuICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5tZW1vcnlDb25maWcsXG4gICAgLi4uY2FjaGVPcHRpb25zLm1lbW9yeUNvbmZpZyxcbiAgICBzaXplOiBjYWNoZU9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUgPyB7XG4gICAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMubWVtb3J5Q29uZmlnPy5zaXplLFxuICAgICAgLi4uY2FjaGVPcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplXG4gICAgfSA6IERFRkFVTFRfQ0FDSEVfT1BUSU9OUy5tZW1vcnlDb25maWc/LnNpemVcbiAgfSA6IHsgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLm1lbW9yeUNvbmZpZyB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLFxuICAgIC4uLmNhY2hlT3B0aW9ucyxcbiAgICBpbmRleGVkREJDb25maWcsXG4gICAgd2ViU3RvcmFnZUNvbmZpZyxcbiAgICBtZW1vcnlDb25maWdcbiAgfSBhcyBPcHRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlIG1hcCBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ2FjaGVNYXAgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAga3RhOiBbUywgLi4uc3RyaW5nW11dLFxuICAgIG9wdGlvbnM6IE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgc3dpdGNoIChvcHRpb25zLmNhY2hlVHlwZSkge1xuICAgIGNhc2UgJ21lbW9yeSc6XG4gICAgICAvLyBVc2UgZW5oYW5jZWQgbWVtb3J5IGNhY2hlIGlmIHNpemUgY29uZmlndXJhdGlvbiBpcyBwcm92aWRlZFxuICAgICAgaWYgKG9wdGlvbnMubWVtb3J5Q29uZmlnPy5zaXplICYmXG4gICAgICAgIChvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heFNpemVCeXRlcyB8fCBvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heEl0ZW1zKSkge1xuICAgICAgICAvLyBDcmVhdGUgc2l6ZSBjb25maWcgd2l0aG91dCBldmljdGlvblBvbGljeSBzaW5jZSB0aGF0J3MgaGFuZGxlZCBieSBDYWNoZS1sZXZlbCBFdmljdGlvbk1hbmFnZXJcbiAgICAgICAgY29uc3Qgc2l6ZUNvbmZpZyA9IHtcbiAgICAgICAgICBtYXhTaXplQnl0ZXM6IG9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4U2l6ZUJ5dGVzLFxuICAgICAgICAgIG1heEl0ZW1zOiBvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heEl0ZW1zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRW5oYW5jZWRNZW1vcnlDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICAgIGt0YSBhcyBhbnksXG4gICAgICAgICAgc2l6ZUNvbmZpZ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNZW1vcnlDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KGt0YSBhcyBhbnkpO1xuXG4gICAgY2FzZSAnbG9jYWxTdG9yYWdlJzpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxTdG9yYWdlQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAga3RhIGFzIGFueSxcbiAgICAgICAgb3B0aW9ucy53ZWJTdG9yYWdlQ29uZmlnPy5rZXlQcmVmaXhcbiAgICAgICk7XG5cbiAgICBjYXNlICdzZXNzaW9uU3RvcmFnZSc6XG4gICAgICByZXR1cm4gbmV3IFNlc3Npb25TdG9yYWdlQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAga3RhIGFzIGFueSxcbiAgICAgICAgb3B0aW9ucy53ZWJTdG9yYWdlQ29uZmlnPy5rZXlQcmVmaXhcbiAgICAgICk7XG5cbiAgICBjYXNlICdpbmRleGVkREInOlxuICAgICAgcmV0dXJuIG5ldyBJbmRleERCQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAga3RhIGFzIGFueSxcbiAgICAgICAgb3B0aW9ucy5pbmRleGVkREJDb25maWc/LmRiTmFtZSxcbiAgICAgICAgb3B0aW9ucy5pbmRleGVkREJDb25maWc/LnN0b3JlTmFtZSxcbiAgICAgICAgb3B0aW9ucy5pbmRleGVkREJDb25maWc/LnZlcnNpb25cbiAgICAgICk7XG5cbiAgICBjYXNlICdjdXN0b20nOlxuICAgICAgaWYgKCFvcHRpb25zLmN1c3RvbUNhY2hlTWFwRmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBjYWNoZSBtYXAgZmFjdG9yeSBpcyByZXF1aXJlZCB3aGVuIGNhY2hlVHlwZSBpcyBcImN1c3RvbVwiJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5jdXN0b21DYWNoZU1hcEZhY3Rvcnkoa3RhKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNhY2hlIHR5cGU6ICR7b3B0aW9ucy5jYWNoZVR5cGV9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY2FjaGUgb3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVPcHRpb25zID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KG9wdGlvbnM6IE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pik6IHZvaWQgPT4ge1xuICBpZiAob3B0aW9ucy5jYWNoZVR5cGUgPT09ICdjdXN0b20nICYmICFvcHRpb25zLmN1c3RvbUNhY2hlTWFwRmFjdG9yeSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY3VzdG9tQ2FjaGVNYXBGYWN0b3J5IGlzIHJlcXVpcmVkIHdoZW4gY2FjaGVUeXBlIGlzIFwiY3VzdG9tXCInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXhSZXRyaWVzID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLm1heFJldHJpZXMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXhSZXRyaWVzIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV0cnlEZWxheSA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5yZXRyeURlbGF5IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmV0cnlEZWxheSBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnR0bCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy50dGwgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndHRsIG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5tZW1vcnlDb25maWc/Lm1heEl0ZW1zID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLm1lbW9yeUNvbmZpZy5tYXhJdGVtcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZW1vcnlDb25maWcubWF4SXRlbXMgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgc2l6ZSBjb25maWd1cmF0aW9uc1xuICBpZiAob3B0aW9ucy5tZW1vcnlDb25maWc/LnNpemUpIHtcbiAgICB2YWxpZGF0ZVNpemVDb25maWcob3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZz8uc2l6ZSkge1xuICAgIHZhbGlkYXRlU2l6ZUNvbmZpZyhvcHRpb25zLndlYlN0b3JhZ2VDb25maWcuc2l6ZSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaW5kZXhlZERCQ29uZmlnPy5zaXplKSB7XG4gICAgdmFsaWRhdGVTaXplQ29uZmlnKG9wdGlvbnMuaW5kZXhlZERCQ29uZmlnLnNpemUpO1xuICB9XG5cbiAgLy8gQnJvd3NlciBzdG9yYWdlIHZhbGlkYXRpb25cbiAgaWYgKFsnbG9jYWxTdG9yYWdlJywgJ3Nlc3Npb25TdG9yYWdlJ10uaW5jbHVkZXMob3B0aW9ucy5jYWNoZVR5cGUpKSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gYSByZWFsIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICBjb25zdCBpc1JlYWxCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoIWlzUmVhbEJyb3dzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLmNhY2hlVHlwZX0gaXMgbm90IGF2YWlsYWJsZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHNgKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbmRleGVkREIgdmFsaWRhdGlvblxuICBpZiAob3B0aW9ucy5jYWNoZVR5cGUgPT09ICdpbmRleGVkREInKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuaW5kZXhlZERCKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ucy5jYWNoZVR5cGV9IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudGApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFzeW5jSW5kZXhlZERCIHZhbGlkYXRpb24gLSBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCBzeW5jaHJvbm91cyBjYWNoZSBmYWN0b3J5XG4gIGlmIChvcHRpb25zLmNhY2hlVHlwZSA9PT0gJ2FzeW5jSW5kZXhlZERCJykge1xuICAgIHRocm93IG5ldyBFcnJvcignYXN5bmNJbmRleGVkREIgY2Fubm90IGJlIHVzZWQgd2l0aCBzeW5jaHJvbm91cyBjYWNoZSBmYWN0b3J5LiBVc2UgQXN5bmNJbmRleERCQ2FjaGVNYXAgZGlyZWN0bHkgZm9yIGFzeW5jIG9wZXJhdGlvbnMuJyk7XG4gIH1cbn07XG4iLCJpbXBvcnQge1xuICBJdGVtXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tIFwiLi4vQ2FjaGVNYXBcIjtcbmltcG9ydCB7IGNyZWF0ZUNhY2hlTWFwLCBPcHRpb25zLCB2YWxpZGF0ZU9wdGlvbnMgfSBmcm9tIFwiLi4vT3B0aW9uc1wiO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCJAZmplbGwvcmVnaXN0cnlcIjtcblxuZXhwb3J0IGNvbnN0IHJlc2V0ID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBjb29yZGluYXRlOiBDb29yZGluYXRlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIG9wdGlvbnM6IE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxbQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pl0+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBWYWxpZGF0ZSBvcHRpb25zIGJlZm9yZSBjcmVhdGluZyBjYWNoZSBtYXBcbiAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY2FjaGUgbWFwIHVzaW5nIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gYXMgdGhlIG9yaWdpbmFsXG4gICAgY29uc3QgY2FjaGVNYXAgPSBjcmVhdGVDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KGNvb3JkaW5hdGUua3RhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gW2NhY2hlTWFwXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBSZS10aHJvdyBhbnkgdmFsaWRhdGlvbiBvciBjcmVhdGlvbiBlcnJvcnNcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcbiIsImltcG9ydCB7IENvbUtleSwgSXRlbSwgSXRlbVF1ZXJ5LCBMb2NLZXlBcnJheSwgUHJpS2V5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiQGZqZWxsL2NsaWVudC1hcGlcIjtcbmltcG9ydCB7IENvb3JkaW5hdGUgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBDYWNoZU1hcCB9IGZyb20gXCIuL0NhY2hlTWFwXCI7XG5pbXBvcnQgeyBjcmVhdGVDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCB7IENhY2hlRXZlbnRFbWl0dGVyIH0gZnJvbSBcIi4vZXZlbnRzL0NhY2hlRXZlbnRFbWl0dGVyXCI7XG5cbi8vIEltcG9ydCBhbGwgb3BlcmF0aW9uIGZ1bmN0aW9uc1xuaW1wb3J0IHsgYWxsIH0gZnJvbSBcIi4vb3BzL2FsbFwiO1xuaW1wb3J0IHsgb25lIH0gZnJvbSBcIi4vb3BzL29uZVwiO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSBcIi4vb3BzL2NyZWF0ZVwiO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSBcIi4vb3BzL2dldFwiO1xuaW1wb3J0IHsgcmV0cmlldmUgfSBmcm9tIFwiLi9vcHMvcmV0cmlldmVcIjtcbmltcG9ydCB7IHJlbW92ZSB9IGZyb20gXCIuL29wcy9yZW1vdmVcIjtcbmltcG9ydCB7IHVwZGF0ZSB9IGZyb20gXCIuL29wcy91cGRhdGVcIjtcbmltcG9ydCB7IGFjdGlvbiB9IGZyb20gXCIuL29wcy9hY3Rpb25cIjtcbmltcG9ydCB7IGFsbEFjdGlvbiB9IGZyb20gXCIuL29wcy9hbGxBY3Rpb25cIjtcbmltcG9ydCB7IGZhY2V0IH0gZnJvbSBcIi4vb3BzL2ZhY2V0XCI7XG5pbXBvcnQgeyBhbGxGYWNldCB9IGZyb20gXCIuL29wcy9hbGxGYWNldFwiO1xuaW1wb3J0IHsgZmluZCB9IGZyb20gXCIuL29wcy9maW5kXCI7XG5pbXBvcnQgeyBmaW5kT25lIH0gZnJvbSBcIi4vb3BzL2ZpbmRPbmVcIjtcbmltcG9ydCB7IHNldCB9IGZyb20gXCIuL29wcy9zZXRcIjtcbmltcG9ydCB7IHJlc2V0IH0gZnJvbSBcIi4vb3BzL3Jlc2V0XCI7XG5pbXBvcnQgeyBPcHRpb25zIH0gZnJvbSBcIi4vT3B0aW9uc1wiO1xuaW1wb3J0IHsgVFRMTWFuYWdlciB9IGZyb20gXCIuL3R0bC9UVExNYW5hZ2VyXCI7XG5pbXBvcnQgeyBFdmljdGlvbk1hbmFnZXIgfSBmcm9tIFwiLi9ldmljdGlvbi9FdmljdGlvbk1hbmFnZXJcIjtcbmltcG9ydCB7IENhY2hlU3RhdHNNYW5hZ2VyIH0gZnJvbSBcIi4vQ2FjaGVTdGF0c1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdGlvbnM8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4+IHtcblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCB0aGUgaXRlbXMgdGhhdCBtYXRjaCB0aGUgcXVlcnkgZnJvbSBjYWNoZSBvciBBUEkuXG4gICAqIEl0ZW1zIGFyZSBjYWNoZWQgYXV0b21hdGljYWxseSBhZnRlciByZXRyaWV2YWwuXG4gICAqL1xuICBhbGwoXG4gICAgcXVlcnk/OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8VltdPjtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnkgZnJvbSBjYWNoZSBvciBBUEkuXG4gICAqIEl0ZW0gaXMgY2FjaGVkIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgcmV0cmlldmFsLlxuICAgKi9cbiAgb25lKFxuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApOiBQcm9taXNlPFYgfCBudWxsPjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpdGVtIHZpYSBBUEkgYW5kIGNhY2hlcyBpdC5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8Vj47XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gaXRlbSBieSBrZXkgZnJvbSBjYWNoZSBvciBBUEkgYW5kIGNhY2hlcyBpdC5cbiAgICovXG4gIGdldChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+XG4gICk6IFByb21pc2U8ViB8IG51bGw+O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIGNhY2hlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZyb20gQVBJLlxuICAgKi9cbiAgcmV0cmlldmUoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPlxuICApOiBQcm9taXNlPFYgfCBudWxsPjtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBpdGVtIHZpYSBBUEkgYW5kIGZyb20gY2FjaGUuXG4gICAqL1xuICByZW1vdmUoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPlxuICApOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGl0ZW0gdmlhIEFQSSBhbmQgY2FjaGVzIHRoZSByZXN1bHQuXG4gICAqL1xuICB1cGRhdGUoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj5cbiAgKTogUHJvbWlzZTxWPjtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYW4gYWN0aW9uIG9uIGFuIGl0ZW0gdmlhIEFQSSBhbmQgY2FjaGVzIHRoZSByZXN1bHQuXG4gICAqL1xuICBhY3Rpb24oXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5PzogYW55XG4gICk6IFByb21pc2U8Vj47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGFuIGFjdGlvbiBvbiBhbGwgaXRlbXMgbWF0Y2hpbmcgY3JpdGVyaWEgdmlhIEFQSSBhbmQgY2FjaGVzIHJlc3VsdHMuXG4gICAqL1xuICBhbGxBY3Rpb24oXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogUHJvbWlzZTxWW10+O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGZhY2V0IHF1ZXJ5IG9uIGFuIGl0ZW0gdmlhIEFQSSAocGFzcy10aHJvdWdoLCBubyBjYWNoaW5nKS5cbiAgICovXG4gIGZhY2V0KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj5cbiAgKTogUHJvbWlzZTxhbnk+O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGZhY2V0IHF1ZXJ5IG9uIGFsbCBpdGVtcyBtYXRjaGluZyBjcml0ZXJpYSB2aWEgQVBJIChwYXNzLXRocm91Z2gsIG5vIGNhY2hpbmcpLlxuICAgKi9cbiAgYWxsRmFjZXQoXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8YW55PjtcblxuICAvKipcbiAgICogRmluZHMgaXRlbXMgdXNpbmcgYSBmaW5kZXIgbWV0aG9kIHZpYSBBUEkgYW5kIGNhY2hlcyByZXN1bHRzLlxuICAgKi9cbiAgZmluZChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8VltdPjtcblxuICAvKipcbiAgICogRmluZHMgYSBzaW5nbGUgaXRlbSB1c2luZyBhIGZpbmRlciBtZXRob2QgdmlhIEFQSSBhbmQgY2FjaGVzIHJlc3VsdC5cbiAgICovXG4gIGZpbmRPbmUoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApOiBQcm9taXNlPFY+O1xuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGl0ZW0gZGlyZWN0bHkgaW4gY2FjaGUgd2l0aG91dCBBUEkgY2FsbC5cbiAgICovXG4gIHNldChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBQcm9taXNlPFY+O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGNhY2hlLCBjbGVhcmluZyBhbGwgY2FjaGVkIGl0ZW1zLlxuICAgKi9cbiAgcmVzZXQoKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU9wZXJhdGlvbnMgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgYXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBjb29yZGluYXRlOiBDb29yZGluYXRlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgY2FjaGVNYXA6IENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgcGtUeXBlOiBTLFxuICAgIG9wdGlvbnM6IE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBldmVudEVtaXR0ZXI6IENhY2hlRXZlbnRFbWl0dGVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgdHRsTWFuYWdlcjogVFRMTWFuYWdlcixcbiAgICBldmljdGlvbk1hbmFnZXI6IEV2aWN0aW9uTWFuYWdlcixcbiAgICBzdGF0c01hbmFnZXI6IENhY2hlU3RhdHNNYW5hZ2VyXG4gICk6IE9wZXJhdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjYWNoZSBjb250ZXh0IG9uY2UgYW5kIHJldXNlIGl0IGFjcm9zcyBhbGwgb3BlcmF0aW9uc1xuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FjaGVDb250ZXh0KGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgb3B0aW9ucywgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIHN0YXRzTWFuYWdlcik7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGw6IChxdWVyeSwgbG9jYXRpb25zKSA9PiBhbGwocXVlcnksIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBvbmU6IChxdWVyeSwgbG9jYXRpb25zKSA9PiBvbmUocXVlcnksIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBjcmVhdGU6IChpdGVtLCBsb2NhdGlvbnMpID0+IGNyZWF0ZShpdGVtLCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgZ2V0OiAoa2V5KSA9PiBnZXQoa2V5LCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIHJldHJpZXZlOiAoa2V5KSA9PiByZXRyaWV2ZShrZXksIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgcmVtb3ZlOiAoa2V5KSA9PiByZW1vdmUoa2V5LCBjb250ZXh0KS50aGVuKChjdHgpID0+IHVuZGVmaW5lZCksXG4gICAgdXBkYXRlOiAoa2V5LCBpdGVtKSA9PiB1cGRhdGUoa2V5LCBpdGVtLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGFjdGlvbjogKGtleSwgYWN0aW9uTmFtZSwgYm9keSkgPT4gYWN0aW9uKGtleSwgYWN0aW9uTmFtZSwgYm9keSwgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBhbGxBY3Rpb246IChhY3Rpb25OYW1lLCBib2R5LCBsb2NhdGlvbnMpID0+IGFsbEFjdGlvbihhY3Rpb25OYW1lLCBib2R5LCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgZmFjZXQ6IChrZXksIGZhY2V0TmFtZSwgcGFyYW1zKSA9PiBmYWNldChrZXksIGZhY2V0TmFtZSwgcGFyYW1zLCBjb250ZXh0KS50aGVuKHJlc3VsdCA9PiByZXN1bHQpLFxuICAgIGFsbEZhY2V0OiAoZmFjZXROYW1lLCBwYXJhbXMsIGxvY2F0aW9ucykgPT4gYWxsRmFjZXQoZmFjZXROYW1lLCBwYXJhbXMsIGxvY2F0aW9ucywgY29udGV4dCkudGhlbihyZXN1bHQgPT4gcmVzdWx0KSxcbiAgICBmaW5kOiAoZmluZGVyLCBwYXJhbXMsIGxvY2F0aW9ucykgPT4gZmluZChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGZpbmRPbmU6IChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zKSA9PiBmaW5kT25lKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgc2V0OiAoa2V5LCBpdGVtKSA9PiBzZXQoa2V5LCBpdGVtLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIHJlc2V0OiAoKSA9PiByZXNldChjb29yZGluYXRlLCBvcHRpb25zKS50aGVuKCgpID0+IHVuZGVmaW5lZClcbiAgfTtcbn07XG4iLCJpbXBvcnQge1xuICBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gIEV2aWN0aW9uQ29udGV4dCxcbiAgRXZpY3Rpb25TdHJhdGVneVxufSBmcm9tICcuL0V2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgZXN0aW1hdGVWYWx1ZVNpemUgfSBmcm9tICcuLi91dGlscy9DYWNoZVNpemUnO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tICcuLi9sb2dnZXInO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdFdmljdGlvbk1hbmFnZXInKTtcblxuLyoqXG4gKiBNYW5hZ2VzIGV2aWN0aW9uIGxvZ2ljIGluZGVwZW5kZW50bHkgb2YgQ2FjaGVNYXAgaW1wbGVtZW50YXRpb25zLlxuICogVGhpcyBjbGFzcyBjb29yZGluYXRlcyBiZXR3ZWVuIGV2aWN0aW9uIHN0cmF0ZWdpZXMgYW5kIGNhY2hlIG1ldGFkYXRhLlxuICovXG5leHBvcnQgY2xhc3MgRXZpY3Rpb25NYW5hZ2VyIHtcbiAgcHJpdmF0ZSBldmljdGlvblN0cmF0ZWd5OiBFdmljdGlvblN0cmF0ZWd5IHwgbnVsbDtcblxuICBjb25zdHJ1Y3RvcihldmljdGlvblN0cmF0ZWd5PzogRXZpY3Rpb25TdHJhdGVneSkge1xuICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneSA9IGV2aWN0aW9uU3RyYXRlZ3kgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3IgdXBkYXRlIHRoZSBldmljdGlvbiBzdHJhdGVneVxuICAgKiBAcGFyYW0gc3RyYXRlZ3kgLSBUaGUgZXZpY3Rpb24gc3RyYXRlZ3kgdG8gdXNlXG4gICAqL1xuICBwdWJsaWMgc2V0RXZpY3Rpb25TdHJhdGVneShzdHJhdGVneTogRXZpY3Rpb25TdHJhdGVneSB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICBsb2dnZXIuZGVidWcoJ0V2aWN0aW9uIHN0cmF0ZWd5IHVwZGF0ZWQnLCB7XG4gICAgICBzdHJhdGVneTogc3RyYXRlZ3k/LmdldFN0cmF0ZWd5TmFtZSgpIHx8ICdub25lJ1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBldmljdGlvbiBzdHJhdGVneSBuYW1lXG4gICAqIEByZXR1cm5zIFN0cmF0ZWd5IG5hbWUgb3IgbnVsbCBpZiBubyBldmljdGlvblxuICAgKi9cbiAgcHVibGljIGdldEV2aWN0aW9uU3RyYXRlZ3lOYW1lKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmV2aWN0aW9uU3RyYXRlZ3k/LmdldFN0cmF0ZWd5TmFtZSgpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGl0ZW0gYWNjZXNzIC0gdXBkYXRlIG1ldGFkYXRhIGZvciBldmljdGlvbiBzdHJhdGVneVxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKi9cbiAgcHVibGljIGFzeW5jIG9uSXRlbUFjY2Vzc2VkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuZXZpY3Rpb25TdHJhdGVneSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kub25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBldmljdGlvbiBzdHJhdGVneSBvbkl0ZW1BY2Nlc3NlZCcsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGl0ZW0gYWRkaXRpb24gLSB1cGRhdGUgbWV0YWRhdGEgYW5kIHBlcmZvcm0gZXZpY3Rpb24gaWYgbmVlZGVkXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gdmFsdWUgLSBJdGVtIHZhbHVlIChmb3Igc2l6ZSBlc3RpbWF0aW9uKVxuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGtleXMgdGhhdCB3ZXJlIGV2aWN0ZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBvbkl0ZW1BZGRlZDxUPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogVCxcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXJcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGV2aWN0ZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLmV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBldmljdGVkS2V5cztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKHZhbHVlKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLmNyZWF0ZUV2aWN0aW9uQ29udGV4dChtZXRhZGF0YVByb3ZpZGVyLCBlc3RpbWF0ZWRTaXplKTtcblxuICAgICAgLy8gUGVyZm9ybSBldmljdGlvbiBiZWZvcmUgYWRkaW5nIHRoZSBuZXcgaXRlbSBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGtleXNUb0V2aWN0ID0gYXdhaXQgdGhpcy5ldmljdGlvblN0cmF0ZWd5LnNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGV2aWN0S2V5IG9mIGtleXNUb0V2aWN0KSB7XG4gICAgICAgIC8vIExldCB0aGUgc3RyYXRlZ3kga25vdyBhYm91dCB0aGUgcmVtb3ZhbFxuICAgICAgICBhd2FpdCB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kub25JdGVtUmVtb3ZlZChldmljdEtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgICAgIGV2aWN0ZWRLZXlzLnB1c2goZXZpY3RLZXkpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgYWRkIG1ldGFkYXRhIGZvciB0aGUgbmV3IGl0ZW1cbiAgICAgIGF3YWl0IHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1BZGRlZChrZXksIGVzdGltYXRlZFNpemUsIG1ldGFkYXRhUHJvdmlkZXIpO1xuXG4gICAgICBpZiAoZXZpY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0l0ZW1zIGV2aWN0ZWQgZHVyaW5nIGFkZGl0aW9uJywge1xuICAgICAgICAgIG5ld0tleToga2V5LFxuICAgICAgICAgIGV2aWN0ZWRLZXlzLFxuICAgICAgICAgIHN0cmF0ZWd5OiB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kuZ2V0U3RyYXRlZ3lOYW1lKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gZXZpY3Rpb24gc3RyYXRlZ3kgb25JdGVtQWRkZWQnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2aWN0ZWRLZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBpdGVtIHJlbW92YWwgLSBjbGVhbiB1cCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKi9cbiAgcHVibGljIG9uSXRlbVJlbW92ZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5ldmljdGlvblN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gZXZpY3Rpb24gc3RyYXRlZ3kgb25JdGVtUmVtb3ZlZCcsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBtYW51YWwgZXZpY3Rpb24gY2hlY2tcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXlzIHRoYXQgd2VyZSBldmljdGVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcGVyZm9ybUV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBldmljdGVkS2V5czogc3RyaW5nW10gPSBbXTtcblxuICAgIGlmICghdGhpcy5ldmljdGlvblN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm4gZXZpY3RlZEtleXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLmNyZWF0ZUV2aWN0aW9uQ29udGV4dChtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IGtleXNUb0V2aWN0ID0gYXdhaXQgdGhpcy5ldmljdGlvblN0cmF0ZWd5LnNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGV2aWN0S2V5IG9mIGtleXNUb0V2aWN0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1SZW1vdmVkKGV2aWN0S2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICAgICAgZXZpY3RlZEtleXMucHVzaChldmljdEtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmljdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnTWFudWFsIGV2aWN0aW9uIHBlcmZvcm1lZCcsIHtcbiAgICAgICAgICBldmljdGVkS2V5cyxcbiAgICAgICAgICBzdHJhdGVneTogdGhpcy5ldmljdGlvblN0cmF0ZWd5LmdldFN0cmF0ZWd5TmFtZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIG1hbnVhbCBldmljdGlvbicsIHsgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2aWN0ZWRLZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGV2aWN0aW9uIGlzIHN1cHBvcnRlZCAoaS5lLiwgc3RyYXRlZ3kgaXMgc2V0KVxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGV2aWN0aW9uIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgcHVibGljIGlzRXZpY3Rpb25TdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXZpY3Rpb25TdHJhdGVneSAhPT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZXZpY3Rpb24gY29udGV4dCBmcm9tIGN1cnJlbnQgY2FjaGUgc3RhdGVcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKiBAcGFyYW0gbmV3SXRlbVNpemUgLSBTaXplIG9mIGl0ZW0gYmVpbmcgYWRkZWQgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyBFdmljdGlvbiBjb250ZXh0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZUV2aWN0aW9uQ29udGV4dChcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgbmV3SXRlbVNpemU/OiBudW1iZXJcbiAgKTogUHJvbWlzZTxFdmljdGlvbkNvbnRleHQ+IHtcbiAgICBjb25zdCBjdXJyZW50U2l6ZSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0Q3VycmVudFNpemUoKTtcbiAgICBjb25zdCBsaW1pdHMgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldFNpemVMaW1pdHMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50U2l6ZSxcbiAgICAgIGxpbWl0cyxcbiAgICAgIG5ld0l0ZW1TaXplXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBCYXNlIGNvbmZpZ3VyYXRpb24gaW50ZXJmYWNlIGZvciBldmljdGlvbiBzdHJhdGVnaWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXZpY3Rpb25TdHJhdGVneUNvbmZpZyB7XG4gIC8qKiBTdHJhdGVneSB0eXBlIGlkZW50aWZpZXIgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIExGVSBldmljdGlvbiBzdHJhdGVneSB3aXRoIGZyZXF1ZW5jeSBza2V0Y2hpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMRlVDb25maWcgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5Q29uZmlnIHtcbiAgcmVhZG9ubHkgdHlwZTogJ2xmdSc7XG4gIC8qKiBEZWNheSBmYWN0b3IgZm9yIGFnaW5nIGZyZXF1ZW5jeSBjb3VudHMgKDAuMCB0byAxLjAsIGRlZmF1bHQ6IDAuMSkgKi9cbiAgZGVjYXlGYWN0b3I/OiBudW1iZXI7XG4gIC8qKiBGcmVxdWVuY3kgZGVjYXkgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiA2MDAwMCkgKi9cbiAgZGVjYXlJbnRlcnZhbD86IG51bWJlcjtcbiAgLyoqIFdpZHRoIG9mIHRoZSBDb3VudC1NaW4gU2tldGNoIChkZWZhdWx0OiAxMDI0KSAqL1xuICBza2V0Y2hXaWR0aD86IG51bWJlcjtcbiAgLyoqIERlcHRoIG9mIHRoZSBDb3VudC1NaW4gU2tldGNoIChkZWZhdWx0OiA0KSAqL1xuICBza2V0Y2hEZXB0aD86IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgdG8gdXNlIHByb2JhYmlsaXN0aWMgY291bnRpbmcgKGRlZmF1bHQ6IHRydWUpICovXG4gIHVzZVByb2JhYmlsaXN0aWNDb3VudGluZz86IGJvb2xlYW47XG4gIC8qKiBNaW5pbXVtIGZyZXF1ZW5jeSB0aHJlc2hvbGQgYmVmb3JlIGRlY2F5IChkZWZhdWx0OiAxKSAqL1xuICBtaW5GcmVxdWVuY3lUaHJlc2hvbGQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgTFJVIGV2aWN0aW9uIHN0cmF0ZWd5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTFJVQ29uZmlnIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneUNvbmZpZyB7XG4gIHJlYWRvbmx5IHR5cGU6ICdscnUnO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIEZJRk8gZXZpY3Rpb24gc3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGSUZPQ29uZmlnIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneUNvbmZpZyB7XG4gIHJlYWRvbmx5IHR5cGU6ICdmaWZvJztcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBNUlUgZXZpY3Rpb24gc3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNUlVDb25maWcgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5Q29uZmlnIHtcbiAgcmVhZG9ubHkgdHlwZTogJ21ydSc7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgUmFuZG9tIGV2aWN0aW9uIHN0cmF0ZWd5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmFuZG9tQ29uZmlnIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneUNvbmZpZyB7XG4gIHJlYWRvbmx5IHR5cGU6ICdyYW5kb20nO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIEFSQyBldmljdGlvbiBzdHJhdGVneVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFSQ0NvbmZpZyBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3lDb25maWcge1xuICByZWFkb25seSB0eXBlOiAnYXJjJztcbiAgLyoqIE1heGltdW0gY2FjaGUgc2l6ZSBmb3IgQVJDIGNhbGN1bGF0aW9ucyAqL1xuICBtYXhDYWNoZVNpemU/OiBudW1iZXI7XG4gIC8qKiBGcmVxdWVuY3kgdGhyZXNob2xkIGZvciBjbGFzc2lmeWluZyBpdGVtcyBhcyBcImZyZXF1ZW50XCIgdnMgXCJyZWNlbnRcIiAoZGVmYXVsdDogMikgKi9cbiAgZnJlcXVlbmN5VGhyZXNob2xkPzogbnVtYmVyO1xuICAvKiogVXNlIGVuaGFuY2VkIGZyZXF1ZW5jeSB0cmFja2luZyB3aXRoIGRlY2F5IChkZWZhdWx0OiB0cnVlKSAqL1xuICB1c2VFbmhhbmNlZEZyZXF1ZW5jeT86IGJvb2xlYW47XG4gIC8qKiBEZWNheSBmYWN0b3IgZm9yIGFnaW5nIGZyZXF1ZW5jeSBzY29yZXMgKGRlZmF1bHQ6IDAuMDUpICovXG4gIGZyZXF1ZW5jeURlY2F5RmFjdG9yPzogbnVtYmVyO1xuICAvKiogRGVjYXkgaW50ZXJ2YWwgZm9yIGZyZXF1ZW5jeSBzY29yZXMgKGRlZmF1bHQ6IDYwMDAwMCAtIDEwIG1pbnV0ZXMpICovXG4gIGZyZXF1ZW5jeURlY2F5SW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKiBVc2UgZnJlcXVlbmN5LXdlaWdodGVkIHNlbGVjdGlvbiB3aXRoaW4gVDEvVDIgbGlzdHMgKGRlZmF1bHQ6IHRydWUpICovXG4gIHVzZUZyZXF1ZW5jeVdlaWdodGVkU2VsZWN0aW9uPzogYm9vbGVhbjtcbiAgLyoqIEFkYXB0aXZlIGxlYXJuaW5nIHJhdGUgZm9yIHRhcmdldCBzaXplIGFkanVzdG1lbnRzIChkZWZhdWx0OiAxLjApICovXG4gIGFkYXB0aXZlTGVhcm5pbmdSYXRlPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIDJRIGV2aWN0aW9uIHN0cmF0ZWd5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHdvUXVldWVDb25maWcgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5Q29uZmlnIHtcbiAgcmVhZG9ubHkgdHlwZTogJzJxJztcbiAgLyoqIE1heGltdW0gY2FjaGUgc2l6ZSBmb3IgMlEgY2FsY3VsYXRpb25zICovXG4gIG1heENhY2hlU2l6ZT86IG51bWJlcjtcbiAgLyoqIFVzZSBmcmVxdWVuY3ktYmFzZWQgcHJvbW90aW9uIGZyb20gcmVjZW50IHRvIGhvdCBxdWV1ZSAoZGVmYXVsdDogdHJ1ZSkgKi9cbiAgdXNlRnJlcXVlbmN5UHJvbW90aW9uPzogYm9vbGVhbjtcbiAgLyoqIE1pbmltdW0gYWNjZXNzIGZyZXF1ZW5jeSByZXF1aXJlZCBmb3IgcHJvbW90aW9uIHRvIGhvdCBxdWV1ZSAoZGVmYXVsdDogMikgKi9cbiAgcHJvbW90aW9uVGhyZXNob2xkPzogbnVtYmVyO1xuICAvKiogRGVjYXkgZmFjdG9yIGZvciBhZ2luZyBmcmVxdWVuY3kgc2NvcmVzIGluIGhvdCBxdWV1ZSAoZGVmYXVsdDogMC4wNSkgKi9cbiAgaG90UXVldWVEZWNheUZhY3Rvcj86IG51bWJlcjtcbiAgLyoqIERlY2F5IGludGVydmFsIGZvciBob3QgcXVldWUgZnJlcXVlbmN5IHNjb3JlcyAoZGVmYXVsdDogMzAwMDAwIC0gNSBtaW51dGVzKSAqL1xuICBob3RRdWV1ZURlY2F5SW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKiBVc2UgZnJlcXVlbmN5LXdlaWdodGVkIExSVSBpbiBob3QgcXVldWUgaW5zdGVhZCBvZiBwdXJlIExSVSAoZGVmYXVsdDogdHJ1ZSkgKi9cbiAgdXNlRnJlcXVlbmN5V2VpZ2h0ZWRMUlU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFVuaW9uIHR5cGUgZm9yIGFsbCBldmljdGlvbiBzdHJhdGVneSBjb25maWd1cmF0aW9uc1xuICovXG5leHBvcnQgdHlwZSBFdmljdGlvblN0cmF0ZWd5Q29uZmlncyA9XG4gIHwgTEZVQ29uZmlnXG4gIHwgTFJVQ29uZmlnXG4gIHwgRklGT0NvbmZpZ1xuICB8IE1SVUNvbmZpZ1xuICB8IFJhbmRvbUNvbmZpZ1xuICB8IEFSQ0NvbmZpZ1xuICB8IFR3b1F1ZXVlQ29uZmlnO1xuXG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiB2YWx1ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTEZVX0NPTkZJRzogTEZVQ29uZmlnID0ge1xuICB0eXBlOiAnbGZ1JyxcbiAgZGVjYXlGYWN0b3I6IDAuMSxcbiAgZGVjYXlJbnRlcnZhbDogNjAwMDAsIC8vIDEgbWludXRlXG4gIHNrZXRjaFdpZHRoOiAxMDI0LFxuICBza2V0Y2hEZXB0aDogNCxcbiAgdXNlUHJvYmFiaWxpc3RpY0NvdW50aW5nOiB0cnVlLFxuICBtaW5GcmVxdWVuY3lUaHJlc2hvbGQ6IDFcbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FSQ19DT05GSUc6IEFSQ0NvbmZpZyA9IHtcbiAgdHlwZTogJ2FyYycsXG4gIG1heENhY2hlU2l6ZTogMTAwMCxcbiAgZnJlcXVlbmN5VGhyZXNob2xkOiAyLFxuICB1c2VFbmhhbmNlZEZyZXF1ZW5jeTogdHJ1ZSxcbiAgZnJlcXVlbmN5RGVjYXlGYWN0b3I6IDAuMDUsXG4gIGZyZXF1ZW5jeURlY2F5SW50ZXJ2YWw6IDYwMDAwMCwgLy8gMTAgbWludXRlc1xuICB1c2VGcmVxdWVuY3lXZWlnaHRlZFNlbGVjdGlvbjogdHJ1ZSxcbiAgYWRhcHRpdmVMZWFybmluZ1JhdGU6IDEuMFxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVFdPX1FVRVVFX0NPTkZJRzogVHdvUXVldWVDb25maWcgPSB7XG4gIHR5cGU6ICcycScsXG4gIG1heENhY2hlU2l6ZTogMTAwMCxcbiAgdXNlRnJlcXVlbmN5UHJvbW90aW9uOiB0cnVlLFxuICBwcm9tb3Rpb25UaHJlc2hvbGQ6IDIsXG4gIGhvdFF1ZXVlRGVjYXlGYWN0b3I6IDAuMDUsXG4gIGhvdFF1ZXVlRGVjYXlJbnRlcnZhbDogMzAwMDAwLCAvLyA1IG1pbnV0ZXNcbiAgdXNlRnJlcXVlbmN5V2VpZ2h0ZWRMUlU6IHRydWVcbn07XG4iLCIvKipcbiAqIE1ldGFkYXRhIGZvciB0cmFja2luZyBjYWNoZSBpdGVtIHVzYWdlIHBhdHRlcm5zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVJdGVtTWV0YWRhdGEge1xuICAvKiogV2hlbiB0aGUgaXRlbSB3YXMgZmlyc3QgYWRkZWQgdG8gY2FjaGUgKi9cbiAgYWRkZWRBdDogbnVtYmVyO1xuICAvKiogV2hlbiB0aGUgaXRlbSB3YXMgbGFzdCBhY2Nlc3NlZCAqL1xuICBsYXN0QWNjZXNzZWRBdDogbnVtYmVyO1xuICAvKiogTnVtYmVyIG9mIHRpbWVzIHRoZSBpdGVtIGhhcyBiZWVuIGFjY2Vzc2VkICovXG4gIGFjY2Vzc0NvdW50OiBudW1iZXI7XG4gIC8qKiBFc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgaXRlbSBpbiBieXRlcyAqL1xuICBlc3RpbWF0ZWRTaXplOiBudW1iZXI7XG4gIC8qKiBJdGVtIGtleSBmb3IgaWRlbnRpZmljYXRpb24gKi9cbiAga2V5OiBzdHJpbmc7XG4gIC8qKiBGcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSBhcHBsaWVkIChmb3IgTEZVIHdpdGggc2tldGNoaW5nKSAqL1xuICBmcmVxdWVuY3lTY29yZT86IG51bWJlcjtcbiAgLyoqIExhc3QgdGltZSBmcmVxdWVuY3kgd2FzIHVwZGF0ZWQgKGZvciBkZWNheSBjYWxjdWxhdGlvbnMpICovXG4gIGxhc3RGcmVxdWVuY3lVcGRhdGU/OiBudW1iZXI7XG4gIC8qKiBSYXcgZnJlcXVlbmN5IGNvdW50IGJlZm9yZSBkZWNheSAqL1xuICByYXdGcmVxdWVuY3k/OiBudW1iZXI7XG4gIC8qKiBBZGRpdGlvbmFsIHN0cmF0ZWd5LXNwZWNpZmljIG1ldGFkYXRhICovXG4gIHN0cmF0ZWd5RGF0YT86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBDYWNoZU1hcCBpbXBsZW1lbnRhdGlvbnMgdG8gc3VwcG9ydCBtZXRhZGF0YSBzdG9yYWdlXG4gKiBUaGlzIGFsbG93cyBldmljdGlvbiBzdHJhdGVnaWVzIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YSBpbmRlcGVuZGVudGx5IG9mIHRoZSBzdG9yYWdlIG1lY2hhbmlzbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciB7XG4gIC8qKlxuICAgKiBHZXQgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgaXRlbVxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHJldHVybnMgTWV0YWRhdGEgaWYgZXhpc3RzLCBudWxsIG90aGVyd2lzZVxuICAgKi9cbiAgZ2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPENhY2hlSXRlbU1ldGFkYXRhIHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIFNldCBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpdGVtXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSB0byBzdG9yZVxuICAgKi9cbiAgc2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcsIG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpdGVtXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKi9cbiAgZGVsZXRlTWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIG1ldGFkYXRhIGVudHJpZXNcbiAgICogQHJldHVybnMgTWFwIG9mIGFsbCBtZXRhZGF0YSBlbnRyaWVzXG4gICAqL1xuICBnZXRBbGxNZXRhZGF0YSgpOiBQcm9taXNlPE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPj47XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBtZXRhZGF0YVxuICAgKi9cbiAgY2xlYXJNZXRhZGF0YSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBjYWNoZSBzaXplIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGN1cnJlbnQgc2l6ZSBtZXRyaWNzXG4gICAqL1xuICBnZXRDdXJyZW50U2l6ZSgpOiBQcm9taXNlPHtcbiAgICBpdGVtQ291bnQ6IG51bWJlcjtcbiAgICBzaXplQnl0ZXM6IG51bWJlcjtcbiAgfT47XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzaXplIGxpbWl0c1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBzaXplIGxpbWl0cyAobnVsbCBtZWFucyB1bmxpbWl0ZWQpXG4gICAqL1xuICBnZXRTaXplTGltaXRzKCk6IFByb21pc2U8e1xuICAgIG1heEl0ZW1zOiBudW1iZXIgfCBudWxsO1xuICAgIG1heFNpemVCeXRlczogbnVtYmVyIHwgbnVsbDtcbiAgfT47XG59XG5cbi8qKlxuICogQ29udGV4dCBwcm92aWRlZCB0byBldmljdGlvbiBzdHJhdGVnaWVzIGZvciBkZWNpc2lvbiBtYWtpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmljdGlvbkNvbnRleHQge1xuICAvKiogQ3VycmVudCBjYWNoZSBzaXplIGluZm9ybWF0aW9uICovXG4gIGN1cnJlbnRTaXplOiB7XG4gICAgaXRlbUNvdW50OiBudW1iZXI7XG4gICAgc2l6ZUJ5dGVzOiBudW1iZXI7XG4gIH07XG4gIC8qKiBDYWNoZSBzaXplIGxpbWl0cyAqL1xuICBsaW1pdHM6IHtcbiAgICBtYXhJdGVtczogbnVtYmVyIHwgbnVsbDtcbiAgICBtYXhTaXplQnl0ZXM6IG51bWJlciB8IG51bGw7XG4gIH07XG4gIC8qKiBTaXplIG9mIHRoZSBpdGVtIGJlaW5nIGFkZGVkIChmb3IgcHJvYWN0aXZlIGV2aWN0aW9uKSAqL1xuICBuZXdJdGVtU2l6ZT86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBjYWNoZSBldmljdGlvbiBzdHJhdGVnaWVzLlxuICogRGVmaW5lcyB0aGUgY29yZSBjb250cmFjdCB0aGF0IGFsbCBldmljdGlvbiBwb2xpY2llcyBtdXN0IGltcGxlbWVudC5cbiAqXG4gKiBFdmljdGlvbiBzdHJhdGVnaWVzIGFyZSBub3cgY29tcGxldGVseSBpbmRlcGVuZGVudCBvZiBDYWNoZU1hcCBpbXBsZW1lbnRhdGlvbnNcbiAqIGFuZCBpbnRlcmFjdCB0aHJvdWdoIHRoZSBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRXZpY3Rpb25TdHJhdGVneSB7XG4gIC8qKlxuICAgKiBTZWxlY3Qgd2hpY2ggaXRlbXMgc2hvdWxkIGJlIGV2aWN0ZWQgYmFzZWQgb24gdGhlIHN0cmF0ZWd5IGFuZCBjb250ZXh0XG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gUHJvdmlkZXIgZm9yIGFjY2Vzc2luZyBjYWNoZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0gY29udGV4dCAtIEN1cnJlbnQgY2FjaGUgc3RhdGUgYW5kIGxpbWl0c1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXlzIHRvIGV2aWN0IChlbXB0eSBhcnJheSBpZiBubyBldmljdGlvbiBuZWVkZWQpXG4gICAqL1xuICBhYnN0cmFjdCBzZWxlY3RGb3JFdmljdGlvbihcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgY29udGV4dDogRXZpY3Rpb25Db250ZXh0XG4gICk6IFByb21pc2U8c3RyaW5nW10+O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgbWV0YWRhdGEgd2hlbiBhbiBpdGVtIGlzIGFjY2Vzc2VkXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIFByb3ZpZGVyIGZvciBhY2Nlc3NpbmcgY2FjaGUgbWV0YWRhdGFcbiAgICovXG4gIGFic3RyYWN0IG9uSXRlbUFjY2Vzc2VkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgbWV0YWRhdGEgd2hlbiBhbiBpdGVtIGlzIGFkZGVkXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gZXN0aW1hdGVkU2l6ZSAtIEVzdGltYXRlZCBzaXplIG9mIHRoZSBpdGVtIGluIGJ5dGVzXG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gUHJvdmlkZXIgZm9yIGFjY2Vzc2luZyBjYWNoZSBtZXRhZGF0YVxuICAgKi9cbiAgYWJzdHJhY3Qgb25JdGVtQWRkZWQoa2V5OiBzdHJpbmcsIGVzdGltYXRlZFNpemU6IG51bWJlciwgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgd2hlbiBhbiBpdGVtIGlzIHJlbW92ZWRcbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gUHJvdmlkZXIgZm9yIGFjY2Vzc2luZyBjYWNoZSBtZXRhZGF0YVxuICAgKi9cbiAgYWJzdHJhY3Qgb25JdGVtUmVtb3ZlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lL2lkZW50aWZpZXIgb2YgdGhpcyBldmljdGlvbiBzdHJhdGVneVxuICAgKiBAcmV0dXJucyBTdHJpbmcgaWRlbnRpZmllciBmb3IgdGhlIHN0cmF0ZWd5XG4gICAqL1xuICBhYnN0cmFjdCBnZXRTdHJhdGVneU5hbWUoKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgZXZpY3Rpb24gaXMgbmVlZGVkIGJhc2VkIG9uIGN1cnJlbnQgY29udGV4dFxuICAgKiBAcGFyYW0gY29udGV4dCAtIEN1cnJlbnQgY2FjaGUgc3RhdGUgYW5kIGxpbWl0c1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIGV2aWN0aW9uIHNob3VsZCBvY2N1clxuICAgKi9cbiAgcHJvdGVjdGVkIGlzRXZpY3Rpb25OZWVkZWQoY29udGV4dDogRXZpY3Rpb25Db250ZXh0KTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBjdXJyZW50U2l6ZSwgbGltaXRzLCBuZXdJdGVtU2l6ZSA9IDAgfSA9IGNvbnRleHQ7XG5cbiAgICAvLyBDaGVjayBpdGVtIGNvdW50IGxpbWl0XG4gICAgaWYgKGxpbWl0cy5tYXhJdGVtcyAhPT0gbnVsbCAmJiBjdXJyZW50U2l6ZS5pdGVtQ291bnQgPj0gbGltaXRzLm1heEl0ZW1zKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBzaXplIGxpbWl0IChpbmNsdWRpbmcgcG90ZW50aWFsIG5ldyBpdGVtKVxuICAgIGlmIChsaW1pdHMubWF4U2l6ZUJ5dGVzICE9PSBudWxsICYmXG4gICAgICAoY3VycmVudFNpemUuc2l6ZUJ5dGVzICsgbmV3SXRlbVNpemUpID4gbGltaXRzLm1heFNpemVCeXRlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBob3cgbWFueSBpdGVtcyBuZWVkIHRvIGJlIGV2aWN0ZWRcbiAgICogQHBhcmFtIGNvbnRleHQgLSBDdXJyZW50IGNhY2hlIHN0YXRlIGFuZCBsaW1pdHNcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGV2aWN0ZWRcbiAgICovXG4gIHByb3RlY3RlZCBjYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQ6IEV2aWN0aW9uQ29udGV4dCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBjdXJyZW50U2l6ZSwgbGltaXRzLCBuZXdJdGVtU2l6ZSA9IDAgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGV2aWN0aW9uQ291bnQgPSAwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGJhc2VkIG9uIGl0ZW0gY291bnQgbGltaXRcbiAgICBpZiAobGltaXRzLm1heEl0ZW1zICE9PSBudWxsICYmIGN1cnJlbnRTaXplLml0ZW1Db3VudCA+PSBsaW1pdHMubWF4SXRlbXMpIHtcbiAgICAgIGV2aWN0aW9uQ291bnQgPSBNYXRoLm1heChldmljdGlvbkNvdW50LCBjdXJyZW50U2l6ZS5pdGVtQ291bnQgLSBsaW1pdHMubWF4SXRlbXMgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgYmFzZWQgb24gc2l6ZSBsaW1pdCAodGhpcyBpcyBtb3JlIGNvbXBsZXggYW5kIGFwcHJveGltYXRlKVxuICAgIGlmIChsaW1pdHMubWF4U2l6ZUJ5dGVzICE9PSBudWxsICYmXG4gICAgICAoY3VycmVudFNpemUuc2l6ZUJ5dGVzICsgbmV3SXRlbVNpemUpID4gbGltaXRzLm1heFNpemVCeXRlcykge1xuICAgICAgLy8gQ29uc2VydmF0aXZlIGVzdGltYXRlOiBldmljdCBhdCBsZWFzdCAxIGl0ZW0sIHBvc3NpYmx5IG1vcmVcbiAgICAgIGNvbnN0IGV4Y2Vzc0J5dGVzID0gKGN1cnJlbnRTaXplLnNpemVCeXRlcyArIG5ld0l0ZW1TaXplKSAtIGxpbWl0cy5tYXhTaXplQnl0ZXM7XG4gICAgICBjb25zdCBhdmdJdGVtU2l6ZSA9IGN1cnJlbnRTaXplLml0ZW1Db3VudCA+IDAgPyBjdXJyZW50U2l6ZS5zaXplQnl0ZXMgLyBjdXJyZW50U2l6ZS5pdGVtQ291bnQgOiAxMDI0O1xuICAgICAgY29uc3QgZXN0aW1hdGVkRXZpY3Rpb25Db3VudCA9IE1hdGguY2VpbChleGNlc3NCeXRlcyAvIGF2Z0l0ZW1TaXplKTtcbiAgICAgIGV2aWN0aW9uQ291bnQgPSBNYXRoLm1heChldmljdGlvbkNvdW50LCBlc3RpbWF0ZWRFdmljdGlvbkNvdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZpY3Rpb25Db3VudDtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2FjaGVJdGVtTWV0YWRhdGEsXG4gIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgRXZpY3Rpb25Db250ZXh0LFxuICBFdmljdGlvblN0cmF0ZWd5XG59IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3knO1xuXG4vKipcbiAqIExSVSAoTGVhc3QgUmVjZW50bHkgVXNlZCkgZXZpY3Rpb24gc3RyYXRlZ3lcbiAqIFJlbW92ZXMgdGhlIGl0ZW0gdGhhdCB3YXMgYWNjZXNzZWQgbG9uZ2VzdCBhZ29cbiAqL1xuZXhwb3J0IGNsYXNzIExSVUV2aWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgYXN5bmMgc2VsZWN0Rm9yRXZpY3Rpb24oXG4gICAgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLFxuICAgIGNvbnRleHQ6IEV2aWN0aW9uQ29udGV4dFxuICApOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgaWYgKCF0aGlzLmlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgY29uc3Qga2V5c1RvRXZpY3Q6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBTb3J0IGJ5IGxhc3RBY2Nlc3NlZEF0IGFzY2VuZGluZyAob2xkZXN0IGZpcnN0KVxuICAgIGNvbnN0IHNvcnRlZEVudHJpZXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmVudHJpZXMoKSlcbiAgICAgIC5zb3J0KChbLCBhXSwgWywgYl0pID0+IGEubGFzdEFjY2Vzc2VkQXQgLSBiLmxhc3RBY2Nlc3NlZEF0KTtcblxuICAgIC8vIFRha2UgdGhlIG9sZGVzdCBpdGVtcyB1cCB0byBldmljdGlvbkNvdW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihldmljdGlvbkNvdW50LCBzb3J0ZWRFbnRyaWVzLmxlbmd0aCk7IGkrKykge1xuICAgICAga2V5c1RvRXZpY3QucHVzaChzb3J0ZWRFbnRyaWVzW2ldWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5c1RvRXZpY3Q7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BY2Nlc3NlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BZGRlZChrZXk6IHN0cmluZywgZXN0aW1hdGVkU2l6ZTogbnVtYmVyLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemVcbiAgICB9O1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1SZW1vdmVkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cblxuICBnZXRTdHJhdGVneU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2xydSc7XG4gIH1cbn1cbiIsIi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbnMgZm9yIGV2aWN0aW9uIHN0cmF0ZWd5IGNvbmZpZ3VyYXRpb25zXG4gKi9cbmltcG9ydCB7XG4gIEFSQ0NvbmZpZyxcbiAgRXZpY3Rpb25TdHJhdGVneUNvbmZpZ3MsXG4gIExGVUNvbmZpZyxcbiAgVHdvUXVldWVDb25maWdcbn0gZnJvbSAnLi9FdmljdGlvblN0cmF0ZWd5Q29uZmlnJztcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIG51bWJlciBpcyB3aXRoaW4gYSBzcGVjaWZpZWQgcmFuZ2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXJSYW5nZShcbiAgdmFsdWU6IG51bWJlcixcbiAgbWluOiBudW1iZXIsXG4gIG1heDogbnVtYmVyLFxuICBmaWVsZE5hbWU6IHN0cmluZ1xuKTogdm9pZCB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ZpZWxkTmFtZX0gbXVzdCBiZSBhIGZpbml0ZSBudW1iZXJgKTtcbiAgfVxuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGJlIGJldHdlZW4gJHttaW59IGFuZCAke21heH0sIGdvdCAke3ZhbHVlfWApO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSBudW1iZXIgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKHZhbHVlOiBudW1iZXIsIGZpZWxkTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ZpZWxkTmFtZX0gbXVzdCBiZSBhIGZpbml0ZSBudW1iZXJgKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgZ290ICR7dmFsdWV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW5pdGl6ZXMgTEZVIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycywgY29ycmVjdGluZyBpbnZhbGlkIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVMRlVDb25maWcoY29uZmlnOiBQYXJ0aWFsPExGVUNvbmZpZz4pOiBQYXJ0aWFsPExGVUNvbmZpZz4ge1xuICBjb25zdCBzYW5pdGl6ZWQgPSB7IC4uLmNvbmZpZyB9O1xuXG4gIC8vIFNhbml0aXplIGRlY2F5RmFjdG9yIHRvIGJlIGJldHdlZW4gMCBhbmQgMVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5kZWNheUZhY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoc2FuaXRpemVkLmRlY2F5RmFjdG9yIDwgMCkge1xuICAgICAgY29uc29sZS53YXJuKGBkZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmRlY2F5RmFjdG9yfS4gQ29ycmVjdGluZyB0byAwLmApO1xuICAgICAgc2FuaXRpemVkLmRlY2F5RmFjdG9yID0gMDtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5kZWNheUZhY3RvciA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihgZGVjYXlGYWN0b3IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGdvdCAke3Nhbml0aXplZC5kZWNheUZhY3Rvcn0uIENvcnJlY3RpbmcgdG8gMS5gKTtcbiAgICAgIHNhbml0aXplZC5kZWNheUZhY3RvciA9IDE7XG4gICAgfVxuICB9XG5cbiAgLy8gU2FuaXRpemUgZGVjYXlJbnRlcnZhbCB0byBiZSBwb3NpdGl2ZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5kZWNheUludGVydmFsID09PSAnbnVtYmVyJyAmJiBzYW5pdGl6ZWQuZGVjYXlJbnRlcnZhbCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBkZWNheUludGVydmFsIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5kZWNheUludGVydmFsfS4gQ29ycmVjdGluZyB0byAzMDAwMDAuYCk7XG4gICAgc2FuaXRpemVkLmRlY2F5SW50ZXJ2YWwgPSAzMDAwMDA7IC8vIDUgbWludXRlcyBkZWZhdWx0XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBza2V0Y2hXaWR0aCB0byBiZSBwb3NpdGl2ZSBhbmQgcmVhc29uYWJsZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5za2V0Y2hXaWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoc2FuaXRpemVkLnNrZXRjaFdpZHRoIDw9IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoV2lkdGggbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaFdpZHRofS4gQ29ycmVjdGluZyB0byAxMDI0LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaFdpZHRoID0gMTAyNDtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5za2V0Y2hXaWR0aCA8IDE2KSB7XG4gICAgICBjb25zb2xlLndhcm4oYHNrZXRjaFdpZHRoIHNob3VsZCBiZSBhdCBsZWFzdCAxNiBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaFdpZHRofS4gQ29ycmVjdGluZyB0byAxNi5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hXaWR0aCA9IDE2O1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLnNrZXRjaFdpZHRoID4gNjU1MzYpIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoV2lkdGggc2hvdWxkIG5vdCBleGNlZWQgNjU1MzYgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UsIGdvdCAke3Nhbml0aXplZC5za2V0Y2hXaWR0aH0uIENvcnJlY3RpbmcgdG8gNjU1MzYuYCk7XG4gICAgICBzYW5pdGl6ZWQuc2tldGNoV2lkdGggPSA2NTUzNjtcbiAgICB9XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBza2V0Y2hEZXB0aCB0byBiZSBwb3NpdGl2ZSBhbmQgcmVhc29uYWJsZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5za2V0Y2hEZXB0aCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoc2FuaXRpemVkLnNrZXRjaERlcHRoIDw9IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoRGVwdGggbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaERlcHRofS4gQ29ycmVjdGluZyB0byA0LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaERlcHRoID0gNDtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5za2V0Y2hEZXB0aCA8IDEpIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoRGVwdGggc2hvdWxkIGJlIGF0IGxlYXN0IDEgZm9yIG9wdGltYWwgYWNjdXJhY3ksIGdvdCAke3Nhbml0aXplZC5za2V0Y2hEZXB0aH0uIENvcnJlY3RpbmcgdG8gMS5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hEZXB0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuc2tldGNoRGVwdGggPiAxNikge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hEZXB0aCBzaG91bGQgbm90IGV4Y2VlZCAxNiBmb3Igb3B0aW1hbCBhY2N1cmFjeSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaERlcHRofS4gQ29ycmVjdGluZyB0byAxNi5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hEZXB0aCA9IDE2O1xuICAgIH1cbiAgfVxuXG4gIC8vIFNhbml0aXplIG1pbkZyZXF1ZW5jeVRocmVzaG9sZCB0byBiZSBwb3NpdGl2ZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5taW5GcmVxdWVuY3lUaHJlc2hvbGQgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5taW5GcmVxdWVuY3lUaHJlc2hvbGQgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgbWluRnJlcXVlbmN5VGhyZXNob2xkIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5taW5GcmVxdWVuY3lUaHJlc2hvbGR9LiBDb3JyZWN0aW5nIHRvIDEuYCk7XG4gICAgc2FuaXRpemVkLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA9IDE7XG4gIH1cblxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBMRlUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIChhZnRlciBzYW5pdGl6YXRpb24pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxGVUNvbmZpZyhjb25maWc6IFBhcnRpYWw8TEZVQ29uZmlnPik6IHZvaWQge1xuICBpZiAodHlwZW9mIGNvbmZpZy5kZWNheUZhY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZU51bWJlclJhbmdlKGNvbmZpZy5kZWNheUZhY3RvciwgMC4wLCAxLjAsICdkZWNheUZhY3RvcicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcuZGVjYXlJbnRlcnZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcuZGVjYXlJbnRlcnZhbCwgJ2RlY2F5SW50ZXJ2YWwnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLnNrZXRjaFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5za2V0Y2hXaWR0aCwgJ3NrZXRjaFdpZHRoJyk7XG4gICAgaWYgKGNvbmZpZy5za2V0Y2hXaWR0aCA8IDE2IHx8IGNvbmZpZy5za2V0Y2hXaWR0aCA+IDY1NTM2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNrZXRjaFdpZHRoIG11c3QgYmUgYmV0d2VlbiAxNiBhbmQgNjU1MzYsIGdvdCAke2NvbmZpZy5za2V0Y2hXaWR0aH1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5za2V0Y2hEZXB0aCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcuc2tldGNoRGVwdGgsICdza2V0Y2hEZXB0aCcpO1xuICAgIGlmIChjb25maWcuc2tldGNoRGVwdGggPCAxIHx8IGNvbmZpZy5za2V0Y2hEZXB0aCA+IDE2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNrZXRjaERlcHRoIG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxNiwgZ290ICR7Y29uZmlnLnNrZXRjaERlcHRofWApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcubWluRnJlcXVlbmN5VGhyZXNob2xkLCAnbWluRnJlcXVlbmN5VGhyZXNob2xkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW5pdGl6ZXMgQVJDIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycywgY29ycmVjdGluZyBpbnZhbGlkIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVBUkNDb25maWcoY29uZmlnOiBQYXJ0aWFsPEFSQ0NvbmZpZz4pOiBQYXJ0aWFsPEFSQ0NvbmZpZz4ge1xuICBjb25zdCBzYW5pdGl6ZWQgPSB7IC4uLmNvbmZpZyB9O1xuXG4gIC8vIFNhbml0aXplIG1heENhY2hlU2l6ZSB0byBiZSBwb3NpdGl2ZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgbWF4Q2FjaGVTaXplIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5tYXhDYWNoZVNpemV9LiBDb3JyZWN0aW5nIHRvIDEwMDAuYCk7XG4gICAgc2FuaXRpemVkLm1heENhY2hlU2l6ZSA9IDEwMDA7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBmcmVxdWVuY3lUaHJlc2hvbGQgdG8gYmUgcG9zaXRpdmVcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuZnJlcXVlbmN5VGhyZXNob2xkID09PSAnbnVtYmVyJyAmJiBzYW5pdGl6ZWQuZnJlcXVlbmN5VGhyZXNob2xkIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeVRocmVzaG9sZCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuZnJlcXVlbmN5VGhyZXNob2xkfS4gQ29ycmVjdGluZyB0byAyLmApO1xuICAgIHNhbml0aXplZC5mcmVxdWVuY3lUaHJlc2hvbGQgPSAyO1xuICB9XG5cbiAgLy8gU2FuaXRpemUgZnJlcXVlbmN5RGVjYXlGYWN0b3IgdG8gYmUgYmV0d2VlbiAwIGFuZCAxXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yID09PSAnbnVtYmVyJykge1xuICAgIGlmIChzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeURlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKGBmcmVxdWVuY3lEZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yfS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgICAgc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yID0gMTtcbiAgICB9XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBmcmVxdWVuY3lEZWNheUludGVydmFsIHRvIGJlIHBvc2l0aXZlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUludGVydmFsIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWx9LiBDb3JyZWN0aW5nIHRvIDYwMDAwLmApO1xuICAgIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUludGVydmFsID0gNjAwMDA7IC8vIDEgbWludXRlIGRlZmF1bHRcbiAgfVxuXG4gIC8vIFNhbml0aXplIGFkYXB0aXZlTGVhcm5pbmdSYXRlIHRvIGJlIGJldHdlZW4gMCBhbmQgMTBcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHNhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgYWRhcHRpdmVMZWFybmluZ1JhdGUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwLCBnb3QgJHtzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGV9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGUgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlID4gMTApIHtcbiAgICAgIGNvbnNvbGUud2FybihgYWRhcHRpdmVMZWFybmluZ1JhdGUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwLCBnb3QgJHtzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGV9LiBDb3JyZWN0aW5nIHRvIDEwLmApO1xuICAgICAgc2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlID0gMTA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNhbml0aXplZDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgQVJDIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAoYWZ0ZXIgc2FuaXRpemF0aW9uKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBUkNDb25maWcoY29uZmlnOiBQYXJ0aWFsPEFSQ0NvbmZpZz4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiBjb25maWcubWF4Q2FjaGVTaXplID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5tYXhDYWNoZVNpemUsICdtYXhDYWNoZVNpemUnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLmZyZXF1ZW5jeVRocmVzaG9sZCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcuZnJlcXVlbmN5VGhyZXNob2xkLCAnZnJlcXVlbmN5VGhyZXNob2xkJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZU51bWJlclJhbmdlKGNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciwgMC4wLCAxLjAsICdmcmVxdWVuY3lEZWNheUZhY3RvcicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCwgJ2ZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLmFkYXB0aXZlTGVhcm5pbmdSYXRlID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlTnVtYmVyUmFuZ2UoY29uZmlnLmFkYXB0aXZlTGVhcm5pbmdSYXRlLCAwLjAsIDEwLjAsICdhZGFwdGl2ZUxlYXJuaW5nUmF0ZScpO1xuICB9XG59XG5cbi8qKlxuICogU2FuaXRpemVzIFR3b1F1ZXVlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycywgY29ycmVjdGluZyBpbnZhbGlkIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVUd29RdWV1ZUNvbmZpZyhjb25maWc6IFBhcnRpYWw8VHdvUXVldWVDb25maWc+KTogUGFydGlhbDxUd29RdWV1ZUNvbmZpZz4ge1xuICBjb25zdCBzYW5pdGl6ZWQgPSB7IC4uLmNvbmZpZyB9O1xuXG4gIC8vIFNhbml0aXplIG1heENhY2hlU2l6ZSB0byBiZSBwb3NpdGl2ZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgbWF4Q2FjaGVTaXplIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5tYXhDYWNoZVNpemV9LiBDb3JyZWN0aW5nIHRvIDEwMDAuYCk7XG4gICAgc2FuaXRpemVkLm1heENhY2hlU2l6ZSA9IDEwMDA7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBwcm9tb3Rpb25UaHJlc2hvbGQgdG8gYmUgcG9zaXRpdmVcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQucHJvbW90aW9uVGhyZXNob2xkID09PSAnbnVtYmVyJyAmJiBzYW5pdGl6ZWQucHJvbW90aW9uVGhyZXNob2xkIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYHByb21vdGlvblRocmVzaG9sZCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQucHJvbW90aW9uVGhyZXNob2xkfS4gQ29ycmVjdGluZyB0byAyLmApO1xuICAgIHNhbml0aXplZC5wcm9tb3Rpb25UaHJlc2hvbGQgPSAyO1xuICB9XG5cbiAgLy8gU2FuaXRpemUgaG90UXVldWVEZWNheUZhY3RvciB0byBiZSBiZXR3ZWVuIDAgYW5kIDFcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGhvdFF1ZXVlRGVjYXlGYWN0b3IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGdvdCAke3Nhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yfS4gQ29ycmVjdGluZyB0byAwLmApO1xuICAgICAgc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPiAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGhvdFF1ZXVlRGVjYXlGYWN0b3IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGdvdCAke3Nhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yfS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgICAgc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNhbml0aXplIGhvdFF1ZXVlRGVjYXlJbnRlcnZhbCB0byBiZSBwb3NpdGl2ZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgaG90UXVldWVEZWNheUludGVydmFsIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5ob3RRdWV1ZURlY2F5SW50ZXJ2YWx9LiBDb3JyZWN0aW5nIHRvIDMwMDAwMC5gKTtcbiAgICBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUludGVydmFsID0gMzAwMDAwOyAvLyA1IG1pbnV0ZXMgZGVmYXVsdFxuICB9XG5cbiAgcmV0dXJuIHNhbml0aXplZDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgVHdvUXVldWUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIChhZnRlciBzYW5pdGl6YXRpb24pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVR3b1F1ZXVlQ29uZmlnKGNvbmZpZzogUGFydGlhbDxUd29RdWV1ZUNvbmZpZz4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiBjb25maWcubWF4Q2FjaGVTaXplID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5tYXhDYWNoZVNpemUsICdtYXhDYWNoZVNpemUnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLnByb21vdGlvblRocmVzaG9sZCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcucHJvbW90aW9uVGhyZXNob2xkLCAncHJvbW90aW9uVGhyZXNob2xkJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlTnVtYmVyUmFuZ2UoY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IsIDAuMCwgMS4wLCAnaG90UXVldWVEZWNheUZhY3RvcicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcuaG90UXVldWVEZWNheUludGVydmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwsICdob3RRdWV1ZURlY2F5SW50ZXJ2YWwnKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhbnkgZXZpY3Rpb24gc3RyYXRlZ3kgY29uZmlndXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFdmljdGlvblN0cmF0ZWd5Q29uZmlnKGNvbmZpZzogUGFydGlhbDxFdmljdGlvblN0cmF0ZWd5Q29uZmlncz4pOiB2b2lkIHtcbiAgaWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZ3VyYXRpb24gbXVzdCBiZSBhIG5vbi1udWxsIG9iamVjdCcpO1xuICB9XG5cbiAgaWYgKCFjb25maWcudHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBtdXN0IHNwZWNpZnkgYSB0eXBlJyk7XG4gIH1cblxuICBjb25zdCB2YWxpZFR5cGVzID0gWydsZnUnLCAnbHJ1JywgJ2ZpZm8nLCAnbXJ1JywgJ3JhbmRvbScsICdhcmMnLCAnMnEnXTtcbiAgaWYgKCF2YWxpZFR5cGVzLmluY2x1ZGVzKGNvbmZpZy50eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmljdGlvbiBzdHJhdGVneSB0eXBlOiAke2NvbmZpZy50eXBlfS4gTXVzdCBiZSBvbmUgb2Y6ICR7dmFsaWRUeXBlcy5qb2luKCcsICcpfWApO1xuICB9XG5cbiAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgIGNhc2UgJ2xmdSc6XG4gICAgICB2YWxpZGF0ZUxGVUNvbmZpZyhjb25maWcgYXMgUGFydGlhbDxMRlVDb25maWc+KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FyYyc6XG4gICAgICB2YWxpZGF0ZUFSQ0NvbmZpZyhjb25maWcgYXMgUGFydGlhbDxBUkNDb25maWc+KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzJxJzpcbiAgICAgIHZhbGlkYXRlVHdvUXVldWVDb25maWcoY29uZmlnIGFzIFBhcnRpYWw8VHdvUXVldWVDb25maWc+KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xydSc6XG4gICAgY2FzZSAnZmlmbyc6XG4gICAgY2FzZSAnbXJ1JzpcbiAgICBjYXNlICdyYW5kb20nOlxuICAgICAgLy8gVGhlc2Ugc3RyYXRlZ2llcyBoYXZlIG5vIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0byB2YWxpZGF0ZVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBkdWUgdG8gdGhlIHR5cGUgY2hlY2sgYWJvdmUsIGJ1dCBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGV2aWN0aW9uIHN0cmF0ZWd5IHR5cGU6ICR7KGNvbmZpZyBhcyBhbnkpLnR5cGV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW5pdGl6ZXMgY29uZmlndXJhdGlvbiBiYXNlZCBvbiB0eXBlXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplQ29uZmlnQnlUeXBlKGNvbmZpZzogUGFydGlhbDxFdmljdGlvblN0cmF0ZWd5Q29uZmlncz4pOiBQYXJ0aWFsPEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzPiB7XG4gIGlmICghY29uZmlnLnR5cGUpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgIGNhc2UgJ2xmdSc6XG4gICAgICByZXR1cm4gc2FuaXRpemVMRlVDb25maWcoY29uZmlnIGFzIFBhcnRpYWw8TEZVQ29uZmlnPik7XG4gICAgY2FzZSAnYXJjJzpcbiAgICAgIHJldHVybiBzYW5pdGl6ZUFSQ0NvbmZpZyhjb25maWcgYXMgUGFydGlhbDxBUkNDb25maWc+KTtcbiAgICBjYXNlICcycSc6XG4gICAgICByZXR1cm4gc2FuaXRpemVUd29RdWV1ZUNvbmZpZyhjb25maWcgYXMgUGFydGlhbDxUd29RdWV1ZUNvbmZpZz4pO1xuICAgIGNhc2UgJ2xydSc6XG4gICAgY2FzZSAnZmlmbyc6XG4gICAgY2FzZSAnbXJ1JzpcbiAgICBjYXNlICdyYW5kb20nOlxuICAgICAgLy8gVGhlc2Ugc3RyYXRlZ2llcyBoYXZlIG5vIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzYW5pdGl6ZVxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB2YWxpZGF0ZWQgY29uZmlndXJhdGlvbiB3aXRoIGRlZmF1bHRzIGFwcGxpZWQgYW5kIGludmFsaWQgdmFsdWVzIHNhbml0aXplZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmFsaWRhdGVkQ29uZmlnPFQgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5Q29uZmlncz4oXG4gIGJhc2VDb25maWc6IFQsXG4gIHVzZXJDb25maWc6IFBhcnRpYWw8VD5cbik6IFQge1xuICAvLyBNZXJnZSB3aXRoIGRlZmF1bHRzIGZpcnN0XG4gIGNvbnN0IG1lcmdlZENvbmZpZyA9IHsgLi4uYmFzZUNvbmZpZywgLi4udXNlckNvbmZpZyB9O1xuXG4gIC8vIFNhbml0aXplIHRoZSBtZXJnZWQgY29uZmlndXJhdGlvblxuICBjb25zdCBzYW5pdGl6ZWRDb25maWcgPSBzYW5pdGl6ZUNvbmZpZ0J5VHlwZShtZXJnZWRDb25maWcpO1xuXG4gIC8vIFZhbGlkYXRlIHRoZSBmaW5hbCBzYW5pdGl6ZWQgY29uZmlndXJhdGlvblxuICB2YWxpZGF0ZUV2aWN0aW9uU3RyYXRlZ3lDb25maWcoc2FuaXRpemVkQ29uZmlnKTtcblxuICByZXR1cm4gc2FuaXRpemVkQ29uZmlnIGFzIFQ7XG59XG4iLCJpbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSwgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLCBFdmljdGlvbkNvbnRleHQsIEV2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi9FdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCB7IERFRkFVTFRfTEZVX0NPTkZJRywgTEZVQ29uZmlnIH0gZnJvbSAnLi4vRXZpY3Rpb25TdHJhdGVneUNvbmZpZyc7XG5pbXBvcnQgeyBjcmVhdGVWYWxpZGF0ZWRDb25maWcgfSBmcm9tICcuLi9FdmljdGlvblN0cmF0ZWd5VmFsaWRhdGlvbic7XG5cbi8qKlxuICogSGlnaC1xdWFsaXR5IGhhc2ggZnVuY3Rpb24gZm9yIENvdW50LU1pbiBTa2V0Y2ggYmFzZWQgb24gRk5WLTFhXG4gKiBQcm92aWRlcyBleGNlbGxlbnQgYXZhbGFuY2hlIGVmZmVjdCBhbmQgZGlzdHJpYnV0aW9uIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZm52MWFIYXNoKGtleTogc3RyaW5nLCBzZWVkOiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBGTlYtMWEgY29uc3RhbnRzIGZvciAzMi1iaXQgaGFzaFxuICBjb25zdCBGTlZfT0ZGU0VUX0JBU0lTID0gMjE2NjEzNjI2MTtcbiAgY29uc3QgRk5WX1BSSU1FID0gMTY3Nzc2MTk7XG5cbiAgLy8gU3RhcnQgd2l0aCBzZWVkLW1vZGlmaWVkIG9mZnNldCBiYXNpcyBmb3IgZGlmZmVyZW50IGhhc2ggZnVuY3Rpb25zXG4gIGxldCBoYXNoID0gKEZOVl9PRkZTRVRfQkFTSVMgXiBzZWVkKSA+Pj4gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFhPUiB3aXRoIGJ5dGUgdmFsdWVcbiAgICBoYXNoIF49IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIE11bHRpcGx5IGJ5IEZOViBwcmltZVxuICAgIGhhc2ggPSAoaGFzaCAqIEZOVl9QUklNRSkgPj4+IDA7XG4gIH1cblxuICAvLyBBZGRpdGlvbmFsIG1peGluZyBmb3IgYmV0dGVyIGF2YWxhbmNoZVxuICBoYXNoIF49IGhhc2ggPj4+IDE2O1xuICBoYXNoID0gKGhhc2ggKiAweDg1ZWJjYTZiKSA+Pj4gMDtcbiAgaGFzaCBePSBoYXNoID4+PiAxMztcbiAgaGFzaCA9IChoYXNoICogMHhjMmIyYWUzNSkgPj4+IDA7XG4gIGhhc2ggXj0gaGFzaCA+Pj4gMTY7XG5cbiAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5cbi8qKlxuICogQ291bnQtTWluIFNrZXRjaCBmb3IgcHJvYmFiaWxpc3RpYyBmcmVxdWVuY3kgY291bnRpbmdcbiAqL1xuY2xhc3MgQ291bnRNaW5Ta2V0Y2gge1xuICBwcml2YXRlIHJlYWRvbmx5IHNrZXRjaGVzOiBudW1iZXJbXVtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHdpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVwdGg6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBzZWVkczogbnVtYmVyW107XG5cbiAgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciA9IDEwMjQsIGRlcHRoOiBudW1iZXIgPSA0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLnNrZXRjaGVzID0gQXJyYXkoZGVwdGgpLmZpbGwobnVsbCkubWFwKCgpID0+IG5ldyBBcnJheSh3aWR0aCkuZmlsbCgwKSk7XG4gICAgdGhpcy5zZWVkcyA9IEFycmF5KGRlcHRoKS5maWxsKG51bGwpLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiAyIGZvciBvcHRpbWl6ZWQgYml0IG1hc2tpbmdcbiAgICovXG4gIHByaXZhdGUgaXNQb3dlck9mVHdvKG46IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuID4gMCAmJiAobiAmIChuIC0gMSkpID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgZnJlcXVlbmN5IGNvdW50IGZvciBhIGtleVxuICAgKi9cbiAgaW5jcmVtZW50KGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlcHRoOyBpKyspIHtcbiAgICAgIC8vIFVzZSBiaXQgbWFza2luZyBmb3IgYmV0dGVyIGRpc3RyaWJ1dGlvbiB3aGVuIHdpZHRoIGlzIHBvd2VyIG9mIDJcbiAgICAgIC8vIEZvciBub24tcG93ZXIgb2YgMiwgZmFsbCBiYWNrIHRvIG1vZHVsbyBidXQgd2l0aCBpbXByb3ZlZCBoYXNoXG4gICAgICBjb25zdCBoYXNoID0gZm52MWFIYXNoKGtleSwgdGhpcy5zZWVkc1tpXSk7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaXNQb3dlck9mVHdvKHRoaXMud2lkdGgpXG4gICAgICAgID8gaGFzaCAmICh0aGlzLndpZHRoIC0gMSlcbiAgICAgICAgOiBoYXNoICUgdGhpcy53aWR0aDtcbiAgICAgIHRoaXMuc2tldGNoZXNbaV1baW5kZXhdKys7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlIHRoZSBmcmVxdWVuY3kgY291bnQgZm9yIGEga2V5XG4gICAqL1xuICBlc3RpbWF0ZShrZXk6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IG1pbkNvdW50ID0gSW5maW5pdHk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlcHRoOyBpKyspIHtcbiAgICAgIC8vIFVzZSBzYW1lIGltcHJvdmVkIGluZGV4aW5nIGFzIGluIGluY3JlbWVudCBtZXRob2RcbiAgICAgIGNvbnN0IGhhc2ggPSBmbnYxYUhhc2goa2V5LCB0aGlzLnNlZWRzW2ldKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pc1Bvd2VyT2ZUd28odGhpcy53aWR0aClcbiAgICAgICAgPyBoYXNoICYgKHRoaXMud2lkdGggLSAxKVxuICAgICAgICA6IGhhc2ggJSB0aGlzLndpZHRoO1xuICAgICAgbWluQ291bnQgPSBNYXRoLm1pbihtaW5Db3VudCwgdGhpcy5za2V0Y2hlc1tpXVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gbWluQ291bnQgPT09IEluZmluaXR5ID8gMCA6IG1pbkNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGRlY2F5IHRvIGFsbCBmcmVxdWVuY2llc1xuICAgKi9cbiAgZGVjYXkoZmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLndpZHRoOyBqKyspIHtcbiAgICAgICAgdGhpcy5za2V0Y2hlc1tpXVtqXSA9IE1hdGguZmxvb3IodGhpcy5za2V0Y2hlc1tpXVtqXSAqICgxIC0gZmFjdG9yKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBmcmVxdWVuY2llcyB0byB6ZXJvXG4gICAqL1xuICByZXNldCgpOiB2b2lkIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLndpZHRoOyBqKyspIHtcbiAgICAgICAgdGhpcy5za2V0Y2hlc1tpXVtqXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTEZVIChMZWFzdCBGcmVxdWVudGx5IFVzZWQpIGV2aWN0aW9uIHN0cmF0ZWd5IHdpdGggZnJlcXVlbmN5IHNrZXRjaGluZyBhbmQgZGVjYXlcbiAqIFVzZXMgcHJvYmFiaWxpc3RpYyBjb3VudGluZyBhbmQgdGltZS1iYXNlZCBmcmVxdWVuY3kgZGVjYXkgZm9yIG1vcmUgYWNjdXJhdGUgZnJlcXVlbmN5IGVzdGltYXRpb25cbiAqIFdoZW4gY29uZmlndXJlZCB3aXRoIGRlZmF1bHQgc2V0dGluZ3MsIGJlaGF2ZXMgbGlrZSB0cmFkaXRpb25hbCBMRlUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKi9cbmV4cG9ydCBjbGFzcyBMRlVFdmljdGlvblN0cmF0ZWd5IGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnbGZ1JztcbiAgfVxuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogTEZVQ29uZmlnO1xuICBwcml2YXRlIHJlYWRvbmx5IHNrZXRjaDogQ291bnRNaW5Ta2V0Y2ggfCBudWxsO1xuICBwcml2YXRlIGxhc3REZWNheVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8TEZVQ29uZmlnPiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvLyBEZWZhdWx0IHRvIGJhY2t3YXJkcy1jb21wYXRpYmxlIGJlaGF2aW9yIGlmIG5vIGNvbmZpZyBwcm92aWRlZFxuICAgIGNvbnN0IGRlZmF1bHRCYWNrd2FyZHNDb21wYXRpYmxlID0ge1xuICAgICAgdXNlUHJvYmFiaWxpc3RpY0NvdW50aW5nOiBmYWxzZSxcbiAgICAgIGRlY2F5RmFjdG9yOiAwLFxuICAgICAgZGVjYXlJbnRlcnZhbDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSB7IC4uLkRFRkFVTFRfTEZVX0NPTkZJRywgLi4uZGVmYXVsdEJhY2t3YXJkc0NvbXBhdGlibGUgfTtcbiAgICB0aGlzLmNvbmZpZyA9IGNyZWF0ZVZhbGlkYXRlZENvbmZpZyhiYXNlQ29uZmlnLCBjb25maWcpO1xuICAgIHRoaXMuc2tldGNoID0gdGhpcy5jb25maWcudXNlUHJvYmFiaWxpc3RpY0NvdW50aW5nXG4gICAgICA/IG5ldyBDb3VudE1pblNrZXRjaCh0aGlzLmNvbmZpZy5za2V0Y2hXaWR0aCwgdGhpcy5jb25maWcuc2tldGNoRGVwdGgpXG4gICAgICA6IG51bGw7XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIGFzeW5jIHNlbGVjdEZvckV2aWN0aW9uKFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBjb250ZXh0OiBFdmljdGlvbkNvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSByZXR1cm4gW107XG5cbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgaWYgKGV2aWN0aW9uQ291bnQgPD0gMCkgcmV0dXJuIFtdO1xuXG4gICAgLy8gQXBwbHkgcGVyaW9kaWMgZGVjYXkgaWYgbmVlZGVkXG4gICAgdGhpcy5hcHBseVBlcmlvZGljRGVjYXkoKTtcblxuICAgIC8vIFNvcnQgaXRlbXMgYnkgZnJlcXVlbmN5IChsb3dlc3QgZmlyc3QpLCB0aGVuIGJ5IGFnZSAob2xkZXN0IGZpcnN0KVxuICAgIGNvbnN0IHNvcnRlZEVudHJpZXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgZnJlcUEgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShhWzBdLCBhWzFdKTtcbiAgICAgIGNvbnN0IGZyZXFCID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3koYlswXSwgYlsxXSk7XG5cbiAgICAgIGlmIChmcmVxQSAhPT0gZnJlcUIpIHtcbiAgICAgICAgcmV0dXJuIGZyZXFBIC0gZnJlcUI7IC8vIExvd2VyIGZyZXF1ZW5jeSBmaXJzdFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYVsxXS5sYXN0QWNjZXNzZWRBdCAtIGJbMV0ubGFzdEFjY2Vzc2VkQXQ7IC8vIE9sZGVyIGZpcnN0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc29ydGVkRW50cmllcy5zbGljZSgwLCBldmljdGlvbkNvdW50KS5tYXAoKFtrZXldKSA9PiBrZXkpO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtQWNjZXNzZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBub3c7XG4gICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcblxuICAgIC8vIFVwZGF0ZSBmcmVxdWVuY3kgdHJhY2tpbmdcbiAgICBpZiAodGhpcy5za2V0Y2gpIHtcbiAgICAgIHRoaXMuc2tldGNoLmluY3JlbWVudChrZXkpO1xuICAgICAgbWV0YWRhdGEucmF3RnJlcXVlbmN5ID0gdGhpcy5za2V0Y2guZXN0aW1hdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0YWRhdGEucmF3RnJlcXVlbmN5ID0gbWV0YWRhdGEuYWNjZXNzQ291bnQ7IC8vIFVzZSBhY2Nlc3MgY291bnQgaW4gc2ltcGxlIG1vZGVcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgY2FsY3VsYXRlIGZyZXF1ZW5jeSBzY29yZSBmb3IgY29uc2lzdGVuY3lcbiAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IHRoaXMuY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGEsIG5vdyk7XG4gICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcblxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BZGRlZChrZXk6IHN0cmluZywgZXN0aW1hdGVkU2l6ZTogbnVtYmVyLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemUsXG4gICAgICByYXdGcmVxdWVuY3k6IDFcbiAgICB9O1xuXG4gICAgLy8gQWx3YXlzIGluaXRpYWxpemUgZnJlcXVlbmN5U2NvcmUgYW5kIGxhc3RGcmVxdWVuY3lVcGRhdGUgZm9yIGNvbnNpc3RlbmN5XG4gICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSAxO1xuICAgIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPSBub3c7XG5cbiAgICAvLyBJbml0aWFsaXplIGluIHNrZXRjaFxuICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgdGhpcy5za2V0Y2guaW5jcmVtZW50KGtleSk7XG4gICAgfVxuXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbVJlbW92ZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIE5vdGU6IEZvciBDb3VudC1NaW4gU2tldGNoLCB3ZSBkb24ndCByZW1vdmUgZW50cmllcyBhcyBpdCdzIGEgcHJvYmFiaWxpc3RpYyBzdHJ1Y3R1cmVcbiAgICAvLyBUaGUgZGVjYXkgbWVjaGFuaXNtIHdpbGwgbmF0dXJhbGx5IHJlZHVjZSB0aGUgaW1wYWN0IG9mIHJlbW92ZWQgaXRlbXMgb3ZlciB0aW1lXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWZmZWN0aXZlIGZyZXF1ZW5jeSBmb3IgYW4gaXRlbSwgYXBwbHlpbmcgcmVhbC10aW1lIGRlY2F5IGlmIG5lZWRlZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRFZmZlY3RpdmVGcmVxdWVuY3koX2tleTogc3RyaW5nLCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBudW1iZXIge1xuICAgIC8vIElmIGRlY2F5IGlzIGRpc2FibGVkLCB1c2Ugc2ltcGxlIGZyZXF1ZW5jeSBjb3VudGluZ1xuICAgIGlmICgodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSByZWNlbnQgZnJlcXVlbmN5IHNjb3JlLCB1c2UgaXQgd2l0aCBtaW5pbWFsIGRlY2F5XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBub3cgLSBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlO1xuICAgICAgY29uc3QgZGVjYXlBbW91bnQgPSAodGltZVNpbmNlVXBkYXRlIC8gKHRoaXMuY29uZmlnLmRlY2F5SW50ZXJ2YWwgPz8gNjAwMDApKSAqICh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwLjEpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuY29uZmlnLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA/PyAxLCBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSAqICgxIC0gZGVjYXlBbW91bnQpKTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byByYXcgZnJlcXVlbmN5IG9yIGFjY2VzcyBjb3VudFxuICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGZyZXF1ZW5jeSBzY29yZSB3aXRoIGRlY2F5IGFwcGxpZWRcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhLCBjdXJyZW50VGltZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCByYXdGcmVxID0gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuXG4gICAgLy8gSWYgZGVjYXkgaXMgZGlzYWJsZWQsIGp1c3QgcmV0dXJuIHJhdyBmcmVxdWVuY3lcbiAgICBpZiAoKHRoaXMuY29uZmlnLmRlY2F5RmFjdG9yID8/IDApID09PSAwKSB7XG4gICAgICByZXR1cm4gcmF3RnJlcTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmF3RnJlcTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBjdXJyZW50VGltZSAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgY29uc3QgZGVjYXlBbW91bnQgPSAodGltZVNpbmNlVXBkYXRlIC8gKHRoaXMuY29uZmlnLmRlY2F5SW50ZXJ2YWwgPz8gNjAwMDApKSAqICh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwLjEpO1xuICAgIGNvbnN0IHByZXZpb3VzU2NvcmUgPSBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSB8fCByYXdGcmVxO1xuXG4gICAgLy8gQXBwbHkgZGVjYXkgdG8gcHJldmlvdXMgc2NvcmUgYW5kIGFkZCBuZXcgZnJlcXVlbmN5IGNvbnRyaWJ1dGlvblxuICAgIGNvbnN0IGRlY2F5ZWRTY29yZSA9IHByZXZpb3VzU2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KTtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5jb25maWcubWluRnJlcXVlbmN5VGhyZXNob2xkID8/IDEsIGRlY2F5ZWRTY29yZSArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHBlcmlvZGljIGRlY2F5IHRvIHRoZSBmcmVxdWVuY3kgc2tldGNoIGFuZCBtZXRhZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseVBlcmlvZGljRGVjYXkoKTogdm9pZCB7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwKSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lU2luY2VEZWNheSA9IG5vdyAtIHRoaXMubGFzdERlY2F5VGltZTtcblxuICAgIGlmICh0aW1lU2luY2VEZWNheSA+PSAodGhpcy5jb25maWcuZGVjYXlJbnRlcnZhbCA/PyA2MDAwMCkpIHtcbiAgICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgICB0aGlzLnNrZXRjaC5kZWNheSh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwLjEpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gbm93O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBzdHJhdGVneVxuICAgKi9cbiAgZ2V0Q29uZmlnKCk6IExGVUNvbmZpZyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBmcmVxdWVuY3kgdHJhY2tpbmcgKHVzZWZ1bCBmb3IgdGVzdGluZyBvciBjYWNoZSBjbGVhcmluZylcbiAgICovXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgdGhpcy5za2V0Y2gucmVzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2FjaGVJdGVtTWV0YWRhdGEsXG4gIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgRXZpY3Rpb25Db250ZXh0LFxuICBFdmljdGlvblN0cmF0ZWd5XG59IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3knO1xuXG4vKipcbiAqIEZJRk8gKEZpcnN0LUluLCBGaXJzdC1PdXQpIGV2aWN0aW9uIHN0cmF0ZWd5XG4gKiBSZW1vdmVzIHRoZSBvbGRlc3QgYWRkZWQgaXRlbSByZWdhcmRsZXNzIG9mIHVzYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBGSUZPRXZpY3Rpb25TdHJhdGVneSBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBhc3luYyBzZWxlY3RGb3JFdmljdGlvbihcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgY29udGV4dDogRXZpY3Rpb25Db250ZXh0XG4gICk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBjb25zdCBrZXlzVG9FdmljdDogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFNvcnQgYnkgYWRkZWRBdCBhc2NlbmRpbmcgKG9sZGVzdCBmaXJzdClcbiAgICBjb25zdCBzb3J0ZWRFbnRyaWVzID0gQXJyYXkuZnJvbShhbGxNZXRhZGF0YS5lbnRyaWVzKCkpXG4gICAgICAuc29ydCgoWywgYV0sIFssIGJdKSA9PiBhLmFkZGVkQXQgLSBiLmFkZGVkQXQpO1xuXG4gICAgLy8gVGFrZSB0aGUgb2xkZXN0IGl0ZW1zIHVwIHRvIGV2aWN0aW9uQ291bnRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGV2aWN0aW9uQ291bnQsIHNvcnRlZEVudHJpZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBrZXlzVG9FdmljdC5wdXNoKHNvcnRlZEVudHJpZXNbaV1bMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFjY2Vzc2VkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFkZGVkKGtleTogc3RyaW5nLCBlc3RpbWF0ZWRTaXplOiBudW1iZXIsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZVxuICAgIH07XG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbVJlbW92ZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuXG4gIGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZmlmbyc7XG4gIH1cbn1cbiIsImltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhLCBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsIEV2aWN0aW9uQ29udGV4dCwgRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3knO1xuXG4vKipcbiAqIE1SVSAoTW9zdCBSZWNlbnRseSBVc2VkKSBldmljdGlvbiBzdHJhdGVneVxuICogUmVtb3ZlcyB0aGUgbW9zdCByZWNlbnRseSBhY2Nlc3NlZCBpdGVtXG4gKi9cbmV4cG9ydCBjbGFzcyBNUlVFdmljdGlvblN0cmF0ZWd5IGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnTVJVJztcbiAgfVxuICBhc3luYyBzZWxlY3RGb3JFdmljdGlvbihcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgY29udGV4dDogRXZpY3Rpb25Db250ZXh0XG4gICk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gICAgaWYgKCF0aGlzLmlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGlmIChldmljdGlvbkNvdW50IDw9IDApIHJldHVybiBbXTtcblxuICAgIC8vIFNvcnQgaXRlbXMgYnkgYWNjZXNzIHRpbWUgKG5ld2VzdCBmaXJzdClcbiAgICBjb25zdCBzb3J0ZWRFbnRyaWVzID0gQXJyYXkuZnJvbShhbGxNZXRhZGF0YS5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBiWzFdLmxhc3RBY2Nlc3NlZEF0IC0gYVsxXS5sYXN0QWNjZXNzZWRBdDsgLy8gTmV3ZXIgZmlyc3RcbiAgICB9KTtcblxuICAgIHJldHVybiBzb3J0ZWRFbnRyaWVzLnNsaWNlKDAsIGV2aWN0aW9uQ291bnQpLm1hcCgoW2tleV0pID0+IGtleSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BY2Nlc3NlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuO1xuXG4gICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBEYXRlLm5vdygpO1xuICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG5cbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtQWRkZWQoa2V5OiBzdHJpbmcsIGVzdGltYXRlZFNpemU6IG51bWJlciwgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEgPSB7XG4gICAgICBrZXksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplXG4gICAgfTtcblxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1SZW1vdmVkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENhY2hlSXRlbU1ldGFkYXRhLFxuICBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gIEV2aWN0aW9uQ29udGV4dCxcbiAgRXZpY3Rpb25TdHJhdGVneVxufSBmcm9tICcuLi9FdmljdGlvblN0cmF0ZWd5JztcblxuLyoqXG4gKiBSYW5kb20gZXZpY3Rpb24gc3RyYXRlZ3lcbiAqIFJlbW92ZXMgYSByYW5kb20gaXRlbSBmcm9tIHRoZSBjYWNoZVxuICovXG5leHBvcnQgY2xhc3MgUmFuZG9tRXZpY3Rpb25TdHJhdGVneSBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBhc3luYyBzZWxlY3RGb3JFdmljdGlvbihcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgY29udGV4dDogRXZpY3Rpb25Db250ZXh0XG4gICk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShhbGxNZXRhZGF0YS5rZXlzKCkpO1xuICAgIGNvbnN0IGtleXNUb0V2aWN0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gUmFuZG9tbHkgc2VsZWN0IGl0ZW1zIHRvIGV2aWN0XG4gICAgY29uc3QgYXZhaWxhYmxlS2V5cyA9IFsuLi5rZXlzXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGV2aWN0aW9uQ291bnQsIGF2YWlsYWJsZUtleXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGF2YWlsYWJsZUtleXMubGVuZ3RoKTtcbiAgICAgIGtleXNUb0V2aWN0LnB1c2goYXZhaWxhYmxlS2V5cy5zcGxpY2UocmFuZG9tSW5kZXgsIDEpWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5c1RvRXZpY3Q7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BY2Nlc3NlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BZGRlZChrZXk6IHN0cmluZywgZXN0aW1hdGVkU2l6ZTogbnVtYmVyLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemVcbiAgICB9O1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1SZW1vdmVkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cblxuICBnZXRTdHJhdGVneU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3JhbmRvbSc7XG4gIH1cbn1cbiIsImltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhLCBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsIEV2aWN0aW9uQ29udGV4dCwgRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgQVJDQ29uZmlnLCBERUZBVUxUX0FSQ19DT05GSUcgfSBmcm9tICcuLi9FdmljdGlvblN0cmF0ZWd5Q29uZmlnJztcbmltcG9ydCB7IGNyZWF0ZVZhbGlkYXRlZENvbmZpZyB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3lWYWxpZGF0aW9uJztcblxuLyoqXG4gKiBBUkMgKEFkYXB0aXZlIFJlcGxhY2VtZW50IENhY2hlKSBldmljdGlvbiBzdHJhdGVneSB3aXRoIGVuaGFuY2VkIGZyZXF1ZW5jeSB0cmFja2luZ1xuICogQmFsYW5jZXMgYmV0d2VlbiByZWNlbmN5IChMUlUpIGFuZCBmcmVxdWVuY3kgKExGVSkgZHluYW1pY2FsbHkgd2l0aCBzb3BoaXN0aWNhdGVkIGZyZXF1ZW5jeSBhbmFseXNpc1xuICovXG5leHBvcnQgY2xhc3MgQVJDRXZpY3Rpb25TdHJhdGVneSBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBnZXRTdHJhdGVneU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0FSQyc7XG4gIH1cbiAgcHJpdmF0ZSByZWNlbnRHaG9zdHMgPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gVDEgZ2hvc3QgZW50cmllc1xuICBwcml2YXRlIGZyZXF1ZW50R2hvc3RzID0gbmV3IFNldDxzdHJpbmc+KCk7IC8vIFQyIGdob3N0IGVudHJpZXNcbiAgcHJpdmF0ZSB0YXJnZXRSZWNlbnRTaXplID0gMDsgLy8gVGFyZ2V0IHNpemUgZm9yIFQxIChyZWNlbnQgZW50cmllcylcbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IEFSQ0NvbmZpZztcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhHaG9zdFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSBsYXN0RGVjYXlUaW1lOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IobWF4Q2FjaGVTaXplOiBudW1iZXIgPSAxMDAwLCBjb25maWc6IFBhcnRpYWw8QVJDQ29uZmlnPiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0geyAuLi5ERUZBVUxUX0FSQ19DT05GSUcsIG1heENhY2hlU2l6ZSB9O1xuICAgIHRoaXMuY29uZmlnID0gY3JlYXRlVmFsaWRhdGVkQ29uZmlnKGJhc2VDb25maWcsIGNvbmZpZyk7XG4gICAgdGhpcy5tYXhHaG9zdFNpemUgPSB0aGlzLmNvbmZpZy5tYXhDYWNoZVNpemUhO1xuICAgIHRoaXMubGFzdERlY2F5VGltZSA9IERhdGUubm93KCk7XG4gIH1cblxuICBhc3luYyBzZWxlY3RGb3JFdmljdGlvbihcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgY29udGV4dDogRXZpY3Rpb25Db250ZXh0XG4gICk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gICAgaWYgKCF0aGlzLmlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGlmIChldmljdGlvbkNvdW50IDw9IDApIHJldHVybiBbXTtcblxuICAgIC8vIEFwcGx5IHBlcmlvZGljIGRlY2F5IGlmIGVuYWJsZWRcbiAgICB0aGlzLmFwcGx5UGVyaW9kaWNEZWNheShhbGxNZXRhZGF0YSk7XG5cbiAgICAvLyBTcGxpdCBpdGVtcyBpbnRvIHJlY2VudCAoVDEpIGFuZCBmcmVxdWVudCAoVDIpIGJhc2VkIG9uIGVuaGFuY2VkIGZyZXF1ZW5jeSBhbmFseXNpc1xuICAgIGNvbnN0IHJlY2VudEl0ZW1zID0gbmV3IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPigpO1xuICAgIGNvbnN0IGZyZXF1ZW50SXRlbXMgPSBuZXcgTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+KCk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIG1ldGFkYXRhXSBvZiBhbGxNZXRhZGF0YSkge1xuICAgICAgaWYgKHRoaXMuaXNGcmVxdWVudEl0ZW0obWV0YWRhdGEpKSB7XG4gICAgICAgIGZyZXF1ZW50SXRlbXMuc2V0KGtleSwgbWV0YWRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjZW50SXRlbXMuc2V0KGtleSwgbWV0YWRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGtleXNUb0V2aWN0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHRvdGFsSXRlbXMgPSByZWNlbnRJdGVtcy5zaXplICsgZnJlcXVlbnRJdGVtcy5zaXplO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1pbihldmljdGlvbkNvdW50LCB0b3RhbEl0ZW1zKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICBsZXQga2V5VG9FdmljdDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICBsZXQgc291cmNlTGlzdDogTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgIC8vIERlY2lkZSB3aGljaCBsaXN0IHRvIGV2aWN0IGZyb20gYmFzZWQgb24gdGFyZ2V0IHNpemVzIGFuZCBhZGFwdGl2ZSBhbGdvcml0aG1cbiAgICAgIGlmIChyZWNlbnRJdGVtcy5zaXplID4gdGhpcy50YXJnZXRSZWNlbnRTaXplICYmIHJlY2VudEl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIEV2aWN0IGZyb20gcmVjZW50IGxpc3QgKFQxKVxuICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5jb25maWcudXNlRnJlcXVlbmN5V2VpZ2h0ZWRTZWxlY3Rpb25cbiAgICAgICAgICA/IHRoaXMuc2VsZWN0RnJlcXVlbmN5V2VpZ2h0ZWRGcm9tSXRlbXMocmVjZW50SXRlbXMsICdyZWNlbnQnKVxuICAgICAgICAgIDogdGhpcy5zZWxlY3RMUlVGcm9tSXRlbXMocmVjZW50SXRlbXMpO1xuICAgICAgICBzb3VyY2VMaXN0ID0gcmVjZW50SXRlbXM7XG4gICAgICB9IGVsc2UgaWYgKGZyZXF1ZW50SXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gRXZpY3QgZnJvbSBmcmVxdWVudCBsaXN0IChUMilcbiAgICAgICAga2V5VG9FdmljdCA9IHRoaXMuY29uZmlnLnVzZUZyZXF1ZW5jeVdlaWdodGVkU2VsZWN0aW9uXG4gICAgICAgICAgPyB0aGlzLnNlbGVjdEZyZXF1ZW5jeVdlaWdodGVkRnJvbUl0ZW1zKGZyZXF1ZW50SXRlbXMsICdmcmVxdWVudCcpXG4gICAgICAgICAgOiB0aGlzLnNlbGVjdExSVUZyb21JdGVtcyhmcmVxdWVudEl0ZW1zKTtcbiAgICAgICAgc291cmNlTGlzdCA9IGZyZXF1ZW50SXRlbXM7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VudEl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrOiBldmljdCBmcm9tIHJlY2VudCBpZiBpdCdzIHRoZSBvbmx5IGxpc3Qgd2l0aCBpdGVtc1xuICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5jb25maWcudXNlRnJlcXVlbmN5V2VpZ2h0ZWRTZWxlY3Rpb25cbiAgICAgICAgICA/IHRoaXMuc2VsZWN0RnJlcXVlbmN5V2VpZ2h0ZWRGcm9tSXRlbXMocmVjZW50SXRlbXMsICdyZWNlbnQnKVxuICAgICAgICAgIDogdGhpcy5zZWxlY3RMUlVGcm9tSXRlbXMocmVjZW50SXRlbXMpO1xuICAgICAgICBzb3VyY2VMaXN0ID0gcmVjZW50SXRlbXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlUb0V2aWN0ICYmIHNvdXJjZUxpc3QpIHtcbiAgICAgICAga2V5c1RvRXZpY3QucHVzaChrZXlUb0V2aWN0KTtcbiAgICAgICAgc291cmNlTGlzdC5kZWxldGUoa2V5VG9FdmljdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyB2YWxpZCBrZXkgZm91bmQgb3Igbm8gbW9yZSBpdGVtcyBhdmFpbGFibGVcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhZmV0eSBjaGVjazogaWYgd2UndmUgZXZpY3RlZCBhbGwgaXRlbXMsIHN0b3BcbiAgICAgIGlmIChyZWNlbnRJdGVtcy5zaXplID09PSAwICYmIGZyZXF1ZW50SXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5c1RvRXZpY3Q7XG4gIH1cblxuICBwcml2YXRlIHNlbGVjdExSVUZyb21JdGVtcyhpdGVtczogTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKGl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBvbGRlc3RLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGxldCBvbGRlc3RUaW1lID0gSW5maW5pdHk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbWV0YWRhdGFdIG9mIGl0ZW1zKSB7XG4gICAgICAvLyBWYWxpZGF0ZSBtZXRhZGF0YSB0byBwcmV2ZW50IGNvcnJ1cHRpb25cbiAgICAgIGlmICghbWV0YWRhdGEgfHwgdHlwZW9mIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ICE9PSAnbnVtYmVyJyB8fCBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA+IG5vdykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0IDwgb2xkZXN0VGltZSkge1xuICAgICAgICBvbGRlc3RUaW1lID0gbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQ7XG4gICAgICAgIG9sZGVzdEtleSA9IGtleTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyB2YWxpZCBrZXkgZm91bmQgdGhyb3VnaCBMUlUgbG9naWMsIGZhbGwgYmFjayB0byBmaXJzdCBhdmFpbGFibGUga2V5XG4gICAgaWYgKG9sZGVzdEtleSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9sZGVzdEtleTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBmaXJzdCBhdmFpbGFibGUga2V5IGlmIGl0ZW1zIGV4aXN0XG4gICAgaWYgKGl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdEtleSA9IGl0ZW1zLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gZmlyc3RLZXkgPz8gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFjY2Vzc2VkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhKSByZXR1cm47XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gQ3JlYXRlIGEgY29weSBvZiBtZXRhZGF0YSB0byBhdm9pZCBkaXJlY3QgbXV0YXRpb24gb2Ygc2hhcmVkIHN0YXRlXG4gICAgY29uc3QgdXBkYXRlZE1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiBtZXRhZGF0YS5hY2Nlc3NDb3VudCArIDFcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGZyZXF1ZW5jeSB0cmFja2luZ1xuICAgIHVwZGF0ZWRNZXRhZGF0YS5yYXdGcmVxdWVuY3kgPSB1cGRhdGVkTWV0YWRhdGEuYWNjZXNzQ291bnQ7XG5cbiAgICAvLyBVcGRhdGUgZnJlcXVlbmN5IHNjb3JlIHdpdGggZGVjYXkgaWYgZW5hYmxlZFxuICAgIGlmICh0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSAmJiAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICB1cGRhdGVkTWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUZyZXF1ZW5jeVNjb3JlKHVwZGF0ZWRNZXRhZGF0YSwgbm93KTtcbiAgICAgIHVwZGF0ZWRNZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgIH1cblxuICAgIC8vIEFkanVzdCB0YXJnZXQgc2l6ZSBiYXNlZCBvbiBnaG9zdCBsaXN0IGhpdHMgd2l0aCBhZGFwdGl2ZSBsZWFybmluZ1xuICAgIGNvbnN0IGxlYXJuaW5nUmF0ZSA9IHRoaXMuY29uZmlnLmFkYXB0aXZlTGVhcm5pbmdSYXRlID8/IDEuMDtcbiAgICBsZXQgdGFyZ2V0QWRqdXN0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChsZWFybmluZ1JhdGUgPiAwKSB7XG4gICAgICBpZiAodGhpcy5yZWNlbnRHaG9zdHMuaGFzKGtleSkpIHtcbiAgICAgICAgLy8gSGl0IGluIHJlY2VudCBnaG9zdCBsaXN0IC0gaW5jcmVhc2UgdGFyZ2V0IGZvciByZWNlbnQgaXRlbXNcbiAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChsZWFybmluZ1JhdGUpKTtcbiAgICAgICAgdGhpcy50YXJnZXRSZWNlbnRTaXplID0gTWF0aC5taW4odGhpcy50YXJnZXRSZWNlbnRTaXplICsgYWRqdXN0bWVudCwgdGhpcy5tYXhHaG9zdFNpemUpO1xuICAgICAgICB0aGlzLnJlY2VudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICAgICAgdGFyZ2V0QWRqdXN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZyZXF1ZW50R2hvc3RzLmhhcyhrZXkpKSB7XG4gICAgICAgIC8vIEhpdCBpbiBmcmVxdWVudCBnaG9zdCBsaXN0IC0gZGVjcmVhc2UgdGFyZ2V0IGZvciByZWNlbnQgaXRlbXNcbiAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChsZWFybmluZ1JhdGUpKTtcbiAgICAgICAgdGhpcy50YXJnZXRSZWNlbnRTaXplID0gTWF0aC5tYXgodGhpcy50YXJnZXRSZWNlbnRTaXplIC0gYWRqdXN0bWVudCwgMCk7XG4gICAgICAgIHRoaXMuZnJlcXVlbnRHaG9zdHMuZGVsZXRlKGtleSk7XG4gICAgICAgIHRhcmdldEFkanVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZlbiB3aXRoIHplcm8gbGVhcm5pbmcgcmF0ZSwgcmVtb3ZlIGZyb20gZ2hvc3QgbGlzdHMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgIGlmICh0aGlzLnJlY2VudEdob3N0cy5oYXMoa2V5KSkge1xuICAgICAgICB0aGlzLnJlY2VudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmVxdWVudEdob3N0cy5oYXMoa2V5KSkge1xuICAgICAgICB0aGlzLmZyZXF1ZW50R2hvc3RzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGdob3N0IGxpc3RzIGlmIHRoZXkgd2VyZSBtb2RpZmllZFxuICAgIGlmICh0YXJnZXRBZGp1c3RlZCkge1xuICAgICAgdGhpcy5jbGVhbnVwR2hvc3RMaXN0cygpO1xuICAgIH1cblxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCB1cGRhdGVkTWV0YWRhdGEpO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtQWRkZWQoa2V5OiBzdHJpbmcsIGVzdGltYXRlZFNpemU6IG51bWJlciwgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEgPSB7XG4gICAgICBrZXksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplLFxuICAgICAgcmF3RnJlcXVlbmN5OiAxXG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemUgZnJlcXVlbmN5IHNjb3JlIGZvciBkZWNheSB0cmFja2luZ1xuICAgIGlmICh0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSAmJiAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IDE7XG4gICAgICBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgIH1cblxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1SZW1vdmVkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcblxuICAgIC8vIERldGVybWluZSB3aGljaCBnaG9zdCBsaXN0IHRvIGFkZCB0byBiYXNlZCBvbiBpdGVtIGNoYXJhY3RlcmlzdGljc1xuICAgIGlmIChtZXRhZGF0YSAmJiB0aGlzLmlzRnJlcXVlbnRJdGVtKG1ldGFkYXRhKSkge1xuICAgICAgdGhpcy5hZGRUb0ZyZXF1ZW50R2hvc3RzKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVG9SZWNlbnRHaG9zdHMoa2V5KTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBtZXRhZGF0YSBmaXJzdCB0byBhdm9pZCBhY2Nlc3Npbmcgc3RhbGUgZGF0YVxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcblxuICAgIC8vIEVuc3VyZSBib3RoIGdob3N0IGxpc3RzIHN0YXkgd2l0aGluIGJvdW5kcyBhZnRlciBtb2RpZmljYXRpb25zXG4gICAgdGhpcy5jbGVhbnVwR2hvc3RMaXN0cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBrZXkgdG8gcmVjZW50IGdob3N0IGxpc3Qgd2l0aCBwcm9wZXIgc2l6ZSBtYW5hZ2VtZW50XG4gICAqL1xuICBwcml2YXRlIGFkZFRvUmVjZW50R2hvc3RzKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGZyb20gZnJlcXVlbnQgZ2hvc3RzIGlmIHByZXNlbnQgKGl0ZW0gbW92ZWQgbGlzdHMpXG4gICAgdGhpcy5mcmVxdWVudEdob3N0cy5kZWxldGUoa2V5KTtcblxuICAgIC8vIEFkZCB0byByZWNlbnQgZ2hvc3RzXG4gICAgdGhpcy5yZWNlbnRHaG9zdHMuYWRkKGtleSk7XG5cbiAgICAvLyBNYWludGFpbiBzaXplIGxpbWl0IGJ5IHJlbW92aW5nIG9sZGVzdCBlbnRyaWVzXG4gICAgdGhpcy5lbmZvcmNlR2hvc3RMaXN0U2l6ZUxpbWl0KHRoaXMucmVjZW50R2hvc3RzLCB0aGlzLm1heEdob3N0U2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGtleSB0byBmcmVxdWVudCBnaG9zdCBsaXN0IHdpdGggcHJvcGVyIHNpemUgbWFuYWdlbWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhZGRUb0ZyZXF1ZW50R2hvc3RzKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGZyb20gcmVjZW50IGdob3N0cyBpZiBwcmVzZW50IChpdGVtIG1vdmVkIGxpc3RzKVxuICAgIHRoaXMucmVjZW50R2hvc3RzLmRlbGV0ZShrZXkpO1xuXG4gICAgLy8gQWRkIHRvIGZyZXF1ZW50IGdob3N0c1xuICAgIHRoaXMuZnJlcXVlbnRHaG9zdHMuYWRkKGtleSk7XG5cbiAgICAvLyBNYWludGFpbiBzaXplIGxpbWl0IGJ5IHJlbW92aW5nIG9sZGVzdCBlbnRyaWVzXG4gICAgdGhpcy5lbmZvcmNlR2hvc3RMaXN0U2l6ZUxpbWl0KHRoaXMuZnJlcXVlbnRHaG9zdHMsIHRoaXMubWF4R2hvc3RTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnVwIGdob3N0IGxpc3RzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAqL1xuICBwcml2YXRlIGNsZWFudXBHaG9zdExpc3RzKCk6IHZvaWQge1xuICAgIHRoaXMuZW5mb3JjZUdob3N0TGlzdFNpemVMaW1pdCh0aGlzLnJlY2VudEdob3N0cywgdGhpcy5tYXhHaG9zdFNpemUpO1xuICAgIHRoaXMuZW5mb3JjZUdob3N0TGlzdFNpemVMaW1pdCh0aGlzLmZyZXF1ZW50R2hvc3RzLCB0aGlzLm1heEdob3N0U2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5mb3JjZSBzaXplIGxpbWl0IG9uIGEgZ2hvc3QgbGlzdCBieSByZW1vdmluZyBvbGRlc3QgZW50cmllc1xuICAgKi9cbiAgcHJpdmF0ZSBlbmZvcmNlR2hvc3RMaXN0U2l6ZUxpbWl0KGdob3N0TGlzdDogU2V0PHN0cmluZz4sIG1heFNpemU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChtYXhTaXplIDw9IDApIHtcbiAgICAgIGdob3N0TGlzdC5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBleGNlc3MgZW50cmllcyBmcm9tIHRoZSBiZWdpbm5pbmcgKG9sZGVzdClcbiAgICBjb25zdCBpdGVyYXRvciA9IGdob3N0TGlzdC52YWx1ZXMoKTtcbiAgICB3aGlsZSAoZ2hvc3RMaXN0LnNpemUgPiBtYXhTaXplKSB7XG4gICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICBicmVhazsgLy8gU2FmZXR5IGNoZWNrIC0gbm8gbW9yZSBpdGVtc1xuICAgICAgfVxuICAgICAgZ2hvc3RMaXN0LmRlbGV0ZShuZXh0LnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGFuIGl0ZW0gc2hvdWxkIGJlIGNsYXNzaWZpZWQgYXMgZnJlcXVlbnQgdnMgcmVjZW50XG4gICAqL1xuICBwcml2YXRlIGlzRnJlcXVlbnRJdGVtKG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5jb25maWcudXNlRW5oYW5jZWRGcmVxdWVuY3kpIHtcbiAgICAgIC8vIFRyYWRpdGlvbmFsIEFSQyBiZWhhdmlvclxuICAgICAgcmV0dXJuIG1ldGFkYXRhLmFjY2Vzc0NvdW50ID4gMTtcbiAgICB9XG5cbiAgICAvLyBFbmhhbmNlZCBmcmVxdWVuY3ktYmFzZWQgY2xhc3NpZmljYXRpb25cbiAgICBjb25zdCBmcmVxdWVuY3kgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YSk7XG4gICAgcmV0dXJuIGZyZXF1ZW5jeSA+PSAodGhpcy5jb25maWcuZnJlcXVlbmN5VGhyZXNob2xkID8/IDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBlZmZlY3RpdmUgZnJlcXVlbmN5IGZvciBhbiBpdGVtLCBhcHBseWluZyBkZWNheSBpZiBlbmFibGVkXG4gICAqL1xuICBwcml2YXRlIGdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBudW1iZXIge1xuICAgIGlmICghdGhpcy5jb25maWcudXNlRW5oYW5jZWRGcmVxdWVuY3kgfHwgKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDApID09PSAwKSB7XG4gICAgICByZXR1cm4gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgZnJlcXVlbmN5IHNjb3JlIHdpdGggZGVjYXkgdHJhY2tpbmdcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IG5vdyAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgICBjb25zdCBkZWNheUludGVydmFsID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA/PyA2MDAwMDA7XG5cbiAgICAgIC8vIE9ubHkgYXBwbHkgZGVjYXkgaWYgc2lnbmlmaWNhbnQgdGltZSBoYXMgcGFzc2VkXG4gICAgICBpZiAodGltZVNpbmNlVXBkYXRlID4gZGVjYXlJbnRlcnZhbCAvIDEwKSB7IC8vIEFwcGx5IGRlY2F5IGFmdGVyIDEwJSBvZiBpbnRlcnZhbFxuICAgICAgICBjb25zdCBkZWNheUFtb3VudCA9IE1hdGgubWluKDAuOSwgKHRpbWVTaW5jZVVwZGF0ZSAvIGRlY2F5SW50ZXJ2YWwpICogKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDAuMDUpKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gcmF3IGZyZXF1ZW5jeVxuICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGZyZXF1ZW5jeSBzY29yZSB3aXRoIGRlY2F5IGFwcGxpZWRcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhLCBjdXJyZW50VGltZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCByYXdGcmVxID0gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuXG4gICAgLy8gSWYgbm8gcHJldmlvdXMgZnJlcXVlbmN5IHRyYWNraW5nLCBzdGFydCB3aXRoIHJhdyBmcmVxdWVuY3lcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmF3RnJlcTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBjdXJyZW50VGltZSAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgY29uc3QgZGVjYXlJbnRlcnZhbCA9IHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgPz8gNjAwMDAwO1xuICAgIGNvbnN0IGRlY2F5RmFjdG9yID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMC4wNTtcblxuICAgIC8vIENhbGN1bGF0ZSBkZWNheSBhbW91bnQsIGJ1dCBjYXAgaXQgdG8gcHJldmVudCBvdmVyLWRlY2F5XG4gICAgY29uc3QgZGVjYXlBbW91bnQgPSBNYXRoLm1pbigwLjksICh0aW1lU2luY2VVcGRhdGUgLyBkZWNheUludGVydmFsKSAqIGRlY2F5RmFjdG9yKTtcbiAgICBjb25zdCBwcmV2aW91c1Njb3JlID0gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgfHwgcmF3RnJlcTtcblxuICAgIC8vIEFwcGx5IGRlY2F5IHRvIHByZXZpb3VzIHNjb3JlIGFuZCBhZGQgbmV3IGZyZXF1ZW5jeSBjb250cmlidXRpb25cbiAgICBjb25zdCBkZWNheWVkU2NvcmUgPSBNYXRoLm1heCgxLCBwcmV2aW91c1Njb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgIHJldHVybiBNYXRoLm1heCgxLCBkZWNheWVkU2NvcmUgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgZXZpY3Rpb24gY2FuZGlkYXRlIHVzaW5nIGZyZXF1ZW5jeS13ZWlnaHRlZCBhcHByb2FjaFxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RGcmVxdWVuY3lXZWlnaHRlZEZyb21JdGVtcyhpdGVtczogTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+LCBjb250ZXh0OiAncmVjZW50JyB8ICdmcmVxdWVudCcgfCAnZmFsbGJhY2snKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKGl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBiZXN0S2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgYmVzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbWV0YWRhdGFdIG9mIGl0ZW1zKSB7XG4gICAgICAvLyBWYWxpZGF0ZSBtZXRhZGF0YSB0byBwcmV2ZW50IGNvcnJ1cHRpb25cbiAgICAgIGlmICghbWV0YWRhdGEgfHwgdHlwZW9mIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ICE9PSAnbnVtYmVyJyB8fCBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA+IG5vdykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHdlaWdodGVkIHNjb3JlIGJhc2VkIG9uIGNvbnRleHRcbiAgICAgIGNvbnN0IGZyZXF1ZW5jeSA9IHRoaXMuZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KG1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IHRpbWVGYWN0b3IgPSBNYXRoLm1heCgwLCBub3cgLSBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCk7XG5cbiAgICAgIGxldCBzY29yZTogbnVtYmVyO1xuICAgICAgaWYgKGNvbnRleHQgPT09ICdyZWNlbnQnKSB7XG4gICAgICAgIC8vIEluIHJlY2VudCBsaXN0LCBwcmlvcml0aXplIGJ5IHJlY2VuY3kgbW9yZSBoZWF2aWx5XG4gICAgICAgIHNjb3JlID0gdGltZUZhY3RvciArICgxMDAwIC8gTWF0aC5tYXgoMSwgZnJlcXVlbmN5KSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09ICdmcmVxdWVudCcpIHtcbiAgICAgICAgLy8gSW4gZnJlcXVlbnQgbGlzdCwgYmFsYW5jZSBmcmVxdWVuY3kgYW5kIHJlY2VuY3lcbiAgICAgICAgc2NvcmUgPSAodGltZUZhY3RvciAvIDEwMDApICsgKDEwIC8gTWF0aC5tYXgoMSwgZnJlcXVlbmN5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayAtIHVzZSBiYWxhbmNlZCBhcHByb2FjaFxuICAgICAgICBzY29yZSA9ICh0aW1lRmFjdG9yIC8gMTAwMCkgLyBNYXRoLm1heCgxLCBmcmVxdWVuY3kpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NvcmUgPCBiZXN0U2NvcmUpIHtcbiAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgIGJlc3RLZXkgPSBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gdmFsaWQga2V5IGZvdW5kIHRocm91Z2ggc2NvcmluZywgZmFsbCBiYWNrIHRvIGZpcnN0IGF2YWlsYWJsZSBrZXlcbiAgICBpZiAoYmVzdEtleSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJlc3RLZXk7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gZmlyc3QgYXZhaWxhYmxlIGtleSBpZiBpdGVtcyBleGlzdFxuICAgIGlmIChpdGVtcy5zaXplID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RLZXkgPSBpdGVtcy5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIGZpcnN0S2V5ID8/IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgcGVyaW9kaWMgZGVjYXkgdG8gZnJlcXVlbmN5IHNjb3Jlc1xuICAgKi9cbiAgcHJpdmF0ZSBhcHBseVBlcmlvZGljRGVjYXkoaXRlbXM6IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb25maWcudXNlRW5oYW5jZWRGcmVxdWVuY3kgfHwgKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDApID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVTaW5jZURlY2F5ID0gbm93IC0gdGhpcy5sYXN0RGVjYXlUaW1lO1xuICAgIGNvbnN0IGRlY2F5SW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUludGVydmFsID8/IDYwMDAwMDtcblxuICAgIGlmICh0aW1lU2luY2VEZWNheSA+PSBkZWNheUludGVydmFsICYmIGl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBkZWNheUZhY3RvciA9IHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDAuMDU7XG5cbiAgICAgIC8vIEFwcGx5IGRlY2F5IHRvIGFsbCBpdGVtcyB0aGF0IGhhdmUgZnJlcXVlbmN5IHNjb3Jlc1xuICAgICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiBpdGVtcy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aW1lLWJhc2VkIGRlY2F5IHRvIGhhbmRsZSBjYXNlcyB3aGVyZSBtdWx0aXBsZSBpbnRlcnZhbHMgcGFzc2VkXG4gICAgICAgICAgY29uc3QgaW50ZXJ2YWxzUGFzc2VkID0gdGltZVNpbmNlRGVjYXkgLyBkZWNheUludGVydmFsO1xuICAgICAgICAgIGNvbnN0IHRvdGFsRGVjYXkgPSBNYXRoLm1pbigwLjksIGRlY2F5RmFjdG9yICogaW50ZXJ2YWxzUGFzc2VkKTsgLy8gQ2FwIGRlY2F5IHRvIHByZXZlbnQgb3Zlci1kZWNheVxuICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIHRvdGFsRGVjYXkpO1xuICAgICAgICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gTWF0aC5tYXgoMSwgbmV3U2NvcmUpO1xuICAgICAgICAgIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPSBub3c7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gbm93O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBzdHJhdGVneVxuICAgKi9cbiAgZ2V0Q29uZmlnKCk6IEFSQ0NvbmZpZyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBpbnRlcm5hbCBzdGF0ZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICAgKi9cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5yZWNlbnRHaG9zdHMuY2xlYXIoKTtcbiAgICB0aGlzLmZyZXF1ZW50R2hvc3RzLmNsZWFyKCk7XG4gICAgdGhpcy50YXJnZXRSZWNlbnRTaXplID0gMDtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGFkYXB0aXZlIHN0YXRlIGZvciBtb25pdG9yaW5nL2RlYnVnZ2luZ1xuICAgKi9cbiAgZ2V0QWRhcHRpdmVTdGF0ZSgpOiB7IHRhcmdldFJlY2VudFNpemU6IG51bWJlcjsgcmVjZW50R2hvc3RTaXplOiBudW1iZXI7IGZyZXF1ZW50R2hvc3RTaXplOiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldFJlY2VudFNpemU6IHRoaXMudGFyZ2V0UmVjZW50U2l6ZSxcbiAgICAgIHJlY2VudEdob3N0U2l6ZTogdGhpcy5yZWNlbnRHaG9zdHMuc2l6ZSxcbiAgICAgIGZyZXF1ZW50R2hvc3RTaXplOiB0aGlzLmZyZXF1ZW50R2hvc3RzLnNpemVcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSwgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLCBFdmljdGlvbkNvbnRleHQsIEV2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi9FdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCB7IERFRkFVTFRfVFdPX1FVRVVFX0NPTkZJRywgVHdvUXVldWVDb25maWcgfSBmcm9tICcuLi9FdmljdGlvblN0cmF0ZWd5Q29uZmlnJztcbmltcG9ydCB7IGNyZWF0ZVZhbGlkYXRlZENvbmZpZyB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3lWYWxpZGF0aW9uJztcblxuLyoqXG4gKiAyUSAoVHdvIFF1ZXVlcykgZXZpY3Rpb24gc3RyYXRlZ3kgd2l0aCBlbmhhbmNlZCBmcmVxdWVuY3kgdHJhY2tpbmdcbiAqIE1haW50YWlucyBzZXBhcmF0ZSBxdWV1ZXMgZm9yIHJlY2VudCBhbmQgZnJlcXVlbnRseSBhY2Nlc3NlZCBpdGVtc1xuICogVXNlcyBmcmVxdWVuY3kgYW5hbHlzaXMgZm9yIHByb21vdGlvbiBkZWNpc2lvbnMgYW5kIHdlaWdodGVkIExSVSBpbiBob3QgcXVldWVcbiAqL1xuZXhwb3J0IGNsYXNzIFR3b1F1ZXVlRXZpY3Rpb25TdHJhdGVneSBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBnZXRTdHJhdGVneU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJzJRJztcbiAgfVxuICBwcml2YXRlIHJlY2VudFF1ZXVlOiBzdHJpbmdbXSA9IFtdOyAvLyBBMSBxdWV1ZSBmb3IgcmVjZW50IGl0ZW1zXG4gIHByaXZhdGUgaG90UXVldWU6IHN0cmluZ1tdID0gW107IC8vIEFtIHF1ZXVlIGZvciBob3QgaXRlbXNcbiAgcHJpdmF0ZSBnaG9zdFF1ZXVlID0gbmV3IFNldDxzdHJpbmc+KCk7IC8vIEExb3V0IGdob3N0IHF1ZXVlXG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBUd29RdWV1ZUNvbmZpZztcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhSZWNlbnRTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4R2hvc3RTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgbGFzdERlY2F5VGltZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG1heENhY2hlU2l6ZTogbnVtYmVyID0gMTAwMCwgY29uZmlnOiBQYXJ0aWFsPFR3b1F1ZXVlQ29uZmlnPiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0geyAuLi5ERUZBVUxUX1RXT19RVUVVRV9DT05GSUcsIG1heENhY2hlU2l6ZSB9O1xuICAgIHRoaXMuY29uZmlnID0gY3JlYXRlVmFsaWRhdGVkQ29uZmlnKGJhc2VDb25maWcsIGNvbmZpZyk7XG4gICAgLy8gQWxsb2NhdGUgMjUlIHRvIHJlY2VudCBxdWV1ZSwgNzUlIHRvIGhvdCBxdWV1ZVxuICAgIHRoaXMubWF4UmVjZW50U2l6ZSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGhpcy5jb25maWcubWF4Q2FjaGVTaXplISAqIDAuMjUpKTtcbiAgICB0aGlzLm1heEdob3N0U2l6ZSA9IHRoaXMuY29uZmlnLm1heENhY2hlU2l6ZSE7XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIGFzeW5jIHNlbGVjdEZvckV2aWN0aW9uKFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBjb250ZXh0OiBFdmljdGlvbkNvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSByZXR1cm4gW107XG5cbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgaWYgKGV2aWN0aW9uQ291bnQgPD0gMCkgcmV0dXJuIFtdO1xuXG4gICAgLy8gQXBwbHkgcGVyaW9kaWMgZGVjYXkgaWYgZW5hYmxlZFxuICAgIGF3YWl0IHRoaXMuYXBwbHlQZXJpb2RpY0RlY2F5KGFsbE1ldGFkYXRhKTtcblxuICAgIGNvbnN0IGtleXNUb0V2aWN0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmljdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGxldCBrZXlUb0V2aWN0OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgICAgLy8gRmlyc3QgdHJ5IHRvIGV2aWN0IGZyb20gcmVjZW50IHF1ZXVlIChBMSkgLSBldmljdCBvbGRlc3QgKHRhaWwpIG9mIHJlY2VudCBxdWV1ZVxuICAgICAgZm9yIChsZXQgaiA9IHRoaXMucmVjZW50UXVldWUubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5yZWNlbnRRdWV1ZVtqXTtcbiAgICAgICAgaWYgKGFsbE1ldGFkYXRhLmhhcyhrZXkpICYmICFrZXlzVG9FdmljdC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAga2V5VG9FdmljdCA9IGtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyB2YWxpZCBrZXkgaW4gcmVjZW50IHF1ZXVlLCB0cnkgaG90IHF1ZXVlXG4gICAgICBpZiAoIWtleVRvRXZpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnVzZUZyZXF1ZW5jeVdlaWdodGVkTFJVKSB7XG4gICAgICAgICAga2V5VG9FdmljdCA9IHRoaXMuc2VsZWN0RnJvbUhvdFF1ZXVlRnJlcXVlbmN5V2VpZ2h0ZWQoYWxsTWV0YWRhdGEsIGtleXNUb0V2aWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5zZWxlY3RGcm9tSG90UXVldWVMUlUoYWxsTWV0YWRhdGEsIGtleXNUb0V2aWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5VG9FdmljdCkge1xuICAgICAgICBrZXlzVG9FdmljdC5wdXNoKGtleVRvRXZpY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7IC8vIE5vIG1vcmUgaXRlbXMgdG8gZXZpY3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5c1RvRXZpY3Q7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGV2aWN0aW9uIGNhbmRpZGF0ZSBmcm9tIGhvdCBxdWV1ZSB1c2luZyB0cmFkaXRpb25hbCBMUlVcbiAgICovXG4gIHByaXZhdGUgc2VsZWN0RnJvbUhvdFF1ZXVlTFJVKGl0ZW1zOiBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4sIGV4Y2x1ZGVLZXlzOiBzdHJpbmdbXSA9IFtdKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgbGV0IG9sZGVzdEtleTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IG9sZGVzdFRpbWUgPSBJbmZpbml0eTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuaG90UXVldWUpIHtcbiAgICAgIGlmIChleGNsdWRlS2V5cy5pbmNsdWRlcyhrZXkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gaXRlbXMuZ2V0KGtleSk7XG4gICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPCBvbGRlc3RUaW1lKSB7XG4gICAgICAgIG9sZGVzdFRpbWUgPSBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdDtcbiAgICAgICAgb2xkZXN0S2V5ID0ga2V5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvbGRlc3RLZXkgfHwgKGl0ZW1zLnNpemUgPiAwID8gKGl0ZW1zLmtleXMoKS5uZXh0KCkudmFsdWUgPz8gbnVsbCkgOiBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgZXZpY3Rpb24gY2FuZGlkYXRlIGZyb20gaG90IHF1ZXVlIHVzaW5nIGZyZXF1ZW5jeS13ZWlnaHRlZCBMUlVcbiAgICovXG4gIHByaXZhdGUgc2VsZWN0RnJvbUhvdFF1ZXVlRnJlcXVlbmN5V2VpZ2h0ZWQoaXRlbXM6IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPiwgZXhjbHVkZUtleXM6IHN0cmluZ1tdID0gW10pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBsZXQgYmVzdEtleTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGxvd2VzdFNjb3JlID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmhvdFF1ZXVlKSB7XG4gICAgICBpZiAoZXhjbHVkZUtleXMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGl0ZW1zLmdldChrZXkpO1xuICAgICAgaWYgKCFtZXRhZGF0YSkgY29udGludWU7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBmcmVxdWVuY3ktd2VpZ2h0ZWQgc2NvcmUgKGxvd2VyID0gbW9yZSBsaWtlbHkgdG8gZXZpY3QpXG4gICAgICBjb25zdCBmcmVxdWVuY3kgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YSk7XG4gICAgICBjb25zdCB0aW1lRmFjdG9yID0gRGF0ZS5ub3coKSAtIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0O1xuXG4gICAgICAvLyBTY29yZSBjb21iaW5lcyBmcmVxdWVuY3kgKGxvd2VyIGlzIHdvcnNlKSBhbmQgcmVjZW5jeSAoaGlnaGVyIGlzIHdvcnNlKVxuICAgICAgLy8gTm9ybWFsaXplIHRpbWUgZmFjdG9yIHRvIHNpbWlsYXIgc2NhbGUgYXMgZnJlcXVlbmN5XG4gICAgICBjb25zdCBub3JtYWxpemVkVGltZUZhY3RvciA9IHRpbWVGYWN0b3IgLyAoMTAwMCAqIDYwKTsgLy8gQ29udmVydCB0byBtaW51dGVzXG4gICAgICBjb25zdCBzY29yZSA9IG5vcm1hbGl6ZWRUaW1lRmFjdG9yIC8gTWF0aC5tYXgoMSwgZnJlcXVlbmN5KTtcblxuICAgICAgaWYgKHNjb3JlIDwgbG93ZXN0U2NvcmUpIHtcbiAgICAgICAgbG93ZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgYmVzdEtleSA9IGtleTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdEtleSB8fCAoaXRlbXMuc2l6ZSA+IDAgPyAoaXRlbXMua2V5cygpLm5leHQoKS52YWx1ZSA/PyBudWxsKSA6IG51bGwpO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtQWNjZXNzZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBub3c7XG4gICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcblxuICAgIC8vIFVwZGF0ZSBmcmVxdWVuY3kgdHJhY2tpbmcgc2ltaWxhciB0byBMRlUgc3RyYXRlZ3lcbiAgICBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgPSBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcblxuICAgIC8vIFVwZGF0ZSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSBpZiBlbmFibGVkXG4gICAgaWYgKCh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDApID4gMCkge1xuICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUZyZXF1ZW5jeVNjb3JlKG1ldGFkYXRhLCBub3cpO1xuICAgICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvbW90aW9uIGZyb20gcmVjZW50IHRvIGhvdCBxdWV1ZVxuICAgIGNvbnN0IHJlY2VudEluZGV4ID0gdGhpcy5yZWNlbnRRdWV1ZS5pbmRleE9mKGtleSk7XG4gICAgaWYgKHJlY2VudEluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gSXRlbSBpcyBpbiByZWNlbnQgcXVldWUgLSBjaGVjayBpZiBpdCBzaG91bGQgYmUgcHJvbW90ZWRcbiAgICAgIGlmICh0aGlzLnNob3VsZFByb21vdGVUb0hvdFF1ZXVlKG1ldGFkYXRhKSkge1xuICAgICAgICB0aGlzLnJlY2VudFF1ZXVlLnNwbGljZShyZWNlbnRJbmRleCwgMSk7XG4gICAgICAgIHRoaXMuaG90UXVldWUudW5zaGlmdChrZXkpOyAvLyBBZGQgdG8gZnJvbnQgb2YgaG90IHF1ZXVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBpbiBob3QgcXVldWUgKG1vdmUgdG8gZnJvbnQpXG4gICAgICBjb25zdCBob3RJbmRleCA9IHRoaXMuaG90UXVldWUuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGhvdEluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmhvdFF1ZXVlLnNwbGljZShob3RJbmRleCwgMSk7XG4gICAgICAgIHRoaXMuaG90UXVldWUudW5zaGlmdChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BZGRlZChrZXk6IHN0cmluZywgZXN0aW1hdGVkU2l6ZTogbnVtYmVyLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGxldCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcblxuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICAgIGVzdGltYXRlZFNpemUsXG4gICAgICAgIHJhd0ZyZXF1ZW5jeTogMVxuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBmcmVxdWVuY3kgc2NvcmUgZm9yIGRlY2F5IHRyYWNraW5nXG4gICAgICBpZiAoKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gMTtcbiAgICAgICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyBpbiBnaG9zdCBxdWV1ZSAocHJvbW90ZSB0byBob3QpXG4gICAgaWYgKHRoaXMuZ2hvc3RRdWV1ZS5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5naG9zdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgdGhpcy5ob3RRdWV1ZS51bnNoaWZ0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCB0byByZWNlbnQgcXVldWVcbiAgICAgIHRoaXMucmVjZW50UXVldWUudW5zaGlmdChrZXkpO1xuXG4gICAgICAvLyBMaW1pdCByZWNlbnQgcXVldWUgc2l6ZVxuICAgICAgaWYgKHRoaXMucmVjZW50UXVldWUubGVuZ3RoID4gdGhpcy5tYXhSZWNlbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IGV2aWN0ZWQgPSB0aGlzLnJlY2VudFF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAoZXZpY3RlZCkge1xuICAgICAgICAgIHRoaXMuZ2hvc3RRdWV1ZS5hZGQoZXZpY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMaW1pdCBnaG9zdCBxdWV1ZSBzaXplXG4gICAgaWYgKHRoaXMuZ2hvc3RRdWV1ZS5zaXplID4gdGhpcy5tYXhHaG9zdFNpemUpIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5naG9zdFF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgIGlmIChmaXJzdEtleSkge1xuICAgICAgICB0aGlzLmdob3N0UXVldWUuZGVsZXRlKGZpcnN0S2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtUmVtb3ZlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gUmVtb3ZlIGZyb20gYXBwcm9wcmlhdGUgcXVldWVcbiAgICBjb25zdCByZWNlbnRJbmRleCA9IHRoaXMucmVjZW50UXVldWUuaW5kZXhPZihrZXkpO1xuICAgIGlmIChyZWNlbnRJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMucmVjZW50UXVldWUuc3BsaWNlKHJlY2VudEluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBob3RJbmRleCA9IHRoaXMuaG90UXVldWUuaW5kZXhPZihrZXkpO1xuICAgIGlmIChob3RJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuaG90UXVldWUuc3BsaWNlKGhvdEluZGV4LCAxKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBtZXRhZGF0YVxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYW4gaXRlbSBzaG91bGQgYmUgcHJvbW90ZWQgZnJvbSByZWNlbnQgdG8gaG90IHF1ZXVlXG4gICAqL1xuICBwcml2YXRlIHNob3VsZFByb21vdGVUb0hvdFF1ZXVlKG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5jb25maWcudXNlRnJlcXVlbmN5UHJvbW90aW9uKSB7XG4gICAgICAvLyBUcmFkaXRpb25hbCAyUSBiZWhhdmlvciAtIHByb21vdGUgb24gc2Vjb25kIGFjY2Vzc1xuICAgICAgcmV0dXJuIG1ldGFkYXRhLmFjY2Vzc0NvdW50ID49IDI7XG4gICAgfVxuXG4gICAgLy8gRnJlcXVlbmN5LWJhc2VkIHByb21vdGlvblxuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuY29uZmlnLnByb21vdGlvblRocmVzaG9sZCA/PyAyO1xuICAgIGNvbnN0IGZyZXF1ZW5jeSA9IHRoaXMuZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KG1ldGFkYXRhKTtcbiAgICByZXR1cm4gZnJlcXVlbmN5ID49IHRocmVzaG9sZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZWZmZWN0aXZlIGZyZXF1ZW5jeSBmb3IgYW4gaXRlbSwgYXBwbHlpbmcgZGVjYXkgaWYgZW5hYmxlZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogbnVtYmVyIHtcbiAgICAvLyBJZiBkZWNheSBpcyBkaXNhYmxlZCwgdXNlIHJhdyBmcmVxdWVuY3lcbiAgICBpZiAoKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSB0cmFja2luZ1xuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09ICdudW1iZXInICYmIHR5cGVvZiBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgdGltZVNpbmNlVXBkYXRlID0gbm93IC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gKHRpbWVTaW5jZVVwZGF0ZSAvICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPz8gMzAwMDAwKSkgKiAodGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwLjA1KTtcbiAgICAgIHJldHVybiBNYXRoLm1heCgxLCBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSAqICgxIC0gZGVjYXlBbW91bnQpKTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byByYXcgZnJlcXVlbmN5XG4gICAgcmV0dXJuIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZnJlcXVlbmN5IHNjb3JlIHdpdGggZGVjYXkgYXBwbGllZFxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVGcmVxdWVuY3lTY29yZShtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHJhd0ZyZXEgPSBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG5cbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmF3RnJlcTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBjdXJyZW50VGltZSAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgY29uc3QgZGVjYXlBbW91bnQgPSAodGltZVNpbmNlVXBkYXRlIC8gKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA/PyAzMDAwMDApKSAqICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDAuMDUpO1xuICAgIGNvbnN0IHByZXZpb3VzU2NvcmUgPSBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSB8fCByYXdGcmVxO1xuXG4gICAgLy8gQXBwbHkgZGVjYXkgdG8gcHJldmlvdXMgc2NvcmUgYW5kIGFkZCBuZXcgZnJlcXVlbmN5IGNvbnRyaWJ1dGlvblxuICAgIGNvbnN0IGRlY2F5ZWRTY29yZSA9IHByZXZpb3VzU2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMSwgZGVjYXllZFNjb3JlICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgcGVyaW9kaWMgZGVjYXkgdG8gaG90IHF1ZXVlIGl0ZW1zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGFwcGx5UGVyaW9kaWNEZWNheShpdGVtczogTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDApID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVTaW5jZURlY2F5ID0gbm93IC0gdGhpcy5sYXN0RGVjYXlUaW1lO1xuXG4gICAgaWYgKHRpbWVTaW5jZURlY2F5ID49ICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPz8gMzAwMDAwKSkge1xuICAgICAgLy8gT25seSB1cGRhdGUgbGFzdERlY2F5VGltZSBpZiB3ZSBhY3R1YWxseSBoYXZlIGl0ZW1zIHRvIGRlY2F5XG4gICAgICBpZiAodGhpcy5ob3RRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEFwcGx5IGRlY2F5IHRvIGFsbCBpdGVtcyBpbiBob3QgcXVldWVcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5ob3RRdWV1ZSkge1xuICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gaXRlbXMuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKG1ldGFkYXRhICYmIHR5cGVvZiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMC4wNSk7XG4gICAgICAgICAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IE1hdGgubWF4KDEsIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBub3c7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHN0cmF0ZWd5XG4gICAqL1xuICBnZXRDb25maWcoKTogVHdvUXVldWVDb25maWcge1xuICAgIHJldHVybiB7IC4uLnRoaXMuY29uZmlnIH07XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgaW50ZXJuYWwgc3RhdGUgKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgICovXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMucmVjZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLmhvdFF1ZXVlID0gW107XG4gICAgdGhpcy5naG9zdFF1ZXVlLmNsZWFyKCk7XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZpY3Rpb25Qb2xpY3kgfSBmcm9tICcuLi9PcHRpb25zJztcbmltcG9ydCB7IEV2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL0V2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHtcbiAgREVGQVVMVF9BUkNfQ09ORklHLFxuICBERUZBVUxUX1RXT19RVUVVRV9DT05GSUcsXG4gIEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzXG59IGZyb20gJy4vRXZpY3Rpb25TdHJhdGVneUNvbmZpZyc7XG5cbi8vIEltcG9ydCBhbGwgc3RyYXRlZ3kgY2xhc3Nlc1xuaW1wb3J0IHsgTFJVRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9MUlVFdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCB7IExGVUV2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvTEZVRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQgeyBGSUZPRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9GSUZPRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQgeyBNUlVFdmljdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zdHJhdGVnaWVzL01SVUV2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgUmFuZG9tRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9SYW5kb21FdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCB7IEFSQ0V2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvQVJDRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQgeyBUd29RdWV1ZUV2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvVHdvUXVldWVFdmljdGlvblN0cmF0ZWd5JztcblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBldmljdGlvbiBzdHJhdGVneSBpbnN0YW5jZXMgd2l0aCBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmljdGlvblN0cmF0ZWd5KFxuICBwb2xpY3k6IEV2aWN0aW9uUG9saWN5LFxuICBtYXhDYWNoZVNpemU/OiBudW1iZXIsXG4gIGNvbmZpZz86IEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzXG4pOiBFdmljdGlvblN0cmF0ZWd5IHtcbiAgLy8gSGFuZGxlIGVkZ2UgY2FzZSBvZiBpbnZhbGlkIG1heENhY2hlU2l6ZSBieSB1c2luZyBhIHJlYXNvbmFibGUgZGVmYXVsdFxuICBjb25zdCBzYWZlTWF4Q2FjaGVTaXplID0gKHR5cGVvZiBtYXhDYWNoZVNpemUgPT09ICdudW1iZXInICYmIG1heENhY2hlU2l6ZSA+IDApID8gbWF4Q2FjaGVTaXplIDogMTAwMDtcblxuICBzd2l0Y2ggKHBvbGljeSkge1xuICAgIGNhc2UgJ2xydSc6XG4gICAgICByZXR1cm4gbmV3IExSVUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICBjYXNlICdsZnUnOiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsZnVDb25maWcgPSBjb25maWc/LnR5cGUgPT09ICdsZnUnID8gY29uZmlnIDogeyB0eXBlOiAnbGZ1JyBhcyBjb25zdCB9O1xuICAgICAgICByZXR1cm4gbmV3IExGVUV2aWN0aW9uU3RyYXRlZ3kobGZ1Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIExGVSBzdHJhdGVneSBjcmVhdGlvbiBmYWlscyBkdWUgdG8gaW52YWxpZCBjb25maWcsIGZhbGwgYmFjayB0byBMUlVcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjcmVhdGUgbGZ1IHN0cmF0ZWd5IHdpdGggcHJvdmlkZWQgY29uZmlndXJhdGlvbiwgZmFsbGluZyBiYWNrIHRvIExSVTpgLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IExSVUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSAnZmlmbyc6XG4gICAgICByZXR1cm4gbmV3IEZJRk9FdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgY2FzZSAnbXJ1JzpcbiAgICAgIHJldHVybiBuZXcgTVJVRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgIGNhc2UgJ3JhbmRvbSc6XG4gICAgICByZXR1cm4gbmV3IFJhbmRvbUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICBjYXNlICdhcmMnOiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcmNDb25maWcgPSBjb25maWc/LnR5cGUgPT09ICdhcmMnID8gY29uZmlnIDogeyAuLi5ERUZBVUxUX0FSQ19DT05GSUcsIG1heENhY2hlU2l6ZTogc2FmZU1heENhY2hlU2l6ZSB9O1xuICAgICAgICBjb25zdCBmaW5hbE1heFNpemUgPSAoYXJjQ29uZmlnLm1heENhY2hlU2l6ZSAmJiBhcmNDb25maWcubWF4Q2FjaGVTaXplID4gMCkgPyBhcmNDb25maWcubWF4Q2FjaGVTaXplIDogc2FmZU1heENhY2hlU2l6ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBUkNFdmljdGlvblN0cmF0ZWd5KGZpbmFsTWF4U2l6ZSwgeyAuLi5hcmNDb25maWcsIG1heENhY2hlU2l6ZTogZmluYWxNYXhTaXplIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgQVJDIHN0cmF0ZWd5IGNyZWF0aW9uIGZhaWxzIGR1ZSB0byBpbnZhbGlkIGNvbmZpZywgZmFsbCBiYWNrIHRvIExSVVxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNyZWF0ZSBhcmMgc3RyYXRlZ3kgd2l0aCBwcm92aWRlZCBjb25maWd1cmF0aW9uLCBmYWxsaW5nIGJhY2sgdG8gTFJVOmAsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJVRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlICcycSc6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHR3b1FDb25maWcgPSBjb25maWc/LnR5cGUgPT09ICcycScgPyBjb25maWcgOiB7IC4uLkRFRkFVTFRfVFdPX1FVRVVFX0NPTkZJRywgbWF4Q2FjaGVTaXplOiBzYWZlTWF4Q2FjaGVTaXplIH07XG4gICAgICAgIGNvbnN0IGZpbmFsTWF4U2l6ZSA9ICh0d29RQ29uZmlnLm1heENhY2hlU2l6ZSAmJiB0d29RQ29uZmlnLm1heENhY2hlU2l6ZSA+IDApID8gdHdvUUNvbmZpZy5tYXhDYWNoZVNpemUgOiBzYWZlTWF4Q2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gbmV3IFR3b1F1ZXVlRXZpY3Rpb25TdHJhdGVneShmaW5hbE1heFNpemUsIHsgLi4udHdvUUNvbmZpZywgbWF4Q2FjaGVTaXplOiBmaW5hbE1heFNpemUgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiAyUSBzdHJhdGVneSBjcmVhdGlvbiBmYWlscyBkdWUgdG8gaW52YWxpZCBjb25maWcsIGZhbGwgYmFjayB0byBMUlVcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjcmVhdGUgMnEgc3RyYXRlZ3kgd2l0aCBwcm92aWRlZCBjb25maWd1cmF0aW9uLCBmYWxsaW5nIGJhY2sgdG8gTFJVOmAsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJVRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBldmljdGlvbiBwb2xpY3k6ICR7cG9saWN5fWApO1xuICB9XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIEBkZXByZWNhdGVkIFVzZSBjcmVhdGVFdmljdGlvblN0cmF0ZWd5IHdpdGggY29uZmlnIHBhcmFtZXRlciBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmljdGlvblN0cmF0ZWd5TGVnYWN5KHBvbGljeTogRXZpY3Rpb25Qb2xpY3ksIG1heENhY2hlU2l6ZT86IG51bWJlcik6IEV2aWN0aW9uU3RyYXRlZ3kge1xuICByZXR1cm4gY3JlYXRlRXZpY3Rpb25TdHJhdGVneShwb2xpY3ksIG1heENhY2hlU2l6ZSk7XG59XG4iLCJpbXBvcnQgeyBDYWNoZUl0ZW1NZXRhZGF0YSwgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIH0gZnJvbSAnLi4vZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ1RUTE1hbmFnZXInKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBUVEwgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUVExDb25maWcge1xuICAvKiogRGVmYXVsdCBUVEwgaW4gbWlsbGlzZWNvbmRzIGZvciBhbGwgaXRlbXMgKi9cbiAgZGVmYXVsdFRUTD86IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBjbGVhbiB1cCBleHBpcmVkIGl0ZW1zICovXG4gIGF1dG9DbGVhbnVwPzogYm9vbGVhbjtcbiAgLyoqIEludGVydmFsIGZvciBhdXRvbWF0aWMgY2xlYW51cCBpbiBtaWxsaXNlY29uZHMgKi9cbiAgY2xlYW51cEludGVydmFsPzogbnVtYmVyO1xuICAvKiogV2hldGhlciB0byB2YWxpZGF0ZSBUVEwgb24gYWNjZXNzICovXG4gIHZhbGlkYXRlT25BY2Nlc3M/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRUTC1hd2FyZSBpdGVtIHdyYXBwZXIgdGhhdCBleHRlbmRzIGNhY2hlIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVFRMSXRlbU1ldGFkYXRhIGV4dGVuZHMgQ2FjaGVJdGVtTWV0YWRhdGEge1xuICAvKiogRXhwaXJhdGlvbiB0aW1lc3RhbXAgKGFkZGVkQXQgKyBUVEwpICovXG4gIGV4cGlyZXNBdD86IG51bWJlcjtcbiAgLyoqIFRUTCB2YWx1ZSB1c2VkIGZvciB0aGlzIHNwZWNpZmljIGl0ZW0gKi9cbiAgdHRsPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIE1hbmFnZXMgVFRMIChUaW1lIFRvIExpdmUpIGxvZ2ljIGluZGVwZW5kZW50bHkgb2YgQ2FjaGVNYXAgaW1wbGVtZW50YXRpb25zLlxuICogVGhpcyBhbGxvd3MgYW55IENhY2hlTWFwIHRvIHN1cHBvcnQgVFRMIHdpdGhvdXQgaW1wbGVtZW50aW5nIFRUTC1zcGVjaWZpYyBsb2dpYy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRUTE1hbmFnZXIge1xuICBwcml2YXRlIGNvbmZpZzogVFRMQ29uZmlnO1xuICBwcml2YXRlIGNsZWFudXBUaW1lcj86IE5vZGVKUy5UaW1lb3V0IHwgbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFRUTENvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBhdXRvQ2xlYW51cDogdHJ1ZSxcbiAgICAgIGNsZWFudXBJbnRlcnZhbDogNjAwMDAsIC8vIDEgbWludXRlIGRlZmF1bHRcbiAgICAgIHZhbGlkYXRlT25BY2Nlc3M6IHRydWUsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmF1dG9DbGVhbnVwICYmIHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgdGhpcy5zdGFydEF1dG9DbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIFRUTCBpcyBlbmFibGVkXG4gICAqL1xuICBwdWJsaWMgaXNUVExFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5jb25maWcuZGVmYXVsdFRUTCA9PT0gJ251bWJlcicgJiYgdGhpcy5jb25maWcuZGVmYXVsdFRUTCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IFRUTCB2YWx1ZVxuICAgKi9cbiAgcHVibGljIGdldERlZmF1bHRUVEwoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGVmYXVsdFRUTDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgVFRMIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVDb25maWcoY29uZmlnOiBQYXJ0aWFsPFRUTENvbmZpZz4pOiB2b2lkIHtcbiAgICBjb25zdCBvbGRDb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9O1xuXG4gICAgLy8gUmVzdGFydCBhdXRvIGNsZWFudXAgaWYgY29uZmlndXJhdGlvbiBjaGFuZ2VkXG4gICAgaWYgKG9sZENvbmZpZy5hdXRvQ2xlYW51cCAhPT0gdGhpcy5jb25maWcuYXV0b0NsZWFudXAgfHxcbiAgICAgIG9sZENvbmZpZy5jbGVhbnVwSW50ZXJ2YWwgIT09IHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgdGhpcy5zdG9wQXV0b0NsZWFudXAoKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRvQ2xlYW51cCAmJiB0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5zdGFydEF1dG9DbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKCdUVEwgY29uZmlndXJhdGlvbiB1cGRhdGVkJywgeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBUVEwgbWV0YWRhdGEgZm9yIGFuIGl0ZW0gd2hlbiBpdCdzIGFkZGVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgb25JdGVtQWRkZWQoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLFxuICAgIGl0ZW1UVEw/OiBudW1iZXJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmlzVFRMRW5hYmxlZCgpICYmICFpdGVtVFRMKSB7XG4gICAgICByZXR1cm47IC8vIE5vIFRUTCBjb25maWd1cmVkXG4gICAgfVxuXG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgbG9nZ2VyLndhcm5pbmcoJ05vIG1ldGFkYXRhIGZvdW5kIGZvciBpdGVtIHdoZW4gc2V0dGluZyBUVEwnLCB7IGtleSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0dGwgPSBpdGVtVFRMIHx8IHRoaXMuY29uZmlnLmRlZmF1bHRUVEw7XG4gICAgaWYgKHR0bCAmJiB0dGwgPiAwKSB7XG4gICAgICBjb25zdCB0dGxNZXRhZGF0YTogVFRMSXRlbU1ldGFkYXRhID0ge1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgZXhwaXJlc0F0OiBtZXRhZGF0YS5hZGRlZEF0ICsgdHRsLFxuICAgICAgICB0dGxcbiAgICAgIH07XG4gICAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgdHRsTWV0YWRhdGEpO1xuXG4gICAgICBsb2dnZXIudHJhY2UoJ1RUTCBzZXQgZm9yIGl0ZW0nLCB7IGtleSwgdHRsLCBleHBpcmVzQXQ6IHR0bE1ldGFkYXRhLmV4cGlyZXNBdCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gaXRlbSBoYXMgZXhwaXJlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlzRXhwaXJlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSkgYXMgVFRMSXRlbU1ldGFkYXRhO1xuICAgIGlmICghbWV0YWRhdGEgfHwgIW1ldGFkYXRhLmV4cGlyZXNBdCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBUVEwgc2V0XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBleHBpcmVkID0gbm93ID49IG1ldGFkYXRhLmV4cGlyZXNBdDtcblxuICAgIGlmIChleHBpcmVkKSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ0l0ZW0gZXhwaXJlZCcsIHsga2V5LCBleHBpcmVzQXQ6IG1ldGFkYXRhLmV4cGlyZXNBdCwgbm93IH0pO1xuICAgIH1cblxuICAgIHJldHVybiBleHBpcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGl0ZW0gaXMgdmFsaWQgKG5vdCBleHBpcmVkKSBiZWZvcmUgcmV0dXJuaW5nIGl0XG4gICAqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIGlzIHZhbGlkLCBmYWxzZSBpZiBleHBpcmVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdmFsaWRhdGVJdGVtKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnZhbGlkYXRlT25BY2Nlc3MpIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBTa2lwIHZhbGlkYXRpb24gaWYgZGlzYWJsZWRcbiAgICB9XG5cbiAgICByZXR1cm4gIShhd2FpdCB0aGlzLmlzRXhwaXJlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgVFRMIGluZm9ybWF0aW9uIGZvciBhbiBpdGVtXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0SXRlbVRUTEluZm8oa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8e1xuICAgIGhhc1RUTDogYm9vbGVhbjtcbiAgICB0dGw/OiBudW1iZXI7XG4gICAgZXhwaXJlc0F0PzogbnVtYmVyO1xuICAgIHJlbWFpbmluZ1RUTD86IG51bWJlcjtcbiAgICBpc0V4cGlyZWQ6IGJvb2xlYW47XG4gIH0+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KSBhcyBUVExJdGVtTWV0YWRhdGE7XG5cbiAgICBpZiAoIW1ldGFkYXRhIHx8ICFtZXRhZGF0YS5leHBpcmVzQXQpIHtcbiAgICAgIHJldHVybiB7IGhhc1RUTDogZmFsc2UsIGlzRXhwaXJlZDogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGlzRXhwaXJlZCA9IG5vdyA+PSBtZXRhZGF0YS5leHBpcmVzQXQ7XG4gICAgY29uc3QgcmVtYWluaW5nVFRMID0gaXNFeHBpcmVkID8gMCA6IG1ldGFkYXRhLmV4cGlyZXNBdCAtIG5vdztcblxuICAgIHJldHVybiB7XG4gICAgICBoYXNUVEw6IHRydWUsXG4gICAgICB0dGw6IG1ldGFkYXRhLnR0bCxcbiAgICAgIGV4cGlyZXNBdDogbWV0YWRhdGEuZXhwaXJlc0F0LFxuICAgICAgcmVtYWluaW5nVFRMLFxuICAgICAgaXNFeHBpcmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCBleHBpcmVkIGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZmluZEV4cGlyZWRJdGVtcyhtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgZXhwaXJlZEtleXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbWV0YWRhdGFdIG9mIGFsbE1ldGFkYXRhKSB7XG4gICAgICBjb25zdCB0dGxNZXRhZGF0YSA9IG1ldGFkYXRhIGFzIFRUTEl0ZW1NZXRhZGF0YTtcbiAgICAgIGlmICh0dGxNZXRhZGF0YS5leHBpcmVzQXQgJiYgbm93ID49IHR0bE1ldGFkYXRhLmV4cGlyZXNBdCkge1xuICAgICAgICBleHBpcmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4cGlyZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnRm91bmQgZXhwaXJlZCBpdGVtcycsIHsgY291bnQ6IGV4cGlyZWRLZXlzLmxlbmd0aCwga2V5czogZXhwaXJlZEtleXMgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGlyZWRLZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGNsZWFuIHVwIGV4cGlyZWQgaXRlbXNcbiAgICogUmV0dXJucyB0aGUga2V5cyBvZiBpdGVtcyB0aGF0IHdlcmUgZXhwaXJlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNsZWFudXBFeHBpcmVkSXRlbXMobWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmZpbmRFeHBpcmVkSXRlbXMobWV0YWRhdGFQcm92aWRlcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlbWFpbmluZyBUVEwgZm9yIGFuIGl0ZW0gaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0UmVtYWluaW5nVFRMKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPG51bWJlciB8IG51bGw+IHtcbiAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5nZXRJdGVtVFRMSW5mbyhrZXksIG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgIHJldHVybiBpbmZvLmhhc1RUTCA/IChpbmZvLnJlbWFpbmluZ1RUTCB8fCAwKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIFRUTCBmb3IgYW4gaXRlbVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGV4dGVuZFRUTChcbiAgICBrZXk6IHN0cmluZyxcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgYWRkaXRpb25hbFRUTDogbnVtYmVyXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpIGFzIFRUTEl0ZW1NZXRhZGF0YTtcbiAgICBpZiAoIW1ldGFkYXRhIHx8ICFtZXRhZGF0YS5leHBpcmVzQXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gVFRMIHNldFxuICAgIH1cblxuICAgIG1ldGFkYXRhLmV4cGlyZXNBdCArPSBhZGRpdGlvbmFsVFRMO1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG5cbiAgICBsb2dnZXIudHJhY2UoJ1RUTCBleHRlbmRlZCBmb3IgaXRlbScsIHsga2V5LCBhZGRpdGlvbmFsVFRMLCBuZXdFeHBpcmVzQXQ6IG1ldGFkYXRhLmV4cGlyZXNBdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBUVEwgZm9yIGFuIGl0ZW0gKHJlZnJlc2ggZXhwaXJhdGlvbilcbiAgICovXG4gIHB1YmxpYyBhc3luYyByZWZyZXNoVFRMKFxuICAgIGtleTogc3RyaW5nLFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBuZXdUVEw/OiBudW1iZXJcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSkgYXMgVFRMSXRlbU1ldGFkYXRhO1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB0dGwgPSBuZXdUVEwgfHwgbWV0YWRhdGEudHRsIHx8IHRoaXMuY29uZmlnLmRlZmF1bHRUVEw7XG4gICAgaWYgKCF0dGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gVFRMIHRvIHNldFxuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdHRsTWV0YWRhdGE6IFRUTEl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgZXhwaXJlc0F0OiBub3cgKyB0dGwsXG4gICAgICB0dGxcbiAgICB9O1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCB0dGxNZXRhZGF0YSk7XG5cbiAgICBsb2dnZXIudHJhY2UoJ1RUTCByZWZyZXNoZWQgZm9yIGl0ZW0nLCB7IGtleSwgdHRsLCBleHBpcmVzQXQ6IHR0bE1ldGFkYXRhLmV4cGlyZXNBdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhdXRvbWF0aWMgY2xlYW51cCBvZiBleHBpcmVkIGl0ZW1zXG4gICAqL1xuICBwcml2YXRlIHN0YXJ0QXV0b0NsZWFudXAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICB0aGlzLnN0b3BBdXRvQ2xlYW51cCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAvLyBOb3RlOiBUaGlzIHdpbGwgYmUgaW1wbGVtZW50ZWQgd2hlbiB3ZSBpbnRlZ3JhdGUgd2l0aCBDYWNoZSBjbGFzc1xuICAgICAgICBsb2dnZXIudHJhY2UoJ0F1dG8gY2xlYW51cCB0aW1lciB0cmlnZ2VyZWQnKTtcbiAgICAgIH0sIHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCk7XG5cbiAgICAgIGxvZ2dlci5kZWJ1ZygnQXV0byBjbGVhbnVwIHN0YXJ0ZWQnLCB7IGludGVydmFsOiB0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYXV0b21hdGljIGNsZWFudXBcbiAgICovXG4gIHByaXZhdGUgc3RvcEF1dG9DbGVhbnVwKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsZWFudXBUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgICBsb2dnZXIuZGVidWcoJ0F1dG8gY2xlYW51cCBzdG9wcGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFudXAgcmVzb3VyY2VzXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BBdXRvQ2xlYW51cCgpO1xuICAgIGxvZ2dlci5kZWJ1ZygnVFRMIG1hbmFnZXIgZGVzdHJveWVkJyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbUtleSwgSXRlbSwgSXRlbVF1ZXJ5LCBMb2NLZXksIExvY0tleUFycmF5LCBQcmlLZXkgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7XG4gIEFueUNhY2hlRXZlbnQsXG4gIENhY2hlRXZlbnRMaXN0ZW5lcixcbiAgQ2FjaGVTdWJzY3JpcHRpb24sXG4gIENhY2hlU3Vic2NyaXB0aW9uT3B0aW9uc1xufSBmcm9tIFwiLi9DYWNoZUV2ZW50VHlwZXNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUtleVZhbHVlIH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdWJzY3JpcHRpb24gZGF0YVxuICovXG5pbnRlcmZhY2UgSW50ZXJuYWxTdWJzY3JpcHRpb248XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4ge1xuICBpZDogc3RyaW5nO1xuICBsaXN0ZW5lcjogQ2FjaGVFdmVudExpc3RlbmVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gIGxpc3RlbmVyUmVmPzogV2Vha1JlZjxDYWNoZUV2ZW50TGlzdGVuZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj47XG4gIG9wdGlvbnM6IENhY2hlU3Vic2NyaXB0aW9uT3B0aW9uczxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgZGVib3VuY2VUaW1lcj86IE5vZGVKUy5UaW1lb3V0IHwgbnVsbDtcbiAgbGFzdEVtaXRUaW1lPzogbnVtYmVyO1xuICBjcmVhdGVkQXQ6IG51bWJlcjtcbiAgbGFzdEFjY2Vzc1RpbWU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDYWNoZSBldmVudCBlbWl0dGVyIHRoYXQgbWFuYWdlcyBzdWJzY3JpcHRpb25zIGFuZCBldmVudCBkaXNwYXRjaGluZ1xuICovXG5leHBvcnQgY2xhc3MgQ2FjaGVFdmVudEVtaXR0ZXI8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4ge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgSW50ZXJuYWxTdWJzY3JpcHRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4oKTtcbiAgcHJpdmF0ZSBuZXh0U3Vic2NyaXB0aW9uSWQgPSAxO1xuICBwcml2YXRlIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gIHByaXZhdGUgY2xlYW51cEludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlYWRvbmx5IENMRUFOVVBfSU5URVJWQUxfTVMgPSAzMDAwMDsgLy8gMzAgc2Vjb25kc1xuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9JTkFDVElWRV9USU1FX01TID0gMzAwMDAwOyAvLyA1IG1pbnV0ZXNcbiAgcHJpdmF0ZSByZWFkb25seSBXRUFLX1JFRl9FTkFCTEVEID0gdHlwZW9mIFdlYWtSZWYgIT09ICd1bmRlZmluZWQnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhcnRQZXJpb2RpY0NsZWFudXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwZXJpb2RpYyBjbGVhbnVwIG9mIGluYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIHByaXZhdGUgc3RhcnRQZXJpb2RpY0NsZWFudXAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsKSByZXR1cm47XG5cbiAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMucGVyZm9ybVBlcmlvZGljQ2xlYW51cCgpO1xuICAgIH0sIHRoaXMuQ0xFQU5VUF9JTlRFUlZBTF9NUyk7XG5cbiAgICAvLyBEb24ndCBrZWVwIHRoZSBwcm9jZXNzIGFsaXZlIGp1c3QgZm9yIGNsZWFudXBcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwudW5yZWYpIHtcbiAgICAgIHRoaXMuY2xlYW51cEludGVydmFsLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gcGVyaW9kaWMgY2xlYW51cCBvZiBpbmFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAqL1xuICBwcml2YXRlIHBlcmZvcm1QZXJpb2RpY0NsZWFudXAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdG9SZW1vdmU6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtpZCwgc3Vic2NyaXB0aW9uXSBvZiB0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIC8vIENoZWNrIGlmIHN1YnNjcmlwdGlvbiBpcyBpbmFjdGl2ZSBmb3IgdG9vIGxvbmdcbiAgICAgIGlmICghc3Vic2NyaXB0aW9uLmlzQWN0aXZlIHx8XG4gICAgICAgIChub3cgLSBzdWJzY3JpcHRpb24ubGFzdEFjY2Vzc1RpbWUgPiB0aGlzLk1BWF9JTkFDVElWRV9USU1FX01TKSkge1xuICAgICAgICB0b1JlbW92ZS5wdXNoKGlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGxpc3RlbmVyIGhhcyBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkIChmb3Igd2VhayByZWZlcmVuY2VzKVxuICAgICAgaWYgKHRoaXMuV0VBS19SRUZfRU5BQkxFRCAmJiBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYuZGVyZWYoKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgIHRvUmVtb3ZlLnB1c2goaWQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGluYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICB0b1JlbW92ZS5mb3JFYWNoKGlkID0+IHRoaXMudW5zdWJzY3JpYmUoaWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gY2FjaGUgZXZlbnRzXG4gICAqL1xuICBwdWJsaWMgc3Vic2NyaWJlKFxuICAgIGxpc3RlbmVyOiBDYWNoZUV2ZW50TGlzdGVuZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBvcHRpb25zOiBDYWNoZVN1YnNjcmlwdGlvbk9wdGlvbnM8UywgTDEsIEwyLCBMMywgTDQsIEw1PiA9IHt9XG4gICk6IENhY2hlU3Vic2NyaXB0aW9uIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIGRlc3Ryb3llZCBldmVudCBlbWl0dGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBgc3Vic2NyaXB0aW9uXyR7dGhpcy5uZXh0U3Vic2NyaXB0aW9uSWQrK31gO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb246IEludGVybmFsU3Vic2NyaXB0aW9uPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPSB7XG4gICAgICBpZCxcbiAgICAgIGxpc3RlbmVyLFxuICAgICAgbGlzdGVuZXJSZWY6IHRoaXMuV0VBS19SRUZfRU5BQkxFRCAmJiBvcHRpb25zLnVzZVdlYWtSZWYgIT09IGZhbHNlID9cbiAgICAgICAgbmV3IFdlYWtSZWYobGlzdGVuZXIpIDogdW5kZWZpbmVkLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzVGltZTogbm93XG4gICAgfTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoaWQsIHN1YnNjcmlwdGlvbik7XG5cbiAgICAvLyBSZXR1cm4gcHVibGljIHN1YnNjcmlwdGlvbiBpbnRlcmZhY2VcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4gdGhpcy51bnN1YnNjcmliZShpZCksXG4gICAgICBpc0FjdGl2ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgIHN1Yi5sYXN0QWNjZXNzVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Yj8uaXNBY3RpdmUgPz8gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZ2V0T3B0aW9uczogKCkgPT4gKHsgLi4ub3B0aW9ucyB9KSBhcyBDYWNoZVN1YnNjcmlwdGlvbk9wdGlvbnM8UywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBldmVudHNcbiAgICovXG4gIHB1YmxpYyB1bnN1YnNjcmliZShzdWJzY3JpcHRpb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb25JZCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBhbnkgcGVuZGluZyBkZWJvdW5jZSB0aW1lclxuICAgIGlmIChzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBzdWJzY3JpcHRpb24uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbklkKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnQgdG8gYWxsIG1hdGNoaW5nIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIHB1YmxpYyBlbWl0KGV2ZW50OiBBbnlDYWNoZUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFzdWJzY3JpcHRpb24uaXNBY3RpdmUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3VsZEVtaXRUb1N1YnNjcmlwdGlvbihldmVudCwgc3Vic2NyaXB0aW9uKSkge1xuICAgICAgICB0aGlzLmVtaXRUb1N1YnNjcmlwdGlvbihldmVudCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvdW50IG9mIGFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAqL1xuICBwdWJsaWMgZ2V0U3Vic2NyaXB0aW9uQ291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCkpLmZpbHRlcihzID0+IHMuaXNBY3RpdmUpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3Vic2NyaXB0aW9uIGRldGFpbHMgKGZvciBkZWJ1Z2dpbmcpXG4gICAqL1xuICBwdWJsaWMgZ2V0U3Vic2NyaXB0aW9ucygpOiBBcnJheTx7IGlkOiBzdHJpbmc7IG9wdGlvbnM6IENhY2hlU3Vic2NyaXB0aW9uT3B0aW9uczxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IH0+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCkpXG4gICAgICAuZmlsdGVyKHMgPT4gcy5pc0FjdGl2ZSlcbiAgICAgIC5tYXAocyA9PiAoeyBpZDogcy5pZCwgb3B0aW9uczogeyAuLi5zLm9wdGlvbnMgfSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZXZlbnQgZW1pdHRlciBhbmQgY2xlYW4gdXAgYWxsIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIFN0b3AgcGVyaW9kaWMgY2xlYW51cFxuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBJbnRlcnZhbCk7XG4gICAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgYWxsIGRlYm91bmNlIHRpbWVyc1xuICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmlwdGlvbi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGV2ZW50IHNob3VsZCBiZSBlbWl0dGVkIHRvIGEgc3BlY2lmaWMgc3Vic2NyaXB0aW9uXG4gICAqL1xuICBwcml2YXRlIHNob3VsZEVtaXRUb1N1YnNjcmlwdGlvbihcbiAgICBldmVudDogQW55Q2FjaGVFdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIHN1YnNjcmlwdGlvbjogSW50ZXJuYWxTdWJzY3JpcHRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHN1YnNjcmlwdGlvbjtcblxuICAgIC8vIEZpbHRlciBieSBldmVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuZXZlbnRUeXBlcyAmJiAhb3B0aW9ucy5ldmVudFR5cGVzLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGJ5IHNwZWNpZmljIGtleXNcbiAgICBpZiAob3B0aW9ucy5rZXlzICYmIG9wdGlvbnMua2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoJ2tleScgaW4gZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRLZXlTdHIgPSB0aGlzLm5vcm1hbGl6ZUtleShldmVudC5rZXkpO1xuICAgICAgICBjb25zdCBtYXRjaGVzS2V5ID0gb3B0aW9ucy5rZXlzLnNvbWUoa2V5ID0+XG4gICAgICAgICAgdGhpcy5ub3JtYWxpemVLZXkoa2V5KSA9PT0gZXZlbnRLZXlTdHJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCdhZmZlY3RlZEtleXMnIGluIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50S2V5U3RycyA9IGV2ZW50LmFmZmVjdGVkS2V5cy5tYXAoa2V5ID0+IHRoaXMubm9ybWFsaXplS2V5KGtleSkpO1xuICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0tleSA9IG9wdGlvbnMua2V5cy5zb21lKGtleSA9PlxuICAgICAgICAgIGV2ZW50S2V5U3Rycy5pbmNsdWRlcyh0aGlzLm5vcm1hbGl6ZUtleShrZXkpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIWhhc01hdGNoaW5nS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFdmVudCBkb2Vzbid0IGhhdmUga2V5cywgc2tpcCBpZiBzdWJzY3JpcHRpb24gaXMga2V5LXNwZWNpZmljXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYnkgbG9jYXRpb25zXG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zICYmIG9wdGlvbnMubG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICgnYWZmZWN0ZWRMb2NhdGlvbnMnIGluIGV2ZW50ICYmIGV2ZW50LmFmZmVjdGVkTG9jYXRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2NhdGlvbnNNYXRjaChvcHRpb25zLmxvY2F0aW9ucywgZXZlbnQuYWZmZWN0ZWRMb2NhdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCdsb2NhdGlvbnMnIGluIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5sb2NhdGlvbnNNYXRjaChvcHRpb25zLmxvY2F0aW9ucywgZXZlbnQubG9jYXRpb25zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgna2V5JyBpbiBldmVudCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaXRlbSBrZXkgbWF0Y2hlcyB0aGUgbG9jYXRpb24gZmlsdGVyXG4gICAgICAgIGlmICghdGhpcy5rZXlNYXRjaGVzTG9jYXRpb25zKGV2ZW50LmtleSwgb3B0aW9ucy5sb2NhdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFdmVudCBkb2Vzbid0IGhhdmUgbG9jYXRpb24gaW5mbywgc2tpcCBpZiBzdWJzY3JpcHRpb24gaXMgbG9jYXRpb24tc3BlY2lmaWNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbHRlciBieSBxdWVyeSAodGhpcyBpcyBtb3JlIGNvbXBsZXggYW5kIGFwcHJveGltYXRlKVxuICAgIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgICBpZiAoJ3F1ZXJ5JyBpbiBldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMucXVlcmllc01hdGNoKG9wdGlvbnMucXVlcnksIGV2ZW50LnF1ZXJ5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG5vbi1xdWVyeSBldmVudHMsIHdlIGNhbid0IGVhc2lseSBkZXRlcm1pbmUgaWYgdGhleSBtYXRjaCBhIHF1ZXJ5IGZpbHRlclxuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGVuaGFuY2VkIHdpdGggbW9yZSBzb3BoaXN0aWNhdGVkIHF1ZXJ5IG1hdGNoaW5nXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgZXZlbnQgdG8gYSBzcGVjaWZpYyBzdWJzY3JpcHRpb24sIGhhbmRsaW5nIGRlYm91bmNpbmdcbiAgICovXG4gIHByaXZhdGUgZW1pdFRvU3Vic2NyaXB0aW9uKFxuICAgIGV2ZW50OiBBbnlDYWNoZUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgc3Vic2NyaXB0aW9uOiBJbnRlcm5hbFN1YnNjcmlwdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBsYXN0IGFjY2VzcyB0aW1lIGZvciBjbGVhbnVwIHB1cnBvc2VzXG4gICAgc3Vic2NyaXB0aW9uLmxhc3RBY2Nlc3NUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIEdldCB0aGUgbGlzdGVuZXIsIGVpdGhlciBkaXJlY3RseSBvciBmcm9tIHdlYWsgcmVmZXJlbmNlXG4gICAgbGV0IGxpc3RlbmVyID0gc3Vic2NyaXB0aW9uLmxpc3RlbmVyO1xuICAgIGlmICh0aGlzLldFQUtfUkVGX0VOQUJMRUQgJiYgc3Vic2NyaXB0aW9uLmxpc3RlbmVyUmVmKSB7XG4gICAgICBjb25zdCB3ZWFrTGlzdGVuZXIgPSBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYuZGVyZWYoKTtcbiAgICAgIGlmICghd2Vha0xpc3RlbmVyKSB7XG4gICAgICAgIC8vIExpc3RlbmVyIGhhcyBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkLCBtYXJrIGFzIGluYWN0aXZlXG4gICAgICAgIHN1YnNjcmlwdGlvbi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsaXN0ZW5lciA9IHdlYWtMaXN0ZW5lcjtcbiAgICB9XG5cbiAgICBpZiAoIXN1YnNjcmlwdGlvbi5vcHRpb25zLmRlYm91bmNlTXMpIHtcbiAgICAgIC8vIE5vIGRlYm91bmNpbmcsIGVtaXQgaW1tZWRpYXRlbHlcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTGlzdGVuZXJFcnJvcihlcnJvciwgZXZlbnQsIHN1YnNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgZXhpc3RpbmcgZGVib3VuY2UgdGltZXJcbiAgICBpZiAoc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lcik7XG4gICAgICBzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2V0IG5ldyBkZWJvdW5jZSB0aW1lclxuICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLmlzQWN0aXZlKSB7XG4gICAgICAgIC8vIFJlLWNoZWNrIGxpc3RlbmVyIGF2YWlsYWJpbGl0eSBmb3Igd2VhayByZWZlcmVuY2VzXG4gICAgICAgIGxldCBjdXJyZW50TGlzdGVuZXIgPSBzdWJzY3JpcHRpb24ubGlzdGVuZXI7XG4gICAgICAgIGlmICh0aGlzLldFQUtfUkVGX0VOQUJMRUQgJiYgc3Vic2NyaXB0aW9uLmxpc3RlbmVyUmVmKSB7XG4gICAgICAgICAgY29uc3Qgd2Vha0xpc3RlbmVyID0gc3Vic2NyaXB0aW9uLmxpc3RlbmVyUmVmLmRlcmVmKCk7XG4gICAgICAgICAgaWYgKCF3ZWFrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50TGlzdGVuZXIgPSB3ZWFrTGlzdGVuZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLmxhc3RFbWl0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVMaXN0ZW5lckVycm9yKGVycm9yLCBldmVudCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyIHJlZmVyZW5jZSB0byBhbGxvdyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICB9LCBzdWJzY3JpcHRpb24ub3B0aW9ucy5kZWJvdW5jZU1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBrZXkgZm9yIGNvbXBhcmlzb25cbiAgICovXG4gIHByaXZhdGUgbm9ybWFsaXplS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBzdHJpbmcge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXksIChrLCB2KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplS2V5VmFsdWUodik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBsb2NhdGlvbiBrZXkgZm9yIGNvbXBhcmlzb25cbiAgICovXG4gIHByaXZhdGUgbm9ybWFsaXplTG9jS2V5KGtleTogTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5LCAoaywgdikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUtleVZhbHVlKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIGxvY2F0aW9uIGFycmF5cyBtYXRjaFxuICAgKiBGaWx0ZXIgbG9jYXRpb25zIG11c3QgYmUgYSBwcmVmaXggb2YgZXZlbnQgbG9jYXRpb25zIChpbiBvcmRlcilcbiAgICovXG4gIHByaXZhdGUgbG9jYXRpb25zTWF0Y2goXG4gICAgZmlsdGVyOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10sXG4gICAgZXZlbnRMb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApOiBib29sZWFuIHtcbiAgICAvLyBFbXB0eSBmaWx0ZXIgb25seSBtYXRjaGVzIGVtcHR5IGV2ZW50IGxvY2F0aW9uc1xuICAgIGlmIChmaWx0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZXZlbnRMb2NhdGlvbnMubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gZXZlbnQgbG9jYXRpb25zXG4gICAgaWYgKGZpbHRlci5sZW5ndGggPiBldmVudExvY2F0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBmaWx0ZXIgbG9jYXRpb25zIGFyZSBhIHByZWZpeCBvZiBldmVudCBsb2NhdGlvbnNcbiAgICByZXR1cm4gZmlsdGVyLmV2ZXJ5KChmaWx0ZXJMb2MsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBldmVudExvYyA9IGV2ZW50TG9jYXRpb25zW2luZGV4XTtcbiAgICAgIC8vIExvY0tleSBoYXMgZGlmZmVyZW50IHN0cnVjdHVyZSBmcm9tIENvbUtleS9QcmlLZXksIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIHVzaW5nIHRoZWlyIG93biBwcm9wZXJ0aWVzXG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVLZXkoZmlsdGVyTG9jIGFzIGFueSkgPT09IHRoaXMubm9ybWFsaXplS2V5KGV2ZW50TG9jIGFzIGFueSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgbWF0Y2hlcyBsb2NhdGlvbiBmaWx0ZXJzXG4gICAqL1xuICBwcml2YXRlIGtleU1hdGNoZXNMb2NhdGlvbnMoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBmaWx0ZXJMb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApOiBib29sZWFuIHtcbiAgICAvLyBJZiBrZXkgaXMgYSBDb21LZXksIGNoZWNrIGlmIGl0cyBsb2NhdGlvbnMgbWF0Y2ggdGhlIGZpbHRlclxuICAgIGlmICgnbG9jJyBpbiBrZXkgJiYga2V5LmxvYykge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb25zTWF0Y2goZmlsdGVyTG9jYXRpb25zLCBrZXkubG9jKTtcbiAgICB9XG5cbiAgICAvLyBQcmlLZXkgZG9lc24ndCBoYXZlIGxvY2F0aW9ucywgc28gb25seSBtYXRjaGVzIGlmIGZpbHRlciBpcyBlbXB0eVxuICAgIHJldHVybiBmaWx0ZXJMb2NhdGlvbnMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byBxdWVyaWVzIG1hdGNoIChpbXByb3ZlZCBjb21wYXJpc29uKVxuICAgKi9cbiAgcHJpdmF0ZSBxdWVyaWVzTWF0Y2goZmlsdGVyUXVlcnk6IEl0ZW1RdWVyeSwgZXZlbnRRdWVyeTogSXRlbVF1ZXJ5KTogYm9vbGVhbiB7XG4gICAgLy8gTm9ybWFsaXplIHF1ZXJpZXMgZm9yIGNvbnNpc3RlbnQgY29tcGFyaXNvblxuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IChvYmo6IGFueSk6IGFueSA9PiB7XG4gICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSByZXR1cm4gb2JqO1xuICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm4gb2JqO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iai5tYXAobm9ybWFsaXplKS5zb3J0KCk7XG5cbiAgICAgIGNvbnN0IHNvcnRlZDogYW55ID0ge307XG4gICAgICBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHNvcnRlZFtrZXldID0gbm9ybWFsaXplKG9ialtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZShmaWx0ZXJRdWVyeSkpID09PSBKU09OLnN0cmluZ2lmeShub3JtYWxpemUoZXZlbnRRdWVyeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBlcnJvcnMgdGhhdCBvY2N1ciBpbiBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlTGlzdGVuZXJFcnJvcihcbiAgICBlcnJvcjogdW5rbm93bixcbiAgICBldmVudDogQW55Q2FjaGVFdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIHN1YnNjcmlwdGlvbjogSW50ZXJuYWxTdWJzY3JpcHRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiB2b2lkIHtcbiAgICBjb25zdCBlcnJvck9iaiA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcblxuICAgIGlmIChzdWJzY3JpcHRpb24ub3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdWJzY3JpcHRpb24ub3B0aW9ucy5vbkVycm9yKGVycm9yT2JqLCBldmVudCk7XG4gICAgICB9IGNhdGNoIChoYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGhlIGVycm9yIGhhbmRsZXIgaXRzZWxmIHRocm93cywgbG9nIGJvdGggZXJyb3JzXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNhY2hlIGV2ZW50IGxpc3RlbmVyOicsIGVycm9yT2JqKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgaGFuZGxlcjonLCBoYW5kbGVyRXJyb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBjYWNoZSBldmVudCBsaXN0ZW5lcjonLCBlcnJvck9iaik7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENhY2hlIHN0YXRpc3RpY3MgdHJhY2tpbmcgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVTdGF0cyB7XG4gIC8qKiBUb3RhbCBudW1iZXIgb2YgY2FjaGUgcmVxdWVzdHMgKGdldC9yZXRyaWV2ZSBvcGVyYXRpb25zKSAqL1xuICBudW1SZXF1ZXN0czogbnVtYmVyO1xuICAvKiogVG90YWwgbnVtYmVyIG9mIGNhY2hlIG1pc3NlcyAoaXRlbXMgbm90IGZvdW5kIGluIGNhY2hlKSAqL1xuICBudW1NaXNzZXM6IG51bWJlcjtcbiAgLyoqIFRvdGFsIG51bWJlciBvZiBjYWNoZSBoaXRzIChpdGVtcyBmb3VuZCBpbiBjYWNoZSkgKi9cbiAgbnVtSGl0czogbnVtYmVyO1xuICAvKiogVG90YWwgbnVtYmVyIG9mIHN1YnNjcmlwdGlvbiByZXF1ZXN0cyAqL1xuICBudW1TdWJzY3JpcHRpb25zOiBudW1iZXI7XG4gIC8qKiBUb3RhbCBudW1iZXIgb2YgdW5zdWJzY3JpcHRpb24gcmVxdWVzdHMgKi9cbiAgbnVtVW5zdWJzY3JpcHRpb25zOiBudW1iZXI7XG4gIC8qKiBDdXJyZW50IG51bWJlciBvZiBhY3RpdmUgc3Vic2NyaXB0aW9ucyAqL1xuICBhY3RpdmVTdWJzY3JpcHRpb25zOiBudW1iZXI7XG59XG5cbi8qKlxuICogQ2FjaGUgc3RhdGlzdGljcyBtYW5hZ2VyIHRoYXQgdHJhY2tzIHZhcmlvdXMgY2FjaGUgbWV0cmljc1xuICovXG5leHBvcnQgY2xhc3MgQ2FjaGVTdGF0c01hbmFnZXIge1xuICBwcml2YXRlIHN0YXRzOiBDYWNoZVN0YXRzID0ge1xuICAgIG51bVJlcXVlc3RzOiAwLFxuICAgIG51bU1pc3NlczogMCxcbiAgICBudW1IaXRzOiAwLFxuICAgIG51bVN1YnNjcmlwdGlvbnM6IDAsXG4gICAgbnVtVW5zdWJzY3JpcHRpb25zOiAwLFxuICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnM6IDBcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSByZXF1ZXN0IGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudFJlcXVlc3RzKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdHMubnVtUmVxdWVzdHMrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIGNhY2hlIGhpdCBjb3VudGVyXG4gICAqL1xuICBpbmNyZW1lbnRIaXRzKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdHMubnVtSGl0cysrO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgY2FjaGUgbWlzcyBjb3VudGVyXG4gICAqL1xuICBpbmNyZW1lbnRNaXNzZXMoKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0cy5udW1NaXNzZXMrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHN1YnNjcmlwdGlvbiBjb3VudGVyXG4gICAqL1xuICBpbmNyZW1lbnRTdWJzY3JpcHRpb25zKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdHMubnVtU3Vic2NyaXB0aW9ucysrO1xuICAgIHRoaXMuc3RhdHMuYWN0aXZlU3Vic2NyaXB0aW9ucysrO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgdW5zdWJzY3JpcHRpb24gY291bnRlclxuICAgKi9cbiAgaW5jcmVtZW50VW5zdWJzY3JpcHRpb25zKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdHMubnVtVW5zdWJzY3JpcHRpb25zKys7XG4gICAgaWYgKHRoaXMuc3RhdHMuYWN0aXZlU3Vic2NyaXB0aW9ucyA+IDApIHtcbiAgICAgIHRoaXMuc3RhdHMuYWN0aXZlU3Vic2NyaXB0aW9ucy0tO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFN0YXRzKCk6IENhY2hlU3RhdHMge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc3RhdHMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhbGwgc3RhdGlzdGljcyB0byB6ZXJvXG4gICAqL1xuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgbnVtUmVxdWVzdHM6IDAsXG4gICAgICBudW1NaXNzZXM6IDAsXG4gICAgICBudW1IaXRzOiAwLFxuICAgICAgbnVtU3Vic2NyaXB0aW9uczogMCxcbiAgICAgIG51bVVuc3Vic2NyaXB0aW9uczogMCxcbiAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnM6IDBcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBJbnN0YW5jZSBhcyBCYXNlSW5zdGFuY2UsIENvb3JkaW5hdGUsIFJlZ2lzdHJ5IH0gZnJvbSBcIkBmamVsbC9yZWdpc3RyeVwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpIH0gZnJvbSBcIkBmamVsbC9jbGllbnQtYXBpXCI7XG5pbXBvcnQgeyBDYWNoZU1hcCB9IGZyb20gXCIuL0NhY2hlTWFwXCI7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRpb25zLCBPcGVyYXRpb25zIH0gZnJvbSBcIi4vT3BlcmF0aW9uc1wiO1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVNYXAsIGNyZWF0ZU9wdGlvbnMsIE9wdGlvbnMgfSBmcm9tIFwiLi9PcHRpb25zXCI7XG5pbXBvcnQgeyBFdmljdGlvbk1hbmFnZXIgfSBmcm9tIFwiLi9ldmljdGlvbi9FdmljdGlvbk1hbmFnZXJcIjtcbmltcG9ydCB7IGNyZWF0ZUV2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tIFwiLi9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5RmFjdG9yeVwiO1xuaW1wb3J0IHsgVFRMTWFuYWdlciB9IGZyb20gXCIuL3R0bC9UVExNYW5hZ2VyXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi9ldmVudHMvQ2FjaGVFdmVudEVtaXR0ZXJcIjtcbmltcG9ydCB7IENhY2hlRXZlbnRMaXN0ZW5lciwgQ2FjaGVTdWJzY3JpcHRpb24sIENhY2hlU3Vic2NyaXB0aW9uT3B0aW9ucyB9IGZyb20gXCIuL2V2ZW50cy9DYWNoZUV2ZW50VHlwZXNcIjtcbmltcG9ydCB7IENhY2hlRXZlbnRGYWN0b3J5IH0gZnJvbSBcIi4vZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBDYWNoZVN0YXRzLCBDYWNoZVN0YXRzTWFuYWdlciB9IGZyb20gXCIuL0NhY2hlU3RhdHNcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnQ2FjaGUnKTtcblxuLyoqXG4gKiBDYWNoZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uIGV4cG9zZWQgdG8gY2xpZW50IGFwcGxpY2F0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlSW5mbyB7XG4gIC8qKiBUaGUgaW1wbGVtZW50YXRpb24gdHlwZSBpbiBmb3JtYXQgXCI8Y2F0ZWdvcnk+LzxpbXBsZW1lbnRhdGlvbj5cIiAqL1xuICBpbXBsZW1lbnRhdGlvblR5cGU6IHN0cmluZztcbiAgLyoqIFRoZSBldmljdGlvbiBwb2xpY3kgYmVpbmcgdXNlZCAoaWYgYW55KSAqL1xuICBldmljdGlvblBvbGljeT86IHN0cmluZztcbiAgLyoqIERlZmF1bHQgVFRMIGluIG1pbGxpc2Vjb25kcyAoaWYgY29uZmlndXJlZCkgKi9cbiAgZGVmYXVsdFRUTD86IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgVFRMIGlzIHN1cHBvcnRlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uICovXG4gIHN1cHBvcnRzVFRMOiBib29sZWFuO1xuICAvKiogV2hldGhlciBldmljdGlvbiBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvbiAqL1xuICBzdXBwb3J0c0V2aWN0aW9uOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRoZSBDYWNoZSBpbnRlcmZhY2UgZXh0ZW5kcyB0aGUgYmFzZSBJbnN0YW5jZSBmcm9tIEBmamVsbC9yZWdpc3RyeSBhbmQgYWRkcyBjYWNoZSBvcGVyYXRpb25zXG4gKiBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBjYWNoZWQgZGF0YS5cbiAqXG4gKiBUaGUgaW50ZXJmYWNlIGV4dGVuZHMgdGhlIGJhc2UgSW5zdGFuY2UgKHdoaWNoIHByb3ZpZGVzIGNvb3JkaW5hdGUgYW5kIHJlZ2lzdHJ5KSB3aXRoOlxuICogLSBhcGk6IFByb3ZpZGVzIG1ldGhvZHMgZm9yIGludGVyYWN0aW5nIHdpdGggc2VydmVyIEFQSVxuICogLSBjYWNoZU1hcDogTG9jYWwgY2FjaGUgc3RvcmFnZSBmb3IgaXRlbXNcbiAqIC0gb3BlcmF0aW9uczogQWxsIGNhY2hlIG9wZXJhdGlvbnMgKGdldCwgc2V0LCBhbGwsIGV0Yy4pIHRoYXQgd29yayB3aXRoIGJvdGggY2FjaGUgYW5kIEFQSVxuICpcbiAqIEB0ZW1wbGF0ZSBWIC0gVGhlIHR5cGUgb2YgdGhlIGRhdGEgbW9kZWwgaXRlbSwgZXh0ZW5kaW5nIEl0ZW1cbiAqIEB0ZW1wbGF0ZSBTIC0gVGhlIHN0cmluZyBsaXRlcmFsIHR5cGUgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCdzIGtleSB0eXBlXG4gKiBAdGVtcGxhdGUgTDEtTDUgLSBPcHRpb25hbCBzdHJpbmcgbGl0ZXJhbCB0eXBlcyBmb3IgbG9jYXRpb24gaGllcmFyY2h5IGxldmVsc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IGV4dGVuZHMgQmFzZUluc3RhbmNlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAvKiogVGhlIEFQSSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggc2VydmVyIGVuZHBvaW50cyAqL1xuICBhcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKiBUaGUgY2FjaGUgbWFwIHRoYXQgc3RvcmVzIGNhY2hlZCBpdGVtcyAqL1xuICBjYWNoZU1hcDogQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogQWxsIGNhY2hlIG9wZXJhdGlvbnMgdGhhdCB3b3JrIHdpdGggYm90aCBjYWNoZSBhbmQgQVBJICovXG4gIG9wZXJhdGlvbnM6IE9wZXJhdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogQ2FjaGUgY29uZmlndXJhdGlvbiBvcHRpb25zICovXG4gIG9wdGlvbnM/OiBPcHRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZXIgZm9yIGNhY2hlIGV2ZW50cyAqL1xuICBldmVudEVtaXR0ZXI6IENhY2hlRXZlbnRFbWl0dGVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLyoqIEV2aWN0aW9uIG1hbmFnZXIgZm9yIGhhbmRsaW5nIGNhY2hlIGV2aWN0aW9uIGluZGVwZW5kZW50bHkgb2Ygc3RvcmFnZSAqL1xuICBldmljdGlvbk1hbmFnZXI6IEV2aWN0aW9uTWFuYWdlcjtcblxuICAvKiogVFRMIG1hbmFnZXIgZm9yIGhhbmRsaW5nIHRpbWUtdG8tbGl2ZSBpbmRlcGVuZGVudGx5IG9mIHN0b3JhZ2UgKi9cbiAgdHRsTWFuYWdlcjogVFRMTWFuYWdlcjtcblxuICAvKiogU3RhdGlzdGljcyBtYW5hZ2VyIGZvciB0cmFja2luZyBjYWNoZSBtZXRyaWNzICovXG4gIHN0YXRzTWFuYWdlcjogQ2FjaGVTdGF0c01hbmFnZXI7XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uIGZvciBjbGllbnQgYXBwbGljYXRpb25zXG4gICAqIFByb3ZpZGVzIHZpc2liaWxpdHkgaW50byBpbXBsZW1lbnRhdGlvbiB0eXBlLCBldmljdGlvbiBwb2xpY3ksIFRUTCBzZXR0aW5ncywgYW5kIGNhcGFiaWxpdGllc1xuICAgKi9cbiAgZ2V0Q2FjaGVJbmZvKCk6IENhY2hlSW5mbztcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY2FjaGUgc3RhdGlzdGljc1xuICAgKiBAcmV0dXJucyBDdXJyZW50IGNhY2hlIHN0YXRpc3RpY3MgaW5jbHVkaW5nIGhpdHMsIG1pc3NlcywgcmVxdWVzdHMsIGFuZCBzdWJzY3JpcHRpb24gY291bnRzXG4gICAqL1xuICBnZXRTdGF0cygpOiBDYWNoZVN0YXRzO1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gY2FjaGUgZXZlbnRzXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlbnRzIG9jY3VyXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIGZpbHRlcnMgZm9yIHdoaWNoIGV2ZW50cyB0byByZWNlaXZlXG4gICAqIEByZXR1cm5zIFN1YnNjcmlwdGlvbiBvYmplY3Qgd2l0aCB1bnN1YnNjcmliZSBtZXRob2RcbiAgICovXG4gIHN1YnNjcmliZShcbiAgICBsaXN0ZW5lcjogQ2FjaGVFdmVudExpc3RlbmVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgb3B0aW9ucz86IENhY2hlU3Vic2NyaXB0aW9uT3B0aW9uczxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IENhY2hlU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIGNhY2hlIGV2ZW50c1xuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIFN1YnNjcmlwdGlvbiB0byBjYW5jZWxcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBzdWJzY3JpcHRpb24gd2FzIGZvdW5kIGFuZCBjYW5jZWxsZWRcbiAgICovXG4gIHVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbjogQ2FjaGVTdWJzY3JpcHRpb24pOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBjYWNoZSBhbmQgY2xlYW4gdXAgYWxsIHJlc291cmNlc1xuICAgKi9cbiAgZGVzdHJveSgpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlQ2FjaGUgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgYXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBjb29yZGluYXRlOiBDb29yZGluYXRlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgcmVnaXN0cnk6IFJlZ2lzdHJ5LFxuICAgIG9wdGlvbnM/OiBQYXJ0aWFsPE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj5cbiAgKTogQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG4gIGxvZ2dlci5kZWJ1ZygnY3JlYXRlQ2FjaGUnLCB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5LCBvcHRpb25zIH0pO1xuXG4gIC8vIENyZWF0ZSBjb21wbGV0ZSBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgY29uc3QgY29tcGxldGVPcHRpb25zID0gY3JlYXRlT3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBDcmVhdGUgdGhlIGNhY2hlIG1hcCB1c2luZyB0aGUgb3B0aW9uc1xuICBjb25zdCBjYWNoZU1hcCA9IGNyZWF0ZUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oY29vcmRpbmF0ZS5rdGEsIGNvbXBsZXRlT3B0aW9ucyk7XG5cbiAgLy8gR2V0IHRoZSBwcmltYXJ5IGtleSB0eXBlIGZyb20gdGhlIGNvb3JkaW5hdGVcbiAgY29uc3QgcGtUeXBlID0gY29vcmRpbmF0ZS5rdGFbMF0gYXMgUztcblxuICAvLyBDcmVhdGUgZXZlbnQgZW1pdHRlclxuICBjb25zdCBldmVudEVtaXR0ZXIgPSBuZXcgQ2FjaGVFdmVudEVtaXR0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PigpO1xuXG4gIC8vIENyZWF0ZSBldmljdGlvbiBtYW5hZ2VyXG4gIGNvbnN0IGV2aWN0aW9uTWFuYWdlciA9IG5ldyBFdmljdGlvbk1hbmFnZXIoKTtcblxuICAvLyBEZXRlcm1pbmUgZXZpY3Rpb24gY29uZmlndXJhdGlvbiAtIHByaW9yaXRpemUgdG9wLWxldmVsIGV2aWN0aW9uQ29uZmlnXG4gIGNvbnN0IGV2aWN0aW9uQ29uZmlnID0gY29tcGxldGVPcHRpb25zLmV2aWN0aW9uQ29uZmlnO1xuICBpZiAoIWV2aWN0aW9uQ29uZmlnICYmXG4gICAgY29tcGxldGVPcHRpb25zLm1lbW9yeUNvbmZpZz8uc2l6ZT8uZXZpY3Rpb25Qb2xpY3kgJiZcbiAgICAoY29tcGxldGVPcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heEl0ZW1zIHx8IGNvbXBsZXRlT3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZS5tYXhTaXplQnl0ZXMpKSB7XG4gIH1cblxuICBpZiAoZXZpY3Rpb25Db25maWcpIHtcbiAgICAvLyBTZXQgZXZpY3Rpb24gc3RyYXRlZ3kgZnJvbSB1bmlmaWVkIGNvbmZpZ1xuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY3JlYXRlRXZpY3Rpb25TdHJhdGVneShcbiAgICAgIGV2aWN0aW9uQ29uZmlnLnR5cGUgfHwgJ2xydScsXG4gICAgICBjb21wbGV0ZU9wdGlvbnMubWVtb3J5Q29uZmlnPy5tYXhJdGVtcyxcbiAgICAgIGV2aWN0aW9uQ29uZmlnXG4gICAgKTtcbiAgICBldmljdGlvbk1hbmFnZXIuc2V0RXZpY3Rpb25TdHJhdGVneShzdHJhdGVneSk7XG4gIH1cblxuICAvLyBDcmVhdGUgVFRMIG1hbmFnZXIgd2l0aCBwcm9wZXIgY29uZmlndXJhdGlvbiBwcmlvcml0eTogbWVtb3J5Q29uZmlnLnR0bCB8fCB0dGxcbiAgY29uc3QgdHRsTWFuYWdlciA9IG5ldyBUVExNYW5hZ2VyKHtcbiAgICBkZWZhdWx0VFRMOiBjb21wbGV0ZU9wdGlvbnMudHRsLFxuICAgIGF1dG9DbGVhbnVwOiB0cnVlLFxuICAgIHZhbGlkYXRlT25BY2Nlc3M6IHRydWVcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHN0YXRpc3RpY3MgbWFuYWdlclxuICBjb25zdCBzdGF0c01hbmFnZXIgPSBuZXcgQ2FjaGVTdGF0c01hbmFnZXIoKTtcblxuICAvLyBOb3RlOiBFdmljdGlvbk1hbmFnZXIgb3BlcmF0ZXMgaW5kZXBlbmRlbnRseSBvZiBDYWNoZU1hcCBpbXBsZW1lbnRhdGlvbnNcbiAgLy8gYW5kIGlzIHBhc3NlZCB0aHJvdWdoIENhY2hlQ29udGV4dCB0byBvcGVyYXRpb25zIGZvciBleHRlcm5hbCBldmljdGlvbiBtYW5hZ2VtZW50XG5cbiAgLy8gQ3JlYXRlIG9wZXJhdGlvbnMgd2l0aCBldmVudCBlbWl0dGVyLCBldmljdGlvbiBtYW5hZ2VyLCBhbmQgc3RhdHMgbWFuYWdlclxuICBjb25zdCBvcGVyYXRpb25zID0gY3JlYXRlT3BlcmF0aW9ucyhhcGksIGNvb3JkaW5hdGUsIGNhY2hlTWFwLCBwa1R5cGUsIGNvbXBsZXRlT3B0aW9ucywgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIHN0YXRzTWFuYWdlcik7XG5cbiAgY29uc3QgY2FjaGU6IENhY2hlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPSB7XG4gICAgY29vcmRpbmF0ZSxcbiAgICByZWdpc3RyeSxcbiAgICBhcGksXG4gICAgY2FjaGVNYXAsXG4gICAgb3BlcmF0aW9ucyxcbiAgICBvcHRpb25zOiBjb21wbGV0ZU9wdGlvbnMsXG4gICAgZXZlbnRFbWl0dGVyLFxuICAgIGV2aWN0aW9uTWFuYWdlcixcbiAgICB0dGxNYW5hZ2VyLFxuICAgIHN0YXRzTWFuYWdlcixcbiAgICBnZXRDYWNoZUluZm86ICgpID0+IHtcbiAgICAgIGNvbnN0IGV2aWN0aW9uU3RyYXRlZ3lOYW1lID0gZXZpY3Rpb25NYW5hZ2VyLmdldEV2aWN0aW9uU3RyYXRlZ3lOYW1lKCk7XG4gICAgICBjb25zdCBjYWNoZUluZm86IENhY2hlSW5mbyA9IHtcbiAgICAgICAgaW1wbGVtZW50YXRpb25UeXBlOiBjYWNoZU1hcC5pbXBsZW1lbnRhdGlvblR5cGUsXG4gICAgICAgIGRlZmF1bHRUVEw6IHR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpLFxuICAgICAgICAvLyBDYWNoZSBzdXBwb3J0cyBUVEwgaWYgdGhlIENhY2hlTWFwIHN1cHBvcnRzIGl0IE9SIGlmIFRUTCBpcyBjb25maWd1cmVkXG4gICAgICAgIHN1cHBvcnRzVFRMOiAoY2FjaGVNYXAgYXMgYW55KS5zdXBwb3J0c1RUTD8uKCkgfHwgISF0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSxcbiAgICAgICAgc3VwcG9ydHNFdmljdGlvbjogZXZpY3Rpb25NYW5hZ2VyLmlzRXZpY3Rpb25TdXBwb3J0ZWQoKVxuICAgICAgfTtcblxuICAgICAgaWYgKGV2aWN0aW9uU3RyYXRlZ3lOYW1lKSB7XG4gICAgICAgIGNhY2hlSW5mby5ldmljdGlvblBvbGljeSA9IGV2aWN0aW9uU3RyYXRlZ3lOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVJbmZvO1xuICAgIH0sXG4gICAgZ2V0U3RhdHM6ICgpID0+IHN0YXRzTWFuYWdlci5nZXRTdGF0cygpLFxuICAgIHN1YnNjcmliZTogKGxpc3RlbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50U3Vic2NyaXB0aW9ucygpO1xuICAgICAgcmV0dXJuIGV2ZW50RW1pdHRlci5zdWJzY3JpYmUobGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgdW5zdWJzY3JpYmU6IChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV2ZW50RW1pdHRlci51bnN1YnNjcmliZShzdWJzY3JpcHRpb24uaWQpO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50VW5zdWJzY3JpcHRpb25zKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgZXZlbnQgZW1pdHRlclxuICAgICAgZXZlbnRFbWl0dGVyLmRlc3Ryb3koKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgVFRMIG1hbmFnZXJcbiAgICAgIGlmICh0dGxNYW5hZ2VyICYmIHR5cGVvZiB0dGxNYW5hZ2VyLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHRsTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFuIHVwIGV2aWN0aW9uIG1hbmFnZXIgKEV2aWN0aW9uTWFuYWdlciBkb2Vzbid0IG5lZWQgZXhwbGljaXQgY2xlYW51cClcbiAgICAgIC8vIGV2aWN0aW9uTWFuYWdlciBpcyBzdGF0ZWxlc3MgYW5kIGRvZXNuJ3QgcmVxdWlyZSBkZXN0cnVjdGlvblxuXG4gICAgICAvLyBDbGVhbiB1cCBjYWNoZSBtYXAgaWYgaXQgaGFzIGEgZGVzdHJveSBtZXRob2RcbiAgICAgIGlmIChjYWNoZU1hcCAmJiB0eXBlb2YgKGNhY2hlTWFwIGFzIGFueSkuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAoY2FjaGVNYXAgYXMgYW55KS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGlmeSBDYWNoZUV2ZW50RmFjdG9yeSB0aGF0IGFuIGluc3RhbmNlIGlzIGJlaW5nIGRlc3Ryb3llZFxuICAgICAgQ2FjaGVFdmVudEZhY3RvcnkuZGVzdHJveUluc3RhbmNlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjYWNoZTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0NhY2hlID0gKGNhY2hlOiBhbnkpOiBjYWNoZSBpcyBDYWNoZTxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+ID0+IHtcbiAgcmV0dXJuIGNhY2hlICE9PSBudWxsICYmXG4gICAgdHlwZW9mIGNhY2hlID09PSAnb2JqZWN0JyAmJlxuICAgICdjb29yZGluYXRlJyBpbiBjYWNoZSAmJlxuICAgICdyZWdpc3RyeScgaW4gY2FjaGUgJiZcbiAgICAnYXBpJyBpbiBjYWNoZSAmJlxuICAgICdjYWNoZU1hcCcgaW4gY2FjaGUgJiZcbiAgICAnb3BlcmF0aW9ucycgaW4gY2FjaGU7XG59O1xuIiwiaW1wb3J0IHsgSXRlbSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpIH0gZnJvbSBcIkBmamVsbC9jbGllbnQtYXBpXCI7XG5pbXBvcnQgeyBJbnN0YW5jZUZhY3RvcnkgYXMgQmFzZUluc3RhbmNlRmFjdG9yeSwgUmVnaXN0cnksIFJlZ2lzdHJ5SHViIH0gZnJvbSBcIkBmamVsbC9yZWdpc3RyeVwiO1xuaW1wb3J0IHsgSW5zdGFuY2UgfSBmcm9tIFwiLi9JbnN0YW5jZVwiO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCJAZmplbGwvcmVnaXN0cnlcIjtcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdGlvbnMgfSBmcm9tIFwiLi9PcGVyYXRpb25zXCI7XG5pbXBvcnQgeyBjcmVhdGVDYWNoZU1hcCwgY3JlYXRlT3B0aW9ucywgT3B0aW9ucywgdmFsaWRhdGVPcHRpb25zIH0gZnJvbSBcIi4vT3B0aW9uc1wiO1xuaW1wb3J0IHsgVFRMTWFuYWdlciB9IGZyb20gXCIuL3R0bC9UVExNYW5hZ2VyXCI7XG5pbXBvcnQgeyBFdmljdGlvbk1hbmFnZXIgfSBmcm9tIFwiLi9ldmljdGlvbi9FdmljdGlvbk1hbmFnZXJcIjtcbmltcG9ydCB7IENhY2hlRXZlbnRFbWl0dGVyIH0gZnJvbSBcIi4vZXZlbnRzL0NhY2hlRXZlbnRFbWl0dGVyXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuaW1wb3J0IHsgQ2FjaGVTdGF0c01hbmFnZXIgfSBmcm9tIFwiLi9DYWNoZVN0YXRzXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJJbnN0YW5jZUZhY3RvcnlcIik7XG5cbmV4cG9ydCB0eXBlIEluc3RhbmNlRmFjdG9yeTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9IChcbiAgYXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgb3B0aW9ucz86IFBhcnRpYWw8T3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PlxuKSA9PiBCYXNlSW5zdGFuY2VGYWN0b3J5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2FjaGUgaW5zdGFuY2VzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnN0YW5jZUZhY3RvcnkgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgYXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+XG4gICk6IEJhc2VJbnN0YW5jZUZhY3Rvcnk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG5cbiAgLy8gQ3JlYXRlIGFuZCB2YWxpZGF0ZSBhIHRlbXBsYXRlIG9mIG9wdGlvbnMgLSB0aGlzIHZhbGlkYXRlcyB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICBjb25zdCB0ZW1wbGF0ZU9wdGlvbnMgPSBjcmVhdGVPcHRpb25zKG9wdGlvbnMpO1xuICB2YWxpZGF0ZU9wdGlvbnModGVtcGxhdGVPcHRpb25zKTtcblxuICByZXR1cm4gKGNvb3JkaW5hdGU6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1PiwgY29udGV4dDogeyByZWdpc3RyeTogUmVnaXN0cnksIHJlZ2lzdHJ5SHViPzogUmVnaXN0cnlIdWIgfSkgPT4ge1xuICAgIC8vIENyZWF0ZSBmcmVzaCBvcHRpb25zIGZvciBlYWNoIGluc3RhbmNlIHRvIGVuc3VyZSBpbW11dGFiaWxpdHlcbiAgICBjb25zdCBpbnN0YW5jZU9wdGlvbnMgPSBjcmVhdGVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgbG9nZ2VyLmRlYnVnKFwiQ3JlYXRpbmcgY2FjaGUgaW5zdGFuY2VcIiwge1xuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHJlZ2lzdHJ5OiBjb250ZXh0LnJlZ2lzdHJ5LFxuICAgICAgYXBpLFxuICAgICAgY2FjaGVUeXBlOiBpbnN0YW5jZU9wdGlvbnMuY2FjaGVUeXBlLFxuICAgICAgb3B0aW9uczogaW5zdGFuY2VPcHRpb25zXG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGFwcHJvcHJpYXRlIGNhY2hlIG1hcCBiYXNlZCBvbiBvcHRpb25zXG4gICAgY29uc3QgY2FjaGVNYXAgPSBjcmVhdGVDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KGNvb3JkaW5hdGUua3RhLCBpbnN0YW5jZU9wdGlvbnMpO1xuICAgIGNvbnN0IHBrVHlwZSA9IGNvb3JkaW5hdGUua3RhWzBdIGFzIFM7XG5cbiAgICAvLyBDcmVhdGUgcHJvcGVyIG1hbmFnZXJzIGluc3RlYWQgb2YgbW9ja3NcbiAgICBjb25zdCBldmVudEVtaXR0ZXIgPSBuZXcgQ2FjaGVFdmVudEVtaXR0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PigpO1xuICAgIGNvbnN0IHR0bE1hbmFnZXIgPSBuZXcgVFRMTWFuYWdlcih7XG4gICAgICBkZWZhdWx0VFRMOiBpbnN0YW5jZU9wdGlvbnMudHRsLFxuICAgICAgYXV0b0NsZWFudXA6IHRydWUsXG4gICAgICB2YWxpZGF0ZU9uQWNjZXNzOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgZXZpY3Rpb25NYW5hZ2VyID0gbmV3IEV2aWN0aW9uTWFuYWdlcigpO1xuICAgIGNvbnN0IHN0YXRzTWFuYWdlciA9IG5ldyBDYWNoZVN0YXRzTWFuYWdlcigpO1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVPcGVyYXRpb25zKFxuICAgICAgYXBpLCBjb29yZGluYXRlLCBjYWNoZU1hcCwgcGtUeXBlLCBpbnN0YW5jZU9wdGlvbnMsIGV2ZW50RW1pdHRlciwgdHRsTWFuYWdlciwgZXZpY3Rpb25NYW5hZ2VyLCBzdGF0c01hbmFnZXIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvb3JkaW5hdGUsXG4gICAgICByZWdpc3RyeTogY29udGV4dC5yZWdpc3RyeSxcbiAgICAgIGFwaSxcbiAgICAgIGNhY2hlTWFwLFxuICAgICAgb3BlcmF0aW9ucyxcbiAgICAgIG9wdGlvbnM6IGluc3RhbmNlT3B0aW9ucyxcbiAgICAgIGV2ZW50RW1pdHRlcixcbiAgICAgIHR0bE1hbmFnZXIsXG4gICAgICBldmljdGlvbk1hbmFnZXIsXG4gICAgICBnZXRDYWNoZUluZm86ICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZpY3Rpb25TdHJhdGVneU5hbWUgPSBldmljdGlvbk1hbmFnZXIuZ2V0RXZpY3Rpb25TdHJhdGVneU5hbWUoKTtcbiAgICAgICAgY29uc3QgY2FjaGVJbmZvID0ge1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVHlwZTogY2FjaGVNYXAuaW1wbGVtZW50YXRpb25UeXBlLFxuICAgICAgICAgIGRlZmF1bHRUVEw6IHR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpLFxuICAgICAgICAgIHN1cHBvcnRzVFRMOiAoY2FjaGVNYXAgYXMgYW55KS5zdXBwb3J0c1RUTD8uKCkgfHwgISF0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSxcbiAgICAgICAgICBzdXBwb3J0c0V2aWN0aW9uOiBldmljdGlvbk1hbmFnZXIuaXNFdmljdGlvblN1cHBvcnRlZCgpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmljdGlvblN0cmF0ZWd5TmFtZSkge1xuICAgICAgICAgIChjYWNoZUluZm8gYXMgYW55KS5ldmljdGlvblBvbGljeSA9IGV2aWN0aW9uU3RyYXRlZ3lOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZUluZm87XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiAobGlzdGVuZXIsIG9wdGlvbnMpID0+IGV2ZW50RW1pdHRlci5zdWJzY3JpYmUobGlzdGVuZXIsIG9wdGlvbnMpLFxuICAgICAgdW5zdWJzY3JpYmU6IChzdWJzY3JpcHRpb24pID0+IGV2ZW50RW1pdHRlci51bnN1YnNjcmliZShzdWJzY3JpcHRpb24uaWQpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHR0bE1hbmFnZXIuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHR0bE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50RW1pdHRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSBhcyBJbnN0YW5jZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICB9O1xufTtcbiIsIlxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCB7IEl0ZW0gfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENvb3JkaW5hdGUsIFJlZ2lzdHJ5IH0gZnJvbSBcIkBmamVsbC9yZWdpc3RyeVwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpIH0gZnJvbSBcIkBmamVsbC9jbGllbnQtYXBpXCI7XG5pbXBvcnQgeyBDYWNoZSwgY3JlYXRlQ2FjaGUgfSBmcm9tIFwiLi9DYWNoZVwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiSW5zdGFuY2VcIik7XG5cbi8qKlxuICogVGhlIENhY2hlIEluc3RhbmNlIGludGVyZmFjZSByZXByZXNlbnRzIGEgY2FjaGUgbW9kZWwgaW5zdGFuY2UgdGhhdCBleHRlbmRzIHRoZSBiYXNlIEluc3RhbmNlXG4gKiBmcm9tIEBmamVsbC9yZWdpc3RyeSBhbmQgYWRkcyBjYWNoZSBvcGVyYXRpb25zIGZvciBpbnRlcmFjdGluZyB3aXRoIGNhY2hlZCBkYXRhLlxuICpcbiAqIFRoaXMgaXMgYSB0eXBlIGFsaWFzIGZvciB0aGUgQ2FjaGUgaW50ZXJmYWNlLiBCb3RoIENhY2hlIGFuZCBJbnN0YW5jZSByZWZlciB0byB0aGUgc2FtZVxuICogY2FjaGUgaW50ZXJmYWNlIC0gSW5zdGFuY2UgZXhpc3RzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFuZCBjb25zaXN0ZW5jeSB3aXRoIG90aGVyXG4gKiBGamVsbCBwYWNrYWdlcyB0aGF0IGV4cG9ydCBJbnN0YW5jZSB0eXBlcy5cbiAqXG4gKiBAdGVtcGxhdGUgViAtIFRoZSB0eXBlIG9mIHRoZSBkYXRhIG1vZGVsIGl0ZW0sIGV4dGVuZGluZyBJdGVtXG4gKiBAdGVtcGxhdGUgUyAtIFRoZSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHJlcHJlc2VudGluZyB0aGUgbW9kZWwncyBrZXkgdHlwZVxuICogQHRlbXBsYXRlIEwxLUw1IC0gT3B0aW9uYWwgc3RyaW5nIGxpdGVyYWwgdHlwZXMgZm9yIGxvY2F0aW9uIGhpZXJhcmNoeSBsZXZlbHNcbiAqL1xuZXhwb3J0IHR5cGUgSW5zdGFuY2U8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gPSBDYWNoZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW5zdGFuY2UgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgcmVnaXN0cnk6IFJlZ2lzdHJ5LFxuICAgIGNvb3JkaW5hdGU6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBhcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIG9wdGlvbnM/OiBQYXJ0aWFsPGltcG9ydCgnLi9PcHRpb25zJykuT3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PlxuICApOiBJbnN0YW5jZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgbG9nZ2VyLmRlYnVnKFwiY3JlYXRlSW5zdGFuY2VcIiwgeyBjb29yZGluYXRlLCBhcGksIHJlZ2lzdHJ5LCBvcHRpb25zIH0pO1xuICByZXR1cm4gY3JlYXRlQ2FjaGUoYXBpLCBjb29yZGluYXRlLCByZWdpc3RyeSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0luc3RhbmNlID0gKGluc3RhbmNlOiBhbnkpOiBpbnN0YW5jZSBpcyBJbnN0YW5jZTxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+ID0+IHtcbiAgcmV0dXJuIGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgdHlwZW9mIGluc3RhbmNlID09PSAnb2JqZWN0JyAmJlxuICAgICdjb29yZGluYXRlJyBpbiBpbnN0YW5jZSAmJlxuICAgICdyZWdpc3RyeScgaW4gaW5zdGFuY2UgJiZcbiAgICAnYXBpJyBpbiBpbnN0YW5jZSAmJlxuICAgICdjYWNoZU1hcCcgaW4gaW5zdGFuY2UgJiZcbiAgICAnb3BlcmF0aW9ucycgaW4gaW5zdGFuY2U7XG59XG4iLCJcbmltcG9ydCB7XG4gIENvbUtleSxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tIFwiLi9DYWNoZVwiO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tIFwiLi9DYWNoZU1hcFwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi9ldmVudHMvQ2FjaGVFdmVudEVtaXR0ZXJcIjtcbmltcG9ydCB7IENhY2hlRXZlbnRMaXN0ZW5lciwgQ2FjaGVTdWJzY3JpcHRpb24sIENhY2hlU3Vic2NyaXB0aW9uT3B0aW9ucyB9IGZyb20gXCIuL2V2ZW50cy9DYWNoZUV2ZW50VHlwZXNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ0l0ZW1BZ2dyZWdhdG9yJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWdncmVnYXRvcjxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiBleHRlbmRzIENhY2hlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAvLyBDYWNoZSBvcGVyYXRpb25zIGV4cG9zZWQgZGlyZWN0bHkgZm9yIGFnZ3JlZ2F0b3JcbiAgYWxsOiAoXG4gICAgcXVlcnk/OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICkgPT4gUHJvbWlzZTxWW10+O1xuXG4gIG9uZTogKFxuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8ViB8IG51bGw+O1xuXG4gIGFjdGlvbjogKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueVxuICApID0+IFByb21pc2U8Vj47XG5cbiAgYWxsQWN0aW9uOiAoXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFZbXT47XG5cbiAgYWxsRmFjZXQ6IChcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPGFueT47XG5cbiAgY3JlYXRlOiAoXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8Vj47XG5cbiAgZ2V0OiAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPlxuICApID0+IFByb21pc2U8ViB8IG51bGw+O1xuXG4gIHJldHJpZXZlOiAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPlxuICApID0+IFByb21pc2U8ViB8IG51bGw+O1xuXG4gIHJlbW92ZTogKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz5cbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIHVwZGF0ZTogKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+XG4gICkgPT4gUHJvbWlzZTxWPjtcblxuICBmYWNldDogKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj5cbiAgKSA9PiBQcm9taXNlPGFueT47XG5cbiAgZmluZDogKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFZbXT47XG5cbiAgZmluZE9uZTogKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFY+O1xuXG4gIHNldDogKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICkgPT4gUHJvbWlzZTxWPjtcblxuICByZXNldDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBwb3B1bGF0ZTogKGl0ZW06IFYpID0+IFByb21pc2U8Vj47XG4gIHBvcHVsYXRlQWdncmVnYXRlOiAoa2V5OiBzdHJpbmcsIGl0ZW06IFYpID0+IFByb21pc2U8dm9pZD47XG4gIHBvcHVsYXRlRXZlbnQ6IChrZXk6IHN0cmluZywgaXRlbTogVikgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKiogRXZlbnQgZW1pdHRlciBmb3IgY2FjaGUgZXZlbnRzICovXG4gIGV2ZW50RW1pdHRlcjogQ2FjaGVFdmVudEVtaXR0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGNhY2hlIGV2ZW50c1xuICAgKi9cbiAgc3Vic2NyaWJlKFxuICAgIGxpc3RlbmVyOiBDYWNoZUV2ZW50TGlzdGVuZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBvcHRpb25zPzogQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogQ2FjaGVTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gY2FjaGUgZXZlbnRzXG4gICAqL1xuICB1bnN1YnNjcmliZShzdWJzY3JpcHRpb246IENhY2hlU3Vic2NyaXB0aW9uKTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZUNvbmZpZyB7IGNhY2hlOiBhbnksIG9wdGlvbmFsOiBib29sZWFuIH1cblxuZXhwb3J0IGludGVyZmFjZSBBZ2dyZWdhdGVDb25maWcgeyBba2V5OiBzdHJpbmddOiAoQ2FjaGVDb25maWcpIH1cblxuZXhwb3J0IGNvbnN0IHRvQ2FjaGVDb25maWcgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oY29uZmlnOiBDYWNoZUNvbmZpZyB8IENhY2hlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pOiBDYWNoZUNvbmZpZyA9PiB7XG4gIGxldCBjYWNoZUNvbmZpZzogQ2FjaGVDb25maWc7XG4gIGlmICgoY29uZmlnIGFzIENhY2hlQ29uZmlnKS5vcHRpb25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGVDb25maWcgPSB7IGNhY2hlOiBjb25maWcgYXMgYW55LCBvcHRpb25hbDogZmFsc2UgfTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZUNvbmZpZyA9IGNvbmZpZyBhcyBDYWNoZUNvbmZpZztcbiAgfVxuICByZXR1cm4gY2FjaGVDb25maWc7XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVBZ2dyZWdhdG9yID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBjYWNoZTogQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgeyBhZ2dyZWdhdGVzID0ge30sIGV2ZW50cyA9IHt9IH06XG4gICAge1xuICAgICAgYWdncmVnYXRlcz86IEFnZ3JlZ2F0ZUNvbmZpZyxcbiAgICAgIGV2ZW50cz86IEFnZ3JlZ2F0ZUNvbmZpZ1xuICAgIH1cbik6IFByb21pc2U8QWdncmVnYXRvcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PiA9PiB7XG5cbiAgY29uc3QgcG9wdWxhdGUgPSBhc3luYyAoaXRlbTogVik6IFByb21pc2U8Vj4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdwb3B1bGF0ZScsIHsgaXRlbSB9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhZ2dyZWdhdGVzKSB7XG4gICAgICBhd2FpdCBwb3B1bGF0ZUFnZ3JlZ2F0ZShrZXksIGl0ZW0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudHMpIHtcbiAgICAgIGF3YWl0IHBvcHVsYXRlRXZlbnQoa2V5LCBpdGVtKTtcbiAgICB9XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3BvcHVsYXRlIGRvbmUnLCB7IGl0ZW0gfSk7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICBjb25zdCBwb3B1bGF0ZUFnZ3JlZ2F0ZSA9IGFzeW5jIChrZXk6IHN0cmluZywgaXRlbTogVikgPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdwb3B1bGF0ZSBhZ2dyZWdhdGUga2V5JywgeyBrZXkgfSk7XG4gICAgY29uc3QgY2FjaGVDb25maWcgPSB0b0NhY2hlQ29uZmlnKGFnZ3JlZ2F0ZXNba2V5XSk7XG4gICAgaWYgKGl0ZW0ucmVmcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY2FjaGVDb25maWcub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignSXRlbSBkb2VzIG5vdCBoYXZlIHJlZnMgYW4gaXMgbm90IG9wdGlvbmFsICcsIHsgaXRlbSB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIGRvZXMgbm90IGhhdmUgcmVmcyBhbiBpcyBub3Qgb3B0aW9uYWwgJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtLmV2ZW50cyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlbS5ldmVudHMsIGtleSkpIHtcbiAgICAgICAgICBkZWxldGUgaXRlbS5ldmVudHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbS5yZWZzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNhY2hlQ29uZmlnLm9wdGlvbmFsID09PSBmYWxzZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0l0ZW0gZG9lcyBub3QgaGF2ZSBtYW5kYXRvcnkgcmVmIHdpdGgga2V5LCBub3Qgb3B0aW9uYWwgJywgeyBrZXksIGl0ZW0gfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSXRlbSBkb2VzIG5vdCBoYXZlIG1hbmRhdG9yeSByZWYgd2l0aCBrZXksIG5vdCBvcHRpb25hbCAnICtcbiAgICAgICAgICBrZXkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbS5ldmVudHMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZW0uZXZlbnRzLCBrZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIGl0ZW0uZXZlbnRzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjb25zdCByZWYgPSBpdGVtLnJlZnNba2V5XTtcblxuICAgICAgbG9nZ2VyLmRlZmF1bHQoJ0FHRyBSZXRyaWV2aW5nIEl0ZW0gaW4gUG9wdWxhdGUnLCB7IGtleTogcmVmIH0pO1xuICAgICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNhY2hlQ29uZmlnLmNhY2hlLm9wZXJhdGlvbnMucmV0cmlldmUocmVmKTtcbiAgICAgIGlmIChuZXdJdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLmFnZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGl0ZW0uYWdncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0uYWdnc1trZXldID0ge1xuICAgICAgICAgIGtleTogcmVmLFxuICAgICAgICAgIGl0ZW06IG5ld0l0ZW0gYXMgSXRlbSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBJJ20gbm90IGEgYmlnIGZhbiB0aGF0IHRoaXMganVzdCBcImF1dG9tYXRpY2FsbHlcIiBhc3N1bWVzIHRoYXQgdGhlIFwiYnlcIiBrZXkgaW4gZXZlbnQgaXMgYSByZWYuXG4gIGNvbnN0IHBvcHVsYXRlRXZlbnQgPSBhc3luYyAoa2V5OiBzdHJpbmcsIGl0ZW06IFYpID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgncG9wdWxhdGUgZXZlbnQga2V5JywgeyBrZXkgfSk7XG4gICAgY29uc3QgY2FjaGVDb25maWcgPSB0b0NhY2hlQ29uZmlnKGV2ZW50c1trZXldKTtcblxuICAgIGlmIChpdGVtLmV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gZG9lcyBub3QgaGF2ZSBldmVudHMgJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uZXZlbnRzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNhY2hlQ29uZmlnLm9wdGlvbmFsID09PSBmYWxzZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0l0ZW0gZG9lcyBub3QgaGF2ZSBtYW5kYXRvcnkgZXZlbnQgd2l0aCBrZXknLCB7IGtleSwgaXRlbSB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIGRvZXMgbm90IGhhdmUgbWFuZGF0b3J5IGV2ZW50IHdpdGgga2V5ICcgKyBrZXkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gaXRlbS5ldmVudHNba2V5XTtcblxuICAgICAgaWYgKGV2ZW50LmJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICdwb3B1bGF0ZUV2ZW50IHdpdGggYW4gRXZlbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGJ5JywgeyBldmVudCwgaWs6IGl0ZW0ua2V5LCBldmVudEtleToga2V5IH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcHVsYXRlRXZlbnQgd2l0aCBhbiBFdmVudCB0aGF0IGRvZXMgbm90IGhhdmUgYnk6ICcgKyBKU09OLnN0cmluZ2lmeSh7IGtleSB9KSk7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5kZWZhdWx0KCdFVkVOVCBSZXRyaWV2aW5nIEl0ZW0gaW4gUG9wdWxhdGUnLCB7IGtleTogZXZlbnQuYnkgfSk7XG4gICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgY2FjaGVDb25maWcuY2FjaGUub3BlcmF0aW9ucy5yZXRyaWV2ZShldmVudC5ieSk7XG4gICAgICBpZiAobmV3SXRlbSkge1xuICAgICAgICBldmVudC5hZ2cgPSBuZXdJdGVtIGFzIEl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWxsID0gYXN5bmMgKFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6XG4gICAgUHJvbWlzZTxWW10+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnYWxsJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5hbGwocXVlcnksIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW0pID0+IHBvcHVsYXRlKGl0ZW0pKSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW1zO1xuICB9XG5cbiAgY29uc3Qgb25lID0gYXN5bmMgKFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6XG4gICAgUHJvbWlzZTxWIHwgbnVsbD4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdvbmUnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMub25lKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIGxldCBwb3B1bGF0ZWRJdGVtID0gbnVsbDtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfVxuXG4gIGNvbnN0IGFjdGlvbiA9IGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnYWN0aW9uJywgeyBrZXksIGFjdGlvbiwgYm9keSB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5hY3Rpb24oa2V5LCBhY3Rpb24sIGJvZHkpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfVxuXG4gIGNvbnN0IGFsbEFjdGlvbiA9IGFzeW5jIChcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5OiBhbnkgPSB7fSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2FjdGlvbicsIHsgYWN0aW9uLCBib2R5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmFsbEFjdGlvbihhY3Rpb24sIGJvZHksIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW06IFYpID0+IHBvcHVsYXRlKGl0ZW0pKSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW1zO1xuICB9XG5cbiAgY29uc3QgYWxsRmFjZXQgPSBhc3luYyAoXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnYWxsRmFjZXQnLCB7IGZhY2V0LCBwYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWxsRmFjZXQoZmFjZXQsIHBhcmFtcywgbG9jYXRpb25zKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBjb25zdCBjcmVhdGUgPSBhc3luYyAoXG4gICAgdjogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2NyZWF0ZScsIHsgdiwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmNyZWF0ZSh2LCBsb2NhdGlvbnMpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfVxuXG4gIGNvbnN0IGdldCA9IGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApOiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2dldCcsIHsga2V5IH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmdldChrZXkpO1xuICAgIGxldCBwb3B1bGF0ZWRJdGVtID0gbnVsbDtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfVxuXG4gIGNvbnN0IHJldHJpZXZlID0gYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICk6IFByb21pc2U8ViB8IG51bGw+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgncmV0cmlldmUnLCB7IGtleSB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5yZXRyaWV2ZShrZXkpO1xuICAgIGxldCBwb3B1bGF0ZWRJdGVtID0gbnVsbDtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfVxuXG4gIGNvbnN0IHJlbW92ZSA9IGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgncmVtb3ZlJywgeyBrZXkgfSk7XG4gICAgYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5yZW1vdmUoa2V5KTtcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZSA9IGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIHY6IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PixcbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3VwZGF0ZScsIHsga2V5LCB2IH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnVwZGF0ZShrZXksIHYpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfVxuXG4gIC8vIEZhY2V0cyBhcmUgYSBwYXNzLXRocnUgZm9yIGFnZ3JlZ2F0b3JzXG4gIGNvbnN0IGZhY2V0ID0gYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZmFjZXQnLCB7IGtleSwgZmFjZXQgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmZhY2V0KGtleSwgZmFjZXQpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGNvbnN0IGZpbmQgPSBhc3luYyAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2ZpbmQnLCB7IGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmZpbmQoZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW06IFYpID0+IHBvcHVsYXRlKGl0ZW0pKSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW1zO1xuICB9XG5cbiAgY29uc3QgZmluZE9uZSA9IGFzeW5jIChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2ZpbmQnLCB7IGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZmluZE9uZShmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zKTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH1cblxuICBjb25zdCBzZXQgPSBhc3luYyAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICB2OiBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3NldCcsIHsga2V5LCB2IH0pO1xuXG4gICAgLy8gVE9ETzogVGhlcmUgc2hvdWxkIGJlIHNvbWUgaW5wdXQgdmFsaWRhdGlvbiBoZXJlIHRvIGVuc3VyZSBhIHZhbGlkIGl0ZW0uXG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuc2V0KGtleSwgdik7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9XG5cbiAgY29uc3QgcmVzZXQgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5yZXNldCgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBDYWNoZSBwcm9wZXJ0aWVzXG4gICAgY29vcmRpbmF0ZTogY2FjaGUuY29vcmRpbmF0ZSxcbiAgICByZWdpc3RyeTogY2FjaGUucmVnaXN0cnksXG4gICAgYXBpOiBjYWNoZS5hcGksXG4gICAgY2FjaGVNYXA6IGNhY2hlLmNhY2hlTWFwLFxuICAgIG9wZXJhdGlvbnM6IGNhY2hlLm9wZXJhdGlvbnMsXG4gICAgZXZpY3Rpb25NYW5hZ2VyOiBjYWNoZS5ldmljdGlvbk1hbmFnZXIsXG4gICAgdHRsTWFuYWdlcjogY2FjaGUudHRsTWFuYWdlcixcbiAgICBzdGF0c01hbmFnZXI6IGNhY2hlLnN0YXRzTWFuYWdlcixcbiAgICBnZXRTdGF0czogY2FjaGUuZ2V0U3RhdHMuYmluZChjYWNoZSksXG4gICAgZ2V0Q2FjaGVJbmZvOiBjYWNoZS5nZXRDYWNoZUluZm8uYmluZChjYWNoZSksXG4gICAgLy8gQ2FjaGUgb3BlcmF0aW9ucyBleHBvc2VkIGRpcmVjdGx5XG4gICAgYWxsLFxuICAgIG9uZSxcbiAgICBhY3Rpb24sXG4gICAgYWxsQWN0aW9uLFxuICAgIGFsbEZhY2V0LFxuICAgIGNyZWF0ZSxcbiAgICBnZXQsXG4gICAgcmV0cmlldmUsXG4gICAgcmVtb3ZlLFxuICAgIHVwZGF0ZSxcbiAgICBmYWNldCxcbiAgICBmaW5kLFxuICAgIGZpbmRPbmUsXG4gICAgcmVzZXQsXG4gICAgc2V0LFxuICAgIC8vIEFnZ3JlZ2F0b3Itc3BlY2lmaWMgb3BlcmF0aW9uc1xuICAgIHBvcHVsYXRlLFxuICAgIHBvcHVsYXRlQWdncmVnYXRlLFxuICAgIHBvcHVsYXRlRXZlbnQsXG4gICAgLy8gRXZlbnQgc3lzdGVtXG4gICAgZXZlbnRFbWl0dGVyOiBjYWNoZS5ldmVudEVtaXR0ZXIsXG4gICAgc3Vic2NyaWJlOiAobGlzdGVuZXIsIG9wdGlvbnMpID0+IGNhY2hlLnN1YnNjcmliZShsaXN0ZW5lciwgb3B0aW9ucyksXG4gICAgdW5zdWJzY3JpYmU6IChzdWJzY3JpcHRpb24pID0+IGNhY2hlLnVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbiksXG4gICAgZGVzdHJveTogKCkgPT4gY2FjaGUuZGVzdHJveSgpXG4gIH1cbn1cbiIsImltcG9ydCBMaWJMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHtcbiAgUmVnaXN0cnkgYXMgQmFzZVJlZ2lzdHJ5LFxuICBjcmVhdGVSZWdpc3RyeSBhcyBjcmVhdGVCYXNlUmVnaXN0cnksXG4gIFJlZ2lzdHJ5RmFjdG9yeSxcbiAgUmVnaXN0cnlIdWJcbn0gZnJvbSAnQGZqZWxsL3JlZ2lzdHJ5JztcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIlJlZ2lzdHJ5XCIpO1xuXG4vKipcbiAqIEV4dGVuZGVkIFJlZ2lzdHJ5IGludGVyZmFjZSBmb3IgY2FjaGUtc3BlY2lmaWMgZnVuY3Rpb25hbGl0eVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZ2lzdHJ5IGV4dGVuZHMgQmFzZVJlZ2lzdHJ5IHtcbiAgdHlwZTogJ2NhY2hlJztcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBjYWNoZSByZWdpc3RyaWVzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWdpc3RyeUZhY3RvcnkgPSAoKTogUmVnaXN0cnlGYWN0b3J5ID0+IHtcbiAgcmV0dXJuICh0eXBlOiBzdHJpbmcsIHJlZ2lzdHJ5SHViPzogUmVnaXN0cnlIdWIpOiBCYXNlUmVnaXN0cnkgPT4ge1xuICAgIGlmICh0eXBlICE9PSAnY2FjaGUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhY2hlIHJlZ2lzdHJ5IGZhY3RvcnkgY2FuIG9ubHkgY3JlYXRlICdjYWNoZScgdHlwZSByZWdpc3RyaWVzLCBnb3Q6ICR7dHlwZX1gKTtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoXCJDcmVhdGluZyBjYWNoZSByZWdpc3RyeVwiLCB7IHR5cGUsIHJlZ2lzdHJ5SHViIH0pO1xuXG4gICAgY29uc3QgYmFzZVJlZ2lzdHJ5ID0gY3JlYXRlQmFzZVJlZ2lzdHJ5KHR5cGUsIHJlZ2lzdHJ5SHViKTtcblxuICAgIC8vIENhc3QgdG8gUmVnaXN0cnkgZm9yIHR5cGUgc2FmZXR5XG4gICAgcmV0dXJuIGJhc2VSZWdpc3RyeSBhcyBSZWdpc3RyeTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjYWNoZSByZWdpc3RyeSBpbnN0YW5jZVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVnaXN0cnkgPSAocmVnaXN0cnlIdWI/OiBSZWdpc3RyeUh1Yik6IFJlZ2lzdHJ5ID0+IHtcbiAgY29uc3QgYmFzZVJlZ2lzdHJ5ID0gY3JlYXRlQmFzZVJlZ2lzdHJ5KCdjYWNoZScsIHJlZ2lzdHJ5SHViKTtcblxuICByZXR1cm4ge1xuICAgIC4uLmJhc2VSZWdpc3RyeSxcbiAgfSBhcyBSZWdpc3RyeTtcbn07XG4iXSwibmFtZXMiOlsidmFsaWRhdGVQSyIsIk5vdEZvdW5kRXJyb3IiLCJsb2dnZXIiLCJrZXlTdHIiLCJpc1ZhbGlkSXRlbUtleSIsImFjdGlvbiIsImZhY2V0Iiwibm9ybWFsaXplS2V5VmFsdWUiLCJpc0NvbUtleSIsImlzUXVlcnlNYXRjaCIsIkNvbUtleSIsInNhZmVTdHJpbmdpZnkiLCJvcHRpb25zIiwiYWxsIiwib25lIiwiYWxsQWN0aW9uIiwiYWxsRmFjZXQiLCJjcmVhdGUiLCJnZXQiLCJyZXRyaWV2ZSIsInJlbW92ZSIsInVwZGF0ZSIsImZpbmQiLCJmaW5kT25lIiwic2V0IiwicmVzZXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../fjell-cache/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-client-api/dist/index.js":
/*!*****************************************!*\
  !*** ../fjell-client-api/dist/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   AuthorizationError: () => (/* binding */ AuthorizationError),\n/* harmony export */   ClientApiError: () => (/* binding */ ClientApiError),\n/* harmony export */   ConfigurationError: () => (/* binding */ ConfigurationError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   HttpWrapper: () => (/* binding */ HttpWrapper),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   ParseError: () => (/* binding */ ParseError),\n/* harmony export */   PayloadTooLargeError: () => (/* binding */ PayloadTooLargeError),\n/* harmony export */   RateLimitError: () => (/* binding */ RateLimitError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   calculateRetryDelay: () => (/* binding */ calculateRetryDelay),\n/* harmony export */   createCItemApi: () => (/* binding */ createCItemApi),\n/* harmony export */   createHttpError: () => (/* binding */ createHttpError),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createInstanceFactory: () => (/* binding */ createInstanceFactory),\n/* harmony export */   createNetworkError: () => (/* binding */ createNetworkError),\n/* harmony export */   createPItemApi: () => (/* binding */ createPItemApi),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryFactory: () => (/* binding */ createRegistryFactory),\n/* harmony export */   enhanceError: () => (/* binding */ enhanceError),\n/* harmony export */   executeErrorHandler: () => (/* binding */ executeErrorHandler),\n/* harmony export */   executeWithRetry: () => (/* binding */ executeWithRetry),\n/* harmony export */   getRetryConfig: () => (/* binding */ getRetryConfig),\n/* harmony export */   isClientApiError: () => (/* binding */ isClientApiError),\n/* harmony export */   isRetryableError: () => (/* binding */ isRetryableError),\n/* harmony export */   shouldRetryError: () => (/* binding */ shouldRetryError)\n/* harmony export */ });\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/core */ \"(ssr)/../fjell-client-api/node_modules/@fjell/core/dist/index.js\");\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../fjell-client-api/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fjell/registry */ \"(ssr)/../fjell-client-api/node_modules/@fjell/registry/dist/index.js\");\n// src/ops/all.ts\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLogger(\"@fjell/client-api\");\nvar logger_default = LibLogger;\n// src/ops/all.ts\nvar logger = logger_default.get(\"client-api\", \"ops\", \"all\");\nvar getAllOperation = (api, apiOptions, utilities)=>{\n    const all = async (query = {}, locations = [])=>{\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const params = (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.queryToParams)(query);\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.allAuthenticated,\n            params\n        });\n        logger.default(\"all\", {\n            query,\n            locations,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)));\n    };\n    return all;\n};\n// src/ops/action.ts\nvar logger2 = logger_default.get(\"client-api\", \"ops\", \"action\");\nvar getActionOperation = (api, apiOptions, utilities)=>{\n    const action = async (ik, action2, body = {})=>{\n        const requestOptions = Object.assign({}, apiOptions.postOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger2.default(\"action\", {\n            ik,\n            action: action2,\n            body,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processOne(api.httpPost(`${utilities.getPath(ik)}/${action2}`, body, requestOptions)));\n    };\n    return action;\n};\n// src/ops/allAction.ts\nvar logger3 = logger_default.get(\"client-api\", \"ops\", \"allAction\");\nvar getAllActionOperation = (api, apiOptions, utilities)=>{\n    const allAction = async (action, body = {}, locations = [])=>{\n        const requestOptions = Object.assign({}, apiOptions.postOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger3.default(\"allAction\", {\n            action,\n            body,\n            locations,\n            requestOptions\n        });\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        return utilities.validatePK(await utilities.processArray(api.httpPost(`${utilities.getPath(loc)}/${action}`, body, requestOptions)));\n    };\n    return allAction;\n};\n// src/ops/one.ts\n\nvar logger4 = logger_default.get(\"client-api\", \"ops\", \"one\");\nvar getOneOperation = (api, apiOptions, utilities)=>{\n    const one = async (query = {}, locations = [])=>{\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const params = (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.queryToParams)(query);\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.readAuthenticated,\n            params\n        });\n        logger4.default(\"one\", {\n            query,\n            locations,\n            requestOptions\n        });\n        let item = null;\n        const items = utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)));\n        if (items.length > 0) {\n            item = items[0];\n        }\n        return item;\n    };\n    return one;\n};\n// src/ops/errorHandling.ts\nfunction shouldRetryError(error) {\n    if (error.code === \"ECONNREFUSED\" || error.code === \"ENOTFOUND\" || error.code === \"ENETUNREACH\" || error.message?.includes(\"timeout\") || error.message?.includes(\"network\")) {\n        return true;\n    }\n    if (error.status >= 500 || error.status === 429) {\n        return true;\n    }\n    if (error.status >= 400 && error.status < 500 && error.status !== 429) {\n        return false;\n    }\n    return true;\n}\nfunction calculateRetryDelay(attempt, config) {\n    const exponentialDelay = (config.initialDelayMs || 1e3) * Math.pow(config.backoffMultiplier || 2, attempt);\n    const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs || 3e4);\n    const jitter = 0.5 + Math.random() * 0.5;\n    return Math.floor(cappedDelay * jitter);\n}\nfunction enhanceError(error, context) {\n    if (!error) return new Error(\"Unknown error occurred\");\n    if (error.context) return error;\n    const enhancedError = new Error(error.message || \"HTTP operation failed\");\n    Object.assign(enhancedError, {\n        code: error.code || error.status || \"UNKNOWN_ERROR\",\n        status: error.status,\n        context,\n        originalError: error\n    });\n    return enhancedError;\n}\nfunction getRetryConfig(apiOptions) {\n    return {\n        maxRetries: 3,\n        initialDelayMs: 1e3,\n        maxDelayMs: 3e4,\n        backoffMultiplier: 2,\n        ...apiOptions.retryConfig\n    };\n}\nfunction executeErrorHandler(errorHandler, error, context, logger21) {\n    if (!errorHandler) return;\n    try {\n        errorHandler(error, context);\n    } catch (handlerError) {\n        logger21.error(\"Custom error handler failed\", {\n            originalError: error.message,\n            handlerError: handlerError?.message || String(handlerError)\n        });\n    }\n}\nasync function executeWithRetry(operation, operationName, operationContext, apiOptions, logger21, specialErrorHandling) {\n    const retryConfig = getRetryConfig(apiOptions);\n    let lastError = null;\n    const startTime = Date.now();\n    for(let attempt = 0; attempt <= retryConfig.maxRetries; attempt++){\n        try {\n            logger21.debug(`Executing ${operationName} (attempt ${attempt + 1})`, operationContext);\n            const result = await operation();\n            if (attempt > 0) {\n                logger21.info(`${operationName} operation succeeded after ${attempt} retries`, {\n                    ...operationContext,\n                    totalAttempts: attempt + 1,\n                    duration: Date.now() - startTime\n                });\n            }\n            return result;\n        } catch (error) {\n            lastError = error;\n            if (specialErrorHandling) {\n                const specialResult = specialErrorHandling(error);\n                if (specialResult !== void 0) {\n                    return specialResult;\n                }\n            }\n            if (attempt === retryConfig.maxRetries) {\n                break;\n            }\n            const isRetryable = shouldRetryError(error);\n            if (!isRetryable) {\n                logger21.debug(`Not retrying ${operationName} operation due to non-retryable error`, {\n                    ...operationContext,\n                    errorMessage: error.message,\n                    errorCode: error.code || error.status,\n                    attempt: attempt + 1\n                });\n                break;\n            }\n            const delay = calculateRetryDelay(attempt, retryConfig);\n            logger21.warning(`Retrying ${operationName} operation (attempt ${attempt + 2}) after ${delay}ms`, {\n                ...operationContext,\n                errorMessage: error.message,\n                errorCode: error.code || error.status,\n                delay,\n                attemptNumber: attempt + 1\n            });\n            await new Promise((resolve)=>setTimeout(resolve, delay));\n        }\n    }\n    const finalError = enhanceError(lastError, operationContext);\n    executeErrorHandler(apiOptions.errorHandler, finalError, operationContext, logger21);\n    logger21.error(`${operationName} operation failed after ${retryConfig.maxRetries + 1} attempts`, {\n        ...operationContext,\n        errorMessage: finalError.message,\n        errorCode: finalError.code || finalError.status,\n        duration: Date.now() - startTime,\n        totalAttempts: retryConfig.maxRetries + 1\n    });\n    throw finalError;\n}\n// src/ops/create.ts\nvar logger5 = logger_default.get(\"client-api\", \"ops\", \"create\");\nvar getCreateOperation = (api, apiOptions, utilities)=>{\n    const create = async (item, locations = [])=>{\n        const requestOptions = Object.assign({}, apiOptions.postOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger5.default(\"create\", {\n            item,\n            locations,\n            requestOptions\n        });\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const operationContext = {\n            operation: \"create\",\n            path: utilities.getPath(loc),\n            itemType: typeof item,\n            hasLocations: locations.length > 0\n        };\n        const retryConfig = {\n            maxRetries: 3,\n            initialDelayMs: 1e3,\n            maxDelayMs: 3e4,\n            backoffMultiplier: 2,\n            ...apiOptions.retryConfig\n        };\n        let lastError = null;\n        const startTime = Date.now();\n        for(let attempt = 0; attempt <= retryConfig.maxRetries; attempt++){\n            try {\n                logger5.debug(`Creating item (attempt ${attempt + 1})`, operationContext);\n                const result = await utilities.processOne(api.httpPost(utilities.getPath(loc), item, requestOptions));\n                const created = utilities.validatePK(result);\n                if (attempt > 0) {\n                    logger5.info(`Create operation succeeded after ${attempt} retries`, {\n                        ...operationContext,\n                        totalAttempts: attempt + 1,\n                        duration: Date.now() - startTime\n                    });\n                }\n                return created;\n            } catch (error) {\n                lastError = error;\n                if (attempt === retryConfig.maxRetries) {\n                    break;\n                }\n                const isRetryable = shouldRetryError(error);\n                if (!isRetryable) {\n                    logger5.debug(\"Not retrying create operation due to non-retryable error\", {\n                        ...operationContext,\n                        errorMessage: error.message,\n                        errorCode: error.code || error.status,\n                        attempt: attempt + 1\n                    });\n                    break;\n                }\n                const delay = calculateRetryDelay(attempt, retryConfig);\n                logger5.warning(`Retrying create operation (attempt ${attempt + 2}) after ${delay}ms`, {\n                    ...operationContext,\n                    errorMessage: error.message,\n                    errorCode: error.code || error.status,\n                    delay,\n                    attemptNumber: attempt + 1\n                });\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n        }\n        const finalError = enhanceError(lastError, operationContext);\n        if (apiOptions.errorHandler) {\n            try {\n                apiOptions.errorHandler(finalError, operationContext);\n            } catch (handlerError) {\n                logger5.error(\"Custom error handler failed\", {\n                    originalError: finalError.message,\n                    handlerError: handlerError?.message || String(handlerError)\n                });\n            }\n        }\n        logger5.error(`Create operation failed after ${retryConfig.maxRetries + 1} attempts`, {\n            ...operationContext,\n            errorMessage: finalError.message,\n            errorCode: finalError.code || finalError.status,\n            duration: Date.now() - startTime,\n            totalAttempts: retryConfig.maxRetries + 1\n        });\n        throw finalError;\n    };\n    return create;\n};\n// src/ops/update.ts\nvar logger6 = logger_default.get(\"client-api\", \"ops\", \"update\");\nvar getUpdateOperation = (api, apiOptions, utilities)=>{\n    const update = async (ik, item)=>{\n        const requestOptions = Object.assign({}, apiOptions.putOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger6.default(\"update\", {\n            ik,\n            item,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processOne(api.httpPut(utilities.getPath(ik), item, requestOptions)));\n    };\n    return update;\n};\n// src/ops/get.ts\nvar logger7 = logger_default.get(\"client-api\", \"ops\", \"get\");\nvar getGetOperation = (api, apiOptions, utilities)=>{\n    const get = async (ik)=>{\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.readAuthenticated\n        });\n        logger7.default(\"get\", {\n            ik,\n            requestOptions\n        });\n        const operationContext = {\n            operation: \"get\",\n            path: utilities.getPath(ik),\n            keyType: typeof ik\n        };\n        const retryConfig = {\n            maxRetries: 3,\n            initialDelayMs: 1e3,\n            maxDelayMs: 3e4,\n            backoffMultiplier: 2,\n            ...apiOptions.retryConfig\n        };\n        let lastError = null;\n        const startTime = Date.now();\n        for(let attempt = 0; attempt <= retryConfig.maxRetries; attempt++){\n            try {\n                logger7.debug(`Getting item (attempt ${attempt + 1})`, operationContext);\n                const result = await utilities.processOne(api.httpGet(utilities.getPath(ik), requestOptions));\n                const item = utilities.validatePK(result);\n                if (attempt > 0) {\n                    logger7.info(`Get operation succeeded after ${attempt} retries`, {\n                        ...operationContext,\n                        totalAttempts: attempt + 1,\n                        duration: Date.now() - startTime\n                    });\n                }\n                return item;\n            } catch (error) {\n                lastError = error;\n                if (error.status === 404) {\n                    logger7.debug(\"Item not found (404)\", operationContext);\n                    return null;\n                }\n                if (attempt === retryConfig.maxRetries) {\n                    break;\n                }\n                const isRetryable = shouldRetryError(error);\n                if (!isRetryable) {\n                    logger7.debug(\"Not retrying get operation due to non-retryable error\", {\n                        ...operationContext,\n                        errorMessage: error.message,\n                        errorCode: error.code || error.status,\n                        attempt: attempt + 1\n                    });\n                    break;\n                }\n                const delay = calculateRetryDelay(attempt, retryConfig);\n                logger7.warning(`Retrying get operation (attempt ${attempt + 2}) after ${delay}ms`, {\n                    ...operationContext,\n                    errorMessage: error.message,\n                    errorCode: error.code || error.status,\n                    delay,\n                    attemptNumber: attempt + 1\n                });\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n        }\n        const finalError = enhanceError(lastError, operationContext);\n        if (apiOptions.errorHandler) {\n            try {\n                apiOptions.errorHandler(finalError, operationContext);\n            } catch (handlerError) {\n                logger7.error(\"Custom error handler failed\", {\n                    originalError: finalError.message,\n                    handlerError: handlerError?.message || String(handlerError)\n                });\n            }\n        }\n        logger7.error(`Get operation failed after ${retryConfig.maxRetries + 1} attempts`, {\n            ...operationContext,\n            errorMessage: finalError.message,\n            errorCode: finalError.code || finalError.status,\n            duration: Date.now() - startTime,\n            totalAttempts: retryConfig.maxRetries + 1\n        });\n        throw finalError;\n    };\n    return get;\n};\n// src/ops/remove.ts\nvar logger8 = logger_default.get(\"client-api\", \"ops\", \"remove\");\nvar getRemoveOperation = (api, apiOptions, utilities)=>{\n    const remove = async (ik)=>{\n        const requestOptions = Object.assign({}, apiOptions.deleteOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger8.default(\"remove\", {\n            ik,\n            requestOptions\n        });\n        return api.httpDelete(utilities.getPath(ik), requestOptions);\n    };\n    return remove;\n};\n// src/ops/find.ts\nvar logger9 = logger_default.get(\"client-api\", \"ops\", \"find\");\nvar getFindOperation = (api, apiOptions, utilities)=>{\n    const find = async (finder, finderParams = {}, locations = [])=>{\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const mergedParams = finderToParams(finder, finderParams);\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.allAuthenticated,\n            params: mergedParams\n        });\n        logger9.default(\"find\", {\n            finder,\n            finderParams,\n            locations,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)));\n    };\n    return find;\n};\n// src/ops/findOne.ts\nvar logger10 = logger_default.get(\"client-api\", \"ops\", \"find\");\nvar getFindOneOperation = (api, apiOptions, utilities)=>{\n    const findOne = async (finder, finderParams = {}, locations = [])=>{\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const params = finderToParams(finder, finderParams);\n        params.one = true;\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.allAuthenticated,\n            params\n        });\n        logger10.default(\"findOne\", {\n            finder,\n            finderParams,\n            locations,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)))[0];\n    };\n    return findOne;\n};\n// src/ops/facet.ts\nvar logger11 = logger_default.get(\"client-api\", \"ops\", \"facet\");\nvar getFacetOperation = (api, apiOptions, utilities)=>{\n    const facet = async (ik, facet2, params = {})=>{\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated,\n            params\n        });\n        logger11.default(\"facet\", {\n            ik,\n            facet: facet2,\n            requestOptions\n        });\n        return api.httpGet(`${utilities.getPath(ik)}/${facet2}`, requestOptions);\n    };\n    return facet;\n};\n// src/ops/allFacet.ts\nvar logger12 = logger_default.get(\"client-api\", \"ops\", \"allFacet\");\nvar getAllFacetOperation = (api, apiOptions, utilities)=>{\n    const allFacet = async (facet, params = {}, locations = [])=>{\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated,\n            params\n        });\n        logger12.default(\"allFacet\", {\n            facet,\n            locations,\n            requestOptions\n        });\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        return api.httpGet(`${utilities.getPath(loc)}/${facet}`, requestOptions);\n    };\n    return allFacet;\n};\n// src/ops/index.ts\nvar getOperations = (api, apiOptions, utilities)=>{\n    return {\n        action: getActionOperation(api, apiOptions, utilities),\n        all: getAllOperation(api, apiOptions, utilities),\n        allAction: getAllActionOperation(api, apiOptions, utilities),\n        allFacet: getAllFacetOperation(api, apiOptions, utilities),\n        create: getCreateOperation(api, apiOptions, utilities),\n        facet: getFacetOperation(api, apiOptions, utilities),\n        findOne: getFindOneOperation(api, apiOptions, utilities),\n        find: getFindOperation(api, apiOptions, utilities),\n        get: getGetOperation(api, apiOptions, utilities),\n        one: getOneOperation(api, apiOptions, utilities),\n        remove: getRemoveOperation(api, apiOptions, utilities),\n        update: getUpdateOperation(api, apiOptions, utilities)\n    };\n};\n// src/Utilities.ts\n\n\nvar logger13 = logger_default.get(\"client-api\", \"Utility\");\nvar createUtilities = (pkType, pathNames)=>{\n    logger13.default(\"createUtilities\", {\n        pkType,\n        pathNames\n    });\n    const verifyLocations = (locations)=>{\n        if (locations && locations.length < pathNames.length - 1) {\n            throw new Error(\"Not enough locations for pathNames: locations:\" + locations.length + \" pathNames:\" + pathNames.length);\n        }\n        return true;\n    };\n    const processOne = async (apiCall)=>{\n        logger13.default(\"processOne\", {\n            apiCall\n        });\n        const response = await apiCall;\n        logger13.default(\"processOne response\", {\n            responseType: typeof response,\n            hasData: !!response\n        });\n        return convertDoc(response);\n    };\n    const processArray = async (api)=>{\n        logger13.default(\"processArray\", {\n            api\n        });\n        const response = await api;\n        logger13.default(\"processArray response\", {\n            responseType: typeof response,\n            isArray: Array.isArray(response),\n            length: Array.isArray(response) ? response.length : 0\n        });\n        if (response && Array.isArray(response)) {\n            return response.map((subjectChat)=>convertDoc(subjectChat));\n        } else {\n            logger13.error(\"Response was not an array\", {\n                response\n            });\n            throw new Error(\"Response was not an array\");\n        }\n    };\n    const convertDoc = (doc)=>{\n        logger13.default(\"convertDoc\", {\n            doc\n        });\n        if (doc && doc.events) {\n            const events = doc.events;\n            for(const key in events){\n                events[key] = deepmerge__WEBPACK_IMPORTED_MODULE_2__(events[key], {\n                    at: events[key].at ? new Date(events[key].at) : null\n                });\n            }\n            return doc;\n        } else {\n            return doc;\n        }\n    };\n    const getPath = (key)=>{\n        const localPathNames = [\n            ...pathNames\n        ];\n        logger13.default(\"getPath\", {\n            key,\n            pathNames: localPathNames\n        });\n        const keys = (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.generateKeyArray)(key);\n        let path = addPath(\"\", keys, localPathNames);\n        if (localPathNames.length === 1) {\n            path = `${path}/${localPathNames[0]}`;\n        }\n        logger13.default(\"getPath created\", {\n            key,\n            path\n        });\n        return path;\n    };\n    const addPath = (base, keys, localPathNames)=>{\n        logger13.default(\"addPath\", {\n            base,\n            keys,\n            pathNames: localPathNames\n        });\n        if (keys.length < localPathNames.length - 1) {\n            logger13.error(\"addPath should never have keys with a length less than the length of pathNames - 1\", {\n                keys,\n                localPathNames\n            });\n            throw new Error(\"addPath should never have keys with a length less than the length of pathNames - 1: \" + keys.length + \" \" + localPathNames.length + \" \" + JSON.stringify(keys, localPathNames));\n        } else if (keys.length > localPathNames.length) {\n            logger13.error(\"addPath should never have keys with a length greater than the length of pathNames\", {\n                keys,\n                pathNames\n            });\n            throw new Error(\"addPath should never have keys with a length greater than the length of pathNames: \" + keys.length + \" \" + localPathNames.length + \" \" + JSON.stringify(keys, localPathNames));\n        }\n        if (keys.length === 0) {\n            logger13.default(\"addPath returning base\", {\n                base\n            });\n            return base;\n        } else {\n            let nextBase;\n            const key = keys.pop();\n            const pathName = localPathNames.pop();\n            if ((0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isPriKey)(key)) {\n                const PriKey2 = key;\n                nextBase = `${base}/${pathName}/${PriKey2.pk}`;\n                logger13.default(\"Adding Path for PK\", {\n                    pathName,\n                    PriKey: PriKey2,\n                    nextBase\n                });\n            } else {\n                const LocKey2 = key;\n                nextBase = `${base}/${pathName}/${LocKey2.lk}`;\n                logger13.default(\"Retrieving Collection for LK\", {\n                    pathName,\n                    LocKey: LocKey2\n                });\n            }\n            logger13.default(\"calling addPath recursively\", {\n                nextBase,\n                keys,\n                localPathNames\n            });\n            return addPath(nextBase, keys, localPathNames);\n        }\n    };\n    const validatePK = (item)=>{\n        return (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType);\n    };\n    return {\n        verifyLocations,\n        processOne,\n        convertDoc,\n        processArray,\n        getPath,\n        validatePK\n    };\n};\n// src/AItemAPI.ts\nvar logger14 = logger_default.get(\"AItemAPI\");\nvar finderToParams = (finder, finderParams)=>{\n    return {\n        finder,\n        finderParams: JSON.stringify(finderParams)\n    };\n};\nvar createAItemAPI = (api, pkType, pathNames, options)=>{\n    logger14.default(\"createAItemAPI\", {\n        pkType,\n        pathNames,\n        options\n    });\n    let mergedOptions;\n    const defaultOptions = {\n        readAuthenticated: true,\n        allAuthenticated: true,\n        writeAuthenticated: true,\n        getOptions: {},\n        postOptions: {},\n        putOptions: {},\n        deleteOptions: {}\n    };\n    if (options) {\n        mergedOptions = Object.assign({}, defaultOptions, options);\n    } else {\n        mergedOptions = defaultOptions;\n    }\n    const utilities = createUtilities(pkType, pathNames);\n    const operations = getOperations(api, mergedOptions, utilities);\n    return {\n        action: operations.action,\n        all: operations.all,\n        allAction: operations.allAction,\n        allFacet: operations.allFacet,\n        create: operations.create,\n        facet: operations.facet,\n        find: operations.find,\n        findOne: operations.findOne,\n        get: operations.get,\n        one: operations.one,\n        remove: operations.remove,\n        update: operations.update\n    };\n};\n// src/CItemAPI.ts\nvar logger15 = logger_default.get(\"CItemAPI\");\nvar createCItemApi = (api, type, pathNames, options)=>{\n    logger15.default(\"createCItemApi\", {\n        api,\n        type,\n        pathNames,\n        options\n    });\n    const aItemAPI = createAItemAPI(api, type, pathNames, options);\n    return {\n        action: aItemAPI.action,\n        all: aItemAPI.all,\n        allAction: aItemAPI.allAction,\n        allFacet: aItemAPI.allFacet,\n        one: aItemAPI.one,\n        get: aItemAPI.get,\n        create: aItemAPI.create,\n        remove: aItemAPI.remove,\n        update: aItemAPI.update,\n        facet: aItemAPI.facet,\n        find: aItemAPI.find,\n        findOne: aItemAPI.findOne\n    };\n};\n// src/PItemAPI.ts\nvar logger16 = logger_default.get(\"PItemAPI\");\nvar createPItemApi = (api, type, pathName, options)=>{\n    logger16.default(\"createPItemApi\", {\n        type,\n        pathName,\n        options\n    });\n    const aItemAPI = createAItemAPI(api, type, [\n        pathName\n    ], options);\n    const action = async (ik, action2, body = {})=>await aItemAPI.action(ik, action2, body);\n    const all = async (query = {})=>await aItemAPI.all(query, []);\n    const allAction = async (action2, body = {})=>await aItemAPI.allAction(action2, body, []);\n    const allFacet = async (facet2, params = {})=>await aItemAPI.allFacet(facet2, params);\n    const one = async (query = {})=>await aItemAPI.one(query, []);\n    const get = async (ik)=>await aItemAPI.get(ik);\n    const create = async (item)=>await aItemAPI.create(item, []);\n    const remove = async (ik)=>await aItemAPI.remove(ik);\n    const update = async (ik, item)=>await aItemAPI.update(ik, item);\n    const facet = async (ik, facet2, params = {})=>await aItemAPI.facet(ik, facet2, params);\n    const find = async (finder, finderParams = {})=>await aItemAPI.find(finder, finderParams);\n    const findOne = async (finder, finderParams = {})=>await aItemAPI.findOne(finder, finderParams);\n    return {\n        ...aItemAPI,\n        action,\n        all,\n        allAction,\n        allFacet,\n        one,\n        get,\n        create,\n        remove,\n        update,\n        facet,\n        find,\n        findOne\n    };\n};\n// src/Instance.ts\n\nvar logger17 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate, clientApi)=>{\n    logger17.debug(\"createInstance\", {\n        coordinate,\n        clientApi,\n        registry\n    });\n    const baseInstance = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_3__.createInstance)(registry, coordinate);\n    return {\n        ...baseInstance,\n        clientApi\n    };\n};\n// src/InstanceFactory.ts\nvar logger18 = logger_default.get(\"InstanceFactory\");\nvar createInstanceFactory = (clientApi)=>{\n    return (coordinate, context)=>{\n        logger18.debug(\"Creating client-api instance\", {\n            coordinate,\n            registry: context.registry,\n            clientApi\n        });\n        return createInstance(context.registry, coordinate, clientApi);\n    };\n};\n// src/Registry.ts\n\nvar logger19 = logger_default.get(\"Registry\");\nvar createRegistryFactory = ()=>{\n    return (type, registryHub)=>{\n        if (type !== \"client-api\") {\n            throw new Error(`Client API registry factory can only create 'client-api' type registries, got: ${type}`);\n        }\n        logger19.debug(\"Creating client-api registry\", {\n            type,\n            registryHub\n        });\n        const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_3__.createRegistry)(type, registryHub);\n        return baseRegistry;\n    };\n};\nvar createRegistry = (registryHub)=>{\n    const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_3__.createRegistry)(\"client-api\", registryHub);\n    return {\n        ...baseRegistry\n    };\n};\n// src/errors/index.ts\nvar ClientApiError = class extends Error {\n    constructor(message, context){\n        super(message);\n        this.name = this.constructor.name;\n        this.timestamp = /* @__PURE__ */ new Date();\n        this.context = context;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            code: this.code,\n            message: this.message,\n            isRetryable: this.isRetryable,\n            timestamp: this.timestamp,\n            context: this.context,\n            stack: this.stack\n        };\n    }\n};\nvar NetworkError = class extends ClientApiError {\n    constructor(message, context){\n        super(`Network error: ${message}`, context), this.code = \"NETWORK_ERROR\", this.isRetryable = true;\n    }\n};\nvar TimeoutError = class extends ClientApiError {\n    constructor(timeout, context){\n        super(`Request timed out after ${timeout}ms`, context), this.code = \"TIMEOUT_ERROR\", this.isRetryable = true;\n    }\n};\nvar AuthenticationError = class extends ClientApiError {\n    constructor(message, context){\n        super(message || \"Authentication failed - invalid or expired credentials\", context), this.code = \"AUTHENTICATION_ERROR\", this.isRetryable = false;\n    }\n};\nvar AuthorizationError = class extends ClientApiError {\n    constructor(message, context){\n        super(message || \"Access forbidden - insufficient permissions\", context), this.code = \"AUTHORIZATION_ERROR\", this.isRetryable = false;\n    }\n};\nvar NotFoundError = class extends ClientApiError {\n    constructor(resource, identifier, context){\n        const message = identifier ? `${resource} with identifier '${identifier}' not found` : `${resource} not found`;\n        super(message, context), this.code = \"NOT_FOUND_ERROR\", this.isRetryable = false;\n    }\n};\nvar ValidationError = class extends ClientApiError {\n    constructor(message, validationErrors, context){\n        super(`Validation error: ${message}`, context), this.code = \"VALIDATION_ERROR\", this.isRetryable = false;\n        this.validationErrors = validationErrors;\n    }\n};\nvar ConflictError = class extends ClientApiError {\n    constructor(message, context){\n        super(`Conflict: ${message}`, context), this.code = \"CONFLICT_ERROR\", this.isRetryable = false;\n    }\n};\nvar RateLimitError = class extends ClientApiError {\n    constructor(retryAfter, context){\n        const message = retryAfter ? `Rate limit exceeded - retry after ${retryAfter} seconds` : \"Rate limit exceeded\";\n        super(message, context), this.code = \"RATE_LIMIT_ERROR\", this.isRetryable = true;\n        this.retryAfter = retryAfter;\n    }\n};\nvar ServerError = class extends ClientApiError {\n    constructor(statusCode, message, context){\n        super(message || `Server error (${statusCode})`, context), this.code = \"SERVER_ERROR\", this.isRetryable = true;\n        this.statusCode = statusCode;\n    }\n};\nvar PayloadTooLargeError = class extends ClientApiError {\n    constructor(maxSize, context){\n        const message = maxSize ? `Request payload too large - maximum size is ${maxSize}` : \"Request payload too large\";\n        super(message, context), this.code = \"PAYLOAD_TOO_LARGE_ERROR\", this.isRetryable = false;\n    }\n};\nvar HttpError = class extends ClientApiError {\n    constructor(statusCode, statusText, message, context){\n        super(message || `HTTP error ${statusCode}: ${statusText}`, context), this.code = \"HTTP_ERROR\";\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n        this.isRetryable = statusCode >= 500;\n    }\n};\nvar ConfigurationError = class extends ClientApiError {\n    constructor(message, context){\n        super(`Configuration error: ${message}`, context), this.code = \"CONFIGURATION_ERROR\", this.isRetryable = false;\n    }\n};\nvar ParseError = class extends ClientApiError {\n    constructor(message, context){\n        super(`Parse error: ${message}`, context), this.code = \"PARSE_ERROR\", this.isRetryable = false;\n    }\n};\nfunction createHttpError(statusCode, statusText, responseBody, context) {\n    const errorContext = {\n        statusCode,\n        statusText,\n        responseBody,\n        ...context\n    };\n    switch(statusCode){\n        case 400:\n            if (responseBody?.validationErrors) {\n                return new ValidationError(responseBody.message || \"Request validation failed\", responseBody.validationErrors, errorContext);\n            }\n            return new ValidationError(responseBody?.message || statusText, [], errorContext);\n        case 401:\n            return new AuthenticationError(responseBody?.message, errorContext);\n        case 403:\n            return new AuthorizationError(responseBody?.message, errorContext);\n        case 404:\n            return new NotFoundError(responseBody?.resource || \"Resource\", responseBody?.identifier, errorContext);\n        case 409:\n            return new ConflictError(responseBody?.message || statusText, errorContext);\n        case 413:\n            return new PayloadTooLargeError(responseBody?.maxSize, errorContext);\n        case 429:\n            {\n                let retryAfter;\n                if (responseBody?.retryAfter) {\n                    retryAfter = responseBody.retryAfter;\n                } else if (context?.headers?.[\"retry-after\"]) {\n                    retryAfter = parseInt(context.headers[\"retry-after\"]);\n                }\n                return new RateLimitError(retryAfter, errorContext);\n            }\n        default:\n            if (statusCode >= 500) {\n                return new ServerError(statusCode, responseBody?.message || statusText, errorContext);\n            }\n            return new HttpError(statusCode, statusText, responseBody?.message, errorContext);\n    }\n}\nfunction createNetworkError(error, context) {\n    const errorContext = {\n        originalError: error,\n        ...context\n    };\n    if (error.code === \"ECONNABORTED\" || error.message?.includes(\"timeout\")) {\n        return new TimeoutError(error.timeout || 5e3, errorContext);\n    }\n    if (error.code === \"ECONNREFUSED\" || error.code === \"ENOTFOUND\" || error.code === \"ENETUNREACH\" || error.message?.includes(\"network\")) {\n        return new NetworkError(error.message || \"Network connection failed\", errorContext);\n    }\n    return new NetworkError(error.message || \"Unknown network error\", errorContext);\n}\nfunction isRetryableError(error) {\n    return error instanceof ClientApiError && error.isRetryable;\n}\nfunction isClientApiError(error) {\n    return error instanceof ClientApiError;\n}\n// src/http/HttpWrapper.ts\nvar logger20 = {\n    debug: (message, context)=>console.debug(message, context),\n    info: (message, context)=>console.info(message, context),\n    warning: (message, context)=>console.warn(message, context),\n    error: (message, context)=>console.error(message, context)\n};\nvar DEFAULT_RETRY_CONFIG = {\n    maxRetries: 3,\n    initialDelayMs: 1e3,\n    maxDelayMs: 3e4,\n    backoffMultiplier: 2,\n    enableJitter: true,\n    shouldRetry: (error, attemptNumber)=>{\n        if (attemptNumber >= 3) return false;\n        if (error.isRetryable) return true;\n        return false;\n    },\n    onRetry: (error, attemptNumber, delay)=>{\n        logger20.warning(`Retrying HTTP request (attempt ${attemptNumber + 1}) after ${delay}ms`, {\n            errorCode: error.code,\n            errorMessage: error.message,\n            delay,\n            attemptNumber\n        });\n    }\n};\nvar sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\nfunction calculateDelay(attemptNumber, config) {\n    const exponentialDelay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attemptNumber);\n    const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\n    if (!config.enableJitter) {\n        return cappedDelay;\n    }\n    const jitter = 0.5 + Math.random() * 0.5;\n    return Math.floor(cappedDelay * jitter);\n}\nvar HttpWrapper = class {\n    constructor(api, retryConfig = {}){\n        this.api = api;\n        this.retryConfig = {\n            ...DEFAULT_RETRY_CONFIG,\n            ...retryConfig\n        };\n    }\n    /**\n   * Execute HTTP operation with retry logic and error handling\n   */ async executeWithRetry(operation, operationName, context) {\n        let lastError = null;\n        const startTime = Date.now();\n        for(let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++){\n            try {\n                logger20.debug(`Executing ${operationName}`, {\n                    attempt: attempt + 1,\n                    maxRetries: this.retryConfig.maxRetries + 1,\n                    ...context\n                });\n                const result = await operation();\n                if (attempt > 0) {\n                    logger20.info(`${operationName} succeeded after ${attempt} retries`, {\n                        totalAttempts: attempt + 1,\n                        duration: Date.now() - startTime,\n                        ...context\n                    });\n                }\n                return result;\n            } catch (error) {\n                lastError = this.convertToClientApiError(error, operationName, context);\n                if (attempt === this.retryConfig.maxRetries) {\n                    break;\n                }\n                if (!this.retryConfig.shouldRetry(lastError, attempt)) {\n                    logger20.debug(`Not retrying ${operationName} due to non-retryable error`, {\n                        errorCode: lastError.code,\n                        errorMessage: lastError.message,\n                        attempt: attempt + 1,\n                        ...context\n                    });\n                    break;\n                }\n                let delay = calculateDelay(attempt, this.retryConfig);\n                if (lastError instanceof RateLimitError && lastError.retryAfter) {\n                    delay = Math.max(delay, lastError.retryAfter * 1e3);\n                }\n                this.retryConfig.onRetry(lastError, attempt, delay);\n                await sleep(delay);\n            }\n        }\n        logger20.error(`${operationName} failed after ${this.retryConfig.maxRetries + 1} attempts`, {\n            errorCode: lastError?.code,\n            errorMessage: lastError?.message,\n            duration: Date.now() - startTime,\n            ...context\n        });\n        throw lastError;\n    }\n    /**\n   * Convert any error to a ClientApiError\n   */ convertToClientApiError(error, operationName, context) {\n        const errorContext = {\n            operation: operationName,\n            ...context\n        };\n        if (error instanceof ClientApiError) {\n            return error;\n        }\n        if (error.response) {\n            const { status, statusText, data, headers } = error.response;\n            return createHttpError(status, statusText, data, {\n                ...errorContext,\n                headers,\n                url: error.config?.url\n            });\n        }\n        if (error.request) {\n            return createNetworkError(error, {\n                ...errorContext,\n                url: error.config?.url,\n                method: error.config?.method\n            });\n        }\n        return createNetworkError(error, errorContext);\n    }\n    /**\n   * Wrapper for HTTP GET operations\n   */ async get(url, options, context) {\n        return this.executeWithRetry(()=>this.api.httpGet(url, options), \"GET\", {\n            url,\n            ...context\n        });\n    }\n    /**\n   * Wrapper for HTTP POST operations\n   */ async post(url, data, options, context) {\n        return this.executeWithRetry(()=>this.api.httpPost(url, data, options), \"POST\", {\n            url,\n            hasData: !!data,\n            ...context\n        });\n    }\n    /**\n   * Wrapper for HTTP PUT operations\n   */ async put(url, data, options, context) {\n        return this.executeWithRetry(()=>this.api.httpPut(url, data, options), \"PUT\", {\n            url,\n            hasData: !!data,\n            ...context\n        });\n    }\n    /**\n   * Wrapper for HTTP DELETE operations\n   */ async delete(url, options, context) {\n        return this.executeWithRetry(()=>this.api.httpDelete(url, options), \"DELETE\", {\n            url,\n            ...context\n        });\n    }\n    /**\n   * Update retry configuration\n   */ updateRetryConfig(newConfig) {\n        Object.assign(this.retryConfig, newConfig);\n    }\n    /**\n   * Get current retry configuration\n   */ getRetryConfig() {\n        return {\n            ...this.retryConfig\n        };\n    }\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vZmplbGwtY2xpZW50LWFwaS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtPOztBQ0xhO0FBRXBCLElBQU0sWUFBWSxnRUFBUSxDQUFVLG1CQUFtQjtBQUV2RCxJQUFPLGlCQUFROztBRFFmLElBQU0sU0FBUyxlQUFVLElBQUksY0FBYyxPQUFPLEtBQUs7QUFFaEQsSUFBTSxrQkFBa0IsQ0FRM0IsS0FDQSxZQUNBO0lBSUYsTUFBTSxNQUFNLE9BQ1YsUUFBbUIsQ0FBQyxHQUNwQixZQUFrRCxDQUFDO1FBRW5ELFVBQVUsZ0JBQWdCLFNBQVM7UUFDbkMsTUFBTSxNQUE0QztRQUVsRCxNQUFNLFNBQXNCLDBEQUFhLENBQUMsS0FBSztRQUMvQyxNQUFNLGlCQUFpQixPQUFPLE9BQU8sQ0FBQyxHQUFHLFdBQVcsWUFBWTtZQUFFLGlCQUFpQixXQUFXO1lBQWtCO1FBQU8sQ0FBQztRQUV4SCxPQUFPLFFBQVEsT0FBTztZQUFFO1lBQU87WUFBVztRQUFlLENBQUM7UUFFMUQsT0FBTyxVQUFVLFdBQVcsTUFBTSxVQUFVLGFBQzFDLElBQUksUUFDRixVQUFVLFFBQVEsR0FBRyxHQUNyQjtJQUVOO0lBRUEsT0FBTztBQUNUOztBRXJDQSxJQUFNQSxVQUFTLGVBQVUsSUFBSSxjQUFjLE9BQU8sUUFBUTtBQUVuRCxJQUFNLHFCQUFxQixDQVE5QixLQUNBLFlBQ0E7SUFJRixNQUFNLFNBQVMsT0FDYixJQUNBQyxTQUNBLE9BQVksQ0FBQztRQUViLE1BQU0saUJBQWlCLE9BQU8sT0FBTyxDQUFDLEdBQUcsV0FBVyxhQUFhO1lBQUUsaUJBQWlCLFdBQVc7UUFBbUIsQ0FBQztRQUNuSEQsUUFBTyxRQUFRLFVBQVU7WUFBRTtZQUFJLFFBQUFDO1lBQVE7WUFBTTtRQUFlLENBQUM7UUFFN0QsT0FBTyxVQUFVLFdBQ2YsTUFBTSxVQUFVLFdBQ2QsSUFBSSxTQUNGLEdBQUcsVUFBVSxRQUFRLEVBQUUsQ0FBQyxJQUFJQSxPQUFNLElBQ2xDLE1BQ0E7SUFJUjtJQUVBLE9BQU87QUFDVDs7QUNyQ0EsSUFBTUQsVUFBUyxlQUFVLElBQUksY0FBYyxPQUFPLFdBQVc7QUFFdEQsSUFBTSx3QkFBd0IsQ0FRakMsS0FDQSxZQUNBO0lBSUYsTUFBTSxZQUFZLE9BQ2hCLFFBQ0EsT0FBWSxDQUFDLEdBQ2IsWUFBa0QsQ0FBQztRQUVuRCxNQUFNLGlCQUFpQixPQUFPLE9BQU8sQ0FBQyxHQUFHLFdBQVcsYUFBYTtZQUFFLGlCQUFpQixXQUFXO1FBQW1CLENBQUM7UUFDbkhBLFFBQU8sUUFBUSxhQUFhO1lBQUU7WUFBUTtZQUFNO1lBQVc7UUFBZSxDQUFDO1FBQ3ZFLFVBQVUsZ0JBQWdCLFNBQVM7UUFFbkMsTUFBTSxNQUE0QztRQUdsRCxPQUFPLFVBQVUsV0FDZixNQUFNLFVBQVUsYUFDZCxJQUFJLFNBQ0YsR0FBRyxVQUFVLFFBQVEsR0FBRyxDQUFDLElBQUksTUFBTSxJQUNuQyxNQUNBO0lBR1I7SUFFQSxPQUFPO0FBQ1Q7O0FDM0NPO0FBT1AsSUFBTUEsVUFBUyxlQUFVLElBQUksY0FBYyxPQUFPLEtBQUs7QUFFaEQsSUFBTSxrQkFBa0IsQ0FRM0IsS0FDQSxZQUNBO0lBT0YsTUFBTSxNQUFNLE9BQ1YsUUFBbUIsQ0FBQyxHQUNwQixZQUFrRCxDQUFDO1FBRW5ELFVBQVUsZ0JBQWdCLFNBQVM7UUFFbkMsTUFBTSxNQUE0QztRQUVsRCxNQUFNLFNBQXNCSywwREFBQUgsQ0FBYyxLQUFLO1FBQy9DLE1BQU0saUJBQWlCLE9BQU8sT0FBTyxDQUFDLEdBQUcsV0FBVyxZQUFZO1lBQUUsaUJBQWlCLFdBQVc7WUFBbUI7UUFBTyxDQUFDO1FBQ3pIRixRQUFPLFFBQVEsT0FBTztZQUFFO1lBQU87WUFBVztRQUFlLENBQUM7UUFFMUQsSUFBSSxPQUFpQjtRQUVyQixNQUFNLFFBQVEsVUFBVSxXQUFXLE1BQU0sVUFBVSxhQUNqRCxJQUFJLFFBQ0YsVUFBVSxRQUFRLEdBQUcsR0FDckI7UUFHSixJQUFJLE1BQU0sU0FBUyxHQUFHO1lBQ3BCLE9BQU8sTUFBTSxDQUFDO1FBQ2hCO1FBRUEsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUOztBQ3JETyxTQUFTLGlCQUFpQixPQUFxQjtJQUVwRCxJQUFJLE1BQU0sU0FBUyxrQkFDakIsTUFBTSxTQUFTLGVBQ2YsTUFBTSxTQUFTLGlCQUNmLE1BQU0sU0FBUyxTQUFTLFNBQVMsS0FDakMsTUFBTSxTQUFTLFNBQVMsU0FBUyxHQUFHO1FBQ3BDLE9BQU87SUFDVDtJQUdBLElBQUksTUFBTSxVQUFVLE9BQU8sTUFBTSxXQUFXLEtBQUs7UUFDL0MsT0FBTztJQUNUO0lBR0EsSUFBSSxNQUFNLFVBQVUsT0FBTyxNQUFNLFNBQVMsT0FBTyxNQUFNLFdBQVcsS0FBSztRQUNyRSxPQUFPO0lBQ1Q7SUFHQSxPQUFPO0FBQ1Q7QUFLTyxTQUFTLG9CQUFvQixTQUFpQixRQUFxQjtJQUN4RSxNQUFNLG1CQUFvQixRQUFPLGtCQUFrQixPQUFRLEtBQUssSUFBSSxPQUFPLHFCQUFxQixHQUFHLE9BQU87SUFDMUcsTUFBTSxjQUFjLEtBQUssSUFBSSxrQkFBa0IsT0FBTyxjQUFjLEdBQUs7SUFHekUsTUFBTSxTQUFTLE1BQU8sS0FBSyxPQUFPLElBQUk7SUFDdEMsT0FBTyxLQUFLLE1BQU0sY0FBYyxNQUFNO0FBQ3hDO0FBS08sU0FBUyxhQUFhLE9BQVksU0FBbUI7SUFDMUQsSUFBSSxDQUFDLE1BQU8sUUFBTyxJQUFJLE1BQU0sd0JBQXdCO0lBR3JELElBQUksTUFBTSxRQUFTLFFBQU87SUFHMUIsTUFBTSxnQkFBZ0IsSUFBSSxNQUFNLE1BQU0sV0FBVyx1QkFBdUI7SUFDeEUsT0FBTyxPQUFPLGVBQWU7UUFDM0IsTUFBTSxNQUFNLFFBQVEsTUFBTSxVQUFVO1FBQ3BDLFFBQVEsTUFBTTtRQUNkO1FBQ0EsZUFBZTtJQUNqQixDQUFDO0lBRUQsT0FBTztBQUNUO0FBS08sU0FBUyxlQUFlLFlBQXNCO0lBQ25ELE9BQU87UUFDTCxZQUFZO1FBQ1osZ0JBQWdCO1FBQ2hCLFlBQVk7UUFDWixtQkFBbUI7UUFDbkIsR0FBRyxXQUFXO0lBQ2hCO0FBQ0Y7QUFLTyxTQUFTLG9CQUNkLGNBQ0EsT0FDQSxTQUNBQSxRQUFBQSxFQUNNO0lBQ04sSUFBSSxDQUFDLGFBQWM7SUFFbkIsSUFBSTtRQUNGLGFBQWEsT0FBTyxPQUFPO0lBQzdCLFNBQVMsY0FBbUI7UUFDMUJBLFNBQU8sTUFBTSwrQkFBK0I7WUFDMUMsZUFBZSxNQUFNO1lBQ3JCLGNBQWMsY0FBYyxXQUFXLE9BQU8sWUFBWTtRQUM1RCxDQUFDO0lBQ0g7QUFDRjtBQUtBLGVBQXNCLGlCQUNwQixXQUNBLGVBQ0Esa0JBQ0EsWUFDQUEsUUFBQUEsRUFDQSxzQkFDWTtJQUNaLE1BQU0sY0FBYyxlQUFlLFVBQVU7SUFDN0MsSUFBSSxZQUFpQjtJQUNyQixNQUFNLFlBQVksS0FBSyxJQUFJO0lBRTNCLFFBQVMsVUFBVSxHQUFHLFdBQVcsWUFBWSxZQUFZLFVBQVc7UUFDbEUsSUFBSTtZQUNGQSxTQUFPLE1BQU0sYUFBYSxhQUFhLGFBQWEsVUFBVSxDQUFDLEtBQUssZ0JBQWdCO1lBRXBGLE1BQU0sU0FBUyxNQUFNLFVBQVU7WUFFL0IsSUFBSSxVQUFVLEdBQUc7Z0JBQ2ZBLFNBQU8sS0FBSyxHQUFHLGFBQWEsOEJBQThCLE9BQU8sWUFBWTtvQkFDM0UsR0FBRztvQkFDSCxlQUFlLFVBQVU7b0JBQ3pCLFVBQVUsS0FBSyxJQUFJLElBQUk7Z0JBQ3pCLENBQUM7WUFDSDtZQUVBLE9BQU87UUFDVCxTQUFTLE9BQVk7WUFDbkIsWUFBWTtZQUdaLElBQUksc0JBQXNCO2dCQUN4QixNQUFNLGdCQUFnQixxQkFBcUIsS0FBSztnQkFDaEQsSUFBSSxrQkFBa0IsUUFBUTtvQkFDNUIsT0FBTztnQkFDVDtZQUNGO1lBR0EsSUFBSSxZQUFZLFlBQVksWUFBWTtnQkFDdEM7WUFDRjtZQUdBLE1BQU0sY0FBYyxpQkFBaUIsS0FBSztZQUMxQyxJQUFJLENBQUMsYUFBYTtnQkFDaEJBLFNBQU8sTUFBTSxnQkFBZ0IsYUFBYSx5Q0FBeUM7b0JBQ2pGLEdBQUc7b0JBQ0gsY0FBYyxNQUFNO29CQUNwQixXQUFXLE1BQU0sUUFBUSxNQUFNO29CQUMvQixTQUFTLFVBQVU7Z0JBQ3JCLENBQUM7Z0JBQ0Q7WUFDRjtZQUdBLE1BQU0sUUFBUSxvQkFBb0IsU0FBUyxXQUFXO1lBRXREQSxTQUFPLFFBQVEsWUFBWSxhQUFhLHVCQUF1QixVQUFVLENBQUMsV0FBVyxLQUFLLE1BQU07Z0JBQzlGLEdBQUc7Z0JBQ0gsY0FBYyxNQUFNO2dCQUNwQixXQUFXLE1BQU0sUUFBUSxNQUFNO2dCQUMvQjtnQkFDQSxlQUFlLFVBQVU7WUFDM0IsQ0FBQztZQUdELE1BQU0sSUFBSSxRQUFRLFdBQVcsV0FBVyxTQUFTLEtBQUssQ0FBQztRQUN6RDtJQUNGO0lBR0EsTUFBTSxhQUFhLGFBQWEsV0FBVyxnQkFBZ0I7SUFHM0Qsb0JBQW9CLFdBQVcsY0FBYyxZQUFZLGtCQUFrQkEsUUFBTTtJQUVqRkEsU0FBTyxNQUFNLEdBQUcsYUFBYSwyQkFBMkIsWUFBWSxhQUFhLENBQUMsYUFBYTtRQUM3RixHQUFHO1FBQ0gsY0FBYyxXQUFXO1FBQ3pCLFdBQVcsV0FBVyxRQUFRLFdBQVc7UUFDekMsVUFBVSxLQUFLLElBQUksSUFBSTtRQUN2QixlQUFlLFlBQVksYUFBYTtJQUMxQyxDQUFDO0lBRUQsTUFBTTtBQUNSOztBQ2hMQSxJQUFNQSxVQUFTLGVBQVUsSUFBSSxjQUFjLE9BQU8sUUFBUTtBQUVuRCxJQUFNLHFCQUFxQixDQVE5QixLQUNBLFlBQ0E7SUFJRixNQUFNLFNBQVMsT0FDYixNQUNBLFlBQWtELENBQUM7UUFFbkQsTUFBTSxpQkFBaUIsT0FBTyxPQUFPLENBQUMsR0FBRyxXQUFXLGFBQWE7WUFBRSxpQkFBaUIsV0FBVztRQUFtQixDQUFDO1FBQ25IQSxRQUFPLFFBQVEsVUFBVTtZQUFFO1lBQU07WUFBVztRQUFlLENBQUM7UUFDNUQsVUFBVSxnQkFBZ0IsU0FBUztRQUVuQyxNQUFNLE1BQTRDO1FBQ2xELE1BQU0sbUJBQW1CO1lBQ3ZCLFdBQVc7WUFDWCxNQUFNLFVBQVUsUUFBUSxHQUFHO1lBQzNCLFVBQVUsT0FBTztZQUNqQixjQUFjLFVBQVUsU0FBUztRQUNuQztRQUdBLE1BQU0sY0FBYztZQUNsQixZQUFZO1lBQ1osZ0JBQWdCO1lBQ2hCLFlBQVk7WUFDWixtQkFBbUI7WUFDbkIsR0FBRyxXQUFXO1FBQ2hCO1FBRUEsSUFBSSxZQUFpQjtRQUNyQixNQUFNLFlBQVksS0FBSyxJQUFJO1FBRTNCLFFBQVMsVUFBVSxHQUFHLFdBQVcsWUFBWSxZQUFZLFVBQVc7WUFDbEUsSUFBSTtnQkFDRkEsUUFBTyxNQUFNLDBCQUEwQixVQUFVLENBQUMsS0FBSyxnQkFBZ0I7Z0JBRXZFLE1BQU0sU0FBUyxNQUFNLFVBQVUsV0FBVyxJQUFJLFNBQzVDLFVBQVUsUUFBUSxHQUFHLEdBQ3JCLE1BQ0E7Z0JBR0YsTUFBTSxVQUFhLFVBQVUsV0FBVyxNQUFNO2dCQUU5QyxJQUFJLFVBQVUsR0FBRztvQkFDZkEsUUFBTyxLQUFLLG9DQUFvQyxPQUFPLFlBQVk7d0JBQ2pFLEdBQUc7d0JBQ0gsZUFBZSxVQUFVO3dCQUN6QixVQUFVLEtBQUssSUFBSSxJQUFJO29CQUN6QixDQUFDO2dCQUNIO2dCQUVBLE9BQU87WUFDVCxTQUFTLE9BQVk7Z0JBQ25CLFlBQVk7Z0JBR1osSUFBSSxZQUFZLFlBQVksWUFBWTtvQkFDdEM7Z0JBQ0Y7Z0JBR0EsTUFBTSxjQUFjLGlCQUFpQixLQUFLO2dCQUMxQyxJQUFJLENBQUMsYUFBYTtvQkFDaEJBLFFBQU8sTUFBTSw0REFBNEQ7d0JBQ3ZFLEdBQUc7d0JBQ0gsY0FBYyxNQUFNO3dCQUNwQixXQUFXLE1BQU0sUUFBUSxNQUFNO3dCQUMvQixTQUFTLFVBQVU7b0JBQ3JCLENBQUM7b0JBQ0Q7Z0JBQ0Y7Z0JBR0EsTUFBTSxRQUFRLG9CQUFvQixTQUFTLFdBQVc7Z0JBRXREQSxRQUFPLFFBQVEsc0NBQXNDLFVBQVUsQ0FBQyxXQUFXLEtBQUssTUFBTTtvQkFDcEYsR0FBRztvQkFDSCxjQUFjLE1BQU07b0JBQ3BCLFdBQVcsTUFBTSxRQUFRLE1BQU07b0JBQy9CO29CQUNBLGVBQWUsVUFBVTtnQkFDM0IsQ0FBQztnQkFHRCxNQUFNLElBQUksUUFBUSxXQUFXLFdBQVcsU0FBUyxLQUFLLENBQUM7WUFDekQ7UUFDRjtRQUdBLE1BQU0sYUFBYSxhQUFhLFdBQVcsZ0JBQWdCO1FBRzNELElBQUksV0FBVyxjQUFjO1lBQzNCLElBQUk7Z0JBQ0YsV0FBVyxhQUFhLFlBQVksZ0JBQWdCO1lBQ3RELFNBQVMsY0FBbUI7Z0JBQzFCQSxRQUFPLE1BQU0sK0JBQStCO29CQUMxQyxlQUFlLFdBQVc7b0JBQzFCLGNBQWMsY0FBYyxXQUFXLE9BQU8sWUFBWTtnQkFDNUQsQ0FBQztZQUNIO1FBQ0Y7UUFFQUEsUUFBTyxNQUFNLGlDQUFpQyxZQUFZLGFBQWEsQ0FBQyxhQUFhO1lBQ25GLEdBQUc7WUFDSCxjQUFjLFdBQVc7WUFDekIsV0FBVyxXQUFXLFFBQVEsV0FBVztZQUN6QyxVQUFVLEtBQUssSUFBSSxJQUFJO1lBQ3ZCLGVBQWUsWUFBWSxhQUFhO1FBQzFDLENBQUM7UUFFRCxNQUFNO0lBQ1I7SUFFQSxPQUFPO0FBQ1Q7O0FDaElBLElBQU1BLFVBQVMsZUFBVSxJQUFJLGNBQWMsT0FBTyxRQUFRO0FBRW5ELElBQU0scUJBQXFCLENBUTlCLEtBQ0EsWUFDQTtJQUlGLE1BQU0sU0FBUyxPQUNiLElBQ0E7UUFFQSxNQUFNLGlCQUFpQixPQUFPLE9BQU8sQ0FBQyxHQUFHLFdBQVcsWUFBWTtZQUFFLGlCQUFpQixXQUFXO1FBQW1CLENBQUM7UUFDbEhBLFFBQU8sUUFBUSxVQUFVO1lBQUU7WUFBSTtZQUFNO1FBQWUsQ0FBQztRQUVyRCxPQUFPLFVBQVUsV0FBVyxNQUFNLFVBQVUsV0FDMUMsSUFBSSxRQUNGLFVBQVUsUUFBUSxFQUFFLEdBQ3BCLE1BQ0E7SUFFTjtJQUVBLE9BQU87QUFDVDs7QUMvQkEsSUFBTUEsVUFBUyxlQUFVLElBQUksY0FBYyxPQUFPLEtBQUs7QUFFaEQsSUFBTSxrQkFBa0IsQ0FRM0IsS0FDQSxZQUNBO0lBSUYsTUFBTSxNQUFNLE9BQ1Y7UUFFQSxNQUFNLGlCQUFpQixPQUFPLE9BQU8sQ0FBQyxHQUFHLFdBQVcsWUFBWTtZQUFFLGlCQUFpQixXQUFXO1FBQWtCLENBQUM7UUFDakhBLFFBQU8sUUFBUSxPQUFPO1lBQUU7WUFBSTtRQUFlLENBQUM7UUFFNUMsTUFBTSxtQkFBbUI7WUFDdkIsV0FBVztZQUNYLE1BQU0sVUFBVSxRQUFRLEVBQUU7WUFDMUIsU0FBUyxPQUFPO1FBQ2xCO1FBRUEsTUFBTSxjQUFjO1lBQ2xCLFlBQVk7WUFDWixnQkFBZ0I7WUFDaEIsWUFBWTtZQUNaLG1CQUFtQjtZQUNuQixHQUFHLFdBQVc7UUFDaEI7UUFFQSxJQUFJLFlBQWlCO1FBQ3JCLE1BQU0sWUFBWSxLQUFLLElBQUk7UUFFM0IsUUFBUyxVQUFVLEdBQUcsV0FBVyxZQUFZLFlBQVksVUFBVztZQUNsRSxJQUFJO2dCQUNGQSxRQUFPLE1BQU0seUJBQXlCLFVBQVUsQ0FBQyxLQUFLLGdCQUFnQjtnQkFFdEUsTUFBTSxTQUFTLE1BQU0sVUFBVSxXQUM3QixJQUFJLFFBQ0YsVUFBVSxRQUFRLEVBQUUsR0FDcEI7Z0JBSUosTUFBTSxPQUFPLFVBQVUsV0FBVyxNQUFNO2dCQUV4QyxJQUFJLFVBQVUsR0FBRztvQkFDZkEsUUFBTyxLQUFLLGlDQUFpQyxPQUFPLFlBQVk7d0JBQzlELEdBQUc7d0JBQ0gsZUFBZSxVQUFVO3dCQUN6QixVQUFVLEtBQUssSUFBSSxJQUFJO29CQUN6QixDQUFDO2dCQUNIO2dCQUVBLE9BQU87WUFDVCxTQUFTLE9BQVk7Z0JBQ25CLFlBQVk7Z0JBR1osSUFBSSxNQUFNLFdBQVcsS0FBSztvQkFDeEJBLFFBQU8sTUFBTSx3QkFBd0IsZ0JBQWdCO29CQUNyRCxPQUFPO2dCQUNUO2dCQUVBLElBQUksWUFBWSxZQUFZLFlBQVk7b0JBQ3RDO2dCQUNGO2dCQUVBLE1BQU0sY0FBYyxpQkFBaUIsS0FBSztnQkFDMUMsSUFBSSxDQUFDLGFBQWE7b0JBQ2hCQSxRQUFPLE1BQU0seURBQXlEO3dCQUNwRSxHQUFHO3dCQUNILGNBQWMsTUFBTTt3QkFDcEIsV0FBVyxNQUFNLFFBQVEsTUFBTTt3QkFDL0IsU0FBUyxVQUFVO29CQUNyQixDQUFDO29CQUNEO2dCQUNGO2dCQUVBLE1BQU0sUUFBUSxvQkFBb0IsU0FBUyxXQUFXO2dCQUV0REEsUUFBTyxRQUFRLG1DQUFtQyxVQUFVLENBQUMsV0FBVyxLQUFLLE1BQU07b0JBQ2pGLEdBQUc7b0JBQ0gsY0FBYyxNQUFNO29CQUNwQixXQUFXLE1BQU0sUUFBUSxNQUFNO29CQUMvQjtvQkFDQSxlQUFlLFVBQVU7Z0JBQzNCLENBQUM7Z0JBRUQsTUFBTSxJQUFJLFFBQVEsV0FBVyxXQUFXLFNBQVMsS0FBSyxDQUFDO1lBQ3pEO1FBQ0Y7UUFFQSxNQUFNLGFBQWEsYUFBYSxXQUFXLGdCQUFnQjtRQUUzRCxJQUFJLFdBQVcsY0FBYztZQUMzQixJQUFJO2dCQUNGLFdBQVcsYUFBYSxZQUFZLGdCQUFnQjtZQUN0RCxTQUFTLGNBQW1CO2dCQUMxQkEsUUFBTyxNQUFNLCtCQUErQjtvQkFDMUMsZUFBZSxXQUFXO29CQUMxQixjQUFjLGNBQWMsV0FBVyxPQUFPLFlBQVk7Z0JBQzVELENBQUM7WUFDSDtRQUNGO1FBRUFBLFFBQU8sTUFBTSw4QkFBOEIsWUFBWSxhQUFhLENBQUMsYUFBYTtZQUNoRixHQUFHO1lBQ0gsY0FBYyxXQUFXO1lBQ3pCLFdBQVcsV0FBVyxRQUFRLFdBQVc7WUFDekMsVUFBVSxLQUFLLElBQUksSUFBSTtZQUN2QixlQUFlLFlBQVksYUFBYTtRQUMxQyxDQUFDO1FBRUQsTUFBTTtJQUNSO0lBRUEsT0FBTztBQUNUOztBQzdIQSxJQUFNQSxVQUFTLGVBQVUsSUFBSSxjQUFjLE9BQU8sUUFBUTtBQUVuRCxJQUFNLHFCQUFxQixDQVE5QixLQUNBLFlBQ0E7SUFJRixNQUFNLFNBQVMsT0FDYjtRQUVBLE1BQU0saUJBQWlCLE9BQU8sT0FBTyxDQUFDLEdBQUcsV0FBVyxlQUFlO1lBQUUsaUJBQWlCLFdBQVc7UUFBbUIsQ0FBQztRQUNySEEsUUFBTyxRQUFRLFVBQVU7WUFBRTtZQUFJO1FBQWUsQ0FBQztRQUUvQyxPQUFPLElBQUksV0FBb0IsVUFBVSxRQUFRLEVBQUUsR0FBRyxjQUFjO0lBQ3RFO0lBRUEsT0FBTztBQUNUOztBQ3pCQSxJQUFNQSxVQUFTLGVBQVUsSUFBSSxjQUFjLE9BQU8sTUFBTTtBQUVqRCxJQUFNLG1CQUFtQixDQVE1QixLQUNBLFlBQ0E7SUFJRixNQUFNLE9BQU8sT0FDWCxRQUNBLGVBQTJHLENBQUMsR0FDNUcsWUFBa0QsQ0FBQztRQUVuRCxVQUFVLGdCQUFnQixTQUFTO1FBQ25DLE1BQU0sTUFBNEM7UUFFbEQsTUFBTSxlQUE0QixlQUFlLFFBQVEsWUFBWTtRQUNyRSxNQUFNLGlCQUFpQixPQUFPLE9BQU8sQ0FBQyxHQUFHLFdBQVcsWUFBWTtZQUFFLGlCQUFpQixXQUFXO1lBQWtCLFFBQVE7UUFBYSxDQUFDO1FBQ3RJQSxRQUFPLFFBQVEsUUFBUTtZQUFFO1lBQVE7WUFBYztZQUFXO1FBQWUsQ0FBQztRQUUxRSxPQUFPLFVBQVUsV0FBVyxNQUFNLFVBQVUsYUFDMUMsSUFBSSxRQUNGLFVBQVUsUUFBUSxHQUFHLEdBQ3JCO0lBRU47SUFFQSxPQUFPO0FBQ1Q7O0FDcENBLElBQU1BLFdBQVMsZUFBVSxJQUFJLGNBQWMsT0FBTyxNQUFNO0FBRWpELElBQU0sc0JBQXNCLENBUS9CLEtBQ0EsWUFDQTtJQUlGLE1BQU0sVUFBVSxPQUNkLFFBQ0EsZUFBMkcsQ0FBQyxHQUM1RyxZQUFrRCxDQUFDO1FBRW5ELFVBQVUsZ0JBQWdCLFNBQVM7UUFDbkMsTUFBTSxNQUE0QztRQUVsRCxNQUFNLFNBQXNCLGVBQWUsUUFBUSxZQUFZO1FBQy9ELE9BQU8sTUFBTTtRQUViLE1BQU0saUJBQWlCLE9BQU8sT0FBTyxDQUFDLEdBQUcsV0FBVyxZQUFZO1lBQUUsaUJBQWlCLFdBQVc7WUFBa0I7UUFBTyxDQUFDO1FBQ3hIQSxTQUFPLFFBQVEsV0FBVztZQUFFO1lBQVE7WUFBYztZQUFXO1FBQWUsQ0FBQztRQUU3RSxPQUFRLFVBQVUsV0FBVyxNQUFNLFVBQVUsYUFDM0MsSUFBSSxRQUNGLFVBQVUsUUFBUSxHQUFHLEdBQ3JCLGlCQUNBLENBQVUsQ0FBQztJQUNqQjtJQUVBLE9BQU87QUFDVDs7QUN2Q0EsSUFBTUEsV0FBUyxlQUFVLElBQUksY0FBYyxPQUFPLE9BQU87QUFFbEQsSUFBTSxvQkFBb0IsQ0FRN0IsS0FDQSxZQUNBO0lBa0JGLE1BQU0sUUFBUSxPQUNaLElBQ0FHLFFBQ0EsU0FBcUcsQ0FBQztRQUV0RyxNQUFNLGlCQUFpQixPQUFPLE9BQU8sQ0FBQyxHQUFHLFdBQVcsWUFBWTtZQUFFLGlCQUFpQixXQUFXO1lBQW9CO1FBQU8sQ0FBQztRQUMxSEgsU0FBTyxRQUFRLFNBQVM7WUFBRTtZQUFJLE9BQUFHO1lBQU87UUFBZSxDQUFDO1FBRXJELE9BQU8sSUFBSSxRQUNULEdBQUcsVUFBVSxRQUFRLEVBQUUsQ0FBQyxJQUFJQSxNQUFLLElBQ2pDO0lBR0o7SUFFQSxPQUFPO0FBQ1Q7O0FDL0NBLElBQU1ILFdBQVMsZUFBVSxJQUFJLGNBQWMsT0FBTyxVQUFVO0FBRXJELElBQU0sdUJBQXVCLENBUWhDLEtBQ0EsWUFDQTtJQUlGLE1BQU0sV0FBVyxPQUNmLE9BQ0EsU0FBcUcsQ0FBQyxHQUN0RyxZQUFrRCxDQUFDO1FBRW5ELE1BQU0saUJBQWlCLE9BQU8sT0FBTyxDQUFDLEdBQUcsV0FBVyxZQUFZO1lBQUUsaUJBQWlCLFdBQVc7WUFBb0I7UUFBTyxDQUFDO1FBQzFIQSxTQUFPLFFBQVEsWUFBWTtZQUFFO1lBQU87WUFBVztRQUFlLENBQUM7UUFDL0QsVUFBVSxnQkFBZ0IsU0FBUztRQUVuQyxNQUFNLE1BQTRDO1FBR2xELE9BQU8sSUFBSSxRQUNULEdBQUcsVUFBVSxRQUFRLEdBQUcsQ0FBQyxJQUFJLEtBQUssSUFDbEM7SUFFSjtJQUVBLE9BQU87QUFDVDs7QUMxQk8sSUFBTSxnQkFDWCxDQVFJLEtBQ0EsWUFDQTtJQUdGLE9BQU87UUFDTCxRQUFRLG1CQUNOLEtBQ0EsWUFDQTtRQUVGLEtBQUssZ0JBQ0gsS0FDQSxZQUNBO1FBRUYsV0FBVyxzQkFDVCxLQUNBLFlBQ0E7UUFFRixVQUFVLHFCQUNSLEtBQ0EsWUFDQTtRQUVGLFFBQVEsbUJBQ04sS0FDQSxZQUNBO1FBRUYsT0FBTyxrQkFDTCxLQUNBLFlBQ0E7UUFFRixTQUFTLG9CQUNQLEtBQ0EsWUFDQTtRQUVGLE1BQU0saUJBQ0osS0FDQSxZQUNBO1FBRUYsS0FBSyxnQkFDSCxLQUNBLFlBQ0E7UUFFRixLQUFLLGdCQUNILEtBQ0EsWUFDQTtRQUVGLFFBQVEsbUJBQ04sS0FDQSxZQUNBO1FBRUYsUUFBUSxtQkFDTixLQUNBLFlBQ0E7SUFFSjtBQUNGOztBQ3RGSztBQUdlO0FBRXRCLElBQU1BLFdBQVMsZUFBVSxJQUFJLGNBQWMsU0FBUztBQW9CN0MsSUFBTSxrQkFBa0IsQ0FRN0IsUUFBVztJQUVYQSxTQUFPLFFBQVEsbUJBQW1CO1FBQUU7UUFBUTtJQUFVLENBQUM7SUFFdkQsTUFBTSxrQkFBa0IsQ0FDdEI7UUFHQSxJQUFJLGFBQWEsVUFBVSxTQUFTLFVBQVUsU0FBUyxHQUFHO1lBQ3hELE1BQU0sSUFBSSxNQUFNLG1EQUNaLFVBQVUsU0FBUyxnQkFBZ0IsVUFBVSxNQUFNO1FBQ3pEO1FBQ0EsT0FBTztJQUNUO0lBRUEsTUFBTSxhQUFhLE9BQ2pCO1FBRUFBLFNBQU8sUUFBUSxjQUFjO1lBQUU7UUFBUSxDQUFDO1FBQ3hDLE1BQU0sV0FBVyxNQUFNO1FBQ3ZCQSxTQUFPLFFBQVEsdUJBQXVCO1lBQ3BDLGNBQWMsT0FBTztZQUNyQixTQUFTLENBQUMsQ0FBQztRQUNiLENBQUM7UUFDRCxPQUFPLFdBQVcsUUFBUTtJQUM1QjtJQUVBLE1BQU0sZUFBZSxPQUNuQjtRQUVBQSxTQUFPLFFBQVEsZ0JBQWdCO1lBQUU7UUFBSSxDQUFDO1FBQ3RDLE1BQU0sV0FBVyxNQUFNO1FBQ3ZCQSxTQUFPLFFBQVEseUJBQXlCO1lBQ3RDLGNBQWMsT0FBTztZQUNyQixTQUFTLE1BQU0sUUFBUSxRQUFRO1lBQy9CLFFBQVEsTUFBTSxRQUFRLFFBQVEsSUFBSSxTQUFTLFNBQVM7UUFDdEQsQ0FBQztRQUNELElBQUksWUFBWSxNQUFNLFFBQVEsUUFBUSxHQUFHO1lBQ3ZDLE9BQU8sU0FBUyxJQUFJLENBQUMsY0FDbkIsV0FBVyxXQUFXO1FBRTFCLE9BQU87WUFDTEEsU0FBTyxNQUFNLDZCQUE2QjtnQkFBRTtZQUFTLENBQUM7WUFDdEQsTUFBTSxJQUFJLE1BQU0sMkJBQTJCO1FBQzdDO0lBQ0Y7SUFFQSxNQUFNLGFBQWEsQ0FBQztRQUNsQkEsU0FBTyxRQUFRLGNBQWM7WUFBRTtRQUFJLENBQUM7UUFFcEMsSUFBSSxPQUFPLElBQUksUUFBUTtZQUNyQixNQUFNLFNBQVMsSUFBSTtZQUNuQixVQUFXLE9BQU8sT0FBUTtnQkFDeEIsT0FBTyxHQUFHLElBQUksc0NBQVMsQ0FBQyxPQUFPLEdBQUcsR0FBRztvQkFBRSxJQUFJLE9BQU8sR0FBRyxFQUFFLEtBQUssSUFBSSxLQUFLLE9BQU8sR0FBRyxFQUFFLEVBQUUsSUFBSTtnQkFBSyxDQUFDO1lBQy9GO1lBRUEsT0FBTztRQUNULE9BQU87WUFDTCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQU0sVUFDSixDQUNFO1FBSUEsTUFBTSxpQkFBaUIsQ0FBQztlQUFHLFNBQVM7U0FBQTtRQUNwQ0EsU0FBTyxRQUFRLFdBQVc7WUFBRTtZQUFLLFdBQVc7UUFBZSxDQUFDO1FBSTVELE1BQU0sT0FBTyw2REFBZ0IsQ0FBQyxHQUFHO1FBS2pDLElBQUksT0FBZSxRQUFRLElBQUksTUFBTSxjQUFjO1FBSW5ELElBQUksZUFBZSxXQUFXLEdBQUc7WUFDL0IsT0FBTyxHQUFHLElBQUksSUFBSSxlQUFlLENBQUMsQ0FBQztRQUNyQztRQUVBQSxTQUFPLFFBQVEsbUJBQW1CO1lBQUU7WUFBSztRQUFLLENBQUM7UUFFL0MsT0FBTztJQUNUO0lBRUYsTUFBTSxVQUFVLENBQ2QsTUFDQSxNQUNBO1FBRUFBLFNBQU8sUUFBUSxXQUFXO1lBQUU7WUFBTTtZQUFNLFdBQVc7UUFBZSxDQUFDO1FBQ25FLElBQUksS0FBSyxTQUFTLGVBQWUsU0FBUyxHQUFHO1lBQzNDQSxTQUFPLE1BQU0sc0ZBQ1g7Z0JBQUU7Z0JBQU07WUFBZTtZQUN6QixNQUFNLElBQUksTUFBTSx5RkFDWixLQUFLLFNBQVMsTUFBTSxlQUFlLFNBQVMsTUFBTSxLQUFLLFVBQVUsTUFBTSxjQUFjLENBQUM7UUFDNUYsV0FBVyxLQUFLLFNBQVMsZUFBZSxRQUFRO1lBQzlDQSxTQUFPLE1BQU0scUZBQ1g7Z0JBQUU7Z0JBQU07WUFBVTtZQUNwQixNQUFNLElBQUksTUFBTSx3RkFDWixLQUFLLFNBQVMsTUFBTSxlQUFlLFNBQVMsTUFBTSxLQUFLLFVBQVUsTUFBTSxjQUFjLENBQUM7UUFDNUY7UUFDQSxJQUFJLEtBQUssV0FBVyxHQUFHO1lBRXJCQSxTQUFPLFFBQVEsMEJBQTBCO2dCQUFFO1lBQUssQ0FBQztZQUNqRCxPQUFPO1FBQ1QsT0FBTztZQUVMLElBQUk7WUFDSixNQUFNLE1BQU0sS0FBSyxJQUFJO1lBQ3JCLE1BQU0sV0FBVyxlQUFlLElBQUk7WUFDcEMsSUFBSSxxREFBUSxDQUFDLEdBQUcsR0FBRztnQkFDakIsTUFBTUksVUFBUztnQkFDZixXQUFXLEdBQUcsSUFBSSxJQUFJLFFBQVEsSUFBSUEsUUFBTyxFQUFFO2dCQUMzQ0osU0FBTyxRQUFRLHNCQUFzQjtvQkFBRTtvQkFBVSxRQUFBSTtvQkFBUTtnQkFBUyxDQUFDO1lBQ3JFLE9BQU87Z0JBQ0wsTUFBTUMsVUFBUztnQkFDZixXQUFXLEdBQUcsSUFBSSxJQUFJLFFBQVEsSUFBSUEsUUFBTyxFQUFFO2dCQUMzQ0wsU0FBTyxRQUFRLGdDQUFnQztvQkFBRTtvQkFBVSxRQUFBSztnQkFBTyxDQUFDO1lBQ3JFO1lBRUFMLFNBQU8sUUFBUSwrQkFBK0I7Z0JBQUU7Z0JBQVU7Z0JBQU07WUFBZSxDQUFDO1lBQ2hGLE9BQU8sUUFBUSxVQUFVLE1BQU0sY0FBYztRQUMvQztJQUVGO0lBRUEsTUFBTSxhQUFhLENBQ2pCO1FBRUEsT0FBTyx1REFBYyxDQUF3QixNQUFNLE1BQU07SUFDM0Q7SUFFQSxPQUFPO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0lBQ0Y7QUFDRjs7QUNsTEEsSUFBTUEsV0FBUyxlQUFVLElBQUksVUFBVTtBQXFCaEMsSUFBTSxpQkFBaUIsQ0FDNUIsUUFDQTtJQUVBLE9BQU87UUFDTDtRQUNBLGNBQWMsS0FBSyxVQUFVLFlBQVk7SUFDM0M7QUFDRjtBQUVPLElBQU0saUJBQWlCLENBUzVCLEtBQ0EsUUFDQSxXQUNBO0lBR0FBLFNBQU8sUUFBUSxrQkFBa0I7UUFBRTtRQUFRO1FBQVc7SUFBUSxDQUFDO0lBRS9ELElBQUk7SUFFSixNQUFNLGlCQUFtQztRQUN2QyxtQkFBbUI7UUFDbkIsa0JBQWtCO1FBQ2xCLG9CQUFvQjtRQUNwQixZQUFZLENBQUM7UUFDYixhQUFhLENBQUM7UUFDZCxZQUFZLENBQUM7UUFDYixlQUFlLENBQUM7SUFDbEI7SUFFQSxJQUFJLFNBQVM7UUFDWCxnQkFBZ0IsT0FBTyxPQUFPLENBQUMsR0FBRyxnQkFBZ0IsT0FBTztJQUMzRCxPQUFPO1FBQ0wsZ0JBQWdCO0lBQ2xCO0lBRUEsTUFBTSxZQUFZLGdCQUEwQyxRQUFRLFNBQVM7SUFDN0UsTUFBTSxhQUFhLGNBQXdDLEtBQUssZUFBZSxTQUFTO0lBRXhGLE9BQU87UUFDTCxRQUFRLFdBQVc7UUFDbkIsS0FBSyxXQUFXO1FBQ2hCLFdBQVcsV0FBVztRQUN0QixVQUFVLFdBQVc7UUFDckIsUUFBUSxXQUFXO1FBQ25CLE9BQU8sV0FBVztRQUNsQixNQUFNLFdBQVc7UUFDakIsU0FBUyxXQUFXO1FBQ3BCLEtBQUssV0FBVztRQUNoQixLQUFLLFdBQVc7UUFDaEIsUUFBUSxXQUFXO1FBQ25CLFFBQVEsV0FBVztJQUNyQjtBQUNGOztBQzdFQSxJQUFNQSxXQUFTLGVBQVUsSUFBSSxVQUFVO0FBNkRoQyxJQUFNLGlCQUFpQixDQVE1QixLQUFjLE1BQVMsV0FBK0M7SUFFdEVBLFNBQU8sUUFBUSxrQkFBa0I7UUFBRTtRQUFLO1FBQU07UUFBVztJQUFRLENBQUM7SUFFbEUsTUFBTSxXQUFXLGVBQWUsS0FBSyxNQUFNLFdBQVcsT0FBTztJQUU3RCxPQUFPO1FBQ0wsUUFBUSxTQUFTO1FBQ2pCLEtBQUssU0FBUztRQUNkLFdBQVcsU0FBUztRQUNwQixVQUFVLFNBQVM7UUFDbkIsS0FBSyxTQUFTO1FBQ2QsS0FBSyxTQUFTO1FBQ2QsUUFBUSxTQUFTO1FBQ2pCLFFBQVEsU0FBUztRQUNqQixRQUFRLFNBQVM7UUFDakIsT0FBTyxTQUFTO1FBQ2hCLE1BQU0sU0FBUztRQUNmLFNBQVMsU0FBUztJQUNwQjtBQUNGOztBQ25HQSxJQUFNQSxXQUFTLGVBQVUsSUFBSSxVQUFVO0FBaUVoQyxJQUFNLGlCQUFpQixDQUM1QixLQUNBLE1BQ0EsVUFDQTtJQUdBQSxTQUFPLFFBQVEsa0JBQWtCO1FBQUU7UUFBTTtRQUFVO0lBQVEsQ0FBQztJQUU1RCxNQUFNLFdBQVcsZUFBcUIsS0FBSyxNQUFNO1FBQUMsUUFBUTtLQUFBLEVBQUcsT0FBTztJQUVwRSxNQUFNLFNBQ0osT0FDRSxJQUNBQyxTQUNBLE9BQVksQ0FBQyxJQUViLE1BQU0sU0FBUyxPQUFPLElBQUlBLFNBQVEsSUFBSTtJQUUxQyxNQUFNLE1BQ0osT0FDRSxRQUFtQixDQUFDLElBRXBCLE1BQU0sU0FBUyxJQUFJLE9BQU8sQ0FBQyxDQUFDO0lBRWhDLE1BQU0sWUFDSixPQUNFQSxTQUNBLE9BQVksQ0FBQyxJQUViLE1BQU0sU0FBUyxVQUFVQSxTQUFRLE1BQU0sQ0FBQyxDQUFDO0lBRTdDLE1BQU0sV0FDSixPQUNFRSxRQUNBLFNBQXFHLENBQUMsSUFFdEcsTUFBTSxTQUFTLFNBQVNBLFFBQU8sTUFBTTtJQUV6QyxNQUFNLE1BQ0osT0FDRSxRQUFtQixDQUFDLElBRXBCLE1BQU0sU0FBUyxJQUFJLE9BQU8sQ0FBQyxDQUFDO0lBRWhDLE1BQU0sTUFDSixPQUNFLEtBRUEsTUFBTSxTQUFTLElBQUksRUFBRTtJQUV6QixNQUFNLFNBQ0osT0FDRSxPQUVBLE1BQU0sU0FBUyxPQUFPLE1BQU0sQ0FBQyxDQUFDO0lBRWxDLE1BQU0sU0FDSixPQUNFLEtBRUEsTUFBTSxTQUFTLE9BQU8sRUFBRTtJQUU1QixNQUFNLFNBQ0osT0FDRSxJQUNBLE9BRUEsTUFBTSxTQUFTLE9BQU8sSUFBSSxJQUFJO0lBRWxDLE1BQU0sUUFDSixPQUNFLElBQ0FBLFFBQ0EsU0FBcUcsQ0FBQyxJQUV0RyxNQUFNLFNBQVMsTUFBTSxJQUFJQSxRQUFPLE1BQU07SUFFMUMsTUFBTSxPQUNKLE9BQ0UsUUFDQSxlQUEyRyxDQUFDLElBRTVHLE1BQU0sU0FBUyxLQUFLLFFBQVEsWUFBWTtJQUU1QyxNQUFNLFVBQ0osT0FDRSxRQUNBLGVBQTJHLENBQUMsSUFFNUcsTUFBTSxTQUFTLFFBQVEsUUFBUSxZQUFZO0lBRS9DLE9BQU87UUFDTCxHQUFHO1FBQ0g7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0lBQ0Y7QUFFRjs7QUNqTHFHO0FBR3JHLElBQU1ILFdBQVMsZUFBVSxJQUFJLFVBQVU7QUEwQmhDLElBQU0saUJBQWlCLENBUzFCLFVBQ0EsWUFDQTtJQUVGQSxTQUFPLE1BQU0sa0JBQWtCO1FBQUU7UUFBWTtRQUFXO0lBQVMsQ0FBQztJQUNsRSxNQUFNLGVBQWUsK0RBQWtCLENBQUMsVUFBVSxVQUFVO0lBQzVELE9BQU87UUFBRSxHQUFHO1FBQWM7SUFBVTtBQUN0Qzs7QUN6Q0EsSUFBTUEsV0FBUyxlQUFVLElBQUksaUJBQWlCO0FBaUJ2QyxJQUFNLHdCQUF3QixDQVNqQztJQUVGLE9BQU8sQ0FBQyxZQUErQztRQUNyREEsU0FBTyxNQUFNLGdDQUFnQztZQUFFO1lBQVksVUFBVSxRQUFRO1lBQVU7UUFBVSxDQUFDO1FBRWxHLE9BQU8sZUFBZSxRQUFRLFVBQVUsWUFBWSxTQUFTO0lBQy9EO0FBQ0Y7O0FDbENPO0FBRVAsSUFBTUEsV0FBUyxlQUFVLElBQUksVUFBVTtBQVloQyxJQUFNLHdCQUF3QjtJQUNuQyxPQUFPLENBQUMsTUFBYztRQUNwQixJQUFJLFNBQVMsY0FBYztZQUN6QixNQUFNLElBQUksTUFBTSxrRkFBa0YsSUFBSSxFQUFFO1FBQzFHO1FBRUFBLFNBQU8sTUFBTSxnQ0FBZ0M7WUFBRTtZQUFNO1FBQVksQ0FBQztRQUVsRSxNQUFNLGVBQWUsK0RBQWtCLENBQUMsTUFBTSxXQUFXO1FBR3pELE9BQU87SUFDVDtBQUNGO0FBS08sSUFBTSxpQkFBaUIsQ0FBQztJQUM3QixNQUFNLGVBQWUsK0RBQWtCLENBQUMsY0FBYyxXQUFXO0lBRWpFLE9BQU87UUFDTCxHQUFHO0lBQ0w7QUFDRjs7QUN6Q08sSUFBZSxpQkFBZixjQUFzQyxNQUFNO0lBTWpELFlBQVksU0FBaUIsUUFBK0I7UUFDMUQsTUFBTSxPQUFPO1FBQ2IsS0FBSyxPQUFPLEtBQUssWUFBWTtRQUM3QixLQUFLLFlBQVksb0JBQUksS0FBSztRQUMxQixLQUFLLFVBQVU7UUFHZixPQUFPLGVBQWUsTUFBTSxXQUFXLFNBQVM7SUFDbEQ7SUFFQSxTQUFTO1FBQ1AsT0FBTztZQUNMLE1BQU0sS0FBSztZQUNYLE1BQU0sS0FBSztZQUNYLFNBQVMsS0FBSztZQUNkLGFBQWEsS0FBSztZQUNsQixXQUFXLEtBQUs7WUFDaEIsU0FBUyxLQUFLO1lBQ2QsT0FBTyxLQUFLO1FBQ2Q7SUFDRjtBQUNGO0FBS08sSUFBTSxlQUFOLGNBQTJCLGVBQWU7SUFJL0MsWUFBWSxTQUFpQixRQUErQjtRQUMxRCxNQUFNLGtCQUFrQixPQUFPLElBQUksT0FBTyxRQUpuQyxPQUFPLHNCQUNQLGNBQWM7SUFJdkI7QUFDRjtBQUtPLElBQU0sZUFBTixjQUEyQixlQUFlO0lBSS9DLFlBQVksU0FBaUIsUUFBK0I7UUFDMUQsTUFBTSwyQkFBMkIsT0FBTyxNQUFNLE9BQU8sUUFKOUMsT0FBTyxzQkFDUCxjQUFjO0lBSXZCO0FBQ0Y7QUFLTyxJQUFNLHNCQUFOLGNBQWtDLGVBQWU7SUFJdEQsWUFBWSxTQUFrQixRQUErQjtRQUMzRCxNQUFNLFdBQVcsMERBQTBELE9BQU8sUUFKM0UsT0FBTyw2QkFDUCxjQUFjO0lBSXZCO0FBQ0Y7QUFLTyxJQUFNLHFCQUFOLGNBQWlDLGVBQWU7SUFJckQsWUFBWSxTQUFrQixRQUErQjtRQUMzRCxNQUFNLFdBQVcsK0NBQStDLE9BQU8sUUFKaEUsT0FBTyw0QkFDUCxjQUFjO0lBSXZCO0FBQ0Y7QUFLTyxJQUFNLGdCQUFOLGNBQTRCLGVBQWU7SUFJaEQsWUFBWSxVQUFrQixZQUFxQixRQUErQjtRQUNoRixNQUFNLFVBQVUsYUFDWixHQUFHLFFBQVEscUJBQXFCLFVBQVUsZ0JBQzFDLEdBQUcsUUFBUTtRQUNmLE1BQU0sU0FBUyxPQUFPLFFBUGYsT0FBTyx3QkFDUCxjQUFjO0lBT3ZCO0FBQ0Y7QUFLTyxJQUFNLGtCQUFOLGNBQThCLGVBQWU7SUFLbEQsWUFBWSxTQUFpQixrQkFBOEQsUUFBK0I7UUFDeEgsTUFBTSxxQkFBcUIsT0FBTyxJQUFJLE9BQU8sUUFMdEMsT0FBTyx5QkFDUCxjQUFjO1FBS3JCLEtBQUssbUJBQW1CO0lBQzFCO0FBQ0Y7QUFLTyxJQUFNLGdCQUFOLGNBQTRCLGVBQWU7SUFJaEQsWUFBWSxTQUFpQixRQUErQjtRQUMxRCxNQUFNLGFBQWEsT0FBTyxJQUFJLE9BQU8sUUFKOUIsT0FBTyx1QkFDUCxjQUFjO0lBSXZCO0FBQ0Y7QUFLTyxJQUFNLGlCQUFOLGNBQTZCLGVBQWU7SUFLakQsWUFBWSxZQUFxQixRQUErQjtRQUM5RCxNQUFNLFVBQVUsYUFDWixxQ0FBcUMsVUFBVSxhQUMvQztRQUNKLE1BQU0sU0FBUyxPQUFPLFFBUmYsT0FBTyx5QkFDUCxjQUFjO1FBUXJCLEtBQUssYUFBYTtJQUNwQjtBQUNGO0FBS08sSUFBTSxjQUFOLGNBQTBCLGVBQWU7SUFLOUMsWUFBWSxZQUFvQixTQUFrQixRQUErQjtRQUMvRSxNQUFNLFdBQVcsaUJBQWlCLFVBQVUsS0FBSyxPQUFPLFFBTGpELE9BQU8scUJBQ1AsY0FBYztRQUtyQixLQUFLLGFBQWE7SUFDcEI7QUFDRjtBQUtPLElBQU0sdUJBQU4sY0FBbUMsZUFBZTtJQUl2RCxZQUFZLFNBQWtCLFFBQStCO1FBQzNELE1BQU0sVUFBVSxVQUNaLCtDQUErQyxPQUFPLEtBQ3REO1FBQ0osTUFBTSxTQUFTLE9BQU8sUUFQZixPQUFPLGdDQUNQLGNBQWM7SUFPdkI7QUFDRjtBQUtPLElBQU0sWUFBTixjQUF3QixlQUFlO0lBTTVDLFlBQVksWUFBb0IsWUFBb0IsU0FBa0IsUUFBK0I7UUFDbkcsTUFBTSxXQUFXLGNBQWMsVUFBVSxLQUFLLFVBQVUsSUFBSSxPQUFPLFFBTjVELE9BQU87UUFPZCxLQUFLLGFBQWE7UUFDbEIsS0FBSyxhQUFhO1FBR2xCLEtBQUssY0FBYyxjQUFjO0lBQ25DO0FBQ0Y7QUFLTyxJQUFNLHFCQUFOLGNBQWlDLGVBQWU7SUFJckQsWUFBWSxTQUFpQixRQUErQjtRQUMxRCxNQUFNLHdCQUF3QixPQUFPLElBQUksT0FBTyxRQUp6QyxPQUFPLDRCQUNQLGNBQWM7SUFJdkI7QUFDRjtBQUtPLElBQU0sYUFBTixjQUF5QixlQUFlO0lBSTdDLFlBQVksU0FBaUIsUUFBK0I7UUFDMUQsTUFBTSxnQkFBZ0IsT0FBTyxJQUFJLE9BQU8sUUFKakMsT0FBTyxvQkFDUCxjQUFjO0lBSXZCO0FBQ0Y7QUFLTyxTQUFTLGdCQUNkLFlBQ0EsWUFDQSxjQUNBLFNBQ2dCO0lBQ2hCLE1BQU0sZUFBZTtRQUFFO1FBQVk7UUFBWTtRQUFjLEdBQUc7SUFBUTtJQUV4RSxPQUFRLFlBQVk7UUFDbEIsS0FBSztZQUNILElBQUksY0FBYyxrQkFBa0I7Z0JBQ2xDLE9BQU8sSUFBSSxnQkFDVCxhQUFhLFdBQVcsNkJBQ3hCLGFBQWEsa0JBQ2I7WUFFSjtZQUNBLE9BQU8sSUFBSSxnQkFBZ0IsY0FBYyxXQUFXLFlBQVksQ0FBQyxHQUFHLFlBQVk7UUFFbEYsS0FBSztZQUNILE9BQU8sSUFBSSxvQkFBb0IsY0FBYyxTQUFTLFlBQVk7UUFFcEUsS0FBSztZQUNILE9BQU8sSUFBSSxtQkFBbUIsY0FBYyxTQUFTLFlBQVk7UUFFbkUsS0FBSztZQUNILE9BQU8sSUFBSSxjQUNULGNBQWMsWUFBWSxZQUMxQixjQUFjLFlBQ2Q7UUFHSixLQUFLO1lBQ0gsT0FBTyxJQUFJLGNBQWMsY0FBYyxXQUFXLFlBQVksWUFBWTtRQUU1RSxLQUFLO1lBQ0gsT0FBTyxJQUFJLHFCQUFxQixjQUFjLFNBQVMsWUFBWTtRQUVyRSxLQUFLO1lBQUs7Z0JBQ1IsSUFBSTtnQkFDSixJQUFJLGNBQWMsWUFBWTtvQkFDNUIsYUFBYSxhQUFhO2dCQUM1QixXQUFXLFNBQVMsVUFBVSxhQUFhLEdBQUc7b0JBQzVDLGFBQWEsU0FBUyxRQUFRLFFBQVEsYUFBYSxDQUFDO2dCQUN0RDtnQkFDQSxPQUFPLElBQUksZUFBZSxZQUFZLFlBQVk7WUFDcEQ7UUFFQTtZQUNFLElBQUksY0FBYyxLQUFLO2dCQUNyQixPQUFPLElBQUksWUFBWSxZQUFZLGNBQWMsV0FBVyxZQUFZLFlBQVk7WUFDdEY7WUFFQSxPQUFPLElBQUksVUFBVSxZQUFZLFlBQVksY0FBYyxTQUFTLFlBQVk7SUFDcEY7QUFDRjtBQUtPLFNBQVMsbUJBQW1CLE9BQVksU0FBK0M7SUFDNUYsTUFBTSxlQUFlO1FBQUUsZUFBZTtRQUFPLEdBQUc7SUFBUTtJQUV4RCxJQUFJLE1BQU0sU0FBUyxrQkFBa0IsTUFBTSxTQUFTLFNBQVMsU0FBUyxHQUFHO1FBQ3ZFLE9BQU8sSUFBSSxhQUFhLE1BQU0sV0FBVyxLQUFNLFlBQVk7SUFDN0Q7SUFFQSxJQUFJLE1BQU0sU0FBUyxrQkFDakIsTUFBTSxTQUFTLGVBQ2YsTUFBTSxTQUFTLGlCQUNmLE1BQU0sU0FBUyxTQUFTLFNBQVMsR0FBRztRQUNwQyxPQUFPLElBQUksYUFBYSxNQUFNLFdBQVcsNkJBQTZCLFlBQVk7SUFDcEY7SUFHQSxPQUFPLElBQUksYUFBYSxNQUFNLFdBQVcseUJBQXlCLFlBQVk7QUFDaEY7QUFLTyxTQUFTLGlCQUFpQixPQUFxQjtJQUNwRCxPQUFPLGlCQUFpQixrQkFBa0IsTUFBTTtBQUNsRDtBQUtPLFNBQVMsaUJBQWlCLE9BQXFDO0lBQ3BFLE9BQU8saUJBQWlCO0FBQzFCOztBQ3RTQSxJQUFNQSxXQUFTO0lBQ2IsT0FBTyxDQUFDLFNBQWlCLFVBQWtCLFFBQVEsTUFBTSxTQUFTLE9BQU87SUFDekUsTUFBTSxDQUFDLFNBQWlCLFVBQWtCLFFBQVEsS0FBSyxTQUFTLE9BQU87SUFDdkUsU0FBUyxDQUFDLFNBQWlCLFVBQWtCLFFBQVEsS0FBSyxTQUFTLE9BQU87SUFDMUUsT0FBTyxDQUFDLFNBQWlCLFVBQWtCLFFBQVEsTUFBTSxTQUFTLE9BQU87QUFDM0U7QUF5QkEsSUFBTSx1QkFBOEM7SUFDbEQsWUFBWTtJQUNaLGdCQUFnQjtJQUNoQixZQUFZO0lBQ1osbUJBQW1CO0lBQ25CLGNBQWM7SUFDZCxhQUFhLENBQUMsT0FBdUI7UUFFbkMsSUFBSSxpQkFBaUIsRUFBRyxRQUFPO1FBRy9CLElBQUksTUFBTSxZQUFhLFFBQU87UUFHOUIsT0FBTztJQUNUO0lBQ0EsU0FBUyxDQUFDLE9BQXVCLGVBQXVCO1FBQ3REQSxTQUFPLFFBQVEsa0NBQWtDLGdCQUFnQixDQUFDLFdBQVcsS0FBSyxNQUFNO1lBQ3RGLFdBQVcsTUFBTTtZQUNqQixjQUFjLE1BQU07WUFDcEI7WUFDQTtRQUNGLENBQUM7SUFDSDtBQUNGO0FBS0EsSUFBTSxRQUFRLENBQUMsS0FBOEIsSUFBSSxRQUFRLFdBQVcsV0FBVyxTQUFTLEVBQUUsQ0FBQztBQUszRixTQUFTLGVBQ1AsZUFDQSxRQUNRO0lBQ1IsTUFBTSxtQkFBbUIsT0FBTyxpQkFBaUIsS0FBSyxJQUFJLE9BQU8sbUJBQW1CLGFBQWE7SUFDakcsTUFBTSxjQUFjLEtBQUssSUFBSSxrQkFBa0IsT0FBTyxVQUFVO0lBRWhFLElBQUksQ0FBQyxPQUFPLGNBQWM7UUFDeEIsT0FBTztJQUNUO0lBR0EsTUFBTSxTQUFTLE1BQU8sS0FBSyxPQUFPLElBQUk7SUFDdEMsT0FBTyxLQUFLLE1BQU0sY0FBYyxNQUFNO0FBQ3hDO0FBS08sSUFBTSxjQUFOLE1BQWtCO0lBSXZCLFlBQVksS0FBYyxjQUEyQixDQUFDLEVBQUc7UUFDdkQsS0FBSyxNQUFNO1FBQ1gsS0FBSyxjQUFjO1lBQUUsR0FBRztZQUFzQixHQUFHO1FBQVk7SUFDL0Q7SUFBQTs7R0FBQSxHQUtBLE1BQU0saUJBQ0osV0FDQSxlQUNBLFNBQ1k7UUFDWixJQUFJLFlBQW1DO1FBQ3ZDLE1BQU0sWUFBWSxLQUFLLElBQUk7UUFFM0IsUUFBUyxVQUFVLEdBQUcsV0FBVyxLQUFLLFlBQVksWUFBWSxVQUFXO1lBQ3ZFLElBQUk7Z0JBQ0ZBLFNBQU8sTUFBTSxhQUFhLGFBQWEsSUFBSTtvQkFDekMsU0FBUyxVQUFVO29CQUNuQixZQUFZLEtBQUssWUFBWSxhQUFhO29CQUMxQyxHQUFHO2dCQUNMLENBQUM7Z0JBRUQsTUFBTSxTQUFTLE1BQU0sVUFBVTtnQkFFL0IsSUFBSSxVQUFVLEdBQUc7b0JBQ2ZBLFNBQU8sS0FBSyxHQUFHLGFBQWEsb0JBQW9CLE9BQU8sWUFBWTt3QkFDakUsZUFBZSxVQUFVO3dCQUN6QixVQUFVLEtBQUssSUFBSSxJQUFJO3dCQUN2QixHQUFHO29CQUNMLENBQUM7Z0JBQ0g7Z0JBRUEsT0FBTztZQUNULFNBQVMsT0FBTztnQkFDZCxZQUFZLEtBQUssd0JBQXdCLE9BQU8sZUFBZSxPQUFPO2dCQUd0RSxJQUFJLFlBQVksS0FBSyxZQUFZLFlBQVk7b0JBQzNDO2dCQUNGO2dCQUdBLElBQUksQ0FBQyxLQUFLLFlBQVksWUFBWSxXQUFXLE9BQU8sR0FBRztvQkFDckRBLFNBQU8sTUFBTSxnQkFBZ0IsYUFBYSwrQkFBK0I7d0JBQ3ZFLFdBQVcsVUFBVTt3QkFDckIsY0FBYyxVQUFVO3dCQUN4QixTQUFTLFVBQVU7d0JBQ25CLEdBQUc7b0JBQ0wsQ0FBQztvQkFDRDtnQkFDRjtnQkFHQSxJQUFJLFFBQVEsZUFBZSxTQUFTLEtBQUssV0FBVztnQkFDcEQsSUFBSSxxQkFBcUIsa0JBQWtCLFVBQVUsWUFBWTtvQkFDL0QsUUFBUSxLQUFLLElBQUksT0FBTyxVQUFVLGFBQWEsR0FBSTtnQkFDckQ7Z0JBR0EsS0FBSyxZQUFZLFFBQVEsV0FBVyxTQUFTLEtBQUs7Z0JBR2xELE1BQU0sTUFBTSxLQUFLO1lBQ25CO1FBQ0Y7UUFHQUEsU0FBTyxNQUFNLEdBQUcsYUFBYSxpQkFBaUIsS0FBSyxZQUFZLGFBQWEsQ0FBQyxhQUFhO1lBQ3hGLFdBQVcsV0FBVztZQUN0QixjQUFjLFdBQVc7WUFDekIsVUFBVSxLQUFLLElBQUksSUFBSTtZQUN2QixHQUFHO1FBQ0wsQ0FBQztRQUVELE1BQU07SUFDUjtJQUFBOztHQUFBLEdBS1Esd0JBQ04sT0FDQSxlQUNBLFNBQ2dCO1FBQ2hCLE1BQU0sZUFBZTtZQUFFLFdBQVc7WUFBZSxHQUFHO1FBQVE7UUFHNUQsSUFBSSxpQkFBaUIsZ0JBQWdCO1lBQ25DLE9BQU87UUFDVDtRQUdBLElBQUksTUFBTSxVQUFVO1lBQ2xCLE1BQU0sRUFBRSxRQUFRLFlBQVksTUFBTSxRQUFRLElBQUksTUFBTTtZQUNwRCxPQUFPLGdCQUFnQixRQUFRLFlBQVksTUFBTTtnQkFDL0MsR0FBRztnQkFDSDtnQkFDQSxLQUFLLE1BQU0sUUFBUTtZQUNyQixDQUFDO1FBQ0g7UUFHQSxJQUFJLE1BQU0sU0FBUztZQUNqQixPQUFPLG1CQUFtQixPQUFPO2dCQUMvQixHQUFHO2dCQUNILEtBQUssTUFBTSxRQUFRO2dCQUNuQixRQUFRLE1BQU0sUUFBUTtZQUN4QixDQUFDO1FBQ0g7UUFHQSxPQUFPLG1CQUFtQixPQUFPLFlBQVk7SUFDL0M7SUFBQTs7R0FBQSxHQUtBLE1BQU0sSUFDSixLQUNBLFNBQ0EsU0FDWTtRQUNaLE9BQU8sS0FBSyxpQkFDVixJQUFNLEtBQUssSUFBSSxRQUFRLEtBQUssT0FBTyxHQUNuQyxPQUNBO1lBQUU7WUFBSyxHQUFHO1FBQVE7SUFFdEI7SUFBQTs7R0FBQSxHQUtBLE1BQU0sS0FDSixLQUNBLE1BQ0EsU0FDQSxTQUNZO1FBQ1osT0FBTyxLQUFLLGlCQUNWLElBQU0sS0FBSyxJQUFJLFNBQVMsS0FBSyxNQUFNLE9BQU8sR0FDMUMsUUFDQTtZQUFFO1lBQUssU0FBUyxDQUFDLENBQUM7WUFBTSxHQUFHO1FBQVE7SUFFdkM7SUFBQTs7R0FBQSxHQUtBLE1BQU0sSUFDSixLQUNBLE1BQ0EsU0FDQSxTQUNZO1FBQ1osT0FBTyxLQUFLLGlCQUNWLElBQU0sS0FBSyxJQUFJLFFBQVEsS0FBSyxNQUFNLE9BQU8sR0FDekMsT0FDQTtZQUFFO1lBQUssU0FBUyxDQUFDLENBQUM7WUFBTSxHQUFHO1FBQVE7SUFFdkM7SUFBQTs7R0FBQSxHQUtBLE1BQU0sT0FDSixLQUNBLFNBQ0EsU0FDWTtRQUNaLE9BQU8sS0FBSyxpQkFDVixJQUFNLEtBQUssSUFBSSxXQUFXLEtBQUssT0FBTyxHQUN0QyxVQUNBO1lBQUU7WUFBSyxHQUFHO1FBQVE7SUFFdEI7SUFBQTs7R0FBQSxHQUtBLGtCQUFrQixXQUF1QztRQUN2RCxPQUFPLE9BQU8sS0FBSyxhQUFhLFNBQVM7SUFDM0M7SUFBQTs7R0FBQSxHQUtBLGlCQUF3QztRQUN0QyxPQUFPO1lBQUUsR0FBRyxLQUFLO1FBQVk7SUFDL0I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2FsbC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9hY3Rpb24udHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvYWxsQWN0aW9uLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL29uZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9lcnJvckhhbmRsaW5nLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2NyZWF0ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy91cGRhdGUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvZ2V0LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL3JlbW92ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9maW5kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2ZpbmRPbmUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvZmFjZXQudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvYWxsRmFjZXQudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvaW5kZXgudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9VdGlsaXRpZXMudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9BSXRlbUFQSS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0NJdGVtQVBJLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvUEl0ZW1BUEkudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9JbnN0YW5jZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0luc3RhbmNlRmFjdG9yeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL1JlZ2lzdHJ5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXJyb3JzL2luZGV4LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvaHR0cC9IdHRwV3JhcHBlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICBxdWVyeVRvUGFyYW1zLFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGksIFF1ZXJ5UGFyYW1zIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdhbGwnKTtcblxuZXhwb3J0IGNvbnN0IGdldEFsbE9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IGFsbCA9IGFzeW5jIChcbiAgICBxdWVyeTogSXRlbVF1ZXJ5ID0ge30gYXMgSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICB1dGlsaXRpZXMudmVyaWZ5TG9jYXRpb25zKGxvY2F0aW9ucyk7XG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBwYXJhbXM6IFF1ZXJ5UGFyYW1zID0gcXVlcnlUb1BhcmFtcyhxdWVyeSk7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLmFsbEF1dGhlbnRpY2F0ZWQsIHBhcmFtcyB9KTtcblxuICAgIGxvZ2dlci5kZWZhdWx0KCdhbGwnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMsIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIHV0aWxpdGllcy52YWxpZGF0ZVBLKGF3YWl0IHV0aWxpdGllcy5wcm9jZXNzQXJyYXkoXG4gICAgICBhcGkuaHR0cEdldDxWW10+KFxuICAgICAgICB1dGlsaXRpZXMuZ2V0UGF0aChsb2MpLFxuICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICkpKSBhcyBWW107XG4gIH1cblxuICByZXR1cm4gYWxsO1xufVxuXG4iLCJpbXBvcnQgTG9nZ2luZyBmcm9tICdAZmplbGwvbG9nZ2luZyc7XG5cbmNvbnN0IExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKCdAZmplbGwvY2xpZW50LWFwaScpO1xuXG5leHBvcnQgZGVmYXVsdCBMaWJMb2dnZXI7XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdhY3Rpb24nKTtcblxuZXhwb3J0IGNvbnN0IGdldEFjdGlvbk9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IGFjdGlvbiA9IGFzeW5jIChcbiAgICBpazogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keTogYW55ID0ge30sXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5wb3N0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdhY3Rpb24nLCB7IGlrLCBhY3Rpb24sIGJvZHksIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIHV0aWxpdGllcy52YWxpZGF0ZVBLKFxuICAgICAgYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NPbmUoXG4gICAgICAgIGFwaS5odHRwUG9zdDxWPihcbiAgICAgICAgICBgJHt1dGlsaXRpZXMuZ2V0UGF0aChpayl9LyR7YWN0aW9ufWAsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgKVxuICAgICAgKSkgYXMgVjtcblxuICB9O1xuXG4gIHJldHVybiBhY3Rpb247XG59XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2FsbEFjdGlvbicpO1xuXG5leHBvcnQgY29uc3QgZ2V0QWxsQWN0aW9uT3BlcmF0aW9uID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICBhcGk6IEh0dHBBcGksXG4gICAgYXBpT3B0aW9uczogQ2xpZW50QXBpT3B0aW9ucyxcbiAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG5cbiAgKSA9PiB7XG5cbiAgY29uc3QgYWxsQWN0aW9uID0gYXN5bmMgKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFwaU9wdGlvbnMucG9zdE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLndyaXRlQXV0aGVudGljYXRlZCB9KTtcbiAgICBsb2dnZXIuZGVmYXVsdCgnYWxsQWN0aW9uJywgeyBhY3Rpb24sIGJvZHksIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZXNwb25kIHRvIGVpdGhlciBhIHNpbmdsZSBvYmplY3QsIG9yIG11bHRpcGxlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gICAgcmV0dXJuIHV0aWxpdGllcy52YWxpZGF0ZVBLKFxuICAgICAgYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NBcnJheShcbiAgICAgICAgYXBpLmh0dHBQb3N0PFZbXT4oXG4gICAgICAgICAgYCR7dXRpbGl0aWVzLmdldFBhdGgobG9jKX0vJHthY3Rpb259YCxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgICApXG4gICAgICApKSBhcyBWW107XG4gIH07XG5cbiAgcmV0dXJuIGFsbEFjdGlvbjtcbn1cbiIsImltcG9ydCB7XG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFF1ZXJ5UGFyYW1zLFxuICBxdWVyeVRvUGFyYW1zXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcblxuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuLi9DbGllbnRBcGlPcHRpb25zXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7IFV0aWxpdGllcyB9IGZyb20gXCIuLi9VdGlsaXRpZXNcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnY2xpZW50LWFwaScsICdvcHMnLCAnb25lJyk7XG5cbmV4cG9ydCBjb25zdCBnZXRPbmVPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG5cbiAgY29uc3Qgb25lID0gYXN5bmMgKFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSBhcyBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBwYXJhbXM6IFF1ZXJ5UGFyYW1zID0gcXVlcnlUb1BhcmFtcyhxdWVyeSk7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLnJlYWRBdXRoZW50aWNhdGVkLCBwYXJhbXMgfSk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ29uZScsIHsgcXVlcnksIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG5cbiAgICBsZXQgaXRlbTogViB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uc3QgaXRlbXMgPSB1dGlsaXRpZXMudmFsaWRhdGVQSyhhd2FpdCB1dGlsaXRpZXMucHJvY2Vzc0FycmF5KFxuICAgICAgYXBpLmh0dHBHZXQ8VltdPihcbiAgICAgICAgdXRpbGl0aWVzLmdldFBhdGgobG9jKSxcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMsXG4gICAgICApKSkgYXMgVltdO1xuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbSBhcyBWO1xuICB9XG5cbiAgcmV0dXJuIG9uZTtcbn1cbiIsIi8qKlxuICogU2hhcmVkIGVycm9yIGhhbmRsaW5nIHV0aWxpdGllcyBmb3IgYWxsIEhUVFAgb3BlcmF0aW9uc1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBlcnJvciBzaG91bGQgYmUgcmV0cmllZCBiYXNlZCBvbiBlcnJvciB0eXBlIGFuZCBzdGF0dXMgY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkUmV0cnlFcnJvcihlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gIC8vIFJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzIGFuZCB0aW1lb3V0c1xuICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVGVVNFRCcgfHxcbiAgICBlcnJvci5jb2RlID09PSAnRU5PVEZPVU5EJyB8fFxuICAgIGVycm9yLmNvZGUgPT09ICdFTkVUVU5SRUFDSCcgfHxcbiAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndGltZW91dCcpIHx8XG4gICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gUmV0cnkgb24gSFRUUCA1eHggZXJyb3JzIGFuZCA0MjkgKHJhdGUgbGltaXRpbmcpXG4gIGlmIChlcnJvci5zdGF0dXMgPj0gNTAwIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBEb24ndCByZXRyeSBvbiA0eHggY2xpZW50IGVycm9ycyAoZXhjZXB0IDQyOSlcbiAgaWYgKGVycm9yLnN0YXR1cyA+PSA0MDAgJiYgZXJyb3Iuc3RhdHVzIDwgNTAwICYmIGVycm9yLnN0YXR1cyAhPT0gNDI5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byByZXRyeWluZyB1bmtub3duIGVycm9yc1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHJldHJ5IGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZiBhbmQgaml0dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQ6IG51bWJlciwgY29uZmlnOiBhbnkpOiBudW1iZXIge1xuICBjb25zdCBleHBvbmVudGlhbERlbGF5ID0gKGNvbmZpZy5pbml0aWFsRGVsYXlNcyB8fCAxMDAwKSAqIE1hdGgucG93KGNvbmZpZy5iYWNrb2ZmTXVsdGlwbGllciB8fCAyLCBhdHRlbXB0KTtcbiAgY29uc3QgY2FwcGVkRGVsYXkgPSBNYXRoLm1pbihleHBvbmVudGlhbERlbGF5LCBjb25maWcubWF4RGVsYXlNcyB8fCAzMDAwMCk7XG5cbiAgLy8gQWRkIGppdHRlcjogcmFuZG9tIHZhbHVlIGJldHdlZW4gNTAlIGFuZCAxMDAlIG9mIGNhbGN1bGF0ZWQgZGVsYXlcbiAgY29uc3Qgaml0dGVyID0gMC41ICsgKE1hdGgucmFuZG9tKCkgKiAwLjUpO1xuICByZXR1cm4gTWF0aC5mbG9vcihjYXBwZWREZWxheSAqIGppdHRlcik7XG59XG5cbi8qKlxuICogRW5oYW5jZXMgZXJyb3Igd2l0aCBhZGRpdGlvbmFsIGNvbnRleHQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvcjogYW55LCBjb250ZXh0OiBhbnkpOiBhbnkge1xuICBpZiAoIWVycm9yKSByZXR1cm4gbmV3IEVycm9yKCdVbmtub3duIGVycm9yIG9jY3VycmVkJyk7XG5cbiAgLy8gSWYgaXQncyBhbHJlYWR5IGVuaGFuY2VkLCByZXR1cm4gYXMtaXNcbiAgaWYgKGVycm9yLmNvbnRleHQpIHJldHVybiBlcnJvcjtcblxuICAvLyBBZGQgY29udGV4dCB0byB0aGUgZXJyb3JcbiAgY29uc3QgZW5oYW5jZWRFcnJvciA9IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdIVFRQIG9wZXJhdGlvbiBmYWlsZWQnKTtcbiAgT2JqZWN0LmFzc2lnbihlbmhhbmNlZEVycm9yLCB7XG4gICAgY29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMgfHwgJ1VOS05PV05fRVJST1InLFxuICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgIGNvbnRleHQsXG4gICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgfSk7XG5cbiAgcmV0dXJuIGVuaGFuY2VkRXJyb3I7XG59XG5cbi8qKlxuICogR2V0cyBkZWZhdWx0IHJldHJ5IGNvbmZpZ3VyYXRpb24gbWVyZ2VkIHdpdGggcHJvdmlkZWQgb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcoYXBpT3B0aW9uczogYW55KTogYW55IHtcbiAgcmV0dXJuIHtcbiAgICBtYXhSZXRyaWVzOiAzLFxuICAgIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICAgIG1heERlbGF5TXM6IDMwMDAwLFxuICAgIGJhY2tvZmZNdWx0aXBsaWVyOiAyLFxuICAgIC4uLmFwaU9wdGlvbnMucmV0cnlDb25maWdcbiAgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGN1c3RvbSBlcnJvciBoYW5kbGVyIGV4ZWN1dGlvbiB3aXRoIGVycm9yIHByb3RlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVFcnJvckhhbmRsZXIoXG4gIGVycm9ySGFuZGxlcjogKChlcnJvcjogYW55LCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gdm9pZCkgfCB1bmRlZmluZWQsXG4gIGVycm9yOiBhbnksXG4gIGNvbnRleHQ6IGFueSxcbiAgbG9nZ2VyOiBhbnlcbik6IHZvaWQge1xuICBpZiAoIWVycm9ySGFuZGxlcikgcmV0dXJuO1xuXG4gIHRyeSB7XG4gICAgZXJyb3JIYW5kbGVyKGVycm9yLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoaGFuZGxlckVycm9yOiBhbnkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0N1c3RvbSBlcnJvciBoYW5kbGVyIGZhaWxlZCcsIHtcbiAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBoYW5kbGVyRXJyb3I6IGhhbmRsZXJFcnJvcj8ubWVzc2FnZSB8fCBTdHJpbmcoaGFuZGxlckVycm9yKVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ29tbW9uIHJldHJ5IGxvb3AgbG9naWMgZm9yIEhUVFAgb3BlcmF0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVdpdGhSZXRyeTxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBvcGVyYXRpb25OYW1lOiBzdHJpbmcsXG4gIG9wZXJhdGlvbkNvbnRleHQ6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGFwaU9wdGlvbnM6IGFueSxcbiAgbG9nZ2VyOiBhbnksXG4gIHNwZWNpYWxFcnJvckhhbmRsaW5nPzogKGVycm9yOiBhbnkpID0+IFQgfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhhcGlPcHRpb25zKTtcbiAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8PSByZXRyeUNvbmZpZy5tYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBFeGVjdXRpbmcgJHtvcGVyYXRpb25OYW1lfSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfSlgLCBvcGVyYXRpb25Db250ZXh0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKCk7XG5cbiAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICBsb2dnZXIuaW5mbyhgJHtvcGVyYXRpb25OYW1lfSBvcGVyYXRpb24gc3VjY2VlZGVkIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllc2AsIHtcbiAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgIHRvdGFsQXR0ZW1wdHM6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuXG4gICAgICAvLyBIYW5kbGUgc3BlY2lhbCBlcnJvciBjYXNlcyAobGlrZSA0MDQgcmV0dXJuaW5nIG51bGwpXG4gICAgICBpZiAoc3BlY2lhbEVycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lhbFJlc3VsdCA9IHNwZWNpYWxFcnJvckhhbmRsaW5nKGVycm9yKTtcbiAgICAgICAgaWYgKHNwZWNpYWxSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzcGVjaWFsUmVzdWx0IGFzIFQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gdGhlIGxhc3QgYXR0ZW1wdFxuICAgICAgaWYgKGF0dGVtcHQgPT09IHJldHJ5Q29uZmlnLm1heFJldHJpZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCByZXRyeSB0aGlzIGVycm9yXG4gICAgICBjb25zdCBpc1JldHJ5YWJsZSA9IHNob3VsZFJldHJ5RXJyb3IoZXJyb3IpO1xuICAgICAgaWYgKCFpc1JldHJ5YWJsZSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYE5vdCByZXRyeWluZyAke29wZXJhdGlvbk5hbWV9IG9wZXJhdGlvbiBkdWUgdG8gbm9uLXJldHJ5YWJsZSBlcnJvcmAsIHtcbiAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBlcnJvckNvZGU6IGVycm9yLmNvZGUgfHwgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQgKyAxXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIHJldHJ5Q29uZmlnKTtcblxuICAgICAgbG9nZ2VyLndhcm5pbmcoYFJldHJ5aW5nICR7b3BlcmF0aW9uTmFtZX0gb3BlcmF0aW9uIChhdHRlbXB0ICR7YXR0ZW1wdCArIDJ9KSBhZnRlciAke2RlbGF5fW1zYCwge1xuICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgIGRlbGF5LFxuICAgICAgICBhdHRlbXB0TnVtYmVyOiBhdHRlbXB0ICsgMVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgZmluYWwgZXJyb3JcbiAgY29uc3QgZmluYWxFcnJvciA9IGVuaGFuY2VFcnJvcihsYXN0RXJyb3IsIG9wZXJhdGlvbkNvbnRleHQpO1xuXG4gIC8vIEV4ZWN1dGUgY3VzdG9tIGVycm9yIGhhbmRsZXIgaWYgcHJvdmlkZWRcbiAgZXhlY3V0ZUVycm9ySGFuZGxlcihhcGlPcHRpb25zLmVycm9ySGFuZGxlciwgZmluYWxFcnJvciwgb3BlcmF0aW9uQ29udGV4dCwgbG9nZ2VyKTtcblxuICBsb2dnZXIuZXJyb3IoYCR7b3BlcmF0aW9uTmFtZX0gb3BlcmF0aW9uIGZhaWxlZCBhZnRlciAke3JldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxfSBhdHRlbXB0c2AsIHtcbiAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgIGVycm9yTWVzc2FnZTogZmluYWxFcnJvci5tZXNzYWdlLFxuICAgIGVycm9yQ29kZTogZmluYWxFcnJvci5jb2RlIHx8IGZpbmFsRXJyb3Iuc3RhdHVzLFxuICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgIHRvdGFsQXR0ZW1wdHM6IHJldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxXG4gIH0pO1xuXG4gIHRocm93IGZpbmFsRXJyb3I7XG59XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVSZXRyeURlbGF5LCBlbmhhbmNlRXJyb3IsIHNob3VsZFJldHJ5RXJyb3IgfSBmcm9tIFwiLi9lcnJvckhhbmRsaW5nXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2NyZWF0ZScpO1xuXG5leHBvcnQgY29uc3QgZ2V0Q3JlYXRlT3BlcmF0aW9uID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICBhcGk6IEh0dHBBcGksXG4gICAgYXBpT3B0aW9uczogQ2xpZW50QXBpT3B0aW9ucyxcbiAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG5cbiAgKSA9PiB7XG5cbiAgY29uc3QgY3JlYXRlID0gYXN5bmMgKFxuICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PixcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5wb3N0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdjcmVhdGUnLCB7IGl0ZW0sIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG4gICAgY29uc3Qgb3BlcmF0aW9uQ29udGV4dCA9IHtcbiAgICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScsXG4gICAgICBwYXRoOiB1dGlsaXRpZXMuZ2V0UGF0aChsb2MpLFxuICAgICAgaXRlbVR5cGU6IHR5cGVvZiBpdGVtLFxuICAgICAgaGFzTG9jYXRpb25zOiBsb2NhdGlvbnMubGVuZ3RoID4gMFxuICAgIH07XG5cbiAgICAvLyBSZXRyeSBjb25maWd1cmF0aW9uIGZyb20gb3B0aW9ucyBvciBkZWZhdWx0c1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0ge1xuICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICAgICAgbWF4RGVsYXlNczogMzAwMDAsXG4gICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcbiAgICAgIC4uLmFwaU9wdGlvbnMucmV0cnlDb25maWdcbiAgICB9O1xuXG4gICAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gcmV0cnlDb25maWcubWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYENyZWF0aW5nIGl0ZW0gKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0pYCwgb3BlcmF0aW9uQ29udGV4dCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NPbmUoYXBpLmh0dHBQb3N0PFY+KFxuICAgICAgICAgIHV0aWxpdGllcy5nZXRQYXRoKGxvYyksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgKSk7XG5cbiAgICAgICAgY29uc3QgY3JlYXRlZDogViA9IHV0aWxpdGllcy52YWxpZGF0ZVBLKHJlc3VsdCkgYXMgVjtcblxuICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgQ3JlYXRlIG9wZXJhdGlvbiBzdWNjZWVkZWQgYWZ0ZXIgJHthdHRlbXB0fSByZXRyaWVzYCwge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIHRvdGFsQXR0ZW1wdHM6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcblxuICAgICAgICAvLyBEb24ndCByZXRyeSBvbiB0aGUgbGFzdCBhdHRlbXB0XG4gICAgICAgIGlmIChhdHRlbXB0ID09PSByZXRyeUNvbmZpZy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgZXJyb3IgaXMgcmV0cnlhYmxlXG4gICAgICAgIGNvbnN0IGlzUmV0cnlhYmxlID0gc2hvdWxkUmV0cnlFcnJvcihlcnJvcik7XG4gICAgICAgIGlmICghaXNSZXRyeWFibGUpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vdCByZXRyeWluZyBjcmVhdGUgb3BlcmF0aW9uIGR1ZSB0byBub24tcmV0cnlhYmxlIGVycm9yJywge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0ICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICBjb25zdCBkZWxheSA9IGNhbGN1bGF0ZVJldHJ5RGVsYXkoYXR0ZW1wdCwgcmV0cnlDb25maWcpO1xuXG4gICAgICAgIGxvZ2dlci53YXJuaW5nKGBSZXRyeWluZyBjcmVhdGUgb3BlcmF0aW9uIChhdHRlbXB0ICR7YXR0ZW1wdCArIDJ9KSBhZnRlciAke2RlbGF5fW1zYCwge1xuICAgICAgICAgIC4uLm9wZXJhdGlvbkNvbnRleHQsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgYXR0ZW1wdE51bWJlcjogYXR0ZW1wdCArIDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGZpbmFsIGVycm9yXG4gICAgY29uc3QgZmluYWxFcnJvciA9IGVuaGFuY2VFcnJvcihsYXN0RXJyb3IsIG9wZXJhdGlvbkNvbnRleHQpO1xuXG4gICAgLy8gQ2FsbCBjdXN0b20gZXJyb3IgaGFuZGxlciBpZiBwcm92aWRlZFxuICAgIGlmIChhcGlPcHRpb25zLmVycm9ySGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXBpT3B0aW9ucy5lcnJvckhhbmRsZXIoZmluYWxFcnJvciwgb3BlcmF0aW9uQ29udGV4dCk7XG4gICAgICB9IGNhdGNoIChoYW5kbGVyRXJyb3I6IGFueSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0N1c3RvbSBlcnJvciBoYW5kbGVyIGZhaWxlZCcsIHtcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBmaW5hbEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgaGFuZGxlckVycm9yOiBoYW5kbGVyRXJyb3I/Lm1lc3NhZ2UgfHwgU3RyaW5nKGhhbmRsZXJFcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmVycm9yKGBDcmVhdGUgb3BlcmF0aW9uIGZhaWxlZCBhZnRlciAke3JldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxfSBhdHRlbXB0c2AsIHtcbiAgICAgIC4uLm9wZXJhdGlvbkNvbnRleHQsXG4gICAgICBlcnJvck1lc3NhZ2U6IGZpbmFsRXJyb3IubWVzc2FnZSxcbiAgICAgIGVycm9yQ29kZTogZmluYWxFcnJvci5jb2RlIHx8IGZpbmFsRXJyb3Iuc3RhdHVzLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICB0b3RhbEF0dGVtcHRzOiByZXRyeUNvbmZpZy5tYXhSZXRyaWVzICsgMVxuICAgIH0pO1xuXG4gICAgdGhyb3cgZmluYWxFcnJvcjtcbiAgfTtcblxuICByZXR1cm4gY3JlYXRlO1xufVxuIiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBJdGVtLFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICd1cGRhdGUnKTtcblxuZXhwb3J0IGNvbnN0IGdldFVwZGF0ZU9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IHVwZGF0ZSA9IGFzeW5jIChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFwaU9wdGlvbnMucHV0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCd1cGRhdGUnLCB7IGlrLCBpdGVtLCByZXF1ZXN0T3B0aW9ucyB9KTtcblxuICAgIHJldHVybiB1dGlsaXRpZXMudmFsaWRhdGVQSyhhd2FpdCB1dGlsaXRpZXMucHJvY2Vzc09uZShcbiAgICAgIGFwaS5odHRwUHV0PFY+KFxuICAgICAgICB1dGlsaXRpZXMuZ2V0UGF0aChpayksXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgKSkpIGFzIFY7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlO1xufVxuIiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBJdGVtLFxuICBQcmlLZXksXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcblxuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuLi9DbGllbnRBcGlPcHRpb25zXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7IFV0aWxpdGllcyB9IGZyb20gXCIuLi9VdGlsaXRpZXNcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZVJldHJ5RGVsYXksIGVuaGFuY2VFcnJvciwgc2hvdWxkUmV0cnlFcnJvciB9IGZyb20gXCIuL2Vycm9ySGFuZGxpbmdcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnY2xpZW50LWFwaScsICdvcHMnLCAnZ2V0Jyk7XG5cbmV4cG9ydCBjb25zdCBnZXRHZXRPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApID0+IHtcblxuICBjb25zdCBnZXQgPSBhc3luYyAoXG4gICAgaWs6IFByaUtleTxTPiB8IENvbUtleTxTLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LFxuICApOiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLnJlYWRBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdnZXQnLCB7IGlrLCByZXF1ZXN0T3B0aW9ucyB9KTtcblxuICAgIGNvbnN0IG9wZXJhdGlvbkNvbnRleHQgPSB7XG4gICAgICBvcGVyYXRpb246ICdnZXQnLFxuICAgICAgcGF0aDogdXRpbGl0aWVzLmdldFBhdGgoaWspLFxuICAgICAga2V5VHlwZTogdHlwZW9mIGlrXG4gICAgfTtcblxuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0ge1xuICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICAgICAgbWF4RGVsYXlNczogMzAwMDAsXG4gICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcbiAgICAgIC4uLmFwaU9wdGlvbnMucmV0cnlDb25maWdcbiAgICB9O1xuXG4gICAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gcmV0cnlDb25maWcubWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYEdldHRpbmcgaXRlbSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfSlgLCBvcGVyYXRpb25Db250ZXh0KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1dGlsaXRpZXMucHJvY2Vzc09uZShcbiAgICAgICAgICBhcGkuaHR0cEdldDxWPihcbiAgICAgICAgICAgIHV0aWxpdGllcy5nZXRQYXRoKGlrKSxcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBpdGVtID0gdXRpbGl0aWVzLnZhbGlkYXRlUEsocmVzdWx0KSBhcyBWO1xuXG4gICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBHZXQgb3BlcmF0aW9uIHN1Y2NlZWRlZCBhZnRlciAke2F0dGVtcHR9IHJldHJpZXNgLCB7XG4gICAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgICAgdG90YWxBdHRlbXB0czogYXR0ZW1wdCArIDEsXG4gICAgICAgICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuXG4gICAgICAgIC8vIEhhbmRsZSA0MDQgZXJyb3JzIHNwZWNpYWxseSAtIHJldHVybiBudWxsIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdJdGVtIG5vdCBmb3VuZCAoNDA0KScsIG9wZXJhdGlvbkNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dGVtcHQgPT09IHJldHJ5Q29uZmlnLm1heFJldHJpZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzUmV0cnlhYmxlID0gc2hvdWxkUmV0cnlFcnJvcihlcnJvcik7XG4gICAgICAgIGlmICghaXNSZXRyeWFibGUpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vdCByZXRyeWluZyBnZXQgb3BlcmF0aW9uIGR1ZSB0byBub24tcmV0cnlhYmxlIGVycm9yJywge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0ICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIHJldHJ5Q29uZmlnKTtcblxuICAgICAgICBsb2dnZXIud2FybmluZyhgUmV0cnlpbmcgZ2V0IG9wZXJhdGlvbiAoYXR0ZW1wdCAke2F0dGVtcHQgKyAyfSkgYWZ0ZXIgJHtkZWxheX1tc2AsIHtcbiAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBlcnJvckNvZGU6IGVycm9yLmNvZGUgfHwgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgIGF0dGVtcHROdW1iZXI6IGF0dGVtcHQgKyAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbmFsRXJyb3IgPSBlbmhhbmNlRXJyb3IobGFzdEVycm9yLCBvcGVyYXRpb25Db250ZXh0KTtcblxuICAgIGlmIChhcGlPcHRpb25zLmVycm9ySGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXBpT3B0aW9ucy5lcnJvckhhbmRsZXIoZmluYWxFcnJvciwgb3BlcmF0aW9uQ29udGV4dCk7XG4gICAgICB9IGNhdGNoIChoYW5kbGVyRXJyb3I6IGFueSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0N1c3RvbSBlcnJvciBoYW5kbGVyIGZhaWxlZCcsIHtcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBmaW5hbEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgaGFuZGxlckVycm9yOiBoYW5kbGVyRXJyb3I/Lm1lc3NhZ2UgfHwgU3RyaW5nKGhhbmRsZXJFcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmVycm9yKGBHZXQgb3BlcmF0aW9uIGZhaWxlZCBhZnRlciAke3JldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxfSBhdHRlbXB0c2AsIHtcbiAgICAgIC4uLm9wZXJhdGlvbkNvbnRleHQsXG4gICAgICBlcnJvck1lc3NhZ2U6IGZpbmFsRXJyb3IubWVzc2FnZSxcbiAgICAgIGVycm9yQ29kZTogZmluYWxFcnJvci5jb2RlIHx8IGZpbmFsRXJyb3Iuc3RhdHVzLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICB0b3RhbEF0dGVtcHRzOiByZXRyeUNvbmZpZy5tYXhSZXRyaWVzICsgMVxuICAgIH0pO1xuXG4gICAgdGhyb3cgZmluYWxFcnJvcjtcbiAgfVxuXG4gIHJldHVybiBnZXQ7XG59XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdyZW1vdmUnKTtcblxuZXhwb3J0IGNvbnN0IGdldFJlbW92ZU9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IHJlbW92ZSA9IGFzeW5jIChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5kZWxldGVPcHRpb25zLCB7IGlzQXV0aGVudGljYXRlZDogYXBpT3B0aW9ucy53cml0ZUF1dGhlbnRpY2F0ZWQgfSk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3JlbW92ZScsIHsgaWssIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIGFwaS5odHRwRGVsZXRlPGJvb2xlYW4+KHV0aWxpdGllcy5nZXRQYXRoKGlrKSwgcmVxdWVzdE9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlbW92ZTtcbn1cbiIsImltcG9ydCB7XG4gIEl0ZW0sXG4gIExvY0tleUFycmF5LFxuICBRdWVyeVBhcmFtc1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IGZpbmRlclRvUGFyYW1zIH0gZnJvbSBcIi4uL0FJdGVtQVBJXCI7XG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdmaW5kJyk7XG5cbmV4cG9ydCBjb25zdCBnZXRGaW5kT3BlcmF0aW9uID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICBhcGk6IEh0dHBBcGksXG4gICAgYXBpT3B0aW9uczogQ2xpZW50QXBpT3B0aW9ucyxcbiAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG5cbiAgKSA9PiB7XG5cbiAgY29uc3QgZmluZCA9IGFzeW5jIChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICB1dGlsaXRpZXMudmVyaWZ5TG9jYXRpb25zKGxvY2F0aW9ucyk7XG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBtZXJnZWRQYXJhbXM6IFF1ZXJ5UGFyYW1zID0gZmluZGVyVG9QYXJhbXMoZmluZGVyLCBmaW5kZXJQYXJhbXMpO1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5nZXRPcHRpb25zLCB7IGlzQXV0aGVudGljYXRlZDogYXBpT3B0aW9ucy5hbGxBdXRoZW50aWNhdGVkLCBwYXJhbXM6IG1lcmdlZFBhcmFtcyB9KTtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZmluZCcsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG5cbiAgICByZXR1cm4gdXRpbGl0aWVzLnZhbGlkYXRlUEsoYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NBcnJheShcbiAgICAgIGFwaS5odHRwR2V0PFZbXT4oXG4gICAgICAgIHV0aWxpdGllcy5nZXRQYXRoKGxvYyksXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgKSkpIGFzIFZbXTtcbiAgfVxuXG4gIHJldHVybiBmaW5kO1xufVxuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgTG9jS2V5QXJyYXksXG4gIFF1ZXJ5UGFyYW1zXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcblxuaW1wb3J0IHsgZmluZGVyVG9QYXJhbXMgfSBmcm9tIFwiLi4vQUl0ZW1BUElcIjtcbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2ZpbmQnKTtcblxuZXhwb3J0IGNvbnN0IGdldEZpbmRPbmVPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApID0+IHtcblxuICBjb25zdCBmaW5kT25lID0gYXN5bmMgKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICB1dGlsaXRpZXMudmVyaWZ5TG9jYXRpb25zKGxvY2F0aW9ucyk7XG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBwYXJhbXM6IFF1ZXJ5UGFyYW1zID0gZmluZGVyVG9QYXJhbXMoZmluZGVyLCBmaW5kZXJQYXJhbXMpO1xuICAgIHBhcmFtcy5vbmUgPSB0cnVlO1xuXG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLmFsbEF1dGhlbnRpY2F0ZWQsIHBhcmFtcyB9KTtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZmluZE9uZScsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG5cbiAgICByZXR1cm4gKHV0aWxpdGllcy52YWxpZGF0ZVBLKGF3YWl0IHV0aWxpdGllcy5wcm9jZXNzQXJyYXkoXG4gICAgICBhcGkuaHR0cEdldDxWW10+KFxuICAgICAgICB1dGlsaXRpZXMuZ2V0UGF0aChsb2MpLFxuICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICkpKSBhcyBWW10pWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRPbmU7XG59XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdmYWNldCcpO1xuXG5leHBvcnQgY29uc3QgZ2V0RmFjZXRPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApID0+IHtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBmYWNldCBvcGVyYXRpb24gb24gYW4gaXRlbS5cbiAgICpcbiAgICogQSBmYWNldCBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgaXMgcmVsYXRlZCB0byBhbiBpdGVtIC0gaXQgcmVwcmVzZW50c1xuICAgKiBhIHNwZWNpZmljIGFzcGVjdCBvciBjaGFyYWN0ZXJpc3RpYyBvZiB0aGUgaXRlbS4gVW5saWtlIGFjdGlvbnMgd2hpY2ggbWF5XG4gICAqIHJldHVybiBpdGVtcyBvciBwZXJmb3JtIG9wZXJhdGlvbnMsIGZhY2V0cyBhcmUgaW5mb3JtYXRpb25hbCBxdWVyaWVzIHRoYXRcbiAgICogcmV0dXJuIGRhdGEgYWJvdXQgYSBwYXJ0aWN1bGFyIGZhY2V0IG9mIGFuIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBpayAtIFRoZSBpdGVtIGtleSAoY29tcG9zaXRlIG9yIHByaW1hcnkga2V5KSBpZGVudGlmeWluZyB0aGUgaXRlbVxuICAgKiBAcGFyYW0gZmFjZXQgLSBUaGUgbmFtZSBvZiB0aGUgZmFjZXQgdG8gcXVlcnlcbiAgICogQHBhcmFtIGJvZHkgLSBPcHRpb25hbCByZXF1ZXN0IGJvZHkgZm9yIHRoZSBmYWNldCBvcGVyYXRpb25cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBIVFRQIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZmFjZXQgZGF0YVxuICAgKi9cbiAgY29uc3QgZmFjZXQgPSBhc3luYyAoXG4gICAgaWs6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFwaU9wdGlvbnMuZ2V0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkLCBwYXJhbXMgfSk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2ZhY2V0JywgeyBpaywgZmFjZXQsIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIGFwaS5odHRwR2V0PGFueT4oXG4gICAgICBgJHt1dGlsaXRpZXMuZ2V0UGF0aChpayl9LyR7ZmFjZXR9YCxcbiAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICk7XG5cbiAgfTtcblxuICByZXR1cm4gZmFjZXQ7XG59XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2FsbEZhY2V0Jyk7XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxGYWNldE9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IGFsbEZhY2V0ID0gYXN5bmMgKFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiA9PiB7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLndyaXRlQXV0aGVudGljYXRlZCwgcGFyYW1zIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdhbGxGYWNldCcsIHsgZmFjZXQsIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZXNwb25kIHRvIGVpdGhlciBhIHNpbmdsZSBvYmplY3QsIG9yIG11bHRpcGxlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gICAgcmV0dXJuIGFwaS5odHRwR2V0PFZbXT4oXG4gICAgICBgJHt1dGlsaXRpZXMuZ2V0UGF0aChsb2MpfS8ke2ZhY2V0fWAsXG4gICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICApXG4gIH07XG5cbiAgcmV0dXJuIGFsbEZhY2V0O1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCJcbmltcG9ydCB7IGdldEFsbE9wZXJhdGlvbiB9IGZyb20gXCIuL2FsbFwiXG5pbXBvcnQgeyBnZXRBY3Rpb25PcGVyYXRpb24gfSBmcm9tIFwiLi9hY3Rpb25cIlxuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiXG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiXG5pbXBvcnQgeyBnZXRBbGxBY3Rpb25PcGVyYXRpb24gfSBmcm9tIFwiLi9hbGxBY3Rpb25cIlxuaW1wb3J0IHsgZ2V0T25lT3BlcmF0aW9uIH0gZnJvbSBcIi4vb25lXCJcbmltcG9ydCB7IGdldENyZWF0ZU9wZXJhdGlvbiB9IGZyb20gXCIuL2NyZWF0ZVwiXG5pbXBvcnQgeyBnZXRVcGRhdGVPcGVyYXRpb24gfSBmcm9tIFwiLi91cGRhdGVcIlxuaW1wb3J0IHsgZ2V0R2V0T3BlcmF0aW9uIH0gZnJvbSBcIi4vZ2V0XCJcbmltcG9ydCB7IGdldFJlbW92ZU9wZXJhdGlvbiB9IGZyb20gXCIuL3JlbW92ZVwiXG5pbXBvcnQgeyBnZXRGaW5kT3BlcmF0aW9uIH0gZnJvbSBcIi4vZmluZFwiXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIlxuaW1wb3J0IHsgQ2xpZW50QXBpIH0gZnJvbSBcIi4uL0NsaWVudEFwaVwiXG5pbXBvcnQgeyBnZXRGaW5kT25lT3BlcmF0aW9uIH0gZnJvbSBcIi4vZmluZE9uZVwiXG5pbXBvcnQgeyBnZXRGYWNldE9wZXJhdGlvbiB9IGZyb20gXCIuL2ZhY2V0XCJcbmltcG9ydCB7IGdldEFsbEZhY2V0T3BlcmF0aW9uIH0gZnJvbSBcIi4vYWxsRmFjZXRcIlxuXG5leHBvcnQgY29uc3QgZ2V0T3BlcmF0aW9ucyA9XG4gIDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICAgIGFwaTogSHR0cEFwaSxcbiAgICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuXG4gICAgKTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IGdldEFjdGlvbk9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBhbGw6IGdldEFsbE9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBhbGxBY3Rpb246IGdldEFsbEFjdGlvbk9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBhbGxGYWNldDogZ2V0QWxsRmFjZXRPcGVyYXRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAgYXBpLFxuICAgICAgICBhcGlPcHRpb25zLFxuICAgICAgICB1dGlsaXRpZXMsXG4gICAgICApLFxuICAgICAgY3JlYXRlOiBnZXRDcmVhdGVPcGVyYXRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAgYXBpLFxuICAgICAgICBhcGlPcHRpb25zLFxuICAgICAgICB1dGlsaXRpZXMsXG4gICAgICApLFxuICAgICAgZmFjZXQ6IGdldEZhY2V0T3BlcmF0aW9uPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oXG4gICAgICAgIGFwaSxcbiAgICAgICAgYXBpT3B0aW9ucyxcbiAgICAgICAgdXRpbGl0aWVzLFxuICAgICAgKSxcbiAgICAgIGZpbmRPbmU6IGdldEZpbmRPbmVPcGVyYXRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAgYXBpLFxuICAgICAgICBhcGlPcHRpb25zLFxuICAgICAgICB1dGlsaXRpZXMsXG4gICAgICApLFxuICAgICAgZmluZDogZ2V0RmluZE9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBnZXQ6IGdldEdldE9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBvbmU6IGdldE9uZU9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICByZW1vdmU6IGdldFJlbW92ZU9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICB1cGRhdGU6IGdldFVwZGF0ZU9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgfVxuICB9IiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICB2YWxpZGF0ZVBLIGFzIGNvcmVWYWxpZGF0ZVBLLFxuICBnZW5lcmF0ZUtleUFycmF5LFxuICBpc1ByaUtleSxcbiAgSXRlbSxcbiAgTG9jS2V5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5LFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSBcImRlZXBtZXJnZVwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ1V0aWxpdHknKTtcblxuZXhwb3J0IGludGVyZmFjZSBVdGlsaXRpZXM8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4ge1xuICB2ZXJpZnlMb2NhdGlvbnM6IChsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSB8IG5ldmVyKSA9PiBib29sZWFuO1xuICBwcm9jZXNzT25lOiAoYXBpQ2FsbDogUHJvbWlzZTxWPikgPT4gUHJvbWlzZTxWPjtcbiAgcHJvY2Vzc0FycmF5OiAoYXBpOiBQcm9taXNlPFZbXT4pID0+IFByb21pc2U8VltdPjtcbiAgY29udmVydERvYzogKGRvYzogVikgPT4gVjtcbiAgZ2V0UGF0aDogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4gfCBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pID0+IHN0cmluZztcbiAgdmFsaWRhdGVQSzogKGl0ZW06IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PltdKSA9PlxuICAgIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PltdO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlVXRpbGl0aWVzID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KHBrVHlwZTogUywgcGF0aE5hbWVzOiBzdHJpbmdbXSk6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcblxuICBsb2dnZXIuZGVmYXVsdCgnY3JlYXRlVXRpbGl0aWVzJywgeyBwa1R5cGUsIHBhdGhOYW1lcyB9KTtcblxuICBjb25zdCB2ZXJpZnlMb2NhdGlvbnMgPSAoXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gfCBuZXZlcixcbiAgKTogYm9vbGVhbiA9PiB7XG5cbiAgICBpZiAobG9jYXRpb25zICYmIGxvY2F0aW9ucy5sZW5ndGggPCBwYXRoTmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGxvY2F0aW9ucyBmb3IgcGF0aE5hbWVzOiBsb2NhdGlvbnM6J1xuICAgICAgICArIGxvY2F0aW9ucy5sZW5ndGggKyAnIHBhdGhOYW1lczonICsgcGF0aE5hbWVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgcHJvY2Vzc09uZSA9IGFzeW5jIChcbiAgICBhcGlDYWxsOiBQcm9taXNlPFY+LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgncHJvY2Vzc09uZScsIHsgYXBpQ2FsbCB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGw7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3Byb2Nlc3NPbmUgcmVzcG9uc2UnLCB7XG4gICAgICByZXNwb25zZVR5cGU6IHR5cGVvZiByZXNwb25zZSxcbiAgICAgIGhhc0RhdGE6ICEhcmVzcG9uc2VcbiAgICB9KTtcbiAgICByZXR1cm4gY29udmVydERvYyhyZXNwb25zZSk7XG4gIH07XG5cbiAgY29uc3QgcHJvY2Vzc0FycmF5ID0gYXN5bmMgKFxuICAgIGFwaTogUHJvbWlzZTxWW10+LFxuICApOiBQcm9taXNlPFZbXT4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdwcm9jZXNzQXJyYXknLCB7IGFwaSB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaTtcbiAgICBsb2dnZXIuZGVmYXVsdCgncHJvY2Vzc0FycmF5IHJlc3BvbnNlJywge1xuICAgICAgcmVzcG9uc2VUeXBlOiB0eXBlb2YgcmVzcG9uc2UsXG4gICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSxcbiAgICAgIGxlbmd0aDogQXJyYXkuaXNBcnJheShyZXNwb25zZSkgPyByZXNwb25zZS5sZW5ndGggOiAwXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlICYmIEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UubWFwKChzdWJqZWN0Q2hhdDogVikgPT5cbiAgICAgICAgY29udmVydERvYyhzdWJqZWN0Q2hhdCksXG4gICAgICApIGFzIHVua25vd24gYXMgVltdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ1Jlc3BvbnNlIHdhcyBub3QgYW4gYXJyYXknLCB7IHJlc3BvbnNlIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSB3YXMgbm90IGFuIGFycmF5Jyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNvbnZlcnREb2MgPSAoZG9jOiBWKTogViA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2NvbnZlcnREb2MnLCB7IGRvYyB9KTtcbiAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShkb2MsIG51bGwsIDIpKTtcbiAgICBpZiAoZG9jICYmIGRvYy5ldmVudHMpIHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGRvYy5ldmVudHM7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgZXZlbnRzW2tleV0gPSBkZWVwbWVyZ2UoZXZlbnRzW2tleV0sIHsgYXQ6IGV2ZW50c1trZXldLmF0ID8gbmV3IERhdGUoZXZlbnRzW2tleV0uYXQpIDogbnVsbCB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvYyBhcyB1bmtub3duIGFzIFY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldFBhdGggPVxuICAgIChcbiAgICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4gfCBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10sXG4gICAgKTpcbiAgICAgIHN0cmluZyA9PiB7XG5cbiAgICAgIGNvbnN0IGxvY2FsUGF0aE5hbWVzID0gWy4uLnBhdGhOYW1lc107XG4gICAgICBsb2dnZXIuZGVmYXVsdCgnZ2V0UGF0aCcsIHsga2V5LCBwYXRoTmFtZXM6IGxvY2FsUGF0aE5hbWVzIH0pO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnZ2V0UGF0aCBrZXk6ICcgKyBKU09OLnN0cmluZ2lmeShrZXkpKTtcblxuICAgICAgY29uc3Qga2V5cyA9IGdlbmVyYXRlS2V5QXJyYXkoa2V5KTtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ2dldFBhdGgga2V5czogJyArIEpTT04uc3RyaW5naWZ5KGtleXMpKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdnZXRQYXRoIHBhdGhOYW1lczogJyArIEpTT04uc3RyaW5naWZ5KHBhdGhOYW1lcykpO1xuXG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gYWRkUGF0aCgnJywga2V5cywgbG9jYWxQYXRoTmFtZXMpO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBjb2xsZWN0aW9uIGxlZnQgaW4gdGhlIGNvbGxlY3Rpb25zIGFycmF5LCB0aGlzIG1lYW5zIHRoYXRcbiAgICAgIC8vIHdlIHJlY2VpdmVkIExvY0tleXMgYW5kIHdlIG5lZWQgdG8gYWRkIHRoZSBsYXN0IGNvbGxlY3Rpb24gdG8gdGhlIHJlZmVyZW5jZVxuICAgICAgaWYgKGxvY2FsUGF0aE5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwYXRoID0gYCR7cGF0aH0vJHtsb2NhbFBhdGhOYW1lc1swXX1gO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIuZGVmYXVsdCgnZ2V0UGF0aCBjcmVhdGVkJywgeyBrZXksIHBhdGggfSk7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgY29uc3QgYWRkUGF0aCA9IChcbiAgICBiYXNlOiBzdHJpbmcsXG4gICAga2V5czogQXJyYXk8UHJpS2V5PFM+IHwgTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+PixcbiAgICBsb2NhbFBhdGhOYW1lczogc3RyaW5nW10sXG4gICk6IHN0cmluZyA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2FkZFBhdGgnLCB7IGJhc2UsIGtleXMsIHBhdGhOYW1lczogbG9jYWxQYXRoTmFtZXMgfSk7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgbG9jYWxQYXRoTmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdhZGRQYXRoIHNob3VsZCBuZXZlciBoYXZlIGtleXMgd2l0aCBhIGxlbmd0aCBsZXNzIHRoYW4gdGhlIGxlbmd0aCBvZiBwYXRoTmFtZXMgLSAxJyxcbiAgICAgICAgeyBrZXlzLCBsb2NhbFBhdGhOYW1lcyB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWRkUGF0aCBzaG91bGQgbmV2ZXIgaGF2ZSBrZXlzIHdpdGggYSBsZW5ndGggbGVzcyB0aGFuIHRoZSBsZW5ndGggb2YgcGF0aE5hbWVzIC0gMTogJ1xuICAgICAgICArIGtleXMubGVuZ3RoICsgJyAnICsgbG9jYWxQYXRoTmFtZXMubGVuZ3RoICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoa2V5cywgbG9jYWxQYXRoTmFtZXMpKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID4gbG9jYWxQYXRoTmFtZXMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ2FkZFBhdGggc2hvdWxkIG5ldmVyIGhhdmUga2V5cyB3aXRoIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHBhdGhOYW1lcycsXG4gICAgICAgIHsga2V5cywgcGF0aE5hbWVzIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRQYXRoIHNob3VsZCBuZXZlciBoYXZlIGtleXMgd2l0aCBhIGxlbmd0aCBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiBwYXRoTmFtZXM6ICdcbiAgICAgICAgKyBrZXlzLmxlbmd0aCArICcgJyArIGxvY2FsUGF0aE5hbWVzLmxlbmd0aCArICcgJyArIEpTT04uc3RyaW5naWZ5KGtleXMsIGxvY2FsUGF0aE5hbWVzKSk7XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgeW91J3ZlIHJlY3Vyc2l2ZWx5IGNvbnN1bWVkIGFsbCBvZiB0aGUga2V5cywgcmV0dXJuIHRoZSBiYXNlLlxuICAgICAgbG9nZ2VyLmRlZmF1bHQoJ2FkZFBhdGggcmV0dXJuaW5nIGJhc2UnLCB7IGJhc2UgfSk7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0cmlldmUgdGhlIG5leHQga2V5IGFuZCBjb2xsZWN0aW9uLCBhbmQgY3JlYXRlIHRoZSBuZXh0IGJhc2VcbiAgICAgIGxldCBuZXh0QmFzZTogc3RyaW5nO1xuICAgICAgY29uc3Qga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgIGNvbnN0IHBhdGhOYW1lID0gbG9jYWxQYXRoTmFtZXMucG9wKCk7XG4gICAgICBpZiAoaXNQcmlLZXkoa2V5KSkge1xuICAgICAgICBjb25zdCBQcmlLZXkgPSBrZXkgYXMgUHJpS2V5PFM+O1xuICAgICAgICBuZXh0QmFzZSA9IGAke2Jhc2V9LyR7cGF0aE5hbWV9LyR7UHJpS2V5LnBrfWA7XG4gICAgICAgIGxvZ2dlci5kZWZhdWx0KCdBZGRpbmcgUGF0aCBmb3IgUEsnLCB7IHBhdGhOYW1lLCBQcmlLZXksIG5leHRCYXNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgTG9jS2V5ID0ga2V5IGFzIExvY0tleTxMMSB8IEwyIHwgTDMgfCBMNCB8IEw1PjtcbiAgICAgICAgbmV4dEJhc2UgPSBgJHtiYXNlfS8ke3BhdGhOYW1lfS8ke0xvY0tleS5sa31gO1xuICAgICAgICBsb2dnZXIuZGVmYXVsdCgnUmV0cmlldmluZyBDb2xsZWN0aW9uIGZvciBMSycsIHsgcGF0aE5hbWUsIExvY0tleSB9KTtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmRlZmF1bHQoJ2NhbGxpbmcgYWRkUGF0aCByZWN1cnNpdmVseScsIHsgbmV4dEJhc2UsIGtleXMsIGxvY2FsUGF0aE5hbWVzIH0pO1xuICAgICAgcmV0dXJuIGFkZFBhdGgobmV4dEJhc2UsIGtleXMsIGxvY2FsUGF0aE5hbWVzKTtcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlUEsgPSAoXG4gICAgaXRlbTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+W10pOlxuICAgIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PltdID0+IHtcbiAgICByZXR1cm4gY29yZVZhbGlkYXRlUEs8UywgTDEsIEwyLCBMMywgTDQsIEw1PihpdGVtLCBwa1R5cGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJpZnlMb2NhdGlvbnMsXG4gICAgcHJvY2Vzc09uZSxcbiAgICBjb252ZXJ0RG9jLFxuICAgIHByb2Nlc3NBcnJheSxcbiAgICBnZXRQYXRoLFxuICAgIHZhbGlkYXRlUEssXG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuaW1wb3J0IHsgSXRlbSwgUXVlcnlQYXJhbXMgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi9DbGllbnRBcGlPcHRpb25zXCI7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25zIH0gZnJvbSBcIi4vb3BzXCI7XG5pbXBvcnQgeyBjcmVhdGVVdGlsaXRpZXMgfSBmcm9tIFwiLi9VdGlsaXRpZXNcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCIuL0NsaWVudEFwaVwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdBSXRlbUFQSScpO1xuXG5leHBvcnQgdHlwZSBQYXRoTmFtZXNBcnJheTxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9XG4gIChbTDVdIGV4dGVuZHMgW25ldmVyXSA/XG4gICAgKFtMNF0gZXh0ZW5kcyBbbmV2ZXJdID9cbiAgICAgIChbTDNdIGV4dGVuZHMgW25ldmVyXSA/XG4gICAgICAgIChbTDJdIGV4dGVuZHMgW25ldmVyXSA/XG4gICAgICAgICAgKFtMMV0gZXh0ZW5kcyBbbmV2ZXJdID9cbiAgICAgICAgICAgIFtzdHJpbmddIDpcbiAgICAgICAgICAgIFtzdHJpbmcsIHN0cmluZ10pIDpcbiAgICAgICAgICBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pIDpcbiAgICAgICAgW3N0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pIDpcbiAgICAgIFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pIDpcbiAgICBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pO1xuXG5leHBvcnQgY29uc3QgZmluZGVyVG9QYXJhbXMgPSAoXG4gIGZpbmRlcjogc3RyaW5nLFxuICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PlxuKTogUXVlcnlQYXJhbXMgPT4ge1xuICByZXR1cm4ge1xuICAgIGZpbmRlcixcbiAgICBmaW5kZXJQYXJhbXM6IEpTT04uc3RyaW5naWZ5KGZpbmRlclBhcmFtcyksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQUl0ZW1BUEkgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGFwaTogSHR0cEFwaSxcbiAgcGtUeXBlOiBTLFxuICBwYXRoTmFtZXM6IFBhdGhOYW1lc0FycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIG9wdGlvbnM/OiBDbGllbnRBcGlPcHRpb25zLFxuKTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuXG4gIGxvZ2dlci5kZWZhdWx0KCdjcmVhdGVBSXRlbUFQSScsIHsgcGtUeXBlLCBwYXRoTmFtZXMsIG9wdGlvbnMgfSk7XG5cbiAgbGV0IG1lcmdlZE9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnM7XG5cbiAgY29uc3QgZGVmYXVsdE9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMgPSB7XG4gICAgcmVhZEF1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgYWxsQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICB3cml0ZUF1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgZ2V0T3B0aW9uczoge30sXG4gICAgcG9zdE9wdGlvbnM6IHt9LFxuICAgIHB1dE9wdGlvbnM6IHt9LFxuICAgIGRlbGV0ZU9wdGlvbnM6IHt9LFxuICB9O1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBtZXJnZWRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIH1cblxuICBjb25zdCB1dGlsaXRpZXMgPSBjcmVhdGVVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pihwa1R5cGUsIHBhdGhOYW1lcyk7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBnZXRPcGVyYXRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oYXBpLCBtZXJnZWRPcHRpb25zLCB1dGlsaXRpZXMpO1xuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uOiBvcGVyYXRpb25zLmFjdGlvbixcbiAgICBhbGw6IG9wZXJhdGlvbnMuYWxsLFxuICAgIGFsbEFjdGlvbjogb3BlcmF0aW9ucy5hbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQ6IG9wZXJhdGlvbnMuYWxsRmFjZXQsXG4gICAgY3JlYXRlOiBvcGVyYXRpb25zLmNyZWF0ZSxcbiAgICBmYWNldDogb3BlcmF0aW9ucy5mYWNldCxcbiAgICBmaW5kOiBvcGVyYXRpb25zLmZpbmQsXG4gICAgZmluZE9uZTogb3BlcmF0aW9ucy5maW5kT25lLFxuICAgIGdldDogb3BlcmF0aW9ucy5nZXQsXG4gICAgb25lOiBvcGVyYXRpb25zLm9uZSxcbiAgICByZW1vdmU6IG9wZXJhdGlvbnMucmVtb3ZlLFxuICAgIHVwZGF0ZTogb3BlcmF0aW9ucy51cGRhdGUsXG4gIH1cbn0iLCJcbmltcG9ydCB7XG4gIENvbUtleSxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5LFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7XG4gIEh0dHBBcGlcbn0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuaW1wb3J0IHsgY3JlYXRlQUl0ZW1BUEksIFBhdGhOYW1lc0FycmF5IH0gZnJvbSBcIi4vQUl0ZW1BUElcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCIuL0NsaWVudEFwaVwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuL0NsaWVudEFwaU9wdGlvbnNcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnQ0l0ZW1BUEknKTtcblxuZXhwb3J0IGludGVyZmFjZSBDSXRlbUFwaTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gIGFjdGlvbjogKFxuICAgIGlrOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5OiBhbnksXG4gICkgPT4gUHJvbWlzZTxWPjtcbiAgYWxsOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFZbXT47XG4gIGFsbEFjdGlvbjogKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk/OiBhbnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICkgPT4gUHJvbWlzZTxWW10+O1xuICBhbGxGYWNldDogKFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8YW55PjtcbiAgZ2V0OiAoXG4gICAgaWs6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApID0+IFByb21pc2U8ViB8IG51bGw+O1xuICBjcmVhdGU6IChcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICkgPT4gUHJvbWlzZTxWPjtcbiAgcmVtb3ZlOiAoXG4gICAgaWs6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIHVwZGF0ZTogKFxuICAgIGlrOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICkgPT4gUHJvbWlzZTxWPjtcbiAgZmFjZXQ6IChcbiAgICBpazogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxhbnk+O1xuICBmaW5kOiAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8VltdPjtcbiAgZmluZE9uZTogKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFY+O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNJdGVtQXBpID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihhcGk6IEh0dHBBcGksIHR5cGU6IFMsIHBhdGhOYW1lczogUGF0aE5hbWVzQXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1Piwgb3B0aW9ucz86IENsaWVudEFwaU9wdGlvbnMpOiBDSXRlbUFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcblxuICBsb2dnZXIuZGVmYXVsdCgnY3JlYXRlQ0l0ZW1BcGknLCB7IGFwaSwgdHlwZSwgcGF0aE5hbWVzLCBvcHRpb25zIH0pO1xuXG4gIGNvbnN0IGFJdGVtQVBJID0gY3JlYXRlQUl0ZW1BUEkoYXBpLCB0eXBlLCBwYXRoTmFtZXMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uOiBhSXRlbUFQSS5hY3Rpb24sXG4gICAgYWxsOiBhSXRlbUFQSS5hbGwsXG4gICAgYWxsQWN0aW9uOiBhSXRlbUFQSS5hbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQ6IGFJdGVtQVBJLmFsbEZhY2V0LFxuICAgIG9uZTogYUl0ZW1BUEkub25lLFxuICAgIGdldDogYUl0ZW1BUEkuZ2V0LFxuICAgIGNyZWF0ZTogYUl0ZW1BUEkuY3JlYXRlLFxuICAgIHJlbW92ZTogYUl0ZW1BUEkucmVtb3ZlLFxuICAgIHVwZGF0ZTogYUl0ZW1BUEkudXBkYXRlLFxuICAgIGZhY2V0OiBhSXRlbUFQSS5mYWNldCxcbiAgICBmaW5kOiBhSXRlbUFQSS5maW5kLFxuICAgIGZpbmRPbmU6IGFJdGVtQVBJLmZpbmRPbmUsXG4gIH0gYXMgdW5rbm93biBhcyBDSXRlbUFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xufVxuIiwiaW1wb3J0IHsgQ29tS2V5LCBJdGVtLCBJdGVtUXVlcnksIFByaUtleSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcbmltcG9ydCB7IGNyZWF0ZUFJdGVtQVBJIH0gZnJvbSBcIi4vQUl0ZW1BUElcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCIuL0NsaWVudEFwaVwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuL0NsaWVudEFwaU9wdGlvbnNcIjtcbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ1BJdGVtQVBJJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUEl0ZW1BcGk8XG4gIFYgZXh0ZW5kcyBJdGVtPFM+LFxuICBTIGV4dGVuZHMgc3RyaW5nXG4+IGV4dGVuZHMgQ2xpZW50QXBpPFYsIFM+IHtcblxuICBhY3Rpb246IChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keTogYW55LFxuICApID0+IFByb21pc2U8Vj47XG5cbiAgYWxsOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgKSA9PiBQcm9taXNlPFZbXT47XG5cbiAgYWxsQWN0aW9uOiAoXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueSxcbiAgKSA9PiBQcm9taXNlPFZbXT47XG5cbiAgYWxsRmFjZXQ6IChcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgKSA9PiBQcm9taXNlPGFueT47XG5cbiAgb25lOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgKSA9PiBQcm9taXNlPFYgfCBudWxsPjtcblxuICBnZXQ6IChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbiAgY3JlYXRlOiAoXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFM+PixcbiAgKSA9PiBQcm9taXNlPFY+O1xuXG4gIHJlbW92ZTogKFxuICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gIHVwZGF0ZTogKFxuICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08Uz4+LFxuICApID0+IFByb21pc2U8Vj47XG5cbiAgZmFjZXQ6IChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxhbnk+O1xuXG4gIGZpbmQ6IChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxWW10+O1xuXG4gIGZpbmRPbmU6IChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxWPjtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBJdGVtQXBpID0gPFYgZXh0ZW5kcyBJdGVtPFM+LCBTIGV4dGVuZHMgc3RyaW5nPihcbiAgYXBpOiBIdHRwQXBpLFxuICB0eXBlOiBTLFxuICBwYXRoTmFtZTogc3RyaW5nLFxuICBvcHRpb25zPzogQ2xpZW50QXBpT3B0aW9uc1xuKTogUEl0ZW1BcGk8ViwgUz4gPT4ge1xuXG4gIGxvZ2dlci5kZWZhdWx0KCdjcmVhdGVQSXRlbUFwaScsIHsgdHlwZSwgcGF0aE5hbWUsIG9wdGlvbnMgfSk7XG5cbiAgY29uc3QgYUl0ZW1BUEkgPSBjcmVhdGVBSXRlbUFQSTxWLCBTPihhcGksIHR5cGUsIFtwYXRoTmFtZV0sIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGFjdGlvbiA9XG4gICAgYXN5bmMgKFxuICAgICAgaWs6IFByaUtleTxTPiB8IENvbUtleTxTLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LFxuICAgICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgICBib2R5OiBhbnkgPSB7fSxcbiAgICApOiBQcm9taXNlPFY+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5hY3Rpb24oaWssIGFjdGlvbiwgYm9keSkgYXMgVjtcblxuICBjb25zdCBhbGwgPVxuICAgIGFzeW5jIChcbiAgICAgIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSBhcyBJdGVtUXVlcnksXG4gICAgKTogUHJvbWlzZTxWW10+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5hbGwocXVlcnksIFtdKSBhcyBWW107XG5cbiAgY29uc3QgYWxsQWN0aW9uID1cbiAgICBhc3luYyAoXG4gICAgICBhY3Rpb246IHN0cmluZyxcbiAgICAgIGJvZHk6IGFueSA9IHt9LFxuICAgICk6IFByb21pc2U8VltdPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuYWxsQWN0aW9uKGFjdGlvbiwgYm9keSwgW10pIGFzIFZbXTtcblxuICBjb25zdCBhbGxGYWNldCA9XG4gICAgYXN5bmMgKFxuICAgICAgZmFjZXQ6IHN0cmluZyxcbiAgICAgIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5hbGxGYWNldChmYWNldCwgcGFyYW1zKSBhcyBhbnk7XG5cbiAgY29uc3Qgb25lID1cbiAgICBhc3luYyAoXG4gICAgICBxdWVyeTogSXRlbVF1ZXJ5ID0ge30gYXMgSXRlbVF1ZXJ5LFxuICAgICk6IFByb21pc2U8ViB8IG51bGw+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5vbmUocXVlcnksIFtdKSBhcyBWIHwgbnVsbDtcblxuICBjb25zdCBnZXQgPVxuICAgIGFzeW5jIChcbiAgICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgICApOiBQcm9taXNlPFYgfCBudWxsPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuZ2V0KGlrKSBhcyBWIHwgbnVsbDtcblxuICBjb25zdCBjcmVhdGUgPVxuICAgIGFzeW5jIChcbiAgICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTPj4sXG4gICAgKTogUHJvbWlzZTxWPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuY3JlYXRlKGl0ZW0sIFtdKSBhcyBWO1xuXG4gIGNvbnN0IHJlbW92ZSA9XG4gICAgYXN5bmMgKFxuICAgICAgaWs6IFByaUtleTxTPiB8IENvbUtleTxTLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4gPT5cbiAgICAgIGF3YWl0IGFJdGVtQVBJLnJlbW92ZShpaykgYXMgYm9vbGVhbjtcblxuICBjb25zdCB1cGRhdGUgPVxuICAgIGFzeW5jIChcbiAgICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTPj4sXG4gICAgKTogUHJvbWlzZTxWPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkudXBkYXRlKGlrLCBpdGVtKSBhcyBWO1xuXG4gIGNvbnN0IGZhY2V0ID1cbiAgICBhc3luYyAoXG4gICAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICAgICBmYWNldDogc3RyaW5nLFxuICAgICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgICApOiBQcm9taXNlPGFueT4gPT5cbiAgICAgIGF3YWl0IGFJdGVtQVBJLmZhY2V0KGlrLCBmYWNldCwgcGFyYW1zKSBhcyBhbnk7XG5cbiAgY29uc3QgZmluZCA9XG4gICAgYXN5bmMgKFxuICAgICAgZmluZGVyOiBzdHJpbmcsXG4gICAgICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICAgICk6IFByb21pc2U8VltdPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuZmluZChmaW5kZXIsIGZpbmRlclBhcmFtcykgYXMgVltdO1xuXG4gIGNvbnN0IGZpbmRPbmUgPVxuICAgIGFzeW5jIChcbiAgICAgIGZpbmRlcjogc3RyaW5nLFxuICAgICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgICApOiBQcm9taXNlPFY+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5maW5kT25lKGZpbmRlciwgZmluZGVyUGFyYW1zKSBhcyBWO1xuXG4gIHJldHVybiB7XG4gICAgLi4uYUl0ZW1BUEksXG4gICAgYWN0aW9uLFxuICAgIGFsbCxcbiAgICBhbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQsXG4gICAgb25lLFxuICAgIGdldCxcbiAgICBjcmVhdGUsXG4gICAgcmVtb3ZlLFxuICAgIHVwZGF0ZSxcbiAgICBmYWNldCxcbiAgICBmaW5kLFxuICAgIGZpbmRPbmUsXG4gIH07XG5cbn07XG4iLCJcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBJbnN0YW5jZSBhcyBCYXNlSW5zdGFuY2UsIENvb3JkaW5hdGUsIGNyZWF0ZUluc3RhbmNlIGFzIGNyZWF0ZUJhc2VJbnN0YW5jZSwgUmVnaXN0cnkgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiLi9DbGllbnRBcGlcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIkluc3RhbmNlXCIpO1xuXG4vKipcbiAqIFRoZSBDbGllbnQgQVBJIEluc3RhbmNlIGludGVyZmFjZSByZXByZXNlbnRzIGEgY2xpZW50IEFQSSBtb2RlbCBpbnN0YW5jZSB0aGF0IGV4dGVuZHMgdGhlIGJhc2UgSW5zdGFuY2VcbiAqIGZyb20gQGZqZWxsL3JlZ2lzdHJ5IGFuZCBhZGRzIGNsaWVudCBBUEkgb3BlcmF0aW9ucyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCByZW1vdGUgZGF0YS5cbiAqXG4gKiBUaGUgaW50ZXJmYWNlIGV4dGVuZHMgdGhlIGJhc2UgSW5zdGFuY2UgKHdoaWNoIHByb3ZpZGVzIGNvb3JkaW5hdGUgYW5kIHJlZ2lzdHJ5KSB3aXRoOlxuICogLSBjbGllbnRBcGk6IFByb3ZpZGVzIG1ldGhvZHMgZm9yIGludGVyYWN0aW5nIHdpdGggcmVtb3RlIGRhdGEgdGhyb3VnaCBIVFRQIEFQSXMgKGdldCwgY3JlYXRlLCB1cGRhdGUsIGV0Yy4pXG4gKlxuICogQHRlbXBsYXRlIFYgLSBUaGUgdHlwZSBvZiB0aGUgZGF0YSBtb2RlbCBpdGVtLCBleHRlbmRpbmcgSXRlbVxuICogQHRlbXBsYXRlIFMgLSBUaGUgc3RyaW5nIGxpdGVyYWwgdHlwZSByZXByZXNlbnRpbmcgdGhlIG1vZGVsJ3Mga2V5IHR5cGVcbiAqIEB0ZW1wbGF0ZSBMMS1MNSAtIE9wdGlvbmFsIHN0cmluZyBsaXRlcmFsIHR5cGVzIGZvciBsb2NhdGlvbiBoaWVyYXJjaHkgbGV2ZWxzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFuY2U8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBCYXNlSW5zdGFuY2U8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gIC8qKiBUaGUgY2xpZW50IEFQSSBvYmplY3QgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBpbnRlcmFjdGluZyB3aXRoIHJlbW90ZSBkYXRhICovXG4gIGNsaWVudEFwaTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnN0YW5jZSA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICByZWdpc3RyeTogUmVnaXN0cnksXG4gICAgY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGNsaWVudEFwaTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICk6IEluc3RhbmNlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBsb2dnZXIuZGVidWcoXCJjcmVhdGVJbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIGNsaWVudEFwaSwgcmVnaXN0cnkgfSk7XG4gIGNvbnN0IGJhc2VJbnN0YW5jZSA9IGNyZWF0ZUJhc2VJbnN0YW5jZShyZWdpc3RyeSwgY29vcmRpbmF0ZSk7XG4gIHJldHVybiB7IC4uLmJhc2VJbnN0YW5jZSwgY2xpZW50QXBpIH07XG59XG4iLCJpbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiLi9DbGllbnRBcGlcIjtcbmltcG9ydCB7IEluc3RhbmNlRmFjdG9yeSBhcyBCYXNlSW5zdGFuY2VGYWN0b3J5LCBSZWdpc3RyeSwgUmVnaXN0cnlIdWIgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBjcmVhdGVJbnN0YW5jZSwgSW5zdGFuY2UgfSBmcm9tIFwiLi9JbnN0YW5jZVwiO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCJAZmplbGwvcmVnaXN0cnlcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJJbnN0YW5jZUZhY3RvcnlcIik7XG5cbmV4cG9ydCB0eXBlIEluc3RhbmNlRmFjdG9yeTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9IChcbiAgY2xpZW50QXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKSA9PiBCYXNlSW5zdGFuY2VGYWN0b3J5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50LWFwaSBpbnN0YW5jZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUluc3RhbmNlRmFjdG9yeSA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBjbGllbnRBcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IEJhc2VJbnN0YW5jZUZhY3Rvcnk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG4gIHJldHVybiAoY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBjb250ZXh0OiB7IHJlZ2lzdHJ5OiBSZWdpc3RyeSwgcmVnaXN0cnlIdWI/OiBSZWdpc3RyeUh1YiB9KSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiQ3JlYXRpbmcgY2xpZW50LWFwaSBpbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5OiBjb250ZXh0LnJlZ2lzdHJ5LCBjbGllbnRBcGkgfSk7XG5cbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UoY29udGV4dC5yZWdpc3RyeSwgY29vcmRpbmF0ZSwgY2xpZW50QXBpKSBhcyBJbnN0YW5jZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICB9O1xufTtcbiIsImltcG9ydCBMaWJMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHtcbiAgUmVnaXN0cnkgYXMgQmFzZVJlZ2lzdHJ5LFxuICBjcmVhdGVSZWdpc3RyeSBhcyBjcmVhdGVCYXNlUmVnaXN0cnksXG4gIFJlZ2lzdHJ5RmFjdG9yeSxcbiAgUmVnaXN0cnlIdWJcbn0gZnJvbSAnQGZqZWxsL3JlZ2lzdHJ5JztcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIlJlZ2lzdHJ5XCIpO1xuXG4vKipcbiAqIEV4dGVuZGVkIFJlZ2lzdHJ5IGludGVyZmFjZSBmb3IgY2xpZW50LWFwaS1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cnkgZXh0ZW5kcyBCYXNlUmVnaXN0cnkge1xuICB0eXBlOiAnY2xpZW50LWFwaSc7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50LWFwaSByZWdpc3RyaWVzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWdpc3RyeUZhY3RvcnkgPSAoKTogUmVnaXN0cnlGYWN0b3J5ID0+IHtcbiAgcmV0dXJuICh0eXBlOiBzdHJpbmcsIHJlZ2lzdHJ5SHViPzogUmVnaXN0cnlIdWIpOiBCYXNlUmVnaXN0cnkgPT4ge1xuICAgIGlmICh0eXBlICE9PSAnY2xpZW50LWFwaScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IEFQSSByZWdpc3RyeSBmYWN0b3J5IGNhbiBvbmx5IGNyZWF0ZSAnY2xpZW50LWFwaScgdHlwZSByZWdpc3RyaWVzLCBnb3Q6ICR7dHlwZX1gKTtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoXCJDcmVhdGluZyBjbGllbnQtYXBpIHJlZ2lzdHJ5XCIsIHsgdHlwZSwgcmVnaXN0cnlIdWIgfSk7XG5cbiAgICBjb25zdCBiYXNlUmVnaXN0cnkgPSBjcmVhdGVCYXNlUmVnaXN0cnkodHlwZSwgcmVnaXN0cnlIdWIpO1xuXG4gICAgLy8gQ2FzdCB0byBSZWdpc3RyeSBmb3IgdHlwZSBzYWZldHlcbiAgICByZXR1cm4gYmFzZVJlZ2lzdHJ5IGFzIFJlZ2lzdHJ5O1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNsaWVudC1hcGkgcmVnaXN0cnkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5SHViPzogUmVnaXN0cnlIdWIpOiBSZWdpc3RyeSA9PiB7XG4gIGNvbnN0IGJhc2VSZWdpc3RyeSA9IGNyZWF0ZUJhc2VSZWdpc3RyeSgnY2xpZW50LWFwaScsIHJlZ2lzdHJ5SHViKTtcblxuICByZXR1cm4ge1xuICAgIC4uLmJhc2VSZWdpc3RyeSxcbiAgfSBhcyBSZWdpc3RyeTtcbn07XG4iLCIvKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBDbGllbnQgQVBJIGVycm9yc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xpZW50QXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGFic3RyYWN0IHJlYWRvbmx5IGNvZGU6IHN0cmluZztcbiAgYWJzdHJhY3QgcmVhZG9ubHkgaXNSZXRyeWFibGU6IGJvb2xlYW47XG4gIHJlYWRvbmx5IHRpbWVzdGFtcDogRGF0ZTtcbiAgcmVhZG9ubHkgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT47XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgIC8vIEVuc3VyZSBwcm9wZXIgcHJvdG90eXBlIGNoYWluIGZvciBpbnN0YW5jZW9mIGNoZWNrc1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGlzUmV0cnlhYmxlOiB0aGlzLmlzUmV0cnlhYmxlLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIE5ldHdvcmstcmVsYXRlZCBlcnJvcnMgKGNvbm5lY3Rpb24gaXNzdWVzLCB0aW1lb3V0cylcbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIENsaWVudEFwaUVycm9yIHtcbiAgcmVhZG9ubHkgY29kZSA9ICdORVRXT1JLX0VSUk9SJztcbiAgcmVhZG9ubHkgaXNSZXRyeWFibGUgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihgTmV0d29yayBlcnJvcjogJHttZXNzYWdlfWAsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogSFRUUCB0aW1lb3V0IGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ1RJTUVPVVRfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IodGltZW91dDogbnVtYmVyLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKGBSZXF1ZXN0IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXNgLCBjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEF1dGhlbnRpY2F0aW9uIGVycm9ycyAoNDAxIFVuYXV0aG9yaXplZClcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnQVVUSEVOVElDQVRJT05fRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCAnQXV0aGVudGljYXRpb24gZmFpbGVkIC0gaW52YWxpZCBvciBleHBpcmVkIGNyZWRlbnRpYWxzJywgY29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdXRob3JpemF0aW9uIGVycm9ycyAoNDAzIEZvcmJpZGRlbilcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhvcml6YXRpb25FcnJvciBleHRlbmRzIENsaWVudEFwaUVycm9yIHtcbiAgcmVhZG9ubHkgY29kZSA9ICdBVVRIT1JJWkFUSU9OX0VSUk9SJztcbiAgcmVhZG9ubHkgaXNSZXRyeWFibGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ0FjY2VzcyBmb3JiaWRkZW4gLSBpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnLCBjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc291cmNlIG5vdCBmb3VuZCBlcnJvcnMgKDQwNCBOb3QgRm91bmQpXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ05PVF9GT1VORF9FUlJPUic7XG4gIHJlYWRvbmx5IGlzUmV0cnlhYmxlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocmVzb3VyY2U6IHN0cmluZywgaWRlbnRpZmllcj86IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaWRlbnRpZmllclxuICAgICAgPyBgJHtyZXNvdXJjZX0gd2l0aCBpZGVudGlmaWVyICcke2lkZW50aWZpZXJ9JyBub3QgZm91bmRgXG4gICAgICA6IGAke3Jlc291cmNlfSBub3QgZm91bmRgO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogUmVxdWVzdCB2YWxpZGF0aW9uIGVycm9ycyAoNDAwIEJhZCBSZXF1ZXN0KVxuICovXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ1ZBTElEQVRJT05fRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuICByZWFkb25seSB2YWxpZGF0aW9uRXJyb3JzPzogQXJyYXk8eyBmaWVsZDogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfT47XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCB2YWxpZGF0aW9uRXJyb3JzPzogQXJyYXk8eyBmaWVsZDogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfT4sIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoYFZhbGlkYXRpb24gZXJyb3I6ICR7bWVzc2FnZX1gLCBjb250ZXh0KTtcbiAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmxpY3QgZXJyb3JzICg0MDkgQ29uZmxpY3QpXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ0NPTkZMSUNUX0VSUk9SJztcbiAgcmVhZG9ubHkgaXNSZXRyeWFibGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoYENvbmZsaWN0OiAke21lc3NhZ2V9YCwgY29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSYXRlIGxpbWl0aW5nIGVycm9ycyAoNDI5IFRvbyBNYW55IFJlcXVlc3RzKVxuICovXG5leHBvcnQgY2xhc3MgUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnUkFURV9MSU1JVF9FUlJPUic7XG4gIHJlYWRvbmx5IGlzUmV0cnlhYmxlID0gdHJ1ZTtcbiAgcmVhZG9ubHkgcmV0cnlBZnRlcj86IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihyZXRyeUFmdGVyPzogbnVtYmVyLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSByZXRyeUFmdGVyXG4gICAgICA/IGBSYXRlIGxpbWl0IGV4Y2VlZGVkIC0gcmV0cnkgYWZ0ZXIgJHtyZXRyeUFmdGVyfSBzZWNvbmRzYFxuICAgICAgOiAnUmF0ZSBsaW1pdCBleGNlZWRlZCc7XG4gICAgc3VwZXIobWVzc2FnZSwgY29udGV4dCk7XG4gICAgdGhpcy5yZXRyeUFmdGVyID0gcmV0cnlBZnRlcjtcbiAgfVxufVxuXG4vKipcbiAqIFNlcnZlciBlcnJvcnMgKDV4eCBzdGF0dXMgY29kZXMpXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIENsaWVudEFwaUVycm9yIHtcbiAgcmVhZG9ubHkgY29kZSA9ICdTRVJWRVJfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IHRydWU7XG4gIHJlYWRvbmx5IHN0YXR1c0NvZGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlOiBudW1iZXIsIG1lc3NhZ2U/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCBgU2VydmVyIGVycm9yICgke3N0YXR1c0NvZGV9KWAsIGNvbnRleHQpO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXF1ZXN0IHBheWxvYWQgdG9vIGxhcmdlIGVycm9ycyAoNDEzKVxuICovXG5leHBvcnQgY2xhc3MgUGF5bG9hZFRvb0xhcmdlRXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnUEFZTE9BRF9UT09fTEFSR0VfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1heFNpemU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1heFNpemVcbiAgICAgID8gYFJlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UgLSBtYXhpbXVtIHNpemUgaXMgJHttYXhTaXplfWBcbiAgICAgIDogJ1JlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UnO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJpYyBIVFRQIGVycm9ycyBmb3IgdW5oYW5kbGVkIHN0YXR1cyBjb2Rlc1xuICovXG5leHBvcnQgY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ0hUVFBfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZTogYm9vbGVhbjtcbiAgcmVhZG9ubHkgc3RhdHVzQ29kZTogbnVtYmVyO1xuICByZWFkb25seSBzdGF0dXNUZXh0OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZTogbnVtYmVyLCBzdGF0dXNUZXh0OiBzdHJpbmcsIG1lc3NhZ2U/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCBgSFRUUCBlcnJvciAke3N0YXR1c0NvZGV9OiAke3N0YXR1c1RleHR9YCwgY29udGV4dCk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuXG4gICAgLy8gNXh4IGVycm9ycyBhcmUgZ2VuZXJhbGx5IHJldHJ5YWJsZSwgNHh4IGFyZSBub3RcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gc3RhdHVzQ29kZSA+PSA1MDA7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ0NPTkZJR1VSQVRJT05fRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihgQ29uZmlndXJhdGlvbiBlcnJvcjogJHttZXNzYWdlfWAsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2Uvc2VyaWFsaXphdGlvbiBlcnJvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnUEFSU0VfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihgUGFyc2UgZXJyb3I6ICR7bWVzc2FnZX1gLCBjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhcHByb3ByaWF0ZSBlcnJvciBmcm9tIEhUVFAgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUh0dHBFcnJvcihcbiAgc3RhdHVzQ29kZTogbnVtYmVyLFxuICBzdGF0dXNUZXh0OiBzdHJpbmcsXG4gIHJlc3BvbnNlQm9keT86IGFueSxcbiAgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT5cbik6IENsaWVudEFwaUVycm9yIHtcbiAgY29uc3QgZXJyb3JDb250ZXh0ID0geyBzdGF0dXNDb2RlLCBzdGF0dXNUZXh0LCByZXNwb25zZUJvZHksIC4uLmNvbnRleHQgfTtcblxuICBzd2l0Y2ggKHN0YXR1c0NvZGUpIHtcbiAgICBjYXNlIDQwMDpcbiAgICAgIGlmIChyZXNwb25zZUJvZHk/LnZhbGlkYXRpb25FcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgcmVzcG9uc2VCb2R5Lm1lc3NhZ2UgfHwgJ1JlcXVlc3QgdmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgIHJlc3BvbnNlQm9keS52YWxpZGF0aW9uRXJyb3JzLFxuICAgICAgICAgIGVycm9yQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IocmVzcG9uc2VCb2R5Py5tZXNzYWdlIHx8IHN0YXR1c1RleHQsIFtdLCBlcnJvckNvbnRleHQpO1xuXG4gICAgY2FzZSA0MDE6XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IocmVzcG9uc2VCb2R5Py5tZXNzYWdlLCBlcnJvckNvbnRleHQpO1xuXG4gICAgY2FzZSA0MDM6XG4gICAgICByZXR1cm4gbmV3IEF1dGhvcml6YXRpb25FcnJvcihyZXNwb25zZUJvZHk/Lm1lc3NhZ2UsIGVycm9yQ29udGV4dCk7XG5cbiAgICBjYXNlIDQwNDpcbiAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihcbiAgICAgICAgcmVzcG9uc2VCb2R5Py5yZXNvdXJjZSB8fCAnUmVzb3VyY2UnLFxuICAgICAgICByZXNwb25zZUJvZHk/LmlkZW50aWZpZXIsXG4gICAgICAgIGVycm9yQ29udGV4dFxuICAgICAgKTtcblxuICAgIGNhc2UgNDA5OlxuICAgICAgcmV0dXJuIG5ldyBDb25mbGljdEVycm9yKHJlc3BvbnNlQm9keT8ubWVzc2FnZSB8fCBzdGF0dXNUZXh0LCBlcnJvckNvbnRleHQpO1xuXG4gICAgY2FzZSA0MTM6XG4gICAgICByZXR1cm4gbmV3IFBheWxvYWRUb29MYXJnZUVycm9yKHJlc3BvbnNlQm9keT8ubWF4U2l6ZSwgZXJyb3JDb250ZXh0KTtcblxuICAgIGNhc2UgNDI5OiB7XG4gICAgICBsZXQgcmV0cnlBZnRlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKHJlc3BvbnNlQm9keT8ucmV0cnlBZnRlcikge1xuICAgICAgICByZXRyeUFmdGVyID0gcmVzcG9uc2VCb2R5LnJldHJ5QWZ0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQ/LmhlYWRlcnM/LlsncmV0cnktYWZ0ZXInXSkge1xuICAgICAgICByZXRyeUFmdGVyID0gcGFyc2VJbnQoY29udGV4dC5oZWFkZXJzWydyZXRyeS1hZnRlciddKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0RXJyb3IocmV0cnlBZnRlciwgZXJyb3JDb250ZXh0KTtcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gNTAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyRXJyb3Ioc3RhdHVzQ29kZSwgcmVzcG9uc2VCb2R5Py5tZXNzYWdlIHx8IHN0YXR1c1RleHQsIGVycm9yQ29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgSHR0cEVycm9yKHN0YXR1c0NvZGUsIHN0YXR1c1RleHQsIHJlc3BvbnNlQm9keT8ubWVzc2FnZSwgZXJyb3JDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhcHByb3ByaWF0ZSBlcnJvciBmcm9tIG5ldHdvcmsvY29ubmVjdGlvbiBpc3N1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5ldHdvcmtFcnJvcihlcnJvcjogYW55LCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pik6IENsaWVudEFwaUVycm9yIHtcbiAgY29uc3QgZXJyb3JDb250ZXh0ID0geyBvcmlnaW5hbEVycm9yOiBlcnJvciwgLi4uY29udGV4dCB9O1xuXG4gIGlmIChlcnJvci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndGltZW91dCcpKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lb3V0RXJyb3IoZXJyb3IudGltZW91dCB8fCA1MDAwLCBlcnJvckNvbnRleHQpO1xuICB9XG5cbiAgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnIHx8XG4gICAgZXJyb3IuY29kZSA9PT0gJ0VOT1RGT1VORCcgfHxcbiAgICBlcnJvci5jb2RlID09PSAnRU5FVFVOUkVBQ0gnIHx8XG4gICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgIHJldHVybiBuZXcgTmV0d29ya0Vycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQnLCBlcnJvckNvbnRleHQpO1xuICB9XG5cbiAgLy8gRm9yIHVua25vd24gZXJyb3JzLCB0cmVhdCBhcyBuZXR3b3JrIGlzc3VlcyB0aGF0IG1pZ2h0IGJlIHJldHJ5YWJsZVxuICByZXR1cm4gbmV3IE5ldHdvcmtFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIG5ldHdvcmsgZXJyb3InLCBlcnJvckNvbnRleHQpO1xufVxuXG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgZXJyb3IgaXMgcmV0cnlhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JldHJ5YWJsZUVycm9yKGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgQ2xpZW50QXBpRXJyb3IgJiYgZXJyb3IuaXNSZXRyeWFibGU7XG59XG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBlcnJvciBpcyBhIENsaWVudCBBUEkgZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xpZW50QXBpRXJyb3IoZXJyb3I6IGFueSk6IGVycm9yIGlzIENsaWVudEFwaUVycm9yIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgQ2xpZW50QXBpRXJyb3I7XG59XG4iLCJpbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSAnQGZqZWxsL2h0dHAtYXBpJztcbmltcG9ydCB7XG4gIENsaWVudEFwaUVycm9yLFxuICBjcmVhdGVIdHRwRXJyb3IsXG4gIGNyZWF0ZU5ldHdvcmtFcnJvcixcbiAgUmF0ZUxpbWl0RXJyb3Jcbn0gZnJvbSAnLi4vZXJyb3JzL2luZGV4JztcblxuLy8gU2ltcGxlIGxvZ2dlciBpbnRlcmZhY2UgZm9yIG5vd1xuY29uc3QgbG9nZ2VyID0ge1xuICBkZWJ1ZzogKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IGFueSkgPT4gY29uc29sZS5kZWJ1ZyhtZXNzYWdlLCBjb250ZXh0KSxcbiAgaW5mbzogKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IGFueSkgPT4gY29uc29sZS5pbmZvKG1lc3NhZ2UsIGNvbnRleHQpLFxuICB3YXJuaW5nOiAobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogYW55KSA9PiBjb25zb2xlLndhcm4obWVzc2FnZSwgY29udGV4dCksXG4gIGVycm9yOiAobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogYW55KSA9PiBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGNvbnRleHQpXG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIHJldHJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlDb25maWcge1xuICAvKiogTWF4aW11bSBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgKGRlZmF1bHQ6IDMpICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIC8qKiBJbml0aWFsIGRlbGF5IGJldHdlZW4gcmV0cmllcyBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDEwMDApICovXG4gIGluaXRpYWxEZWxheU1zPzogbnVtYmVyO1xuICAvKiogTWF4aW11bSBkZWxheSBiZXR3ZWVuIHJldHJpZXMgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiAzMDAwMCkgKi9cbiAgbWF4RGVsYXlNcz86IG51bWJlcjtcbiAgLyoqIEJhY2tvZmYgbXVsdGlwbGllciBmb3IgZXhwb25lbnRpYWwgYmFja29mZiAoZGVmYXVsdDogMikgKi9cbiAgYmFja29mZk11bHRpcGxpZXI/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIGFkZCBqaXR0ZXIgdG8gcmV0cnkgZGVsYXlzIChkZWZhdWx0OiB0cnVlKSAqL1xuICBlbmFibGVKaXR0ZXI/OiBib29sZWFuO1xuICAvKiogQ3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBzaG91bGQgYmUgcmV0cmllZCAqL1xuICBzaG91bGRSZXRyeT86IChlcnJvcjogQ2xpZW50QXBpRXJyb3IsIGF0dGVtcHROdW1iZXI6IG51bWJlcikgPT4gYm9vbGVhbjtcbiAgLyoqIENhbGxlZCBiZWZvcmUgZWFjaCByZXRyeSBhdHRlbXB0ICovXG4gIG9uUmV0cnk/OiAoZXJyb3I6IENsaWVudEFwaUVycm9yLCBhdHRlbXB0TnVtYmVyOiBudW1iZXIsIGRlbGF5OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogRGVmYXVsdCByZXRyeSBjb25maWd1cmF0aW9uXG4gKi9cbmNvbnN0IERFRkFVTFRfUkVUUllfQ09ORklHOiBSZXF1aXJlZDxSZXRyeUNvbmZpZz4gPSB7XG4gIG1heFJldHJpZXM6IDMsXG4gIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICBtYXhEZWxheU1zOiAzMDAwMCxcbiAgYmFja29mZk11bHRpcGxpZXI6IDIsXG4gIGVuYWJsZUppdHRlcjogdHJ1ZSxcbiAgc2hvdWxkUmV0cnk6IChlcnJvcjogQ2xpZW50QXBpRXJyb3IsIGF0dGVtcHROdW1iZXI6IG51bWJlcikgPT4ge1xuICAgIC8vIERvbid0IHJldHJ5IGFmdGVyIG1heCBhdHRlbXB0c1xuICAgIGlmIChhdHRlbXB0TnVtYmVyID49IDMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEFsd2F5cyByZXRyeSByZXRyeWFibGUgZXJyb3JzXG4gICAgaWYgKGVycm9yLmlzUmV0cnlhYmxlKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIERvbid0IHJldHJ5IG5vbi1yZXRyeWFibGUgZXJyb3JzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBvblJldHJ5OiAoZXJyb3I6IENsaWVudEFwaUVycm9yLCBhdHRlbXB0TnVtYmVyOiBudW1iZXIsIGRlbGF5OiBudW1iZXIpID0+IHtcbiAgICBsb2dnZXIud2FybmluZyhgUmV0cnlpbmcgSFRUUCByZXF1ZXN0IChhdHRlbXB0ICR7YXR0ZW1wdE51bWJlciArIDF9KSBhZnRlciAke2RlbGF5fW1zYCwge1xuICAgICAgZXJyb3JDb2RlOiBlcnJvci5jb2RlLFxuICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgZGVsYXksXG4gICAgICBhdHRlbXB0TnVtYmVyXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2xlZXAgdXRpbGl0eSBmb3IgcmV0cnkgZGVsYXlzXG4gKi9cbmNvbnN0IHNsZWVwID0gKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkZWxheSBmb3IgZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIG9wdGlvbmFsIGppdHRlclxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVEZWxheShcbiAgYXR0ZW1wdE51bWJlcjogbnVtYmVyLFxuICBjb25maWc6IFJlcXVpcmVkPFJldHJ5Q29uZmlnPlxuKTogbnVtYmVyIHtcbiAgY29uc3QgZXhwb25lbnRpYWxEZWxheSA9IGNvbmZpZy5pbml0aWFsRGVsYXlNcyAqIE1hdGgucG93KGNvbmZpZy5iYWNrb2ZmTXVsdGlwbGllciwgYXR0ZW1wdE51bWJlcik7XG4gIGNvbnN0IGNhcHBlZERlbGF5ID0gTWF0aC5taW4oZXhwb25lbnRpYWxEZWxheSwgY29uZmlnLm1heERlbGF5TXMpO1xuXG4gIGlmICghY29uZmlnLmVuYWJsZUppdHRlcikge1xuICAgIHJldHVybiBjYXBwZWREZWxheTtcbiAgfVxuXG4gIC8vIEFkZCBqaXR0ZXI6IHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIDUwJSBhbmQgMTAwJSBvZiBjYWxjdWxhdGVkIGRlbGF5XG4gIGNvbnN0IGppdHRlciA9IDAuNSArIChNYXRoLnJhbmRvbSgpICogMC41KTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoY2FwcGVkRGVsYXkgKiBqaXR0ZXIpO1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIEhUVFAgd3JhcHBlciB3aXRoIHJldHJ5IGxvZ2ljIGFuZCBjb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwV3JhcHBlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXBpOiBIdHRwQXBpO1xuICBwcml2YXRlIHJlYWRvbmx5IHJldHJ5Q29uZmlnOiBSZXF1aXJlZDxSZXRyeUNvbmZpZz47XG5cbiAgY29uc3RydWN0b3IoYXBpOiBIdHRwQXBpLCByZXRyeUNvbmZpZzogUmV0cnlDb25maWcgPSB7fSkge1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMucmV0cnlDb25maWcgPSB7IC4uLkRFRkFVTFRfUkVUUllfQ09ORklHLCAuLi5yZXRyeUNvbmZpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgSFRUUCBvcGVyYXRpb24gd2l0aCByZXRyeSBsb2dpYyBhbmQgZXJyb3IgaGFuZGxpbmdcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVXaXRoUmV0cnk8VD4oXG4gICAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PlxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgbGFzdEVycm9yOiBDbGllbnRBcGlFcnJvciB8IG51bGwgPSBudWxsO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8PSB0aGlzLnJldHJ5Q29uZmlnLm1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBFeGVjdXRpbmcgJHtvcGVyYXRpb25OYW1lfWAsIHtcbiAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0ICsgMSxcbiAgICAgICAgICBtYXhSZXRyaWVzOiB0aGlzLnJldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxLFxuICAgICAgICAgIC4uLmNvbnRleHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYCR7b3BlcmF0aW9uTmFtZX0gc3VjY2VlZGVkIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllc2AsIHtcbiAgICAgICAgICAgIHRvdGFsQXR0ZW1wdHM6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICAuLi5jb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gdGhpcy5jb252ZXJ0VG9DbGllbnRBcGlFcnJvcihlcnJvciwgb3BlcmF0aW9uTmFtZSwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gdGhlIGxhc3QgYXR0ZW1wdFxuICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gdGhpcy5yZXRyeUNvbmZpZy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgcmV0cnkgdGhpcyBlcnJvclxuICAgICAgICBpZiAoIXRoaXMucmV0cnlDb25maWcuc2hvdWxkUmV0cnkobGFzdEVycm9yLCBhdHRlbXB0KSkge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm90IHJldHJ5aW5nICR7b3BlcmF0aW9uTmFtZX0gZHVlIHRvIG5vbi1yZXRyeWFibGUgZXJyb3JgLCB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IGxhc3RFcnJvci5jb2RlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBsYXN0RXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgICAgLi4uY29udGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgd2l0aCBjdXN0b20gZGVsYXlcbiAgICAgICAgbGV0IGRlbGF5ID0gY2FsY3VsYXRlRGVsYXkoYXR0ZW1wdCwgdGhpcy5yZXRyeUNvbmZpZyk7XG4gICAgICAgIGlmIChsYXN0RXJyb3IgaW5zdGFuY2VvZiBSYXRlTGltaXRFcnJvciAmJiBsYXN0RXJyb3IucmV0cnlBZnRlcikge1xuICAgICAgICAgIGRlbGF5ID0gTWF0aC5tYXgoZGVsYXksIGxhc3RFcnJvci5yZXRyeUFmdGVyICogMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIHJldHJ5IGNhbGxiYWNrXG4gICAgICAgIHRoaXMucmV0cnlDb25maWcub25SZXRyeShsYXN0RXJyb3IsIGF0dGVtcHQsIGRlbGF5KTtcblxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeWluZ1xuICAgICAgICBhd2FpdCBzbGVlcChkZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9nIGZpbmFsIGZhaWx1cmVcbiAgICBsb2dnZXIuZXJyb3IoYCR7b3BlcmF0aW9uTmFtZX0gZmFpbGVkIGFmdGVyICR7dGhpcy5yZXRyeUNvbmZpZy5tYXhSZXRyaWVzICsgMX0gYXR0ZW1wdHNgLCB7XG4gICAgICBlcnJvckNvZGU6IGxhc3RFcnJvcj8uY29kZSxcbiAgICAgIGVycm9yTWVzc2FnZTogbGFzdEVycm9yPy5tZXNzYWdlLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAuLi5jb250ZXh0XG4gICAgfSk7XG5cbiAgICB0aHJvdyBsYXN0RXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbnkgZXJyb3IgdG8gYSBDbGllbnRBcGlFcnJvclxuICAgKi9cbiAgcHJpdmF0ZSBjb252ZXJ0VG9DbGllbnRBcGlFcnJvcihcbiAgICBlcnJvcjogYW55LFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PlxuICApOiBDbGllbnRBcGlFcnJvciB7XG4gICAgY29uc3QgZXJyb3JDb250ZXh0ID0geyBvcGVyYXRpb246IG9wZXJhdGlvbk5hbWUsIC4uLmNvbnRleHQgfTtcblxuICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhIENsaWVudEFwaUVycm9yLCByZXR1cm4gYXMtaXNcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDbGllbnRBcGlFcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBIVFRQIHJlc3BvbnNlIGVycm9yc1xuICAgIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgICAgY29uc3QgeyBzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEsIGhlYWRlcnMgfSA9IGVycm9yLnJlc3BvbnNlO1xuICAgICAgcmV0dXJuIGNyZWF0ZUh0dHBFcnJvcihzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEsIHtcbiAgICAgICAgLi4uZXJyb3JDb250ZXh0LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICB1cmw6IGVycm9yLmNvbmZpZz8udXJsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVxdWVzdCBlcnJvcnMgKG5ldHdvcmsgaXNzdWVzLCB0aW1lb3V0cywgZXRjLilcbiAgICBpZiAoZXJyb3IucmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5ldHdvcmtFcnJvcihlcnJvciwge1xuICAgICAgICAuLi5lcnJvckNvbnRleHQsXG4gICAgICAgIHVybDogZXJyb3IuY29uZmlnPy51cmwsXG4gICAgICAgIG1ldGhvZDogZXJyb3IuY29uZmlnPy5tZXRob2RcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb25maWd1cmF0aW9uIG9yIG90aGVyIGVycm9yc1xuICAgIHJldHVybiBjcmVhdGVOZXR3b3JrRXJyb3IoZXJyb3IsIGVycm9yQ29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgSFRUUCBHRVQgb3BlcmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0PFQ+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBhbnksXG4gICAgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVdpdGhSZXRyeShcbiAgICAgICgpID0+IHRoaXMuYXBpLmh0dHBHZXQodXJsLCBvcHRpb25zKSxcbiAgICAgICdHRVQnLFxuICAgICAgeyB1cmwsIC4uLmNvbnRleHQgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgSFRUUCBQT1NUIG9wZXJhdGlvbnNcbiAgICovXG4gIGFzeW5jIHBvc3Q8VD4oXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgZGF0YT86IGFueSxcbiAgICBvcHRpb25zPzogYW55LFxuICAgIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVXaXRoUmV0cnkoXG4gICAgICAoKSA9PiB0aGlzLmFwaS5odHRwUG9zdCh1cmwsIGRhdGEsIG9wdGlvbnMpLFxuICAgICAgJ1BPU1QnLFxuICAgICAgeyB1cmwsIGhhc0RhdGE6ICEhZGF0YSwgLi4uY29udGV4dCB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIGZvciBIVFRQIFBVVCBvcGVyYXRpb25zXG4gICAqL1xuICBhc3luYyBwdXQ8VD4oXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgZGF0YT86IGFueSxcbiAgICBvcHRpb25zPzogYW55LFxuICAgIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVXaXRoUmV0cnkoXG4gICAgICAoKSA9PiB0aGlzLmFwaS5odHRwUHV0KHVybCwgZGF0YSwgb3B0aW9ucyksXG4gICAgICAnUFVUJyxcbiAgICAgIHsgdXJsLCBoYXNEYXRhOiAhIWRhdGEsIC4uLmNvbnRleHQgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgSFRUUCBERUxFVEUgb3BlcmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgZGVsZXRlPFQ+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBhbnksXG4gICAgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVdpdGhSZXRyeShcbiAgICAgICgpID0+IHRoaXMuYXBpLmh0dHBEZWxldGUodXJsLCBvcHRpb25zKSxcbiAgICAgICdERUxFVEUnLFxuICAgICAgeyB1cmwsIC4uLmNvbnRleHQgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHJldHJ5IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHVwZGF0ZVJldHJ5Q29uZmlnKG5ld0NvbmZpZzogUGFydGlhbDxSZXRyeUNvbmZpZz4pOiB2b2lkIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMucmV0cnlDb25maWcsIG5ld0NvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcmV0cnkgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0UmV0cnlDb25maWcoKTogUmVxdWlyZWQ8UmV0cnlDb25maWc+IHtcbiAgICByZXR1cm4geyAuLi50aGlzLnJldHJ5Q29uZmlnIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJsb2dnZXIiLCJhY3Rpb24iLCJxdWVyeVRvUGFyYW1zIiwiZmFjZXQiLCJQcmlLZXkiLCJMb2NLZXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../fjell-client-api/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-http-api/dist/index.js":
/*!***************************************!*\
  !*** ../fjell-http-api/dist/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   ForbiddenError: () => (/* binding */ ForbiddenError),\n/* harmony export */   GoneError: () => (/* binding */ GoneError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   MethodNotAllowedError: () => (/* binding */ MethodNotAllowedError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),\n/* harmony export */   RequestTimeoutError: () => (/* binding */ RequestTimeoutError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   ServiceUnavailableError: () => (/* binding */ ServiceUnavailableError),\n/* harmony export */   TooManyRequestsError: () => (/* binding */ TooManyRequestsError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   connectMethod: () => (/* binding */ connectMethod),\n/* harmony export */   deleteMethod: () => (/* binding */ deleteMethod2),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getHttp: () => (/* binding */ getHttp),\n/* harmony export */   getHttpApi: () => (/* binding */ getHttpApi),\n/* harmony export */   getHttpFile: () => (/* binding */ getHttpFile),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   optionsMethod: () => (/* binding */ optionsMethod),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   patchMethod: () => (/* binding */ patchMethod),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   postFileMethod: () => (/* binding */ postFileMethod2),\n/* harmony export */   postMethod: () => (/* binding */ postMethod),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   putMethod: () => (/* binding */ putMethod),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   traceMethod: () => (/* binding */ traceMethod),\n/* harmony export */   uploadAsyncMethod: () => (/* binding */ uploadAsyncMethod2)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-http-api/node_modules/@fjell/logging/dist/index.js\");\n// src/errors.ts\nvar APIError = class _APIError extends Error {\n    constructor(message, path, httpResponseCode, options2){\n        super(message, options2);\n        this.httpResponseCode = httpResponseCode;\n        this.path = path;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, _APIError);\n        }\n    }\n};\nvar ClientError = class extends APIError {\n    constructor(message, path, httpResponseCode, options2){\n        super(message, path, httpResponseCode, options2);\n    }\n};\nvar BadRequestError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 400, options2);\n    }\n};\nvar UnauthorizedError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 401, options2);\n    }\n};\nvar ForbiddenError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 403, options2);\n    }\n};\nvar NotFoundError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 404, options2);\n    }\n};\nvar MethodNotAllowedError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 405, options2);\n    }\n};\nvar RequestTimeoutError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 408, options2);\n    }\n};\nvar ConflictError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 409, options2);\n    }\n};\nvar GoneError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 410, options2);\n    }\n};\nvar TooManyRequestsError = class extends ClientError {\n    constructor(message, path, options2){\n        super(`${message} ${path}`, path, 429, options2);\n    }\n};\nvar ServerError = class extends APIError {\n    constructor(message, path, httpResponseCode, options2){\n        super(message, path, httpResponseCode, options2);\n    }\n};\nvar InternalServerError = class extends ServerError {\n    constructor(message, path, options2){\n        super(message, path, 500, options2);\n    }\n};\nvar NotImplementedError = class extends ServerError {\n    constructor(message, path, options2){\n        super(message, path, 501, options2);\n    }\n};\nvar ServiceUnavailableError = class extends ServerError {\n    constructor(message, path, options2){\n        super(message, path, 503, options2);\n    }\n};\n// src/api/util.ts\nvar getParameterValue = (value)=>{\n    if (value) {\n        return value instanceof Date ? value.toISOString() : value.toString();\n    } else {\n        return \"\";\n    }\n};\nvar generateQueryParameters = (params)=>Object.keys(params).length > 0 ? \"?\" + Object.keys(params).filter((key)=>params[key] !== void 0 && (typeof params[key] === \"string\" && params[key].length === 0) === false).map((key)=>{\n        let value;\n        if (params[key] === false) {\n            value = \"false\";\n        } else {\n            value = params[key];\n        }\n        return `${key}=${encodeURIComponent(getParameterValue(value))}`;\n    }).join(\"&\") : \"\";\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/http-api\");\nvar logger_default = LibLogger;\n// src/api/http.ts\nvar logger = logger_default.get(\"api\", \"http\");\nfunction getHttp(apiParams) {\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (method, path, body = {}, httpOptions = {})=>{\n        logger.trace(\"http\", {\n            method,\n            path,\n            body,\n            httpOptions\n        });\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...httpOptions\n        };\n        const config = apiParams.config;\n        const populateAuthHeader = apiParams.populateAuthHeader;\n        const headers = {};\n        if (!options2.skipContentType) {\n            headers[\"Content-Type\"] = options2.contentType;\n        }\n        headers[\"Accept\"] = options2.accept;\n        headers[\"X-Client-Name\"] = config.clientName;\n        const debugOptions = {\n            ...options2,\n            method,\n            path,\n            body\n        };\n        await populateAuthHeader(options2.isAuthenticated, headers);\n        logger.debug(\"http Request: %j, %j\", method, path);\n        const fetchOptions = {\n            method,\n            headers,\n            credentials: options2.requestCredentials\n        };\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            fetchOptions.body = body ? options2.isJsonBody ? JSON.stringify(body) : body : null;\n        }\n        const response = await fetch(`${config.url}${path}${generateQueryParameters(options2.params)}`, fetchOptions);\n        let returnValue;\n        returnValue = await response.text();\n        if (response.status >= 400) {\n            let error;\n            if (response.status >= 500) {\n                if (response.status === 500) {\n                    error = new InternalServerError(response.statusText, path, debugOptions);\n                } else if (response.status === 501) {\n                    error = new NotImplementedError(response.statusText, path, debugOptions);\n                } else if (response.status === 503) {\n                    error = new ServiceUnavailableError(response.statusText, path, debugOptions);\n                } else {\n                    error = new ServerError(response.statusText, path, response.status, debugOptions);\n                }\n            } else {\n                if (response.status === 400) {\n                    error = new BadRequestError(response.statusText, path, debugOptions);\n                } else if (response.status === 401) {\n                    error = new UnauthorizedError(response.statusText, path, debugOptions);\n                } else if (response.status === 403) {\n                    error = new ForbiddenError(response.statusText, path, debugOptions);\n                } else if (response.status === 404) {\n                    error = new NotFoundError(response.statusText, path, debugOptions);\n                } else if (response.status === 405) {\n                    error = new MethodNotAllowedError(response.statusText, path, debugOptions);\n                } else if (response.status === 408) {\n                    error = new RequestTimeoutError(response.statusText, path, debugOptions);\n                } else if (response.status === 409) {\n                    error = new ConflictError(response.statusText, path, debugOptions);\n                } else if (response.status === 410) {\n                    error = new GoneError(response.statusText, path, debugOptions);\n                } else if (response.status === 429) {\n                    error = new TooManyRequestsError(response.statusText, path, debugOptions);\n                } else {\n                    error = new ClientError(response.statusText, path, response.status, debugOptions);\n                }\n            }\n            throw error;\n        }\n        if (options2.isJson) {\n            try {\n                returnValue = JSON.parse(returnValue);\n                logger.default(\"API RESPONSE JSON: %j\", {\n                    status: response.status,\n                    body: returnValue\n                });\n            } catch (e) {\n                logger.error(\"Error parsing JSON\", {\n                    message: e.message,\n                    stack: e.stack,\n                    returnValue\n                });\n                throw e;\n            }\n        } else {\n            logger.default(\"API RESPONSE TEXT: %j\", {\n                status: response.status,\n                body: returnValue\n            });\n        }\n        return returnValue;\n    };\n}\n// src/api/deleteMethod.ts\nvar logger2 = logger_default.get(\"api\", \"deleteMethod\");\nfunction deleteMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, body = {}, deleteOptions = {})=>{\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...deleteOptions\n        };\n        logger2.debug(\"httpDelete Request: %j, %j\", path, options2);\n        const s = await http(\"DELETE\", path, body, options2);\n        logger2.default(\"httpDelete Result: %j\", s);\n        return s;\n    };\n}\n// src/api/getMethod.ts\nvar logger3 = logger_default.get(\"api\", \"getMethod\");\nfunction getMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, getOptions = {})=>{\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...getOptions\n        };\n        logger3.debug(\"httpGet Request: %j, %j\", path, options2);\n        const s = await http(\"GET\", path, null, options2);\n        logger3.default(\"httpGet Result: %j\", s);\n        return s;\n    };\n}\n// src/api/postMethod.ts\nvar logger4 = logger_default.get(\"api\", \"postMethod\");\nfunction postMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, body = {}, getOptions = {})=>{\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...getOptions\n        };\n        logger4.debug(\"httpPost Request: %j, %j\", path, options2);\n        const s = await http(\"POST\", path, body, options2);\n        logger4.default(\"httpPost Result: %j\", s);\n        return s;\n    };\n}\n// src/api/putMethod.ts\nvar logger5 = logger_default.get(\"api\", \"putMethod\");\nfunction putMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, body = {}, getOptions = {})=>{\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...getOptions\n        };\n        logger5.debug(\"httpPut Request: %j, %j\", path, options2);\n        const s = await http(\"PUT\", path, body, options2);\n        logger5.default(\"httpPut Result: %j\", s);\n        return s;\n    };\n}\n// src/api/optionsMethod.ts\nvar logger6 = logger_default.get(\"api\", \"optionsMethod\");\nfunction optionsMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, options2 = {})=>{\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger6.debug(\"httpOptions Request: %j, %j\", path, opts);\n        const s = await http(\"OPTIONS\", path, null, opts);\n        logger6.default(\"httpOptions Result: %j\", s);\n        return s;\n    };\n}\n// src/api/connectMethod.ts\nvar logger7 = logger_default.get(\"api\", \"connectMethod\");\nfunction connectMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, options2 = {})=>{\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger7.debug(\"httpConnect Request: %j, %j\", path, opts);\n        const s = await http(\"CONNECT\", path, null, opts);\n        logger7.default(\"httpConnect Result: %j\", s);\n        return s;\n    };\n}\n// src/api/traceMethod.ts\nvar logger8 = logger_default.get(\"api\", \"traceMethod\");\nfunction traceMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, options2 = {})=>{\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger8.debug(\"httpTrace Request: %j, %j\", path, opts);\n        const s = await http(\"TRACE\", path, null, opts);\n        logger8.default(\"httpTrace Result: %j\", s);\n        return s;\n    };\n}\n// src/api/patchMethod.ts\nvar logger9 = logger_default.get(\"api\", \"patchMethod\");\nfunction patchMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, body = {}, options2 = {})=>{\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger9.debug(\"httpPatch Request: %j, %j\", path, opts);\n        const s = await http(\"PATCH\", path, body, opts);\n        logger9.default(\"httpPatch Result: %j\", s);\n        return s;\n    };\n}\n// src/api/httpFile.ts\nfunction getHttpFile(apiParams) {\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (method, path, file, httpFileOptions = {}, body = {}, headers = {})=>{\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...httpFileOptions\n        };\n        const config = apiParams.config;\n        const populateAuthHeader = apiParams.populateAuthHeader;\n        try {\n            headers[\"Accept\"] = options2.accept;\n            headers[\"X-Client-Name\"] = config.clientName;\n            await populateAuthHeader(options2.isAuthenticated, headers);\n            const bodyData = new FormData();\n            Object.keys(body).forEach((key)=>{\n                bodyData.set(key, body[key]);\n            });\n            bodyData.set(\"file\", new Blob([\n                new Uint8Array(file.buffer)\n            ]), file.bufferName);\n            const response = await fetch(`${config.url}${path}${generateQueryParameters(options2.params)}`, {\n                method,\n                headers,\n                body: bodyData,\n                credentials: options2.requestCredentials\n            });\n            const returnValue = options2.isJson ? await response.json() : await response.text();\n            if (response.status >= 400) {\n                console.error(`Error executing API request httpFile, status: ${response.status}: ` + JSON.stringify({\n                    method,\n                    path,\n                    params: options2.params,\n                    body,\n                    returnValue\n                }));\n                throw new Error(options2.isJson ? returnValue.message : returnValue);\n            }\n            return returnValue;\n        } catch (e) {\n            console.error(`Error executing API request http ${method} ${path} ${generateQueryParameters(options2.params)}`, e);\n            throw e;\n        }\n    };\n}\n// src/api/postFileMethod.ts\nvar logger10 = logger_default.get(\"api\", \"postFileMethod\");\nfunction postFileMethod(apiParams) {\n    const httpFile = getHttpFile(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async (path, body = {}, headers = {}, file, postFileOptions = {})=>{\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...postFileOptions\n        };\n        logger10.debug(\"httpPostFileData Request: %s, %j\", path, options2);\n        logger10.default(\"httpPostFileData Request Body: %j\", body);\n        const s = await httpFile(\"POST\", path, file, options2, body, headers);\n        logger10.default(\"httpPostFileData Result: %j\", s);\n        return s;\n    };\n}\n// src/api/uploadAsyncMethod.ts\nfunction uploadAsyncMethod(apiParams) {\n    const getOptionDefaults = ()=>({\n            method: \"POST\",\n            isJson: true,\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            fieldName: \"file\",\n            headers: {}\n        });\n    return async (path, uri, uploadAsyncOptions = {})=>{\n        const options2 = {\n            ...getOptionDefaults(),\n            ...uploadAsyncOptions\n        };\n        const config = apiParams.config;\n        const populateAuthHeader = apiParams.populateAuthHeader;\n        const uploadAsyncFile = apiParams.uploadAsyncFile;\n        try {\n            options2.headers[\"Accept\"] = options2.accept;\n            await populateAuthHeader(options2.isAuthenticated, options2.headers);\n            const result = await uploadAsyncFile(`${config.url}${path}${generateQueryParameters(options2.params)}`, uri, options2.method, \"multipart\", options2.fieldName, options2.headers);\n            const returnValue = options2.isJson ? JSON.parse(result.body) : result.body;\n            return returnValue;\n        } catch (e) {\n            console.error(`Error executing API request http ${options2.method} ${path} ${generateQueryParameters(options2.params)}`, e);\n            throw e;\n        }\n    };\n}\n// src/api.ts\nvar getHttpApi = (apiParams)=>{\n    const httpDelete = deleteMethod(apiParams);\n    const httpGet = getMethod(apiParams);\n    const httpPost = postMethod(apiParams);\n    const httpPut = putMethod(apiParams);\n    const httpOptions = optionsMethod(apiParams);\n    const httpConnect = connectMethod(apiParams);\n    const httpTrace = traceMethod(apiParams);\n    const httpPatch = patchMethod(apiParams);\n    const httpPostFile = postFileMethod(apiParams);\n    const uploadAsync = uploadAsyncMethod(apiParams);\n    return {\n        httpDelete,\n        httpGet,\n        httpPut,\n        httpPost,\n        httpPostFile,\n        uploadAsync,\n        httpOptions,\n        httpConnect,\n        httpTrace,\n        httpPatch\n    };\n};\n// src/simple-api.ts\nvar defaultApiParams = {\n    config: {\n        url: \"\",\n        requestCredentials: \"same-origin\",\n        clientName: \"fjell-http-api-examples\"\n    },\n    populateAuthHeader: async (isAuthenticated, headers)=>{\n        if (isAuthenticated) {\n            headers[\"Authorization\"] = \"Bearer example-token\";\n        }\n    },\n    uploadAsyncFile: async ()=>{\n        return {\n            headers: {},\n            status: 200,\n            mimeType: \"application/json\",\n            body: JSON.stringify({\n                success: true\n            })\n        };\n    }\n};\nvar getImpl = getMethod(defaultApiParams);\nvar postImpl = postMethod(defaultApiParams);\nvar putImpl = putMethod(defaultApiParams);\nvar optionsImpl = optionsMethod(defaultApiParams);\nvar connectImpl = connectMethod(defaultApiParams);\nvar traceImpl = traceMethod(defaultApiParams);\nvar patchImpl = patchMethod(defaultApiParams);\nvar deleteImpl = deleteMethod(defaultApiParams);\nvar postFileImpl = postFileMethod(defaultApiParams);\nvar uploadAsyncImpl = uploadAsyncMethod(defaultApiParams);\nvar get = (path, options2)=>{\n    return getImpl(path, options2);\n};\nvar post = (path, body, options2)=>{\n    return postImpl(path, body, options2);\n};\nvar put = (path, body, options2)=>{\n    return putImpl(path, body, options2);\n};\nvar deleteMethod2 = (path, body, options2)=>{\n    return deleteImpl(path, body, options2);\n};\nvar options = (path, opts)=>{\n    return optionsImpl(path, opts);\n};\nvar connect = (path, opts)=>{\n    return connectImpl(path, opts);\n};\nvar trace = (path, opts)=>{\n    return traceImpl(path, opts);\n};\nvar patch = (path, body, opts)=>{\n    return patchImpl(path, body, opts);\n};\nvar postFileMethod2 = (path, file, options2)=>{\n    const fileBuffer = {\n        buffer: Buffer.from([]),\n        // Placeholder - would need proper File reading in browser\n        bufferName: file.name\n    };\n    return postFileImpl(path, {}, {}, fileBuffer, options2);\n};\nvar uploadAsyncMethod2 = (path, uri, options2)=>{\n    return uploadAsyncImpl(path, uri, options2);\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRU8sSUFBTSxNQUFNLENBQUksTUFBYyxNQUFZQTtJQUMvQyxPQUFPLFFBQVEsTUFBTSxNQUFNQSxRQUFPO0FBQ3BDO0FBRU8sSUFBTUcsZ0JBQWUsQ0FBSSxNQUFjLE1BQVlIO0lBQ3hELE9BQU8sV0FBVyxNQUFNLE1BQU1BLFFBQU87QUFDdkM7QUFFTyxJQUFNLFVBQVUsQ0FBSSxNQUFjO0lBQ3ZDLE9BQU8sWUFBWSxNQUFNLElBQUk7QUFDL0I7QUFFTyxJQUFNLFVBQVUsQ0FBSSxNQUFjO0lBQ3ZDLE9BQU8sWUFBWSxNQUFNLElBQUk7QUFDL0I7QUFFTyxJQUFNLFFBQVEsQ0FBSSxNQUFjO0lBQ3JDLE9BQU8sVUFBVSxNQUFNLElBQUk7QUFDN0I7QUFFTyxJQUFNLFFBQVEsQ0FBSSxNQUFjLE1BQVk7SUFDakQsT0FBTyxVQUFVLE1BQU0sTUFBTSxJQUFJO0FBQ25DO0FBRU8sSUFBTUksa0JBQWlCLENBQUksTUFBYyxNQUFZSjtJQUcxRCxNQUFNLGFBQWE7UUFDakIsUUFBUSxPQUFPLEtBQUssQ0FBQyxDQUFDO1FBQUE7UUFDdEIsWUFBWSxLQUFLO0lBQ25CO0lBR0EsT0FBTyxhQUFhLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxZQUFZQSxRQUFPO0FBQ3ZEO0FBRU8sSUFBTUsscUJBQW9CLENBQUksTUFBYyxLQUFhTDtJQUM5RCxPQUFPLGdCQUFnQixNQUFNLEtBQUtBLFFBQU87QUFDM0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2Vycm9ycy50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2FwaS91dGlsLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvbG9nZ2VyLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL2h0dHAudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvZGVsZXRlTWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL2dldE1ldGhvZC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2FwaS9wb3N0TWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL3B1dE1ldGhvZC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2FwaS9vcHRpb25zTWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL2Nvbm5lY3RNZXRob2QudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvdHJhY2VNZXRob2QudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvcGF0Y2hNZXRob2QudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvaHR0cEZpbGUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvcG9zdEZpbGVNZXRob2QudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvdXBsb2FkQXN5bmNNZXRob2QudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9zaW1wbGUtYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBBUElFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHJpdmF0ZSBodHRwUmVzcG9uc2VDb2RlOiBudW1iZXI7XG4gIHByaXZhdGUgcGF0aDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBodHRwUmVzcG9uc2VDb2RlOiBudW1iZXIsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5odHRwUmVzcG9uc2VDb2RlID0gaHR0cFJlc3BvbnNlQ29kZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQVBJRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2xpZW50RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBodHRwUmVzcG9uc2VDb2RlOiBudW1iZXIsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAwLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVW5hdXRob3JpemVkRXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAxLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRm9yYmlkZGVuRXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAzLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNZXRob2ROb3RBbGxvd2VkRXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA1LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVxdWVzdFRpbWVvdXRFcnJvciBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDgsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb25mbGljdEVycm9yIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwOSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdvbmVFcnJvciBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MTAsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUb29NYW55UmVxdWVzdHNFcnJvciBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MjksIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGh0dHBSZXNwb25zZUNvZGU6IG51bWJlciwgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgaHR0cFJlc3BvbnNlQ29kZSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludGVybmFsU2VydmVyRXJyb3IgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCA1MDAsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb3RJbXBsZW1lbnRlZEVycm9yIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAxLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCA1MDMsIG9wdGlvbnMpO1xuICB9XG59XG4iLCJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuY29uc3QgZ2V0UGFyYW1ldGVyVmFsdWUgPSAoXG4gIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZCxcbik6IHN0cmluZyA9PiB7XG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyB2YWx1ZS50b0lTT1N0cmluZygpIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzID0gKHBhcmFtczoge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZDtcbn0pID0+XG4gIE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMFxuICAgID8gXCI/XCIgK1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgIC5maWx0ZXIoKGtleSkgPT5cbiAgICAgICAgKHBhcmFtc1trZXldICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICh0eXBlb2YgcGFyYW1zW2tleV0gPT09ICdzdHJpbmcnICYmIChwYXJhbXNba2V5XSBhcyBzdHJpbmcpLmxlbmd0aCA9PT0gMCkgPT09IGZhbHNlXG4gICAgICApXG4gICAgICAubWFwKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlOiBhbnk7XG4gICAgICAgIGlmIChwYXJhbXNba2V5XSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YWx1ZSA9ICdmYWxzZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7a2V5fT0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbWV0ZXJWYWx1ZSh2YWx1ZSkpfWBcbiAgICAgIH0pXG4gICAgICAuam9pbihcIiZcIilcbiAgICA6IFwiXCI7XG4iLCJpbXBvcnQgTG9nZ2luZyBmcm9tICdAZmplbGwvbG9nZ2luZyc7XG5cbmNvbnN0IExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKCdAZmplbGwvaHR0cC1hcGknKTtcblxuZXhwb3J0IGRlZmF1bHQgTGliTG9nZ2VyO1xuIiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHtcbiAgQmFkUmVxdWVzdEVycm9yLFxuICBDbGllbnRFcnJvcixcbiAgQ29uZmxpY3RFcnJvcixcbiAgRm9yYmlkZGVuRXJyb3IsXG4gIEdvbmVFcnJvcixcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgTWV0aG9kTm90QWxsb3dlZEVycm9yLFxuICBOb3RGb3VuZEVycm9yLFxuICBOb3RJbXBsZW1lbnRlZEVycm9yLFxuICBSZXF1ZXN0VGltZW91dEVycm9yLFxuICBTZXJ2ZXJFcnJvcixcbiAgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IsXG4gIFRvb01hbnlSZXF1ZXN0c0Vycm9yLFxuICBVbmF1dGhvcml6ZWRFcnJvclxufSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWxcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJodHRwXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEh0dHBNZXRob2RPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBpc0pzb25Cb2R5OiBib29sZWFuO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgc2tpcENvbnRlbnRUeXBlOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIGdldEh0dHAoYXBpUGFyYW1zOiBBcGlQYXJhbXMpIHtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKGFwaVBhcmFtczogQXBpUGFyYW1zKTogSHR0cE1ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGh0dHBPcHRpb25zOiBQYXJ0aWFsPEh0dHBNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2h0dHAnLCB7IG1ldGhvZCwgcGF0aCwgYm9keSwgaHR0cE9wdGlvbnMgfSk7XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmh0dHBPcHRpb25zLFxuICAgIH07XG5cbiAgICBjb25zdCBjb25maWcgPSBhcGlQYXJhbXMuY29uZmlnO1xuICAgIGNvbnN0IHBvcHVsYXRlQXV0aEhlYWRlciA9IGFwaVBhcmFtcy5wb3B1bGF0ZUF1dGhIZWFkZXI7XG4gICAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgIGlmICghb3B0aW9ucy5za2lwQ29udGVudFR5cGUpIHtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gb3B0aW9ucy5hY2NlcHQ7XG4gICAgaGVhZGVyc1tcIlgtQ2xpZW50LU5hbWVcIl0gPSBjb25maWcuY2xpZW50TmFtZTtcblxuICAgIGNvbnN0IGRlYnVnT3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBtZXRob2QsXG4gICAgICBwYXRoLFxuICAgICAgYm9keSxcbiAgICB9O1xuICAgIC8vIGNvbnNvbGUuZGVidWcoXCJBUEkgUkVRVUVTVDogXCIgKyBKU09OLnN0cmluZ2lmeShkZWJ1Z09wdGlvbnMsIG51bGwsIDIpKTtcblxuICAgIGF3YWl0IHBvcHVsYXRlQXV0aEhlYWRlcihvcHRpb25zLmlzQXV0aGVudGljYXRlZCwgaGVhZGVycyk7XG5cbiAgICBsb2dnZXIuZGVidWcoXCJodHRwIFJlcXVlc3Q6ICVqLCAlalwiLCBtZXRob2QsIHBhdGgpO1xuXG4gICAgY29uc3QgZmV0Y2hPcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBjcmVkZW50aWFsczogb3B0aW9ucy5yZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgfTtcblxuICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBib2R5ID8gKG9wdGlvbnMuaXNKc29uQm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogYm9keSkgOiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMucGFyYW1zKX1gLFxuICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICk7XG5cbiAgICAvLyBIYW5kbGUgdGhlIEVycm9ycyAtIGFueXRoaW5nIGFib3ZlIDQwMFxuICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICByZXR1cm5WYWx1ZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcblxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICBsZXQgZXJyb3I7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDEpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDMpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBTZXJ2aWNlVW5hdmFpbGFibGVFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IFNlcnZlckVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIHJlc3BvbnNlLnN0YXR1cywgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgQmFkUmVxdWVzdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBVbmF1dGhvcml6ZWRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRm9yYmlkZGVuRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IE5vdEZvdW5kRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IE1ldGhvZE5vdEFsbG93ZWRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA4KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgUmVxdWVzdFRpbWVvdXRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgQ29uZmxpY3RFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDEwKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgR29uZUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBUb29NYW55UmVxdWVzdHNFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IENsaWVudEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIHJlc3BvbnNlLnN0YXR1cywgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmRlYnVnKGBBUEkgRVJST1I6IEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdDpgICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlzSnNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBKU09OLnBhcnNlKHJldHVyblZhbHVlKTtcbiAgICAgICAgbG9nZ2VyLmRlZmF1bHQoXCJBUEkgUkVTUE9OU0UgSlNPTjogJWpcIiwgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgYm9keTogcmV0dXJuVmFsdWUgfSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBwYXJzaW5nIEpTT04nLCB7IG1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2ssIHJldHVyblZhbHVlIH0pO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVmYXVsdChcIkFQSSBSRVNQT05TRSBURVhUOiAlalwiLCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBib2R5OiByZXR1cm5WYWx1ZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWUgYXMgdW5rbm93biBhcyBTO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIGdldEh0dHAsXG59IiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cCB9IGZyb20gXCIuL2h0dHBcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJkZWxldGVNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVsZXRlTWV0aG9kT3B0aW9ucyB7XG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgaXNKc29uQm9keTogYm9vbGVhbjtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkXG4gIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgc2tpcENvbnRlbnRUeXBlOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIGRlbGV0ZU1ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuXG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IERlbGV0ZU1ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGRlbGV0ZU9wdGlvbnM6IFBhcnRpYWw8RGVsZXRlTWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5kZWxldGVPcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cERlbGV0ZSBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgY29uc3QgczogUyA9IGF3YWl0IGh0dHA8Uz4oXG4gICAgICBcIkRFTEVURVwiLFxuICAgICAgcGF0aCxcbiAgICAgIGJvZHksXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoXCJodHRwRGVsZXRlIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmV4cG9ydCB7IGRlbGV0ZU1ldGhvZCB9XG4iLCJpbXBvcnQgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBnZXRIdHRwIH0gZnJvbSBcIi4vaHR0cFwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcImFwaVwiLCBcImdldE1ldGhvZFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBHZXRNZXRob2RPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBpc0pzb25Cb2R5OiBib29sZWFuO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWRcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBza2lwQ29udGVudFR5cGU6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gZ2V0TWV0aG9kKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG5cbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKGFwaVBhcmFtczogQXBpUGFyYW1zKTogR2V0TWV0aG9kT3B0aW9ucyA9PiAoe1xuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgfSk7XG5cbiAgcmV0dXJuIGFzeW5jIDxTPihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZ2V0T3B0aW9uczogUGFydGlhbDxHZXRNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmdldE9wdGlvbnMsXG4gICAgfTtcbiAgICBsb2dnZXIuZGVidWcoXCJodHRwR2V0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBzOiBTID0gYXdhaXQgaHR0cDxTPihcIkdFVFwiLCBwYXRoLCBudWxsLCBvcHRpb25zKTtcbiAgICBsb2dnZXIuZGVmYXVsdChcImh0dHBHZXQgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5leHBvcnQgeyBnZXRNZXRob2QgfTsiLCJpbXBvcnQgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBnZXRIdHRwIH0gZnJvbSBcIi4vaHR0cFwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcImFwaVwiLCBcInBvc3RNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zdE1ldGhvZE9wdGlvbnMge1xuICBpc0pzb246IGJvb2xlYW47XG4gIGlzSnNvbkJvZHk6IGJvb2xlYW47XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGFjY2VwdDogc3RyaW5nO1xuICBwYXJhbXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZFxuICB9O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIHNraXBDb250ZW50VHlwZTogYm9vbGVhbjtcbiAgcmVxdWVzdENyZWRlbnRpYWxzOiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG59O1xuXG5mdW5jdGlvbiBwb3N0TWV0aG9kKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG5cbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKGFwaVBhcmFtczogQXBpUGFyYW1zKTogUG9zdE1ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGdldE9wdGlvbnM6IFBhcnRpYWw8UG9zdE1ldGhvZE9wdGlvbnM+ID0ge30sXG4gICk6IFByb21pc2U8Uz4gPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uZ2V0T3B0aW9ucyxcbiAgICB9O1xuICAgIGxvZ2dlci5kZWJ1ZyhcImh0dHBQb3N0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBzOiBTID0gYXdhaXQgaHR0cDxTPihcIlBPU1RcIiwgcGF0aCwgYm9keSwgb3B0aW9ucyk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoXCJodHRwUG9zdCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5leHBvcnQgeyBwb3N0TWV0aG9kIH07XG4iLCJpbXBvcnQgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBnZXRIdHRwIH0gZnJvbSBcIi4vaHR0cFwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcImFwaVwiLCBcInB1dE1ldGhvZFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBQdXRNZXRob2RPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBpc0pzb25Cb2R5OiBib29sZWFuO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWRcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBza2lwQ29udGVudFR5cGU6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gcHV0TWV0aG9kKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG5cbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKGFwaVBhcmFtczogQXBpUGFyYW1zKTogUHV0TWV0aG9kT3B0aW9ucyA9PiAoe1xuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgfSk7XG5cbiAgcmV0dXJuIGFzeW5jIDxTPihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgYm9keTogYW55ID0ge30sXG4gICAgZ2V0T3B0aW9uczogUGFydGlhbDxQdXRNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmdldE9wdGlvbnMsXG4gICAgfTtcbiAgICBsb2dnZXIuZGVidWcoXCJodHRwUHV0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBzOiBTID0gYXdhaXQgaHR0cDxTPihcIlBVVFwiLCBwYXRoLCBib2R5LCBvcHRpb25zKTtcbiAgICBsb2dnZXIuZGVmYXVsdChcImh0dHBQdXQgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZXhwb3J0IHsgcHV0TWV0aG9kIH07XG4iLCJpbXBvcnQgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBnZXRIdHRwIH0gZnJvbSBcIi4vaHR0cFwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcImFwaVwiLCBcIm9wdGlvbnNNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc01ldGhvZE9wdGlvbnMge1xuICBpc0pzb246IGJvb2xlYW47XG4gIGlzSnNvbkJvZHk6IGJvb2xlYW47XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGFjY2VwdDogc3RyaW5nO1xuICBwYXJhbXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBza2lwQ29udGVudFR5cGU6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gb3B0aW9uc01ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID1cbiAgICAoYXBpUGFyYW1zOiBBcGlQYXJhbXMpOiBPcHRpb25zTWV0aG9kT3B0aW9ucyA9PiAoe1xuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgfSk7XG5cbiAgcmV0dXJuIGFzeW5jIDxTPihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9uczogUGFydGlhbDxPcHRpb25zTWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cE9wdGlvbnMgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHM6IFMgPSBhd2FpdCBodHRwPFM+KFwiT1BUSU9OU1wiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXIuZGVmYXVsdChcImh0dHBPcHRpb25zIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmV4cG9ydCB7IG9wdGlvbnNNZXRob2QgfTtcbiIsImltcG9ydCB7IEFwaVBhcmFtcyB9IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IGdldEh0dHAgfSBmcm9tIFwiLi9odHRwXCI7XG5cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiYXBpXCIsIFwiY29ubmVjdE1ldGhvZFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0TWV0aG9kT3B0aW9ucyB7XG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgaXNKc29uQm9keTogYm9vbGVhbjtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkO1xuICB9O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIHNraXBDb250ZW50VHlwZTogYm9vbGVhbjtcbiAgcmVxdWVzdENyZWRlbnRpYWxzOiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG59O1xuXG5mdW5jdGlvbiBjb25uZWN0TWV0aG9kKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IENvbm5lY3RNZXRob2RPcHRpb25zID0+ICh7XG4gICAgICBpc0pzb246IHRydWUsXG4gICAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zOiBQYXJ0aWFsPENvbm5lY3RNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBsb2dnZXIuZGVidWcoXCJodHRwQ29ubmVjdCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgczogUyA9IGF3YWl0IGh0dHA8Uz4oXCJDT05ORUNUXCIsIHBhdGgsIG51bGwsIG9wdHMpO1xuICAgIGxvZ2dlci5kZWZhdWx0KFwiaHR0cENvbm5lY3QgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZXhwb3J0IHsgY29ubmVjdE1ldGhvZCB9O1xuIiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cCB9IGZyb20gXCIuL2h0dHBcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJ0cmFjZU1ldGhvZFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFjZU1ldGhvZE9wdGlvbnMge1xuICBpc0pzb246IGJvb2xlYW47XG4gIGlzSnNvbkJvZHk6IGJvb2xlYW47XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGFjY2VwdDogc3RyaW5nO1xuICBwYXJhbXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBza2lwQ29udGVudFR5cGU6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gdHJhY2VNZXRob2QoYXBpUGFyYW1zOiBBcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKGFwaVBhcmFtczogQXBpUGFyYW1zKTogVHJhY2VNZXRob2RPcHRpb25zID0+ICh7XG4gICAgICBpc0pzb246IHRydWUsXG4gICAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zOiBQYXJ0aWFsPFRyYWNlTWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cFRyYWNlIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRzKTtcbiAgICBjb25zdCBzOiBTID0gYXdhaXQgaHR0cDxTPihcIlRSQUNFXCIsIHBhdGgsIG51bGwsIG9wdHMpO1xuICAgIGxvZ2dlci5kZWZhdWx0KFwiaHR0cFRyYWNlIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmV4cG9ydCB7IHRyYWNlTWV0aG9kIH07XG4iLCJpbXBvcnQgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBnZXRIdHRwIH0gZnJvbSBcIi4vaHR0cFwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcImFwaVwiLCBcInBhdGNoTWV0aG9kXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGNoTWV0aG9kT3B0aW9ucyB7XG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgaXNKc29uQm9keTogYm9vbGVhbjtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkO1xuICB9O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIHNraXBDb250ZW50VHlwZTogYm9vbGVhbjtcbiAgcmVxdWVzdENyZWRlbnRpYWxzOiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG59O1xuXG5mdW5jdGlvbiBwYXRjaE1ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID1cbiAgICAoYXBpUGFyYW1zOiBBcGlQYXJhbXMpOiBQYXRjaE1ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIG9wdGlvbnM6IFBhcnRpYWw8UGF0Y2hNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBsb2dnZXIuZGVidWcoXCJodHRwUGF0Y2ggUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHM6IFMgPSBhd2FpdCBodHRwPFM+KFwiUEFUQ0hcIiwgcGF0aCwgYm9keSwgb3B0cyk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoXCJodHRwUGF0Y2ggUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZXhwb3J0IHsgcGF0Y2hNZXRob2QgfTtcbiIsIlxuaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSHR0cEZpbGVPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWRcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIGdldEh0dHBGaWxlKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IEh0dHBGaWxlT3B0aW9ucyA9PiAoe1xuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZpbGU6IHsgYnVmZmVyOiBCdWZmZXI7IGJ1ZmZlck5hbWU6IHN0cmluZyB9LFxuICAgIGh0dHBGaWxlT3B0aW9uczogUGFydGlhbDxIdHRwRmlsZU9wdGlvbnM+ID0ge30sXG4gICAgYm9keTogYW55ID0ge30sXG4gICAgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmh0dHBGaWxlT3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IGFwaVBhcmFtcy5jb25maWc7XG4gICAgY29uc3QgcG9wdWxhdGVBdXRoSGVhZGVyID0gYXBpUGFyYW1zLnBvcHVsYXRlQXV0aEhlYWRlclxuICAgIHRyeSB7XG4gICAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gb3B0aW9ucy5hY2NlcHQ7XG4gICAgICAvLyBjb25zb2xlLmRlYnVnKFwiaHR0cEZpbGU6IFwiICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xuICAgICAgaGVhZGVyc1tcIlgtQ2xpZW50LU5hbWVcIl0gPSBjb25maWcuY2xpZW50TmFtZTtcblxuICAgICAgYXdhaXQgcG9wdWxhdGVBdXRoSGVhZGVyKG9wdGlvbnMuaXNBdXRoZW50aWNhdGVkLCBoZWFkZXJzKTtcblxuICAgICAgY29uc3QgYm9keURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIE9iamVjdC5rZXlzKGJvZHkpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgYm9keURhdGEuc2V0KGtleSwgYm9keVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgYm9keURhdGEuc2V0KCdmaWxlJywgbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KGZpbGUuYnVmZmVyKV0pLCBmaWxlLmJ1ZmZlck5hbWUpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMucGFyYW1zKX1gLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keTogYm9keURhdGEsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcHRpb25zLmlzSnNvbiA/IGF3YWl0IHJlc3BvbnNlLmpzb24oKSA6IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdCBodHRwRmlsZSwgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c306IGAgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgbWV0aG9kLCBwYXRoLCBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLCBib2R5LCByZXR1cm5WYWx1ZSB9KSxcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMuaXNKc29uID8gcmV0dXJuVmFsdWUubWVzc2FnZSA6IHJldHVyblZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZSBhcyB1bmtub3duIGFzIFM7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIEFQSSByZXF1ZXN0IGh0dHAgJHttZXRob2R9ICR7cGF0aH0gJHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhcbiAgICAgICAgICBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgKX1gLFxuICAgICAgICBlLFxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBnZXRIdHRwRmlsZSB9O1xuIiwiIFxuaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cEZpbGUgfSBmcm9tIFwiLi9odHRwRmlsZVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJwb3N0RmlsZU1ldGhvZFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBQb3N0RmlsZU1ldGhvZE9wdGlvbnMge1xuICBpc0pzb246IGJvb2xlYW47XG4gIGFjY2VwdDogc3RyaW5nO1xuICBwYXJhbXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZFxuICB9O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gcG9zdEZpbGVNZXRob2QoYXBpUGFyYW1zOiBBcGlQYXJhbXMpIHtcblxuICBjb25zdCBodHRwRmlsZSA9IGdldEh0dHBGaWxlKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IFBvc3RGaWxlTWV0aG9kT3B0aW9ucyA9PiAoe1xuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGhlYWRlcnM6IGFueSA9IHt9LFxuICAgIGZpbGU6IHsgYnVmZmVyOiBCdWZmZXI7IGJ1ZmZlck5hbWU6IHN0cmluZyB9LFxuICAgIHBvc3RGaWxlT3B0aW9uczogUGFydGlhbDxQb3N0RmlsZU1ldGhvZE9wdGlvbnM+ID0ge30sXG4gICk6IFByb21pc2U8Uz4gPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ucG9zdEZpbGVPcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cFBvc3RGaWxlRGF0YSBSZXF1ZXN0OiAlcywgJWpcIiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoXCJodHRwUG9zdEZpbGVEYXRhIFJlcXVlc3QgQm9keTogJWpcIiwgYm9keSk7XG4gICAgY29uc3QgczogUyA9IGF3YWl0IGh0dHBGaWxlPFM+KFxuICAgICAgXCJQT1NUXCIsXG4gICAgICBwYXRoLFxuICAgICAgZmlsZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBib2R5LFxuICAgICAgaGVhZGVycyxcbiAgICApO1xuICAgIGxvZ2dlci5kZWZhdWx0KFwiaHR0cFBvc3RGaWxlRGF0YSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5leHBvcnQgeyBwb3N0RmlsZU1ldGhvZCB9XG4iLCJpbXBvcnQgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRBc3luY01ldGhvZE9wdGlvbnMge1xuICBtZXRob2Q6IHN0cmluZyxcbiAgaXNKc29uOiBib29sZWFuO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgZmllbGROYW1lOiBzdHJpbmc7XG4gIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59O1xuXG5mdW5jdGlvbiB1cGxvYWRBc3luY01ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuXG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID1cbiAgICAoKTogVXBsb2FkQXN5bmNNZXRob2RPcHRpb25zID0+ICh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBmaWVsZE5hbWU6IFwiZmlsZVwiLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgfSk7XG5cbiAgcmV0dXJuIGFzeW5jPFM+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICB1cmk6IHN0cmluZyxcbiAgICB1cGxvYWRBc3luY09wdGlvbnM6IFBhcnRpYWw8VXBsb2FkQXN5bmNNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoKSxcbiAgICAgIC4uLnVwbG9hZEFzeW5jT3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IGFwaVBhcmFtcy5jb25maWc7XG4gICAgY29uc3QgcG9wdWxhdGVBdXRoSGVhZGVyID0gYXBpUGFyYW1zLnBvcHVsYXRlQXV0aEhlYWRlcjtcbiAgICBjb25zdCB1cGxvYWRBc3luY0ZpbGUgPSBhcGlQYXJhbXMudXBsb2FkQXN5bmNGaWxlO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnNbXCJBY2NlcHRcIl0gPSBvcHRpb25zLmFjY2VwdDtcblxuICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcInVwbG9hZEFzeW5jOiBcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcblxuICAgICAgYXdhaXQgcG9wdWxhdGVBdXRoSGVhZGVyKG9wdGlvbnMuaXNBdXRoZW50aWNhdGVkLCBvcHRpb25zLmhlYWRlcnMpO1xuXG4gICAgICBjb25zdCByZXN1bHQ6IHtcbiAgICAgICAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICAgICAgc3RhdHVzOiBudW1iZXI7XG4gICAgICAgIG1pbWVUeXBlOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBib2R5OiBzdHJpbmc7XG4gICAgICB9ID0gYXdhaXQgdXBsb2FkQXN5bmNGaWxlKGAke2NvbmZpZy51cmx9JHtwYXRofSR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMob3B0aW9ucy5wYXJhbXMpfWAsXG4gICAgICAgIHVyaSwgb3B0aW9ucy5tZXRob2QsIFwibXVsdGlwYXJ0XCIsIG9wdGlvbnMuZmllbGROYW1lLCBvcHRpb25zLmhlYWRlcnMpO1xuXG4gICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9wdGlvbnMuaXNKc29uID8gSlNPTi5wYXJzZShyZXN1bHQuYm9keSkgOiByZXN1bHQuYm9keTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZSBhcyB1bmtub3duIGFzIFM7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIEFQSSByZXF1ZXN0IGh0dHAgJHtvcHRpb25zLm1ldGhvZH0gJHtwYXRofSAke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKFxuICAgICAgICAgIG9wdGlvbnMucGFyYW1zLFxuICAgICAgICApfWAsXG4gICAgICAgIGUsXG4gICAgICApO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHVwbG9hZEFzeW5jTWV0aG9kIH1cbiIsImltcG9ydCB7IGRlbGV0ZU1ldGhvZCwgRGVsZXRlTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9kZWxldGVNZXRob2RcIjtcbmltcG9ydCB7IGdldE1ldGhvZCwgR2V0TWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9nZXRNZXRob2RcIjtcbmltcG9ydCB7IHBvc3RNZXRob2QsIFBvc3RNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3Bvc3RNZXRob2RcIjtcbmltcG9ydCB7IHB1dE1ldGhvZCwgUHV0TWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9wdXRNZXRob2RcIjtcbmltcG9ydCB7IG9wdGlvbnNNZXRob2QsIE9wdGlvbnNNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL29wdGlvbnNNZXRob2RcIjtcbmltcG9ydCB7IGNvbm5lY3RNZXRob2QsIENvbm5lY3RNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL2Nvbm5lY3RNZXRob2RcIjtcbmltcG9ydCB7IHRyYWNlTWV0aG9kLCBUcmFjZU1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvdHJhY2VNZXRob2RcIjtcbmltcG9ydCB7IHBhdGNoTWV0aG9kLCBQYXRjaE1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvcGF0Y2hNZXRob2RcIjtcbmltcG9ydCB7IHBvc3RGaWxlTWV0aG9kLCBQb3N0RmlsZU1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvcG9zdEZpbGVNZXRob2RcIjtcbmltcG9ydCB7IHVwbG9hZEFzeW5jTWV0aG9kLCBVcGxvYWRBc3luY01ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvdXBsb2FkQXN5bmNNZXRob2RcIjtcblxuLy8gRXhwb3J0IG9wdGlvbiB0eXBlcyBmb3IgZXh0ZXJuYWwgdXNlXG5leHBvcnQgdHlwZSB7XG4gIERlbGV0ZU1ldGhvZE9wdGlvbnMsXG4gIEdldE1ldGhvZE9wdGlvbnMsXG4gIFBvc3RNZXRob2RPcHRpb25zLFxuICBQdXRNZXRob2RPcHRpb25zLFxuICBPcHRpb25zTWV0aG9kT3B0aW9ucyxcbiAgQ29ubmVjdE1ldGhvZE9wdGlvbnMsXG4gIFRyYWNlTWV0aG9kT3B0aW9ucyxcbiAgUGF0Y2hNZXRob2RPcHRpb25zLFxufTtcblxuZXhwb3J0IHR5cGUgSHR0cERlbGV0ZSA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICBib2R5PzogYW55LFxuICBvcHRpb25zPzogUGFydGlhbDxEZWxldGVNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgSHR0cFB1dCA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICBib2R5PzogYW55LFxuICBvcHRpb25zPzogUGFydGlhbDxQdXRNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgSHR0cFBvc3QgPSA8Uz4oXG4gIHBhdGg6IHN0cmluZyxcbiAgYm9keT86IGFueSxcbiAgb3B0aW9ucz86IFBhcnRpYWw8UG9zdE1ldGhvZE9wdGlvbnM+LFxuKSA9PiBQcm9taXNlPFM+O1xuXG5leHBvcnQgdHlwZSBIdHRwUG9zdEZpbGUgPSA8Uz4oXG4gIHBhdGg6IHN0cmluZyxcbiAgYm9keTogYW55LFxuICBoZWFkZXJzOiBhbnksXG4gIGZpbGU6IHsgYnVmZmVyOiBCdWZmZXI7IGJ1ZmZlck5hbWU6IHN0cmluZyB9LFxuICBvcHRpb25zPzogUGFydGlhbDxQb3N0RmlsZU1ldGhvZE9wdGlvbnM+LFxuKSA9PiBQcm9taXNlPFM+O1xuXG5leHBvcnQgdHlwZSBIdHRwR2V0ID0gPFM+KFxuICBwYXRoOiBzdHJpbmcsXG4gIGdldE9wdGlvbnM/OiBQYXJ0aWFsPEdldE1ldGhvZE9wdGlvbnM+LFxuKSA9PiBQcm9taXNlPFM+O1xuXG5leHBvcnQgdHlwZSBIdHRwT3B0aW9uc01ldGhvZCA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRpb25zPzogUGFydGlhbDxPcHRpb25zTWV0aG9kT3B0aW9ucz4sXG4pID0+IFByb21pc2U8Uz47XG5cbmV4cG9ydCB0eXBlIEh0dHBDb25uZWN0ID0gPFM+KFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQYXJ0aWFsPENvbm5lY3RNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgSHR0cFRyYWNlID0gPFM+KFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQYXJ0aWFsPFRyYWNlTWV0aG9kT3B0aW9ucz4sXG4pID0+IFByb21pc2U8Uz47XG5cbmV4cG9ydCB0eXBlIEh0dHBQYXRjaCA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICBib2R5PzogYW55LFxuICBvcHRpb25zPzogUGFydGlhbDxQYXRjaE1ldGhvZE9wdGlvbnM+LFxuKSA9PiBQcm9taXNlPFM+O1xuXG5leHBvcnQgdHlwZSBVcGxvYWRBc3luYyA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICB1cmk6IHN0cmluZyxcbiAgb3B0aW9ucz86IFBhcnRpYWw8VXBsb2FkQXN5bmNNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgSHR0cEFwaSA9IHtcbiAgaHR0cERlbGV0ZTogSHR0cERlbGV0ZTtcbiAgaHR0cEdldDogSHR0cEdldDtcbiAgaHR0cFB1dDogSHR0cFB1dCxcbiAgaHR0cFBvc3Q6IEh0dHBQb3N0LFxuICBodHRwUG9zdEZpbGU6IEh0dHBQb3N0RmlsZSxcbiAgdXBsb2FkQXN5bmM6IFVwbG9hZEFzeW5jLFxuICBodHRwT3B0aW9uczogSHR0cE9wdGlvbnNNZXRob2QsXG4gIGh0dHBDb25uZWN0OiBIdHRwQ29ubmVjdCxcbiAgaHR0cFRyYWNlOiBIdHRwVHJhY2UsXG4gIGh0dHBQYXRjaDogSHR0cFBhdGNoLFxufVxuXG5leHBvcnQgdHlwZSBBcGlDb25maWcgPSB7XG4gIHVybDogc3RyaW5nLFxuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscyxcbiAgY2xpZW50TmFtZTogc3RyaW5nLFxufVxuXG5leHBvcnQgdHlwZSBBcGlQb3B1bGF0ZUF1dGhIZWFkZXIgPVxuICAoaXNBdXRoZW50aWNhdGVkOiBib29sZWFuLCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuZXhwb3J0IHR5cGUgQXBpVXBsb2FkQXN5bmNGaWxlID1cbiAgKGRlc3RVcmw6IHN0cmluZywgZmlsZVVyaTogc3RyaW5nLCBtZXRob2Q6IHN0cmluZyxcbiAgICB1cGxvYWRUeXBlOiBzdHJpbmcsIGZpZWxkTmFtZTogc3RyaW5nLCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiBQcm9taXNlPHtcbiAgICAgIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICBzdGF0dXM6IG51bWJlcjtcbiAgICAgIG1pbWVUeXBlOiBzdHJpbmcgfCBudWxsO1xuICAgICAgYm9keTogc3RyaW5nO1xuICAgIH0+O1xuXG5leHBvcnQgdHlwZSBBcGlQYXJhbXMgPSB7XG4gIGNvbmZpZzogQXBpQ29uZmlnLFxuICBwb3B1bGF0ZUF1dGhIZWFkZXI6IEFwaVBvcHVsYXRlQXV0aEhlYWRlcixcbiAgdXBsb2FkQXN5bmNGaWxlOiBBcGlVcGxvYWRBc3luY0ZpbGUsXG59XG5cbmV4cG9ydCBjb25zdCBnZXRIdHRwQXBpID0gKGFwaVBhcmFtczogQXBpUGFyYW1zKTogSHR0cEFwaSA9PiB7XG5cbiAgY29uc3QgaHR0cERlbGV0ZTogSHR0cERlbGV0ZSA9IGRlbGV0ZU1ldGhvZChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGh0dHBHZXQ6IEh0dHBHZXQgPSBnZXRNZXRob2QoYXBpUGFyYW1zKTtcblxuICBjb25zdCBodHRwUG9zdDogSHR0cFBvc3QgPSBwb3N0TWV0aG9kKGFwaVBhcmFtcylcblxuICBjb25zdCBodHRwUHV0OiBIdHRwUHV0ID0gcHV0TWV0aG9kKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgaHR0cE9wdGlvbnM6IEh0dHBPcHRpb25zTWV0aG9kID0gb3B0aW9uc01ldGhvZChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGh0dHBDb25uZWN0OiBIdHRwQ29ubmVjdCA9IGNvbm5lY3RNZXRob2QoYXBpUGFyYW1zKTtcblxuICBjb25zdCBodHRwVHJhY2U6IEh0dHBUcmFjZSA9IHRyYWNlTWV0aG9kKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgaHR0cFBhdGNoOiBIdHRwUGF0Y2ggPSBwYXRjaE1ldGhvZChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGh0dHBQb3N0RmlsZTogSHR0cFBvc3RGaWxlID0gcG9zdEZpbGVNZXRob2QoYXBpUGFyYW1zKTtcblxuICBjb25zdCB1cGxvYWRBc3luYzogVXBsb2FkQXN5bmMgPSB1cGxvYWRBc3luY01ldGhvZChhcGlQYXJhbXMpO1xuXG4gIHJldHVybiB7XG4gICAgaHR0cERlbGV0ZSxcbiAgICBodHRwR2V0LFxuICAgIGh0dHBQdXQsXG4gICAgaHR0cFBvc3QsXG4gICAgaHR0cFBvc3RGaWxlLFxuICAgIHVwbG9hZEFzeW5jLFxuICAgIGh0dHBPcHRpb25zLFxuICAgIGh0dHBDb25uZWN0LFxuICAgIGh0dHBUcmFjZSxcbiAgICBodHRwUGF0Y2gsXG4gIH07XG5cbn1cbiIsIi8vIFNpbXBsZSBBUEkgd3JhcHBlcnMgZm9yIGVhc2llciB1c2UgaW4gZXhhbXBsZXMgYW5kIGJhc2ljIHVzYWdlXG5pbXBvcnQgeyBnZXRNZXRob2QsIEdldE1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvZ2V0TWV0aG9kXCI7XG5pbXBvcnQgeyBwb3N0TWV0aG9kLCBQb3N0TWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9wb3N0TWV0aG9kXCI7XG5pbXBvcnQgeyBwdXRNZXRob2QsIFB1dE1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvcHV0TWV0aG9kXCI7XG5pbXBvcnQgeyBvcHRpb25zTWV0aG9kLCBPcHRpb25zTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9vcHRpb25zTWV0aG9kXCI7XG5pbXBvcnQgeyBjb25uZWN0TWV0aG9kLCBDb25uZWN0TWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9jb25uZWN0TWV0aG9kXCI7XG5pbXBvcnQgeyB0cmFjZU1ldGhvZCwgVHJhY2VNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3RyYWNlTWV0aG9kXCI7XG5pbXBvcnQgeyBwYXRjaE1ldGhvZCwgUGF0Y2hNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3BhdGNoTWV0aG9kXCI7XG5pbXBvcnQgeyBkZWxldGVNZXRob2QgYXMgZGVsZXRlTWV0aG9kRmFjdG9yeSwgRGVsZXRlTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9kZWxldGVNZXRob2RcIjtcbmltcG9ydCB7IHBvc3RGaWxlTWV0aG9kIGFzIHBvc3RGaWxlTWV0aG9kRmFjdG9yeSwgUG9zdEZpbGVNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3Bvc3RGaWxlTWV0aG9kXCI7XG5pbXBvcnQgeyB1cGxvYWRBc3luY01ldGhvZCBhcyB1cGxvYWRBc3luY01ldGhvZEZhY3RvcnksIFVwbG9hZEFzeW5jTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS91cGxvYWRBc3luY01ldGhvZFwiO1xuaW1wb3J0IHR5cGUgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi9hcGlcIjtcblxuLy8gRXh0ZW5kZWQgb3B0aW9ucyBpbnRlcmZhY2VzIHRoYXQgaW5jbHVkZSBjb21tb25seSB1c2VkIHByb3BlcnRpZXNcbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlR2V0T3B0aW9ucyBleHRlbmRzIFBhcnRpYWw8R2V0TWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgLy8gUmVtb3ZlIHBhcmFtcyBvdmVycmlkZSB0byBhdm9pZCB0eXBlIGNvbmZsaWN0c1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVBvc3RPcHRpb25zIGV4dGVuZHMgUGFydGlhbDxQb3N0TWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgLy8gUmVtb3ZlIHBhcmFtcyBvdmVycmlkZSB0byBhdm9pZCB0eXBlIGNvbmZsaWN0c1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVB1dE9wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPFB1dE1ldGhvZE9wdGlvbnM+IHtcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlRGVsZXRlT3B0aW9ucyBleHRlbmRzIFBhcnRpYWw8RGVsZXRlTWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVQb3N0RmlsZU9wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPFBvc3RGaWxlTWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVVcGxvYWRBc3luY09wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPFVwbG9hZEFzeW5jTWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVPcHRpb25zT3B0aW9ucyBleHRlbmRzIFBhcnRpYWw8T3B0aW9uc01ldGhvZE9wdGlvbnM+IHtcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlQ29ubmVjdE9wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPENvbm5lY3RNZXRob2RPcHRpb25zPiB7XG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVRyYWNlT3B0aW9ucyBleHRlbmRzIFBhcnRpYWw8VHJhY2VNZXRob2RPcHRpb25zPiB7XG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVBhdGNoT3B0aW9ucyBleHRlbmRzIFBhcnRpYWw8UGF0Y2hNZXRob2RPcHRpb25zPiB7XG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG4vLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIGV4YW1wbGVzXG5jb25zdCBkZWZhdWx0QXBpUGFyYW1zOiBBcGlQYXJhbXMgPSB7XG4gIGNvbmZpZzoge1xuICAgIHVybDogJycsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIGFzIFJlcXVlc3RDcmVkZW50aWFscyxcbiAgICBjbGllbnROYW1lOiAnZmplbGwtaHR0cC1hcGktZXhhbXBsZXMnXG4gIH0sXG4gIHBvcHVsYXRlQXV0aEhlYWRlcjogYXN5bmMgKGlzQXV0aGVudGljYXRlZDogYm9vbGVhbiwgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgIC8vIE1vY2sgYXV0aCBoZWFkZXIgcG9wdWxhdGlvbiBmb3IgZXhhbXBsZXNcbiAgICBpZiAoaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyIGV4YW1wbGUtdG9rZW4nO1xuICAgIH1cbiAgfSxcbiAgdXBsb2FkQXN5bmNGaWxlOiBhc3luYyAoKSA9PiB7XG4gICAgLy8gTW9jayBmaWxlIHVwbG9hZCBmb3IgZXhhbXBsZXNcbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyczoge30sXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBDcmVhdGUgY29uZmlndXJlZCBpbnN0YW5jZXNcbmNvbnN0IGdldEltcGwgPSBnZXRNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG5jb25zdCBwb3N0SW1wbCA9IHBvc3RNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG5jb25zdCBwdXRJbXBsID0gcHV0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3Qgb3B0aW9uc0ltcGwgPSBvcHRpb25zTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3QgY29ubmVjdEltcGwgPSBjb25uZWN0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3QgdHJhY2VJbXBsID0gdHJhY2VNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG5jb25zdCBwYXRjaEltcGwgPSBwYXRjaE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbmNvbnN0IGRlbGV0ZUltcGwgPSBkZWxldGVNZXRob2RGYWN0b3J5KGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3QgcG9zdEZpbGVJbXBsID0gcG9zdEZpbGVNZXRob2RGYWN0b3J5KGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3QgdXBsb2FkQXN5bmNJbXBsID0gdXBsb2FkQXN5bmNNZXRob2RGYWN0b3J5KGRlZmF1bHRBcGlQYXJhbXMpO1xuXG4vLyBFeHBvcnQgc2ltcGxlIGZ1bmN0aW9ucyB0aGF0IG1hdGNoIHRoZSBleHBlY3RlZCBpbnRlcmZhY2VcbmV4cG9ydCBjb25zdCBnZXQgPSA8Uz4ocGF0aDogc3RyaW5nLCBvcHRpb25zPzogU2ltcGxlR2V0T3B0aW9ucyk6IFByb21pc2U8Uz4gPT4ge1xuICByZXR1cm4gZ2V0SW1wbChwYXRoLCBvcHRpb25zKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwb3N0ID0gPFM+KHBhdGg6IHN0cmluZywgYm9keT86IGFueSwgb3B0aW9ucz86IFNpbXBsZVBvc3RPcHRpb25zKTogUHJvbWlzZTxTPiA9PiB7XG4gIHJldHVybiBwb3N0SW1wbChwYXRoLCBib2R5LCBvcHRpb25zKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwdXQgPSA8Uz4ocGF0aDogc3RyaW5nLCBib2R5PzogYW55LCBvcHRpb25zPzogU2ltcGxlUHV0T3B0aW9ucyk6IFByb21pc2U8Uz4gPT4ge1xuICByZXR1cm4gcHV0SW1wbChwYXRoLCBib2R5LCBvcHRpb25zKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVNZXRob2QgPSA8Uz4ocGF0aDogc3RyaW5nLCBib2R5PzogYW55LCBvcHRpb25zPzogU2ltcGxlRGVsZXRlT3B0aW9ucyk6IFByb21pc2U8Uz4gPT4ge1xuICByZXR1cm4gZGVsZXRlSW1wbChwYXRoLCBib2R5LCBvcHRpb25zKTtcbn07XG5cbmV4cG9ydCBjb25zdCBvcHRpb25zID0gPFM+KHBhdGg6IHN0cmluZywgb3B0cz86IFNpbXBsZU9wdGlvbnNPcHRpb25zKTogUHJvbWlzZTxTPiA9PiB7XG4gIHJldHVybiBvcHRpb25zSW1wbChwYXRoLCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb25uZWN0ID0gPFM+KHBhdGg6IHN0cmluZywgb3B0cz86IFNpbXBsZUNvbm5lY3RPcHRpb25zKTogUHJvbWlzZTxTPiA9PiB7XG4gIHJldHVybiBjb25uZWN0SW1wbChwYXRoLCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFjZSA9IDxTPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBTaW1wbGVUcmFjZU9wdGlvbnMpOiBQcm9taXNlPFM+ID0+IHtcbiAgcmV0dXJuIHRyYWNlSW1wbChwYXRoLCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXRjaCA9IDxTPihwYXRoOiBzdHJpbmcsIGJvZHk/OiBhbnksIG9wdHM/OiBTaW1wbGVQYXRjaE9wdGlvbnMpOiBQcm9taXNlPFM+ID0+IHtcbiAgcmV0dXJuIHBhdGNoSW1wbChwYXRoLCBib2R5LCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwb3N0RmlsZU1ldGhvZCA9IDxTPihwYXRoOiBzdHJpbmcsIGZpbGU6IEZpbGUsIG9wdGlvbnM/OiBTaW1wbGVQb3N0RmlsZU9wdGlvbnMpOiBQcm9taXNlPFM+ID0+IHtcbiAgLy8gQ29udmVydCBGaWxlIHRvIHRoZSBleHBlY3RlZCBmb3JtYXQgLSB0aGlzIGlzIGEgc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvblxuICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCByZWFkIHRoZSBGaWxlIG9iamVjdCBwcm9wZXJseSB1c2luZyBGaWxlUmVhZGVyXG4gIGNvbnN0IGZpbGVCdWZmZXIgPSB7XG4gICAgYnVmZmVyOiBCdWZmZXIuZnJvbShbXSksIC8vIFBsYWNlaG9sZGVyIC0gd291bGQgbmVlZCBwcm9wZXIgRmlsZSByZWFkaW5nIGluIGJyb3dzZXJcbiAgICBidWZmZXJOYW1lOiBmaWxlLm5hbWVcbiAgfTtcblxuICAvLyBVc2UgZGVmYXVsdCBlbXB0eSBvYmplY3RzIGZvciBib2R5IGFuZCBoZWFkZXJzLCB0aGVuIHRoZSBmaWxlIG9iamVjdCwgdGhlbiBvcHRpb25zXG4gIHJldHVybiBwb3N0RmlsZUltcGwocGF0aCwge30sIHt9LCBmaWxlQnVmZmVyLCBvcHRpb25zKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGxvYWRBc3luY01ldGhvZCA9IDxTPihwYXRoOiBzdHJpbmcsIHVyaTogc3RyaW5nLCBvcHRpb25zPzogU2ltcGxlVXBsb2FkQXN5bmNPcHRpb25zKTogUHJvbWlzZTxTPiA9PiB7XG4gIHJldHVybiB1cGxvYWRBc3luY0ltcGwocGF0aCwgdXJpLCBvcHRpb25zKTtcbn07XG4iXSwibmFtZXMiOlsib3B0aW9ucyIsImFwaVBhcmFtcyIsImxvZ2dlciIsImRlbGV0ZU1ldGhvZCIsInBvc3RGaWxlTWV0aG9kIiwidXBsb2FkQXN5bmNNZXRob2QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../fjell-http-api/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../fjell-registry/dist/index.js":
/*!***************************************!*\
  !*** ../fjell-registry/dist/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(ssr)/../fjell-logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = (kta, scopes = [])=>{\n    const ktArray = Array.isArray(kta) ? kta : [\n        kta\n    ];\n    const toString = ()=>{\n        logger.debug(\"toString\", {\n            kta,\n            scopes\n        });\n        return `${ktArray.join(\", \")} - ${scopes.join(\", \")}`;\n    };\n    logger.debug(\"createCoordinate\", {\n        kta: ktArray,\n        scopes,\n        toString\n    });\n    return {\n        kta: ktArray,\n        scopes,\n        toString\n    };\n};\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate)=>{\n    logger2.debug(\"createInstance\", {\n        coordinate,\n        registry\n    });\n    return {\n        coordinate,\n        registry\n    };\n};\nvar isInstance = (instance)=>{\n    return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n// src/RegistryStats.ts\nvar RegistryStats = class {\n    /**\n   * Records a get() call for the specified coordinate and client\n   */ recordGetCall(kta, scopes, client) {\n        this.totalCalls++;\n        const ktaKey = kta.join(\".\");\n        const scopeKey = this.createScopeKey(scopes || []);\n        const clientKey = this.createClientKey(client);\n        if (!this.coordinateCalls.has(ktaKey)) {\n            this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n        }\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap.has(scopeKey)) {\n            scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n        }\n        const clientMap = scopeMap.get(scopeKey);\n        const currentCount = clientMap.get(clientKey) || 0;\n        clientMap.set(clientKey, currentCount + 1);\n    }\n    /**\n   * Gets the current statistics snapshot\n   */ getStatistics() {\n        const coordinateCallRecords = [];\n        let serviceCalls = 0;\n        let applicationCalls = 0;\n        let unidentifiedCalls = 0;\n        for (const [ktaKey, scopeMap] of this.coordinateCalls){\n            for (const [scopeKey, clientMap] of scopeMap){\n                const clientCalls = [];\n                let totalCount = 0;\n                for (const [clientKey, count] of clientMap){\n                    const client = this.parseClientKey(clientKey);\n                    if (client !== null) {\n                        clientCalls.push({\n                            client,\n                            count\n                        });\n                    }\n                    totalCount += count;\n                    if (clientKey === \"__no_client__\") {\n                        unidentifiedCalls += count;\n                    } else if (typeof client === \"string\") {\n                        applicationCalls += count;\n                    } else if (client !== null) {\n                        serviceCalls += count;\n                    }\n                }\n                coordinateCallRecords.push({\n                    kta: ktaKey.split(\".\"),\n                    scopes: this.parseScopeKey(scopeKey),\n                    count: totalCount,\n                    clientCalls: [\n                        ...clientCalls\n                    ]\n                });\n            }\n        }\n        return {\n            totalGetCalls: this.totalCalls,\n            coordinateCallRecords: [\n                ...coordinateCallRecords\n            ],\n            // Return a copy\n            clientSummary: {\n                serviceCalls,\n                applicationCalls,\n                unidentifiedCalls\n            }\n        };\n    }\n    /**\n   * Gets call count for a specific coordinate combination\n   */ getCallCount(kta, scopes) {\n        const ktaKey = kta.join(\".\");\n        const scopeKey = this.createScopeKey(scopes || []);\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap) return 0;\n        const clientMap = scopeMap.get(scopeKey);\n        if (!clientMap) return 0;\n        let total = 0;\n        for (const count of clientMap.values()){\n            total += count;\n        }\n        return total;\n    }\n    /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */ getCallCountByClient(kta, scopes, client) {\n        const ktaKey = kta.join(\".\");\n        const scopeKey = this.createScopeKey(scopes || []);\n        const clientKey = this.createClientKey(client);\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap) return 0;\n        const clientMap = scopeMap.get(scopeKey);\n        if (!clientMap) return 0;\n        return clientMap.get(clientKey) || 0;\n    }\n    /**\n   * Gets total calls for a specific kta (across all scopes)\n   */ getTotalCallsForKta(kta) {\n        const ktaKey = kta.join(\".\");\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap) return 0;\n        let total = 0;\n        for (const clientMap of scopeMap.values()){\n            for (const count of clientMap.values()){\n                total += count;\n            }\n        }\n        return total;\n    }\n    /**\n   * Gets all unique kta paths that have been called\n   */ getCalledKtaPaths() {\n        const ktaPaths = [];\n        for (const ktaKey of this.coordinateCalls.keys()){\n            ktaPaths.push(ktaKey.split(\".\"));\n        }\n        return ktaPaths;\n    }\n    /**\n   * Creates a normalized scope key from scopes array\n   */ createScopeKey(scopes) {\n        if (scopes.length === 0) return \"__no_scopes__\";\n        return [\n            ...scopes\n        ].sort().join(\",\");\n    }\n    /**\n   * Parses a scope key back to scopes array\n   */ parseScopeKey(scopeKey) {\n        if (scopeKey === \"__no_scopes__\") return [];\n        return scopeKey.split(\",\");\n    }\n    /**\n   * Creates a normalized client key from client identifier\n   */ createClientKey(client) {\n        if (!client) return \"__no_client__\";\n        if (typeof client === \"string\") {\n            return `app:${client}`;\n        }\n        const coordKey = `${client.coordinate.kta.join(\".\")};${this.createScopeKey(client.coordinate.scopes)}`;\n        return `service:${client.registryType}:${coordKey}`;\n    }\n    /**\n   * Parses a client key back to client identifier\n   */ parseClientKey(clientKey) {\n        if (clientKey === \"__no_client__\") return null;\n        if (clientKey.startsWith(\"app:\")) {\n            return clientKey.substring(4);\n        }\n        if (clientKey.startsWith(\"service:\")) {\n            const parts = clientKey.substring(8).split(\":\");\n            if (parts.length !== 2) return null;\n            const registryType = parts[0];\n            const coordParts = parts[1].split(\";\");\n            if (coordParts.length !== 2) return null;\n            const kta = coordParts[0].split(\".\");\n            const scopes = this.parseScopeKey(coordParts[1]);\n            return {\n                registryType,\n                coordinate: {\n                    kta,\n                    scopes\n                }\n            };\n        }\n        return null;\n    }\n    constructor(){\n        this.totalCalls = 0;\n        // Map structure: ktaKey -> scopeKey -> clientKey -> count\n        this.coordinateCalls = /* @__PURE__ */ new Map();\n    }\n};\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes)=>{\n    if (!requestedScopes || requestedScopes.length === 0) {\n        const firstInstance = scopedInstances[0]?.instance;\n        if (!firstInstance) {\n            throw new Error(\"No instances available\");\n        }\n        return firstInstance;\n    }\n    const matchingInstance = scopedInstances.find((scopedInstance)=>{\n        if (!scopedInstance.scopes) return false;\n        return requestedScopes.every((scope)=>scopedInstance.scopes && scopedInstance.scopes.includes(scope));\n    });\n    if (!matchingInstance) {\n        throw new Error(`No instance found matching scopes: ${requestedScopes.join(\", \")}`);\n    }\n    return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub)=>{\n    const instanceTree = {};\n    const registryStats = new RegistryStats();\n    const createProxiedRegistry = (callingCoordinate)=>{\n        const serviceClient = {\n            registryType: type,\n            coordinate: {\n                kta: callingCoordinate.kta,\n                scopes: callingCoordinate.scopes\n            }\n        };\n        return {\n            ...registry,\n            get: (kta, options)=>{\n                const clientToUse = options?.client || serviceClient;\n                return registry.get(kta, {\n                    ...options,\n                    client: clientToUse\n                });\n            }\n        };\n    };\n    const createInstance2 = (kta, scopes, factory)=>{\n        logger3.debug(`Creating and registering instance for key path and scopes`, kta, scopes, `in registry type: ${type}`);\n        const coordinate = createCoordinate(kta, scopes);\n        const proxiedRegistry = createProxiedRegistry(coordinate);\n        const instance = factory(coordinate, {\n            registry: proxiedRegistry,\n            registryHub\n        });\n        if (!isInstance(instance)) {\n            throw new Error(`Factory did not return a valid instance for: ${kta.join(\".\")}`);\n        }\n        registerInternal(kta, instance, {\n            scopes\n        });\n        return instance;\n    };\n    const registerInternal = (kta, instance, options)=>{\n        const keyPath = [\n            ...kta\n        ].reverse();\n        let currentLevel = instanceTree;\n        logger3.debug(`Registering instance for key path and scopes`, keyPath, options?.scopes, `in registry type: ${type}`);\n        if (!isInstance(instance)) {\n            throw new Error(`Attempting to register a non-instance: ${kta.join(\".\")}`);\n        }\n        for(let i = 0; i < keyPath.length; i++){\n            const keyType = keyPath[i];\n            const isLeaf = i === keyPath.length - 1;\n            if (!currentLevel[keyType]) {\n                currentLevel[keyType] = {\n                    instances: [],\n                    children: isLeaf ? null : {}\n                };\n            }\n            if (isLeaf) {\n                currentLevel[keyType].instances.push({\n                    scopes: options?.scopes,\n                    instance\n                });\n            } else {\n                if (!currentLevel[keyType].children) {\n                    currentLevel[keyType].children = {};\n                }\n                currentLevel = currentLevel[keyType].children;\n            }\n        }\n    };\n    const register = (kta, instance, options)=>{\n        logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n        registerInternal(kta, instance, options);\n    };\n    const get = (kta, options)=>{\n        registryStats.recordGetCall(kta, options?.scopes, options?.client);\n        const keyPath = [\n            ...kta\n        ].reverse();\n        let currentLevel = instanceTree;\n        for(let i = 0; i < keyPath.length; i++){\n            const keyType = keyPath[i];\n            const isLeaf = i === keyPath.length - 1;\n            if (!currentLevel[keyType]) {\n                throw new Error(`Instance not found for key path: ${kta.join(\".\")}, Missing key: ${keyType}`);\n            }\n            if (isLeaf) {\n                const scopedInstances = currentLevel[keyType].instances;\n                if (scopedInstances.length === 0) {\n                    throw new Error(`No instances registered for key path: ${kta.join(\".\")}`);\n                }\n                return findScopedInstance(scopedInstances, options?.scopes);\n            } else {\n                if (!currentLevel[keyType].children) {\n                    throw new Error(`Instance not found for key path: ${kta.join(\".\")}, No children for: ${keyType}`);\n                }\n                currentLevel = currentLevel[keyType].children;\n            }\n        }\n        return null;\n    };\n    const getCoordinates = ()=>{\n        const coordinates = [];\n        const traverseTree = (node)=>{\n            for(const keyType in node){\n                const treeNode = node[keyType];\n                for (const scopedInstance of treeNode.instances){\n                    coordinates.push(scopedInstance.instance.coordinate);\n                }\n                if (treeNode.children) {\n                    traverseTree(treeNode.children);\n                }\n            }\n        };\n        traverseTree(instanceTree);\n        return coordinates;\n    };\n    const getStatistics = ()=>{\n        return registryStats.getStatistics();\n    };\n    const registry = {\n        type,\n        registryHub,\n        createInstance: createInstance2,\n        register,\n        get,\n        getCoordinates,\n        getStatistics,\n        instanceTree\n    };\n    return registry;\n};\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n    constructor(message, registryType, context){\n        super(message);\n        this.name = this.constructor.name;\n        this.registryType = registryType;\n        this.context = context;\n        const ErrorConstructor = Error;\n        if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n            ErrorConstructor.captureStackTrace(this, this.constructor);\n        }\n    }\n    getDetails() {\n        const details = [\n            this.message\n        ];\n        if (this.registryType) {\n            details.push(`Registry Type: ${this.registryType}`);\n        }\n        if (this.context) {\n            details.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n        }\n        return details.join(\"\\n\");\n    }\n};\nvar RegistryCreationError = class extends RegistryError {\n    constructor(type, reason, context){\n        super(`Failed to create registry of type '${type}': ${reason}`, type, context);\n    }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n    constructor(keyPath, factoryResult, registryType){\n        const keyPathStr = keyPath.join(\".\");\n        super(`Factory did not return a valid instance for: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof factoryResult}`, registryType, {\n            keyPath,\n            factoryResult: typeof factoryResult\n        });\n        this.keyPath = keyPath;\n        this.factoryResult = factoryResult;\n    }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n    constructor(keyPath, attemptedRegistration, registryType){\n        const keyPathStr = keyPath.join(\".\");\n        super(`Attempting to register a non-instance: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof attemptedRegistration}`, registryType, {\n            keyPath,\n            attemptedRegistration: typeof attemptedRegistration\n        });\n        this.keyPath = keyPath;\n        this.attemptedRegistration = attemptedRegistration;\n    }\n};\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n    constructor(message, hubType, context){\n        const enrichedContext = hubType ? {\n            ...context,\n            hubType\n        } : context;\n        super(message, \"\", enrichedContext);\n        this.hubType = hubType;\n    }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n    constructor(type, context){\n        super(`Registry already registered under type: ${type}. Each registry type must be unique within a registry hub.`, \"\", {\n            ...context,\n            duplicateType: type\n        });\n        this.duplicateType = type;\n    }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n    constructor(requestedType, availableTypes = [], context){\n        let message = `No registry registered under type: ${requestedType}`;\n        if (availableTypes.length > 0) {\n            message += `. Available types: [${availableTypes.join(\", \")}]`;\n        }\n        super(message, \"\", {\n            ...context,\n            requestedType,\n            availableTypes\n        });\n        this.requestedType = requestedType;\n        this.availableTypes = availableTypes;\n    }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n    constructor(type, factoryError, context){\n        super(`Registry factory failed to create registry of type '${type}': ${factoryError.message}`, \"\", {\n            ...context,\n            attemptedType: type,\n            originalError: factoryError.message\n        });\n        this.factoryError = factoryError;\n        this.attemptedType = type;\n    }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n    constructor(type, factoryResult, context){\n        super(`Registry factory returned invalid registry for type '${type}'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: ${typeof factoryResult}`, \"\", {\n            ...context,\n            attemptedType: type,\n            factoryResult: typeof factoryResult\n        });\n        this.factoryResult = factoryResult;\n        this.attemptedType = type;\n    }\n};\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = ()=>{\n    const registries = {};\n    const createRegistry2 = (type, factory)=>{\n        logger4.debug(`Creating new registry with type: ${type}`);\n        if (registries[type]) {\n            throw new DuplicateRegistryTypeError(type);\n        }\n        const registry = factory(type, hub);\n        if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n            registry.registryHub = hub;\n        }\n        registries[type] = registry;\n        logger4.debug(`Successfully created and registered new registry with type: ${type}`);\n        return registry;\n    };\n    const registerRegistry = (registry)=>{\n        const type = registry.type;\n        logger4.debug(`Registering registry with type: ${type}`);\n        if (registries[type]) {\n            throw new DuplicateRegistryTypeError(type);\n        }\n        registries[type] = registry;\n        if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n            registry.registryHub = hub;\n        }\n        logger4.debug(`Successfully registered registry with type: ${type}`);\n    };\n    const get = (type, kta, options)=>{\n        logger4.debug(`Looking up instance for type: ${type}, kta: ${kta.join(\".\")}, scopes: ${options?.scopes?.join(\",\") || \"none\"}`);\n        const registry = registries[type];\n        if (!registry) {\n            const availableTypes = Object.keys(registries);\n            throw new RegistryTypeNotFoundError(type, availableTypes);\n        }\n        return registry.get(kta, options);\n    };\n    const getRegistry = (type)=>{\n        return registries[type] || null;\n    };\n    const getRegisteredTypes = ()=>{\n        return Object.keys(registries);\n    };\n    const unregisterRegistry = (type)=>{\n        if (registries[type]) {\n            delete registries[type];\n            logger4.debug(`Unregistered registry under type: ${type}`);\n            return true;\n        }\n        return false;\n    };\n    const getAllCoordinates = ()=>{\n        const allCoordinates = [];\n        for(const registryType in registries){\n            const registry = registries[registryType];\n            const coordinates = registry.getCoordinates();\n            coordinates.forEach((coordinate)=>{\n                allCoordinates.push({\n                    coordinate,\n                    registryType\n                });\n            });\n        }\n        logger4.debug(`Retrieved ${allCoordinates.length} total coordinates from ${Object.keys(registries).length} registries`);\n        return allCoordinates;\n    };\n    const hub = {\n        createRegistry: createRegistry2,\n        registerRegistry,\n        get,\n        getRegistry,\n        getRegisteredTypes,\n        getAllCoordinates,\n        unregisterRegistry\n    };\n    return hub;\n};\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n    constructor(message, keyPath, registryType, context){\n        super(message, registryType, {\n            ...context,\n            keyPath\n        });\n        this.keyPath = keyPath;\n    }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n    constructor(keyPath, missingKey, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        let message = `Instance not found for key path: ${keyPathStr}`;\n        if (missingKey) {\n            message += `, Missing key: ${missingKey}`;\n        }\n        super(message, keyPath, registryType, {\n            ...context,\n            missingKey\n        });\n        this.missingKey = missingKey;\n    }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n    constructor(keyPath, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        super(`No instances registered for key path: ${keyPathStr}. The key path exists in the registry tree but contains no instances.`, keyPath, registryType, context);\n    }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n    constructor(keyPath, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        super(`No instances available for key path: ${keyPathStr}. This typically indicates an internal registry state issue.`, keyPath, registryType, context);\n    }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n    constructor(keyPath, requestedScopes, availableScopes = [], registryType){\n        const keyPathStr = keyPath.join(\".\");\n        const scopesStr = requestedScopes.join(\", \");\n        const availableScopesStr = availableScopes.map((scopes)=>`[${scopes.join(\", \")}]`).join(\", \");\n        let message = `No instance found matching scopes: ${scopesStr} for key path: ${keyPathStr}`;\n        if (availableScopes.length > 0) {\n            message += `. Available scopes: ${availableScopesStr}`;\n        }\n        super(message, keyPath, registryType, {\n            requestedScopes,\n            availableScopes\n        });\n        this.requestedScopes = requestedScopes;\n        this.availableScopes = availableScopes;\n    }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n    constructor(keyPath, parentKey, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        super(`Instance not found for key path: ${keyPathStr}, No children for: ${parentKey}. The path cannot be traversed further as '${parentKey}' has no child nodes.`, keyPath, registryType, {\n            ...context,\n            parentKey\n        });\n        this.parentKey = parentKey;\n    }\n};\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n    constructor(message, kta, scopes, context){\n        super(message, \"\", {\n            ...context,\n            kta,\n            scopes\n        });\n        this.kta = kta;\n        this.scopes = scopes;\n    }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n    constructor(kta, scopes, reason, context){\n        super(`Invalid coordinate parameters: ${reason}. KTA: ${JSON.stringify(kta)}, Scopes: [${scopes.join(\", \")}]`, kta, scopes, {\n            ...context,\n            reason\n        });\n    }\n};\nvar InvalidKTAError = class extends CoordinateError {\n    constructor(kta, reason, context){\n        super(`Invalid KTA (Key Type Array): ${reason}. Expected string or array of strings, got: ${JSON.stringify(kta)}`, kta, [], {\n            ...context,\n            reason\n        });\n    }\n};\nvar InvalidScopesError = class extends CoordinateError {\n    constructor(scopes, invalidScopes, reason, context){\n        super(`Invalid scopes: ${reason}. Invalid scope values: ${JSON.stringify(invalidScopes)}`, null, scopes.filter((s)=>typeof s === \"string\"), {\n            ...context,\n            reason,\n            invalidScopes\n        });\n        this.invalidScopes = invalidScopes;\n    }\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0Y7QUFLTyxJQUFNLHlCQUFOLGNBQXFDLGdCQUFnQjtJQUMxRCxZQUFZLEtBQVUsUUFBa0IsUUFBZ0IsUUFBK0I7UUFDckYsTUFDRSxrQ0FBa0MsTUFBTSxVQUNoQyxLQUFLLFVBQVUsR0FBRyxDQUFDLGNBQWMsT0FBTyxLQUFLLElBQUksQ0FBQyxLQUMxRCxLQUNBLFFBQ0E7WUFBRSxHQUFHO1lBQVM7UUFBTztJQUV6QjtBQUNGO0FBS08sSUFBTSxrQkFBTixjQUE4QixnQkFBZ0I7SUFDbkQsWUFBWSxLQUFVLFFBQWdCLFFBQStCO1FBQ25FLE1BQ0UsaUNBQWlDLE1BQU0sK0NBQ00sS0FBSyxVQUFVLEdBQUcsQ0FBQyxJQUNoRSxLQUNBLENBQUMsR0FDRDtZQUFFLEdBQUc7WUFBUztRQUFPO0lBRXpCO0FBQ0Y7QUFLTyxJQUFNLHFCQUFOLGNBQWlDLGdCQUFnQjtJQUd0RCxZQUFZLFFBQWUsZUFBc0IsUUFBZ0IsUUFBK0I7UUFDOUYsTUFDRSxtQkFBbUIsTUFBTSwyQkFDQSxLQUFLLFVBQVUsYUFBYSxDQUFDLElBQ3RELE1BQ0EsT0FBTyxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsR0FDeEM7WUFBRSxHQUFHO1lBQVM7WUFBUTtRQUFjO1FBRXRDLEtBQUssZ0JBQWdCO0lBQ3ZCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0Nvb3JkaW5hdGUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9JbnN0YW5jZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL1JlZ2lzdHJ5U3RhdHMudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9SZWdpc3RyeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2Vycm9ycy9SZWdpc3RyeUVycm9yLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXJyb3JzL1JlZ2lzdHJ5SHViRXJyb3IudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9SZWdpc3RyeUh1Yi50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2Vycm9ycy9JbnN0YW5jZUVycm9yLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXJyb3JzL0Nvb3JkaW5hdGVFcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9nZ2luZyBmcm9tICdAZmplbGwvbG9nZ2luZyc7XG5cbmNvbnN0IExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKCdAZmplbGwvcmVnaXN0cnknKTtcblxuZXhwb3J0IGRlZmF1bHQgTGliTG9nZ2VyO1xuIiwiaW1wb3J0IHsgSXRlbVR5cGVBcnJheSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiQ29vcmRpbmF0ZVwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBDb29yZGluYXRlPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuPiB7XG4gIGt0YTogSXRlbVR5cGVBcnJheTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICBzY29wZXM6IHN0cmluZ1tdO1xuICB0b1N0cmluZzogKCkgPT4gc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29vcmRpbmF0ZSA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbj4oa3RhOiBJdGVtVHlwZUFycmF5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBTLCBzY29wZXM6IHN0cmluZ1tdID0gW10pOiBDb29yZGluYXRlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBjb25zdCBrdEFycmF5ID0gQXJyYXkuaXNBcnJheShrdGEpID8ga3RhIDogW2t0YV07XG4gIGNvbnN0IHRvU3RyaW5nID0gKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhcInRvU3RyaW5nXCIsIHsga3RhLCBzY29wZXMgfSk7XG4gICAgcmV0dXJuIGAke2t0QXJyYXkuam9pbignLCAnKX0gLSAke3Njb3Blcy5qb2luKCcsICcpfWA7XG4gIH1cbiAgbG9nZ2VyLmRlYnVnKFwiY3JlYXRlQ29vcmRpbmF0ZVwiLCB7IGt0YToga3RBcnJheSwgc2NvcGVzLCB0b1N0cmluZyB9KTtcbiAgcmV0dXJuIHsga3RhOiBrdEFycmF5IGFzIEl0ZW1UeXBlQXJyYXk8UywgTDEsIEwyLCBMMywgTDQsIEw1Piwgc2NvcGVzLCB0b1N0cmluZyB9O1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBSZWdpc3RyeSB9IGZyb20gXCIuL1JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBDb29yZGluYXRlIH0gZnJvbSBcIi4vQ29vcmRpbmF0ZVwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiSW5zdGFuY2VcIik7XG5cbi8qKlxuICogVGhlIEluc3RhbmNlIGludGVyZmFjZSByZXByZXNlbnRzIGEgZGF0YSBtb2RlbCBpbnN0YW5jZSB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBib3RoIGl0cyBzdHJ1Y3R1cmVcbiAqIGFuZCBvcGVyYXRpb25zLiBJdCBzZXJ2ZXMgYXMgdGhlIG1haW4gaW50ZXJmYWNlIGZvciBpbnRlcmFjdGluZyB3aXRoIGRhdGEgbW9kZWxzIGluIHRoZSBzeXN0ZW0uXG4gKlxuICogVGhlIGludGVyZmFjZSBjb25zaXN0cyBvZiB0d28gbWFpbiBjb21wb25lbnRzOlxuICogMS4gZGVmaW5pdGlvbjogRGVmaW5lcyB0aGUgc3RydWN0dXJlLCBrZXlzLCBhbmQgcmVsYXRpb25zaGlwcyBvZiB0aGUgZGF0YSBtb2RlbFxuICogMi4gb3BlcmF0aW9uczogUHJvdmlkZXMgbWV0aG9kcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZGF0YSBtb2RlbCAoZ2V0LCBmaW5kLCBhbGwsIGV0Yy4pXG4gKiAzLiByZWdpc3RyeTogTWFuYWdlcyB0aGUgcmVnaXN0cmF0aW9uIGFuZCBsb29rdXAgb2YgTGlicmFyeSBpbnN0YW5jZXNcbiAqXG4gKiBUaGUgSW5zdGFuY2UgaW50ZXJmYWNlIGlzIGdlbmVyaWMgYW5kIHN1cHBvcnRzIHVwIHRvIDUgbGV2ZWxzIG9mIGxvY2F0aW9uIGhpZXJhcmNoeSAoTDEtTDUpXG4gKiBmb3IgY29udGFpbmVkIGluc3RhbmNlcywgYWxsb3dpbmcgZm9yIGNvbXBsZXggbmVzdGVkIGRhdGEgc3RydWN0dXJlcy5cbiAqXG4gKiBAdGVtcGxhdGUgViAtIFRoZSB0eXBlIG9mIHRoZSBkYXRhIG1vZGVsIGl0ZW0sIGV4dGVuZGluZyBJdGVtXG4gKiBAdGVtcGxhdGUgUyAtIFRoZSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHJlcHJlc2VudGluZyB0aGUgbW9kZWwncyBrZXkgdHlwZVxuICogQHRlbXBsYXRlIEwxLUw1IC0gT3B0aW9uYWwgc3RyaW5nIGxpdGVyYWwgdHlwZXMgZm9yIGxvY2F0aW9uIGhpZXJhcmNoeSBsZXZlbHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZTxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiB7XG4gIGNvb3JkaW5hdGU6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogVGhlIHJlZ2lzdHJ5IG9iamVjdCB0aGF0IG1hbmFnZXMgdGhlIHJlZ2lzdHJhdGlvbiBhbmQgbG9va3VwIG9mIG1vZGVsIGluc3RhbmNlcyAqL1xuICByZWdpc3RyeTogUmVnaXN0cnk7XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnN0YW5jZSA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgcmVnaXN0cnk6IFJlZ2lzdHJ5LFxuICBjb29yZGluYXRlOiBDb29yZGluYXRlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4pOiBJbnN0YW5jZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgbG9nZ2VyLmRlYnVnKFwiY3JlYXRlSW5zdGFuY2VcIiwgeyBjb29yZGluYXRlLCByZWdpc3RyeSB9KTtcbiAgcmV0dXJuIHsgY29vcmRpbmF0ZSwgcmVnaXN0cnkgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzSW5zdGFuY2UgPSAoaW5zdGFuY2U6IGFueSk6IGluc3RhbmNlIGlzIEluc3RhbmNlPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+ID0+IHtcbiAgcmV0dXJuIGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgaW5zdGFuY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgIGluc3RhbmNlLmNvb3JkaW5hdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgIGluc3RhbmNlLnJlZ2lzdHJ5ICE9PSB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBBbGxJdGVtVHlwZUFycmF5cyB9IGZyb20gJ0BmamVsbC9jb3JlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2VydmljZSBjbGllbnQgKGFub3RoZXIgc2VydmljZSBtYWtpbmcgdGhlIHJlcXVlc3QpXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZUNsaWVudCB7XG4gIC8qKiBUaGUgdHlwZSBvZiByZWdpc3RyeSB3aGVyZSB0aGUgY2FsbGluZyBzZXJ2aWNlIGlzIHJlZ2lzdGVyZWQgKi9cbiAgcmVnaXN0cnlUeXBlOiBzdHJpbmc7XG4gIC8qKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgY2FsbGluZyBzZXJ2aWNlICovXG4gIGNvb3JkaW5hdGU6IHtcbiAgICBrdGE6IHN0cmluZ1tdO1xuICAgIHNjb3Blczogc3RyaW5nW107XG4gIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBlaXRoZXIgYSBzZXJ2aWNlIG9yIGFwcGxpY2F0aW9uIGNsaWVudFxuICovXG5leHBvcnQgdHlwZSBDbGllbnRJZGVudGlmaWVyID0gU2VydmljZUNsaWVudCB8IHN0cmluZztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3BlY2lmaWMgY29vcmRpbmF0ZSBjYWxsIHdpdGggYm90aCBrdGEgYW5kIHNjb3Blc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENvb3JkaW5hdGVDYWxsUmVjb3JkIHtcbiAgLyoqIFRoZSBrZXkgdHlwZSBhcnJheSB0aGF0IHdhcyByZXF1ZXN0ZWQgKi9cbiAga3RhOiBzdHJpbmdbXTtcbiAgLyoqIFRoZSBzY29wZXMgdGhhdCB3ZXJlIHJlcXVlc3RlZCAoZW1wdHkgYXJyYXkgaWYgbm8gc2NvcGVzKSAqL1xuICBzY29wZXM6IHN0cmluZ1tdO1xuICAvKiogTnVtYmVyIG9mIHRpbWVzIHRoaXMgZXhhY3QgY29tYmluYXRpb24gd2FzIGNhbGxlZCAqL1xuICBjb3VudDogbnVtYmVyO1xuICAvKiogQnJlYWtkb3duIG9mIGNhbGxzIGJ5IGNsaWVudCAqL1xuICBjbGllbnRDYWxsczogQ2xpZW50Q2FsbFJlY29yZFtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgY2FsbHMgZnJvbSBhIHNwZWNpZmljIGNsaWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudENhbGxSZWNvcmQge1xuICAvKiogVGhlIGNsaWVudCB0aGF0IG1hZGUgdGhlIGNhbGxzICovXG4gIGNsaWVudDogQ2xpZW50SWRlbnRpZmllcjtcbiAgLyoqIE51bWJlciBvZiBjYWxscyBmcm9tIHRoaXMgY2xpZW50ICovXG4gIGNvdW50OiBudW1iZXI7XG59XG5cbi8qKlxuICogU3RhdGlzdGljcyBhYm91dCBSZWdpc3RyeSBnZXQoKSBtZXRob2QgY2FsbHMgd2l0aCBkZXRhaWxlZCBjb29yZGluYXRlIHRyYWNraW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cnlTdGF0aXN0aWNzIHtcbiAgLyoqIFRvdGFsIG51bWJlciBvZiBnZXQoKSBjYWxscyBtYWRlIG9uIHRoaXMgcmVnaXN0cnkgKi9cbiAgdG90YWxHZXRDYWxsczogbnVtYmVyO1xuICAvKiogRGV0YWlsZWQgcmVjb3JkcyBvZiBlYWNoIHVuaXF1ZSBjb29yZGluYXRlIGNvbWJpbmF0aW9uIGFuZCB0aGVpciBjYWxsIGNvdW50cyAqL1xuICBjb29yZGluYXRlQ2FsbFJlY29yZHM6IENvb3JkaW5hdGVDYWxsUmVjb3JkW107XG4gIC8qKiBTdW1tYXJ5IG9mIGNhbGxzIGJ5IGNsaWVudCB0eXBlICovXG4gIGNsaWVudFN1bW1hcnk6IHtcbiAgICAvKiogVG90YWwgY2FsbHMgZnJvbSBzZXJ2aWNlcyAoc2VydmljZS10by1zZXJ2aWNlKSAqL1xuICAgIHNlcnZpY2VDYWxsczogbnVtYmVyO1xuICAgIC8qKiBUb3RhbCBjYWxscyBmcm9tIGFwcGxpY2F0aW9ucyAoZGlyZWN0IGFwcGxpY2F0aW9uIGNhbGxzKSAqL1xuICAgIGFwcGxpY2F0aW9uQ2FsbHM6IG51bWJlcjtcbiAgICAvKiogVG90YWwgY2FsbHMgd2l0aCBubyBjbGllbnQgc3BlY2lmaWVkICovXG4gICAgdW5pZGVudGlmaWVkQ2FsbHM6IG51bWJlcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBjbGFzcyBmb3IgdHJhY2tpbmcgUmVnaXN0cnkgc3RhdGlzdGljcyB3aXRoIGNvbXBsZXggY29vcmRpbmF0ZSBjb21iaW5hdGlvbnMgYW5kIGNsaWVudCB0cmFja2luZ1xuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0cnlTdGF0cyB7XG4gIHByaXZhdGUgdG90YWxDYWxscyA9IDA7XG4gIC8vIE1hcCBzdHJ1Y3R1cmU6IGt0YUtleSAtPiBzY29wZUtleSAtPiBjbGllbnRLZXkgLT4gY291bnRcbiAgcHJpdmF0ZSBjb29yZGluYXRlQ2FsbHMgPSBuZXcgTWFwPHN0cmluZywgTWFwPHN0cmluZywgTWFwPHN0cmluZywgbnVtYmVyPj4+KCk7XG5cbiAgLyoqXG4gICAqIFJlY29yZHMgYSBnZXQoKSBjYWxsIGZvciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUgYW5kIGNsaWVudFxuICAgKi9cbiAgcmVjb3JkR2V0Q2FsbDxcbiAgICBTIGV4dGVuZHMgc3RyaW5nID0gYW55LFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gYW55IHwgbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBhbnkgfCBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IGFueSB8IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gYW55IHwgbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBhbnkgfCBuZXZlcixcbiAgPihrdGE6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIHNjb3Blcz86IHN0cmluZ1tdLCBjbGllbnQ/OiBDbGllbnRJZGVudGlmaWVyKTogdm9pZCB7XG4gICAgdGhpcy50b3RhbENhbGxzKys7XG5cbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbignLicpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IGNsaWVudEtleSA9IHRoaXMuY3JlYXRlQ2xpZW50S2V5KGNsaWVudCk7XG5cbiAgICBpZiAoIXRoaXMuY29vcmRpbmF0ZUNhbGxzLmhhcyhrdGFLZXkpKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVDYWxscy5zZXQoa3RhS2V5LCBuZXcgTWFwKCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSkhO1xuICAgIGlmICghc2NvcGVNYXAuaGFzKHNjb3BlS2V5KSkge1xuICAgICAgc2NvcGVNYXAuc2V0KHNjb3BlS2V5LCBuZXcgTWFwKCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSkhO1xuICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IGNsaWVudE1hcC5nZXQoY2xpZW50S2V5KSB8fCAwO1xuICAgIGNsaWVudE1hcC5zZXQoY2xpZW50S2V5LCBjdXJyZW50Q291bnQgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRpc3RpY3Mgc25hcHNob3RcbiAgICovXG4gIGdldFN0YXRpc3RpY3MoKTogUmVnaXN0cnlTdGF0aXN0aWNzIHtcbiAgICBjb25zdCBjb29yZGluYXRlQ2FsbFJlY29yZHM6IENvb3JkaW5hdGVDYWxsUmVjb3JkW10gPSBbXTtcbiAgICBsZXQgc2VydmljZUNhbGxzID0gMDtcbiAgICBsZXQgYXBwbGljYXRpb25DYWxscyA9IDA7XG4gICAgbGV0IHVuaWRlbnRpZmllZENhbGxzID0gMDtcblxuICAgIGZvciAoY29uc3QgW2t0YUtleSwgc2NvcGVNYXBdIG9mIHRoaXMuY29vcmRpbmF0ZUNhbGxzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtzY29wZUtleSwgY2xpZW50TWFwXSBvZiBzY29wZU1hcCkge1xuICAgICAgICBjb25zdCBjbGllbnRDYWxsczogQ2xpZW50Q2FsbFJlY29yZFtdID0gW107XG4gICAgICAgIGxldCB0b3RhbENvdW50ID0gMDtcblxuICAgICAgICBmb3IgKGNvbnN0IFtjbGllbnRLZXksIGNvdW50XSBvZiBjbGllbnRNYXApIHtcbiAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLnBhcnNlQ2xpZW50S2V5KGNsaWVudEtleSk7XG4gICAgICAgICAgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xpZW50Q2FsbHMucHVzaCh7IGNsaWVudCwgY291bnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsQ291bnQgKz0gY291bnQ7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgY2xpZW50IHN1bW1hcnlcbiAgICAgICAgICBpZiAoY2xpZW50S2V5ID09PSAnX19ub19jbGllbnRfXycpIHtcbiAgICAgICAgICAgIHVuaWRlbnRpZmllZENhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNsaWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZpY2VDYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb29yZGluYXRlQ2FsbFJlY29yZHMucHVzaCh7XG4gICAgICAgICAga3RhOiBrdGFLZXkuc3BsaXQoJy4nKSxcbiAgICAgICAgICBzY29wZXM6IHRoaXMucGFyc2VTY29wZUtleShzY29wZUtleSksXG4gICAgICAgICAgY291bnQ6IHRvdGFsQ291bnQsXG4gICAgICAgICAgY2xpZW50Q2FsbHM6IFsuLi5jbGllbnRDYWxsc10gLy8gUmV0dXJuIGEgY29weVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxHZXRDYWxsczogdGhpcy50b3RhbENhbGxzLFxuICAgICAgY29vcmRpbmF0ZUNhbGxSZWNvcmRzOiBbLi4uY29vcmRpbmF0ZUNhbGxSZWNvcmRzXSwgLy8gUmV0dXJuIGEgY29weVxuICAgICAgY2xpZW50U3VtbWFyeToge1xuICAgICAgICBzZXJ2aWNlQ2FsbHMsXG4gICAgICAgIGFwcGxpY2F0aW9uQ2FsbHMsXG4gICAgICAgIHVuaWRlbnRpZmllZENhbGxzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGwgY291bnQgZm9yIGEgc3BlY2lmaWMgY29vcmRpbmF0ZSBjb21iaW5hdGlvblxuICAgKi9cbiAgZ2V0Q2FsbENvdW50KGt0YTogc3RyaW5nW10sIHNjb3Blcz86IHN0cmluZ1tdKTogbnVtYmVyIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbignLicpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuXG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcblxuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgaWYgKCFjbGllbnRNYXApIHJldHVybiAwO1xuXG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IGNvdW50IG9mIGNsaWVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgdG90YWwgKz0gY291bnQ7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGwgY291bnQgZm9yIGEgc3BlY2lmaWMgY29vcmRpbmF0ZSBjb21iaW5hdGlvbiBmcm9tIGEgc3BlY2lmaWMgY2xpZW50XG4gICAqL1xuICBnZXRDYWxsQ291bnRCeUNsaWVudChrdGE6IHN0cmluZ1tdLCBzY29wZXM/OiBzdHJpbmdbXSwgY2xpZW50PzogQ2xpZW50SWRlbnRpZmllcik6IG51bWJlciB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oJy4nKTtcbiAgICBjb25zdCBzY29wZUtleSA9IHRoaXMuY3JlYXRlU2NvcGVLZXkoc2NvcGVzIHx8IFtdKTtcbiAgICBjb25zdCBjbGllbnRLZXkgPSB0aGlzLmNyZWF0ZUNsaWVudEtleShjbGllbnQpO1xuXG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcblxuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgaWYgKCFjbGllbnRNYXApIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIGNsaWVudE1hcC5nZXQoY2xpZW50S2V5KSB8fCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdG90YWwgY2FsbHMgZm9yIGEgc3BlY2lmaWMga3RhIChhY3Jvc3MgYWxsIHNjb3BlcylcbiAgICovXG4gIGdldFRvdGFsQ2FsbHNGb3JLdGEoa3RhOiBzdHJpbmdbXSk6IG51bWJlciB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oJy4nKTtcbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuXG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IGNsaWVudE1hcCBvZiBzY29wZU1hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjb3VudCBvZiBjbGllbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgdG90YWwgKz0gY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB1bmlxdWUga3RhIHBhdGhzIHRoYXQgaGF2ZSBiZWVuIGNhbGxlZFxuICAgKi9cbiAgZ2V0Q2FsbGVkS3RhUGF0aHMoKTogc3RyaW5nW11bXSB7XG4gICAgY29uc3Qga3RhUGF0aHM6IHN0cmluZ1tdW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGt0YUtleSBvZiB0aGlzLmNvb3JkaW5hdGVDYWxscy5rZXlzKCkpIHtcbiAgICAgIGt0YVBhdGhzLnB1c2goa3RhS2V5LnNwbGl0KCcuJykpO1xuICAgIH1cbiAgICByZXR1cm4ga3RhUGF0aHM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5vcm1hbGl6ZWQgc2NvcGUga2V5IGZyb20gc2NvcGVzIGFycmF5XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVNjb3BlS2V5KHNjb3Blczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGlmIChzY29wZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ19fbm9fc2NvcGVzX18nO1xuICAgIHJldHVybiBbLi4uc2NvcGVzXS5zb3J0KCkuam9pbignLCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNjb3BlIGtleSBiYWNrIHRvIHNjb3BlcyBhcnJheVxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZVNjb3BlS2V5KHNjb3BlS2V5OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgaWYgKHNjb3BlS2V5ID09PSAnX19ub19zY29wZXNfXycpIHJldHVybiBbXTtcbiAgICByZXR1cm4gc2NvcGVLZXkuc3BsaXQoJywnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9ybWFsaXplZCBjbGllbnQga2V5IGZyb20gY2xpZW50IGlkZW50aWZpZXJcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQ2xpZW50S2V5KGNsaWVudD86IENsaWVudElkZW50aWZpZXIpOiBzdHJpbmcge1xuICAgIGlmICghY2xpZW50KSByZXR1cm4gJ19fbm9fY2xpZW50X18nO1xuXG4gICAgaWYgKHR5cGVvZiBjbGllbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYGFwcDoke2NsaWVudH1gO1xuICAgIH1cblxuICAgIC8vIFNlcnZpY2UgY2xpZW50XG4gICAgY29uc3QgY29vcmRLZXkgPSBgJHtjbGllbnQuY29vcmRpbmF0ZS5rdGEuam9pbignLicpfTske3RoaXMuY3JlYXRlU2NvcGVLZXkoY2xpZW50LmNvb3JkaW5hdGUuc2NvcGVzKX1gO1xuICAgIHJldHVybiBgc2VydmljZToke2NsaWVudC5yZWdpc3RyeVR5cGV9OiR7Y29vcmRLZXl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBjbGllbnQga2V5IGJhY2sgdG8gY2xpZW50IGlkZW50aWZpZXJcbiAgICovXG4gIHByaXZhdGUgcGFyc2VDbGllbnRLZXkoY2xpZW50S2V5OiBzdHJpbmcpOiBDbGllbnRJZGVudGlmaWVyIHwgbnVsbCB7XG4gICAgaWYgKGNsaWVudEtleSA9PT0gJ19fbm9fY2xpZW50X18nKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChjbGllbnRLZXkuc3RhcnRzV2l0aCgnYXBwOicpKSB7XG4gICAgICByZXR1cm4gY2xpZW50S2V5LnN1YnN0cmluZyg0KTtcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50S2V5LnN0YXJ0c1dpdGgoJ3NlcnZpY2U6JykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gY2xpZW50S2V5LnN1YnN0cmluZyg4KS5zcGxpdCgnOicpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IHJlZ2lzdHJ5VHlwZSA9IHBhcnRzWzBdO1xuICAgICAgY29uc3QgY29vcmRQYXJ0cyA9IHBhcnRzWzFdLnNwbGl0KCc7Jyk7XG4gICAgICBpZiAoY29vcmRQYXJ0cy5sZW5ndGggIT09IDIpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBrdGEgPSBjb29yZFBhcnRzWzBdLnNwbGl0KCcuJyk7XG4gICAgICBjb25zdCBzY29wZXMgPSB0aGlzLnBhcnNlU2NvcGVLZXkoY29vcmRQYXJ0c1sxXSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgICAgY29vcmRpbmF0ZTogeyBrdGEsIHNjb3BlcyB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgSW5zdGFuY2UsIGlzSW5zdGFuY2UgfSBmcm9tICcuL0luc3RhbmNlJztcbmltcG9ydCB7IENvb3JkaW5hdGUsIGNyZWF0ZUNvb3JkaW5hdGUgfSBmcm9tICcuL0Nvb3JkaW5hdGUnO1xuaW1wb3J0IHsgQWxsSXRlbVR5cGVBcnJheXMgfSBmcm9tICdAZmplbGwvY29yZSc7XG5pbXBvcnQge1xuICBJbnN0YW5jZUZhY3RvcnksXG4gIEluc3RhbmNlVHJlZSxcbiAgUmVnaXN0cnksXG4gIFJlZ2lzdHJ5SHViLFxuICBTY29wZWRJbnN0YW5jZVxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IENsaWVudElkZW50aWZpZXIsIFJlZ2lzdHJ5U3RhdGlzdGljcywgUmVnaXN0cnlTdGF0cywgU2VydmljZUNsaWVudCB9IGZyb20gJy4vUmVnaXN0cnlTdGF0cyc7XG5cbi8vIFJlLWV4cG9ydCB0eXBlcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0IHR5cGUgeyBSZWdpc3RyeSwgUmVnaXN0cnlIdWIsIEluc3RhbmNlRmFjdG9yeSwgUmVnaXN0cnlGYWN0b3J5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJSZWdpc3RyeVwiKTtcblxuY29uc3QgZmluZFNjb3BlZEluc3RhbmNlID0gKFxuICBzY29wZWRJbnN0YW5jZXM6IFNjb3BlZEluc3RhbmNlW10sXG4gIHJlcXVlc3RlZFNjb3Blcz86IHN0cmluZ1tdLFxuXG4pOiBJbnN0YW5jZTxhbnksIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlcj4gPT4ge1xuICBpZiAoIXJlcXVlc3RlZFNjb3BlcyB8fCByZXF1ZXN0ZWRTY29wZXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gUmV0dXJuIGZpcnN0IGluc3RhbmNlIGlmIG5vIHNjb3BlcyBzcGVjaWZpZWRcbiAgICBjb25zdCBmaXJzdEluc3RhbmNlID0gc2NvcGVkSW5zdGFuY2VzWzBdPy5pbnN0YW5jZTtcbiAgICBpZiAoIWZpcnN0SW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5zdGFuY2VzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RJbnN0YW5jZTtcbiAgfVxuXG4gIC8vIEZpbmQgaW5zdGFuY2UgdGhhdCBtYXRjaGVzIGFsbCByZXF1ZXN0ZWQgc2NvcGVzXG4gIGNvbnN0IG1hdGNoaW5nSW5zdGFuY2UgPSBzY29wZWRJbnN0YW5jZXMuZmluZChzY29wZWRJbnN0YW5jZSA9PiB7XG4gICAgaWYgKCFzY29wZWRJbnN0YW5jZS5zY29wZXMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVxdWVzdGVkU2NvcGVzLmV2ZXJ5KHNjb3BlID0+XG4gICAgICBzY29wZWRJbnN0YW5jZS5zY29wZXMgJiYgc2NvcGVkSW5zdGFuY2Uuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKVxuICAgICk7XG4gIH0pO1xuXG4gIGlmICghbWF0Y2hpbmdJbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5zdGFuY2UgZm91bmQgbWF0Y2hpbmcgc2NvcGVzOiAke3JlcXVlc3RlZFNjb3Blcy5qb2luKCcsICcpfWApO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoaW5nSW5zdGFuY2UuaW5zdGFuY2U7XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWdpc3RyeSA9ICh0eXBlOiBzdHJpbmcsIHJlZ2lzdHJ5SHViPzogUmVnaXN0cnlIdWIpOiBSZWdpc3RyeSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlVHJlZTogSW5zdGFuY2VUcmVlID0ge307XG5cbiAgLy8gU3RhdGlzdGljcyB0cmFja2luZ1xuICBjb25zdCByZWdpc3RyeVN0YXRzID0gbmV3IFJlZ2lzdHJ5U3RhdHMoKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHByb3hpZWQgUmVnaXN0cnkgdGhhdCBhdXRvbWF0aWNhbGx5IGluamVjdHMgY2xpZW50IGluZm9ybWF0aW9uIGZvciBzZXJ2aWNlLXRvLXNlcnZpY2UgY2FsbHNcbiAgICovXG4gIGNvbnN0IGNyZWF0ZVByb3hpZWRSZWdpc3RyeSA9IChjYWxsaW5nQ29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxhbnksIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlcj4pOiBSZWdpc3RyeSA9PiB7XG4gICAgY29uc3Qgc2VydmljZUNsaWVudDogU2VydmljZUNsaWVudCA9IHtcbiAgICAgIHJlZ2lzdHJ5VHlwZTogdHlwZSxcbiAgICAgIGNvb3JkaW5hdGU6IHtcbiAgICAgICAga3RhOiBjYWxsaW5nQ29vcmRpbmF0ZS5rdGEsXG4gICAgICAgIHNjb3BlczogY2FsbGluZ0Nvb3JkaW5hdGUuc2NvcGVzXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZWdpc3RyeSxcbiAgICAgIGdldDogPFxuICAgICAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgICAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgICAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgICAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgICAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgICAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgICAgPihrdGE6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIG9wdGlvbnM/OiB7IHNjb3Blcz86IHN0cmluZ1tdOyBjbGllbnQ/OiBDbGllbnRJZGVudGlmaWVyIH0pOiBJbnN0YW5jZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbCA9PiB7XG4gICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgaW5qZWN0IHRoZSBjYWxsaW5nIHNlcnZpY2UgYXMgdGhlIGNsaWVudCBpZiBubyBjbGllbnQgaXMgc3BlY2lmaWVkXG4gICAgICAgIGNvbnN0IGNsaWVudFRvVXNlID0gb3B0aW9ucz8uY2xpZW50IHx8IHNlcnZpY2VDbGllbnQ7XG4gICAgICAgIHJldHVybiByZWdpc3RyeS5nZXQoa3RhLCB7IC4uLm9wdGlvbnMsIGNsaWVudDogY2xpZW50VG9Vc2UgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBjcmVhdGVJbnN0YW5jZSA9IDxcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgPihcbiAgICBrdGE6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgc2NvcGVzOiBzdHJpbmdbXSxcbiAgICBmYWN0b3J5OiBJbnN0YW5jZUZhY3Rvcnk8UywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBJbnN0YW5jZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgICBsb2dnZXIuZGVidWcoYENyZWF0aW5nIGFuZCByZWdpc3RlcmluZyBpbnN0YW5jZSBmb3Iga2V5IHBhdGggYW5kIHNjb3Blc2AsIGt0YSwgc2NvcGVzLCBgaW4gcmVnaXN0cnkgdHlwZTogJHt0eXBlfWApO1xuXG4gICAgLy8gQ3JlYXRlIGNvb3JkaW5hdGUgZm9yIHRoZSBpbnN0YW5jZVxuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSBjcmVhdGVDb29yZGluYXRlKGt0YSBhcyBhbnksIHNjb3Blcyk7XG5cbiAgICAvLyBDcmVhdGUgYSBwcm94aWVkIHJlZ2lzdHJ5IHRoYXQgYXV0b21hdGljYWxseSB0cmFja3MgdGhpcyBzZXJ2aWNlIGFzIHRoZSBjbGllbnRcbiAgICBjb25zdCBwcm94aWVkUmVnaXN0cnkgPSBjcmVhdGVQcm94aWVkUmVnaXN0cnkoY29vcmRpbmF0ZSk7XG5cbiAgICAvLyBVc2UgZmFjdG9yeSB0byBjcmVhdGUgdGhlIGluc3RhbmNlIHdpdGggdGhlIHByb3hpZWQgcmVnaXN0cnlcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZhY3RvcnkoY29vcmRpbmF0ZSwge1xuICAgICAgcmVnaXN0cnk6IHByb3hpZWRSZWdpc3RyeSxcbiAgICAgIHJlZ2lzdHJ5SHViLFxuICAgIH0pO1xuXG4gICAgLy8gVmFsaWRhdGUgdGhlIGNyZWF0ZWQgaW5zdGFuY2VcbiAgICBpZiAoIWlzSW5zdGFuY2UoaW5zdGFuY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhY3RvcnkgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBmb3I6ICR7a3RhLmpvaW4oJy4nKX1gKTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgaW5zdGFuY2VcbiAgICByZWdpc3RlckludGVybmFsKGt0YSwgaW5zdGFuY2UsIHsgc2NvcGVzIH0pO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGNvbnN0IHJlZ2lzdGVySW50ZXJuYWwgPSA8XG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gID4oa3RhOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBpbnN0YW5jZTogSW5zdGFuY2U8UywgTDEsIEwyLCBMMywgTDQsIEw1Piwgb3B0aW9ucz86IHsgc2NvcGVzPzogc3RyaW5nW10gfSk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGtleVBhdGggPSBbLi4ua3RhXS5yZXZlcnNlKCk7IC8vIFdvcmsgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0IHNwZWNpZmljXG4gICAgbGV0IGN1cnJlbnRMZXZlbCA9IGluc3RhbmNlVHJlZTtcblxuICAgIGxvZ2dlci5kZWJ1ZyhgUmVnaXN0ZXJpbmcgaW5zdGFuY2UgZm9yIGtleSBwYXRoIGFuZCBzY29wZXNgLCBrZXlQYXRoLCBvcHRpb25zPy5zY29wZXMsIGBpbiByZWdpc3RyeSB0eXBlOiAke3R5cGV9YCk7XG5cbiAgICBpZiAoIWlzSW5zdGFuY2UoaW5zdGFuY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBub24taW5zdGFuY2U6ICR7a3RhLmpvaW4oJy4nKX1gKTtcbiAgICB9XG5cbiAgICAvLyBOYXZpZ2F0ZSB0byB0aGUgY29ycmVjdCBsb2NhdGlvbiBpbiB0aGUgdHJlZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5VHlwZSA9IGtleVBhdGhbaV07XG4gICAgICBjb25zdCBpc0xlYWYgPSBpID09PSBrZXlQYXRoLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXSA9IHtcbiAgICAgICAgICBpbnN0YW5jZXM6IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBpc0xlYWYgPyBudWxsIDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICAvLyBBZGQgaW5zdGFuY2UgdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0uaW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgIHNjb3Blczogb3B0aW9ucz8uc2NvcGVzLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTmF2aWdhdGUgZGVlcGVyIGludG8gdGhlIHRyZWVcbiAgICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4hO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCByZWdpc3RlciA9IDxcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgPihrdGE6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIGluc3RhbmNlOiBJbnN0YW5jZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBvcHRpb25zPzogeyBzY29wZXM/OiBzdHJpbmdbXSB9KTogdm9pZCA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdVc2luZyBkZXByZWNhdGVkIHJlZ2lzdGVyIG1ldGhvZC4gQ29uc2lkZXIgdXNpbmcgY3JlYXRlSW5zdGFuY2UgaW5zdGVhZC4nKTtcbiAgICByZWdpc3RlckludGVybmFsKGt0YSwgaW5zdGFuY2UsIG9wdGlvbnMpO1xuICB9O1xuXG4gIGNvbnN0IGdldCA9IDxcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgPihrdGE6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIG9wdGlvbnM/OiB7IHNjb3Blcz86IHN0cmluZ1tdOyBjbGllbnQ/OiBDbGllbnRJZGVudGlmaWVyIH0pOiBJbnN0YW5jZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbCA9PiB7XG4gICAgLy8gVHJhY2sgc3RhdGlzdGljcyB3aXRoIGt0YSwgc2NvcGVzLCBhbmQgY2xpZW50XG4gICAgcmVnaXN0cnlTdGF0cy5yZWNvcmRHZXRDYWxsKGt0YSwgb3B0aW9ucz8uc2NvcGVzLCBvcHRpb25zPy5jbGllbnQpO1xuXG4gICAgY29uc3Qga2V5UGF0aCA9IFsuLi5rdGFdLnJldmVyc2UoKTtcbiAgICBsZXQgY3VycmVudExldmVsID0gaW5zdGFuY2VUcmVlO1xuXG4gICAgLy8gTmF2aWdhdGUgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlUeXBlID0ga2V5UGF0aFtpXTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGkgPT09IGtleVBhdGgubGVuZ3RoIC0gMTtcblxuICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKCcuJyl9LCBNaXNzaW5nIGtleTogJHtrZXlUeXBlfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIC8vIEZvdW5kIHRoZSB0YXJnZXQgbm9kZSwgZXh0cmFjdCBpbnN0YW5jZVxuICAgICAgICBjb25zdCBzY29wZWRJbnN0YW5jZXMgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uaW5zdGFuY2VzO1xuXG4gICAgICAgIGlmIChzY29wZWRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnN0YW5jZXMgcmVnaXN0ZXJlZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oJy4nKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaW5kU2NvcGVkSW5zdGFuY2Uoc2NvcGVkSW5zdGFuY2VzLCBvcHRpb25zPy5zY29wZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29udGludWUgbmF2aWdhdGlvblxuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbignLicpfSwgTm8gY2hpbGRyZW4gZm9yOiAke2tleVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuITtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBjb25zdCBnZXRDb29yZGluYXRlcyA9ICgpOiBDb29yZGluYXRlPGFueSwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyPltdID0+IHtcbiAgICBjb25zdCBjb29yZGluYXRlczogQ29vcmRpbmF0ZTxhbnksIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlcj5bXSA9IFtdO1xuXG4gICAgY29uc3QgdHJhdmVyc2VUcmVlID0gKG5vZGU6IEluc3RhbmNlVHJlZSk6IHZvaWQgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXlUeXBlIGluIG5vZGUpIHtcbiAgICAgICAgY29uc3QgdHJlZU5vZGUgPSBub2RlW2tleVR5cGVdO1xuXG4gICAgICAgIC8vIENvbGxlY3QgY29vcmRpbmF0ZXMgZnJvbSBpbnN0YW5jZXMgYXQgdGhpcyBsZXZlbFxuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlZEluc3RhbmNlIG9mIHRyZWVOb2RlLmluc3RhbmNlcykge1xuICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goc2NvcGVkSW5zdGFuY2UuaW5zdGFuY2UuY29vcmRpbmF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSBjaGlsZHJlbiBpZiB0aGV5IGV4aXN0XG4gICAgICAgIGlmICh0cmVlTm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIHRyYXZlcnNlVHJlZSh0cmVlTm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJhdmVyc2VUcmVlKGluc3RhbmNlVHJlZSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9O1xuXG4gIGNvbnN0IGdldFN0YXRpc3RpY3MgPSAoKTogUmVnaXN0cnlTdGF0aXN0aWNzID0+IHtcbiAgICByZXR1cm4gcmVnaXN0cnlTdGF0cy5nZXRTdGF0aXN0aWNzKCk7XG4gIH07XG5cbiAgY29uc3QgcmVnaXN0cnk6IFJlZ2lzdHJ5ID0ge1xuICAgIHR5cGUsXG4gICAgcmVnaXN0cnlIdWIsXG4gICAgY3JlYXRlSW5zdGFuY2UsXG4gICAgcmVnaXN0ZXIsXG4gICAgZ2V0LFxuICAgIGdldENvb3JkaW5hdGVzLFxuICAgIGdldFN0YXRpc3RpY3MsXG4gICAgaW5zdGFuY2VUcmVlLFxuICB9O1xuXG4gIHJldHVybiByZWdpc3RyeTtcbn1cbiIsIi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIHJlZ2lzdHJ5LXJlbGF0ZWQgZXJyb3JzXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWdpc3RyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgcmVnaXN0cnlUeXBlPzogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT47XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCByZWdpc3RyeVR5cGU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMucmVnaXN0cnlUeXBlID0gcmVnaXN0cnlUeXBlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAoTm9kZS5qcyBzcGVjaWZpYylcbiAgICBjb25zdCBFcnJvckNvbnN0cnVjdG9yID0gRXJyb3IgYXMgYW55O1xuICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3Rvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgRXJyb3JDb25zdHJ1Y3Rvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RGV0YWlscygpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRldGFpbHM6IHN0cmluZ1tdID0gW3RoaXMubWVzc2FnZV07XG5cbiAgICBpZiAodGhpcy5yZWdpc3RyeVR5cGUpIHtcbiAgICAgIGRldGFpbHMucHVzaChgUmVnaXN0cnkgVHlwZTogJHt0aGlzLnJlZ2lzdHJ5VHlwZX1gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBkZXRhaWxzLnB1c2goYENvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jb250ZXh0LCBudWxsLCAyKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGV0YWlscy5qb2luKCdcXG4nKTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgcmVnaXN0cnkgd2l0aCBpbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lzdHJ5Q3JlYXRpb25FcnJvciBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKGBGYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJ5IG9mIHR5cGUgJyR7dHlwZX0nOiAke3JlYXNvbn1gLCB0eXBlLCBjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGEgZmFjdG9yeSBmdW5jdGlvbiByZXR1cm5zIGFuIGludmFsaWQgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRGYWN0b3J5UmVzdWx0RXJyb3IgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGtleVBhdGg6IHN0cmluZ1tdO1xuICBwdWJsaWMgcmVhZG9ubHkgZmFjdG9yeVJlc3VsdDogYW55O1xuXG4gIGNvbnN0cnVjdG9yKGtleVBhdGg6IHN0cmluZ1tdLCBmYWN0b3J5UmVzdWx0OiBhbnksIHJlZ2lzdHJ5VHlwZT86IHN0cmluZykge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oJy4nKTtcbiAgICBzdXBlcihcbiAgICAgIGBGYWN0b3J5IGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2UgZm9yOiAke2tleVBhdGhTdHJ9LiBgICtcbiAgICAgIGBFeHBlY3RlZCBpbnN0YW5jZSB3aXRoICdjb29yZGluYXRlJyBhbmQgJ3JlZ2lzdHJ5JyBwcm9wZXJ0aWVzLCBnb3Q6ICR7dHlwZW9mIGZhY3RvcnlSZXN1bHR9YCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsga2V5UGF0aCwgZmFjdG9yeVJlc3VsdDogdHlwZW9mIGZhY3RvcnlSZXN1bHQgfVxuICAgICk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICB0aGlzLmZhY3RvcnlSZXN1bHQgPSBmYWN0b3J5UmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byByZWdpc3RlciBhIG5vbi1pbnN0YW5jZSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnN0YW5jZVJlZ2lzdHJhdGlvbkVycm9yIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBrZXlQYXRoOiBzdHJpbmdbXTtcbiAgcHVibGljIHJlYWRvbmx5IGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjogYW55O1xuXG4gIGNvbnN0cnVjdG9yKGtleVBhdGg6IHN0cmluZ1tdLCBhdHRlbXB0ZWRSZWdpc3RyYXRpb246IGFueSwgcmVnaXN0cnlUeXBlPzogc3RyaW5nKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbignLicpO1xuICAgIHN1cGVyKFxuICAgICAgYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBub24taW5zdGFuY2U6ICR7a2V5UGF0aFN0cn0uIGAgK1xuICAgICAgYEV4cGVjdGVkIGluc3RhbmNlIHdpdGggJ2Nvb3JkaW5hdGUnIGFuZCAncmVnaXN0cnknIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgYXR0ZW1wdGVkUmVnaXN0cmF0aW9ufWAsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IGtleVBhdGgsIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjogdHlwZW9mIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbiB9XG4gICAgKTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaXN0cmF0aW9uID0gYXR0ZW1wdGVkUmVnaXN0cmF0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQgeyBSZWdpc3RyeUVycm9yIH0gZnJvbSAnLi9SZWdpc3RyeUVycm9yJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciByZWdpc3RyeSBodWItcmVsYXRlZCBlcnJvcnNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlZ2lzdHJ5SHViRXJyb3IgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGh1YlR5cGU/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBodWJUeXBlPzogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGNvbnN0IGVucmljaGVkQ29udGV4dCA9IGh1YlR5cGUgPyB7IC4uLmNvbnRleHQsIGh1YlR5cGUgfSA6IGNvbnRleHQ7XG4gICAgc3VwZXIobWVzc2FnZSwgJycsIGVucmljaGVkQ29udGV4dCk7XG4gICAgdGhpcy5odWJUeXBlID0gaHViVHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSByZWdpc3RyeSB3aXRoIGEgdHlwZSB0aGF0IGFscmVhZHkgZXhpc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvciBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgZHVwbGljYXRlVHlwZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBhbHJlYWR5IHJlZ2lzdGVyZWQgdW5kZXIgdHlwZTogJHt0eXBlfS4gYCArXG4gICAgICBgRWFjaCByZWdpc3RyeSB0eXBlIG11c3QgYmUgdW5pcXVlIHdpdGhpbiBhIHJlZ2lzdHJ5IGh1Yi5gLFxuICAgICAgJycsXG4gICAgICB7IC4uLmNvbnRleHQsIGR1cGxpY2F0ZVR5cGU6IHR5cGUgfVxuICAgICk7XG4gICAgdGhpcy5kdXBsaWNhdGVUeXBlID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGEgcmVnaXN0cnkgdHlwZSB0aGF0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVlc3RlZFR5cGU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGF2YWlsYWJsZVR5cGVzOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcihyZXF1ZXN0ZWRUeXBlOiBzdHJpbmcsIGF2YWlsYWJsZVR5cGVzOiBzdHJpbmdbXSA9IFtdLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGxldCBtZXNzYWdlID0gYE5vIHJlZ2lzdHJ5IHJlZ2lzdGVyZWQgdW5kZXIgdHlwZTogJHtyZXF1ZXN0ZWRUeXBlfWA7XG4gICAgaWYgKGF2YWlsYWJsZVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2UgKz0gYC4gQXZhaWxhYmxlIHR5cGVzOiBbJHthdmFpbGFibGVUeXBlcy5qb2luKCcsICcpfV1gO1xuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UsICcnLCB7IC4uLmNvbnRleHQsIHJlcXVlc3RlZFR5cGUsIGF2YWlsYWJsZVR5cGVzIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkVHlwZSA9IHJlcXVlc3RlZFR5cGU7XG4gICAgdGhpcy5hdmFpbGFibGVUeXBlcyA9IGF2YWlsYWJsZVR5cGVzO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSByZWdpc3RyeSBmYWN0b3J5IGZ1bmN0aW9uIGZhaWxzIHRvIGNyZWF0ZSBhIHZhbGlkIHJlZ2lzdHJ5XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeUZhY3RvcnlFcnJvciBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgZmFjdG9yeUVycm9yOiBFcnJvcjtcbiAgcHVibGljIHJlYWRvbmx5IGF0dGVtcHRlZFR5cGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIGZhY3RvcnlFcnJvcjogRXJyb3IsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVnaXN0cnkgZmFjdG9yeSBmYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJ5IG9mIHR5cGUgJyR7dHlwZX0nOiAke2ZhY3RvcnlFcnJvci5tZXNzYWdlfWAsXG4gICAgICAnJyxcbiAgICAgIHsgLi4uY29udGV4dCwgYXR0ZW1wdGVkVHlwZTogdHlwZSwgb3JpZ2luYWxFcnJvcjogZmFjdG9yeUVycm9yLm1lc3NhZ2UgfVxuICAgICk7XG4gICAgdGhpcy5mYWN0b3J5RXJyb3IgPSBmYWN0b3J5RXJyb3I7XG4gICAgdGhpcy5hdHRlbXB0ZWRUeXBlID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGEgZmFjdG9yeSByZXR1cm5zIGFuIGludmFsaWQgcmVnaXN0cnkgb2JqZWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUmVnaXN0cnlGYWN0b3J5UmVzdWx0RXJyb3IgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGZhY3RvcnlSZXN1bHQ6IGFueTtcbiAgcHVibGljIHJlYWRvbmx5IGF0dGVtcHRlZFR5cGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIGZhY3RvcnlSZXN1bHQ6IGFueSwgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBmYWN0b3J5IHJldHVybmVkIGludmFsaWQgcmVnaXN0cnkgZm9yIHR5cGUgJyR7dHlwZX0nLiBgICtcbiAgICAgIGBFeHBlY3RlZCByZWdpc3RyeSB3aXRoICd0eXBlJywgJ2dldCcsICdyZWdpc3RlcicsIGFuZCAnY3JlYXRlSW5zdGFuY2UnIHByb3BlcnRpZXMsIGAgK1xuICAgICAgYGdvdDogJHt0eXBlb2YgZmFjdG9yeVJlc3VsdH1gLFxuICAgICAgJycsXG4gICAgICB7IC4uLmNvbnRleHQsIGF0dGVtcHRlZFR5cGU6IHR5cGUsIGZhY3RvcnlSZXN1bHQ6IHR5cGVvZiBmYWN0b3J5UmVzdWx0IH1cbiAgICApO1xuICAgIHRoaXMuZmFjdG9yeVJlc3VsdCA9IGZhY3RvcnlSZXN1bHQ7XG4gICAgdGhpcy5hdHRlbXB0ZWRUeXBlID0gdHlwZTtcbiAgfVxufVxuIiwiXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IENvb3JkaW5hdGVXaXRoUmVnaXN0cnksIFJlZ2lzdHJ5LCBSZWdpc3RyeUZhY3RvcnksIFJlZ2lzdHJ5SHViIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBJbnN0YW5jZSB9IGZyb20gJy4vSW5zdGFuY2UnO1xuaW1wb3J0IHsgQ2xpZW50SWRlbnRpZmllciB9IGZyb20gJy4vUmVnaXN0cnlTdGF0cyc7XG5pbXBvcnQge1xuICBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcixcbiAgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvcixcbn0gZnJvbSAnLi9lcnJvcnMvUmVnaXN0cnlIdWJFcnJvcic7XG5pbXBvcnQgeyBBbGxJdGVtVHlwZUFycmF5cyB9IGZyb20gJ0BmamVsbC9jb3JlJztcblxuLy8gUmUtZXhwb3J0IHR5cGVzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnQgdHlwZSB7IFJlZ2lzdHJ5SHViIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJSZWdpc3RyeUh1YlwiKTtcblxuaW50ZXJmYWNlIFJlZ2lzdHJ5SHViRGF0YSB7XG4gIFt0eXBlOiBzdHJpbmddOiBSZWdpc3RyeTtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZ2lzdHJ5SHViID0gKCk6IFJlZ2lzdHJ5SHViID0+IHtcbiAgY29uc3QgcmVnaXN0cmllczogUmVnaXN0cnlIdWJEYXRhID0ge307XG5cbiAgY29uc3QgY3JlYXRlUmVnaXN0cnkgPSAodHlwZTogc3RyaW5nLCBmYWN0b3J5OiBSZWdpc3RyeUZhY3RvcnkpOiBSZWdpc3RyeSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKGBDcmVhdGluZyBuZXcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG5cbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yKHR5cGUpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVnaXN0cnkgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGlzIGh1YlxuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gZmFjdG9yeSh0eXBlLCBodWIpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBjcmVhdGVkIHJlZ2lzdHJ5IGhhcyBhIHJlZmVyZW5jZSB0byB0aGlzIGh1YiBpZiBub3QgYWxyZWFkeSBzZXRcbiAgICBpZiAoISgncmVnaXN0cnlIdWInIGluIHJlZ2lzdHJ5KSB8fCByZWdpc3RyeS5yZWdpc3RyeUh1YiAhPT0gaHViKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiByZWdpc3RyeUh1YiBpcyBvcHRpb25hbCBhbmQgbWF5IGJlIHJlYWRvbmx5LCBidXQgd2Ugd2FudCB0byBzZXQgaXQgZm9yIGh1YiBhd2FyZW5lc3NcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViID0gaHViO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBjcmVhdGVkIHJlZ2lzdHJ5XG4gICAgcmVnaXN0cmllc1t0eXBlXSA9IHJlZ2lzdHJ5O1xuICAgIGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYW5kIHJlZ2lzdGVyZWQgbmV3IHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuXG4gICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICB9O1xuXG4gIGNvbnN0IHJlZ2lzdGVyUmVnaXN0cnkgPSAocmVnaXN0cnk6IFJlZ2lzdHJ5KTogdm9pZCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHJlZ2lzdHJ5LnR5cGU7XG4gICAgbG9nZ2VyLmRlYnVnKGBSZWdpc3RlcmluZyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcblxuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuXG4gICAgcmVnaXN0cmllc1t0eXBlXSA9IHJlZ2lzdHJ5O1xuXG4gICAgLy8gRW5zdXJlIHRoZSBjcmVhdGVkIHJlZ2lzdHJ5IGhhcyBhIHJlZmVyZW5jZSB0byB0aGlzIGh1YiBpZiBub3QgYWxyZWFkeSBzZXRcbiAgICBpZiAoISgncmVnaXN0cnlIdWInIGluIHJlZ2lzdHJ5KSB8fCByZWdpc3RyeS5yZWdpc3RyeUh1YiAhPT0gaHViKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiByZWdpc3RyeUh1YiBpcyBvcHRpb25hbCBhbmQgbWF5IGJlIHJlYWRvbmx5LCBidXQgd2Ugd2FudCB0byBzZXQgaXQgZm9yIGh1YiBhd2FyZW5lc3NcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViID0gaHViO1xuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gIH07XG5cbiAgY29uc3QgZ2V0ID0gPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICA+KFxuICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAga3RhOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgICAgb3B0aW9ucz86IHsgc2NvcGVzPzogc3RyaW5nW107IGNsaWVudD86IENsaWVudElkZW50aWZpZXIgfSxcbiAgICApOiBJbnN0YW5jZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbCA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKGBMb29raW5nIHVwIGluc3RhbmNlIGZvciB0eXBlOiAke3R5cGV9LCBrdGE6ICR7a3RhLmpvaW4oJy4nKX0sIHNjb3BlczogJHtvcHRpb25zPy5zY29wZXM/LmpvaW4oJywnKSB8fCAnbm9uZSd9YCk7XG5cbiAgICBjb25zdCByZWdpc3RyeSA9IHJlZ2lzdHJpZXNbdHlwZV07XG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgY29uc3QgYXZhaWxhYmxlVHlwZXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyaWVzKTtcbiAgICAgIHRocm93IG5ldyBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yKHR5cGUsIGF2YWlsYWJsZVR5cGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaXN0cnkuZ2V0KGt0YSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgY29uc3QgZ2V0UmVnaXN0cnkgPSAodHlwZTogc3RyaW5nKTogUmVnaXN0cnkgfCBudWxsID0+IHtcbiAgICByZXR1cm4gcmVnaXN0cmllc1t0eXBlXSB8fCBudWxsO1xuICB9O1xuXG4gIGNvbnN0IGdldFJlZ2lzdGVyZWRUeXBlcyA9ICgpOiBzdHJpbmdbXSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdHJpZXMpO1xuICB9O1xuXG4gIGNvbnN0IHVucmVnaXN0ZXJSZWdpc3RyeSA9ICh0eXBlOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgZGVsZXRlIHJlZ2lzdHJpZXNbdHlwZV07XG4gICAgICBsb2dnZXIuZGVidWcoYFVucmVnaXN0ZXJlZCByZWdpc3RyeSB1bmRlciB0eXBlOiAke3R5cGV9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGNvbnN0IGdldEFsbENvb3JkaW5hdGVzID0gKCk6IENvb3JkaW5hdGVXaXRoUmVnaXN0cnlbXSA9PiB7XG4gICAgY29uc3QgYWxsQ29vcmRpbmF0ZXM6IENvb3JkaW5hdGVXaXRoUmVnaXN0cnlbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCByZWdpc3RyeVR5cGUgaW4gcmVnaXN0cmllcykge1xuICAgICAgY29uc3QgcmVnaXN0cnkgPSByZWdpc3RyaWVzW3JlZ2lzdHJ5VHlwZV07XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IHJlZ2lzdHJ5LmdldENvb3JkaW5hdGVzKCk7XG5cbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2goY29vcmRpbmF0ZSA9PiB7XG4gICAgICAgIGFsbENvb3JkaW5hdGVzLnB1c2goe1xuICAgICAgICAgIGNvb3JkaW5hdGUsXG4gICAgICAgICAgcmVnaXN0cnlUeXBlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKGBSZXRyaWV2ZWQgJHthbGxDb29yZGluYXRlcy5sZW5ndGh9IHRvdGFsIGNvb3JkaW5hdGVzIGZyb20gJHtPYmplY3Qua2V5cyhyZWdpc3RyaWVzKS5sZW5ndGh9IHJlZ2lzdHJpZXNgKTtcbiAgICByZXR1cm4gYWxsQ29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgY29uc3QgaHViOiBSZWdpc3RyeUh1YiA9IHtcbiAgICBjcmVhdGVSZWdpc3RyeSxcbiAgICByZWdpc3RlclJlZ2lzdHJ5LFxuICAgIGdldCxcbiAgICBnZXRSZWdpc3RyeSxcbiAgICBnZXRSZWdpc3RlcmVkVHlwZXMsXG4gICAgZ2V0QWxsQ29vcmRpbmF0ZXMsXG4gICAgdW5yZWdpc3RlclJlZ2lzdHJ5LFxuICB9IGFzIHVua25vd24gYXMgUmVnaXN0cnlIdWI7XG5cbiAgcmV0dXJuIGh1Yjtcbn07XG4iLCJpbXBvcnQgeyBSZWdpc3RyeUVycm9yIH0gZnJvbSAnLi9SZWdpc3RyeUVycm9yJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBpbnN0YW5jZS1yZWxhdGVkIGVycm9yc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5zdGFuY2VFcnJvciBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkga2V5UGF0aDogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBrZXlQYXRoOiBzdHJpbmdbXSwgcmVnaXN0cnlUeXBlPzogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHJlZ2lzdHJ5VHlwZSwgeyAuLi5jb250ZXh0LCBrZXlQYXRoIH0pO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhbiBpbnN0YW5jZSBjYW5ub3QgYmUgZm91bmQgZm9yIGEgZ2l2ZW4ga2V5IHBhdGhcbiAqL1xuZXhwb3J0IGNsYXNzIEluc3RhbmNlTm90Rm91bmRFcnJvciBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgbWlzc2luZ0tleT86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihrZXlQYXRoOiBzdHJpbmdbXSwgbWlzc2luZ0tleT86IHN0cmluZywgcmVnaXN0cnlUeXBlPzogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oJy4nKTtcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9YDtcblxuICAgIGlmIChtaXNzaW5nS2V5KSB7XG4gICAgICBtZXNzYWdlICs9IGAsIE1pc3Npbmcga2V5OiAke21pc3NpbmdLZXl9YDtcbiAgICB9XG5cbiAgICBzdXBlcihtZXNzYWdlLCBrZXlQYXRoLCByZWdpc3RyeVR5cGUsIHsgLi4uY29udGV4dCwgbWlzc2luZ0tleSB9KTtcbiAgICB0aGlzLm1pc3NpbmdLZXkgPSBtaXNzaW5nS2V5O1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gbm8gaW5zdGFuY2VzIGFyZSByZWdpc3RlcmVkIGZvciBhIGtleSBwYXRoIHRoYXQgZXhpc3RzIGluIHRoZSB0cmVlXG4gKi9cbmV4cG9ydCBjbGFzcyBOb0luc3RhbmNlc1JlZ2lzdGVyZWRFcnJvciBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoOiBzdHJpbmdbXSwgcmVnaXN0cnlUeXBlPzogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oJy4nKTtcbiAgICBzdXBlcihcbiAgICAgIGBObyBpbnN0YW5jZXMgcmVnaXN0ZXJlZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0uIGAgK1xuICAgICAgYFRoZSBrZXkgcGF0aCBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5IHRyZWUgYnV0IGNvbnRhaW5zIG5vIGluc3RhbmNlcy5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gbm8gaW5zdGFuY2VzIGFyZSBhdmFpbGFibGUgKGVtcHR5IGluc3RhbmNlcyBhcnJheSlcbiAqL1xuZXhwb3J0IGNsYXNzIE5vSW5zdGFuY2VzQXZhaWxhYmxlRXJyb3IgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aDogc3RyaW5nW10sIHJlZ2lzdHJ5VHlwZT86IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKCcuJyk7XG4gICAgc3VwZXIoXG4gICAgICBgTm8gaW5zdGFuY2VzIGF2YWlsYWJsZSBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0uIGAgK1xuICAgICAgYFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyBhbiBpbnRlcm5hbCByZWdpc3RyeSBzdGF0ZSBpc3N1ZS5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gbm8gaW5zdGFuY2UgbWF0Y2hlcyB0aGUgcmVxdWVzdGVkIHNjb3Blc1xuICovXG5leHBvcnQgY2xhc3MgU2NvcGVOb3RGb3VuZEVycm9yIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1ZXN0ZWRTY29wZXM6IHN0cmluZ1tdO1xuICBwdWJsaWMgcmVhZG9ubHkgYXZhaWxhYmxlU2NvcGVzOiBzdHJpbmdbXVtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGtleVBhdGg6IHN0cmluZ1tdLFxuICAgIHJlcXVlc3RlZFNjb3Blczogc3RyaW5nW10sXG4gICAgYXZhaWxhYmxlU2NvcGVzOiBzdHJpbmdbXVtdID0gW10sXG4gICAgcmVnaXN0cnlUeXBlPzogc3RyaW5nXG4gICkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oJy4nKTtcbiAgICBjb25zdCBzY29wZXNTdHIgPSByZXF1ZXN0ZWRTY29wZXMuam9pbignLCAnKTtcbiAgICBjb25zdCBhdmFpbGFibGVTY29wZXNTdHIgPSBhdmFpbGFibGVTY29wZXMubWFwKHNjb3BlcyA9PiBgWyR7c2NvcGVzLmpvaW4oJywgJyl9XWApLmpvaW4oJywgJyk7XG5cbiAgICBsZXQgbWVzc2FnZSA9IGBObyBpbnN0YW5jZSBmb3VuZCBtYXRjaGluZyBzY29wZXM6ICR7c2NvcGVzU3RyfSBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn1gO1xuICAgIGlmIChhdmFpbGFibGVTY29wZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZSArPSBgLiBBdmFpbGFibGUgc2NvcGVzOiAke2F2YWlsYWJsZVNjb3Blc1N0cn1gO1xuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgeyByZXF1ZXN0ZWRTY29wZXMsIGF2YWlsYWJsZVNjb3BlcyB9KTtcbiAgICB0aGlzLnJlcXVlc3RlZFNjb3BlcyA9IHJlcXVlc3RlZFNjb3BlcztcbiAgICB0aGlzLmF2YWlsYWJsZVNjb3BlcyA9IGF2YWlsYWJsZVNjb3BlcztcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGEga2V5IHBhdGggaGFzIG5vIGNoaWxkcmVuIGJ1dCBjaGlsZHJlbiBhcmUgZXhwZWN0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIE5vQ2hpbGRyZW5BdmFpbGFibGVFcnJvciBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgcGFyZW50S2V5OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioa2V5UGF0aDogc3RyaW5nW10sIHBhcmVudEtleTogc3RyaW5nLCByZWdpc3RyeVR5cGU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbignLicpO1xuICAgIHN1cGVyKFxuICAgICAgYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0sIE5vIGNoaWxkcmVuIGZvcjogJHtwYXJlbnRLZXl9LiBgICtcbiAgICAgIGBUaGUgcGF0aCBjYW5ub3QgYmUgdHJhdmVyc2VkIGZ1cnRoZXIgYXMgJyR7cGFyZW50S2V5fScgaGFzIG5vIGNoaWxkIG5vZGVzLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyAuLi5jb250ZXh0LCBwYXJlbnRLZXkgfVxuICAgICk7XG4gICAgdGhpcy5wYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFJlZ2lzdHJ5RXJyb3IgfSBmcm9tICcuL1JlZ2lzdHJ5RXJyb3InO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvb3JkaW5hdGUtcmVsYXRlZCBlcnJvcnNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvb3JkaW5hdGVFcnJvciBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkga3RhPzogYW55O1xuICBwdWJsaWMgcmVhZG9ubHkgc2NvcGVzPzogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBrdGE/OiBhbnksIHNjb3Blcz86IHN0cmluZ1tdLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKG1lc3NhZ2UsICcnLCB7IC4uLmNvbnRleHQsIGt0YSwgc2NvcGVzIH0pO1xuICAgIHRoaXMua3RhID0ga3RhO1xuICAgIHRoaXMuc2NvcGVzID0gc2NvcGVzO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gY29vcmRpbmF0ZSBjcmVhdGlvbiBmYWlscyBkdWUgdG8gaW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ29vcmRpbmF0ZUVycm9yIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa3RhOiBhbnksIHNjb3Blczogc3RyaW5nW10sIHJlYXNvbjogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgY29vcmRpbmF0ZSBwYXJhbWV0ZXJzOiAke3JlYXNvbn0uIGAgK1xuICAgICAgYEtUQTogJHtKU09OLnN0cmluZ2lmeShrdGEpfSwgU2NvcGVzOiBbJHtzY29wZXMuam9pbignLCAnKX1dYCxcbiAgICAgIGt0YSxcbiAgICAgIHNjb3BlcyxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uIH1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gS1RBIChLZXkgVHlwZSBBcnJheSkgaXMgaW52YWxpZFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEtUQUVycm9yIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa3RhOiBhbnksIHJlYXNvbjogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgS1RBIChLZXkgVHlwZSBBcnJheSk6ICR7cmVhc29ufS4gYCArXG4gICAgICBgRXhwZWN0ZWQgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGdvdDogJHtKU09OLnN0cmluZ2lmeShrdGEpfWAsXG4gICAgICBrdGEsXG4gICAgICBbXSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uIH1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gc2NvcGVzIGFycmF5IGNvbnRhaW5zIGludmFsaWQgdmFsdWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2NvcGVzRXJyb3IgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgaW52YWxpZFNjb3BlczogYW55W107XG5cbiAgY29uc3RydWN0b3Ioc2NvcGVzOiBhbnlbXSwgaW52YWxpZFNjb3BlczogYW55W10sIHJlYXNvbjogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgc2NvcGVzOiAke3JlYXNvbn0uIGAgK1xuICAgICAgYEludmFsaWQgc2NvcGUgdmFsdWVzOiAke0pTT04uc3RyaW5naWZ5KGludmFsaWRTY29wZXMpfWAsXG4gICAgICBudWxsLFxuICAgICAgc2NvcGVzLmZpbHRlcihzID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJyksXG4gICAgICB7IC4uLmNvbnRleHQsIHJlYXNvbiwgaW52YWxpZFNjb3BlcyB9XG4gICAgKTtcbiAgICB0aGlzLmludmFsaWRTY29wZXMgPSBpbnZhbGlkU2NvcGVzO1xuICB9XG59XG4iXSwibmFtZXMiOlsibG9nZ2VyIiwiY3JlYXRlSW5zdGFuY2UiLCJjcmVhdGVSZWdpc3RyeSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../fjell-registry/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./src/client/api/WidgetAPI.ts":
/*!*************************************!*\
  !*** ./src/client/api/WidgetAPI.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   widgetApi: () => (/* binding */ widgetApi),\n/* harmony export */   widgetTypeApi: () => (/* binding */ widgetTypeApi)\n/* harmony export */ });\n/* harmony import */ var _fjell_client_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/client-api */ \"(ssr)/../fjell-client-api/dist/index.js\");\n/* harmony import */ var _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/http-api */ \"(ssr)/../fjell-http-api/dist/index.js\");\n\n\n// Create HttpApi configuration for browser environment\nconst createApiParams = (baseUrl = 'http://localhost:3001/api')=>({\n        config: {\n            url: baseUrl,\n            requestCredentials: 'same-origin',\n            clientName: 'fjell-sample-app-widget-client'\n        },\n        populateAuthHeader: async (isAuthenticated, headers)=>{\n            // In a real app, you'd get the token from your auth system\n            if (isAuthenticated) {\n                const token = localStorage.getItem('authToken') || 'demo-token';\n                headers['Authorization'] = `Bearer ${token}`;\n            }\n        },\n        uploadAsyncFile: async ()=>{\n            // Mock implementation for file uploads\n            return {\n                headers: {},\n                status: 200,\n                mimeType: 'application/json',\n                body: JSON.stringify({\n                    success: true\n                })\n            };\n        }\n    });\n// Create HttpApi instance\nconst apiParams = createApiParams();\nconst baseHttpApi = (0,_fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.getHttpApi)(apiParams);\n// fjell-express-router returns data directly, no wrapper needed\nconst httpApi = baseHttpApi;\n// Create Fjell Client APIs for Widget and WidgetType\nconst widgetApi = (0,_fjell_client_api__WEBPACK_IMPORTED_MODULE_0__.createPItemApi)(httpApi, 'widget', 'widgets', {\n    readAuthenticated: false,\n    writeAuthenticated: true,\n    enableErrorHandling: true,\n    retryConfig: {\n        maxRetries: 3,\n        initialDelayMs: 1000,\n        maxDelayMs: 10000,\n        backoffMultiplier: 2,\n        enableJitter: true\n    }\n});\nconst widgetTypeApi = (0,_fjell_client_api__WEBPACK_IMPORTED_MODULE_0__.createPItemApi)(httpApi, 'widgetType', 'widget-types', {\n    readAuthenticated: false,\n    writeAuthenticated: true,\n    enableErrorHandling: true,\n    retryConfig: {\n        maxRetries: 3,\n        initialDelayMs: 1000,\n        maxDelayMs: 10000,\n        backoffMultiplier: 2,\n        enableJitter: true\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvY2xpZW50L2FwaS9XaWRnZXRBUEkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE2RDtBQUNMO0FBWXhELHVEQUF1RDtBQUN2RCxNQUFNRSxrQkFBa0IsQ0FBQ0MsVUFBa0IsMkJBQTJCLEdBQWlCO1FBQ3JGQyxRQUFRO1lBQ05DLEtBQUtGO1lBQ0xHLG9CQUFvQjtZQUNwQkMsWUFBWTtRQUNkO1FBQ0FDLG9CQUFvQixPQUFPQyxpQkFBMEJDO1lBQ25ELDJEQUEyRDtZQUMzRCxJQUFJRCxpQkFBaUI7Z0JBQ25CLE1BQU1FLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQyxnQkFBZ0I7Z0JBQ25ESCxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxPQUFPLEVBQUVDLE9BQU87WUFDOUM7UUFDRjtRQUNBRyxpQkFBaUI7WUFDZix1Q0FBdUM7WUFDdkMsT0FBTztnQkFDTEosU0FBUyxDQUFDO2dCQUNWSyxRQUFRO2dCQUNSQyxVQUFVO2dCQUNWQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVDLFNBQVM7Z0JBQUs7WUFDdkM7UUFDRjtJQUNGO0FBRUEsMEJBQTBCO0FBQzFCLE1BQU1DLFlBQVluQjtBQUNsQixNQUFNb0IsY0FBY3JCLDJEQUFVQSxDQUFDb0I7QUFFL0IsZ0VBQWdFO0FBQ2hFLE1BQU1FLFVBQVVEO0FBRWhCLHFEQUFxRDtBQUM5QyxNQUFNRSxZQUF3Q3hCLGlFQUFjQSxDQUNqRXVCLFNBQ0EsVUFDQSxXQUNBO0lBQ0VFLG1CQUFtQjtJQUNuQkMsb0JBQW9CO0lBQ3BCQyxxQkFBcUI7SUFDckJDLGFBQWE7UUFDWEMsWUFBWTtRQUNaQyxnQkFBZ0I7UUFDaEJDLFlBQVk7UUFDWkMsbUJBQW1CO1FBQ25CQyxjQUFjO0lBQ2hCO0FBQ0YsR0FDQTtBQUVLLE1BQU1DLGdCQUFvRGxDLGlFQUFjQSxDQUM3RXVCLFNBQ0EsY0FDQSxnQkFDQTtJQUNFRSxtQkFBbUI7SUFDbkJDLG9CQUFvQjtJQUNwQkMscUJBQXFCO0lBQ3JCQyxhQUFhO1FBQ1hDLFlBQVk7UUFDWkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLG1CQUFtQjtRQUNuQkMsY0FBYztJQUNoQjtBQUNGLEdBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtc2FtcGxlLWFwcC9zcmMvY2xpZW50L2FwaS9XaWRnZXRBUEkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUEl0ZW1BcGksIFBJdGVtQXBpIH0gZnJvbSAnQGZqZWxsL2NsaWVudC1hcGknO1xuaW1wb3J0IHsgQXBpUGFyYW1zLCBnZXRIdHRwQXBpIH0gZnJvbSAnQGZqZWxsL2h0dHAtYXBpJztcbmltcG9ydCB0eXBlIHsgV2lkZ2V0IH0gZnJvbSAnLi4vLi4vbW9kZWwvV2lkZ2V0JztcbmltcG9ydCB0eXBlIHsgV2lkZ2V0VHlwZSB9IGZyb20gJy4uLy4uL21vZGVsL1dpZGdldFR5cGUnO1xuXG4vLyBXaWRnZXQgU3VtbWFyeSBpbnRlcmZhY2UgZm9yIGJ1c2luZXNzIGFuYWx5dGljc1xuZXhwb3J0IGludGVyZmFjZSBXaWRnZXRTdW1tYXJ5IHtcbiAgdG90YWw6IG51bWJlcjtcbiAgYWN0aXZlOiBudW1iZXI7XG4gIGluYWN0aXZlOiBudW1iZXI7XG4gIGFjdGl2ZVBlcmNlbnRhZ2U6IG51bWJlcjtcbn1cblxuLy8gQ3JlYXRlIEh0dHBBcGkgY29uZmlndXJhdGlvbiBmb3IgYnJvd3NlciBlbnZpcm9ubWVudFxuY29uc3QgY3JlYXRlQXBpUGFyYW1zID0gKGJhc2VVcmw6IHN0cmluZyA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpJyk6IEFwaVBhcmFtcyA9PiAoe1xuICBjb25maWc6IHtcbiAgICB1cmw6IGJhc2VVcmwsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIGNsaWVudE5hbWU6ICdmamVsbC1zYW1wbGUtYXBwLXdpZGdldC1jbGllbnQnXG4gIH0sXG4gIHBvcHVsYXRlQXV0aEhlYWRlcjogYXN5bmMgKGlzQXV0aGVudGljYXRlZDogYm9vbGVhbiwgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSdkIGdldCB0aGUgdG9rZW4gZnJvbSB5b3VyIGF1dGggc3lzdGVtXG4gICAgaWYgKGlzQXV0aGVudGljYXRlZCkge1xuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJykgfHwgJ2RlbW8tdG9rZW4nO1xuICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICB9LFxuICB1cGxvYWRBc3luY0ZpbGU6IGFzeW5jICgpID0+IHtcbiAgICAvLyBNb2NrIGltcGxlbWVudGF0aW9uIGZvciBmaWxlIHVwbG9hZHNcbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyczoge30sXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gQ3JlYXRlIEh0dHBBcGkgaW5zdGFuY2VcbmNvbnN0IGFwaVBhcmFtcyA9IGNyZWF0ZUFwaVBhcmFtcygpO1xuY29uc3QgYmFzZUh0dHBBcGkgPSBnZXRIdHRwQXBpKGFwaVBhcmFtcyk7XG5cbi8vIGZqZWxsLWV4cHJlc3Mtcm91dGVyIHJldHVybnMgZGF0YSBkaXJlY3RseSwgbm8gd3JhcHBlciBuZWVkZWRcbmNvbnN0IGh0dHBBcGkgPSBiYXNlSHR0cEFwaTtcblxuLy8gQ3JlYXRlIEZqZWxsIENsaWVudCBBUElzIGZvciBXaWRnZXQgYW5kIFdpZGdldFR5cGVcbmV4cG9ydCBjb25zdCB3aWRnZXRBcGk6IFBJdGVtQXBpPFdpZGdldCwgJ3dpZGdldCc+ID0gY3JlYXRlUEl0ZW1BcGkoXG4gIGh0dHBBcGksXG4gICd3aWRnZXQnLFxuICAnd2lkZ2V0cycsIC8vIEFQSSBwYXRoXG4gIHtcbiAgICByZWFkQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgd3JpdGVBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIGVuYWJsZUVycm9ySGFuZGxpbmc6IHRydWUsXG4gICAgcmV0cnlDb25maWc6IHtcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICBpbml0aWFsRGVsYXlNczogMTAwMCxcbiAgICAgIG1heERlbGF5TXM6IDEwMDAwLFxuICAgICAgYmFja29mZk11bHRpcGxpZXI6IDIsXG4gICAgICBlbmFibGVKaXR0ZXI6IHRydWVcbiAgICB9XG4gIH1cbik7XG5cbmV4cG9ydCBjb25zdCB3aWRnZXRUeXBlQXBpOiBQSXRlbUFwaTxXaWRnZXRUeXBlLCAnd2lkZ2V0VHlwZSc+ID0gY3JlYXRlUEl0ZW1BcGkoXG4gIGh0dHBBcGksXG4gICd3aWRnZXRUeXBlJyxcbiAgJ3dpZGdldC10eXBlcycsIC8vIEFQSSBwYXRoXG4gIHtcbiAgICByZWFkQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgd3JpdGVBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIGVuYWJsZUVycm9ySGFuZGxpbmc6IHRydWUsXG4gICAgcmV0cnlDb25maWc6IHtcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICBpbml0aWFsRGVsYXlNczogMTAwMCxcbiAgICAgIG1heERlbGF5TXM6IDEwMDAwLFxuICAgICAgYmFja29mZk11bHRpcGxpZXI6IDIsXG4gICAgICBlbmFibGVKaXR0ZXI6IHRydWVcbiAgICB9XG4gIH1cbik7XG4iXSwibmFtZXMiOlsiY3JlYXRlUEl0ZW1BcGkiLCJnZXRIdHRwQXBpIiwiY3JlYXRlQXBpUGFyYW1zIiwiYmFzZVVybCIsImNvbmZpZyIsInVybCIsInJlcXVlc3RDcmVkZW50aWFscyIsImNsaWVudE5hbWUiLCJwb3B1bGF0ZUF1dGhIZWFkZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJoZWFkZXJzIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidXBsb2FkQXN5bmNGaWxlIiwic3RhdHVzIiwibWltZVR5cGUiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInN1Y2Nlc3MiLCJhcGlQYXJhbXMiLCJiYXNlSHR0cEFwaSIsImh0dHBBcGkiLCJ3aWRnZXRBcGkiLCJyZWFkQXV0aGVudGljYXRlZCIsIndyaXRlQXV0aGVudGljYXRlZCIsImVuYWJsZUVycm9ySGFuZGxpbmciLCJyZXRyeUNvbmZpZyIsIm1heFJldHJpZXMiLCJpbml0aWFsRGVsYXlNcyIsIm1heERlbGF5TXMiLCJiYWNrb2ZmTXVsdGlwbGllciIsImVuYWJsZUppdHRlciIsIndpZGdldFR5cGVBcGkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/client/api/WidgetAPI.ts\n");

/***/ }),

/***/ "(ssr)/./src/client/cache/WidgetCache.ts":
/*!*****************************************!*\
  !*** ./src/client/cache/WidgetCache.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheRegistry: () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.cacheRegistry),\n/* harmony export */   widgetCache: () => (/* binding */ widgetCache),\n/* harmony export */   widgetCacheUtils: () => (/* binding */ widgetCacheUtils)\n/* harmony export */ });\n/* harmony import */ var _fjell_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/cache */ \"(ssr)/../fjell-cache/dist/index.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/registry */ \"(ssr)/../fjell-registry/dist/index.js\");\n/* harmony import */ var _api_WidgetAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/WidgetAPI */ \"(ssr)/./src/client/api/WidgetAPI.ts\");\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ \"(ssr)/./src/client/cache/registry.ts\");\n\n\n\n\n// Removed circular dependency import\n// Cache configuration optimized for browser environment with IndexedDB\nconst createCacheOptions = (dbName, storeName)=>({\n        cacheType: 'indexedDB',\n        indexedDBConfig: {\n            dbName,\n            version: 1,\n            storeName\n        },\n        enableDebugLogging: true,\n        autoSync: true,\n        maxRetries: 5,\n        retryDelay: 2000,\n        ttl: 900000,\n        evictionPolicy: 'lru',\n        evictionConfig: {\n            type: 'lru'\n        }\n    });\n// Widget Cache Instance\nconst widgetCache = (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_0__.createCache)(_api_WidgetAPI__WEBPACK_IMPORTED_MODULE_2__.widgetApi, (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_1__.createCoordinate)('widget'), _registry__WEBPACK_IMPORTED_MODULE_3__.cacheRegistry, createCacheOptions('WidgetAppCache_Widgets', 'widgets'));\n// Utility functions for widget cache management\nconst widgetCacheUtils = {\n    /**\n   * Clear widget cache\n   */ clear: async ()=>{\n        await widgetCache.operations.reset();\n    },\n    /**\n   * Get widget cache information for debugging\n   */ getCacheInfo: ()=>widgetCache.getCacheInfo(),\n    /**\n   * Manually invalidate widget caches when external changes occur\n   */ invalidate: ()=>{\n        widgetCache.cacheMap.clearQueryResults();\n    },\n    /**\n   * Get widget cache statistics for monitoring\n   */ getCacheStats: ()=>{\n        const sizeInfo = widgetCache.cacheMap.getCurrentSize();\n        return {\n            ...sizeInfo\n        };\n    }\n};\n// Export the cache registry for test access\n // Cross-cache utilities moved to index.ts to avoid circular dependencies\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvY2xpZW50L2NhY2hlL1dpZGdldENhY2hlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBa0Q7QUFDQztBQUVOO0FBQ0Y7QUFDM0MscUNBQXFDO0FBRXJDLHVFQUF1RTtBQUN2RSxNQUFNSSxxQkFBcUIsQ0FBQ0MsUUFBZ0JDLFlBQXVCO1FBQ2pFQyxXQUFXO1FBQ1hDLGlCQUFpQjtZQUNmSDtZQUNBSSxTQUFTO1lBQ1RIO1FBQ0Y7UUFDQUksb0JBQW9CO1FBQ3BCQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsWUFBWTtRQUNaQyxLQUFLO1FBQ0xDLGdCQUFnQjtRQUNoQkMsZ0JBQWdCO1lBQ2RDLE1BQU07UUFDUjtJQUNGO0FBRUEsd0JBQXdCO0FBQ2pCLE1BQU1DLGNBQXVDbEIseURBQVdBLENBQzdERSxxREFBU0EsRUFDVEQsaUVBQWdCQSxDQUFDLFdBQ2pCRSxvREFBYUEsRUFDYkMsbUJBQW1CLDBCQUEwQixZQUM3QztBQUVGLGdEQUFnRDtBQUN6QyxNQUFNZSxtQkFBbUI7SUFDOUI7O0dBRUMsR0FDREMsT0FBTztRQUNMLE1BQU1GLFlBQVlHLFVBQVUsQ0FBQ0MsS0FBSztJQUNwQztJQUVBOztHQUVDLEdBQ0RDLGNBQWMsSUFBTUwsWUFBWUssWUFBWTtJQUU1Qzs7R0FFQyxHQUNEQyxZQUFZO1FBQ1ZOLFlBQVlPLFFBQVEsQ0FBQ0MsaUJBQWlCO0lBQ3hDO0lBRUE7O0dBRUMsR0FDREMsZUFBZTtRQUNiLE1BQU1DLFdBQVdWLFlBQVlPLFFBQVEsQ0FBQ0ksY0FBYztRQUNwRCxPQUFPO1lBQ0wsR0FBR0QsUUFBUTtRQUNiO0lBQ0Y7QUFDRixFQUFFO0FBRUYsNENBQTRDO0FBQ25CLENBRXpCLHlFQUF5RSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL3NyYy9jbGllbnQvY2FjaGUvV2lkZ2V0Q2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FjaGUsIGNyZWF0ZUNhY2hlIH0gZnJvbSAnQGZqZWxsL2NhY2hlJztcbmltcG9ydCB7IGNyZWF0ZUNvb3JkaW5hdGUgfSBmcm9tICdAZmplbGwvcmVnaXN0cnknO1xuaW1wb3J0IHR5cGUgeyBXaWRnZXQgfSBmcm9tICcuLi8uLi9tb2RlbC9XaWRnZXQnO1xuaW1wb3J0IHsgd2lkZ2V0QXBpIH0gZnJvbSAnLi4vYXBpL1dpZGdldEFQSSc7XG5pbXBvcnQgeyBjYWNoZVJlZ2lzdHJ5IH0gZnJvbSAnLi9yZWdpc3RyeSc7XG4vLyBSZW1vdmVkIGNpcmN1bGFyIGRlcGVuZGVuY3kgaW1wb3J0XG5cbi8vIENhY2hlIGNvbmZpZ3VyYXRpb24gb3B0aW1pemVkIGZvciBicm93c2VyIGVudmlyb25tZW50IHdpdGggSW5kZXhlZERCXG5jb25zdCBjcmVhdGVDYWNoZU9wdGlvbnMgPSAoZGJOYW1lOiBzdHJpbmcsIHN0b3JlTmFtZTogc3RyaW5nKSA9PiAoe1xuICBjYWNoZVR5cGU6ICdpbmRleGVkREInIGFzIGNvbnN0LFxuICBpbmRleGVkREJDb25maWc6IHtcbiAgICBkYk5hbWUsXG4gICAgdmVyc2lvbjogMSxcbiAgICBzdG9yZU5hbWVcbiAgfSxcbiAgZW5hYmxlRGVidWdMb2dnaW5nOiB0cnVlLCAvLyBFbmFibGUgZGVidWcgbG9nZ2luZ1xuICBhdXRvU3luYzogdHJ1ZSxcbiAgbWF4UmV0cmllczogNSxcbiAgcmV0cnlEZWxheTogMjAwMCxcbiAgdHRsOiA5MDAwMDAsIC8vIDE1IG1pbnV0ZXNcbiAgZXZpY3Rpb25Qb2xpY3k6ICdscnUnIGFzIGNvbnN0LFxuICBldmljdGlvbkNvbmZpZzoge1xuICAgIHR5cGU6ICdscnUnIGFzIGNvbnN0XG4gIH1cbn0pO1xuXG4vLyBXaWRnZXQgQ2FjaGUgSW5zdGFuY2VcbmV4cG9ydCBjb25zdCB3aWRnZXRDYWNoZTogQ2FjaGU8V2lkZ2V0LCAnd2lkZ2V0Jz4gPSBjcmVhdGVDYWNoZShcbiAgd2lkZ2V0QXBpLFxuICBjcmVhdGVDb29yZGluYXRlKCd3aWRnZXQnKSxcbiAgY2FjaGVSZWdpc3RyeSxcbiAgY3JlYXRlQ2FjaGVPcHRpb25zKCdXaWRnZXRBcHBDYWNoZV9XaWRnZXRzJywgJ3dpZGdldHMnKVxuKTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdpZGdldCBjYWNoZSBtYW5hZ2VtZW50XG5leHBvcnQgY29uc3Qgd2lkZ2V0Q2FjaGVVdGlscyA9IHtcbiAgLyoqXG4gICAqIENsZWFyIHdpZGdldCBjYWNoZVxuICAgKi9cbiAgY2xlYXI6IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB3aWRnZXRDYWNoZS5vcGVyYXRpb25zLnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB3aWRnZXQgY2FjaGUgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgKi9cbiAgZ2V0Q2FjaGVJbmZvOiAoKSA9PiB3aWRnZXRDYWNoZS5nZXRDYWNoZUluZm8oKSxcblxuICAvKipcbiAgICogTWFudWFsbHkgaW52YWxpZGF0ZSB3aWRnZXQgY2FjaGVzIHdoZW4gZXh0ZXJuYWwgY2hhbmdlcyBvY2N1clxuICAgKi9cbiAgaW52YWxpZGF0ZTogKCkgPT4ge1xuICAgIHdpZGdldENhY2hlLmNhY2hlTWFwLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB3aWRnZXQgY2FjaGUgc3RhdGlzdGljcyBmb3IgbW9uaXRvcmluZ1xuICAgKi9cbiAgZ2V0Q2FjaGVTdGF0czogKCkgPT4ge1xuICAgIGNvbnN0IHNpemVJbmZvID0gd2lkZ2V0Q2FjaGUuY2FjaGVNYXAuZ2V0Q3VycmVudFNpemUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2l6ZUluZm9cbiAgICB9O1xuICB9XG59O1xuXG4vLyBFeHBvcnQgdGhlIGNhY2hlIHJlZ2lzdHJ5IGZvciB0ZXN0IGFjY2Vzc1xuZXhwb3J0IHsgY2FjaGVSZWdpc3RyeSB9O1xuXG4vLyBDcm9zcy1jYWNoZSB1dGlsaXRpZXMgbW92ZWQgdG8gaW5kZXgudHMgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2FjaGUiLCJjcmVhdGVDb29yZGluYXRlIiwid2lkZ2V0QXBpIiwiY2FjaGVSZWdpc3RyeSIsImNyZWF0ZUNhY2hlT3B0aW9ucyIsImRiTmFtZSIsInN0b3JlTmFtZSIsImNhY2hlVHlwZSIsImluZGV4ZWREQkNvbmZpZyIsInZlcnNpb24iLCJlbmFibGVEZWJ1Z0xvZ2dpbmciLCJhdXRvU3luYyIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwidHRsIiwiZXZpY3Rpb25Qb2xpY3kiLCJldmljdGlvbkNvbmZpZyIsInR5cGUiLCJ3aWRnZXRDYWNoZSIsIndpZGdldENhY2hlVXRpbHMiLCJjbGVhciIsIm9wZXJhdGlvbnMiLCJyZXNldCIsImdldENhY2hlSW5mbyIsImludmFsaWRhdGUiLCJjYWNoZU1hcCIsImNsZWFyUXVlcnlSZXN1bHRzIiwiZ2V0Q2FjaGVTdGF0cyIsInNpemVJbmZvIiwiZ2V0Q3VycmVudFNpemUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/client/cache/WidgetCache.ts\n");

/***/ }),

/***/ "(ssr)/./src/client/cache/registry.ts":
/*!**************************************!*\
  !*** ./src/client/cache/registry.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheRegistry: () => (/* binding */ cacheRegistry)\n/* harmony export */ });\n/* harmony import */ var _fjell_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/cache */ \"(ssr)/../fjell-cache/dist/index.js\");\n\n// Create Cache Registry - centralized registry for all cache instances\nconst cacheRegistry = (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_0__.createRegistry)();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvY2xpZW50L2NhY2hlL3JlZ2lzdHJ5LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDO0FBRTlDLHVFQUF1RTtBQUNoRSxNQUFNQyxnQkFBZ0JELDREQUFjQSxHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXNhbXBsZS1hcHAvc3JjL2NsaWVudC9jYWNoZS9yZWdpc3RyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWdpc3RyeSB9IGZyb20gJ0BmamVsbC9jYWNoZSc7XG5cbi8vIENyZWF0ZSBDYWNoZSBSZWdpc3RyeSAtIGNlbnRyYWxpemVkIHJlZ2lzdHJ5IGZvciBhbGwgY2FjaGUgaW5zdGFuY2VzXG5leHBvcnQgY29uc3QgY2FjaGVSZWdpc3RyeSA9IGNyZWF0ZVJlZ2lzdHJ5KCk7XG4iXSwibmFtZXMiOlsiY3JlYXRlUmVnaXN0cnkiLCJjYWNoZVJlZ2lzdHJ5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/client/cache/registry.ts\n");

/***/ })

};
;