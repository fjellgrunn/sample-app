/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_client_cache_WidgetTypeCache_ts"],{

/***/ "(app-pages-browser)/../fjell-cache/dist/index.js":
/*!************************************!*\
  !*** ../fjell-cache/dist/index.js ***!
  \************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncIndexDBCacheMap: () => (/* binding */ AsyncIndexDBCacheMap),\n/* harmony export */   CacheEventEmitter: () => (/* binding */ CacheEventEmitter),\n/* harmony export */   CacheEventFactory: () => (/* binding */ CacheEventFactory),\n/* harmony export */   CacheMap: () => (/* binding */ CacheMap),\n/* harmony export */   CacheStatsManager: () => (/* binding */ CacheStatsManager),\n/* harmony export */   EnhancedMemoryCacheMap: () => (/* binding */ EnhancedMemoryCacheMap),\n/* harmony export */   EvictionManager: () => (/* binding */ EvictionManager),\n/* harmony export */   IndexDBCacheMap: () => (/* binding */ IndexDBCacheMap),\n/* harmony export */   LocalStorageCacheMap: () => (/* binding */ LocalStorageCacheMap),\n/* harmony export */   MemoryCacheMap: () => (/* binding */ MemoryCacheMap),\n/* harmony export */   SessionStorageCacheMap: () => (/* binding */ SessionStorageCacheMap),\n/* harmony export */   TTLManager: () => (/* binding */ TTLManager),\n/* harmony export */   createAggregator: () => (/* binding */ createAggregator),\n/* harmony export */   createCache: () => (/* binding */ createCache),\n/* harmony export */   createCacheMap: () => (/* binding */ createCacheMap),\n/* harmony export */   createEvictionStrategy: () => (/* binding */ createEvictionStrategy),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createInstanceFactory: () => (/* binding */ createInstanceFactory),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   createOperations: () => (/* binding */ createOperations),\n/* harmony export */   createOptions: () => (/* binding */ createOptions),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryFactory: () => (/* binding */ createRegistryFactory),\n/* harmony export */   createValidatedConfig: () => (/* binding */ createValidatedConfig),\n/* harmony export */   estimateValueSize: () => (/* binding */ estimateValueSize),\n/* harmony export */   formatBytes: () => (/* binding */ formatBytes),\n/* harmony export */   isCache: () => (/* binding */ isCache),\n/* harmony export */   isInstance: () => (/* binding */ isInstance),\n/* harmony export */   isLocKeyArrayEqual: () => (/* binding */ isLocKeyArrayEqual),\n/* harmony export */   normalizeKeyValue: () => (/* binding */ normalizeKeyValue),\n/* harmony export */   normalizeLocKeyItem: () => (/* binding */ normalizeLocKeyItem),\n/* harmony export */   parseSizeString: () => (/* binding */ parseSizeString),\n/* harmony export */   toCacheConfig: () => (/* binding */ toCacheConfig),\n/* harmony export */   validateARCConfig: () => (/* binding */ validateARCConfig),\n/* harmony export */   validateEvictionStrategyConfig: () => (/* binding */ validateEvictionStrategyConfig),\n/* harmony export */   validateLFUConfig: () => (/* binding */ validateLFUConfig),\n/* harmony export */   validateOptions: () => (/* binding */ validateOptions),\n/* harmony export */   validateSizeConfig: () => (/* binding */ validateSizeConfig),\n/* harmony export */   validateTwoQueueConfig: () => (/* binding */ validateTwoQueueConfig)\n/* harmony export */ });\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/core */ \"(app-pages-browser)/../fjell-cache/node_modules/@fjell/core/dist/index.js\");\n/* harmony import */ var _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/http-api */ \"(app-pages-browser)/../fjell-cache/node_modules/@fjell/http-api/dist/index.js\");\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fast-safe-stringify */ \"(app-pages-browser)/../fjell-cache/node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fjell/registry */ \"(app-pages-browser)/../fjell-cache/node_modules/@fjell/registry/dist/index.js\");\n// src/CacheContext.ts\nvar _class, __AsyncIndexDBCacheMap;\nvar createCacheContext = (api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager)=>{\n    return {\n        api,\n        cacheMap,\n        pkType,\n        options,\n        eventEmitter,\n        ttlManager,\n        evictionManager,\n        statsManager\n    };\n};\n// src/ops/all.ts\n\n\n// src/normalization.ts\nvar normalizeKeyValue = (value)=>{\n    return String(value);\n};\nvar deterministicStringify = (obj)=>{\n    if (obj === null || typeof obj !== \"object\") {\n        return JSON.stringify(obj);\n    }\n    if (Array.isArray(obj)) {\n        return \"[\" + obj.map(deterministicStringify).join(\",\") + \"]\";\n    }\n    const sortedKeys = Object.keys(obj).sort();\n    const keyValuePairs = sortedKeys.map((key)=>{\n        return JSON.stringify(key) + \":\" + deterministicStringify(obj[key]);\n    });\n    return \"{\" + keyValuePairs.join(\",\") + \"}\";\n};\nvar createNormalizedHashFunction = ()=>{\n    return (key)=>{\n        if (typeof key === \"object\" && key !== null) {\n            const normalizedKey = JSON.parse(JSON.stringify(key));\n            if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n                normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n            }\n            if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n                normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n            }\n            if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n                normalizedKey.loc = normalizedKey.loc.map((locItem)=>{\n                    if (typeof locItem === \"object\" && locItem !== null && \"lk\" in locItem && locItem.lk !== null) {\n                        return {\n                            ...locItem,\n                            lk: normalizeKeyValue(locItem.lk)\n                        };\n                    }\n                    return locItem;\n                });\n            }\n            return deterministicStringify(normalizedKey);\n        }\n        return JSON.stringify(key);\n    };\n};\nvar isLocKeyArrayEqual = (a, b)=>{\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        const normalizedA = normalizeLocKeyItem(a[i]);\n        const normalizedB = normalizeLocKeyItem(b[i]);\n        if (deterministicStringify(normalizedA) !== deterministicStringify(normalizedB)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar normalizeLocKeyItem = (item)=>{\n    if (typeof item === \"object\" && item !== null) {\n        const normalized = {\n            ...item\n        };\n        if (\"lk\" in normalized && normalized.lk !== null) {\n            normalized.lk = normalizeKeyValue(normalized.lk);\n        }\n        return normalized;\n    }\n    return item;\n};\nvar createQueryHash = (pkType, query, locations)=>{\n    const normalizedQuery = JSON.parse(JSON.stringify(query || {}));\n    const sortedQueryKeys = Object.keys(normalizedQuery).sort();\n    const sortedQuery = {};\n    sortedQueryKeys.forEach((key)=>{\n        sortedQuery[key] = normalizedQuery[key];\n    });\n    const locationsArray = Array.isArray(locations) ? locations : [];\n    const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n    const hashInput = {\n        type: \"query\",\n        pkType,\n        query: sortedQuery,\n        locations: normalizedLocations\n    };\n    return deterministicStringify(hashInput);\n};\nvar createFinderHash = (finder, params, locations)=>{\n    const normalizedParams = JSON.parse(JSON.stringify(params || {}));\n    const sortedParamKeys = Object.keys(normalizedParams).sort();\n    const sortedParams = {};\n    sortedParamKeys.forEach((key)=>{\n        sortedParams[key] = normalizedParams[key];\n    });\n    const locationsArray = Array.isArray(locations) ? locations : [];\n    const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n    const hashInput = {\n        type: \"finder\",\n        finder,\n        params: sortedParams,\n        locations: normalizedLocations\n    };\n    return deterministicStringify(hashInput);\n};\n// src/events/CacheEventFactory.ts\nvar CacheEventFactory = (_class = class {\n    // 5 minutes\n    /**\n   * Initialize cleanup mechanism when first instance is created\n   */ static initializeCleanup() {\n        if (this.cleanupInterval === null && this.instanceCount === 0) {\n            this.startCleanupTimer();\n        }\n        this.instanceCount++;\n    }\n    /**\n   * Cleanup mechanism when instance is destroyed\n   */ static destroyInstance() {\n        this.instanceCount = Math.max(0, this.instanceCount - 1);\n        if (this.instanceCount === 0) {\n            this.stopCleanupTimer();\n            this.resetTimestamp();\n        }\n    }\n    /**\n   * Start automatic cleanup timer\n   */ static startCleanupTimer() {\n        this.cleanupInterval = setInterval(()=>{\n            this.performCleanup();\n        }, this.CLEANUP_INTERVAL_MS);\n        if (this.cleanupInterval.unref) {\n            this.cleanupInterval.unref();\n        }\n    }\n    /**\n   * Stop automatic cleanup timer\n   */ static stopCleanupTimer() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n            this.cleanupInterval = null;\n        }\n    }\n    /**\n   * Perform periodic cleanup of stale timestamp state\n   */ static performCleanup() {\n        const now = Date.now();\n        if (now - this.lastTimestamp > this.MAX_TIMESTAMP_AGE_MS) {\n            this.lastTimestamp = 0;\n        }\n    }\n    /**\n   * Reset the timestamp state (useful for testing)\n   */ static resetTimestamp() {\n        this.lastTimestamp = 0;\n    }\n    /**\n   * Generate a unique timestamp that is always greater than the previous one\n   */ static generateTimestamp() {\n        this.initializeCleanup();\n        const now = Date.now();\n        if (now > this.lastTimestamp) {\n            this.lastTimestamp = now;\n        } else {\n            this.lastTimestamp = this.lastTimestamp + 1;\n        }\n        return this.lastTimestamp;\n    }\n    /**\n   * Extract affected locations from an item key\n   */ static extractAffectedLocations(key) {\n        if (\"loc\" in key && key.loc) {\n            return key.loc;\n        }\n        return [];\n    }\n    /**\n   * Create an item-related event\n   */ static createItemEvent(type, key, item) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        const affectedLocations = options.affectedLocations !== void 0 ? options.affectedLocations : this.extractAffectedLocations(key);\n        return {\n            type,\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            key,\n            item,\n            previousItem: options.previousItem,\n            affectedLocations\n        };\n    }\n    /**\n   * Create a query event\n   */ static createQueryEvent(query, locations, items) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        const affectedKeys = items.map((item)=>item.key);\n        return {\n            type: \"items_queried\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            query,\n            locations,\n            items,\n            affectedKeys\n        };\n    }\n    /**\n   * Create a cache cleared event\n   */ static createCacheClearedEvent(itemsCleared) {\n        let queryCacheCleared = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return {\n            type: \"cache_cleared\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            itemsCleared,\n            queryCacheCleared\n        };\n    }\n    /**\n   * Create a location invalidated event\n   */ static createLocationInvalidatedEvent(locations, affectedKeys) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return {\n            type: \"location_invalidated\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            locations,\n            affectedKeys\n        };\n    }\n    /**\n   * Create a query invalidated event\n   */ static createQueryInvalidatedEvent(invalidatedQueries, reason) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return {\n            type: \"query_invalidated\",\n            timestamp: this.generateTimestamp(),\n            source: options.source || \"operation\",\n            context: options.context,\n            invalidatedQueries,\n            reason\n        };\n    }\n    /**\n   * Create an item created event\n   */ static itemCreated(key, item) {\n        let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"api\";\n        return this.createItemEvent(\"item_created\", key, item, {\n            source\n        });\n    }\n    /**\n   * Create an item updated event\n   */ static itemUpdated(key, item, previousItem) {\n        let source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"api\";\n        return this.createItemEvent(\"item_updated\", key, item, {\n            previousItem,\n            source\n        });\n    }\n    /**\n   * Create an item removed event\n   */ static itemRemoved(key, previousItem) {\n        let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"api\";\n        return this.createItemEvent(\"item_removed\", key, null, {\n            previousItem,\n            source\n        });\n    }\n    /**\n   * Create an item retrieved event\n   */ static itemRetrieved(key, item) {\n        let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"api\";\n        return this.createItemEvent(\"item_retrieved\", key, item, {\n            source\n        });\n    }\n    /**\n   * Create an item set event (direct cache operation)\n   */ static itemSet(key, item, previousItem) {\n        return this.createItemEvent(\"item_set\", key, item, {\n            previousItem,\n            source: \"cache\"\n        });\n    }\n}, _class.lastTimestamp = 0, _class.cleanupInterval = null, _class.instanceCount = 0, _class.CLEANUP_INTERVAL_MS = 6e4, // 1 minute\n_class.MAX_TIMESTAMP_AGE_MS = 3e5, _class);\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLogger(\"@fjell/cache\");\nvar logger_default = LibLogger;\n// src/ops/all.ts\nvar logger = logger_default.get(\"all\");\nvar all = async function() {\n    let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], context = arguments.length > 2 ? arguments[2] : void 0;\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger.default(\"all\", {\n        query,\n        locations\n    });\n    const queryHash = createQueryHash(pkType, query, locations);\n    logger.debug(\"Generated query hash for all\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys) {\n        logger.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        const cachedItems = [];\n        let allItemsAvailable = true;\n        for (const itemKey of cachedItemKeys){\n            const item = await cacheMap.get(itemKey);\n            if (item) {\n                cachedItems.push(item);\n            } else {\n                allItemsAvailable = false;\n                break;\n            }\n        }\n        if (allItemsAvailable) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)\n            ];\n        } else {\n            logger.debug(\"Some cached items missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    try {\n        const directCachedItems = await cacheMap.queryIn(query, locations);\n        if (directCachedItems && directCachedItems.length > 0) {\n            logger.debug(\"Found items directly in cache, skipping API call\", {\n                itemCount: directCachedItems.length\n            });\n            const itemKeys = directCachedItems.map((item)=>item.key);\n            await cacheMap.setQueryResult(queryHash, itemKeys);\n            logger.debug(\"Cached query result from direct cache hit\", {\n                queryHash,\n                itemKeyCount: itemKeys.length\n            });\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(directCachedItems, pkType)\n            ];\n        }\n    } catch (error) {\n        logger.debug(\"Error querying cache directly, proceeding to API\", {\n            error\n        });\n    }\n    let ret = [];\n    try {\n        ret = await api.all(query, locations);\n        for (const v of ret){\n            await cacheMap.set(v.key, v);\n            const keyStr = JSON.stringify(v.key);\n            ttlManager.onItemAdded(keyStr, cacheMap);\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n        }\n        const itemKeys = ret.map((item)=>item.key);\n        cacheMap.setQueryResult(queryHash, itemKeys);\n        logger.debug(\"Cached query result\", {\n            queryHash,\n            itemKeyCount: itemKeys.length\n        });\n        const event = CacheEventFactory.createQueryEvent(query, locations, ret);\n        context.eventEmitter.emit(event);\n    } catch (e) {\n        if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n            cacheMap.setQueryResult(queryHash, []);\n            logger.debug(\"Cached empty query result for not found\", {\n                queryHash\n            });\n        } else {\n            throw e;\n        }\n    }\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/one.ts\n\n\n// src/utils/CacheSize.ts\n\nvar SIZE_UNITS = {\n    // Decimal units (powers of 1000)\n    \"b\": 1,\n    \"byte\": 1,\n    \"bytes\": 1,\n    \"kb\": 1e3,\n    \"kilobyte\": 1e3,\n    \"kilobytes\": 1e3,\n    \"mb\": 1e3 * 1e3,\n    \"megabyte\": 1e3 * 1e3,\n    \"megabytes\": 1e3 * 1e3,\n    \"gb\": 1e3 * 1e3 * 1e3,\n    \"gigabyte\": 1e3 * 1e3 * 1e3,\n    \"gigabytes\": 1e3 * 1e3 * 1e3,\n    \"tb\": 1e3 * 1e3 * 1e3 * 1e3,\n    \"terabyte\": 1e3 * 1e3 * 1e3 * 1e3,\n    \"terabytes\": 1e3 * 1e3 * 1e3 * 1e3,\n    // Binary units (powers of 1024)\n    \"kib\": 1024,\n    \"kibibyte\": 1024,\n    \"kibibytes\": 1024,\n    \"mib\": 1024 * 1024,\n    \"mebibyte\": 1024 * 1024,\n    \"mebibytes\": 1024 * 1024,\n    \"gib\": 1024 * 1024 * 1024,\n    \"gibibyte\": 1024 * 1024 * 1024,\n    \"gibibytes\": 1024 * 1024 * 1024,\n    \"tib\": 1024 * 1024 * 1024 * 1024,\n    \"tebibyte\": 1024 * 1024 * 1024 * 1024,\n    \"tebibytes\": 1024 * 1024 * 1024 * 1024\n};\nfunction parseSizeString(sizeStr) {\n    if (!sizeStr || typeof sizeStr !== \"string\") {\n        throw new Error(\"Size string must be a non-empty string\");\n    }\n    const trimmed = sizeStr.trim();\n    if (/^\\d+(\\.\\d+)?$/.test(trimmed)) {\n        const bytes = parseFloat(trimmed);\n        if (isNaN(bytes) || bytes < 0) {\n            throw new Error(\"Invalid size value: \".concat(sizeStr));\n        }\n        return Math.floor(bytes);\n    }\n    const match = trimmed.match(/^(\\d+(?:\\.\\d+)?)\\s*([a-zA-Z]+)$/);\n    if (!match) {\n        throw new Error(\"Invalid size format: \".concat(sizeStr, \". Expected format: '100', '5KB', '10MB', etc.\"));\n    }\n    const [, valueStr, unitStr] = match;\n    const value = parseFloat(valueStr);\n    const unit = unitStr.toLowerCase();\n    if (isNaN(value) || value < 0) {\n        throw new Error(\"Invalid size value: \".concat(valueStr));\n    }\n    const multiplier = SIZE_UNITS[unit];\n    if (!(unit in SIZE_UNITS)) {\n        const supportedUnits = Object.keys(SIZE_UNITS).filter((u)=>u.length <= 3).join(\", \");\n        throw new Error(\"Unsupported size unit: \".concat(unitStr, \". Supported units: \").concat(supportedUnits));\n    }\n    return Math.floor(value * multiplier);\n}\nfunction formatBytes(bytes) {\n    let binary = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    if (bytes === 0) return \"0 B\";\n    if (bytes < 0) return \"\".concat(bytes, \" B\");\n    const k = binary ? 1024 : 1e3;\n    const sizes = binary ? [\n        \"B\",\n        \"KiB\",\n        \"MiB\",\n        \"GiB\",\n        \"TiB\",\n        \"PiB\"\n    ] : [\n        \"B\",\n        \"KB\",\n        \"MB\",\n        \"GB\",\n        \"TB\",\n        \"PB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    const size = bytes / Math.pow(k, i);\n    const formatted = size % 1 === 0 ? size.toString() : size.toFixed(1);\n    return \"\".concat(formatted, \" \").concat(sizes[i]);\n}\nfunction estimateValueSize(value) {\n    if (value === null || typeof value === \"undefined\") {\n        return 8;\n    }\n    switch(typeof value){\n        case \"boolean\":\n            return 4;\n        case \"number\":\n            return 8;\n        case \"string\":\n            return value.length * 2;\n        case \"object\":\n            if (Array.isArray(value)) {\n                return value.reduce((total, item)=>total + estimateValueSize(item), 24);\n            }\n            const hasCircularReference = function(obj) {\n                let ancestors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new WeakSet(), checked = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new WeakSet();\n                if (obj === null || typeof obj !== \"object\") {\n                    return false;\n                }\n                const asObject = obj;\n                if (checked.has(asObject)) {\n                    return false;\n                }\n                if (ancestors.has(asObject)) {\n                    return true;\n                }\n                ancestors.add(asObject);\n                try {\n                    if (Array.isArray(asObject)) {\n                        for (const item of asObject){\n                            if (hasCircularReference(item, ancestors, checked)) {\n                                return true;\n                            }\n                        }\n                    } else {\n                        for (const key of Object.keys(asObject)){\n                            let child;\n                            try {\n                                child = asObject[key];\n                            } catch (e) {\n                                continue;\n                            }\n                            if (hasCircularReference(child, ancestors, checked)) {\n                                return true;\n                            }\n                        }\n                    }\n                } finally{\n                    ancestors.delete(asObject);\n                    checked.add(asObject);\n                }\n                return false;\n            };\n            try {\n                if (hasCircularReference(value)) {\n                    return 64;\n                }\n            } catch (e) {\n                return 64;\n            }\n            try {\n                const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(value);\n                return jsonString.length * 2 + 16;\n            } catch (e) {\n                return 64;\n            }\n        default:\n            return 32;\n    }\n}\nfunction validateSizeConfig(config) {\n    if (typeof config.maxSizeBytes !== \"undefined\") {\n        try {\n            const bytes = parseSizeString(config.maxSizeBytes);\n            if (bytes <= 0) {\n                throw new Error(\"maxSizeBytes must be positive\");\n            }\n        } catch (error) {\n            throw new Error(\"Invalid maxSizeBytes: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    if (typeof config.maxItems !== \"undefined\") {\n        if (!Number.isInteger(config.maxItems) || config.maxItems <= 0) {\n            throw new Error(\"maxItems must be a positive integer\");\n        }\n    }\n}\n// src/ops/one.ts\nvar logger2 = logger_default.get(\"one\");\nvar one = async function() {\n    let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], context = arguments.length > 2 ? arguments[2] : void 0;\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger2.default(\"one\", {\n        query,\n        locations\n    });\n    const queryHash = createQueryHash(pkType, query, locations);\n    logger2.debug(\"Generated query hash for one\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys) {\n        logger2.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        if (cachedItemKeys.length === 0) {\n            return [\n                context,\n                null\n            ];\n        }\n        const item = await cacheMap.get(cachedItemKeys[0]);\n        if (item) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)\n            ];\n        } else {\n            logger2.debug(\"Cached item missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    let retItem = null;\n    try {\n        retItem = await api.one(query, locations);\n        if (retItem) {\n            await cacheMap.set(retItem.key, retItem);\n            const keyStr = JSON.stringify(retItem.key);\n            const metadata = await cacheMap.getMetadata(keyStr);\n            if (!metadata) {\n                const now = Date.now();\n                const baseMetadata = {\n                    key: keyStr,\n                    addedAt: now,\n                    lastAccessedAt: now,\n                    accessCount: 1,\n                    estimatedSize: estimateValueSize(retItem)\n                };\n                await cacheMap.setMetadata(keyStr, baseMetadata);\n            }\n            await ttlManager.onItemAdded(keyStr, cacheMap);\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr, retItem, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n            await cacheMap.setQueryResult(queryHash, [\n                retItem.key\n            ]);\n            logger2.debug(\"Cached query result\", {\n                queryHash,\n                itemKey: retItem.key\n            });\n        } else {\n            await cacheMap.setQueryResult(queryHash, []);\n            logger2.debug(\"Cached empty query result\", {\n                queryHash\n            });\n        }\n    } catch (e) {\n        if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n            cacheMap.setQueryResult(queryHash, []);\n            logger2.debug(\"Cached empty query result for not found\", {\n                queryHash\n            });\n        } else {\n            throw e;\n        }\n    }\n    return [\n        context,\n        retItem ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retItem, pkType) : null\n    ];\n};\n// src/ops/create.ts\n\nvar logger3 = logger_default.get(\"create\");\nvar create = async function(v) {\n    let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], context = arguments.length > 2 ? arguments[2] : void 0;\n    const { api, cacheMap, pkType, eventEmitter, ttlManager, evictionManager } = context;\n    logger3.default(\"create\", {\n        v,\n        locations\n    });\n    const created = await api.create(v, locations);\n    cacheMap.set(created.key, created);\n    const keyStr = JSON.stringify(created.key);\n    ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await evictionManager.onItemAdded(keyStr, created, cacheMap);\n    for (const evictedKey of evictedKeys){\n        const parsedKey = JSON.parse(evictedKey);\n        await cacheMap.delete(parsedKey);\n    }\n    const event = CacheEventFactory.itemCreated(created.key, created, \"api\");\n    eventEmitter.emit(event);\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(created, pkType)\n    ];\n};\n// src/ops/get.ts\n\nvar logger4 = logger_default.get(\"get\");\nvar inFlightRequests = /* @__PURE__ */ new Map();\nvar CLEANUP_TIMEOUT = 5 * 60 * 1e3;\nvar cleanupStaleRequests = ()=>{\n    const now = Date.now();\n    const keysToDelete = [];\n    inFlightRequests.forEach((request, key)=>{\n        if (now - request.timestamp > CLEANUP_TIMEOUT) {\n            keysToDelete.push(key);\n        }\n    });\n    keysToDelete.forEach((key)=>{\n        logger4.debug(\"Cleaning up stale in-flight request\", {\n            key\n        });\n        inFlightRequests.delete(key);\n    });\n};\nvar cleanupInterval = setInterval(cleanupStaleRequests, 60 * 1e3);\nvar keyToString = createNormalizedHashFunction();\nvar get = async (key, context)=>{\n    const { api, cacheMap, pkType, ttlManager, statsManager } = context;\n    logger4.default(\"get\", {\n        key,\n        defaultTTL: ttlManager.getDefaultTTL()\n    });\n    statsManager.incrementRequests();\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger4.error(\"Key for Get is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Get is not a valid ItemKey\");\n    }\n    if (ttlManager.isTTLEnabled()) {\n        const keyStr2 = JSON.stringify(key);\n        const cachedItem = await cacheMap.get(key);\n        if (cachedItem) {\n            const isValid = await ttlManager.validateItem(keyStr2, cacheMap);\n            if (isValid) {\n                logger4.debug(\"Cache hit with valid TTL\", {\n                    key,\n                    defaultTTL: ttlManager.getDefaultTTL()\n                });\n                statsManager.incrementHits();\n                return [\n                    context,\n                    (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)\n                ];\n            } else {\n                logger4.debug(\"Cache item expired, removing\", {\n                    key\n                });\n                cacheMap.delete(key);\n                statsManager.incrementMisses();\n            }\n        } else {\n            statsManager.incrementMisses();\n        }\n        logger4.debug(\"Cache miss or expired\", {\n            key,\n            defaultTTL: ttlManager.getDefaultTTL()\n        });\n    } else {\n        const cachedItem = await cacheMap.get(key);\n        if (cachedItem) {\n            logger4.debug(\"Cache hit (TTL disabled)\", {\n                key\n            });\n            statsManager.incrementHits();\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)\n            ];\n        } else {\n            statsManager.incrementMisses();\n        }\n    }\n    let ret;\n    const keyStr = keyToString(key);\n    try {\n        const requestEntry = inFlightRequests.get(keyStr);\n        let apiRequest;\n        if (!requestEntry) {\n            apiRequest = api.get(key);\n            if (apiRequest && typeof apiRequest.then === \"function\") {\n                const timestamp = Date.now();\n                inFlightRequests.set(keyStr, {\n                    promise: apiRequest,\n                    timestamp\n                });\n                const cleanup = ()=>inFlightRequests.delete(keyStr);\n                if (typeof apiRequest.finally === \"function\") {\n                    apiRequest.finally(cleanup);\n                } else {\n                    apiRequest.then(cleanup, cleanup);\n                }\n            }\n        } else {\n            logger4.debug(\"Using in-flight request for key\", {\n                key\n            });\n            apiRequest = requestEntry.promise;\n        }\n        ret = await apiRequest;\n        if (ret) {\n            await cacheMap.set(ret.key, ret);\n            const keyStr2 = JSON.stringify(ret.key);\n            const metadata = await cacheMap.getMetadata(keyStr2);\n            if (!metadata) {\n                const now = Date.now();\n                const baseMetadata = {\n                    key: keyStr2,\n                    addedAt: now,\n                    lastAccessedAt: now,\n                    accessCount: 1,\n                    estimatedSize: estimateValueSize(ret)\n                };\n                await cacheMap.setMetadata(keyStr2, baseMetadata);\n            }\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr2, ret, cacheMap);\n            await ttlManager.onItemAdded(keyStr2, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n            const event = CacheEventFactory.itemRetrieved(ret.key, ret, \"api\");\n            context.eventEmitter.emit(event);\n        }\n    } catch (e) {\n        inFlightRequests.delete(keyStr);\n        logger4.error(\"Error getting item for key\", {\n            key,\n            message: e.message,\n            stack: e.stack\n        });\n        throw e;\n    }\n    return [\n        context,\n        ret ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType) : null\n    ];\n};\n// src/ops/retrieve.ts\n\nvar logger5 = logger_default.get(\"retrieve\");\nvar retrieve = async (key, context)=>{\n    const { cacheMap, pkType, statsManager } = context;\n    logger5.default(\"retrieve\", {\n        key\n    });\n    statsManager.incrementRequests();\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger5.error(\"Key for Retrieve is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Retrieve is not a valid ItemKey\");\n    }\n    const containsItemKey = await cacheMap.includesKey(key);\n    let retrieved;\n    let contextToReturn;\n    if (containsItemKey) {\n        logger5.default(\"Looking for Object in Cache\", key);\n        retrieved = await cacheMap.get(key);\n        contextToReturn = null;\n        statsManager.incrementHits();\n    } else {\n        logger5.default(\"Object Not Found in Cache, Retrieving from Server API\", {\n            key\n        });\n        statsManager.incrementMisses();\n        [contextToReturn, retrieved] = await get(key, context);\n    }\n    const retValue = [\n        contextToReturn,\n        retrieved ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retrieved, pkType) : null\n    ];\n    return retValue;\n};\n// src/ops/remove.ts\n\nvar logger6 = logger_default.get(\"remove\");\nvar remove = async (key, context)=>{\n    const { api, cacheMap } = context;\n    logger6.default(\"remove\", {\n        key\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger6.error(\"Key for Remove is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Remove is not a valid ItemKey\");\n    }\n    try {\n        const previousItem = await cacheMap.get(key);\n        await api.remove(key);\n        cacheMap.delete(key);\n        if (previousItem) {\n            const event = CacheEventFactory.itemRemoved(key, previousItem, \"api\");\n            context.eventEmitter.emit(event);\n        }\n        logger6.debug(\"Successfully removed item from API and cache\", {\n            key\n        });\n    } catch (e) {\n        logger6.error(\"Error deleting item\", {\n            error: e\n        });\n        throw e;\n    }\n    return context;\n};\n// src/ops/update.ts\n\nvar logger7 = logger_default.get(\"update\");\nvar update = async (key, v, context)=>{\n    const { api, cacheMap, pkType } = context;\n    logger7.default(\"update\", {\n        key,\n        v\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger7.error(\"Key for Update is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Update is not a valid ItemKey\");\n    }\n    logger7.debug(\"Invalidating item key before update\", {\n        key\n    });\n    cacheMap.invalidateItemKeys([\n        key\n    ]);\n    try {\n        const previousItem = await cacheMap.get(key);\n        const updated = await api.update(key, v);\n        logger7.debug(\"Caching update result\", {\n            updatedKey: updated.key\n        });\n        await cacheMap.set(updated.key, updated);\n        const keyStr = JSON.stringify(updated.key);\n        const metadata = await cacheMap.getMetadata(keyStr);\n        if (!metadata) {\n            const now = Date.now();\n            const baseMetadata = {\n                key: keyStr,\n                addedAt: now,\n                lastAccessedAt: now,\n                accessCount: 1,\n                estimatedSize: estimateValueSize(updated)\n            };\n            await cacheMap.setMetadata(keyStr, baseMetadata);\n        }\n        await context.ttlManager.onItemAdded(keyStr, cacheMap);\n        const evictedKeys = await context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n        for (const evictedKey of evictedKeys){\n            const parsedKey = JSON.parse(evictedKey);\n            await cacheMap.delete(parsedKey);\n        }\n        const event = CacheEventFactory.itemUpdated(updated.key, updated, previousItem, \"api\");\n        context.eventEmitter.emit(event);\n        return [\n            context,\n            (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)\n        ];\n    } catch (e) {\n        logger7.error(\"Error updating item\", {\n            error: e\n        });\n        throw e;\n    }\n};\n// src/ops/action.ts\n\nvar logger8 = logger_default.get(\"action\");\nvar action = async function(key, action2) {\n    let body = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, context = arguments.length > 3 ? arguments[3] : void 0;\n    const { api, cacheMap, pkType } = context;\n    logger8.default(\"action\", {\n        key,\n        action: action2,\n        body\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger8.error(\"Key for Action is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Action is not a valid ItemKey\");\n    }\n    logger8.debug(\"Invalidating item key before action\", {\n        key\n    });\n    cacheMap.invalidateItemKeys([\n        key\n    ]);\n    const updated = await api.action(key, action2, body);\n    logger8.debug(\"Caching action result\", {\n        updatedKey: updated.key\n    });\n    cacheMap.set(updated.key, updated);\n    const keyStr = JSON.stringify(updated.key);\n    context.ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n    for (const evictedKey of evictedKeys){\n        try {\n            const parsedKey = JSON.parse(evictedKey);\n            await cacheMap.delete(parsedKey);\n        } catch (error) {\n            logger8.error(\"Failed to parse evicted key during deletion\", {\n                evictedKey,\n                error: error instanceof Error ? error.message : String(error)\n            });\n        }\n    }\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)\n    ];\n};\n// src/ops/allAction.ts\n\n\nvar logger9 = logger_default.get(\"allAction\");\nvar allAction = async function(action2) {\n    let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], context = arguments.length > 3 ? arguments[3] : void 0;\n    const { api, cacheMap, pkType } = context;\n    logger9.default(\"allAction\", {\n        action: action2,\n        body,\n        locations\n    });\n    logger9.debug(\"Invalidating location before allAction\", {\n        locations\n    });\n    cacheMap.invalidateLocation(locations);\n    let ret = [];\n    try {\n        ret = await api.allAction(action2, body, locations);\n        logger9.debug(\"Caching allAction results\", {\n            resultCount: ret.length\n        });\n        for (const v of ret){\n            await cacheMap.set(v.key, v);\n            const keyStr = JSON.stringify(v.key);\n            context.ttlManager.onItemAdded(keyStr, cacheMap);\n            const evictedKeys = await context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n            for (const evictedKey of evictedKeys){\n                const parsedKey = JSON.parse(evictedKey);\n                await cacheMap.delete(parsedKey);\n            }\n        }\n    } catch (e) {\n        if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {} else {\n            throw e;\n        }\n    }\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/facet.ts\nvar logger10 = logger_default.get(\"facet\");\nvar facet = async function(key, facet2) {\n    let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, context = arguments.length > 3 ? arguments[3] : void 0;\n    const { api } = context;\n    logger10.default(\"facet\", {\n        key,\n        facet: facet2\n    });\n    const ret = await api.facet(key, facet2, params);\n    return ret;\n};\n// src/ops/allFacet.ts\nvar logger11 = logger_default.get(\"allFacet\");\nvar allFacet = async function(facet2) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], context = arguments.length > 3 ? arguments[3] : void 0;\n    const { api } = context;\n    logger11.default(\"allFacet\", {\n        facet: facet2,\n        params,\n        locations\n    });\n    const ret = await api.allFacet(facet2, params, locations);\n    return ret;\n};\n// src/ops/find.ts\n\nvar logger12 = logger_default.get(\"find\");\nvar find = async function(finder) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], context = arguments.length > 3 ? arguments[3] : void 0;\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger12.default(\"find\", {\n        finder,\n        params,\n        locations\n    });\n    const queryHash = createFinderHash(finder, params, locations);\n    logger12.debug(\"Generated query hash for find\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys) {\n        logger12.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        const cachedItems = [];\n        let allItemsAvailable = true;\n        for (const itemKey of cachedItemKeys){\n            const item = await cacheMap.get(itemKey);\n            if (item) {\n                cachedItems.push(item);\n            } else {\n                allItemsAvailable = false;\n                break;\n            }\n        }\n        if (allItemsAvailable) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)\n            ];\n        } else {\n            logger12.debug(\"Some cached items missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    const ret = await api.find(finder, params, locations);\n    for (const v of ret){\n        await cacheMap.set(v.key, v);\n        const keyStr = JSON.stringify(v.key);\n        ttlManager.onItemAdded(keyStr, cacheMap);\n        const evictedKeys = await context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n        for (const evictedKey of evictedKeys){\n            const parsedKey = JSON.parse(evictedKey);\n            await cacheMap.delete(parsedKey);\n        }\n    }\n    const itemKeys = ret.map((item)=>item.key);\n    cacheMap.setQueryResult(queryHash, itemKeys);\n    logger12.debug(\"Cached query result\", {\n        queryHash,\n        itemKeyCount: itemKeys.length\n    });\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/findOne.ts\n\nvar logger13 = logger_default.get(\"findOne\");\nvar findOne = async function(finder) {\n    let finderParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], context = arguments.length > 3 ? arguments[3] : void 0;\n    const { api, cacheMap, pkType, ttlManager } = context;\n    logger13.default(\"findOne\", {\n        finder,\n        finderParams,\n        locations\n    });\n    const queryHash = createFinderHash(finder, finderParams, locations);\n    logger13.debug(\"Generated query hash for findOne\", {\n        queryHash\n    });\n    const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n    if (cachedItemKeys && cachedItemKeys.length > 0) {\n        logger13.debug(\"Using cached query results\", {\n            cachedKeyCount: cachedItemKeys.length\n        });\n        const item = await cacheMap.get(cachedItemKeys[0]);\n        if (item) {\n            return [\n                context,\n                (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)\n            ];\n        } else {\n            logger13.debug(\"Cached item missing, invalidating query cache\");\n            cacheMap.deleteQueryResult(queryHash);\n        }\n    }\n    const ret = await api.findOne(finder, finderParams, locations);\n    cacheMap.set(ret.key, ret);\n    const keyStr = JSON.stringify(ret.key);\n    ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await context.evictionManager.onItemAdded(keyStr, ret, cacheMap);\n    for (const evictedKey of evictedKeys){\n        const parsedKey = JSON.parse(evictedKey);\n        await cacheMap.delete(parsedKey);\n    }\n    cacheMap.setQueryResult(queryHash, [\n        ret.key\n    ]);\n    logger13.debug(\"Cached query result\", {\n        queryHash,\n        itemKey: ret.key\n    });\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)\n    ];\n};\n// src/ops/set.ts\n\nvar logger14 = logger_default.get(\"set\");\nvar normalizeKeyValue2 = (value)=>{\n    return String(value);\n};\nvar isItemKeyEqualNormalized = (a, b)=>{\n    const normalizedA = normalizeKey(a);\n    const normalizedB = normalizeKey(b);\n    return (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isItemKeyEqual)(normalizedA, normalizedB);\n};\nvar normalizeKey = (key)=>{\n    if (typeof key === \"object\" && key !== null) {\n        let needsNormalization = false;\n        let normalizedKey = key;\n        if (\"pk\" in key && key.pk !== null && typeof key.pk !== \"string\") {\n            needsNormalization = true;\n        }\n        if (\"lk\" in key && key.lk !== null && typeof key.lk !== \"string\") {\n            needsNormalization = true;\n        }\n        if (\"loc\" in key && Array.isArray(key.loc)) {\n            for (const locItem of key.loc){\n                if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n                    needsNormalization = true;\n                    break;\n                }\n            }\n        }\n        if (needsNormalization) {\n            normalizedKey = {\n                ...key\n            };\n            if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n                normalizedKey.pk = normalizeKeyValue2(normalizedKey.pk);\n            }\n            if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n                normalizedKey.lk = normalizeKeyValue2(normalizedKey.lk);\n            }\n            if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n                normalizedKey.loc = normalizedKey.loc.map((locItem)=>{\n                    if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n                        return {\n                            ...locItem,\n                            lk: normalizeKeyValue2(locItem.lk)\n                        };\n                    }\n                    return locItem;\n                });\n            }\n        }\n        return normalizedKey;\n    }\n    return key;\n};\nvar set = async (key, v, context)=>{\n    const { cacheMap, pkType, ttlManager, evictionManager, eventEmitter } = context;\n    logger14.default(\"set\", {\n        key,\n        v\n    });\n    if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n        logger14.error(\"Key for Set is not a valid ItemKey: %j\", key);\n        throw new Error(\"Key for Set is not a valid ItemKey\");\n    }\n    (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType);\n    if (!isItemKeyEqualNormalized(key, v.key)) {\n        logger14.error(\"Key does not match item key: %j != %j\", key, v.key);\n        throw new Error(\"Key does not match item key\");\n    }\n    const previousItem = await cacheMap.get(key);\n    await cacheMap.set(key, v);\n    const keyStr = JSON.stringify(key);\n    const metadata = await cacheMap.getMetadata(keyStr);\n    if (!metadata) {\n        const now = Date.now();\n        const baseMetadata = {\n            key: keyStr,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize: estimateValueSize(v)\n        };\n        await cacheMap.setMetadata(keyStr, baseMetadata);\n    }\n    await ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = await evictionManager.onItemAdded(keyStr, v, cacheMap);\n    for (const evictedKey of evictedKeys){\n        const parsedKey = JSON.parse(evictedKey);\n        await cacheMap.delete(parsedKey);\n    }\n    const event = CacheEventFactory.itemSet(key, v, previousItem);\n    eventEmitter.emit(event);\n    return [\n        context,\n        (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType)\n    ];\n};\n// src/memory/MemoryCacheMap.ts\n\n// src/CacheMap.ts\nvar CacheMap = class {\n    constructor(types){\n        this.types = types;\n    }\n};\n// src/memory/MemoryCacheMap.ts\nvar logger15 = logger_default.get(\"MemoryCacheMap\");\nvar MemoryCacheMap = class _MemoryCacheMap extends CacheMap {\n    async get(key) {\n        logger15.trace(\"get\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            const keyStr = JSON.stringify(key);\n            const metadata = this.metadataMap.get(keyStr);\n            if (metadata) {\n                metadata.lastAccessedAt = Date.now();\n                metadata.accessCount++;\n            }\n            return entry.value;\n        }\n        return null;\n    }\n    async set(key, value) {\n        logger15.trace(\"set\", {\n            key,\n            value\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const keyStr = JSON.stringify(key);\n        this.map[hashedKey] = {\n            originalKey: key,\n            value\n        };\n        if (!this.metadataMap.has(keyStr)) {\n            const now = Date.now();\n            const metadata = {\n                key: keyStr,\n                addedAt: now,\n                lastAccessedAt: now,\n                accessCount: 1,\n                estimatedSize: estimateValueSize(value)\n            };\n            this.metadataMap.set(keyStr, metadata);\n        } else {\n            const metadata = this.metadataMap.get(keyStr);\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            metadata.estimatedSize = estimateValueSize(value);\n        }\n    }\n    async includesKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey;\n    }\n    async delete(key) {\n        logger15.trace(\"delete\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            const keyStr = JSON.stringify(entry.originalKey);\n            this.metadataMap.delete(keyStr);\n            delete this.map[hashedKey];\n            for (const [queryHash, cacheEntry] of Object.entries(this.queryResultCache)){\n                cacheEntry.itemKeys = cacheEntry.itemKeys.filter((k)=>this.normalizedHashFunction(k) !== hashedKey);\n                if (cacheEntry.itemKeys.length === 0) {\n                    delete this.queryResultCache[queryHash];\n                }\n            }\n        }\n    }\n    async keys() {\n        return Object.values(this.map).map((entry)=>entry.originalKey);\n    }\n    async values() {\n        return Object.values(this.map).map((entry)=>entry.value);\n    }\n    async clear() {\n        this.map = {};\n        this.metadataMap.clear();\n        this.queryResultCache = {};\n    }\n    async allIn(locations) {\n        const allValues = await this.values();\n        if (locations.length === 0) {\n            logger15.debug(\"Returning all items, LocKeys is empty\");\n            return allValues;\n        } else {\n            logger15.debug(\"allIn\", {\n                locations,\n                count: allValues.length\n            });\n            return allValues.filter((item)=>{\n                const key = item.key;\n                if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n                    const comKey = key;\n                    return isLocKeyArrayEqual(locations, comKey.loc);\n                }\n                return false;\n            });\n        }\n    }\n    async contains(query, locations) {\n        logger15.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query) {\n        let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger15.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        const clone = new _MemoryCacheMap(this.types);\n        const keys = await this.keys();\n        for (const key of keys){\n            const value = await this.get(key);\n            if (value) {\n                await clone.set(key, value);\n            }\n        }\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            clone.queryResultCache[queryHash] = {\n                itemKeys: [\n                    ...entry.itemKeys\n                ]\n            };\n        }\n        return clone;\n    }\n    // Query result caching methods implementation\n    async setQueryResult(queryHash, itemKeys) {\n        logger15.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        const entry = {\n            itemKeys: [\n                ...itemKeys\n            ]\n        };\n        this.queryResultCache[queryHash] = entry;\n    }\n    async getQueryResult(queryHash) {\n        logger15.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const entry = this.queryResultCache[queryHash];\n        if (!entry) {\n            return null;\n        }\n        return [\n            ...entry.itemKeys\n        ];\n    }\n    async hasQueryResult(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        return !!entry;\n    }\n    async deleteQueryResult(queryHash) {\n        logger15.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        delete this.queryResultCache[queryHash];\n    }\n    async invalidateItemKeys(keys) {\n        logger15.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            await this.delete(key);\n        }\n    }\n    async invalidateLocation(locations) {\n        logger15.debug(\"invalidateLocation\", {\n            locations\n        });\n        if (locations.length === 0) {\n            const allKeys = await this.keys();\n            const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n            await this.invalidateItemKeys(primaryKeys);\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            const keysToInvalidate = itemsInLocation.map((item)=>item.key);\n            await this.invalidateItemKeys(keysToInvalidate);\n        }\n        await this.clearQueryResults();\n    }\n    async clearQueryResults() {\n        logger15.trace(\"clearQueryResults\");\n        this.queryResultCache = {};\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        return this.metadataMap.get(key) || null;\n    }\n    async setMetadata(key, metadata) {\n        this.metadataMap.set(key, metadata);\n    }\n    async deleteMetadata(key) {\n        this.metadataMap.delete(key);\n    }\n    async getAllMetadata() {\n        return new Map(this.metadataMap);\n    }\n    async clearMetadata() {\n        this.metadataMap.clear();\n    }\n    async getCurrentSize() {\n        let sizeBytes = 0;\n        for (const entry of Object.values(this.map)){\n            sizeBytes += estimateValueSize(entry.value);\n        }\n        return {\n            itemCount: Object.keys(this.map).length,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            maxSizeBytes: null\n        };\n    }\n    constructor(types, initialData){\n        super(types), this.implementationType = \"memory/memory\", this.map = {}, // Query result cache: maps query hash to cache entry\n        this.queryResultCache = {}, // Metadata storage for eviction strategies\n        this.metadataMap = /* @__PURE__ */ new Map();\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        if (initialData) {\n            for (const [keyStr, value] of Object.entries(initialData)){\n                try {\n                    const key = JSON.parse(keyStr);\n                    this.set(key, value);\n                } catch (error) {\n                    logger15.error(\"Failed to parse initial data key\", {\n                        keyStr,\n                        error\n                    });\n                }\n            }\n        }\n    }\n};\n// src/memory/EnhancedMemoryCacheMap.ts\n\nvar logger16 = logger_default.get(\"EnhancedMemoryCacheMap\");\nvar EnhancedMemoryCacheMap = class _EnhancedMemoryCacheMap extends CacheMap {\n    async get(key) {\n        logger16.trace(\"get\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null) {\n            return entry.value;\n        }\n        return null;\n    }\n    async set(key, value) {\n        logger16.trace(\"set\", {\n            key,\n            value\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const estimatedSize = estimateValueSize(value);\n        const existingEntry = this.map[hashedKey];\n        const isUpdate = existingEntry && this.normalizedHashFunction(existingEntry.originalKey) === hashedKey;\n        if (isUpdate) {\n            const sizeDiff = estimatedSize - existingEntry.metadata.estimatedSize;\n            this.currentSizeBytes += sizeDiff;\n            const oldValue = existingEntry.value;\n            existingEntry.value = value;\n            existingEntry.metadata.estimatedSize = estimatedSize;\n            logger16.trace(\"Updated existing cache entry\", {\n                key: hashedKey,\n                sizeDiff,\n                currentSize: this.currentSizeBytes,\n                oldValue: oldValue !== value\n            });\n        } else {\n            const metadata = {\n                addedAt: Date.now(),\n                lastAccessedAt: Date.now(),\n                accessCount: 0,\n                estimatedSize,\n                key: hashedKey\n            };\n            this.map[hashedKey] = {\n                originalKey: key,\n                value,\n                metadata\n            };\n            this.currentSizeBytes += estimatedSize;\n            this.currentItemCount++;\n            logger16.trace(\"Added new cache entry\", {\n                key: hashedKey,\n                size: estimatedSize,\n                currentSize: this.currentSizeBytes,\n                currentCount: this.currentItemCount\n            });\n        }\n    }\n    async includesKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null;\n    }\n    async delete(key) {\n        this.deleteInternal(key, true, \"filter\");\n    }\n    deleteInternal(key) {\n        let invalidateQueries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, invalidationMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"remove\";\n        logger16.trace(\"delete\", {\n            key\n        });\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.map[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            this.currentSizeBytes -= entry.metadata.estimatedSize;\n            this.currentItemCount--;\n            delete this.map[hashedKey];\n            logger16.trace(\"Deleted cache entry\", {\n                key: hashedKey,\n                freedSize: entry.metadata.estimatedSize,\n                currentSize: this.currentSizeBytes,\n                currentCount: this.currentItemCount\n            });\n            if (invalidateQueries) {\n                if (invalidationMode === \"filter\") {\n                    this.filterQueriesReferencingKeys([\n                        key\n                    ]);\n                } else {\n                    this.invalidateQueriesReferencingKeys([\n                        key\n                    ]);\n                }\n            }\n        }\n    }\n    async keys() {\n        return Object.values(this.map).filter((entry)=>entry.value !== null).map((entry)=>entry.originalKey);\n    }\n    async values() {\n        return Object.values(this.map).filter((entry)=>entry.value !== null).map((entry)=>entry.value);\n    }\n    async clear() {\n        logger16.debug(\"Clearing cache\", {\n            itemsCleared: this.currentItemCount,\n            bytesFreed: this.currentSizeBytes\n        });\n        this.map = {};\n        this.currentSizeBytes = 0;\n        this.currentItemCount = 0;\n    }\n    async allIn(locations) {\n        const allValues = await this.values();\n        if (locations.length === 0) {\n            logger16.debug(\"Returning all items, LocKeys is empty\");\n            return allValues;\n        } else {\n            logger16.debug(\"allIn\", {\n                locations,\n                count: allValues.length\n            });\n            return allValues.filter((item)=>{\n                const key = item.key;\n                if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n                    return isLocKeyArrayEqual(locations, key.loc);\n                }\n                return false;\n            });\n        }\n    }\n    async contains(query, locations) {\n        logger16.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query) {\n        let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger16.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        const sizeConfig = {};\n        if (this.maxSizeBytes) {\n            sizeConfig.maxSizeBytes = this.maxSizeBytes.toString();\n        }\n        if (this.maxItems) {\n            sizeConfig.maxItems = this.maxItems;\n        }\n        const clone = new _EnhancedMemoryCacheMap(this.types, sizeConfig);\n        const keys = await this.keys();\n        for (const key of keys){\n            const value = await this.get(key);\n            if (value) {\n                await clone.set(key, value);\n            }\n        }\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            await clone.setQueryResult(queryHash, entry.itemKeys);\n        }\n        return clone;\n    }\n    /**\n   * Get current cache statistics\n   */ getStats() {\n        const stats = {\n            currentSizeBytes: this.currentSizeBytes,\n            currentItemCount: this.currentItemCount,\n            maxSizeBytes: this.maxSizeBytes,\n            maxItems: this.maxItems,\n            utilizationPercent: {}\n        };\n        if (this.maxSizeBytes) {\n            stats.utilizationPercent.bytes = this.currentSizeBytes / this.maxSizeBytes * 100;\n        }\n        if (this.maxItems) {\n            stats.utilizationPercent.items = this.currentItemCount / this.maxItems * 100;\n        }\n        return stats;\n    }\n    // Query result caching methods\n    async setQueryResult(queryHash, itemKeys) {\n        logger16.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        if (queryHash in this.queryResultCache) {\n            this.removeQueryResultFromSizeTracking(queryHash);\n        }\n        const entry = {\n            itemKeys: [\n                ...itemKeys\n            ]\n        };\n        this.queryResultCache[queryHash] = entry;\n        this.addQueryResultToSizeTracking(queryHash, entry);\n    }\n    async getQueryResult(queryHash) {\n        logger16.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const entry = this.queryResultCache[queryHash];\n        if (!entry) {\n            return null;\n        }\n        return [\n            ...entry.itemKeys\n        ];\n    }\n    async hasQueryResult(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        return !!entry;\n    }\n    async deleteQueryResult(queryHash) {\n        if (queryHash in this.queryResultCache) {\n            this.removeQueryResultFromSizeTracking(queryHash);\n            delete this.queryResultCache[queryHash];\n        }\n    }\n    async clearQueryResults() {\n        this.queryResultCache = {};\n        this.queryResultsCacheSize = 0;\n    }\n    async invalidateItemKeys(keys) {\n        logger16.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        if (keys.length === 0) {\n            return;\n        }\n        for (const key of keys){\n            this.deleteInternal(key, false);\n        }\n        this.invalidateQueriesReferencingKeys(keys);\n    }\n    filterQueriesReferencingKeys(keys) {\n        if (keys.length === 0) {\n            return;\n        }\n        const hashedKeysToInvalidate = new Set(keys.map((key)=>this.normalizedHashFunction(key)));\n        const queriesToRemove = [];\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            const filteredKeys = entry.itemKeys.filter((itemKey)=>{\n                const hashedItemKey = this.normalizedHashFunction(itemKey);\n                return !hashedKeysToInvalidate.has(hashedItemKey);\n            });\n            if (filteredKeys.length === 0) {\n                queriesToRemove.push(queryHash);\n            } else if (filteredKeys.length !== entry.itemKeys.length) {\n                this.setQueryResult(queryHash, filteredKeys);\n            }\n        }\n        queriesToRemove.forEach((queryHash)=>{\n            this.deleteQueryResult(queryHash);\n        });\n    }\n    invalidateQueriesReferencingKeys(keys) {\n        if (keys.length === 0) {\n            return;\n        }\n        const hashedKeysToInvalidate = new Set(keys.map((key)=>this.normalizedHashFunction(key)));\n        const queriesToRemove = [];\n        for (const [queryHash, entry] of Object.entries(this.queryResultCache)){\n            const queryReferencesInvalidatedKey = entry.itemKeys.some((itemKey)=>{\n                const hashedItemKey = this.normalizedHashFunction(itemKey);\n                return hashedKeysToInvalidate.has(hashedItemKey);\n            });\n            if (queryReferencesInvalidatedKey) {\n                queriesToRemove.push(queryHash);\n            }\n        }\n        queriesToRemove.forEach((queryHash)=>{\n            this.deleteQueryResult(queryHash);\n        });\n    }\n    async invalidateLocation(locations) {\n        logger16.debug(\"invalidateLocation\", {\n            locations\n        });\n        let keysToInvalidate = [];\n        if (locations.length === 0) {\n            const allKeys = await this.keys();\n            const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n            keysToInvalidate = primaryKeys;\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            keysToInvalidate = itemsInLocation.map((item)=>item.key);\n        }\n        await this.invalidateItemKeys(keysToInvalidate);\n    }\n    /**\n   * Add query result to size tracking\n   */ addQueryResultToSizeTracking(queryHash, entry) {\n        const hashSize = estimateValueSize(queryHash);\n        const itemKeysSize = estimateValueSize(entry.itemKeys);\n        const totalSize = hashSize + itemKeysSize;\n        this.queryResultsCacheSize += totalSize;\n        logger16.trace(\"Added query result to size tracking\", {\n            queryHash,\n            estimatedSize: totalSize,\n            totalQueryCacheSize: this.queryResultsCacheSize\n        });\n    }\n    /**\n   * Remove query result from size tracking\n   */ removeQueryResultFromSizeTracking(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        if (entry) {\n            const hashSize = estimateValueSize(queryHash);\n            const itemKeysSize = estimateValueSize(entry.itemKeys);\n            const totalSize = hashSize + itemKeysSize;\n            this.queryResultsCacheSize = Math.max(0, this.queryResultsCacheSize - totalSize);\n            logger16.trace(\"Removed query result from size tracking\", {\n                queryHash,\n                estimatedSize: totalSize,\n                totalQueryCacheSize: this.queryResultsCacheSize\n            });\n        }\n    }\n    /**\n   * Get total cache size including query results\n   */ getTotalSizeBytes() {\n        return this.currentSizeBytes + this.queryResultsCacheSize;\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        const entry = this.map[key];\n        if (entry && !entry.metadataCleared) {\n            return entry.metadata;\n        }\n        return null;\n    }\n    async setMetadata(key, metadata) {\n        const entry = this.map[key];\n        if (entry) {\n            entry.metadata = metadata;\n            entry.metadataCleared = false;\n        } else {\n            let originalKey;\n            try {\n                originalKey = JSON.parse(key);\n            } catch (e) {\n                originalKey = {\n                    kt: \"metadata-only\",\n                    pk: key\n                };\n            }\n            this.map[key] = {\n                originalKey,\n                value: null,\n                // Placeholder value\n                metadata,\n                metadataCleared: false\n            };\n        }\n    }\n    async deleteMetadata(_key) {}\n    async getAllMetadata() {\n        const metadata = /* @__PURE__ */ new Map();\n        for (const [hashedKey, entry] of Object.entries(this.map)){\n            if (!entry.metadataCleared) {\n                metadata.set(hashedKey, entry.metadata);\n            }\n        }\n        return metadata;\n    }\n    async clearMetadata() {\n        const keysToRemove = [];\n        for (const [hashedKey, entry] of Object.entries(this.map)){\n            if (entry.value === null) {\n                keysToRemove.push(hashedKey);\n            } else {\n                entry.metadataCleared = true;\n            }\n        }\n        for (const key of keysToRemove){\n            delete this.map[key];\n        }\n    }\n    async getCurrentSize() {\n        return {\n            itemCount: this.currentItemCount,\n            sizeBytes: this.currentSizeBytes\n        };\n    }\n    async getSizeLimits() {\n        var _this_maxItems, _this_maxSizeBytes;\n        return {\n            maxItems: (_this_maxItems = this.maxItems) !== null && _this_maxItems !== void 0 ? _this_maxItems : null,\n            maxSizeBytes: (_this_maxSizeBytes = this.maxSizeBytes) !== null && _this_maxSizeBytes !== void 0 ? _this_maxSizeBytes : null\n        };\n    }\n    constructor(types, sizeConfig, initialData){\n        super(types), this.implementationType = \"memory/enhanced\", this.map = {}, // Query result cache: maps query hash to cache entry\n        this.queryResultCache = {}, // Size tracking\n        this.currentSizeBytes = 0, this.currentItemCount = 0, this.queryResultsCacheSize = 0;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        if (sizeConfig === null || sizeConfig === void 0 ? void 0 : sizeConfig.maxSizeBytes) {\n            this.maxSizeBytes = parseSizeString(sizeConfig.maxSizeBytes);\n            logger16.debug(\"Cache size limit set\", {\n                maxSizeBytes: this.maxSizeBytes\n            });\n        }\n        if (sizeConfig === null || sizeConfig === void 0 ? void 0 : sizeConfig.maxItems) {\n            this.maxItems = sizeConfig.maxItems;\n            logger16.debug(\"Cache item limit set\", {\n                maxItems: this.maxItems\n            });\n        }\n        if (initialData) {\n            for (const [keyStr, value] of Object.entries(initialData)){\n                try {\n                    const key = JSON.parse(keyStr);\n                    this.set(key, value);\n                } catch (error) {\n                    logger16.error(\"Failed to parse initial data key\", {\n                        keyStr,\n                        error\n                    });\n                }\n            }\n        }\n    }\n};\n// src/browser/LocalStorageCacheMap.ts\n\nvar logger17 = logger_default.get(\"LocalStorageCacheMap\");\nvar LocalStorageCacheMap = class _LocalStorageCacheMap extends CacheMap {\n    getStorageKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        return \"\".concat(this.keyPrefix, \":\").concat(hashedKey);\n    }\n    isQuotaExceededError(error) {\n        return error && (error.name === \"QuotaExceededError\" || error.name === \"NS_ERROR_DOM_QUOTA_REACHED\" || error.code === 22 || error.code === 1014);\n    }\n    getAllKeysStartingWith(prefix) {\n        const keys = [];\n        try {\n            for(let i = 0; i < localStorage.length; i++){\n                const key = localStorage.key(i);\n                if (key && key.startsWith(prefix)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        } catch (error) {\n            logger17.error(\"Error getting keys by prefix from localStorage\", {\n                prefix,\n                error\n            });\n            throw error;\n        }\n    }\n    tryCleanupOldEntries() {\n        let aggressive = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        try {\n            const allEntries = this.collectCacheEntries();\n            if (allEntries.length === 0) {\n                logger17.debug(\"No entries to clean up\");\n                return false;\n            }\n            return this.removeOldestEntries(allEntries, aggressive);\n        } catch (error) {\n            logger17.error(\"Failed to cleanup old localStorage entries\", {\n                error\n            });\n            return false;\n        }\n    }\n    collectCacheEntries() {\n        const allEntries = [];\n        const keys = this.getAllStorageKeys();\n        for (const key of keys){\n            if (key.includes(\":metadata:\") || key.includes(\":query:\")) {\n                continue;\n            }\n            try {\n                const stored = localStorage.getItem(key);\n                if (stored) {\n                    const parsed = JSON.parse(stored);\n                    if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed) {\n                        allEntries.push({\n                            key,\n                            timestamp: parsed.timestamp || Date.now(),\n                            size: stored.length\n                        });\n                    } else {\n                        allEntries.push({\n                            key,\n                            timestamp: 0,\n                            size: stored.length\n                        });\n                    }\n                }\n            } catch (error) {\n                logger17.debug(\"Found corrupted entry during cleanup\", {\n                    key,\n                    error\n                });\n                allEntries.push({\n                    key,\n                    timestamp: 0,\n                    size: 0\n                });\n            }\n        }\n        return allEntries;\n    }\n    removeOldestEntries(allEntries) {\n        let aggressive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        allEntries.sort((a, b)=>a.timestamp - b.timestamp);\n        const cleanupPercentage = aggressive ? this.AGGRESSIVE_CLEANUP_PERCENTAGE : 0.25;\n        const toRemove = Math.max(1, Math.ceil(allEntries.length * cleanupPercentage));\n        let removedCount = 0;\n        let removedSize = 0;\n        for(let i = 0; i < toRemove && i < allEntries.length; i++){\n            try {\n                const key = allEntries[i].key;\n                localStorage.removeItem(key);\n                removedCount++;\n                removedSize += allEntries[i].size;\n            } catch (error) {\n                logger17.error(\"Failed to remove entry during cleanup\", {\n                    key: allEntries[i].key,\n                    error\n                });\n            }\n        }\n        if (removedCount > 0) {\n            const cleanupType = aggressive ? \"aggressive\" : \"normal\";\n            logger17.info(\"Cleaned up \".concat(removedCount, \" old localStorage entries (\").concat(removedSize, \" bytes) using \").concat(cleanupType, \" cleanup to free space\"));\n        }\n        return removedCount > 0;\n    }\n    getAllStorageKeys() {\n        return this.getAllKeysStartingWith(\"\".concat(this.keyPrefix, \":\"));\n    }\n    async get(key) {\n        logger17.trace(\"get\", {\n            key\n        });\n        try {\n            const storageKey = this.getStorageKey(key);\n            let stored = localStorage.getItem(storageKey);\n            if (!stored && typeof (key === null || key === void 0 ? void 0 : key.kt) === \"string\" && (key === null || key === void 0 ? void 0 : key.pk)) {\n                const legacyKey = \"\".concat(this.keyPrefix, \":\").concat(key.kt, \":\").concat(key.pk);\n                stored = localStorage.getItem(legacyKey);\n            }\n            if (stored) {\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key)) {\n                        return parsed.value;\n                    }\n                } catch (parseError) {\n                    logger17.debug(\"Failed to parse stored value\", {\n                        key,\n                        error: parseError\n                    });\n                    return null;\n                }\n            }\n            return null;\n        } catch (error) {\n            logger17.error(\"Error retrieving from localStorage\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    async set(key, value) {\n        logger17.trace(\"set\", {\n            key,\n            value\n        });\n        for(let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++){\n            try {\n                const storageKey = this.getStorageKey(key);\n                const toStore = {\n                    originalKey: key,\n                    value,\n                    timestamp: Date.now()\n                };\n                localStorage.setItem(storageKey, JSON.stringify(toStore));\n                if (attempt > 0) {\n                    logger17.info(\"Successfully stored item after \".concat(attempt, \" retries\"));\n                }\n                return;\n            } catch (error) {\n                const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n                logger17.error(\"Error storing to localStorage (attempt \".concat(attempt + 1, \"/\").concat(this.MAX_RETRY_ATTEMPTS, \")\"), {\n                    key,\n                    value,\n                    error,\n                    isLastAttempt\n                });\n                if (this.isQuotaExceededError(error)) {\n                    const useAggressiveCleanup = attempt > 0;\n                    this.tryCleanupOldEntries(useAggressiveCleanup);\n                    if (isLastAttempt) {\n                        throw new Error(\"Failed to store item in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n                    }\n                    continue;\n                }\n                throw new Error(\"Failed to store item in localStorage: \".concat(error instanceof Error ? error.message : String(error)));\n            }\n        }\n    }\n    async includesKey(key) {\n        try {\n            const storageKey = this.getStorageKey(key);\n            const stored = localStorage.getItem(storageKey);\n            if (stored) {\n                try {\n                    const parsed = JSON.parse(stored);\n                    return this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key);\n                } catch (parseError) {\n                    logger17.debug(\"Failed to parse stored value in includesKey\", {\n                        key,\n                        error: parseError\n                    });\n                    return false;\n                }\n            }\n            return false;\n        } catch (error) {\n            logger17.error(\"Error checking key in localStorage\", {\n                key,\n                error\n            });\n            return false;\n        }\n    }\n    async delete(key) {\n        logger17.trace(\"delete\", {\n            key\n        });\n        try {\n            const storageKey = this.getStorageKey(key);\n            localStorage.removeItem(storageKey);\n        } catch (error) {\n            logger17.error(\"Error deleting from localStorage\", {\n                key,\n                error\n            });\n            throw error;\n        }\n    }\n    async allIn(locations) {\n        const allKeys = this.keys();\n        if (locations.length === 0) {\n            logger17.debug(\"Returning all items, LocKeys is empty\");\n            const items = [];\n            for (const key of (await allKeys)){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        } else {\n            const locKeys = locations;\n            const resolvedKeys = await allKeys;\n            logger17.debug(\"allIn\", {\n                locKeys,\n                keys: resolvedKeys.length\n            });\n            const filteredKeys = resolvedKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                const ComKey13 = key;\n                logger17.debug(\"Comparing Location Keys\", {\n                    locKeys,\n                    ComKey: ComKey13\n                });\n                return isLocKeyArrayEqual(locKeys, ComKey13.loc);\n            });\n            const items = [];\n            for (const key of filteredKeys){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        }\n    }\n    async contains(query, locations) {\n        logger17.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query) {\n        let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger17.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        return new _LocalStorageCacheMap(this.types, this.keyPrefix);\n    }\n    parseStorageEntry(storageKey) {\n        try {\n            const stored = localStorage.getItem(storageKey);\n            if (stored) {\n                return JSON.parse(stored);\n            }\n        } catch (parseError) {\n            logger17.debug(\"Skipping corrupted localStorage entry\", {\n                storageKey,\n                error: parseError\n            });\n        }\n        return null;\n    }\n    async keys() {\n        const keys = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const parsed = this.parseStorageEntry(storageKey);\n                if (parsed === null || parsed === void 0 ? void 0 : parsed.originalKey) {\n                    keys.push(parsed.originalKey);\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error getting keys from localStorage\", {\n                error\n            });\n        }\n        return keys;\n    }\n    async values() {\n        const values = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const parsed = this.parseStorageEntry(storageKey);\n                if (parsed === null || parsed === void 0 ? void 0 : parsed.value) {\n                    values.push(parsed.value);\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error getting values from localStorage\", {\n                error\n            });\n        }\n        return values;\n    }\n    async clear() {\n        logger17.debug(\"Clearing localStorage cache\");\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                localStorage.removeItem(storageKey);\n            }\n        } catch (error) {\n            logger17.error(\"Error clearing localStorage cache\", {\n                error\n            });\n            throw error;\n        }\n    }\n    // Query result caching methods implementation\n    async setQueryResult(queryHash, itemKeys) {\n        logger17.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        const entry = {\n            itemKeys\n        };\n        try {\n            localStorage.setItem(queryKey, JSON.stringify(entry));\n        } catch (error) {\n            logger17.error(\"Failed to store query result in localStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async getQueryResult(queryHash) {\n        logger17.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        try {\n            const data = localStorage.getItem(queryKey);\n            if (!data) {\n                return null;\n            }\n            const entry = JSON.parse(data);\n            if (Array.isArray(entry)) {\n                return entry;\n            }\n            return entry.itemKeys || null;\n        } catch (error) {\n            logger17.error(\"Failed to retrieve query result from localStorage\", {\n                queryHash,\n                error\n            });\n            return null;\n        }\n    }\n    async hasQueryResult(queryHash) {\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        try {\n            return localStorage.getItem(queryKey) !== null;\n        } catch (error) {\n            logger17.error(\"Failed to check query result in localStorage\", {\n                queryHash,\n                error\n            });\n            return false;\n        }\n    }\n    async deleteQueryResult(queryHash) {\n        logger17.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        try {\n            localStorage.removeItem(queryKey);\n        } catch (error) {\n            logger17.error(\"Failed to delete query result from localStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async invalidateItemKeys(keys) {\n        logger17.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            try {\n                await this.delete(key);\n            } catch (error) {\n                logger17.error(\"Failed to delete key during invalidation\", {\n                    key,\n                    error\n                });\n            }\n        }\n    }\n    async invalidateLocation(locations) {\n        logger17.debug(\"invalidateLocation\", {\n            locations\n        });\n        try {\n            if (locations.length === 0) {\n                const allKeys = await this.keys();\n                const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n                await this.invalidateItemKeys(primaryKeys);\n            } else {\n                const allKeys = await this.keys();\n                const keysToInvalidate = allKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                    const compositeKey = key;\n                    return isLocKeyArrayEqual(locations, compositeKey.loc);\n                });\n                await this.invalidateItemKeys(keysToInvalidate);\n            }\n            await this.clearQueryResults();\n        } catch (error) {\n            logger17.error(\"Error in invalidateLocation\", {\n                locations,\n                error\n            });\n        }\n    }\n    async clearQueryResults() {\n        logger17.trace(\"clearQueryResults\");\n        const queryPrefix = \"\".concat(this.keyPrefix, \":query:\");\n        try {\n            const keysToRemove = this.getAllKeysStartingWith(queryPrefix);\n            for (const key of keysToRemove){\n                try {\n                    localStorage.removeItem(key);\n                } catch (error) {\n                    logger17.error(\"Failed to remove query result from localStorage\", {\n                        key,\n                        error\n                    });\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Failed to clear query results from localStorage\", {\n                error\n            });\n        }\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        try {\n            const metadataKey = \"\".concat(this.keyPrefix, \":metadata:\").concat(key);\n            const stored = localStorage.getItem(metadataKey);\n            if (stored) {\n                try {\n                    return JSON.parse(stored);\n                } catch (e) {\n                    logger17.debug(\"Invalid metadata JSON, treating as null\", {\n                        key,\n                        error: e\n                    });\n                    return null;\n                }\n            }\n            return null;\n        } catch (error) {\n            logger17.error(\"Error getting metadata from localStorage\", {\n                key,\n                error\n            });\n            throw error;\n        }\n    }\n    async setMetadata(key, metadata) {\n        for(let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++){\n            try {\n                const metadataKey = \"\".concat(this.keyPrefix, \":metadata:\").concat(key);\n                localStorage.setItem(metadataKey, JSON.stringify(metadata));\n                if (attempt > 0) {\n                    logger17.info(\"Successfully stored metadata after \".concat(attempt, \" retries\"));\n                }\n                return;\n            } catch (error) {\n                const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n                logger17.error(\"Error storing metadata to localStorage (attempt \".concat(attempt + 1, \"/\").concat(this.MAX_RETRY_ATTEMPTS, \")\"), {\n                    key,\n                    error,\n                    isLastAttempt\n                });\n                if (this.isQuotaExceededError(error)) {\n                    const useAggressiveCleanup = attempt > 0;\n                    this.tryCleanupOldEntries(useAggressiveCleanup);\n                    if (isLastAttempt) {\n                        throw new Error(\"Failed to store metadata in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n                    }\n                    continue;\n                }\n                throw new Error(\"Failed to store metadata in localStorage: \".concat(error instanceof Error ? error.message : String(error)));\n            }\n        }\n    }\n    async deleteMetadata(key) {\n        try {\n            const metadataKey = \"\".concat(this.keyPrefix, \":metadata:\").concat(key);\n            localStorage.removeItem(metadataKey);\n        } catch (error) {\n            logger17.error(\"Error deleting metadata from localStorage\", {\n                key,\n                error\n            });\n            throw error;\n        }\n    }\n    async getAllMetadata() {\n        const metadata = /* @__PURE__ */ new Map();\n        try {\n            const metadataPrefix = \"\".concat(this.keyPrefix, \":metadata:\");\n            const metaKeys = this.getAllKeysStartingWith(metadataPrefix);\n            for (const key of metaKeys){\n                const metadataKey = key.substring(metadataPrefix.length);\n                const stored = localStorage.getItem(key);\n                if (!stored) continue;\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (parsed && typeof parsed === \"object\") {\n                        metadata.set(metadataKey, parsed);\n                    }\n                } catch (error) {\n                    logger17.debug(\"Skipping invalid metadata entry\", {\n                        key,\n                        error\n                    });\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error getting metadata from localStorage\", {\n                error\n            });\n            throw error;\n        }\n        return metadata;\n    }\n    async clearMetadata() {\n        try {\n            const metadataPrefix = \"\".concat(this.keyPrefix, \":metadata:\");\n            const keysToDelete = this.getAllKeysStartingWith(metadataPrefix);\n            keysToDelete.forEach((key)=>localStorage.removeItem(key));\n        } catch (error) {\n            logger17.error(\"Error clearing metadata from localStorage\", {\n                error\n            });\n            throw error;\n        }\n    }\n    async getCurrentSize() {\n        let itemCount = 0;\n        let sizeBytes = 0;\n        try {\n            const keys = this.getAllStorageKeys();\n            for (const key of keys){\n                const value = localStorage.getItem(key);\n                if (!value) continue;\n                try {\n                    if (typeof Blob !== \"undefined\") {\n                        sizeBytes += new Blob([\n                            value\n                        ]).size;\n                    } else if (typeof TextEncoder !== \"undefined\") {\n                        sizeBytes += new TextEncoder().encode(value).length;\n                    } else if (typeof globalThis.Buffer !== \"undefined\") {\n                        sizeBytes += globalThis.Buffer.byteLength(value, \"utf8\");\n                    } else {\n                        sizeBytes += value.length;\n                    }\n                    if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n                        try {\n                            const parsed = JSON.parse(value);\n                            if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed && \"value\" in parsed) {\n                                itemCount++;\n                            }\n                        } catch (error) {\n                            logger17.debug(\"Invalid entry in getCurrentSize\", {\n                                key,\n                                error\n                            });\n                        }\n                    }\n                } catch (error) {\n                    logger17.debug(\"Size calculation failed, using string length\", {\n                        key,\n                        error\n                    });\n                    sizeBytes += value.length;\n                }\n            }\n        } catch (error) {\n            logger17.error(\"Error calculating size from localStorage\", {\n                error\n            });\n            throw error;\n        }\n        return {\n            itemCount,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            // No specific item limit\n            maxSizeBytes: 5 * 1024 * 1024\n        };\n    }\n    // Remove 50% of entries when quota exceeded\n    constructor(types, keyPrefix = \"fjell-cache\"){\n        super(types), this.implementationType = \"browser/localStorage\", this.MAX_RETRY_ATTEMPTS = 3, this.AGGRESSIVE_CLEANUP_PERCENTAGE = 0.5;\n        this.keyPrefix = keyPrefix;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n    }\n};\n// src/browser/SessionStorageCacheMap.ts\n\n\nvar logger18 = logger_default.get(\"SessionStorageCacheMap\");\nvar SessionStorageCacheMap = class _SessionStorageCacheMap extends CacheMap {\n    getStorageKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        return \"\".concat(this.keyPrefix, \":\").concat(hashedKey);\n    }\n    // Using flatted for safe circular serialization; no manual replacer needed\n    getAllStorageKeys() {\n        const keys = [];\n        try {\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (key && key.startsWith(\"\".concat(this.keyPrefix, \":\"))) {\n                    keys.push(key);\n                }\n            }\n        } catch (error) {\n            logger18.error(\"Error getting keys from sessionStorage\", {\n                error\n            });\n        }\n        return keys;\n    }\n    // Detect if current normalized hash function collapses multiple stored items into the same hash\n    hasCollisionForHash(targetHash) {\n        try {\n            const storageKey = \"\".concat(this.keyPrefix, \":\").concat(targetHash);\n            const raw = sessionStorage.getItem(storageKey);\n            if (!raw) return false;\n            const parsed = JSON.parse(raw);\n            if (!(parsed === null || parsed === void 0 ? void 0 : parsed.originalKey)) return false;\n            const storedVerificationHash = parsed.originalVerificationHash;\n            const currentVerificationHash = this.verificationHashFunction(parsed.originalKey);\n            if (storedVerificationHash === currentVerificationHash) {\n                return false;\n            }\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async get(key) {\n        logger18.trace(\"get\", {\n            key\n        });\n        try {\n            const currentHash = this.normalizedHashFunction(key);\n            if (this.hasCollisionForHash(currentHash)) {\n                return null;\n            }\n            const storageKey = this.getStorageKey(key);\n            const stored = sessionStorage.getItem(storageKey);\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                const storedVerificationHash = parsed.originalVerificationHash;\n                const currentVerificationHash = this.verificationHashFunction(key);\n                const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n                if (storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey) {\n                    if (parsed.value == null) return null;\n                    return parsed.value;\n                }\n            }\n            return null;\n        } catch (error) {\n            logger18.error(\"Error retrieving from sessionStorage\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    async set(key, value) {\n        try {\n            const storageKey = this.getStorageKey(key);\n            logger18.trace(\"set\", {\n                storageKey\n            });\n            const toStore = {\n                originalKey: key,\n                value,\n                timestamp: Date.now(),\n                originalVerificationHash: this.verificationHashFunction(key)\n            };\n            const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(toStore);\n            sessionStorage.setItem(storageKey, jsonString);\n        } catch (error) {\n            logger18.error(\"Error storing to sessionStorage\", {\n                errorMessage: error === null || error === void 0 ? void 0 : error.message\n            });\n            throw new Error(\"Failed to store item in sessionStorage: \".concat(error));\n        }\n    }\n    async includesKey(key) {\n        try {\n            const currentHash = this.normalizedHashFunction(key);\n            if (this.hasCollisionForHash(currentHash)) {\n                return false;\n            }\n            const storageKey = this.getStorageKey(key);\n            const stored = sessionStorage.getItem(storageKey);\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                const storedVerificationHash = parsed.originalVerificationHash;\n                const currentVerificationHash = this.verificationHashFunction(key);\n                const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n                return !!storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey;\n            }\n            return false;\n        } catch (error) {\n            logger18.error(\"Error checking key in sessionStorage\", {\n                key,\n                error\n            });\n            return false;\n        }\n    }\n    async delete(key) {\n        logger18.trace(\"delete\", {\n            key\n        });\n        try {\n            const storageKey = this.getStorageKey(key);\n            sessionStorage.removeItem(storageKey);\n        } catch (error) {\n            logger18.error(\"Error deleting from sessionStorage\", {\n                key,\n                error\n            });\n        }\n    }\n    async allIn(locations) {\n        const allKeys = this.keys();\n        if (locations.length === 0) {\n            logger18.debug(\"Returning all items, LocKeys is empty\");\n            const items = [];\n            for (const key of (await allKeys)){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        } else {\n            const locKeys = locations;\n            const resolvedKeys = await allKeys;\n            logger18.debug(\"allIn\", {\n                locKeys,\n                keys: resolvedKeys.length\n            });\n            const filteredKeys = resolvedKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                const ComKey13 = key;\n                logger18.debug(\"Comparing Location Keys\", {\n                    locKeys,\n                    ComKey: ComKey13\n                });\n                return isLocKeyArrayEqual(locKeys, ComKey13.loc);\n            });\n            const items = [];\n            for (const key of filteredKeys){\n                const item = await this.get(key);\n                if (item !== null) {\n                    items.push(item);\n                }\n            }\n            return items;\n        }\n    }\n    async contains(query, locations) {\n        logger18.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query) {\n        let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger18.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async clone() {\n        return new _SessionStorageCacheMap(this.types, this.keyPrefix);\n    }\n    async keys() {\n        const keys = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const stored = sessionStorage.getItem(storageKey);\n                if (!stored) continue;\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (parsed.originalKey) {\n                        keys.push(parsed.originalKey);\n                    }\n                } catch (itemError) {\n                    logger18.trace(\"Skipping invalid storage item\", {\n                        storageKey,\n                        error: itemError\n                    });\n                }\n            }\n        } catch (error) {\n            logger18.error(\"Error getting keys from sessionStorage\", {\n                error\n            });\n        }\n        return keys;\n    }\n    async values() {\n        const values = [];\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                const stored = sessionStorage.getItem(storageKey);\n                if (!stored) continue;\n                try {\n                    const parsed = JSON.parse(stored);\n                    if (parsed.value != null) {\n                        values.push(parsed.value);\n                    }\n                } catch (itemError) {\n                    logger18.trace(\"Skipping invalid storage item for values\", {\n                        storageKey,\n                        error: itemError\n                    });\n                }\n            }\n        } catch (error) {\n            logger18.error(\"Error getting values from sessionStorage\", {\n                error\n            });\n        }\n        return values;\n    }\n    async clear() {\n        logger18.debug(\"Clearing sessionStorage cache\");\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const storageKey of storageKeys){\n                sessionStorage.removeItem(storageKey);\n            }\n        } catch (error) {\n            logger18.error(\"Error clearing sessionStorage cache\", {\n                error\n            });\n        }\n    }\n    // Query result caching methods implementation\n    async setQueryResult(queryHash, itemKeys) {\n        logger18.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        const entry = {\n            itemKeys\n        };\n        try {\n            const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry);\n            sessionStorage.setItem(queryKey, jsonString);\n        } catch (error) {\n            logger18.error(\"Failed to store query result in sessionStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async getQueryResult(queryHash) {\n        logger18.trace(\"getQueryResult\", {\n            queryHash\n        });\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        try {\n            const data = sessionStorage.getItem(queryKey);\n            if (!data) {\n                return null;\n            }\n            const entry = JSON.parse(data);\n            if (Array.isArray(entry)) {\n                return entry;\n            }\n            return entry.itemKeys || null;\n        } catch (error) {\n            logger18.error(\"Failed to retrieve query result from sessionStorage\", {\n                queryHash,\n                error\n            });\n            return null;\n        }\n    }\n    async hasQueryResult(queryHash) {\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        try {\n            return sessionStorage.getItem(queryKey) !== null;\n        } catch (error) {\n            logger18.error(\"Failed to check query result in sessionStorage\", {\n                queryHash,\n                error\n            });\n            return false;\n        }\n    }\n    async deleteQueryResult(queryHash) {\n        logger18.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        const queryKey = \"\".concat(this.keyPrefix, \":query:\").concat(queryHash);\n        try {\n            sessionStorage.removeItem(queryKey);\n        } catch (error) {\n            logger18.error(\"Failed to delete query result from sessionStorage\", {\n                queryHash,\n                error\n            });\n        }\n    }\n    async invalidateItemKeys(keys) {\n        logger18.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            await this.delete(key);\n        }\n    }\n    async invalidateLocation(locations) {\n        logger18.debug(\"invalidateLocation\", {\n            locations\n        });\n        if (locations.length === 0) {\n            const allKeys = await this.keys();\n            const primaryKeys = allKeys.filter((key)=>!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n            await this.invalidateItemKeys(primaryKeys);\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            const keysToInvalidate = itemsInLocation.map((item)=>item.key);\n            await this.invalidateItemKeys(keysToInvalidate);\n        }\n        await this.clearQueryResults();\n    }\n    async clearQueryResults() {\n        logger18.trace(\"clearQueryResults\");\n        const queryPrefix = \"\".concat(this.keyPrefix, \":query:\");\n        try {\n            const keysToRemove = [];\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (key && key.startsWith(queryPrefix)) {\n                    keysToRemove.push(key);\n                }\n            }\n            keysToRemove.forEach((key)=>sessionStorage.removeItem(key));\n        } catch (error) {\n            logger18.error(\"Failed to clear query results from sessionStorage\", {\n                error\n            });\n        }\n    }\n    // CacheMapMetadataProvider implementation\n    async getMetadata(key) {\n        try {\n            const metadataKey = \"\".concat(this.keyPrefix, \":metadata:\").concat(key);\n            const stored = sessionStorage.getItem(metadataKey);\n            return stored ? JSON.parse(stored) : null;\n        } catch (e) {\n            return null;\n        }\n    }\n    async setMetadata(key, metadata) {\n        try {\n            const metadataKey = \"\".concat(this.keyPrefix, \":metadata:\").concat(key);\n            const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(metadata);\n            sessionStorage.setItem(metadataKey, jsonString);\n        } catch (e) {}\n    }\n    async deleteMetadata(key) {\n        try {\n            const metadataKey = \"\".concat(this.keyPrefix, \":metadata:\").concat(key);\n            sessionStorage.removeItem(metadataKey);\n        } catch (e) {}\n    }\n    async getAllMetadata() {\n        const metadata = /* @__PURE__ */ new Map();\n        const metadataPrefix = \"\".concat(this.keyPrefix, \":metadata:\");\n        try {\n            let foundAny = false;\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (!key || !key.startsWith(metadataPrefix)) continue;\n                foundAny = true;\n                const metadataKey = key.substring(metadataPrefix.length);\n                const stored = sessionStorage.getItem(key);\n                if (!stored) continue;\n                try {\n                    metadata.set(metadataKey, JSON.parse(stored));\n                } catch (e) {}\n            }\n            return metadata;\n        } catch (error) {\n            logger18.error(\"Error getting all metadata from sessionStorage\", {\n                error\n            });\n            return metadata;\n        }\n    }\n    async clearMetadata() {\n        try {\n            const metadataPrefix = \"\".concat(this.keyPrefix, \":metadata:\");\n            const keysToDelete = [];\n            for(let i = 0; i < sessionStorage.length; i++){\n                const key = sessionStorage.key(i);\n                if (key && key.startsWith(metadataPrefix)) {\n                    keysToDelete.push(key);\n                }\n            }\n            keysToDelete.forEach((key)=>sessionStorage.removeItem(key));\n        } catch (e) {}\n    }\n    async getCurrentSize() {\n        let itemCount = 0;\n        let sizeBytes = 0;\n        try {\n            sessionStorage.key(0);\n        } catch (e) {\n            return {\n                itemCount: 0,\n                sizeBytes: 0\n            };\n        }\n        try {\n            const storageKeys = this.getAllStorageKeys();\n            for (const key of storageKeys){\n                if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n                    try {\n                        const value = sessionStorage.getItem(key);\n                        if (value) {\n                            const parsed = JSON.parse(value);\n                            if ((parsed === null || parsed === void 0 ? void 0 : parsed.originalKey) && (parsed === null || parsed === void 0 ? void 0 : parsed.originalVerificationHash) === this.verificationHashFunction(parsed.originalKey)) {\n                                itemCount++;\n                                sizeBytes += new Blob([\n                                    value\n                                ]).size;\n                            }\n                        }\n                    } catch (e) {}\n                }\n            }\n        } catch (e) {\n            return {\n                itemCount: 0,\n                sizeBytes: 0\n            };\n        }\n        return {\n            itemCount,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            // No specific item limit\n            maxSizeBytes: 5 * 1024 * 1024\n        };\n    }\n    constructor(types, keyPrefix = \"fjell-session-cache\"){\n        super(types), this.implementationType = \"browser/sessionStorage\";\n        this.keyPrefix = keyPrefix;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        this.verificationHashFunction = createNormalizedHashFunction();\n    }\n};\n// src/browser/IndexDBCacheMap.ts\n\n// src/browser/AsyncIndexDBCacheMap.ts\n\n\nvar logger19 = logger_default.get(\"AsyncIndexDBCacheMap\");\nvar AsyncIndexDBCacheMap = (__AsyncIndexDBCacheMap = class _AsyncIndexDBCacheMap {\n    async getDB() {\n        if (!this.dbPromise) {\n            this.dbPromise = new Promise((resolve, reject)=>{\n                if (typeof indexedDB === \"undefined\") {\n                    reject(new Error(\"IndexedDB is not available in this environment\"));\n                    return;\n                }\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Error opening IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    logger19.debug(\"IndexedDB opened successfully\");\n                    resolve(request.result);\n                };\n                request.onupgradeneeded = (event)=>{\n                    logger19.debug(\"IndexedDB upgrade needed\");\n                    const db = event.target.result;\n                    if (!db.objectStoreNames.contains(this.storeName)) {\n                        db.createObjectStore(this.storeName);\n                        logger19.debug(\"Created object store\", {\n                            storeName: this.storeName\n                        });\n                    }\n                };\n            });\n        }\n        return this.dbPromise;\n    }\n    getStorageKey(key) {\n        return this.normalizedHashFunction(key);\n    }\n    async get(key) {\n        logger19.trace(\"get\", {\n            key\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.get(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting from IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const stored = request.result;\n                    if (stored && this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key)) {\n                        resolve(stored.value);\n                    } else {\n                        resolve(null);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB get operation\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    /**\n   * Get both the value and metadata for an item\n   */ async getWithMetadata(key) {\n        logger19.trace(\"getWithMetadata\", {\n            key\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.get(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting from IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const stored = request.result;\n                    if (stored && this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key)) {\n                        resolve({\n                            value: stored.value,\n                            metadata: stored.metadata\n                        });\n                    } else {\n                        resolve(null);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB getWithMetadata operation\", {\n                key,\n                error\n            });\n            return null;\n        }\n    }\n    async set(key, value, metadata) {\n        logger19.trace(\"set\", {\n            key,\n            value,\n            hasMetadata: !!metadata\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readwrite\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            const storedItem = {\n                originalKey: key,\n                value,\n                metadata,\n                version: _AsyncIndexDBCacheMap.CURRENT_VERSION\n            };\n            return new Promise((resolve, reject)=>{\n                const request = store.put(storedItem, storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error setting in IndexedDB\", {\n                        key,\n                        value,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    resolve();\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB set operation\", {\n                key,\n                value,\n                error\n            });\n            throw new Error(\"Failed to store item in IndexedDB: \".concat(error));\n        }\n    }\n    /**\n   * Update only the metadata for an existing item\n   */ async setMetadata(key, metadata) {\n        logger19.trace(\"setMetadata\", {\n            key,\n            metadata\n        });\n        try {\n            const existing = await this.getWithMetadata(key);\n            if (existing) {\n                await this.set(key, existing.value, metadata);\n            } else {\n                logger19.warning(\"Attempted to set metadata for non-existent item\", {\n                    key\n                });\n            }\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB setMetadata operation\", {\n                key,\n                error\n            });\n            throw new Error(\"Failed to update metadata in IndexedDB: \".concat(error));\n        }\n    }\n    async includesKey(key) {\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.get(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error checking key in IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const stored = request.result;\n                    if (stored) {\n                        const matches = this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key);\n                        resolve(matches);\n                    } else {\n                        resolve(false);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB includesKey operation\", {\n                key,\n                error\n            });\n            return false;\n        }\n    }\n    async delete(key) {\n        logger19.trace(\"delete\", {\n            key\n        });\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readwrite\");\n            const store = transaction.objectStore(this.storeName);\n            const storageKey = this.getStorageKey(key);\n            return new Promise((resolve, reject)=>{\n                const request = store.delete(storageKey);\n                request.onerror = ()=>{\n                    logger19.error(\"Error deleting from IndexedDB\", {\n                        key,\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    resolve();\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB delete operation\", {\n                key,\n                error\n            });\n        }\n    }\n    async allIn(locations) {\n        const allKeys = await this.keys();\n        if (locations.length === 0) {\n            logger19.debug(\"Returning all items, LocKeys is empty\");\n            const promises = allKeys.map((key)=>this.get(key));\n            const results = await Promise.all(promises);\n            return results.filter((item)=>item !== null);\n        } else {\n            const locKeys = locations;\n            logger19.debug(\"allIn\", {\n                locKeys,\n                keys: allKeys.length\n            });\n            const filteredKeys = allKeys.filter((key)=>key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key)=>{\n                const ComKey13 = key;\n                logger19.debug(\"Comparing Location Keys\", {\n                    locKeys,\n                    ComKey: ComKey13\n                });\n                return isLocKeyArrayEqual(locKeys, ComKey13.loc);\n            });\n            const promises = filteredKeys.map((key)=>this.get(key));\n            const results = await Promise.all(promises);\n            return results.filter((item)=>item !== null);\n        }\n    }\n    async contains(query, locations) {\n        logger19.debug(\"contains\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.some((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    async queryIn(query) {\n        let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger19.debug(\"queryIn\", {\n            query,\n            locations\n        });\n        const items = await this.allIn(locations);\n        return items.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    clone() {\n        return new _AsyncIndexDBCacheMap(this.types, this.dbName, this.storeName, this.version);\n    }\n    async keys() {\n        const keys = [];\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.openCursor();\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting keys from IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = (event)=>{\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        const stored = cursor.value;\n                        keys.push(stored.originalKey);\n                        cursor.continue();\n                    } else {\n                        resolve(keys);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB keys operation\", {\n                error\n            });\n            return [];\n        }\n    }\n    /**\n   * Get all metadata entries from IndexedDB\n   */ async getAllMetadata() {\n        const metadataMap = /* @__PURE__ */ new Map();\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.openCursor();\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting metadata from IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = (event)=>{\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        const stored = cursor.value;\n                        if (stored.metadata) {\n                            const keyStr = JSON.stringify(stored.originalKey);\n                            metadataMap.set(keyStr, stored.metadata);\n                        }\n                        cursor.continue();\n                    } else {\n                        resolve(metadataMap);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB getAllMetadata operation\", {\n                error\n            });\n            return metadataMap;\n        }\n    }\n    async values() {\n        const values = [];\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readonly\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.openCursor();\n                request.onerror = ()=>{\n                    logger19.error(\"Error getting values from IndexedDB\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = (event)=>{\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        const stored = cursor.value;\n                        values.push(stored.value);\n                        cursor.continue();\n                    } else {\n                        resolve(values);\n                    }\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB values operation\", {\n                error\n            });\n            return [];\n        }\n    }\n    async clear() {\n        logger19.debug(\"Clearing IndexedDB cache\");\n        try {\n            const db = await this.getDB();\n            const transaction = db.transaction([\n                this.storeName\n            ], \"readwrite\");\n            const store = transaction.objectStore(this.storeName);\n            return new Promise((resolve, reject)=>{\n                const request = store.clear();\n                request.onerror = ()=>{\n                    logger19.error(\"Error clearing IndexedDB cache\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    resolve();\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in IndexedDB clear operation\", {\n                error\n            });\n        }\n    }\n    // Async Query result caching methods\n    async setQueryResult(queryHash, itemKeys) {\n        logger19.trace(\"setQueryResult\", {\n            queryHash,\n            itemKeys\n        });\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for setQueryResult\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readwrite\");\n                    const store = transaction.objectStore(this.storeName);\n                    const entry = {\n                        itemKeys\n                    };\n                    const queryKey = \"query:\".concat(queryHash);\n                    const putRequest = store.put(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry), queryKey);\n                    putRequest.onerror = ()=>{\n                        logger19.error(\"Failed to store query result\", {\n                            queryHash,\n                            error: putRequest.error\n                        });\n                        reject(putRequest.error);\n                    };\n                    putRequest.onsuccess = ()=>{\n                        resolve();\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in setQueryResult\", {\n                queryHash,\n                error\n            });\n            throw error;\n        }\n    }\n    async getQueryResult(queryHash) {\n        logger19.trace(\"getQueryResult\", {\n            queryHash\n        });\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for getQueryResult\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readonly\");\n                    const store = transaction.objectStore(this.storeName);\n                    const queryKey = \"query:\".concat(queryHash);\n                    const getRequest = store.get(queryKey);\n                    getRequest.onerror = ()=>{\n                        logger19.error(\"Failed to retrieve query result\", {\n                            queryHash,\n                            error: getRequest.error\n                        });\n                        reject(getRequest.error);\n                    };\n                    getRequest.onsuccess = ()=>{\n                        try {\n                            const result = getRequest.result;\n                            if (!result) {\n                                resolve(null);\n                                return;\n                            }\n                            const entry = JSON.parse(result);\n                            if (Array.isArray(entry)) {\n                                resolve(entry);\n                                return;\n                            }\n                            resolve(entry.itemKeys || null);\n                        } catch (parseError) {\n                            logger19.error(\"Failed to parse query result\", {\n                                queryHash,\n                                error: parseError\n                            });\n                            resolve(null);\n                        }\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in getQueryResult\", {\n                queryHash,\n                error\n            });\n            return null;\n        }\n    }\n    async hasQueryResult(queryHash) {\n        logger19.trace(\"hasQueryResult\", {\n            queryHash\n        });\n        try {\n            const result = await this.getQueryResult(queryHash);\n            return result !== null;\n        } catch (error) {\n            logger19.error(\"Error in hasQueryResult\", {\n                queryHash,\n                error\n            });\n            return false;\n        }\n    }\n    async deleteQueryResult(queryHash) {\n        logger19.trace(\"deleteQueryResult\", {\n            queryHash\n        });\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for deleteQueryResult\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readwrite\");\n                    const store = transaction.objectStore(this.storeName);\n                    const queryKey = \"query:\".concat(queryHash);\n                    const deleteRequest = store.delete(queryKey);\n                    deleteRequest.onerror = ()=>{\n                        logger19.error(\"Failed to delete query result\", {\n                            queryHash,\n                            error: deleteRequest.error\n                        });\n                        reject(deleteRequest.error);\n                    };\n                    deleteRequest.onsuccess = ()=>{\n                        resolve();\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in deleteQueryResult\", {\n                queryHash,\n                error\n            });\n            throw error;\n        }\n    }\n    async invalidateItemKeys(keys) {\n        logger19.debug(\"invalidateItemKeys\", {\n            keys\n        });\n        for (const key of keys){\n            await this.delete(key);\n        }\n    }\n    async invalidateLocation(locations) {\n        logger19.debug(\"invalidateLocation\", {\n            locations\n        });\n        if (locations.length === 0) {\n            await this.clearQueryResults();\n        } else {\n            const itemsInLocation = await this.allIn(locations);\n            const keysToInvalidate = itemsInLocation.map((item)=>item.key);\n            await this.invalidateItemKeys(keysToInvalidate);\n        }\n        await this.clearQueryResults();\n    }\n    async clearQueryResults() {\n        logger19.trace(\"clearQueryResults\");\n        try {\n            return new Promise((resolve, reject)=>{\n                const request = indexedDB.open(this.dbName, this.version);\n                request.onerror = ()=>{\n                    logger19.error(\"Failed to open database for clearQueryResults\", {\n                        error: request.error\n                    });\n                    reject(request.error);\n                };\n                request.onsuccess = ()=>{\n                    const db = request.result;\n                    const transaction = db.transaction([\n                        this.storeName\n                    ], \"readwrite\");\n                    const store = transaction.objectStore(this.storeName);\n                    const cursorRequest = store.openCursor();\n                    const keysToDelete = [];\n                    cursorRequest.onerror = ()=>{\n                        logger19.error(\"Failed to open cursor for clearQueryResults\", {\n                            error: cursorRequest.error\n                        });\n                        reject(cursorRequest.error);\n                    };\n                    cursorRequest.onsuccess = ()=>{\n                        const cursor = cursorRequest.result;\n                        if (cursor) {\n                            const key = cursor.key;\n                            if (typeof key === \"string\" && key.startsWith(\"query:\")) {\n                                keysToDelete.push(key);\n                            }\n                            cursor.continue();\n                        } else {\n                            if (keysToDelete.length === 0) {\n                                resolve();\n                                return;\n                            }\n                            let deletedCount = 0;\n                            const totalToDelete = keysToDelete.length;\n                            keysToDelete.forEach((queryKey)=>{\n                                const deleteRequest = store.delete(queryKey);\n                                deleteRequest.onerror = ()=>{\n                                    logger19.error(\"Failed to delete query key\", {\n                                        queryKey,\n                                        error: deleteRequest.error\n                                    });\n                                    deletedCount++;\n                                    if (deletedCount === totalToDelete) {\n                                        resolve();\n                                    }\n                                };\n                                deleteRequest.onsuccess = ()=>{\n                                    deletedCount++;\n                                    if (deletedCount === totalToDelete) {\n                                        resolve();\n                                    }\n                                };\n                            });\n                        }\n                    };\n                };\n            });\n        } catch (error) {\n            logger19.error(\"Error in clearQueryResults\", {\n                error\n            });\n            throw error;\n        }\n    }\n    constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1){\n        this.dbPromise = null;\n        this.types = types;\n        this.dbName = dbName;\n        this.storeName = storeName;\n        this.version = version;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n    }\n}, // Current storage format version\n__AsyncIndexDBCacheMap.CURRENT_VERSION = 1, __AsyncIndexDBCacheMap);\n// src/browser/IndexDBCacheMap.ts\nvar logger20 = logger_default.get(\"IndexDBCacheMap\");\nvar IndexDBCacheMap = class _IndexDBCacheMap extends CacheMap {\n    async initializeFromIndexedDB() {\n        try {\n            const keys = await this.asyncCache.keys();\n            for (const key of keys){\n                const hashedKey = this.normalizedHashFunction(key);\n                if (!this.memoryMap[hashedKey]) {\n                    const value = await this.asyncCache.get(key);\n                    if (value) {\n                        this.memoryMap[hashedKey] = {\n                            originalKey: key,\n                            value\n                        };\n                    }\n                }\n            }\n        } catch (error) {\n            console.warn(\"Failed to initialize from IndexedDB, using memory-only mode:\", error);\n        }\n    }\n    startPeriodicSync() {\n        this.syncInterval = setInterval(()=>{\n            this.processPendingOperations();\n        }, 10);\n    }\n    async processPendingOperations() {\n        if (this.pendingOperations.length === 0) return;\n        const operations = [\n            ...this.pendingOperations\n        ];\n        this.pendingOperations = [];\n        for (const op of operations){\n            try {\n                switch(op.type){\n                    case \"set\":\n                        if (op.key && op.value) {\n                            await this.asyncCache.set(op.key, op.value, op.metadata);\n                        }\n                        break;\n                    case \"delete\":\n                        if (op.key) {\n                            await this.asyncCache.delete(op.key);\n                        }\n                        break;\n                    case \"clear\":\n                        await this.asyncCache.clear();\n                        break;\n                }\n            } catch (error) {\n                console.warn(\"Failed to sync operation to IndexedDB:\", error);\n            }\n        }\n    }\n    // Synchronous memory operations\n    async get(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.memoryMap[hashedKey];\n        if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n            return entry.value;\n        }\n        return null;\n    }\n    async set(key, value) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const now = Date.now();\n        const metadata = {\n            key: JSON.stringify(key),\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize: JSON.stringify(value).length\n        };\n        this.memoryMap[hashedKey] = {\n            originalKey: key,\n            value\n        };\n        this.pendingOperations.push({\n            type: \"set\",\n            key,\n            value,\n            metadata,\n            sequenceId: ++this.sequenceCounter\n        });\n        this.processPendingOperations();\n    }\n    async includesKey(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        const entry = this.memoryMap[hashedKey];\n        return !!(entry && this.normalizedHashFunction(entry.originalKey) === hashedKey);\n    }\n    async delete(key) {\n        const hashedKey = this.normalizedHashFunction(key);\n        delete this.memoryMap[hashedKey];\n        this.metadataMap.delete(hashedKey);\n        this.pendingOperations.push({\n            type: \"delete\",\n            key,\n            sequenceId: ++this.sequenceCounter\n        });\n        this.processPendingOperations();\n    }\n    async keys() {\n        return Object.values(this.memoryMap).map((entry)=>entry.originalKey);\n    }\n    async values() {\n        return Object.values(this.memoryMap).map((entry)=>entry.value);\n    }\n    async clear() {\n        this.memoryMap = {};\n        this.queryResultCache = {};\n        this.metadataMap.clear();\n        this.pendingOperations.push({\n            type: \"clear\",\n            sequenceId: ++this.sequenceCounter\n        });\n        this.processPendingOperations();\n    }\n    async allIn(locations) {\n        const result = [];\n        for (const entry of Object.values(this.memoryMap)){\n            const key = entry.originalKey;\n            if (locations.length === 0) {\n                result.push(entry.value);\n            } else if ((0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n                if (isLocKeyArrayEqual(key.loc, locations)) {\n                    result.push(entry.value);\n                }\n            }\n        }\n        return result;\n    }\n    async contains(query, locations) {\n        const items = await this.queryIn(query, locations);\n        return items.length > 0;\n    }\n    async queryIn(query, locations) {\n        const candidates = await this.allIn(locations);\n        if (!query.compoundCondition) {\n            return candidates;\n        }\n        return candidates.filter((item)=>(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n    }\n    // Query result caching methods\n    async setQueryResult(queryHash, itemKeys) {\n        this.queryResultCache[queryHash] = {\n            itemKeys\n        };\n    }\n    async getQueryResult(queryHash) {\n        const entry = this.queryResultCache[queryHash];\n        return entry ? entry.itemKeys : null;\n    }\n    async hasQueryResult(queryHash) {\n        return queryHash in this.queryResultCache;\n    }\n    async deleteQueryResult(queryHash) {\n        delete this.queryResultCache[queryHash];\n    }\n    async clearQueryResults() {\n        this.queryResultCache = {};\n    }\n    // Invalidation methods\n    async invalidateItemKeys(keys) {\n        for(const queryHash in this.queryResultCache){\n            const entry = this.queryResultCache[queryHash];\n            if (entry && entry.itemKeys.some((key)=>keys.some((affectedKey)=>this.normalizedHashFunction(affectedKey) === this.normalizedHashFunction(key)))) {\n                delete this.queryResultCache[queryHash];\n            }\n        }\n    }\n    async invalidateLocation(locations) {\n        const itemsToDelete = [];\n        for (const entry of Object.values(this.memoryMap)){\n            const key = entry.originalKey;\n            if ((0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key) && isLocKeyArrayEqual(key.loc, locations)) {\n                itemsToDelete.push(key);\n            }\n        }\n        this.invalidateItemKeys(itemsToDelete);\n    }\n    // Metadata operations\n    async getMetadata(key) {\n        return this.metadataMap.get(key) || null;\n    }\n    async setMetadata(key, metadata) {\n        this.metadataMap.set(key, metadata);\n    }\n    async deleteMetadata(key) {\n        this.metadataMap.delete(key);\n    }\n    async getAllMetadata() {\n        return new Map(this.metadataMap);\n    }\n    async clearMetadata() {\n        this.metadataMap.clear();\n    }\n    // Size operations\n    async getCurrentSize() {\n        const itemCount = Object.keys(this.memoryMap).length;\n        let sizeBytes = 0;\n        for (const entry of Object.values(this.memoryMap)){\n            sizeBytes += JSON.stringify(entry.value).length;\n        }\n        return {\n            itemCount,\n            sizeBytes\n        };\n    }\n    async getSizeLimits() {\n        return {\n            maxItems: null,\n            maxSizeBytes: null\n        };\n    }\n    // Clone operation\n    async clone() {\n        const cloned = new _IndexDBCacheMap(this.types, \"fjell-indexdb-cache-clone\", \"cache-clone\", 1);\n        cloned.memoryMap = {\n            ...this.memoryMap\n        };\n        cloned.queryResultCache = {\n            ...this.queryResultCache\n        };\n        cloned.metadataMap = new Map(this.metadataMap);\n        return cloned;\n    }\n    /**\n   * Clean up resources when the cache is no longer needed\n   */ destroy() {\n        if (this.syncInterval) {\n            clearInterval(this.syncInterval);\n            this.syncInterval = null;\n        }\n    }\n    constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1){\n        super(types), this.implementationType = \"browser/indexedDB\", // Memory storage\n        this.memoryMap = {}, this.queryResultCache = {}, this.metadataMap = /* @__PURE__ */ new Map(), // Background sync management\n        this.syncInterval = null, this.pendingOperations = [], this.sequenceCounter = 0;\n        this.types = types;\n        this.normalizedHashFunction = createNormalizedHashFunction();\n        this.asyncCache = new AsyncIndexDBCacheMap(types, dbName, storeName, version);\n        this.initializeFromIndexedDB();\n        this.startPeriodicSync();\n    }\n};\n// src/Options.ts\nvar DEFAULT_CACHE_OPTIONS = {\n    cacheType: \"memory\",\n    enableDebugLogging: false,\n    autoSync: true,\n    maxRetries: 3,\n    retryDelay: 1e3,\n    indexedDBConfig: {\n        dbName: \"fjell-cache\",\n        version: 1,\n        storeName: \"cache\",\n        size: {\n            evictionPolicy: \"lru\"\n        }\n    },\n    webStorageConfig: {\n        keyPrefix: \"fjell-cache:\",\n        compress: false,\n        size: {\n            evictionPolicy: \"lru\"\n        }\n    },\n    memoryConfig: {\n        // No limits by default\n        size: {\n            evictionPolicy: \"lru\"\n        }\n    }\n};\nvar createOptions = (cacheOptions)=>{\n    var _DEFAULT_CACHE_OPTIONS_indexedDBConfig, _DEFAULT_CACHE_OPTIONS_indexedDBConfig1, _DEFAULT_CACHE_OPTIONS_webStorageConfig, _DEFAULT_CACHE_OPTIONS_webStorageConfig1, _DEFAULT_CACHE_OPTIONS_memoryConfig, _DEFAULT_CACHE_OPTIONS_memoryConfig1;\n    const indexedDBConfig = (cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.indexedDBConfig) ? {\n        ...DEFAULT_CACHE_OPTIONS.indexedDBConfig,\n        ...cacheOptions.indexedDBConfig,\n        size: cacheOptions.indexedDBConfig.size ? {\n            ...(_DEFAULT_CACHE_OPTIONS_indexedDBConfig = DEFAULT_CACHE_OPTIONS.indexedDBConfig) === null || _DEFAULT_CACHE_OPTIONS_indexedDBConfig === void 0 ? void 0 : _DEFAULT_CACHE_OPTIONS_indexedDBConfig.size,\n            ...cacheOptions.indexedDBConfig.size\n        } : (_DEFAULT_CACHE_OPTIONS_indexedDBConfig1 = DEFAULT_CACHE_OPTIONS.indexedDBConfig) === null || _DEFAULT_CACHE_OPTIONS_indexedDBConfig1 === void 0 ? void 0 : _DEFAULT_CACHE_OPTIONS_indexedDBConfig1.size\n    } : {\n        ...DEFAULT_CACHE_OPTIONS.indexedDBConfig\n    };\n    const webStorageConfig = (cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.webStorageConfig) ? {\n        ...DEFAULT_CACHE_OPTIONS.webStorageConfig,\n        ...cacheOptions.webStorageConfig,\n        size: cacheOptions.webStorageConfig.size ? {\n            ...(_DEFAULT_CACHE_OPTIONS_webStorageConfig = DEFAULT_CACHE_OPTIONS.webStorageConfig) === null || _DEFAULT_CACHE_OPTIONS_webStorageConfig === void 0 ? void 0 : _DEFAULT_CACHE_OPTIONS_webStorageConfig.size,\n            ...cacheOptions.webStorageConfig.size\n        } : (_DEFAULT_CACHE_OPTIONS_webStorageConfig1 = DEFAULT_CACHE_OPTIONS.webStorageConfig) === null || _DEFAULT_CACHE_OPTIONS_webStorageConfig1 === void 0 ? void 0 : _DEFAULT_CACHE_OPTIONS_webStorageConfig1.size\n    } : {\n        ...DEFAULT_CACHE_OPTIONS.webStorageConfig\n    };\n    const memoryConfig = (cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.memoryConfig) ? {\n        ...DEFAULT_CACHE_OPTIONS.memoryConfig,\n        ...cacheOptions.memoryConfig,\n        size: cacheOptions.memoryConfig.size ? {\n            ...(_DEFAULT_CACHE_OPTIONS_memoryConfig = DEFAULT_CACHE_OPTIONS.memoryConfig) === null || _DEFAULT_CACHE_OPTIONS_memoryConfig === void 0 ? void 0 : _DEFAULT_CACHE_OPTIONS_memoryConfig.size,\n            ...cacheOptions.memoryConfig.size\n        } : (_DEFAULT_CACHE_OPTIONS_memoryConfig1 = DEFAULT_CACHE_OPTIONS.memoryConfig) === null || _DEFAULT_CACHE_OPTIONS_memoryConfig1 === void 0 ? void 0 : _DEFAULT_CACHE_OPTIONS_memoryConfig1.size\n    } : {\n        ...DEFAULT_CACHE_OPTIONS.memoryConfig\n    };\n    return {\n        ...DEFAULT_CACHE_OPTIONS,\n        ...cacheOptions,\n        indexedDBConfig,\n        webStorageConfig,\n        memoryConfig\n    };\n};\nvar createCacheMap = (kta, options)=>{\n    switch(options.cacheType){\n        case \"memory\":\n            var _options_memoryConfig;\n            if (((_options_memoryConfig = options.memoryConfig) === null || _options_memoryConfig === void 0 ? void 0 : _options_memoryConfig.size) && (options.memoryConfig.size.maxSizeBytes || options.memoryConfig.size.maxItems)) {\n                const sizeConfig = {\n                    maxSizeBytes: options.memoryConfig.size.maxSizeBytes,\n                    maxItems: options.memoryConfig.size.maxItems\n                };\n                return new EnhancedMemoryCacheMap(kta, sizeConfig);\n            }\n            return new MemoryCacheMap(kta);\n        case \"localStorage\":\n            var _options_webStorageConfig;\n            return new LocalStorageCacheMap(kta, (_options_webStorageConfig = options.webStorageConfig) === null || _options_webStorageConfig === void 0 ? void 0 : _options_webStorageConfig.keyPrefix);\n        case \"sessionStorage\":\n            var _options_webStorageConfig1;\n            return new SessionStorageCacheMap(kta, (_options_webStorageConfig1 = options.webStorageConfig) === null || _options_webStorageConfig1 === void 0 ? void 0 : _options_webStorageConfig1.keyPrefix);\n        case \"indexedDB\":\n            var _options_indexedDBConfig, _options_indexedDBConfig1, _options_indexedDBConfig2;\n            return new IndexDBCacheMap(kta, (_options_indexedDBConfig = options.indexedDBConfig) === null || _options_indexedDBConfig === void 0 ? void 0 : _options_indexedDBConfig.dbName, (_options_indexedDBConfig1 = options.indexedDBConfig) === null || _options_indexedDBConfig1 === void 0 ? void 0 : _options_indexedDBConfig1.storeName, (_options_indexedDBConfig2 = options.indexedDBConfig) === null || _options_indexedDBConfig2 === void 0 ? void 0 : _options_indexedDBConfig2.version);\n        case \"custom\":\n            if (!options.customCacheMapFactory) {\n                throw new Error('Custom cache map factory is required when cacheType is \"custom\"');\n            }\n            return options.customCacheMapFactory(kta);\n        default:\n            throw new Error(\"Unsupported cache type: \".concat(options.cacheType));\n    }\n};\nvar validateOptions = (options)=>{\n    var _options_memoryConfig, _options_memoryConfig1, _options_webStorageConfig, _options_indexedDBConfig;\n    if (options.cacheType === \"custom\" && !options.customCacheMapFactory) {\n        throw new Error('customCacheMapFactory is required when cacheType is \"custom\"');\n    }\n    if (typeof options.maxRetries === \"number\" && options.maxRetries < 0) {\n        throw new Error(\"maxRetries must be non-negative\");\n    }\n    if (typeof options.retryDelay === \"number\" && options.retryDelay < 0) {\n        throw new Error(\"retryDelay must be non-negative\");\n    }\n    if (typeof options.ttl === \"number\" && options.ttl <= 0) {\n        throw new Error(\"ttl must be positive\");\n    }\n    if (typeof ((_options_memoryConfig = options.memoryConfig) === null || _options_memoryConfig === void 0 ? void 0 : _options_memoryConfig.maxItems) === \"number\" && options.memoryConfig.maxItems <= 0) {\n        throw new Error(\"memoryConfig.maxItems must be positive\");\n    }\n    if ((_options_memoryConfig1 = options.memoryConfig) === null || _options_memoryConfig1 === void 0 ? void 0 : _options_memoryConfig1.size) {\n        validateSizeConfig(options.memoryConfig.size);\n    }\n    if ((_options_webStorageConfig = options.webStorageConfig) === null || _options_webStorageConfig === void 0 ? void 0 : _options_webStorageConfig.size) {\n        validateSizeConfig(options.webStorageConfig.size);\n    }\n    if ((_options_indexedDBConfig = options.indexedDBConfig) === null || _options_indexedDBConfig === void 0 ? void 0 : _options_indexedDBConfig.size) {\n        validateSizeConfig(options.indexedDBConfig.size);\n    }\n    if ([\n        \"localStorage\",\n        \"sessionStorage\"\n    ].includes(options.cacheType)) {\n        const isRealBrowser =  true && typeof window.document !== \"undefined\" && typeof window.document.createElement === \"function\";\n        if (!isRealBrowser) {\n            throw new Error(\"\".concat(options.cacheType, \" is not available in non-browser environments\"));\n        }\n    }\n    if (options.cacheType === \"indexedDB\") {\n        if ( false || !window.indexedDB) {\n            throw new Error(\"\".concat(options.cacheType, \" is not available in this environment\"));\n        }\n    }\n    if (options.cacheType === \"asyncIndexedDB\") {\n        throw new Error(\"asyncIndexedDB cannot be used with synchronous cache factory. Use AsyncIndexDBCacheMap directly for async operations.\");\n    }\n};\n// src/ops/reset.ts\nvar reset = async (coordinate, options)=>{\n    try {\n        validateOptions(options);\n        const cacheMap = createCacheMap(coordinate.kta, options);\n        return [\n            cacheMap\n        ];\n    } catch (error) {\n        throw error;\n    }\n};\n// src/Operations.ts\nvar createOperations = (api, coordinate, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager)=>{\n    const context = createCacheContext(api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager);\n    return {\n        all: (query, locations)=>all(query, locations, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        one: (query, locations)=>one(query, locations, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        create: (item, locations)=>create(item, locations, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        get: (key)=>get(key, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        retrieve: (key)=>retrieve(key, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        remove: (key)=>remove(key, context).then((ctx)=>void 0),\n        update: (key, item)=>update(key, item, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        action: (key, actionName, body)=>action(key, actionName, body, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        allAction: (actionName, body, locations)=>allAction(actionName, body, locations, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        facet: (key, facetName, params)=>facet(key, facetName, params, context).then((result)=>result),\n        allFacet: (facetName, params, locations)=>allFacet(facetName, params, locations, context).then((result)=>result),\n        find: (finder, params, locations)=>find(finder, params, locations, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        findOne: (finder, params, locations)=>findOne(finder, params, locations, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        set: (key, item)=>set(key, item, context).then((param)=>{\n                let [ctx, result] = param;\n                return result;\n            }),\n        reset: ()=>reset(coordinate, options).then(()=>void 0)\n    };\n};\n// src/eviction/EvictionManager.ts\nvar logger21 = logger_default.get(\"EvictionManager\");\nvar EvictionManager = class {\n    /**\n   * Set or update the eviction strategy\n   * @param strategy - The eviction strategy to use\n   */ setEvictionStrategy(strategy) {\n        this.evictionStrategy = strategy;\n        logger21.debug(\"Eviction strategy updated\", {\n            strategy: (strategy === null || strategy === void 0 ? void 0 : strategy.getStrategyName()) || \"none\"\n        });\n    }\n    /**\n   * Get the current eviction strategy name\n   * @returns Strategy name or null if no eviction\n   */ getEvictionStrategyName() {\n        var _this_evictionStrategy;\n        return ((_this_evictionStrategy = this.evictionStrategy) === null || _this_evictionStrategy === void 0 ? void 0 : _this_evictionStrategy.getStrategyName()) || null;\n    }\n    /**\n   * Handle item access - update metadata for eviction strategy\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */ async onItemAccessed(key, metadataProvider) {\n        if (!this.evictionStrategy) {\n            return;\n        }\n        try {\n            await this.evictionStrategy.onItemAccessed(key, metadataProvider);\n        } catch (error) {\n            logger21.error(\"Error in eviction strategy onItemAccessed\", {\n                key,\n                error\n            });\n        }\n    }\n    /**\n   * Handle item addition - update metadata and perform eviction if needed\n   * @param key - Item key\n   * @param value - Item value (for size estimation)\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */ async onItemAdded(key, value, metadataProvider) {\n        const evictedKeys = [];\n        if (!this.evictionStrategy) {\n            return evictedKeys;\n        }\n        try {\n            const estimatedSize = estimateValueSize(value);\n            const context = await this.createEvictionContext(metadataProvider, estimatedSize);\n            const keysToEvict = await this.evictionStrategy.selectForEviction(metadataProvider, context);\n            for (const evictKey of keysToEvict){\n                await this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n                evictedKeys.push(evictKey);\n            }\n            await this.evictionStrategy.onItemAdded(key, estimatedSize, metadataProvider);\n            if (evictedKeys.length > 0) {\n                logger21.debug(\"Items evicted during addition\", {\n                    newKey: key,\n                    evictedKeys,\n                    strategy: this.evictionStrategy.getStrategyName()\n                });\n            }\n        } catch (error) {\n            logger21.error(\"Error in eviction strategy onItemAdded\", {\n                key,\n                error\n            });\n        }\n        return evictedKeys;\n    }\n    /**\n   * Handle item removal - clean up metadata\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */ onItemRemoved(key, metadataProvider) {\n        if (!this.evictionStrategy) {\n            return;\n        }\n        try {\n            this.evictionStrategy.onItemRemoved(key, metadataProvider);\n        } catch (error) {\n            logger21.error(\"Error in eviction strategy onItemRemoved\", {\n                key,\n                error\n            });\n        }\n    }\n    /**\n   * Perform manual eviction check\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */ async performEviction(metadataProvider) {\n        const evictedKeys = [];\n        if (!this.evictionStrategy) {\n            return evictedKeys;\n        }\n        try {\n            const context = await this.createEvictionContext(metadataProvider);\n            const keysToEvict = await this.evictionStrategy.selectForEviction(metadataProvider, context);\n            for (const evictKey of keysToEvict){\n                await this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n                evictedKeys.push(evictKey);\n            }\n            if (evictedKeys.length > 0) {\n                logger21.debug(\"Manual eviction performed\", {\n                    evictedKeys,\n                    strategy: this.evictionStrategy.getStrategyName()\n                });\n            }\n        } catch (error) {\n            logger21.error(\"Error in manual eviction\", {\n                error\n            });\n        }\n        return evictedKeys;\n    }\n    /**\n   * Check if eviction is supported (i.e., strategy is set)\n   * @returns True if eviction is supported\n   */ isEvictionSupported() {\n        return this.evictionStrategy !== null;\n    }\n    /**\n   * Create eviction context from current cache state\n   * @param metadataProvider - Cache metadata provider\n   * @param newItemSize - Size of item being added (optional)\n   * @returns Eviction context\n   */ async createEvictionContext(metadataProvider, newItemSize) {\n        const currentSize = await metadataProvider.getCurrentSize();\n        const limits = await metadataProvider.getSizeLimits();\n        return {\n            currentSize,\n            limits,\n            newItemSize\n        };\n    }\n    constructor(evictionStrategy){\n        this.evictionStrategy = evictionStrategy || null;\n    }\n};\n// src/eviction/EvictionStrategyConfig.ts\nvar DEFAULT_LFU_CONFIG = {\n    type: \"lfu\",\n    decayFactor: 0.1,\n    decayInterval: 6e4,\n    // 1 minute\n    sketchWidth: 1024,\n    sketchDepth: 4,\n    useProbabilisticCounting: true,\n    minFrequencyThreshold: 1\n};\nvar DEFAULT_ARC_CONFIG = {\n    type: \"arc\",\n    maxCacheSize: 1e3,\n    frequencyThreshold: 2,\n    useEnhancedFrequency: true,\n    frequencyDecayFactor: 0.05,\n    frequencyDecayInterval: 6e5,\n    // 10 minutes\n    useFrequencyWeightedSelection: true,\n    adaptiveLearningRate: 1\n};\nvar DEFAULT_TWO_QUEUE_CONFIG = {\n    type: \"2q\",\n    maxCacheSize: 1e3,\n    useFrequencyPromotion: true,\n    promotionThreshold: 2,\n    hotQueueDecayFactor: 0.05,\n    hotQueueDecayInterval: 3e5,\n    // 5 minutes\n    useFrequencyWeightedLRU: true\n};\n// src/eviction/EvictionStrategy.ts\nvar EvictionStrategy = class {\n    /**\n   * Determine if eviction is needed based on current context\n   * @param context - Current cache state and limits\n   * @returns True if eviction should occur\n   */ isEvictionNeeded(context) {\n        const { currentSize, limits, newItemSize = 0 } = context;\n        if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n            return true;\n        }\n        if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Calculate how many items need to be evicted\n   * @param context - Current cache state and limits\n   * @returns Number of items that should be evicted\n   */ calculateEvictionCount(context) {\n        const { currentSize, limits, newItemSize = 0 } = context;\n        let evictionCount = 0;\n        if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n            evictionCount = Math.max(evictionCount, currentSize.itemCount - limits.maxItems + 1);\n        }\n        if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n            const excessBytes = currentSize.sizeBytes + newItemSize - limits.maxSizeBytes;\n            const avgItemSize = currentSize.itemCount > 0 ? currentSize.sizeBytes / currentSize.itemCount : 1024;\n            const estimatedEvictionCount = Math.ceil(excessBytes / avgItemSize);\n            evictionCount = Math.max(evictionCount, estimatedEvictionCount);\n        }\n        return evictionCount;\n    }\n};\n// src/eviction/strategies/LRUEvictionStrategy.ts\nvar LRUEvictionStrategy = class extends EvictionStrategy {\n    async selectForEviction(metadataProvider, context) {\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        const keysToEvict = [];\n        const sortedEntries = Array.from(allMetadata.entries()).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return a.lastAccessedAt - b.lastAccessedAt;\n        });\n        for(let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++){\n            keysToEvict.push(sortedEntries[i][0]);\n        }\n        return keysToEvict;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata) {\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            await metadataProvider.setMetadata(key, metadata);\n        }\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    getStrategyName() {\n        return \"lru\";\n    }\n};\n// src/eviction/EvictionStrategyValidation.ts\nfunction validateNumberRange(value, min, max, fieldName) {\n    if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n        throw new Error(\"\".concat(fieldName, \" must be a finite number\"));\n    }\n    if (value < min || value > max) {\n        throw new Error(\"\".concat(fieldName, \" must be between \").concat(min, \" and \").concat(max, \", got \").concat(value));\n    }\n}\nfunction validatePositiveInteger(value, fieldName) {\n    if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n        throw new Error(\"\".concat(fieldName, \" must be a finite number\"));\n    }\n    if (!Number.isInteger(value) || value <= 0) {\n        throw new Error(\"\".concat(fieldName, \" must be a positive integer, got \").concat(value));\n    }\n}\nfunction sanitizeLFUConfig(config) {\n    const sanitized = {\n        ...config\n    };\n    if (typeof sanitized.decayFactor === \"number\") {\n        if (sanitized.decayFactor < 0) {\n            console.warn(\"decayFactor must be between 0 and 1, got \".concat(sanitized.decayFactor, \". Correcting to 0.\"));\n            sanitized.decayFactor = 0;\n        } else if (sanitized.decayFactor > 1) {\n            console.warn(\"decayFactor must be between 0 and 1, got \".concat(sanitized.decayFactor, \". Correcting to 1.\"));\n            sanitized.decayFactor = 1;\n        }\n    }\n    if (typeof sanitized.decayInterval === \"number\" && sanitized.decayInterval <= 0) {\n        console.warn(\"decayInterval must be positive, got \".concat(sanitized.decayInterval, \". Correcting to 300000.\"));\n        sanitized.decayInterval = 3e5;\n    }\n    if (typeof sanitized.sketchWidth === \"number\") {\n        if (sanitized.sketchWidth <= 0) {\n            console.warn(\"sketchWidth must be positive, got \".concat(sanitized.sketchWidth, \". Correcting to 1024.\"));\n            sanitized.sketchWidth = 1024;\n        } else if (sanitized.sketchWidth < 16) {\n            console.warn(\"sketchWidth should be at least 16 for optimal performance, got \".concat(sanitized.sketchWidth, \". Correcting to 16.\"));\n            sanitized.sketchWidth = 16;\n        } else if (sanitized.sketchWidth > 65536) {\n            console.warn(\"sketchWidth should not exceed 65536 for optimal performance, got \".concat(sanitized.sketchWidth, \". Correcting to 65536.\"));\n            sanitized.sketchWidth = 65536;\n        }\n    }\n    if (typeof sanitized.sketchDepth === \"number\") {\n        if (sanitized.sketchDepth <= 0) {\n            console.warn(\"sketchDepth must be positive, got \".concat(sanitized.sketchDepth, \". Correcting to 4.\"));\n            sanitized.sketchDepth = 4;\n        } else if (sanitized.sketchDepth < 1) {\n            console.warn(\"sketchDepth should be at least 1 for optimal accuracy, got \".concat(sanitized.sketchDepth, \". Correcting to 1.\"));\n            sanitized.sketchDepth = 1;\n        } else if (sanitized.sketchDepth > 16) {\n            console.warn(\"sketchDepth should not exceed 16 for optimal accuracy, got \".concat(sanitized.sketchDepth, \". Correcting to 16.\"));\n            sanitized.sketchDepth = 16;\n        }\n    }\n    if (typeof sanitized.minFrequencyThreshold === \"number\" && sanitized.minFrequencyThreshold <= 0) {\n        console.warn(\"minFrequencyThreshold must be positive, got \".concat(sanitized.minFrequencyThreshold, \". Correcting to 1.\"));\n        sanitized.minFrequencyThreshold = 1;\n    }\n    return sanitized;\n}\nfunction validateLFUConfig(config) {\n    if (typeof config.decayFactor === \"number\") {\n        validateNumberRange(config.decayFactor, 0, 1, \"decayFactor\");\n    }\n    if (typeof config.decayInterval === \"number\") {\n        validatePositiveInteger(config.decayInterval, \"decayInterval\");\n    }\n    if (typeof config.sketchWidth === \"number\") {\n        validatePositiveInteger(config.sketchWidth, \"sketchWidth\");\n        if (config.sketchWidth < 16 || config.sketchWidth > 65536) {\n            throw new Error(\"sketchWidth must be between 16 and 65536, got \".concat(config.sketchWidth));\n        }\n    }\n    if (typeof config.sketchDepth === \"number\") {\n        validatePositiveInteger(config.sketchDepth, \"sketchDepth\");\n        if (config.sketchDepth < 1 || config.sketchDepth > 16) {\n            throw new Error(\"sketchDepth must be between 1 and 16, got \".concat(config.sketchDepth));\n        }\n    }\n    if (typeof config.minFrequencyThreshold === \"number\") {\n        validatePositiveInteger(config.minFrequencyThreshold, \"minFrequencyThreshold\");\n    }\n}\nfunction sanitizeARCConfig(config) {\n    const sanitized = {\n        ...config\n    };\n    if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n        console.warn(\"maxCacheSize must be positive, got \".concat(sanitized.maxCacheSize, \". Correcting to 1000.\"));\n        sanitized.maxCacheSize = 1e3;\n    }\n    if (typeof sanitized.frequencyThreshold === \"number\" && sanitized.frequencyThreshold <= 0) {\n        console.warn(\"frequencyThreshold must be positive, got \".concat(sanitized.frequencyThreshold, \". Correcting to 2.\"));\n        sanitized.frequencyThreshold = 2;\n    }\n    if (typeof sanitized.frequencyDecayFactor === \"number\") {\n        if (sanitized.frequencyDecayFactor < 0) {\n            console.warn(\"frequencyDecayFactor must be between 0 and 1, got \".concat(sanitized.frequencyDecayFactor, \". Correcting to 0.\"));\n            sanitized.frequencyDecayFactor = 0;\n        } else if (sanitized.frequencyDecayFactor > 1) {\n            console.warn(\"frequencyDecayFactor must be between 0 and 1, got \".concat(sanitized.frequencyDecayFactor, \". Correcting to 1.\"));\n            sanitized.frequencyDecayFactor = 1;\n        }\n    }\n    if (typeof sanitized.frequencyDecayInterval === \"number\" && sanitized.frequencyDecayInterval <= 0) {\n        console.warn(\"frequencyDecayInterval must be positive, got \".concat(sanitized.frequencyDecayInterval, \". Correcting to 60000.\"));\n        sanitized.frequencyDecayInterval = 6e4;\n    }\n    if (typeof sanitized.adaptiveLearningRate === \"number\") {\n        if (sanitized.adaptiveLearningRate < 0) {\n            console.warn(\"adaptiveLearningRate must be between 0 and 10, got \".concat(sanitized.adaptiveLearningRate, \". Correcting to 0.\"));\n            sanitized.adaptiveLearningRate = 0;\n        } else if (sanitized.adaptiveLearningRate > 10) {\n            console.warn(\"adaptiveLearningRate must be between 0 and 10, got \".concat(sanitized.adaptiveLearningRate, \". Correcting to 10.\"));\n            sanitized.adaptiveLearningRate = 10;\n        }\n    }\n    return sanitized;\n}\nfunction validateARCConfig(config) {\n    if (typeof config.maxCacheSize === \"number\") {\n        validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n    }\n    if (typeof config.frequencyThreshold === \"number\") {\n        validatePositiveInteger(config.frequencyThreshold, \"frequencyThreshold\");\n    }\n    if (typeof config.frequencyDecayFactor === \"number\") {\n        validateNumberRange(config.frequencyDecayFactor, 0, 1, \"frequencyDecayFactor\");\n    }\n    if (typeof config.frequencyDecayInterval === \"number\") {\n        validatePositiveInteger(config.frequencyDecayInterval, \"frequencyDecayInterval\");\n    }\n    if (typeof config.adaptiveLearningRate === \"number\") {\n        validateNumberRange(config.adaptiveLearningRate, 0, 10, \"adaptiveLearningRate\");\n    }\n}\nfunction sanitizeTwoQueueConfig(config) {\n    const sanitized = {\n        ...config\n    };\n    if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n        console.warn(\"maxCacheSize must be positive, got \".concat(sanitized.maxCacheSize, \". Correcting to 1000.\"));\n        sanitized.maxCacheSize = 1e3;\n    }\n    if (typeof sanitized.promotionThreshold === \"number\" && sanitized.promotionThreshold <= 0) {\n        console.warn(\"promotionThreshold must be positive, got \".concat(sanitized.promotionThreshold, \". Correcting to 2.\"));\n        sanitized.promotionThreshold = 2;\n    }\n    if (typeof sanitized.hotQueueDecayFactor === \"number\") {\n        if (sanitized.hotQueueDecayFactor < 0) {\n            console.warn(\"hotQueueDecayFactor must be between 0 and 1, got \".concat(sanitized.hotQueueDecayFactor, \". Correcting to 0.\"));\n            sanitized.hotQueueDecayFactor = 0;\n        } else if (sanitized.hotQueueDecayFactor > 1) {\n            console.warn(\"hotQueueDecayFactor must be between 0 and 1, got \".concat(sanitized.hotQueueDecayFactor, \". Correcting to 1.\"));\n            sanitized.hotQueueDecayFactor = 1;\n        }\n    }\n    if (typeof sanitized.hotQueueDecayInterval === \"number\" && sanitized.hotQueueDecayInterval <= 0) {\n        console.warn(\"hotQueueDecayInterval must be positive, got \".concat(sanitized.hotQueueDecayInterval, \". Correcting to 300000.\"));\n        sanitized.hotQueueDecayInterval = 3e5;\n    }\n    return sanitized;\n}\nfunction validateTwoQueueConfig(config) {\n    if (typeof config.maxCacheSize === \"number\") {\n        validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n    }\n    if (typeof config.promotionThreshold === \"number\") {\n        validatePositiveInteger(config.promotionThreshold, \"promotionThreshold\");\n    }\n    if (typeof config.hotQueueDecayFactor === \"number\") {\n        validateNumberRange(config.hotQueueDecayFactor, 0, 1, \"hotQueueDecayFactor\");\n    }\n    if (typeof config.hotQueueDecayInterval === \"number\") {\n        validatePositiveInteger(config.hotQueueDecayInterval, \"hotQueueDecayInterval\");\n    }\n}\nfunction validateEvictionStrategyConfig(config) {\n    if (!config || typeof config !== \"object\") {\n        throw new Error(\"Configuration must be a non-null object\");\n    }\n    if (!config.type) {\n        throw new Error(\"Configuration must specify a type\");\n    }\n    const validTypes = [\n        \"lfu\",\n        \"lru\",\n        \"fifo\",\n        \"mru\",\n        \"random\",\n        \"arc\",\n        \"2q\"\n    ];\n    if (!validTypes.includes(config.type)) {\n        throw new Error(\"Invalid eviction strategy type: \".concat(config.type, \". Must be one of: \").concat(validTypes.join(\", \")));\n    }\n    switch(config.type){\n        case \"lfu\":\n            validateLFUConfig(config);\n            break;\n        case \"arc\":\n            validateARCConfig(config);\n            break;\n        case \"2q\":\n            validateTwoQueueConfig(config);\n            break;\n        case \"lru\":\n        case \"fifo\":\n        case \"mru\":\n        case \"random\":\n            break;\n        default:\n            throw new Error(\"Unsupported eviction strategy type: \".concat(config.type));\n    }\n}\nfunction sanitizeConfigByType(config) {\n    if (!config.type) {\n        return config;\n    }\n    switch(config.type){\n        case \"lfu\":\n            return sanitizeLFUConfig(config);\n        case \"arc\":\n            return sanitizeARCConfig(config);\n        case \"2q\":\n            return sanitizeTwoQueueConfig(config);\n        case \"lru\":\n        case \"fifo\":\n        case \"mru\":\n        case \"random\":\n            return config;\n        default:\n            return config;\n    }\n}\nfunction createValidatedConfig(baseConfig, userConfig) {\n    const mergedConfig = {\n        ...baseConfig,\n        ...userConfig\n    };\n    const sanitizedConfig = sanitizeConfigByType(mergedConfig);\n    validateEvictionStrategyConfig(sanitizedConfig);\n    return sanitizedConfig;\n}\n// src/eviction/strategies/LFUEvictionStrategy.ts\nfunction fnv1aHash(key, seed) {\n    const FNV_OFFSET_BASIS = 2166136261;\n    const FNV_PRIME = 16777619;\n    let hash = (FNV_OFFSET_BASIS ^ seed) >>> 0;\n    for(let i = 0; i < key.length; i++){\n        hash ^= key.charCodeAt(i);\n        hash = hash * FNV_PRIME >>> 0;\n    }\n    hash ^= hash >>> 16;\n    hash = hash * 2246822507 >>> 0;\n    hash ^= hash >>> 13;\n    hash = hash * 3266489909 >>> 0;\n    hash ^= hash >>> 16;\n    return hash >>> 0;\n}\nvar CountMinSketch = class {\n    /**\n   * Check if a number is a power of 2 for optimized bit masking\n   */ isPowerOfTwo(n) {\n        return n > 0 && (n & n - 1) === 0;\n    }\n    /**\n   * Increment the frequency count for a key\n   */ increment(key) {\n        for(let i = 0; i < this.depth; i++){\n            const hash = fnv1aHash(key, this.seeds[i]);\n            const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n            this.sketches[i][index]++;\n        }\n    }\n    /**\n   * Estimate the frequency count for a key\n   */ estimate(key) {\n        let minCount = Infinity;\n        for(let i = 0; i < this.depth; i++){\n            const hash = fnv1aHash(key, this.seeds[i]);\n            const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n            minCount = Math.min(minCount, this.sketches[i][index]);\n        }\n        return minCount === Infinity ? 0 : minCount;\n    }\n    /**\n   * Apply decay to all frequencies\n   */ decay(factor) {\n        for(let i = 0; i < this.depth; i++){\n            for(let j = 0; j < this.width; j++){\n                this.sketches[i][j] = Math.floor(this.sketches[i][j] * (1 - factor));\n            }\n        }\n    }\n    /**\n   * Reset all frequencies to zero\n   */ reset() {\n        for(let i = 0; i < this.depth; i++){\n            for(let j = 0; j < this.width; j++){\n                this.sketches[i][j] = 0;\n            }\n        }\n    }\n    constructor(width = 1024, depth = 4){\n        this.width = width;\n        this.depth = depth;\n        this.sketches = Array(depth).fill(null).map(()=>new Array(width).fill(0));\n        this.seeds = Array(depth).fill(null).map(()=>Math.floor(Math.random() * 1e6));\n    }\n};\nvar LFUEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"lfu\";\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        this.applyPeriodicDecay();\n        const sortedEntries = Array.from(allMetadata.entries()).sort((a, b)=>{\n            const freqA = this.getEffectiveFrequency(a[0], a[1]);\n            const freqB = this.getEffectiveFrequency(b[0], b[1]);\n            if (freqA !== freqB) {\n                return freqA - freqB;\n            }\n            return a[1].lastAccessedAt - b[1].lastAccessedAt;\n        });\n        return sortedEntries.slice(0, evictionCount).map((param)=>{\n            let [key] = param;\n            return key;\n        });\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        const now = Date.now();\n        metadata.lastAccessedAt = now;\n        metadata.accessCount++;\n        if (this.sketch) {\n            this.sketch.increment(key);\n            metadata.rawFrequency = this.sketch.estimate(key);\n        } else {\n            metadata.rawFrequency = metadata.accessCount;\n        }\n        metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n        metadata.lastFrequencyUpdate = now;\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize,\n            rawFrequency: 1\n        };\n        metadata.frequencyScore = 1;\n        metadata.lastFrequencyUpdate = now;\n        if (this.sketch) {\n            this.sketch.increment(key);\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    /**\n   * Get the effective frequency for an item, applying real-time decay if needed\n   */ getEffectiveFrequency(_key, metadata) {\n        var _this_config_decayFactor;\n        if (((_this_config_decayFactor = this.config.decayFactor) !== null && _this_config_decayFactor !== void 0 ? _this_config_decayFactor : 0) === 0) {\n            return metadata.rawFrequency || metadata.accessCount;\n        }\n        const now = Date.now();\n        if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n            const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n            var _this_config_decayInterval, _this_config_decayFactor1;\n            const decayAmount = timeSinceUpdate / ((_this_config_decayInterval = this.config.decayInterval) !== null && _this_config_decayInterval !== void 0 ? _this_config_decayInterval : 6e4) * ((_this_config_decayFactor1 = this.config.decayFactor) !== null && _this_config_decayFactor1 !== void 0 ? _this_config_decayFactor1 : 0.1);\n            var _this_config_minFrequencyThreshold;\n            return Math.max((_this_config_minFrequencyThreshold = this.config.minFrequencyThreshold) !== null && _this_config_minFrequencyThreshold !== void 0 ? _this_config_minFrequencyThreshold : 1, metadata.frequencyScore * (1 - decayAmount));\n        }\n        return metadata.rawFrequency || metadata.accessCount;\n    }\n    /**\n   * Calculate frequency score with decay applied\n   */ calculateFrequencyScore(metadata, currentTime) {\n        const rawFreq = metadata.rawFrequency || metadata.accessCount;\n        var _this_config_decayFactor;\n        if (((_this_config_decayFactor = this.config.decayFactor) !== null && _this_config_decayFactor !== void 0 ? _this_config_decayFactor : 0) === 0) {\n            return rawFreq;\n        }\n        if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n            return rawFreq;\n        }\n        const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n        var _this_config_decayInterval, _this_config_decayFactor1;\n        const decayAmount = timeSinceUpdate / ((_this_config_decayInterval = this.config.decayInterval) !== null && _this_config_decayInterval !== void 0 ? _this_config_decayInterval : 6e4) * ((_this_config_decayFactor1 = this.config.decayFactor) !== null && _this_config_decayFactor1 !== void 0 ? _this_config_decayFactor1 : 0.1);\n        const previousScore = metadata.frequencyScore || rawFreq;\n        const decayedScore = previousScore * (1 - decayAmount);\n        var _this_config_minFrequencyThreshold;\n        return Math.max((_this_config_minFrequencyThreshold = this.config.minFrequencyThreshold) !== null && _this_config_minFrequencyThreshold !== void 0 ? _this_config_minFrequencyThreshold : 1, decayedScore + 1);\n    }\n    /**\n   * Apply periodic decay to the frequency sketch and metadata\n   */ applyPeriodicDecay() {\n        var _this_config_decayFactor;\n        if (((_this_config_decayFactor = this.config.decayFactor) !== null && _this_config_decayFactor !== void 0 ? _this_config_decayFactor : 0) === 0) return;\n        const now = Date.now();\n        const timeSinceDecay = now - this.lastDecayTime;\n        var _this_config_decayInterval;\n        if (timeSinceDecay >= ((_this_config_decayInterval = this.config.decayInterval) !== null && _this_config_decayInterval !== void 0 ? _this_config_decayInterval : 6e4)) {\n            if (this.sketch) {\n                var _this_config_decayFactor1;\n                this.sketch.decay((_this_config_decayFactor1 = this.config.decayFactor) !== null && _this_config_decayFactor1 !== void 0 ? _this_config_decayFactor1 : 0.1);\n            }\n            this.lastDecayTime = now;\n        }\n    }\n    /**\n   * Get configuration for this strategy\n   */ getConfig() {\n        return {\n            ...this.config\n        };\n    }\n    /**\n   * Reset frequency tracking (useful for testing or cache clearing)\n   */ reset() {\n        if (this.sketch) {\n            this.sketch.reset();\n        }\n        this.lastDecayTime = Date.now();\n    }\n    constructor(config = {}){\n        super();\n        const defaultBackwardsCompatible = {\n            useProbabilisticCounting: false,\n            decayFactor: 0,\n            decayInterval: Number.MAX_SAFE_INTEGER\n        };\n        const baseConfig = {\n            ...DEFAULT_LFU_CONFIG,\n            ...defaultBackwardsCompatible\n        };\n        this.config = createValidatedConfig(baseConfig, config);\n        this.sketch = this.config.useProbabilisticCounting ? new CountMinSketch(this.config.sketchWidth, this.config.sketchDepth) : null;\n        this.lastDecayTime = Date.now();\n    }\n};\n// src/eviction/strategies/FIFOEvictionStrategy.ts\nvar FIFOEvictionStrategy = class extends EvictionStrategy {\n    async selectForEviction(metadataProvider, context) {\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        const keysToEvict = [];\n        const sortedEntries = Array.from(allMetadata.entries()).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return a.addedAt - b.addedAt;\n        });\n        for(let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++){\n            keysToEvict.push(sortedEntries[i][0]);\n        }\n        return keysToEvict;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata) {\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            await metadataProvider.setMetadata(key, metadata);\n        }\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    getStrategyName() {\n        return \"fifo\";\n    }\n};\n// src/eviction/strategies/MRUEvictionStrategy.ts\nvar MRUEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"MRU\";\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        const sortedEntries = Array.from(allMetadata.entries()).sort((a, b)=>{\n            return b[1].lastAccessedAt - a[1].lastAccessedAt;\n        });\n        return sortedEntries.slice(0, evictionCount).map((param)=>{\n            let [key] = param;\n            return key;\n        });\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        metadata.lastAccessedAt = Date.now();\n        metadata.accessCount++;\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n};\n// src/eviction/strategies/RandomEvictionStrategy.ts\nvar RandomEvictionStrategy = class extends EvictionStrategy {\n    async selectForEviction(metadataProvider, context) {\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        const keys = Array.from(allMetadata.keys());\n        const keysToEvict = [];\n        const availableKeys = [\n            ...keys\n        ];\n        for(let i = 0; i < Math.min(evictionCount, availableKeys.length); i++){\n            const randomIndex = Math.floor(Math.random() * availableKeys.length);\n            keysToEvict.push(availableKeys.splice(randomIndex, 1)[0]);\n        }\n        return keysToEvict;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata) {\n            metadata.lastAccessedAt = Date.now();\n            metadata.accessCount++;\n            await metadataProvider.setMetadata(key, metadata);\n        }\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize\n        };\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        await metadataProvider.deleteMetadata(key);\n    }\n    getStrategyName() {\n        return \"random\";\n    }\n};\n// src/eviction/strategies/ARCEvictionStrategy.ts\nvar ARCEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"ARC\";\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        this.applyPeriodicDecay(allMetadata);\n        const recentItems = /* @__PURE__ */ new Map();\n        const frequentItems = /* @__PURE__ */ new Map();\n        for (const [key, metadata] of allMetadata){\n            if (this.isFrequentItem(metadata)) {\n                frequentItems.set(key, metadata);\n            } else {\n                recentItems.set(key, metadata);\n            }\n        }\n        const keysToEvict = [];\n        const totalItems = recentItems.size + frequentItems.size;\n        const maxIterations = Math.min(evictionCount, totalItems);\n        for(let i = 0; i < maxIterations; i++){\n            let keyToEvict = null;\n            let sourceList = null;\n            if (recentItems.size > this.targetRecentSize && recentItems.size > 0) {\n                keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n                sourceList = recentItems;\n            } else if (frequentItems.size > 0) {\n                keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(frequentItems, \"frequent\") : this.selectLRUFromItems(frequentItems);\n                sourceList = frequentItems;\n            } else if (recentItems.size > 0) {\n                keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n                sourceList = recentItems;\n            }\n            if (keyToEvict && sourceList) {\n                keysToEvict.push(keyToEvict);\n                sourceList.delete(keyToEvict);\n            } else {\n                break;\n            }\n            if (recentItems.size === 0 && frequentItems.size === 0) {\n                break;\n            }\n        }\n        return keysToEvict;\n    }\n    selectLRUFromItems(items) {\n        if (items.size === 0) {\n            return null;\n        }\n        let oldestKey = null;\n        let oldestTime = Infinity;\n        const now = Date.now();\n        for (const [key, metadata] of items){\n            if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n                continue;\n            }\n            if (metadata.lastAccessedAt < oldestTime) {\n                oldestTime = metadata.lastAccessedAt;\n                oldestKey = key;\n            }\n        }\n        if (oldestKey !== null) {\n            return oldestKey;\n        }\n        if (items.size > 0) {\n            const firstKey = items.keys().next().value;\n            return firstKey !== null && firstKey !== void 0 ? firstKey : null;\n        }\n        return null;\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        const now = Date.now();\n        const updatedMetadata = {\n            ...metadata,\n            lastAccessedAt: now,\n            accessCount: metadata.accessCount + 1\n        };\n        updatedMetadata.rawFrequency = updatedMetadata.accessCount;\n        var _this_config_frequencyDecayFactor;\n        if (this.config.useEnhancedFrequency && ((_this_config_frequencyDecayFactor = this.config.frequencyDecayFactor) !== null && _this_config_frequencyDecayFactor !== void 0 ? _this_config_frequencyDecayFactor : 0) > 0) {\n            updatedMetadata.frequencyScore = this.calculateFrequencyScore(updatedMetadata, now);\n            updatedMetadata.lastFrequencyUpdate = now;\n        }\n        var _this_config_adaptiveLearningRate;\n        const learningRate = (_this_config_adaptiveLearningRate = this.config.adaptiveLearningRate) !== null && _this_config_adaptiveLearningRate !== void 0 ? _this_config_adaptiveLearningRate : 1;\n        let targetAdjusted = false;\n        if (learningRate > 0) {\n            if (this.recentGhosts.has(key)) {\n                const adjustment = Math.max(1, Math.ceil(learningRate));\n                this.targetRecentSize = Math.min(this.targetRecentSize + adjustment, this.maxGhostSize);\n                this.recentGhosts.delete(key);\n                targetAdjusted = true;\n            } else if (this.frequentGhosts.has(key)) {\n                const adjustment = Math.max(1, Math.ceil(learningRate));\n                this.targetRecentSize = Math.max(this.targetRecentSize - adjustment, 0);\n                this.frequentGhosts.delete(key);\n                targetAdjusted = true;\n            }\n        } else {\n            if (this.recentGhosts.has(key)) {\n                this.recentGhosts.delete(key);\n            } else if (this.frequentGhosts.has(key)) {\n                this.frequentGhosts.delete(key);\n            }\n        }\n        if (targetAdjusted) {\n            this.cleanupGhostLists();\n        }\n        await metadataProvider.setMetadata(key, updatedMetadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        const metadata = {\n            key,\n            addedAt: now,\n            lastAccessedAt: now,\n            accessCount: 1,\n            estimatedSize,\n            rawFrequency: 1\n        };\n        var _this_config_frequencyDecayFactor;\n        if (this.config.useEnhancedFrequency && ((_this_config_frequencyDecayFactor = this.config.frequencyDecayFactor) !== null && _this_config_frequencyDecayFactor !== void 0 ? _this_config_frequencyDecayFactor : 0) > 0) {\n            metadata.frequencyScore = 1;\n            metadata.lastFrequencyUpdate = now;\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (metadata && this.isFrequentItem(metadata)) {\n            this.addToFrequentGhosts(key);\n        } else {\n            this.addToRecentGhosts(key);\n        }\n        await metadataProvider.deleteMetadata(key);\n        this.cleanupGhostLists();\n    }\n    /**\n   * Add key to recent ghost list with proper size management\n   */ addToRecentGhosts(key) {\n        this.frequentGhosts.delete(key);\n        this.recentGhosts.add(key);\n        this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n    }\n    /**\n   * Add key to frequent ghost list with proper size management\n   */ addToFrequentGhosts(key) {\n        this.recentGhosts.delete(key);\n        this.frequentGhosts.add(key);\n        this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n    }\n    /**\n   * Cleanup ghost lists to prevent memory leaks\n   */ cleanupGhostLists() {\n        this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n        this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n    }\n    /**\n   * Enforce size limit on a ghost list by removing oldest entries\n   */ enforceGhostListSizeLimit(ghostList, maxSize) {\n        if (maxSize <= 0) {\n            ghostList.clear();\n            return;\n        }\n        const iterator = ghostList.values();\n        while(ghostList.size > maxSize){\n            const next = iterator.next();\n            if (next.done) {\n                break;\n            }\n            ghostList.delete(next.value);\n        }\n    }\n    /**\n   * Determine if an item should be classified as frequent vs recent\n   */ isFrequentItem(metadata) {\n        if (!this.config.useEnhancedFrequency) {\n            return metadata.accessCount > 1;\n        }\n        const frequency = this.getEffectiveFrequency(metadata);\n        var _this_config_frequencyThreshold;\n        return frequency >= ((_this_config_frequencyThreshold = this.config.frequencyThreshold) !== null && _this_config_frequencyThreshold !== void 0 ? _this_config_frequencyThreshold : 2);\n    }\n    /**\n   * Get effective frequency for an item, applying decay if enabled\n   */ getEffectiveFrequency(metadata) {\n        var _this_config_frequencyDecayFactor;\n        if (!this.config.useEnhancedFrequency || ((_this_config_frequencyDecayFactor = this.config.frequencyDecayFactor) !== null && _this_config_frequencyDecayFactor !== void 0 ? _this_config_frequencyDecayFactor : 0) === 0) {\n            return metadata.rawFrequency || metadata.accessCount;\n        }\n        const now = Date.now();\n        if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n            const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n            var _this_config_frequencyDecayInterval;\n            const decayInterval = (_this_config_frequencyDecayInterval = this.config.frequencyDecayInterval) !== null && _this_config_frequencyDecayInterval !== void 0 ? _this_config_frequencyDecayInterval : 6e5;\n            if (timeSinceUpdate > decayInterval / 10) {\n                var _this_config_frequencyDecayFactor1;\n                const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * ((_this_config_frequencyDecayFactor1 = this.config.frequencyDecayFactor) !== null && _this_config_frequencyDecayFactor1 !== void 0 ? _this_config_frequencyDecayFactor1 : 0.05));\n                return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n            }\n            return metadata.frequencyScore;\n        }\n        return metadata.rawFrequency || metadata.accessCount;\n    }\n    /**\n   * Calculate frequency score with decay applied\n   */ calculateFrequencyScore(metadata, currentTime) {\n        const rawFreq = metadata.rawFrequency || metadata.accessCount;\n        if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n            return rawFreq;\n        }\n        const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n        var _this_config_frequencyDecayInterval;\n        const decayInterval = (_this_config_frequencyDecayInterval = this.config.frequencyDecayInterval) !== null && _this_config_frequencyDecayInterval !== void 0 ? _this_config_frequencyDecayInterval : 6e5;\n        var _this_config_frequencyDecayFactor;\n        const decayFactor = (_this_config_frequencyDecayFactor = this.config.frequencyDecayFactor) !== null && _this_config_frequencyDecayFactor !== void 0 ? _this_config_frequencyDecayFactor : 0.05;\n        const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * decayFactor);\n        const previousScore = metadata.frequencyScore || rawFreq;\n        const decayedScore = Math.max(1, previousScore * (1 - decayAmount));\n        return Math.max(1, decayedScore + 1);\n    }\n    /**\n   * Select eviction candidate using frequency-weighted approach\n   */ selectFrequencyWeightedFromItems(items, context) {\n        if (items.size === 0) {\n            return null;\n        }\n        let bestKey = null;\n        let bestScore = Infinity;\n        const now = Date.now();\n        for (const [key, metadata] of items){\n            if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n                continue;\n            }\n            const frequency = this.getEffectiveFrequency(metadata);\n            const timeFactor = Math.max(0, now - metadata.lastAccessedAt);\n            let score;\n            if (context === \"recent\") {\n                score = timeFactor + 1e3 / Math.max(1, frequency);\n            } else if (context === \"frequent\") {\n                score = timeFactor / 1e3 + 10 / Math.max(1, frequency);\n            } else {\n                score = timeFactor / 1e3 / Math.max(1, frequency);\n            }\n            if (score < bestScore) {\n                bestScore = score;\n                bestKey = key;\n            }\n        }\n        if (bestKey !== null) {\n            return bestKey;\n        }\n        if (items.size > 0) {\n            const firstKey = items.keys().next().value;\n            return firstKey !== null && firstKey !== void 0 ? firstKey : null;\n        }\n        return null;\n    }\n    /**\n   * Apply periodic decay to frequency scores\n   */ applyPeriodicDecay(items) {\n        var _this_config_frequencyDecayFactor;\n        if (!this.config.useEnhancedFrequency || ((_this_config_frequencyDecayFactor = this.config.frequencyDecayFactor) !== null && _this_config_frequencyDecayFactor !== void 0 ? _this_config_frequencyDecayFactor : 0) === 0) return;\n        const now = Date.now();\n        const timeSinceDecay = now - this.lastDecayTime;\n        var _this_config_frequencyDecayInterval;\n        const decayInterval = (_this_config_frequencyDecayInterval = this.config.frequencyDecayInterval) !== null && _this_config_frequencyDecayInterval !== void 0 ? _this_config_frequencyDecayInterval : 6e5;\n        if (timeSinceDecay >= decayInterval && items.size > 0) {\n            var _this_config_frequencyDecayFactor1;\n            const decayFactor = (_this_config_frequencyDecayFactor1 = this.config.frequencyDecayFactor) !== null && _this_config_frequencyDecayFactor1 !== void 0 ? _this_config_frequencyDecayFactor1 : 0.05;\n            for (const metadata of items.values()){\n                if (typeof metadata.frequencyScore === \"number\") {\n                    const intervalsPassed = timeSinceDecay / decayInterval;\n                    const totalDecay = Math.min(0.9, decayFactor * intervalsPassed);\n                    const newScore = metadata.frequencyScore * (1 - totalDecay);\n                    metadata.frequencyScore = Math.max(1, newScore);\n                    metadata.lastFrequencyUpdate = now;\n                }\n            }\n            this.lastDecayTime = now;\n        }\n    }\n    /**\n   * Get configuration for this strategy\n   */ getConfig() {\n        return {\n            ...this.config\n        };\n    }\n    /**\n   * Reset internal state (useful for testing)\n   */ reset() {\n        this.recentGhosts.clear();\n        this.frequentGhosts.clear();\n        this.targetRecentSize = 0;\n        this.lastDecayTime = Date.now();\n    }\n    /**\n   * Get current adaptive state for monitoring/debugging\n   */ getAdaptiveState() {\n        return {\n            targetRecentSize: this.targetRecentSize,\n            recentGhostSize: this.recentGhosts.size,\n            frequentGhostSize: this.frequentGhosts.size\n        };\n    }\n    constructor(maxCacheSize = 1e3, config = {}){\n        super(), this.recentGhosts = /* @__PURE__ */ new Set(), // T1 ghost entries\n        this.frequentGhosts = /* @__PURE__ */ new Set(), // T2 ghost entries\n        this.targetRecentSize = 0;\n        const baseConfig = {\n            ...DEFAULT_ARC_CONFIG,\n            maxCacheSize\n        };\n        this.config = createValidatedConfig(baseConfig, config);\n        this.maxGhostSize = this.config.maxCacheSize;\n        this.lastDecayTime = Date.now();\n    }\n};\n// src/eviction/strategies/TwoQueueEvictionStrategy.ts\nvar TwoQueueEvictionStrategy = class extends EvictionStrategy {\n    getStrategyName() {\n        return \"2Q\";\n    }\n    async selectForEviction(metadataProvider, context) {\n        const allMetadata = await metadataProvider.getAllMetadata();\n        if (allMetadata.size === 0) return [];\n        if (!this.isEvictionNeeded(context)) {\n            return [];\n        }\n        const evictionCount = this.calculateEvictionCount(context);\n        if (evictionCount <= 0) return [];\n        await this.applyPeriodicDecay(allMetadata);\n        const keysToEvict = [];\n        for(let i = 0; i < evictionCount; i++){\n            let keyToEvict = null;\n            for(let j = this.recentQueue.length - 1; j >= 0; j--){\n                const key = this.recentQueue[j];\n                if (allMetadata.has(key) && !keysToEvict.includes(key)) {\n                    keyToEvict = key;\n                    break;\n                }\n            }\n            if (!keyToEvict) {\n                if (this.config.useFrequencyWeightedLRU) {\n                    keyToEvict = this.selectFromHotQueueFrequencyWeighted(allMetadata, keysToEvict);\n                } else {\n                    keyToEvict = this.selectFromHotQueueLRU(allMetadata, keysToEvict);\n                }\n            }\n            if (keyToEvict) {\n                keysToEvict.push(keyToEvict);\n            } else {\n                break;\n            }\n        }\n        return keysToEvict;\n    }\n    /**\n   * Select eviction candidate from hot queue using traditional LRU\n   */ selectFromHotQueueLRU(items) {\n        let excludeKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        let oldestKey = null;\n        let oldestTime = Infinity;\n        for (const key of this.hotQueue){\n            if (excludeKeys.includes(key)) continue;\n            const metadata = items.get(key);\n            if (metadata && metadata.lastAccessedAt < oldestTime) {\n                oldestTime = metadata.lastAccessedAt;\n                oldestKey = key;\n            }\n        }\n        var _items_keys_next_value;\n        return oldestKey || (items.size > 0 ? (_items_keys_next_value = items.keys().next().value) !== null && _items_keys_next_value !== void 0 ? _items_keys_next_value : null : null);\n    }\n    /**\n   * Select eviction candidate from hot queue using frequency-weighted LRU\n   */ selectFromHotQueueFrequencyWeighted(items) {\n        let excludeKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        let bestKey = null;\n        let lowestScore = Infinity;\n        for (const key of this.hotQueue){\n            if (excludeKeys.includes(key)) continue;\n            const metadata = items.get(key);\n            if (!metadata) continue;\n            const frequency = this.getEffectiveFrequency(metadata);\n            const timeFactor = Date.now() - metadata.lastAccessedAt;\n            const normalizedTimeFactor = timeFactor / (1e3 * 60);\n            const score = normalizedTimeFactor / Math.max(1, frequency);\n            if (score < lowestScore) {\n                lowestScore = score;\n                bestKey = key;\n            }\n        }\n        var _items_keys_next_value;\n        return bestKey || (items.size > 0 ? (_items_keys_next_value = items.keys().next().value) !== null && _items_keys_next_value !== void 0 ? _items_keys_next_value : null : null);\n    }\n    async onItemAccessed(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) return;\n        const now = Date.now();\n        metadata.lastAccessedAt = now;\n        metadata.accessCount++;\n        metadata.rawFrequency = metadata.accessCount;\n        var _this_config_hotQueueDecayFactor;\n        if (((_this_config_hotQueueDecayFactor = this.config.hotQueueDecayFactor) !== null && _this_config_hotQueueDecayFactor !== void 0 ? _this_config_hotQueueDecayFactor : 0) > 0) {\n            metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n            metadata.lastFrequencyUpdate = now;\n        }\n        const recentIndex = this.recentQueue.indexOf(key);\n        if (recentIndex !== -1) {\n            if (this.shouldPromoteToHotQueue(metadata)) {\n                this.recentQueue.splice(recentIndex, 1);\n                this.hotQueue.unshift(key);\n            }\n        } else {\n            const hotIndex = this.hotQueue.indexOf(key);\n            if (hotIndex !== -1) {\n                this.hotQueue.splice(hotIndex, 1);\n                this.hotQueue.unshift(key);\n            }\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemAdded(key, estimatedSize, metadataProvider) {\n        const now = Date.now();\n        let metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) {\n            metadata = {\n                key,\n                addedAt: now,\n                lastAccessedAt: now,\n                accessCount: 1,\n                estimatedSize,\n                rawFrequency: 1\n            };\n            var _this_config_hotQueueDecayFactor;\n            if (((_this_config_hotQueueDecayFactor = this.config.hotQueueDecayFactor) !== null && _this_config_hotQueueDecayFactor !== void 0 ? _this_config_hotQueueDecayFactor : 0) > 0) {\n                metadata.frequencyScore = 1;\n                metadata.lastFrequencyUpdate = now;\n            }\n        }\n        if (this.ghostQueue.has(key)) {\n            this.ghostQueue.delete(key);\n            this.hotQueue.unshift(key);\n        } else {\n            this.recentQueue.unshift(key);\n            if (this.recentQueue.length > this.maxRecentSize) {\n                const evicted = this.recentQueue.pop();\n                if (evicted) {\n                    this.ghostQueue.add(evicted);\n                }\n            }\n        }\n        if (this.ghostQueue.size > this.maxGhostSize) {\n            const firstKey = this.ghostQueue.values().next().value;\n            if (firstKey) {\n                this.ghostQueue.delete(firstKey);\n            }\n        }\n        await metadataProvider.setMetadata(key, metadata);\n    }\n    async onItemRemoved(key, metadataProvider) {\n        const recentIndex = this.recentQueue.indexOf(key);\n        if (recentIndex !== -1) {\n            this.recentQueue.splice(recentIndex, 1);\n        }\n        const hotIndex = this.hotQueue.indexOf(key);\n        if (hotIndex !== -1) {\n            this.hotQueue.splice(hotIndex, 1);\n        }\n        await metadataProvider.deleteMetadata(key);\n    }\n    /**\n   * Determine if an item should be promoted from recent to hot queue\n   */ shouldPromoteToHotQueue(metadata) {\n        if (!this.config.useFrequencyPromotion) {\n            return metadata.accessCount >= 2;\n        }\n        var _this_config_promotionThreshold;\n        const threshold = (_this_config_promotionThreshold = this.config.promotionThreshold) !== null && _this_config_promotionThreshold !== void 0 ? _this_config_promotionThreshold : 2;\n        const frequency = this.getEffectiveFrequency(metadata);\n        return frequency >= threshold;\n    }\n    /**\n   * Get effective frequency for an item, applying decay if enabled\n   */ getEffectiveFrequency(metadata) {\n        var _this_config_hotQueueDecayFactor;\n        if (((_this_config_hotQueueDecayFactor = this.config.hotQueueDecayFactor) !== null && _this_config_hotQueueDecayFactor !== void 0 ? _this_config_hotQueueDecayFactor : 0) === 0) {\n            return metadata.rawFrequency || metadata.accessCount;\n        }\n        const now = Date.now();\n        if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n            const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n            var _this_config_hotQueueDecayInterval, _this_config_hotQueueDecayFactor1;\n            const decayAmount = timeSinceUpdate / ((_this_config_hotQueueDecayInterval = this.config.hotQueueDecayInterval) !== null && _this_config_hotQueueDecayInterval !== void 0 ? _this_config_hotQueueDecayInterval : 3e5) * ((_this_config_hotQueueDecayFactor1 = this.config.hotQueueDecayFactor) !== null && _this_config_hotQueueDecayFactor1 !== void 0 ? _this_config_hotQueueDecayFactor1 : 0.05);\n            return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n        }\n        return metadata.rawFrequency || metadata.accessCount;\n    }\n    /**\n   * Calculate frequency score with decay applied\n   */ calculateFrequencyScore(metadata, currentTime) {\n        const rawFreq = metadata.rawFrequency || metadata.accessCount;\n        if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n            return rawFreq;\n        }\n        const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n        var _this_config_hotQueueDecayInterval, _this_config_hotQueueDecayFactor;\n        const decayAmount = timeSinceUpdate / ((_this_config_hotQueueDecayInterval = this.config.hotQueueDecayInterval) !== null && _this_config_hotQueueDecayInterval !== void 0 ? _this_config_hotQueueDecayInterval : 3e5) * ((_this_config_hotQueueDecayFactor = this.config.hotQueueDecayFactor) !== null && _this_config_hotQueueDecayFactor !== void 0 ? _this_config_hotQueueDecayFactor : 0.05);\n        const previousScore = metadata.frequencyScore || rawFreq;\n        const decayedScore = previousScore * (1 - decayAmount);\n        return Math.max(1, decayedScore + 1);\n    }\n    /**\n   * Apply periodic decay to hot queue items\n   */ async applyPeriodicDecay(items) {\n        var _this_config_hotQueueDecayFactor;\n        if (((_this_config_hotQueueDecayFactor = this.config.hotQueueDecayFactor) !== null && _this_config_hotQueueDecayFactor !== void 0 ? _this_config_hotQueueDecayFactor : 0) === 0) return;\n        const now = Date.now();\n        const timeSinceDecay = now - this.lastDecayTime;\n        var _this_config_hotQueueDecayInterval;\n        if (timeSinceDecay >= ((_this_config_hotQueueDecayInterval = this.config.hotQueueDecayInterval) !== null && _this_config_hotQueueDecayInterval !== void 0 ? _this_config_hotQueueDecayInterval : 3e5)) {\n            if (this.hotQueue.length > 0) {\n                for (const key of this.hotQueue){\n                    const metadata = items.get(key);\n                    if (metadata && typeof metadata.frequencyScore === \"number\") {\n                        var _this_config_hotQueueDecayFactor1;\n                        const decayAmount = (_this_config_hotQueueDecayFactor1 = this.config.hotQueueDecayFactor) !== null && _this_config_hotQueueDecayFactor1 !== void 0 ? _this_config_hotQueueDecayFactor1 : 0.05;\n                        metadata.frequencyScore = Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n                    }\n                }\n                this.lastDecayTime = now;\n            }\n        }\n    }\n    /**\n   * Get configuration for this strategy\n   */ getConfig() {\n        return {\n            ...this.config\n        };\n    }\n    /**\n   * Reset internal state (useful for testing)\n   */ reset() {\n        this.recentQueue = [];\n        this.hotQueue = [];\n        this.ghostQueue.clear();\n        this.lastDecayTime = Date.now();\n    }\n    constructor(maxCacheSize = 1e3, config = {}){\n        super(), this.recentQueue = [], // A1 queue for recent items\n        this.hotQueue = [], // Am queue for hot items\n        this.ghostQueue = /* @__PURE__ */ new Set();\n        const baseConfig = {\n            ...DEFAULT_TWO_QUEUE_CONFIG,\n            maxCacheSize\n        };\n        this.config = createValidatedConfig(baseConfig, config);\n        this.maxRecentSize = Math.max(1, Math.floor(this.config.maxCacheSize * 0.25));\n        this.maxGhostSize = this.config.maxCacheSize;\n        this.lastDecayTime = Date.now();\n    }\n};\n// src/eviction/EvictionStrategyFactory.ts\nfunction createEvictionStrategy(policy, maxCacheSize, config) {\n    const safeMaxCacheSize = typeof maxCacheSize === \"number\" && maxCacheSize > 0 ? maxCacheSize : 1e3;\n    switch(policy){\n        case \"lru\":\n            return new LRUEvictionStrategy();\n        case \"lfu\":\n            {\n                try {\n                    const lfuConfig = (config === null || config === void 0 ? void 0 : config.type) === \"lfu\" ? config : {\n                        type: \"lfu\"\n                    };\n                    return new LFUEvictionStrategy(lfuConfig);\n                } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    console.warn(\"Failed to create lfu strategy with provided configuration, falling back to LRU:\", errorMessage);\n                    return new LRUEvictionStrategy();\n                }\n            }\n        case \"fifo\":\n            return new FIFOEvictionStrategy();\n        case \"mru\":\n            return new MRUEvictionStrategy();\n        case \"random\":\n            return new RandomEvictionStrategy();\n        case \"arc\":\n            {\n                try {\n                    const arcConfig = (config === null || config === void 0 ? void 0 : config.type) === \"arc\" ? config : {\n                        ...DEFAULT_ARC_CONFIG,\n                        maxCacheSize: safeMaxCacheSize\n                    };\n                    const finalMaxSize = arcConfig.maxCacheSize && arcConfig.maxCacheSize > 0 ? arcConfig.maxCacheSize : safeMaxCacheSize;\n                    return new ARCEvictionStrategy(finalMaxSize, {\n                        ...arcConfig,\n                        maxCacheSize: finalMaxSize\n                    });\n                } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    console.warn(\"Failed to create arc strategy with provided configuration, falling back to LRU:\", errorMessage);\n                    return new LRUEvictionStrategy();\n                }\n            }\n        case \"2q\":\n            {\n                try {\n                    const twoQConfig = (config === null || config === void 0 ? void 0 : config.type) === \"2q\" ? config : {\n                        ...DEFAULT_TWO_QUEUE_CONFIG,\n                        maxCacheSize: safeMaxCacheSize\n                    };\n                    const finalMaxSize = twoQConfig.maxCacheSize && twoQConfig.maxCacheSize > 0 ? twoQConfig.maxCacheSize : safeMaxCacheSize;\n                    return new TwoQueueEvictionStrategy(finalMaxSize, {\n                        ...twoQConfig,\n                        maxCacheSize: finalMaxSize\n                    });\n                } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    console.warn(\"Failed to create 2q strategy with provided configuration, falling back to LRU:\", errorMessage);\n                    return new LRUEvictionStrategy();\n                }\n            }\n        default:\n            throw new Error(\"Unsupported eviction policy: \".concat(policy));\n    }\n}\n// src/ttl/TTLManager.ts\nvar logger22 = logger_default.get(\"TTLManager\");\nvar TTLManager = class {\n    /**\n   * Check if TTL is enabled\n   */ isTTLEnabled() {\n        return typeof this.config.defaultTTL === \"number\" && this.config.defaultTTL > 0;\n    }\n    /**\n   * Get the default TTL value\n   */ getDefaultTTL() {\n        return this.config.defaultTTL;\n    }\n    /**\n   * Update TTL configuration\n   */ updateConfig(config) {\n        const oldConfig = this.config;\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        if (oldConfig.autoCleanup !== this.config.autoCleanup || oldConfig.cleanupInterval !== this.config.cleanupInterval) {\n            this.stopAutoCleanup();\n            if (this.config.autoCleanup && this.config.cleanupInterval) {\n                this.startAutoCleanup();\n            }\n        }\n        logger22.debug(\"TTL configuration updated\", {\n            config: this.config\n        });\n    }\n    /**\n   * Set TTL metadata for an item when it's added\n   */ async onItemAdded(key, metadataProvider, itemTTL) {\n        if (!this.isTTLEnabled() && !itemTTL) {\n            return;\n        }\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) {\n            logger22.warning(\"No metadata found for item when setting TTL\", {\n                key\n            });\n            return;\n        }\n        const ttl = itemTTL || this.config.defaultTTL;\n        if (ttl && ttl > 0) {\n            const ttlMetadata = {\n                ...metadata,\n                expiresAt: metadata.addedAt + ttl,\n                ttl\n            };\n            await metadataProvider.setMetadata(key, ttlMetadata);\n            logger22.trace(\"TTL set for item\", {\n                key,\n                ttl,\n                expiresAt: ttlMetadata.expiresAt\n            });\n        }\n    }\n    /**\n   * Check if an item has expired\n   */ async isExpired(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata || !metadata.expiresAt) {\n            return false;\n        }\n        const now = Date.now();\n        const expired = now >= metadata.expiresAt;\n        if (expired) {\n            logger22.trace(\"Item expired\", {\n                key,\n                expiresAt: metadata.expiresAt,\n                now\n            });\n        }\n        return expired;\n    }\n    /**\n   * Check if an item is valid (not expired) before returning it\n   * Returns true if item is valid, false if expired\n   */ async validateItem(key, metadataProvider) {\n        if (!this.config.validateOnAccess) {\n            return true;\n        }\n        return !await this.isExpired(key, metadataProvider);\n    }\n    /**\n   * Get TTL information for an item\n   */ async getItemTTLInfo(key, metadataProvider) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata || !metadata.expiresAt) {\n            return {\n                hasTTL: false,\n                isExpired: false\n            };\n        }\n        const now = Date.now();\n        const isExpired = now >= metadata.expiresAt;\n        const remainingTTL = isExpired ? 0 : metadata.expiresAt - now;\n        return {\n            hasTTL: true,\n            ttl: metadata.ttl,\n            expiresAt: metadata.expiresAt,\n            remainingTTL,\n            isExpired\n        };\n    }\n    /**\n   * Find all expired items\n   */ async findExpiredItems(metadataProvider) {\n        const expiredKeys = [];\n        const allMetadata = await metadataProvider.getAllMetadata();\n        const now = Date.now();\n        for (const [key, metadata] of allMetadata){\n            const ttlMetadata = metadata;\n            if (ttlMetadata.expiresAt && now >= ttlMetadata.expiresAt) {\n                expiredKeys.push(key);\n            }\n        }\n        if (expiredKeys.length > 0) {\n            logger22.debug(\"Found expired items\", {\n                count: expiredKeys.length,\n                keys: expiredKeys\n            });\n        }\n        return expiredKeys;\n    }\n    /**\n   * Manually clean up expired items\n   * Returns the keys of items that were expired\n   */ async cleanupExpiredItems(metadataProvider) {\n        return await this.findExpiredItems(metadataProvider);\n    }\n    /**\n   * Get remaining TTL for an item in milliseconds\n   */ async getRemainingTTL(key, metadataProvider) {\n        const info = await this.getItemTTLInfo(key, metadataProvider);\n        return info.hasTTL ? info.remainingTTL || 0 : null;\n    }\n    /**\n   * Extend TTL for an item\n   */ async extendTTL(key, metadataProvider, additionalTTL) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata || !metadata.expiresAt) {\n            return false;\n        }\n        metadata.expiresAt += additionalTTL;\n        await metadataProvider.setMetadata(key, metadata);\n        logger22.trace(\"TTL extended for item\", {\n            key,\n            additionalTTL,\n            newExpiresAt: metadata.expiresAt\n        });\n        return true;\n    }\n    /**\n   * Reset TTL for an item (refresh expiration)\n   */ async refreshTTL(key, metadataProvider, newTTL) {\n        const metadata = await metadataProvider.getMetadata(key);\n        if (!metadata) {\n            return false;\n        }\n        const ttl = newTTL || metadata.ttl || this.config.defaultTTL;\n        if (!ttl) {\n            return false;\n        }\n        const now = Date.now();\n        const ttlMetadata = {\n            ...metadata,\n            expiresAt: now + ttl,\n            ttl\n        };\n        await metadataProvider.setMetadata(key, ttlMetadata);\n        logger22.trace(\"TTL refreshed for item\", {\n            key,\n            ttl,\n            expiresAt: ttlMetadata.expiresAt\n        });\n        return true;\n    }\n    /**\n   * Start automatic cleanup of expired items\n   */ startAutoCleanup() {\n        if (this.cleanupTimer) {\n            this.stopAutoCleanup();\n        }\n        if (this.config.cleanupInterval) {\n            this.cleanupTimer = setInterval(()=>{\n                logger22.trace(\"Auto cleanup timer triggered\");\n            }, this.config.cleanupInterval);\n            logger22.debug(\"Auto cleanup started\", {\n                interval: this.config.cleanupInterval\n            });\n        }\n    }\n    /**\n   * Stop automatic cleanup\n   */ stopAutoCleanup() {\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n            logger22.debug(\"Auto cleanup stopped\");\n        }\n    }\n    /**\n   * Cleanup resources\n   */ destroy() {\n        this.stopAutoCleanup();\n        logger22.debug(\"TTL manager destroyed\");\n    }\n    constructor(config = {}){\n        this.config = {\n            autoCleanup: true,\n            cleanupInterval: 6e4,\n            // 1 minute default\n            validateOnAccess: true,\n            ...config\n        };\n        if (this.config.autoCleanup && this.config.cleanupInterval) {\n            this.startAutoCleanup();\n        }\n    }\n};\n// src/events/CacheEventEmitter.ts\nvar CacheEventEmitter = class {\n    /**\n   * Start periodic cleanup of inactive subscriptions\n   */ startPeriodicCleanup() {\n        if (this.cleanupInterval) return;\n        this.cleanupInterval = setInterval(()=>{\n            this.performPeriodicCleanup();\n        }, this.CLEANUP_INTERVAL_MS);\n        if (this.cleanupInterval.unref) {\n            this.cleanupInterval.unref();\n        }\n    }\n    /**\n   * Perform periodic cleanup of inactive subscriptions\n   */ performPeriodicCleanup() {\n        if (this.isDestroyed) return;\n        const now = Date.now();\n        const toRemove = [];\n        for (const [id, subscription] of this.subscriptions){\n            if (!subscription.isActive || now - subscription.lastAccessTime > this.MAX_INACTIVE_TIME_MS) {\n                toRemove.push(id);\n                continue;\n            }\n            if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n                const listener = subscription.listenerRef.deref();\n                if (!listener) {\n                    toRemove.push(id);\n                    continue;\n                }\n            }\n        }\n        toRemove.forEach((id)=>this.unsubscribe(id));\n    }\n    /**\n   * Subscribe to cache events\n   */ subscribe(listener) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (this.isDestroyed) {\n            throw new Error(\"Cannot subscribe to destroyed event emitter\");\n        }\n        const id = \"subscription_\".concat(this.nextSubscriptionId++);\n        const now = Date.now();\n        const subscription = {\n            id,\n            listener,\n            listenerRef: this.WEAK_REF_ENABLED && options.useWeakRef !== false ? new WeakRef(listener) : void 0,\n            options,\n            isActive: true,\n            createdAt: now,\n            lastAccessTime: now\n        };\n        this.subscriptions.set(id, subscription);\n        return {\n            id,\n            unsubscribe: ()=>this.unsubscribe(id),\n            isActive: ()=>{\n                const sub = this.subscriptions.get(id);\n                if (sub) {\n                    sub.lastAccessTime = Date.now();\n                }\n                var _sub_isActive;\n                return (_sub_isActive = sub === null || sub === void 0 ? void 0 : sub.isActive) !== null && _sub_isActive !== void 0 ? _sub_isActive : false;\n            },\n            getOptions: ()=>({\n                    ...options\n                })\n        };\n    }\n    /**\n   * Unsubscribe from events\n   */ unsubscribe(subscriptionId) {\n        const subscription = this.subscriptions.get(subscriptionId);\n        if (!subscription) {\n            return false;\n        }\n        if (subscription.debounceTimer) {\n            clearTimeout(subscription.debounceTimer);\n            subscription.debounceTimer = null;\n        }\n        subscription.isActive = false;\n        this.subscriptions.delete(subscriptionId);\n        return true;\n    }\n    /**\n   * Emit an event to all matching subscriptions\n   */ emit(event) {\n        if (this.isDestroyed) {\n            return;\n        }\n        for (const subscription of this.subscriptions.values()){\n            if (!subscription.isActive) {\n                continue;\n            }\n            if (this.shouldEmitToSubscription(event, subscription)) {\n                this.emitToSubscription(event, subscription);\n            }\n        }\n    }\n    /**\n   * Get count of active subscriptions\n   */ getSubscriptionCount() {\n        return Array.from(this.subscriptions.values()).filter((s)=>s.isActive).length;\n    }\n    /**\n   * Get subscription details (for debugging)\n   */ getSubscriptions() {\n        return Array.from(this.subscriptions.values()).filter((s)=>s.isActive).map((s)=>({\n                id: s.id,\n                options: {\n                    ...s.options\n                }\n            }));\n    }\n    /**\n   * Destroy the event emitter and clean up all subscriptions\n   */ destroy() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n            this.cleanupInterval = null;\n        }\n        for (const subscription of this.subscriptions.values()){\n            if (subscription.debounceTimer) {\n                clearTimeout(subscription.debounceTimer);\n                subscription.debounceTimer = null;\n            }\n            subscription.isActive = false;\n        }\n        this.subscriptions.clear();\n        this.isDestroyed = true;\n    }\n    /**\n   * Check if an event should be emitted to a specific subscription\n   */ shouldEmitToSubscription(event, subscription) {\n        const { options } = subscription;\n        if (options.eventTypes && !options.eventTypes.includes(event.type)) {\n            return false;\n        }\n        if (options.keys && options.keys.length > 0) {\n            if (\"key\" in event) {\n                const eventKeyStr = this.normalizeKey(event.key);\n                const matchesKey = options.keys.some((key)=>this.normalizeKey(key) === eventKeyStr);\n                if (!matchesKey) {\n                    return false;\n                }\n            } else if (\"affectedKeys\" in event) {\n                const eventKeyStrs = event.affectedKeys.map((key)=>this.normalizeKey(key));\n                const hasMatchingKey = options.keys.some((key)=>eventKeyStrs.includes(this.normalizeKey(key)));\n                if (!hasMatchingKey) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        if (options.locations && options.locations.length > 0) {\n            if (\"affectedLocations\" in event && event.affectedLocations) {\n                if (!this.locationsMatch(options.locations, event.affectedLocations)) {\n                    return false;\n                }\n            } else if (\"locations\" in event) {\n                if (!this.locationsMatch(options.locations, event.locations)) {\n                    return false;\n                }\n            } else if (\"key\" in event) {\n                if (!this.keyMatchesLocations(event.key, options.locations)) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        if (options.query) {\n            if (\"query\" in event) {\n                if (!this.queriesMatch(options.query, event.query)) {\n                    return false;\n                }\n            } else {\n                return true;\n            }\n        }\n        return true;\n    }\n    /**\n   * Emit event to a specific subscription, handling debouncing\n   */ emitToSubscription(event, subscription) {\n        subscription.lastAccessTime = Date.now();\n        let listener = subscription.listener;\n        if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n            const weakListener = subscription.listenerRef.deref();\n            if (!weakListener) {\n                subscription.isActive = false;\n                return;\n            }\n            listener = weakListener;\n        }\n        if (!subscription.options.debounceMs) {\n            try {\n                listener(event);\n            } catch (error) {\n                this.handleListenerError(error, event, subscription);\n            }\n            return;\n        }\n        if (subscription.debounceTimer) {\n            clearTimeout(subscription.debounceTimer);\n            subscription.debounceTimer = null;\n        }\n        subscription.debounceTimer = setTimeout(()=>{\n            if (subscription.isActive) {\n                let currentListener = subscription.listener;\n                if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n                    const weakListener = subscription.listenerRef.deref();\n                    if (!weakListener) {\n                        subscription.isActive = false;\n                        subscription.debounceTimer = null;\n                        return;\n                    }\n                    currentListener = weakListener;\n                }\n                try {\n                    currentListener(event);\n                    subscription.lastEmitTime = Date.now();\n                } catch (error) {\n                    this.handleListenerError(error, event, subscription);\n                }\n            }\n            subscription.debounceTimer = null;\n        }, subscription.options.debounceMs);\n    }\n    /**\n   * Normalize a key for comparison\n   */ normalizeKey(key) {\n        return JSON.stringify(key, (k, v)=>{\n            if (typeof v === \"string\" || typeof v === \"number\") {\n                return normalizeKeyValue(v);\n            }\n            return v;\n        });\n    }\n    /**\n   * Normalize a location key for comparison\n   */ normalizeLocKey(key) {\n        return JSON.stringify(key, (k, v)=>{\n            if (typeof v === \"string\" || typeof v === \"number\") {\n                return normalizeKeyValue(v);\n            }\n            return v;\n        });\n    }\n    /**\n   * Check if two location arrays match\n   * Filter locations must be a prefix of event locations (in order)\n   */ locationsMatch(filter, eventLocations) {\n        if (filter.length === 0) {\n            return eventLocations.length === 0;\n        }\n        if (filter.length > eventLocations.length) {\n            return false;\n        }\n        return filter.every((filterLoc, index)=>{\n            const eventLoc = eventLocations[index];\n            return this.normalizeKey(filterLoc) === this.normalizeKey(eventLoc);\n        });\n    }\n    /**\n   * Check if a key matches location filters\n   */ keyMatchesLocations(key, filterLocations) {\n        if (\"loc\" in key && key.loc) {\n            return this.locationsMatch(filterLocations, key.loc);\n        }\n        return filterLocations.length === 0;\n    }\n    /**\n   * Check if two queries match (improved comparison)\n   */ queriesMatch(filterQuery, eventQuery) {\n        const normalize = (obj)=>{\n            if (obj === null || typeof obj === \"undefined\") return obj;\n            if (typeof obj !== \"object\") return obj;\n            if (Array.isArray(obj)) return obj.map(normalize).sort();\n            const sorted = {};\n            Object.keys(obj).sort().forEach((key)=>{\n                sorted[key] = normalize(obj[key]);\n            });\n            return sorted;\n        };\n        return JSON.stringify(normalize(filterQuery)) === JSON.stringify(normalize(eventQuery));\n    }\n    /**\n   * Handle errors that occur in event listeners\n   */ handleListenerError(error, event, subscription) {\n        const errorObj = error instanceof Error ? error : new Error(String(error));\n        if (subscription.options.onError) {\n            try {\n                subscription.options.onError(errorObj, event);\n            } catch (handlerError) {\n                console.error(\"Error in cache event listener:\", errorObj);\n                console.error(\"Error in error handler:\", handlerError);\n            }\n        } else {\n            console.error(\"Error in cache event listener:\", errorObj);\n        }\n    }\n    constructor(){\n        this.subscriptions = /* @__PURE__ */ new Map();\n        this.nextSubscriptionId = 1;\n        this.isDestroyed = false;\n        this.cleanupInterval = null;\n        this.CLEANUP_INTERVAL_MS = 3e4;\n        // 30 seconds\n        this.MAX_INACTIVE_TIME_MS = 3e5;\n        // 5 minutes\n        this.WEAK_REF_ENABLED = typeof WeakRef !== \"undefined\";\n        this.startPeriodicCleanup();\n    }\n};\n// src/CacheStats.ts\nvar CacheStatsManager = class {\n    /**\n   * Increment the request counter\n   */ incrementRequests() {\n        this.stats.numRequests++;\n    }\n    /**\n   * Increment the cache hit counter\n   */ incrementHits() {\n        this.stats.numHits++;\n    }\n    /**\n   * Increment the cache miss counter\n   */ incrementMisses() {\n        this.stats.numMisses++;\n    }\n    /**\n   * Increment the subscription counter\n   */ incrementSubscriptions() {\n        this.stats.numSubscriptions++;\n        this.stats.activeSubscriptions++;\n    }\n    /**\n   * Increment the unsubscription counter\n   */ incrementUnsubscriptions() {\n        this.stats.numUnsubscriptions++;\n        if (this.stats.activeSubscriptions > 0) {\n            this.stats.activeSubscriptions--;\n        }\n    }\n    /**\n   * Get a copy of the current statistics\n   */ getStats() {\n        return {\n            ...this.stats\n        };\n    }\n    /**\n   * Reset all statistics to zero\n   */ reset() {\n        this.stats = {\n            numRequests: 0,\n            numMisses: 0,\n            numHits: 0,\n            numSubscriptions: 0,\n            numUnsubscriptions: 0,\n            activeSubscriptions: 0\n        };\n    }\n    constructor(){\n        this.stats = {\n            numRequests: 0,\n            numMisses: 0,\n            numHits: 0,\n            numSubscriptions: 0,\n            numUnsubscriptions: 0,\n            activeSubscriptions: 0\n        };\n    }\n};\n// src/Cache.ts\nvar logger23 = logger_default.get(\"Cache\");\nvar createCache = (api, coordinate, registry, options)=>{\n    var _completeOptions_memoryConfig_size, _completeOptions_memoryConfig;\n    logger23.debug(\"createCache\", {\n        coordinate,\n        registry,\n        options\n    });\n    const completeOptions = createOptions(options);\n    const cacheMap = createCacheMap(coordinate.kta, completeOptions);\n    const pkType = coordinate.kta[0];\n    const eventEmitter = new CacheEventEmitter();\n    const evictionManager = new EvictionManager();\n    const evictionConfig = completeOptions.evictionConfig;\n    if (!evictionConfig && ((_completeOptions_memoryConfig = completeOptions.memoryConfig) === null || _completeOptions_memoryConfig === void 0 ? void 0 : (_completeOptions_memoryConfig_size = _completeOptions_memoryConfig.size) === null || _completeOptions_memoryConfig_size === void 0 ? void 0 : _completeOptions_memoryConfig_size.evictionPolicy) && (completeOptions.memoryConfig.size.maxItems || completeOptions.memoryConfig.size.maxSizeBytes)) {}\n    if (evictionConfig) {\n        var _completeOptions_memoryConfig1;\n        const strategy = createEvictionStrategy(evictionConfig.type || \"lru\", (_completeOptions_memoryConfig1 = completeOptions.memoryConfig) === null || _completeOptions_memoryConfig1 === void 0 ? void 0 : _completeOptions_memoryConfig1.maxItems, evictionConfig);\n        evictionManager.setEvictionStrategy(strategy);\n    }\n    const ttlManager = new TTLManager({\n        defaultTTL: completeOptions.ttl,\n        autoCleanup: true,\n        validateOnAccess: true\n    });\n    const statsManager = new CacheStatsManager();\n    const operations = createOperations(api, coordinate, cacheMap, pkType, completeOptions, eventEmitter, ttlManager, evictionManager, statsManager);\n    const cache = {\n        coordinate,\n        registry,\n        api,\n        cacheMap,\n        operations,\n        options: completeOptions,\n        eventEmitter,\n        evictionManager,\n        ttlManager,\n        statsManager,\n        getCacheInfo: ()=>{\n            var _cacheMap_supportsTTL;\n            const evictionStrategyName = evictionManager.getEvictionStrategyName();\n            const cacheInfo = {\n                implementationType: cacheMap.implementationType,\n                defaultTTL: ttlManager.getDefaultTTL(),\n                // Cache supports TTL if the CacheMap supports it OR if TTL is configured\n                supportsTTL: ((_cacheMap_supportsTTL = cacheMap.supportsTTL) === null || _cacheMap_supportsTTL === void 0 ? void 0 : _cacheMap_supportsTTL.call(cacheMap)) || !!ttlManager.getDefaultTTL(),\n                supportsEviction: evictionManager.isEvictionSupported()\n            };\n            if (evictionStrategyName) {\n                cacheInfo.evictionPolicy = evictionStrategyName;\n            }\n            return cacheInfo;\n        },\n        getStats: ()=>statsManager.getStats(),\n        subscribe: (listener, options2)=>{\n            statsManager.incrementSubscriptions();\n            return eventEmitter.subscribe(listener, options2);\n        },\n        unsubscribe: (subscription)=>{\n            const result = eventEmitter.unsubscribe(subscription.id);\n            if (result) {\n                statsManager.incrementUnsubscriptions();\n            }\n            return result;\n        },\n        destroy: ()=>{\n            eventEmitter.destroy();\n            if (ttlManager && typeof ttlManager.destroy === \"function\") {\n                ttlManager.destroy();\n            }\n            if (cacheMap && typeof cacheMap.destroy === \"function\") {\n                cacheMap.destroy();\n            }\n            CacheEventFactory.destroyInstance();\n        }\n    };\n    return cache;\n};\nvar isCache = (cache)=>{\n    return cache !== null && typeof cache === \"object\" && \"coordinate\" in cache && \"registry\" in cache && \"api\" in cache && \"cacheMap\" in cache && \"operations\" in cache;\n};\n// src/InstanceFactory.ts\nvar logger24 = logger_default.get(\"InstanceFactory\");\nvar createInstanceFactory = (api, options)=>{\n    const templateOptions = createOptions(options);\n    validateOptions(templateOptions);\n    return (coordinate, context)=>{\n        const instanceOptions = createOptions(options);\n        logger24.debug(\"Creating cache instance\", {\n            coordinate,\n            registry: context.registry,\n            api,\n            cacheType: instanceOptions.cacheType,\n            options: instanceOptions\n        });\n        const cacheMap = createCacheMap(coordinate.kta, instanceOptions);\n        const pkType = coordinate.kta[0];\n        const eventEmitter = new CacheEventEmitter();\n        const ttlManager = new TTLManager({\n            defaultTTL: instanceOptions.ttl,\n            autoCleanup: true,\n            validateOnAccess: true\n        });\n        const evictionManager = new EvictionManager();\n        const statsManager = new CacheStatsManager();\n        const operations = createOperations(api, coordinate, cacheMap, pkType, instanceOptions, eventEmitter, ttlManager, evictionManager, statsManager);\n        return {\n            coordinate,\n            registry: context.registry,\n            api,\n            cacheMap,\n            operations,\n            options: instanceOptions,\n            eventEmitter,\n            ttlManager,\n            evictionManager,\n            getCacheInfo: ()=>{\n                var _cacheMap_supportsTTL;\n                const evictionStrategyName = evictionManager.getEvictionStrategyName();\n                const cacheInfo = {\n                    implementationType: cacheMap.implementationType,\n                    defaultTTL: ttlManager.getDefaultTTL(),\n                    supportsTTL: ((_cacheMap_supportsTTL = cacheMap.supportsTTL) === null || _cacheMap_supportsTTL === void 0 ? void 0 : _cacheMap_supportsTTL.call(cacheMap)) || !!ttlManager.getDefaultTTL(),\n                    supportsEviction: evictionManager.isEvictionSupported()\n                };\n                if (evictionStrategyName) {\n                    cacheInfo.evictionPolicy = evictionStrategyName;\n                }\n                return cacheInfo;\n            },\n            subscribe: (listener, options2)=>eventEmitter.subscribe(listener, options2),\n            unsubscribe: (subscription)=>eventEmitter.unsubscribe(subscription.id),\n            destroy: ()=>{\n                if (typeof ttlManager.destroy === \"function\") {\n                    ttlManager.destroy();\n                }\n                eventEmitter.destroy();\n            }\n        };\n    };\n};\n// src/Instance.ts\nvar logger25 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate, api, options)=>{\n    logger25.debug(\"createInstance\", {\n        coordinate,\n        api,\n        registry,\n        options\n    });\n    return createCache(api, coordinate, registry, options);\n};\nvar isInstance = (instance)=>{\n    return instance !== null && typeof instance === \"object\" && \"coordinate\" in instance && \"registry\" in instance && \"api\" in instance && \"cacheMap\" in instance && \"operations\" in instance;\n};\n// src/Aggregator.ts\nvar logger26 = logger_default.get(\"ItemAggregator\");\nvar toCacheConfig = (config)=>{\n    let cacheConfig;\n    if (config.optional === void 0) {\n        cacheConfig = {\n            cache: config,\n            optional: false\n        };\n    } else {\n        cacheConfig = config;\n    }\n    return cacheConfig;\n};\nvar createAggregator = async (cache, param)=>{\n    let { aggregates = {}, events = {} } = param;\n    const populate = async (item)=>{\n        logger26.default(\"populate\", {\n            item\n        });\n        for(const key in aggregates){\n            await populateAggregate(key, item);\n        }\n        for(const key in events){\n            await populateEvent(key, item);\n        }\n        logger26.default(\"populate done\", {\n            item\n        });\n        return item;\n    };\n    const populateAggregate = async (key, item)=>{\n        logger26.default(\"populate aggregate key\", {\n            key\n        });\n        const cacheConfig = toCacheConfig(aggregates[key]);\n        if (item.refs === void 0) {\n            if (cacheConfig.optional === false) {\n                logger26.error(\"Item does not have refs an is not optional \", {\n                    item\n                });\n                throw new Error(\"Item does not have refs an is not optional \" + JSON.stringify(item));\n            } else {\n                if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n                    delete item.events[key];\n                }\n            }\n        } else if (item.refs[key] === void 0) {\n            if (cacheConfig.optional === false) {\n                logger26.error(\"Item does not have mandatory ref with key, not optional \", {\n                    key,\n                    item\n                });\n                throw new Error(\"Item does not have mandatory ref with key, not optional \" + key + \" \" + JSON.stringify(item));\n            } else {\n                if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n                    delete item.events[key];\n                }\n            }\n        } else {\n            const ref = item.refs[key];\n            logger26.default(\"AGG Retrieving Item in Populate\", {\n                key: ref\n            });\n            const newItem = await cacheConfig.cache.operations.retrieve(ref);\n            if (newItem) {\n                if (item.aggs === void 0) {\n                    item.aggs = {};\n                }\n                item.aggs[key] = {\n                    key: ref,\n                    item: newItem\n                };\n            }\n        }\n    };\n    const populateEvent = async (key, item)=>{\n        logger26.default(\"populate event key\", {\n            key\n        });\n        const cacheConfig = toCacheConfig(events[key]);\n        if (item.events === void 0) {\n            throw new Error(\"Item does not have events \" + JSON.stringify(item));\n        } else if (item.events[key] === void 0) {\n            if (cacheConfig.optional === false) {\n                logger26.error(\"Item does not have mandatory event with key\", {\n                    key,\n                    item\n                });\n                throw new Error(\"Item does not have mandatory event with key \" + key + \" \" + JSON.stringify(item));\n            }\n        } else {\n            const event = item.events[key];\n            if (event.by === void 0) {\n                logger26.error(\"populateEvent with an Event that does not have by\", {\n                    event,\n                    ik: item.key,\n                    eventKey: key\n                });\n                throw new Error(\"populateEvent with an Event that does not have by: \" + JSON.stringify({\n                    key\n                }));\n            }\n            logger26.default(\"EVENT Retrieving Item in Populate\", {\n                key: event.by\n            });\n            const newItem = await cacheConfig.cache.operations.retrieve(event.by);\n            if (newItem) {\n                event.agg = newItem;\n            }\n        }\n    };\n    const all2 = async function() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger26.default(\"all\", {\n            query,\n            locations\n        });\n        const items = await cache.operations.all(query, locations);\n        const populatedItems = await Promise.all(items.map(async (item)=>populate(item)));\n        return populatedItems;\n    };\n    const one2 = async function() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger26.default(\"one\", {\n            query,\n            locations\n        });\n        const item = await cache.operations.one(query, locations);\n        let populatedItem = null;\n        if (item) {\n            populatedItem = await populate(item);\n        }\n        return populatedItem;\n    };\n    const action2 = async function(key, action3) {\n        let body = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        logger26.default(\"action\", {\n            key,\n            action: action3,\n            body\n        });\n        const item = await cache.operations.action(key, action3, body);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const allAction2 = async function(action3) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        logger26.default(\"action\", {\n            action: action3,\n            body,\n            locations\n        });\n        const items = await cache.operations.allAction(action3, body, locations);\n        const populatedItems = await Promise.all(items.map(async (item)=>populate(item)));\n        return populatedItems;\n    };\n    const allFacet2 = async function(facet3) {\n        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        logger26.default(\"allFacet\", {\n            facet: facet3,\n            params,\n            locations\n        });\n        const response = await cache.operations.allFacet(facet3, params, locations);\n        return response;\n    };\n    const create2 = async function(v) {\n        let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        logger26.default(\"create\", {\n            v,\n            locations\n        });\n        const item = await cache.operations.create(v, locations);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const get2 = async (key)=>{\n        logger26.default(\"get\", {\n            key\n        });\n        const item = await cache.operations.get(key);\n        let populatedItem = null;\n        if (item) {\n            populatedItem = await populate(item);\n        }\n        return populatedItem;\n    };\n    const retrieve2 = async (key)=>{\n        logger26.default(\"retrieve\", {\n            key\n        });\n        const item = await cache.operations.retrieve(key);\n        let populatedItem = null;\n        if (item) {\n            populatedItem = await populate(item);\n        }\n        return populatedItem;\n    };\n    const remove2 = async (key)=>{\n        logger26.default(\"remove\", {\n            key\n        });\n        await cache.operations.remove(key);\n    };\n    const update2 = async (key, v)=>{\n        logger26.default(\"update\", {\n            key,\n            v\n        });\n        const item = await cache.operations.update(key, v);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const facet2 = async (key, facet3)=>{\n        logger26.default(\"facet\", {\n            key,\n            facet: facet3\n        });\n        const response = await cache.operations.facet(key, facet3);\n        return response;\n    };\n    const find2 = async function(finder) {\n        let finderParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        logger26.default(\"find\", {\n            finder,\n            finderParams,\n            locations\n        });\n        const items = await cache.operations.find(finder, finderParams, locations);\n        const populatedItems = await Promise.all(items.map(async (item)=>populate(item)));\n        return populatedItems;\n    };\n    const findOne2 = async function(finder) {\n        let finderParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        logger26.default(\"find\", {\n            finder,\n            finderParams,\n            locations\n        });\n        const item = await cache.operations.findOne(finder, finderParams, locations);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const set2 = async (key, v)=>{\n        logger26.default(\"set\", {\n            key,\n            v\n        });\n        const item = await cache.operations.set(key, v);\n        const populatedItem = await populate(item);\n        return populatedItem;\n    };\n    const reset2 = async ()=>{\n        await cache.operations.reset();\n    };\n    return {\n        // Cache properties\n        coordinate: cache.coordinate,\n        registry: cache.registry,\n        api: cache.api,\n        cacheMap: cache.cacheMap,\n        operations: cache.operations,\n        evictionManager: cache.evictionManager,\n        ttlManager: cache.ttlManager,\n        statsManager: cache.statsManager,\n        getStats: cache.getStats.bind(cache),\n        getCacheInfo: cache.getCacheInfo.bind(cache),\n        // Cache operations exposed directly\n        all: all2,\n        one: one2,\n        action: action2,\n        allAction: allAction2,\n        allFacet: allFacet2,\n        create: create2,\n        get: get2,\n        retrieve: retrieve2,\n        remove: remove2,\n        update: update2,\n        facet: facet2,\n        find: find2,\n        findOne: findOne2,\n        reset: reset2,\n        set: set2,\n        // Aggregator-specific operations\n        populate,\n        populateAggregate,\n        populateEvent,\n        // Event system\n        eventEmitter: cache.eventEmitter,\n        subscribe: (listener, options)=>cache.subscribe(listener, options),\n        unsubscribe: (subscription)=>cache.unsubscribe(subscription),\n        destroy: ()=>cache.destroy()\n    };\n};\n// src/Registry.ts\n\nvar logger27 = logger_default.get(\"Registry\");\nvar createRegistryFactory = ()=>{\n    return (type, registryHub)=>{\n        if (type !== \"cache\") {\n            throw new Error(\"Cache registry factory can only create 'cache' type registries, got: \".concat(type));\n        }\n        logger27.debug(\"Creating cache registry\", {\n            type,\n            registryHub\n        });\n        const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(type, registryHub);\n        return baseRegistry;\n    };\n};\nvar createRegistry = (registryHub)=>{\n    const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(\"cache\", registryHub);\n    return {\n        ...baseRegistry\n    };\n};\n //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtRE8sSUFBTSxxQkFBcUIsQ0FTOUIsS0FDQSxVQUNBLFFBQ0EsU0FDQSxjQUNBLFlBQ0EsaUJBQ0E7SUFFRixPQUFPO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtJQUNGO0FBQ0Y7O0FDMUVPO0FBQ3VCOztBQ0Z2QixJQUFNLG9CQUFvQixDQUFDO0lBQ2hDLE9BQU8sT0FBTyxLQUFLO0FBQ3JCO0FBR0EsSUFBTSx5QkFBeUIsQ0FBQztJQUM5QixJQUFJLFFBQVEsUUFBUSxPQUFPLFFBQVEsVUFBVTtRQUMzQyxPQUFPLEtBQUssVUFBVSxHQUFHO0lBQzNCO0lBRUEsSUFBSSxNQUFNLFFBQVEsR0FBRyxHQUFHO1FBQ3RCLE9BQU8sTUFBTSxJQUFJLElBQUksc0JBQXNCLEVBQUUsS0FBSyxHQUFHLElBQUk7SUFDM0Q7SUFFQSxNQUFNLGFBQWEsT0FBTyxLQUFLLEdBQUcsRUFBRSxLQUFLO0lBQ3pDLE1BQU0sZ0JBQWdCLFdBQVcsSUFBSTtRQUNuQyxPQUFPLEtBQUssVUFBVSxHQUFHLElBQUksTUFBTSx1QkFBdUIsSUFBSSxHQUFHLENBQUM7SUFDcEUsQ0FBQztJQUVELE9BQU8sTUFBTSxjQUFjLEtBQUssR0FBRyxJQUFJO0FBQ3pDO0FBR08sSUFBTSwrQkFBK0I7SUFDMUMsT0FBTyxDQUFDO1FBQ04sSUFBSSxPQUFPLFFBQVEsWUFBWSxRQUFRLE1BQU07WUFFM0MsTUFBTSxnQkFBZ0IsS0FBSyxNQUFNLEtBQUssVUFBVSxHQUFHLENBQUM7WUFHcEQsSUFBSSxRQUFRLGlCQUFpQixjQUFjLE9BQU8sTUFBTTtnQkFDdEQsY0FBYyxLQUFLLGtCQUFrQixjQUFjLEVBQUU7WUFDdkQ7WUFHQSxJQUFJLFFBQVEsaUJBQWlCLGNBQWMsT0FBTyxN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LCtEQUFrQixDQUFDLE1BQU0sV0FBVztRQUd6RCxPQUFPO0lBQ1Q7QUFDRjtBQUtPLElBQU0saUJBQWlCLENBQUM7SUFDN0IsTUFBTSxlQUFlLCtEQUFrQixDQUFDLFNBQVMsV0FBVztJQUU1RCxPQUFPO1FBQ0wsR0FBRztJQUNMO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0NhY2hlQ29udGV4dC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9hbGwudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ub3JtYWxpemF0aW9uLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZlbnRzL0NhY2hlRXZlbnRGYWN0b3J5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvbG9nZ2VyLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL29uZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL3V0aWxzL0NhY2hlU2l6ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9jcmVhdGUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvZ2V0LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL3JldHJpZXZlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL3JlbW92ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy91cGRhdGUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvYWN0aW9uLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2FsbEFjdGlvbi50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9mYWNldC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9hbGxGYWNldC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9maW5kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2ZpbmRPbmUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvc2V0LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvbWVtb3J5L01lbW9yeUNhY2hlTWFwLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvQ2FjaGVNYXAudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9tZW1vcnkvRW5oYW5jZWRNZW1vcnlDYWNoZU1hcC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2Jyb3dzZXIvTG9jYWxTdG9yYWdlQ2FjaGVNYXAudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9icm93c2VyL1Nlc3Npb25TdG9yYWdlQ2FjaGVNYXAudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9icm93c2VyL0luZGV4REJDYWNoZU1hcC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2Jyb3dzZXIvQXN5bmNJbmRleERCQ2FjaGVNYXAudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9PcHRpb25zLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL3Jlc2V0LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvT3BlcmF0aW9ucy50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL0V2aWN0aW9uTWFuYWdlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lDb25maWcudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9MUlVFdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneVZhbGlkYXRpb24udHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ldmljdGlvbi9zdHJhdGVnaWVzL0xGVUV2aWN0aW9uU3RyYXRlZ3kudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ldmljdGlvbi9zdHJhdGVnaWVzL0ZJRk9FdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9NUlVFdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9SYW5kb21FdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9BUkNFdmljdGlvblN0cmF0ZWd5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9Ud29RdWV1ZUV2aWN0aW9uU3RyYXRlZ3kudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5RmFjdG9yeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL3R0bC9UVExNYW5hZ2VyLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXZlbnRzL0NhY2hlRXZlbnRFbWl0dGVyLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvQ2FjaGVTdGF0cy50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0NhY2hlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvSW5zdGFuY2VGYWN0b3J5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvSW5zdGFuY2UudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9BZ2dyZWdhdG9yLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvUmVnaXN0cnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlbSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpIH0gZnJvbSBcIkBmamVsbC9jbGllbnQtYXBpXCI7XG5pbXBvcnQgeyBDYWNoZU1hcCB9IGZyb20gXCIuL0NhY2hlTWFwXCI7XG5pbXBvcnQgeyBPcHRpb25zIH0gZnJvbSBcIi4vT3B0aW9uc1wiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi9ldmVudHMvQ2FjaGVFdmVudEVtaXR0ZXJcIjtcbmltcG9ydCB7IFRUTE1hbmFnZXIgfSBmcm9tIFwiLi90dGwvVFRMTWFuYWdlclwiO1xuaW1wb3J0IHsgRXZpY3Rpb25NYW5hZ2VyIH0gZnJvbSBcIi4vZXZpY3Rpb24vRXZpY3Rpb25NYW5hZ2VyXCI7XG5pbXBvcnQgeyBDYWNoZVN0YXRzTWFuYWdlciB9IGZyb20gXCIuL0NhY2hlU3RhdHNcIjtcblxuLyoqXG4gKiBDb250ZXh0IG9iamVjdCB0aGF0IGNvbnNvbGlkYXRlcyBhbGwgY2FjaGUtcmVsYXRlZCBwYXJhbWV0ZXJzXG4gKiBwYXNzZWQgdG8gY2FjaGUgb3BlcmF0aW9ucy4gVGhpcyBwcmV2ZW50cyBjYWNoZSBjb25jZXJucyBmcm9tXG4gKiBwb2xsdXRpbmcgb3BlcmF0aW9uIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVDb250ZXh0PFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IHtcbiAgLyoqIFRoZSBjbGllbnQgQVBJIGZvciBtYWtpbmcgcmVxdWVzdHMgKi9cbiAgYXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogVGhlIGNhY2hlIG1hcCBmb3Igc3RvcmluZyBhbmQgcmV0cmlldmluZyBjYWNoZWQgaXRlbXMgKi9cbiAgY2FjaGVNYXA6IENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLyoqIFRoZSBwcmltYXJ5IGtleSB0eXBlICovXG4gIHBrVHlwZTogUztcblxuICAvKiogQ2FjaGUgb3B0aW9ucyBpbmNsdWRpbmcgVFRMIGNvbmZpZ3VyYXRpb24gKi9cbiAgb3B0aW9uczogT3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKiBFdmVudCBlbWl0dGVyIGZvciBjYWNoZSBldmVudHMgKi9cbiAgZXZlbnRFbWl0dGVyOiBDYWNoZUV2ZW50RW1pdHRlcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKiBUVEwgbWFuYWdlciBmb3IgaGFuZGxpbmcgdGltZS10by1saXZlIGluZGVwZW5kZW50bHkgb2Ygc3RvcmFnZSAqL1xuICB0dGxNYW5hZ2VyOiBUVExNYW5hZ2VyO1xuXG4gIC8qKiBFdmljdGlvbiBtYW5hZ2VyIGZvciBoYW5kbGluZyBjYWNoZSBldmljdGlvbiBpbmRlcGVuZGVudGx5IG9mIHN0b3JhZ2UgKi9cbiAgZXZpY3Rpb25NYW5hZ2VyOiBFdmljdGlvbk1hbmFnZXI7XG5cbiAgLyoqIFN0YXRpc3RpY3MgbWFuYWdlciBmb3IgdHJhY2tpbmcgY2FjaGUgbWV0cmljcyAqL1xuICBzdGF0c01hbmFnZXI6IENhY2hlU3RhdHNNYW5hZ2VyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBDYWNoZUNvbnRleHQgZnJvbSB0aGUgaW5kaXZpZHVhbCBjYWNoZS1yZWxhdGVkIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNhY2hlQ29udGV4dCA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBhcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGNhY2hlTWFwOiBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIHBrVHlwZTogUyxcbiAgICBvcHRpb25zOiBPcHRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgZXZlbnRFbWl0dGVyOiBDYWNoZUV2ZW50RW1pdHRlcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIHR0bE1hbmFnZXI6IFRUTE1hbmFnZXIsXG4gICAgZXZpY3Rpb25NYW5hZ2VyOiBFdmljdGlvbk1hbmFnZXIsXG4gICAgc3RhdHNNYW5hZ2VyOiBDYWNoZVN0YXRzTWFuYWdlclxuICApOiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG4gIHJldHVybiB7XG4gICAgYXBpLFxuICAgIGNhY2hlTWFwLFxuICAgIHBrVHlwZSxcbiAgICBvcHRpb25zLFxuICAgIGV2ZW50RW1pdHRlcixcbiAgICB0dGxNYW5hZ2VyLFxuICAgIGV2aWN0aW9uTWFuYWdlcixcbiAgICBzdGF0c01hbmFnZXJcbiAgfTtcbn07XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICB2YWxpZGF0ZVBLXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgTm90Rm91bmRFcnJvciB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCB7IGNyZWF0ZVF1ZXJ5SGFzaCB9IGZyb20gXCIuLi9ub3JtYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RmFjdG9yeSB9IGZyb20gXCIuLi9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnlcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdhbGwnKTtcblxuZXhwb3J0IGNvbnN0IGFsbCA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgcXVlcnk6IEl0ZW1RdWVyeSA9IHt9LFxuICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdLFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxbQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIFZbXV0+ID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUsIHR0bE1hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdhbGwnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG5cbiAgLy8gR2VuZXJhdGUgcXVlcnkgaGFzaCBmb3IgY2FjaGluZ1xuICBjb25zdCBxdWVyeUhhc2ggPSBjcmVhdGVRdWVyeUhhc2gocGtUeXBlLCBxdWVyeSwgbG9jYXRpb25zKTtcbiAgbG9nZ2VyLmRlYnVnKCdHZW5lcmF0ZWQgcXVlcnkgaGFzaCBmb3IgYWxsJywgeyBxdWVyeUhhc2ggfSk7XG5cbiAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBjYWNoZWQgcXVlcnkgcmVzdWx0c1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cykge1xuICAgIGxvZ2dlci5kZWJ1ZygnVXNpbmcgY2FjaGVkIHF1ZXJ5IHJlc3VsdHMnLCB7IGNhY2hlZEtleUNvdW50OiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggfSk7XG5cbiAgICAvLyBSZXRyaWV2ZSBhbGwgY2FjaGVkIGl0ZW1zIC0gaWYgYW55IGFyZSBtaXNzaW5nLCBpbnZhbGlkYXRlIHRoZSBxdWVyeSBjYWNoZVxuICAgIGNvbnN0IGNhY2hlZEl0ZW1zOiBWW10gPSBbXTtcbiAgICBsZXQgYWxsSXRlbXNBdmFpbGFibGUgPSB0cnVlO1xuXG4gICAgZm9yIChjb25zdCBpdGVtS2V5IG9mIGNhY2hlZEl0ZW1LZXlzKSB7XG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGl0ZW1LZXkpO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY2FjaGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbEl0ZW1zQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbGxJdGVtc0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKGNhY2hlZEl0ZW1zLCBwa1R5cGUpIGFzIFZbXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU29tZSBjYWNoZWQgaXRlbXMgbWlzc2luZywgaW52YWxpZGF0aW5nIHF1ZXJ5IGNhY2hlJyk7XG4gICAgICBjYWNoZU1hcC5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIGNhY2hlZCBxdWVyeSByZXN1bHRzLCB0cnkgdG8gZmluZCBpdGVtcyBkaXJlY3RseSBpbiBjYWNoZSB1c2luZyBxdWVyeUluXG4gIC8vIFRoaXMgaGFuZGxlcyBjYXNlcyB3aGVyZSBpbmRpdmlkdWFsIGl0ZW1zIGFyZSBjYWNoZWQgYnV0IHF1ZXJ5IHJlc3VsdHMgYXJlIG5vdCB5ZXQgY2FjaGVkXG4gIHRyeSB7XG4gICAgY29uc3QgZGlyZWN0Q2FjaGVkSXRlbXMgPSBhd2FpdCBjYWNoZU1hcC5xdWVyeUluKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIGlmIChkaXJlY3RDYWNoZWRJdGVtcyAmJiBkaXJlY3RDYWNoZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0ZvdW5kIGl0ZW1zIGRpcmVjdGx5IGluIGNhY2hlLCBza2lwcGluZyBBUEkgY2FsbCcsIHsgaXRlbUNvdW50OiBkaXJlY3RDYWNoZWRJdGVtcy5sZW5ndGggfSk7XG5cbiAgICAgIC8vIENhY2hlIHRoZSBxdWVyeSByZXN1bHQgZm9yIGZ1dHVyZSB1c2VcbiAgICAgIGNvbnN0IGl0ZW1LZXlzID0gZGlyZWN0Q2FjaGVkSXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5rZXkpO1xuICAgICAgYXdhaXQgY2FjaGVNYXAuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cyk7XG4gICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlZCBxdWVyeSByZXN1bHQgZnJvbSBkaXJlY3QgY2FjaGUgaGl0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXlDb3VudDogaXRlbUtleXMubGVuZ3RoIH0pO1xuXG4gICAgICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsoZGlyZWN0Q2FjaGVkSXRlbXMsIHBrVHlwZSkgYXMgVltdXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdFcnJvciBxdWVyeWluZyBjYWNoZSBkaXJlY3RseSwgcHJvY2VlZGluZyB0byBBUEknLCB7IGVycm9yIH0pO1xuICB9XG5cbiAgLy8gRmV0Y2ggZnJvbSBBUElcbiAgbGV0IHJldDogVltdID0gW107XG4gIHRyeSB7XG4gICAgcmV0ID0gYXdhaXQgYXBpLmFsbChxdWVyeSwgbG9jYXRpb25zKTtcblxuICAgIC8vIFN0b3JlIGluZGl2aWR1YWwgaXRlbXMgaW4gY2FjaGVcbiAgICBmb3IgKGNvbnN0IHYgb2YgcmV0KSB7XG4gICAgICBhd2FpdCBjYWNoZU1hcC5zZXQodi5rZXksIHYpO1xuXG4gICAgICAvLyBTZXQgVFRMIG1ldGFkYXRhIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHYua2V5KTtcbiAgICAgIHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG5cbiAgICAgIC8vIEhhbmRsZSBldmljdGlvbiBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gICAgICBjb25zdCBldmljdGVkS2V5cyA9IGF3YWl0IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdiwgY2FjaGVNYXApO1xuICAgICAgLy8gUmVtb3ZlIGV2aWN0ZWQgaXRlbXMgZnJvbSBjYWNoZVxuICAgICAgZm9yIChjb25zdCBldmljdGVkS2V5IG9mIGV2aWN0ZWRLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICAgIGF3YWl0IGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0b3JlIHF1ZXJ5IHJlc3VsdCAoaXRlbSBrZXlzKSBpbiBxdWVyeSBjYWNoZVxuICAgIGNvbnN0IGl0ZW1LZXlzID0gcmV0Lm1hcChpdGVtID0+IGl0ZW0ua2V5KTtcbiAgICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGl0ZW1LZXlzKTtcbiAgICBsb2dnZXIuZGVidWcoJ0NhY2hlZCBxdWVyeSByZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleUNvdW50OiBpdGVtS2V5cy5sZW5ndGggfSk7XG5cbiAgICAvLyBFbWl0IHF1ZXJ5IGV2ZW50XG4gICAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5jcmVhdGVRdWVyeUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ocXVlcnksIGxvY2F0aW9ucywgcmV0KTtcbiAgICBjb250ZXh0LmV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcblxuICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSB7XG4gICAgICAvLyBIYW5kbGUgbm90IGZvdW5kIGdyYWNlZnVsbHkgLSBjYWNoZSBlbXB0eSByZXN1bHRcbiAgICAgIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW10pO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgZW1wdHkgcXVlcnkgcmVzdWx0IGZvciBub3QgZm91bmQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKHJldCwgcGtUeXBlKSBhcyBWW11dO1xufTtcbiIsIi8vIE5vcm1hbGl6YXRpb24gdXRpbGl0aWVzIGZvciBjYWNoZSBrZXlzXG5pbXBvcnQgeyBJdGVtUXVlcnksIExvY0tleUFycmF5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5cbi8vIE5vcm1hbGl6ZSBhIGtleSB2YWx1ZSB0byBzdHJpbmcgZm9yIGNvbnNpc3RlbnQgY29tcGFyaXNvbiBhbmQgaGFzaGluZ1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUtleVZhbHVlID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgZGV0ZXJtaW5pc3RpYyBKU09OIHN0cmluZyB3aXRoIHNvcnRlZCBrZXlzXG5jb25zdCBkZXRlcm1pbmlzdGljU3RyaW5naWZ5ID0gKG9iajogYW55KTogc3RyaW5nID0+IHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiAnWycgKyBvYmoubWFwKGRldGVybWluaXN0aWNTdHJpbmdpZnkpLmpvaW4oJywnKSArICddJztcbiAgfVxuXG4gIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IHNvcnRlZEtleXMubWFwKGtleSA9PiB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnOicgKyBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9ialtrZXldKTtcbiAgfSk7XG5cbiAgcmV0dXJuICd7JyArIGtleVZhbHVlUGFpcnMuam9pbignLCcpICsgJ30nO1xufTtcblxuLy8gTm9ybWFsaXplZCBoYXNoIGZ1bmN0aW9uIGZvciBEaWN0aW9uYXJ5IHRoYXQgY29udmVydHMgcGsvbGsgdmFsdWVzIHRvIHN0cmluZ3NcbmV4cG9ydCBjb25zdCBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gPFQ+KCkgPT4ge1xuICByZXR1cm4gKGtleTogVCk6IHN0cmluZyA9PiB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgLy8gQ3JlYXRlIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBrZXkgd2l0aCBzdHJpbmcgdmFsdWVzXG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShrZXkpKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHBrIHZhbHVlc1xuICAgICAgaWYgKCdwaycgaW4gbm9ybWFsaXplZEtleSAmJiBub3JtYWxpemVkS2V5LnBrICE9PSBudWxsKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkucGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LnBrKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGxrIHZhbHVlc1xuICAgICAgaWYgKCdsaycgaW4gbm9ybWFsaXplZEtleSAmJiBub3JtYWxpemVkS2V5LmxrICE9PSBudWxsKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LmxrKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGxvYyBhcnJheSBsayB2YWx1ZXNcbiAgICAgIGlmICgnbG9jJyBpbiBub3JtYWxpemVkS2V5ICYmIEFycmF5LmlzQXJyYXkobm9ybWFsaXplZEtleS5sb2MpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubG9jID0gbm9ybWFsaXplZEtleS5sb2MubWFwKChsb2NJdGVtOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxvY0l0ZW0gPT09ICdvYmplY3QnICYmIGxvY0l0ZW0gIT09IG51bGwgJiYgJ2xrJyBpbiBsb2NJdGVtICYmIChsb2NJdGVtIGFzIGFueSkubGsgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmxvY0l0ZW0sIGxrOiBub3JtYWxpemVLZXlWYWx1ZSgobG9jSXRlbSBhcyBhbnkpLmxrKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9jSXRlbTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBkZXRlcm1pbmlzdGljIHN0cmluZ2lmeSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgb3JkZXJpbmdcbiAgICAgIHJldHVybiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG5vcm1hbGl6ZWRLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgfTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBub3JtYWxpemUgYW5kIGNvbXBhcmUgbG9jYXRpb24ga2V5IGFycmF5c1xuZXhwb3J0IGNvbnN0IGlzTG9jS2V5QXJyYXlFcXVhbCA9IChhOiBhbnlbXSwgYjogYW55W10pOiBib29sZWFuID0+IHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBID0gbm9ybWFsaXplTG9jS2V5SXRlbShhW2ldKTtcbiAgICBjb25zdCBub3JtYWxpemVkQiA9IG5vcm1hbGl6ZUxvY0tleUl0ZW0oYltpXSk7XG5cbiAgICBpZiAoZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShub3JtYWxpemVkQSkgIT09IGRldGVybWluaXN0aWNTdHJpbmdpZnkobm9ybWFsaXplZEIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGEgbG9jYXRpb24ga2V5IGl0ZW1cbmV4cG9ydCBjb25zdCBub3JtYWxpemVMb2NLZXlJdGVtID0gKGl0ZW06IGFueSk6IGFueSA9PiB7XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7IC4uLml0ZW0gfTtcblxuICAgIGlmICgnbGsnIGluIG5vcm1hbGl6ZWQgJiYgbm9ybWFsaXplZC5sayAhPT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZC5sayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWQubGspO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG4vLyBRdWVyeSByZXN1bHQgY2FjaGUgdXRpbGl0aWVzXG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBzdG9yaW5nIHF1ZXJ5IHJlc3VsdHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeUNhY2hlRW50cnkge1xuICBpdGVtS2V5czogKGFueSlbXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNhZmUgaGFzaCBmb3IgYWxsL29uZSBxdWVyeSBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVRdWVyeUhhc2ggPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgcGtUeXBlOiBTLFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogc3RyaW5nID0+IHtcbiAgLy8gTm9ybWFsaXplIHRoZSBxdWVyeSBvYmplY3QgZm9yIGNvbnNpc3RlbnQgb3JkZXJpbmdcbiAgY29uc3Qgbm9ybWFsaXplZFF1ZXJ5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShxdWVyeSB8fCB7fSkpO1xuXG4gIC8vIFNvcnQga2V5cyB0byBlbnN1cmUgY29uc2lzdGVudCBoYXNoXG4gIGNvbnN0IHNvcnRlZFF1ZXJ5S2V5cyA9IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRRdWVyeSkuc29ydCgpO1xuICBjb25zdCBzb3J0ZWRRdWVyeTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICBzb3J0ZWRRdWVyeUtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgIHNvcnRlZFF1ZXJ5W2tleV0gPSBub3JtYWxpemVkUXVlcnlba2V5XTtcbiAgfSk7XG5cbiAgLy8gTm9ybWFsaXplIGxvY2F0aW9ucyB1c2luZyBleGlzdGluZyB1dGlsaXR5IC0gZW5zdXJlIGxvY2F0aW9ucyBpcyBhbiBhcnJheVxuICBjb25zdCBsb2NhdGlvbnNBcnJheSA9IEFycmF5LmlzQXJyYXkobG9jYXRpb25zKSA/IGxvY2F0aW9ucyA6IFtdO1xuICBjb25zdCBub3JtYWxpemVkTG9jYXRpb25zID0gbG9jYXRpb25zQXJyYXkubWFwKG5vcm1hbGl6ZUxvY0tleUl0ZW0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgaGFzaCBpbnB1dCBvYmplY3RcbiAgY29uc3QgaGFzaElucHV0ID0ge1xuICAgIHR5cGU6ICdxdWVyeScsXG4gICAgcGtUeXBlLFxuICAgIHF1ZXJ5OiBzb3J0ZWRRdWVyeSxcbiAgICBsb2NhdGlvbnM6IG5vcm1hbGl6ZWRMb2NhdGlvbnNcbiAgfTtcblxuICByZXR1cm4gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShoYXNoSW5wdXQpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNhZmUgaGFzaCBmb3IgZmluZC9maW5kT25lIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUZpbmRlckhhc2ggPSA8XG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogc3RyaW5nID0+IHtcbiAgLy8gTm9ybWFsaXplIHRoZSBwYXJhbXMgb2JqZWN0IGZvciBjb25zaXN0ZW50IG9yZGVyaW5nXG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXJhbXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcmFtcyB8fCB7fSkpO1xuXG4gIC8vIFNvcnQga2V5cyB0byBlbnN1cmUgY29uc2lzdGVudCBoYXNoXG4gIGNvbnN0IHNvcnRlZFBhcmFtS2V5cyA9IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRQYXJhbXMpLnNvcnQoKTtcbiAgY29uc3Qgc29ydGVkUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIHNvcnRlZFBhcmFtS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgc29ydGVkUGFyYW1zW2tleV0gPSBub3JtYWxpemVkUGFyYW1zW2tleV07XG4gIH0pO1xuXG4gIC8vIE5vcm1hbGl6ZSBsb2NhdGlvbnMgdXNpbmcgZXhpc3RpbmcgdXRpbGl0eSAtIGVuc3VyZSBsb2NhdGlvbnMgaXMgYW4gYXJyYXlcbiAgY29uc3QgbG9jYXRpb25zQXJyYXkgPSBBcnJheS5pc0FycmF5KGxvY2F0aW9ucykgPyBsb2NhdGlvbnMgOiBbXTtcbiAgY29uc3Qgbm9ybWFsaXplZExvY2F0aW9ucyA9IGxvY2F0aW9uc0FycmF5Lm1hcChub3JtYWxpemVMb2NLZXlJdGVtKTtcblxuICAvLyBDcmVhdGUgdGhlIGhhc2ggaW5wdXQgb2JqZWN0XG4gIGNvbnN0IGhhc2hJbnB1dCA9IHtcbiAgICB0eXBlOiAnZmluZGVyJyxcbiAgICBmaW5kZXIsXG4gICAgcGFyYW1zOiBzb3J0ZWRQYXJhbXMsXG4gICAgbG9jYXRpb25zOiBub3JtYWxpemVkTG9jYXRpb25zXG4gIH07XG5cbiAgcmV0dXJuIGRldGVybWluaXN0aWNTdHJpbmdpZnkoaGFzaElucHV0KTtcbn07XG4iLCJcbmltcG9ydCB7IENvbUtleSwgSXRlbSwgSXRlbVF1ZXJ5LCBMb2NLZXlBcnJheSwgUHJpS2V5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQge1xuICBDYWNoZUNsZWFyZWRFdmVudCxcbiAgSXRlbUV2ZW50LFxuICBMb2NhdGlvbkludmFsaWRhdGVkRXZlbnQsXG4gIFF1ZXJ5RXZlbnQsXG4gIFF1ZXJ5SW52YWxpZGF0ZWRFdmVudFxufSBmcm9tIFwiLi9DYWNoZUV2ZW50VHlwZXNcIjtcblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9ucyBmb3IgY3JlYXRpbmcgY2FjaGUgZXZlbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWNoZUV2ZW50RmFjdG9yeSB7XG4gIHByaXZhdGUgc3RhdGljIGxhc3RUaW1lc3RhbXAgPSAwO1xuICBwcml2YXRlIHN0YXRpYyBjbGVhbnVwSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlQ291bnQgPSAwO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBDTEVBTlVQX0lOVEVSVkFMX01TID0gNjAwMDA7IC8vIDEgbWludXRlXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1BWF9USU1FU1RBTVBfQUdFX01TID0gMzAwMDAwOyAvLyA1IG1pbnV0ZXNcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBjbGVhbnVwIG1lY2hhbmlzbSB3aGVuIGZpcnN0IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGluaXRpYWxpemVDbGVhbnVwKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbCA9PT0gbnVsbCAmJiB0aGlzLmluc3RhbmNlQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRDbGVhbnVwVGltZXIoKTtcbiAgICB9XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW51cCBtZWNoYW5pc20gd2hlbiBpbnN0YW5jZSBpcyBkZXN0cm95ZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZGVzdHJveUluc3RhbmNlKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IE1hdGgubWF4KDAsIHRoaXMuaW5zdGFuY2VDb3VudCAtIDEpO1xuICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMuc3RvcENsZWFudXBUaW1lcigpO1xuICAgICAgdGhpcy5yZXNldFRpbWVzdGFtcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhdXRvbWF0aWMgY2xlYW51cCB0aW1lclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3RhcnRDbGVhbnVwVGltZXIoKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnBlcmZvcm1DbGVhbnVwKCk7XG4gICAgfSwgdGhpcy5DTEVBTlVQX0lOVEVSVkFMX01TKTtcblxuICAgIC8vIERvbid0IGtlZXAgdGhlIHByb2Nlc3MgYWxpdmUganVzdCBmb3IgY2xlYW51cFxuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbC51bnJlZikge1xuICAgICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwudW5yZWYoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhdXRvbWF0aWMgY2xlYW51cCB0aW1lclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3RvcENsZWFudXBUaW1lcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHBlcmlvZGljIGNsZWFudXAgb2Ygc3RhbGUgdGltZXN0YW1wIHN0YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBwZXJmb3JtQ2xlYW51cCgpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIC8vIFJlc2V0IHRpbWVzdGFtcCBpZiBpdCdzIHRvbyBvbGQgdG8gcHJldmVudCBtZW1vcnkgaXNzdWVzXG4gICAgaWYgKG5vdyAtIHRoaXMubGFzdFRpbWVzdGFtcCA+IHRoaXMuTUFYX1RJTUVTVEFNUF9BR0VfTVMpIHtcbiAgICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0aW1lc3RhbXAgc3RhdGUgKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVzZXRUaW1lc3RhbXAoKTogdm9pZCB7XG4gICAgdGhpcy5sYXN0VGltZXN0YW1wID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSB0aW1lc3RhbXAgdGhhdCBpcyBhbHdheXMgZ3JlYXRlciB0aGFuIHRoZSBwcmV2aW91cyBvbmVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlVGltZXN0YW1wKCk6IG51bWJlciB7XG4gICAgdGhpcy5pbml0aWFsaXplQ2xlYW51cCgpO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAvLyBJZiBjdXJyZW50IHRpbWUgaXMgZ3JlYXRlciB0aGFuIGxhc3QgdGltZXN0YW1wLCB1c2UgY3VycmVudCB0aW1lXG4gICAgLy8gT3RoZXJ3aXNlLCBpbmNyZW1lbnQgbGFzdCB0aW1lc3RhbXAgdG8gZW5zdXJlIHVuaXF1ZW5lc3NcbiAgICBpZiAobm93ID4gdGhpcy5sYXN0VGltZXN0YW1wKSB7XG4gICAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSBub3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHRoaXMubGFzdFRpbWVzdGFtcCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBhZmZlY3RlZCBsb2NhdGlvbnMgZnJvbSBhbiBpdGVtIGtleVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZXh0cmFjdEFmZmVjdGVkTG9jYXRpb25zPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4oa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSB7XG4gICAgaWYgKCdsb2MnIGluIGtleSAmJiBrZXkubG9jKSB7XG4gICAgICByZXR1cm4ga2V5LmxvYztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtLXJlbGF0ZWQgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlSXRlbUV2ZW50PFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihcbiAgICB0eXBlOiAnaXRlbV9jcmVhdGVkJyB8ICdpdGVtX3VwZGF0ZWQnIHwgJ2l0ZW1fcmVtb3ZlZCcgfCAnaXRlbV9yZXRyaWV2ZWQnIHwgJ2l0ZW1fc2V0JyxcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IFYgfCBudWxsLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHByZXZpb3VzSXRlbT86IFYgfCBudWxsIHwgbnVsbDtcbiAgICAgIHNvdXJjZT86ICdhcGknIHwgJ2NhY2hlJyB8ICdvcGVyYXRpb24nO1xuICAgICAgYWZmZWN0ZWRMb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW107XG4gICAgICBjb250ZXh0Pzoge1xuICAgICAgICBvcGVyYXRpb24/OiBzdHJpbmc7XG4gICAgICAgIHJlcXVlc3RJZD86IHN0cmluZztcbiAgICAgICAgdXNlcklkPzogc3RyaW5nO1xuICAgICAgfTtcbiAgICB9ID0ge31cbiAgKTogSXRlbUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIC8vIEF1dG8tY2FsY3VsYXRlIGFmZmVjdGVkIGxvY2F0aW9ucyBpZiBub3QgcHJvdmlkZWRcbiAgICBjb25zdCBhZmZlY3RlZExvY2F0aW9ucyA9IG9wdGlvbnMuYWZmZWN0ZWRMb2NhdGlvbnMgIT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLmFmZmVjdGVkTG9jYXRpb25zXG4gICAgICA6IHRoaXMuZXh0cmFjdEFmZmVjdGVkTG9jYXRpb25zKGtleSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZW5lcmF0ZVRpbWVzdGFtcCgpLFxuICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSB8fCAnb3BlcmF0aW9uJyxcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgIGtleSxcbiAgICAgIGl0ZW0sXG4gICAgICBwcmV2aW91c0l0ZW06IG9wdGlvbnMucHJldmlvdXNJdGVtLFxuICAgICAgYWZmZWN0ZWRMb2NhdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHF1ZXJ5IGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZVF1ZXJ5RXZlbnQ8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+KFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10sXG4gICAgaXRlbXM6IFZbXSxcbiAgICBvcHRpb25zOiB7XG4gICAgICBzb3VyY2U/OiAnYXBpJyB8ICdjYWNoZScgfCAnb3BlcmF0aW9uJztcbiAgICAgIGNvbnRleHQ/OiB7XG4gICAgICAgIG9wZXJhdGlvbj86IHN0cmluZztcbiAgICAgICAgcmVxdWVzdElkPzogc3RyaW5nO1xuICAgICAgICB1c2VySWQ/OiBzdHJpbmc7XG4gICAgICB9O1xuICAgIH0gPSB7fVxuICApOiBRdWVyeUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIGNvbnN0IGFmZmVjdGVkS2V5cyA9IGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0ua2V5KTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaXRlbXNfcXVlcmllZCcsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgJ29wZXJhdGlvbicsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBxdWVyeSxcbiAgICAgIGxvY2F0aW9ucyxcbiAgICAgIGl0ZW1zLFxuICAgICAgYWZmZWN0ZWRLZXlzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjYWNoZSBjbGVhcmVkIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUNhY2hlQ2xlYXJlZEV2ZW50KFxuICAgIGl0ZW1zQ2xlYXJlZDogbnVtYmVyLFxuICAgIHF1ZXJ5Q2FjaGVDbGVhcmVkOiBib29sZWFuID0gdHJ1ZSxcbiAgICBvcHRpb25zOiB7XG4gICAgICBzb3VyY2U/OiAnYXBpJyB8ICdjYWNoZScgfCAnb3BlcmF0aW9uJztcbiAgICAgIGNvbnRleHQ/OiB7XG4gICAgICAgIG9wZXJhdGlvbj86IHN0cmluZztcbiAgICAgICAgcmVxdWVzdElkPzogc3RyaW5nO1xuICAgICAgICB1c2VySWQ/OiBzdHJpbmc7XG4gICAgICB9O1xuICAgIH0gPSB7fVxuICApOiBDYWNoZUNsZWFyZWRFdmVudCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjYWNoZV9jbGVhcmVkJyxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZW5lcmF0ZVRpbWVzdGFtcCgpLFxuICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSB8fCAnb3BlcmF0aW9uJyxcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgIGl0ZW1zQ2xlYXJlZCxcbiAgICAgIHF1ZXJ5Q2FjaGVDbGVhcmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhdGlvbiBpbnZhbGlkYXRlZCBldmVudFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVMb2NhdGlvbkludmFsaWRhdGVkRXZlbnQ8XG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSxcbiAgICBhZmZlY3RlZEtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSxcbiAgICBvcHRpb25zOiB7XG4gICAgICBzb3VyY2U/OiAnYXBpJyB8ICdjYWNoZScgfCAnb3BlcmF0aW9uJztcbiAgICAgIGNvbnRleHQ/OiB7XG4gICAgICAgIG9wZXJhdGlvbj86IHN0cmluZztcbiAgICAgICAgcmVxdWVzdElkPzogc3RyaW5nO1xuICAgICAgICB1c2VySWQ/OiBzdHJpbmc7XG4gICAgICB9O1xuICAgIH0gPSB7fVxuICApOiBMb2NhdGlvbkludmFsaWRhdGVkRXZlbnQ8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsb2NhdGlvbl9pbnZhbGlkYXRlZCcsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgJ29wZXJhdGlvbicsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBsb2NhdGlvbnMsXG4gICAgICBhZmZlY3RlZEtleXNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHF1ZXJ5IGludmFsaWRhdGVkIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZVF1ZXJ5SW52YWxpZGF0ZWRFdmVudChcbiAgICBpbnZhbGlkYXRlZFF1ZXJpZXM6IHN0cmluZ1tdLFxuICAgIHJlYXNvbjogJ21hbnVhbCcgfCAnaXRlbV9jaGFuZ2VkJyB8ICdsb2NhdGlvbl9jaGFuZ2VkJyB8ICd0dGxfZXhwaXJlZCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgc291cmNlPzogJ2FwaScgfCAnY2FjaGUnIHwgJ29wZXJhdGlvbic7XG4gICAgICBjb250ZXh0Pzoge1xuICAgICAgICBvcGVyYXRpb24/OiBzdHJpbmc7XG4gICAgICAgIHJlcXVlc3RJZD86IHN0cmluZztcbiAgICAgICAgdXNlcklkPzogc3RyaW5nO1xuICAgICAgfTtcbiAgICB9ID0ge31cbiAgKTogUXVlcnlJbnZhbGlkYXRlZEV2ZW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3F1ZXJ5X2ludmFsaWRhdGVkJyxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZW5lcmF0ZVRpbWVzdGFtcCgpLFxuICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSB8fCAnb3BlcmF0aW9uJyxcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgIGludmFsaWRhdGVkUXVlcmllcyxcbiAgICAgIHJlYXNvblxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0gY3JlYXRlZCBldmVudFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpdGVtQ3JlYXRlZDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4oXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBWLFxuICAgIHNvdXJjZTogJ2FwaScgfCAnY2FjaGUnIHwgJ29wZXJhdGlvbicgPSAnYXBpJ1xuICApOiBJdGVtRXZlbnQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlSXRlbUV2ZW50KCdpdGVtX2NyZWF0ZWQnLCBrZXksIGl0ZW0sIHsgc291cmNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtIHVwZGF0ZWQgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXRlbVVwZGF0ZWQ8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogVixcbiAgICBwcmV2aW91c0l0ZW0/OiBWIHwgbnVsbCxcbiAgICBzb3VyY2U6ICdhcGknIHwgJ2NhY2hlJyB8ICdvcGVyYXRpb24nID0gJ2FwaSdcbiAgKTogSXRlbUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUl0ZW1FdmVudCgnaXRlbV91cGRhdGVkJywga2V5LCBpdGVtLCB7IHByZXZpb3VzSXRlbSwgc291cmNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtIHJlbW92ZWQgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXRlbVJlbW92ZWQ8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgcHJldmlvdXNJdGVtPzogViB8IG51bGwsXG4gICAgc291cmNlOiAnYXBpJyB8ICdjYWNoZScgfCAnb3BlcmF0aW9uJyA9ICdhcGknXG4gICk6IEl0ZW1FdmVudDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJdGVtRXZlbnQoJ2l0ZW1fcmVtb3ZlZCcsIGtleSwgbnVsbCwgeyBwcmV2aW91c0l0ZW0sIHNvdXJjZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbSByZXRyaWV2ZWQgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXRlbVJldHJpZXZlZDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4oXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBWLFxuICAgIHNvdXJjZTogJ2FwaScgfCAnY2FjaGUnIHwgJ29wZXJhdGlvbicgPSAnYXBpJ1xuICApOiBJdGVtRXZlbnQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlSXRlbUV2ZW50KCdpdGVtX3JldHJpZXZlZCcsIGtleSwgaXRlbSwgeyBzb3VyY2UgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0gc2V0IGV2ZW50IChkaXJlY3QgY2FjaGUgb3BlcmF0aW9uKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpdGVtU2V0PFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IFYsXG4gICAgcHJldmlvdXNJdGVtPzogViB8IG51bGxcbiAgKTogSXRlbUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUl0ZW1FdmVudCgnaXRlbV9zZXQnLCBrZXksIGl0ZW0sIHtcbiAgICAgIHByZXZpb3VzSXRlbSxcbiAgICAgIHNvdXJjZTogJ2NhY2hlJ1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgTG9nZ2luZyBmcm9tICdAZmplbGwvbG9nZ2luZyc7XG5cbmNvbnN0IExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKCdAZmplbGwvY2FjaGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgTGliTG9nZ2VyO1xuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IE5vdEZvdW5kRXJyb3IgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBjcmVhdGVRdWVyeUhhc2ggfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuaW1wb3J0IHsgZXN0aW1hdGVWYWx1ZVNpemUgfSBmcm9tIFwiLi4vdXRpbHMvQ2FjaGVTaXplXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnb25lJyk7XG5cbmV4cG9ydCBjb25zdCBvbmUgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSxcbiAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXSxcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWIHwgbnVsbF0+ID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUsIHR0bE1hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdvbmUnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG5cbiAgLy8gR2VuZXJhdGUgcXVlcnkgaGFzaCBmb3IgY2FjaGluZ1xuICBjb25zdCBxdWVyeUhhc2ggPSBjcmVhdGVRdWVyeUhhc2gocGtUeXBlLCBxdWVyeSwgbG9jYXRpb25zKTtcbiAgbG9nZ2VyLmRlYnVnKCdHZW5lcmF0ZWQgcXVlcnkgaGFzaCBmb3Igb25lJywgeyBxdWVyeUhhc2ggfSk7XG5cbiAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBjYWNoZWQgcXVlcnkgcmVzdWx0c1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cykge1xuICAgIGxvZ2dlci5kZWJ1ZygnVXNpbmcgY2FjaGVkIHF1ZXJ5IHJlc3VsdHMnLCB7IGNhY2hlZEtleUNvdW50OiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggfSk7XG5cbiAgICBpZiAoY2FjaGVkSXRlbUtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBDYWNoZWQgZW1wdHkgcmVzdWx0IChub3QgZm91bmQpXG4gICAgICByZXR1cm4gW2NvbnRleHQsIG51bGxdO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIHRoZSBmaXJzdCBjYWNoZWQgaXRlbSAtIGlmIG1pc3NpbmcsIGludmFsaWRhdGUgdGhlIHF1ZXJ5IGNhY2hlXG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChjYWNoZWRJdGVtS2V5c1swXSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhpdGVtLCBwa1R5cGUpIGFzIFZdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0NhY2hlZCBpdGVtIG1pc3NpbmcsIGludmFsaWRhdGluZyBxdWVyeSBjYWNoZScpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmV0SXRlbTogViB8IG51bGwgPSBudWxsO1xuICB0cnkge1xuICAgIHJldEl0ZW0gPSBhd2FpdCBhcGkub25lKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIGlmIChyZXRJdGVtKSB7XG4gICAgICAvLyBTdG9yZSBpbmRpdmlkdWFsIGl0ZW0gaW4gY2FjaGVcbiAgICAgIGF3YWl0IGNhY2hlTWFwLnNldChyZXRJdGVtLmtleSwgcmV0SXRlbSk7XG5cbiAgICAgIC8vIENyZWF0ZSBiYXNlIG1ldGFkYXRhIGlmIGl0IGRvZXNuJ3QgZXhpc3QgKG5lZWRlZCBmb3IgVFRMIGFuZCBldmljdGlvbilcbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHJldEl0ZW0ua2V5KTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2FjaGVNYXAuZ2V0TWV0YWRhdGEoa2V5U3RyKTtcbiAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgYmFzZU1ldGFkYXRhID0ge1xuICAgICAgICAgIGtleToga2V5U3RyLFxuICAgICAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgICAgIGVzdGltYXRlZFNpemU6IGVzdGltYXRlVmFsdWVTaXplKHJldEl0ZW0pXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IGNhY2hlTWFwLnNldE1ldGFkYXRhKGtleVN0ciwgYmFzZU1ldGFkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IFRUTCBtZXRhZGF0YSBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gICAgICBhd2FpdCB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gICAgICAvLyBIYW5kbGUgZXZpY3Rpb24gZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHJldEl0ZW0sIGNhY2hlTWFwKTtcbiAgICAgIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgICAgIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgcXVlcnkgcmVzdWx0IChzaW5nbGUgaXRlbSBrZXkpIGluIHF1ZXJ5IGNhY2hlXG4gICAgICBhd2FpdCBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIFtyZXRJdGVtLmtleV0pO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgcXVlcnkgcmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXk6IHJldEl0ZW0ua2V5IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdG9yZSBlbXB0eSByZXN1bHQgaW4gcXVlcnkgY2FjaGVcbiAgICAgIGF3YWl0IGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW10pO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgZW1wdHkgcXVlcnkgcmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgfVxuICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSB7XG4gICAgICAvLyBIYW5kbGUgbm90IGZvdW5kIGdyYWNlZnVsbHkgLSBjYWNoZSBlbXB0eSByZXN1bHRcbiAgICAgIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW10pO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgZW1wdHkgcXVlcnkgcmVzdWx0IGZvciBub3QgZm91bmQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBjb250ZXh0LFxuICAgIHJldEl0ZW0gP1xuICAgICAgdmFsaWRhdGVQSyhyZXRJdGVtLCBwa1R5cGUpIGFzIFYgOlxuICAgICAgbnVsbFxuICBdO1xufTtcbiIsIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgYW5kIG1hbmFnaW5nIGNhY2hlIHNpemVzXG4gKi9cblxuLyoqXG4gKiBTaXplIHVuaXQgbXVsdGlwbGllcnMgKGRlY2ltYWwgYW5kIGJpbmFyeSlcbiAqL1xuY29uc3QgU0laRV9VTklUUzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHtcbiAgLy8gRGVjaW1hbCB1bml0cyAocG93ZXJzIG9mIDEwMDApXG4gICdiJzogMSxcbiAgJ2J5dGUnOiAxLFxuICAnYnl0ZXMnOiAxLFxuICAna2InOiAxMDAwLFxuICAna2lsb2J5dGUnOiAxMDAwLFxuICAna2lsb2J5dGVzJzogMTAwMCxcbiAgJ21iJzogMTAwMCAqIDEwMDAsXG4gICdtZWdhYnl0ZSc6IDEwMDAgKiAxMDAwLFxuICAnbWVnYWJ5dGVzJzogMTAwMCAqIDEwMDAsXG4gICdnYic6IDEwMDAgKiAxMDAwICogMTAwMCxcbiAgJ2dpZ2FieXRlJzogMTAwMCAqIDEwMDAgKiAxMDAwLFxuICAnZ2lnYWJ5dGVzJzogMTAwMCAqIDEwMDAgKiAxMDAwLFxuICAndGInOiAxMDAwICogMTAwMCAqIDEwMDAgKiAxMDAwLFxuICAndGVyYWJ5dGUnOiAxMDAwICogMTAwMCAqIDEwMDAgKiAxMDAwLFxuICAndGVyYWJ5dGVzJzogMTAwMCAqIDEwMDAgKiAxMDAwICogMTAwMCxcblxuICAvLyBCaW5hcnkgdW5pdHMgKHBvd2VycyBvZiAxMDI0KVxuICAna2liJzogMTAyNCxcbiAgJ2tpYmlieXRlJzogMTAyNCxcbiAgJ2tpYmlieXRlcyc6IDEwMjQsXG4gICdtaWInOiAxMDI0ICogMTAyNCxcbiAgJ21lYmlieXRlJzogMTAyNCAqIDEwMjQsXG4gICdtZWJpYnl0ZXMnOiAxMDI0ICogMTAyNCxcbiAgJ2dpYic6IDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgJ2dpYmlieXRlJzogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICAnZ2liaWJ5dGVzJzogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICAndGliJzogMTAyNCAqIDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgJ3RlYmlieXRlJzogMTAyNCAqIDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgJ3RlYmlieXRlcyc6IDEwMjQgKiAxMDI0ICogMTAyNCAqIDEwMjQsXG59O1xuXG4vKipcbiAqIFBhcnNlIGEgc2l6ZSBzdHJpbmcgYW5kIHJldHVybiB0aGUgc2l6ZSBpbiBieXRlc1xuICpcbiAqIEBwYXJhbSBzaXplU3RyIC0gU2l6ZSBzdHJpbmcgKGUuZy4sICczMDAnLCAnM2tiJywgJzVNQicsICcyR2lCJylcbiAqIEByZXR1cm5zIFNpemUgaW4gYnl0ZXNcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIHNpemUgc3RyaW5nIGlzIGludmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2l6ZVN0cmluZyhzaXplU3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBpZiAoIXNpemVTdHIgfHwgdHlwZW9mIHNpemVTdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIHN0cmluZyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgY29uc3QgdHJpbW1lZCA9IHNpemVTdHIudHJpbSgpO1xuXG4gIC8vIEhhbmRsZSBwdXJlIG51bWVyaWMgdmFsdWVzIChhc3N1bWUgYnl0ZXMpXG4gIGlmICgvXlxcZCsoXFwuXFxkKyk/JC8udGVzdCh0cmltbWVkKSkge1xuICAgIGNvbnN0IGJ5dGVzID0gcGFyc2VGbG9hdCh0cmltbWVkKTtcbiAgICBpZiAoaXNOYU4oYnl0ZXMpIHx8IGJ5dGVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemUgdmFsdWU6ICR7c2l6ZVN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoYnl0ZXMpO1xuICB9XG5cbiAgLy8gUGFyc2Ugd2l0aCB1bml0XG4gIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaCgvXihcXGQrKD86XFwuXFxkKyk/KVxccyooW2EtekEtWl0rKSQvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaXplIGZvcm1hdDogJHtzaXplU3RyfS4gRXhwZWN0ZWQgZm9ybWF0OiAnMTAwJywgJzVLQicsICcxME1CJywgZXRjLmApO1xuICB9XG5cbiAgY29uc3QgWywgdmFsdWVTdHIsIHVuaXRTdHJdID0gbWF0Y2g7XG4gIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZVN0cik7XG4gIGNvbnN0IHVuaXQgPSB1bml0U3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2l6ZSB2YWx1ZTogJHt2YWx1ZVN0cn1gKTtcbiAgfVxuXG4gIGNvbnN0IG11bHRpcGxpZXIgPSBTSVpFX1VOSVRTW3VuaXRdO1xuICBpZiAoISh1bml0IGluIFNJWkVfVU5JVFMpKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkVW5pdHMgPSBPYmplY3Qua2V5cyhTSVpFX1VOSVRTKS5maWx0ZXIodSA9PiB1Lmxlbmd0aCA8PSAzKS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2l6ZSB1bml0OiAke3VuaXRTdHJ9LiBTdXBwb3J0ZWQgdW5pdHM6ICR7c3VwcG9ydGVkVW5pdHN9YCk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSAqIG11bHRpcGxpZXIpO1xufVxuXG4vKipcbiAqIEZvcm1hdCBieXRlcyBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBieXRlcyAtIFNpemUgaW4gYnl0ZXNcbiAqIEBwYXJhbSBiaW5hcnkgLSBVc2UgYmluYXJ5IHVuaXRzICgxMDI0KSBpbnN0ZWFkIG9mIGRlY2ltYWwgKDEwMDApXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgc2l6ZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJ5dGVzKGJ5dGVzOiBudW1iZXIsIGJpbmFyeTogYm9vbGVhbiA9IGZhbHNlKTogc3RyaW5nIHtcbiAgaWYgKGJ5dGVzID09PSAwKSByZXR1cm4gJzAgQic7XG4gIGlmIChieXRlcyA8IDApIHJldHVybiBgJHtieXRlc30gQmA7XG5cbiAgY29uc3QgayA9IGJpbmFyeSA/IDEwMjQgOiAxMDAwO1xuICBjb25zdCBzaXplcyA9IGJpbmFyeVxuICAgID8gWydCJywgJ0tpQicsICdNaUInLCAnR2lCJywgJ1RpQicsICdQaUInXVxuICAgIDogWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJ107XG5cbiAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2coaykpO1xuICBjb25zdCBzaXplID0gYnl0ZXMgLyBNYXRoLnBvdyhrLCBpKTtcblxuICAvLyBTaG93IGRlY2ltYWxzIG9ubHkgaWYgbmVlZGVkXG4gIGNvbnN0IGZvcm1hdHRlZCA9IHNpemUgJSAxID09PSAwID8gc2l6ZS50b1N0cmluZygpIDogc2l6ZS50b0ZpeGVkKDEpO1xuXG4gIHJldHVybiBgJHtmb3JtYXR0ZWR9ICR7c2l6ZXNbaV19YDtcbn1cblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgc2VyaWFsaXplZCBzaXplIG9mIGEgdmFsdWUgaW4gYnl0ZXNcbiAqIFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBmb3IgY2FjaGUgc2l6ZSBjYWxjdWxhdGlvbnNcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZXN0aW1hdGUgc2l6ZSBmb3JcbiAqIEByZXR1cm5zIEVzdGltYXRlZCBzaXplIGluIGJ5dGVzXG4gKi9cbmltcG9ydCBzYWZlU3RyaW5naWZ5IGZyb20gJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknO1xuXG5leHBvcnQgZnVuY3Rpb24gZXN0aW1hdGVWYWx1ZVNpemUodmFsdWU6IGFueSk6IG51bWJlciB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDg7IC8vIEFwcHJveGltYXRlIG92ZXJoZWFkXG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAvLyBVVEYtOCBlbmNvZGluZzogbW9zdCBjaGFyYWN0ZXJzIGFyZSAxIGJ5dGUsIHNvbWUgYXJlIDItNCBieXRlc1xuICAgICAgLy8gVXNlIGEgc2ltcGxlIGFwcHJveGltYXRpb24gb2YgMiBieXRlcyBwZXIgY2hhcmFjdGVyIGZvciBzYWZldHlcbiAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggKiAyO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlZHVjZSgodG90YWwsIGl0ZW0pID0+IHRvdGFsICsgZXN0aW1hdGVWYWx1ZVNpemUoaXRlbSksIDI0KTsgLy8gQXJyYXkgb3ZlcmhlYWRcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZWN0IGNpcmN1bGFyIHJlZmVyZW5jZXMgZXhwbGljaXRseSB0byByZXNwZWN0IGZhbGxiYWNrIGJlaGF2aW9yXG4gICAgICBjb25zdCBoYXNDaXJjdWxhclJlZmVyZW5jZSA9IChvYmo6IHVua25vd24sIGFuY2VzdG9yczogV2Vha1NldDxvYmplY3Q+ID0gbmV3IFdlYWtTZXQoKSwgY2hlY2tlZDogV2Vha1NldDxvYmplY3Q+ID0gbmV3IFdlYWtTZXQoKSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXNPYmplY3QgPSBvYmogYXMgb2JqZWN0O1xuXG4gICAgICAgIGlmIChjaGVja2VkLmhhcyhhc09iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyhhc09iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuY2VzdG9ycy5hZGQoYXNPYmplY3QpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzT2JqZWN0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFzT2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmIChoYXNDaXJjdWxhclJlZmVyZW5jZShpdGVtLCBhbmNlc3RvcnMsIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXNPYmplY3QgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pKSB7XG4gICAgICAgICAgICAgIC8vIEFjY2VzcyB2YWx1ZSBkZWZlbnNpdmVseSBpbiBjYXNlIG9mIGdldHRlcnMgdGhyb3dpbmdcbiAgICAgICAgICAgICAgbGV0IGNoaWxkOiB1bmtub3duO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gKGFzT2JqZWN0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXkgYXMga2V5b2YgdHlwZW9mIGFzT2JqZWN0XTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgcHJvcGVydHkgYWNjZXNzIGVycm9ycyBhcyBub24tZmF0YWwgZm9yIHRyYXZlcnNhbFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoYXNDaXJjdWxhclJlZmVyZW5jZShjaGlsZCwgYW5jZXN0b3JzLCBjaGVja2VkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFuY2VzdG9ycy5kZWxldGUoYXNPYmplY3QpO1xuICAgICAgICAgIGNoZWNrZWQuYWRkKGFzT2JqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYXNDaXJjdWxhclJlZmVyZW5jZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gNjQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gNjQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBvYmplY3RzLCBlc3RpbWF0ZSBiYXNlZCBvbiBzYWZlIHNlcmlhbGl6YXRpb24gdGhhdCBzdXBwb3J0cyBjaXJjdWxhciByZWZzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gc2FmZVN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBqc29uU3RyaW5nLmxlbmd0aCAqIDIgKyAxNjsgLy8gSlNPTiBzdHJpbmcgc2l6ZSArIG9iamVjdCBvdmVyaGVhZFxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBvYmplY3RzIHRoYXQgY2FuJ3QgYmUgc2VyaWFsaXplZFxuICAgICAgICByZXR1cm4gNjQ7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAzMjsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzaXplIGNvbmZpZ3VyYXRpb24gaXMgdmFsaWRcbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gU2l6ZSBjb25maWd1cmF0aW9uIHRvIHZhbGlkYXRlXG4gKiBAdGhyb3dzIEVycm9yIGlmIGNvbmZpZ3VyYXRpb24gaXMgaW52YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTaXplQ29uZmlnKGNvbmZpZzogeyBtYXhTaXplQnl0ZXM/OiBzdHJpbmc7IG1heEl0ZW1zPzogbnVtYmVyIH0pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiBjb25maWcubWF4U2l6ZUJ5dGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBieXRlcyA9IHBhcnNlU2l6ZVN0cmluZyhjb25maWcubWF4U2l6ZUJ5dGVzKTtcbiAgICAgIGlmIChieXRlcyA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4U2l6ZUJ5dGVzIG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1heFNpemVCeXRlczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5tYXhJdGVtcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29uZmlnLm1heEl0ZW1zKSB8fCBjb25maWcubWF4SXRlbXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhJdGVtcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgTG9jS2V5QXJyYXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RmFjdG9yeSB9IGZyb20gXCIuLi9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnlcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjcmVhdGUnKTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgdjogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdLFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxbQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIFZdPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCBldmVudEVtaXR0ZXIsIHR0bE1hbmFnZXIsIGV2aWN0aW9uTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2NyZWF0ZScsIHsgdiwgbG9jYXRpb25zIH0pO1xuICBjb25zdCBjcmVhdGVkID0gYXdhaXQgYXBpLmNyZWF0ZSh2LCBsb2NhdGlvbnMpO1xuICBjYWNoZU1hcC5zZXQoY3JlYXRlZC5rZXksIGNyZWF0ZWQpO1xuXG4gIC8vIFNldCBUVEwgbWV0YWRhdGEgZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShjcmVhdGVkLmtleSk7XG4gIHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG5cbiAgLy8gSGFuZGxlIGV2aWN0aW9uIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjcmVhdGVkLCBjYWNoZU1hcCk7XG4gIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgZm9yIChjb25zdCBldmljdGVkS2V5IG9mIGV2aWN0ZWRLZXlzKSB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgfVxuXG4gIC8vIEVtaXQgZXZlbnRcbiAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtQ3JlYXRlZChjcmVhdGVkLmtleSwgY3JlYXRlZCBhcyBWLCAnYXBpJyk7XG4gIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcblxuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsoY3JlYXRlZCwgcGtUeXBlKSBhcyBWXTtcbn07XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBJdGVtLFxuICBQcmlLZXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RmFjdG9yeSB9IGZyb20gXCIuLi9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnlcIjtcbmltcG9ydCB7IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24gfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuaW1wb3J0IHsgZXN0aW1hdGVWYWx1ZVNpemUgfSBmcm9tIFwiLi4vdXRpbHMvQ2FjaGVTaXplXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnZ2V0Jyk7XG5cbi8vIFRyYWNrIGluLWZsaWdodCBBUEkgcmVxdWVzdHMgdG8gcHJldmVudCBkdXBsaWNhdGUgY2FsbHMgZm9yIHRoZSBzYW1lIGtleVxuY29uc3QgaW5GbGlnaHRSZXF1ZXN0cyA9IG5ldyBNYXA8c3RyaW5nLCB7IHByb21pc2U6IFByb21pc2U8YW55PjsgdGltZXN0YW1wOiBudW1iZXIgfT4oKTtcblxuLy8gQ2xlYW51cCB0aW1lb3V0IGZvciBoYW5naW5nIHJlcXVlc3RzIChkZWZhdWx0IDUgbWludXRlcylcbmNvbnN0IENMRUFOVVBfVElNRU9VVCA9IDUgKiA2MCAqIDEwMDA7IC8vIDUgbWludXRlc1xuXG4vLyBQZXJpb2RpYyBjbGVhbnVwIG9mIHN0YWxlIGluLWZsaWdodCByZXF1ZXN0c1xuY29uc3QgY2xlYW51cFN0YWxlUmVxdWVzdHMgPSAoKSA9PiB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IGtleXNUb0RlbGV0ZTogc3RyaW5nW10gPSBbXTtcblxuICBpbkZsaWdodFJlcXVlc3RzLmZvckVhY2goKHJlcXVlc3QsIGtleSkgPT4ge1xuICAgIGlmIChub3cgLSByZXF1ZXN0LnRpbWVzdGFtcCA+IENMRUFOVVBfVElNRU9VVCkge1xuICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICB9XG4gIH0pO1xuXG4gIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdDbGVhbmluZyB1cCBzdGFsZSBpbi1mbGlnaHQgcmVxdWVzdCcsIHsga2V5IH0pO1xuICAgIGluRmxpZ2h0UmVxdWVzdHMuZGVsZXRlKGtleSk7XG4gIH0pO1xufTtcblxuLy8gUnVuIGNsZWFudXAgZXZlcnkgbWludXRlXG5jb25zdCBjbGVhbnVwSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjbGVhbnVwU3RhbGVSZXF1ZXN0cywgNjAgKiAxMDAwKTtcblxuLy8gRXhwb3J0IGNsZWFudXAgZnVuY3Rpb24gZm9yIGdyYWNlZnVsIHNodXRkb3duXG5leHBvcnQgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgY2xlYXJJbnRlcnZhbChjbGVhbnVwSW50ZXJ2YWwpO1xuICBpbkZsaWdodFJlcXVlc3RzLmNsZWFyKCk7XG59O1xuXG4vLyBOb3JtYWxpemVkIGtleSBzdHJpbmdpZmljYXRpb24gZm9yIHRyYWNraW5nIHB1cnBvc2VzIC0gdXNlcyBzYW1lIG5vcm1hbGl6YXRpb24gYXMgY2FjaGUgbWFwc1xuY29uc3Qga2V5VG9TdHJpbmcgPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uPGFueT4oKTtcblxuZXhwb3J0IGNvbnN0IGdldCA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWIHwgbnVsbF0+ID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUsIHR0bE1hbmFnZXIsIHN0YXRzTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2dldCcsIHsga2V5LCBkZWZhdWx0VFRMOiB0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSB9KTtcblxuICAvLyBUcmFjayBjYWNoZSByZXF1ZXN0XG4gIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRSZXF1ZXN0cygpO1xuXG4gIGlmICghaXNWYWxpZEl0ZW1LZXkoa2V5KSkge1xuICAgIGxvZ2dlci5lcnJvcignS2V5IGZvciBHZXQgaXMgbm90IGEgdmFsaWQgSXRlbUtleTogJWonLCBrZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IGZvciBHZXQgaXMgbm90IGEgdmFsaWQgSXRlbUtleScpO1xuICB9XG5cbiAgLy8gQ2hlY2sgY2FjaGUgZmlyc3QgaWYgVFRMIGlzIGVuYWJsZWRcbiAgaWYgKHR0bE1hbmFnZXIuaXNUVExFbmFibGVkKCkpIHtcbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgIGNvbnN0IGNhY2hlZEl0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBpZiAoY2FjaGVkSXRlbSkge1xuICAgICAgLy8gQ2hlY2sgVFRMIHZhbGlkaXR5IHVzaW5nIFRUTE1hbmFnZXJcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB0dGxNYW5hZ2VyLnZhbGlkYXRlSXRlbShrZXlTdHIsIGNhY2hlTWFwKTtcbiAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGUgaGl0IHdpdGggdmFsaWQgVFRMJywgeyBrZXksIGRlZmF1bHRUVEw6IHR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpIH0pO1xuICAgICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50SGl0cygpO1xuICAgICAgICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsoY2FjaGVkSXRlbSwgcGtUeXBlKSBhcyBWXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0ZW0gZXhwaXJlZCwgcmVtb3ZlIGl0IGZyb20gY2FjaGVcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdDYWNoZSBpdGVtIGV4cGlyZWQsIHJlbW92aW5nJywgeyBrZXkgfSk7XG4gICAgICAgIGNhY2hlTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50TWlzc2VzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhY2hlZCBpdGVtIGZvdW5kXG4gICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50TWlzc2VzKCk7XG4gICAgfVxuICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGUgbWlzcyBvciBleHBpcmVkJywgeyBrZXksIGRlZmF1bHRUVEw6IHR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRUTCBub3QgZW5hYmxlZCwgY2hlY2sgY2FjaGUgZGlyZWN0bHlcbiAgICBjb25zdCBjYWNoZWRJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgaWYgKGNhY2hlZEl0ZW0pIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGUgaGl0IChUVEwgZGlzYWJsZWQpJywgeyBrZXkgfSk7XG4gICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50SGl0cygpO1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKGNhY2hlZEl0ZW0sIHBrVHlwZSkgYXMgVl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRNaXNzZXMoKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBUVEwgaXMgMCBvciBjYWNoZSBtaXNzL2V4cGlyZWQsIGZldGNoIGZyb20gQVBJXG4gIGxldCByZXQ6IFYgfCBudWxsO1xuICBjb25zdCBrZXlTdHIgPSBrZXlUb1N0cmluZyhrZXkpO1xuXG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGFuIGluLWZsaWdodCByZXF1ZXN0IGZvciB0aGlzIGtleVxuICAgIGNvbnN0IHJlcXVlc3RFbnRyeSA9IGluRmxpZ2h0UmVxdWVzdHMuZ2V0KGtleVN0cik7XG4gICAgbGV0IGFwaVJlcXVlc3Q6IFByb21pc2U8YW55PjtcblxuICAgIGlmICghcmVxdWVzdEVudHJ5KSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IEFQSSByZXF1ZXN0XG4gICAgICBhcGlSZXF1ZXN0ID0gYXBpLmdldChrZXkpO1xuXG4gICAgICAvLyBPbmx5IHRyYWNrIHN1Y2Nlc3NmdWwgcHJvbWlzZSBjcmVhdGlvblxuICAgICAgaWYgKGFwaVJlcXVlc3QgJiYgdHlwZW9mIGFwaVJlcXVlc3QudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBpbkZsaWdodFJlcXVlc3RzLnNldChrZXlTdHIsIHsgcHJvbWlzZTogYXBpUmVxdWVzdCwgdGltZXN0YW1wIH0pO1xuXG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSB0cmFja2luZyB3aGVuIHJlcXVlc3QgY29tcGxldGVzIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBpbkZsaWdodFJlcXVlc3RzLmRlbGV0ZShrZXlTdHIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpUmVxdWVzdC5maW5hbGx5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYXBpUmVxdWVzdC5maW5hbGx5KGNsZWFudXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZhbGxiYWNrIGNsZWFudXAgZm9yIHByb21pc2VzIHdpdGhvdXQgLmZpbmFsbHkoKVxuICAgICAgICAgIGFwaVJlcXVlc3QudGhlbihjbGVhbnVwLCBjbGVhbnVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1VzaW5nIGluLWZsaWdodCByZXF1ZXN0IGZvciBrZXknLCB7IGtleSB9KTtcbiAgICAgIGFwaVJlcXVlc3QgPSByZXF1ZXN0RW50cnkucHJvbWlzZTtcbiAgICB9XG5cbiAgICByZXQgPSBhd2FpdCBhcGlSZXF1ZXN0O1xuICAgIGlmIChyZXQpIHtcbiAgICAgIGF3YWl0IGNhY2hlTWFwLnNldChyZXQua2V5LCByZXQpO1xuXG4gICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShyZXQua2V5KTtcblxuICAgICAgLy8gQ3JlYXRlIGJhc2UgbWV0YWRhdGEgaWYgaXQgZG9lc24ndCBleGlzdCAobmVlZGVkIGZvciBUVEwgYW5kIGV2aWN0aW9uKVxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYWNoZU1hcC5nZXRNZXRhZGF0YShrZXlTdHIpO1xuICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBiYXNlTWV0YWRhdGEgPSB7XG4gICAgICAgICAga2V5OiBrZXlTdHIsXG4gICAgICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICAgICAgZXN0aW1hdGVkU2l6ZTogZXN0aW1hdGVWYWx1ZVNpemUocmV0KVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBjYWNoZU1hcC5zZXRNZXRhZGF0YShrZXlTdHIsIGJhc2VNZXRhZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBldmljdGlvbiBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gICAgICBjb25zdCBldmljdGVkS2V5cyA9IGF3YWl0IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgcmV0LCBjYWNoZU1hcCk7XG5cbiAgICAgIC8vIFNldCBUVEwgbWV0YWRhdGEgZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgICAgYXdhaXQgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcblxuICAgICAgLy8gUmVtb3ZlIGV2aWN0ZWQgaXRlbXMgZnJvbSBjYWNoZVxuICAgICAgZm9yIChjb25zdCBldmljdGVkS2V5IG9mIGV2aWN0ZWRLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICAgIGF3YWl0IGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbWl0IGV2ZW50IGZvciBpdGVtIHJldHJpZXZlZCBmcm9tIEFQSVxuICAgICAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtUmV0cmlldmVkKHJldC5rZXksIHJldCBhcyBWLCAnYXBpJyk7XG4gICAgICBjb250ZXh0LmV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIC8vIEVuc3VyZSB3ZSBjbGVhbiB1cCB0aGUgaW4tZmxpZ2h0IHJlcXVlc3Qgb24gZXJyb3JcbiAgICBpbkZsaWdodFJlcXVlc3RzLmRlbGV0ZShrZXlTdHIpO1xuICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGdldHRpbmcgaXRlbSBmb3Iga2V5XCIsIHsga2V5LCBtZXNzYWdlOiBlLm1lc3NhZ2UsIHN0YWNrOiBlLnN0YWNrIH0pO1xuICAgIHRocm93IGU7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIGNvbnRleHQsXG4gICAgcmV0ID9cbiAgICAgIHZhbGlkYXRlUEsocmV0LCBwa1R5cGUpIGFzIFYgOlxuICAgICAgbnVsbFxuICBdO1xufTtcbiIsImltcG9ydCB7XG4gIENvbUtleSxcbiAgaXNWYWxpZEl0ZW1LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSBcIi4vZ2V0XCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ3JldHJpZXZlJyk7XG5cbmV4cG9ydCBjb25zdCByZXRyaWV2ZSA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbCwgViB8IG51bGxdPiA9PiB7XG4gIGNvbnN0IHsgY2FjaGVNYXAsIHBrVHlwZSwgc3RhdHNNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgncmV0cmlldmUnLCB7IGtleSB9KTtcblxuICAvLyBUcmFjayBjYWNoZSByZXF1ZXN0XG4gIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRSZXF1ZXN0cygpO1xuXG4gIGlmICghaXNWYWxpZEl0ZW1LZXkoa2V5KSkge1xuICAgIGxvZ2dlci5lcnJvcignS2V5IGZvciBSZXRyaWV2ZSBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlaicsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZm9yIFJldHJpZXZlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXknKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5zSXRlbUtleSA9IGF3YWl0IGNhY2hlTWFwLmluY2x1ZGVzS2V5KGtleSk7XG5cbiAgbGV0IHJldHJpZXZlZDogViB8IG51bGw7XG4gIGxldCBjb250ZXh0VG9SZXR1cm46IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbDtcblxuICBpZiAoY29udGFpbnNJdGVtS2V5KSB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ0xvb2tpbmcgZm9yIE9iamVjdCBpbiBDYWNoZScsIGtleSk7XG4gICAgcmV0cmlldmVkID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgY29udGV4dFRvUmV0dXJuID0gbnVsbDtcbiAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50SGl0cygpO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdPYmplY3QgTm90IEZvdW5kIGluIENhY2hlLCBSZXRyaWV2aW5nIGZyb20gU2VydmVyIEFQSScsIHsga2V5IH0pO1xuICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRNaXNzZXMoKTtcbiAgICBbY29udGV4dFRvUmV0dXJuLCByZXRyaWV2ZWRdID0gYXdhaXQgZ2V0KGtleSwgY29udGV4dCk7XG4gIH1cblxuICBjb25zdCByZXRWYWx1ZTogW0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbCwgViB8IG51bGxdID0gW1xuICAgIGNvbnRleHRUb1JldHVybixcbiAgICByZXRyaWV2ZWQgP1xuICAgICAgdmFsaWRhdGVQSyhyZXRyaWV2ZWQsIHBrVHlwZSkgYXMgViA6XG4gICAgICBudWxsXG4gIF07XG5cbiAgcmV0dXJuIHJldFZhbHVlO1xufTtcbiIsImltcG9ydCB7XG4gIENvbUtleSxcbiAgaXNWYWxpZEl0ZW1LZXksXG4gIEl0ZW0sXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCB7IENhY2hlRXZlbnRGYWN0b3J5IH0gZnJvbSBcIi4uL2V2ZW50cy9DYWNoZUV2ZW50RmFjdG9yeVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ3JlbW92ZScpO1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4gPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCdyZW1vdmUnLCB7IGtleSB9KTtcblxuICBpZiAoIWlzVmFsaWRJdGVtS2V5KGtleSkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0tleSBmb3IgUmVtb3ZlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqJywga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBmb3IgUmVtb3ZlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXknKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gR2V0IGl0ZW0gYmVmb3JlIHJlbW92YWwgZm9yIGV2ZW50XG4gICAgY29uc3QgcHJldmlvdXNJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG5cbiAgICAvLyBGaXJzdCByZW1vdmUgZnJvbSBBUEksIHRoZW4gZnJvbSBjYWNoZSB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgIGF3YWl0IGFwaS5yZW1vdmUoa2V5KTtcbiAgICBjYWNoZU1hcC5kZWxldGUoa2V5KTtcblxuICAgIC8vIEVtaXQgZXZlbnRcbiAgICBpZiAocHJldmlvdXNJdGVtKSB7XG4gICAgICBjb25zdCBldmVudCA9IENhY2hlRXZlbnRGYWN0b3J5Lml0ZW1SZW1vdmVkKGtleSwgcHJldmlvdXNJdGVtLCAnYXBpJyk7XG4gICAgICBjb250ZXh0LmV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoJ1N1Y2Nlc3NmdWxseSByZW1vdmVkIGl0ZW0gZnJvbSBBUEkgYW5kIGNhY2hlJywgeyBrZXkgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBkZWxldGluZyBpdGVtXCIsIHsgZXJyb3I6IGUgfSk7XG4gICAgLy8gRG9uJ3QgZGVsZXRlIGZyb20gY2FjaGUgaWYgQVBJIGRlbGV0aW9uIGZhaWxlZFxuICAgIHRocm93IGU7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn07XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBJdGVtLFxuICBQcmlLZXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RmFjdG9yeSB9IGZyb20gXCIuLi9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnlcIjtcbmltcG9ydCB7IGVzdGltYXRlVmFsdWVTaXplIH0gZnJvbSBcIi4uL3V0aWxzL0NhY2hlU2l6ZVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ3VwZGF0ZScpO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlID0gYXN5bmMgPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICB2OiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgVl0+ID0+IHtcbiAgY29uc3QgeyBhcGksIGNhY2hlTWFwLCBwa1R5cGUgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlci5kZWZhdWx0KCd1cGRhdGUnLCB7IGtleSwgdiB9KTtcblxuICBpZiAoIWlzVmFsaWRJdGVtS2V5KGtleSkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0tleSBmb3IgVXBkYXRlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqJywga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBmb3IgVXBkYXRlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXknKTtcbiAgfVxuXG4gIC8vIEludmFsaWRhdGUgdGhlIGl0ZW0ga2V5IGJlZm9yZSBleGVjdXRpbmcgdGhlIHVwZGF0ZVxuICBsb2dnZXIuZGVidWcoJ0ludmFsaWRhdGluZyBpdGVtIGtleSBiZWZvcmUgdXBkYXRlJywgeyBrZXkgfSk7XG4gIGNhY2hlTWFwLmludmFsaWRhdGVJdGVtS2V5cyhba2V5XSk7XG5cbiAgdHJ5IHtcbiAgICAvLyBHZXQgcHJldmlvdXMgaXRlbSBmb3IgZXZlbnRcbiAgICBjb25zdCBwcmV2aW91c0l0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoa2V5KTtcblxuICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCBhcGkudXBkYXRlKGtleSwgdik7XG5cbiAgICAvLyBDYWNoZSB0aGUgcmVzdWx0IGFmdGVyIHRoZSB1cGRhdGVcbiAgICBsb2dnZXIuZGVidWcoJ0NhY2hpbmcgdXBkYXRlIHJlc3VsdCcsIHsgdXBkYXRlZEtleTogdXBkYXRlZC5rZXkgfSk7XG4gICAgYXdhaXQgY2FjaGVNYXAuc2V0KHVwZGF0ZWQua2V5LCB1cGRhdGVkKTtcblxuICAgIC8vIENyZWF0ZSBiYXNlIG1ldGFkYXRhIGlmIGl0IGRvZXNuJ3QgZXhpc3QgKG5lZWRlZCBmb3IgVFRMIGFuZCBldmljdGlvbilcbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeSh1cGRhdGVkLmtleSk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYWNoZU1hcC5nZXRNZXRhZGF0YShrZXlTdHIpO1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBiYXNlTWV0YWRhdGEgPSB7XG4gICAgICAgIGtleToga2V5U3RyLFxuICAgICAgICBhZGRlZEF0OiBub3csXG4gICAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgICBlc3RpbWF0ZWRTaXplOiBlc3RpbWF0ZVZhbHVlU2l6ZSh1cGRhdGVkKVxuICAgICAgfTtcbiAgICAgIGF3YWl0IGNhY2hlTWFwLnNldE1ldGFkYXRhKGtleVN0ciwgYmFzZU1ldGFkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgVFRMIG1ldGFkYXRhIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICBhd2FpdCBjb250ZXh0LnR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG5cbiAgICAvLyBIYW5kbGUgZXZpY3Rpb24gZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gYXdhaXQgY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB1cGRhdGVkLCBjYWNoZU1hcCk7XG4gICAgLy8gUmVtb3ZlIGV2aWN0ZWQgaXRlbXMgZnJvbSBjYWNoZVxuICAgIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgIGF3YWl0IGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgIH1cblxuICAgIC8vIEVtaXQgZXZlbnRcbiAgICBjb25zdCBldmVudCA9IENhY2hlRXZlbnRGYWN0b3J5Lml0ZW1VcGRhdGVkKHVwZGF0ZWQua2V5LCB1cGRhdGVkIGFzIFYsIHByZXZpb3VzSXRlbSwgJ2FwaScpO1xuICAgIGNvbnRleHQuZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQpO1xuXG4gICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKHVwZGF0ZWQsIHBrVHlwZSkgYXMgVl07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBpdGVtXCIsIHsgZXJyb3I6IGUgfSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsImltcG9ydCB7XG4gIENvbUtleSxcbiAgaXNWYWxpZEl0ZW1LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdhY3Rpb24nKTtcblxuZXhwb3J0IGNvbnN0IGFjdGlvbiA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgYWN0aW9uOiBzdHJpbmcsXG4gIGJvZHk6IGFueSA9IHt9LFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxbQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIFZdPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgnYWN0aW9uJywgeyBrZXksIGFjdGlvbiwgYm9keSB9KTtcblxuICBpZiAoIWlzVmFsaWRJdGVtS2V5KGtleSkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0tleSBmb3IgQWN0aW9uIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqJywga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBmb3IgQWN0aW9uIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXknKTtcbiAgfVxuXG4gIC8vIEludmFsaWRhdGUgdGhlIGl0ZW0ga2V5IGJlZm9yZSBleGVjdXRpbmcgdGhlIGFjdGlvblxuICBsb2dnZXIuZGVidWcoJ0ludmFsaWRhdGluZyBpdGVtIGtleSBiZWZvcmUgYWN0aW9uJywgeyBrZXkgfSk7XG4gIGNhY2hlTWFwLmludmFsaWRhdGVJdGVtS2V5cyhba2V5XSk7XG5cbiAgY29uc3QgdXBkYXRlZCA9IGF3YWl0IGFwaS5hY3Rpb24oa2V5LCBhY3Rpb24sIGJvZHkpO1xuXG4gIC8vIENhY2hlIHRoZSByZXN1bHQgYWZ0ZXIgdGhlIGFjdGlvblxuICBsb2dnZXIuZGVidWcoJ0NhY2hpbmcgYWN0aW9uIHJlc3VsdCcsIHsgdXBkYXRlZEtleTogdXBkYXRlZC5rZXkgfSk7XG4gIGNhY2hlTWFwLnNldCh1cGRhdGVkLmtleSwgdXBkYXRlZCk7XG5cbiAgLy8gU2V0IFRUTCBtZXRhZGF0YSBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHVwZGF0ZWQua2V5KTtcbiAgY29udGV4dC50dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gIC8vIEhhbmRsZSBldmljdGlvbiBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gIGNvbnN0IGV2aWN0ZWRLZXlzID0gYXdhaXQgY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB1cGRhdGVkLCBjYWNoZU1hcCk7XG4gIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgZm9yIChjb25zdCBldmljdGVkS2V5IG9mIGV2aWN0ZWRLZXlzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgZXZpY3RlZCBrZXkgZHVyaW5nIGRlbGV0aW9uJywge1xuICAgICAgICBldmljdGVkS2V5LFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIC8vIENvbnRpbnVlIHByb2Nlc3Npbmcgb3RoZXIga2V5cyByYXRoZXIgdGhhbiBmYWlsaW5nIGNvbXBsZXRlbHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsodXBkYXRlZCwgcGtUeXBlKSBhcyBWXTtcbn07XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheSxcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IE5vdEZvdW5kRXJyb3IgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnYWxsQWN0aW9uJyk7XG5cbmV4cG9ydCBjb25zdCBhbGxBY3Rpb24gPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGFjdGlvbjogc3RyaW5nLFxuICBib2R5OiBhbnkgPSB7fSxcbiAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXSxcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWW11dPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgnYWxsQWN0aW9uJywgeyBhY3Rpb24sIGJvZHksIGxvY2F0aW9ucyB9KTtcblxuICAvLyBJbnZhbGlkYXRlIGFsbCBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9ucyBiZWZvcmUgZXhlY3V0aW5nIHRoZSBhY3Rpb25cbiAgbG9nZ2VyLmRlYnVnKCdJbnZhbGlkYXRpbmcgbG9jYXRpb24gYmVmb3JlIGFsbEFjdGlvbicsIHsgbG9jYXRpb25zIH0pO1xuICBjYWNoZU1hcC5pbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKTtcblxuICBsZXQgcmV0OiBWW10gPSBbXTtcbiAgdHJ5IHtcbiAgICByZXQgPSBhd2FpdCBhcGkuYWxsQWN0aW9uKGFjdGlvbiwgYm9keSwgbG9jYXRpb25zKTtcblxuICAgIC8vIENhY2hlIGFsbCByZXN1bHRzIGFmdGVyIHRoZSBhY3Rpb25cbiAgICBsb2dnZXIuZGVidWcoJ0NhY2hpbmcgYWxsQWN0aW9uIHJlc3VsdHMnLCB7IHJlc3VsdENvdW50OiByZXQubGVuZ3RoIH0pO1xuICAgIGZvciAoY29uc3QgdiBvZiByZXQpIHtcbiAgICAgIGF3YWl0IGNhY2hlTWFwLnNldCh2LmtleSwgdik7XG5cbiAgICAgIC8vIFNldCBUVEwgbWV0YWRhdGEgZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkodi5rZXkpO1xuICAgICAgY29udGV4dC50dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gICAgICAvLyBIYW5kbGUgZXZpY3Rpb24gZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHYsIGNhY2hlTWFwKTtcbiAgICAgIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgICAgIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGU6IHVua25vd24pIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikge1xuICAgICAgLy8gSGFuZGxlIG5vdCBmb3VuZCBncmFjZWZ1bGx5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhyZXQsIHBrVHlwZSkgYXMgVltdXTtcbn07XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIEl0ZW0sXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdmYWNldCcpO1xuXG5leHBvcnQgY29uc3QgZmFjZXQgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gIGZhY2V0OiBzdHJpbmcsXG4gIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPGFueT4gPT4ge1xuICBjb25zdCB7IGFwaSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2ZhY2V0JywgeyBrZXksIGZhY2V0IH0pO1xuICBjb25zdCByZXQgPSBhd2FpdCBhcGkuZmFjZXQoa2V5LCBmYWNldCwgcGFyYW1zKTtcbiAgcmV0dXJuIHJldDtcbn07XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdhbGxGYWNldCcpO1xuXG5leHBvcnQgY29uc3QgYWxsRmFjZXQgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGZhY2V0OiBzdHJpbmcsXG4gIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW10sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPGFueT4gPT4ge1xuICBjb25zdCB7IGFwaSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2FsbEZhY2V0JywgeyBmYWNldCwgcGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gIGNvbnN0IHJldCA9IGF3YWl0IGFwaS5hbGxGYWNldChmYWNldCwgcGFyYW1zLCBsb2NhdGlvbnMpO1xuICByZXR1cm4gcmV0O1xufTtcbiIsImltcG9ydCB7XG4gIEl0ZW0sXG4gIExvY0tleUFycmF5LFxuICB2YWxpZGF0ZVBLXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVDb250ZXh0IH0gZnJvbSBcIi4uL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IHsgY3JlYXRlRmluZGVySGFzaCB9IGZyb20gXCIuLi9ub3JtYWxpemF0aW9uXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnZmluZCcpO1xuXG5leHBvcnQgY29uc3QgZmluZCA9IGFzeW5jIDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgZmluZGVyOiBzdHJpbmcsXG4gIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW10sXG4gIGNvbnRleHQ6IENhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgVltdXT4gPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgdHRsTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyLmRlZmF1bHQoJ2ZpbmQnLCB7IGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMgfSk7XG5cbiAgLy8gR2VuZXJhdGUgcXVlcnkgaGFzaCBmb3IgY2FjaGluZ1xuICBjb25zdCBxdWVyeUhhc2ggPSBjcmVhdGVGaW5kZXJIYXNoKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMpO1xuICBsb2dnZXIuZGVidWcoJ0dlbmVyYXRlZCBxdWVyeSBoYXNoIGZvciBmaW5kJywgeyBxdWVyeUhhc2ggfSk7XG5cbiAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBjYWNoZWQgcXVlcnkgcmVzdWx0c1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cykge1xuICAgIGxvZ2dlci5kZWJ1ZygnVXNpbmcgY2FjaGVkIHF1ZXJ5IHJlc3VsdHMnLCB7IGNhY2hlZEtleUNvdW50OiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggfSk7XG5cbiAgICAvLyBSZXRyaWV2ZSBhbGwgY2FjaGVkIGl0ZW1zIC0gaWYgYW55IGFyZSBtaXNzaW5nLCBpbnZhbGlkYXRlIHRoZSBxdWVyeSBjYWNoZVxuICAgIGNvbnN0IGNhY2hlZEl0ZW1zOiBWW10gPSBbXTtcbiAgICBsZXQgYWxsSXRlbXNBdmFpbGFibGUgPSB0cnVlO1xuXG4gICAgZm9yIChjb25zdCBpdGVtS2V5IG9mIGNhY2hlZEl0ZW1LZXlzKSB7XG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGl0ZW1LZXkpO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY2FjaGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbEl0ZW1zQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbGxJdGVtc0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKGNhY2hlZEl0ZW1zLCBwa1R5cGUpIGFzIFZbXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU29tZSBjYWNoZWQgaXRlbXMgbWlzc2luZywgaW52YWxpZGF0aW5nIHF1ZXJ5IGNhY2hlJyk7XG4gICAgICBjYWNoZU1hcC5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZldGNoIGZyb20gQVBJXG4gIGNvbnN0IHJldDogVltdID0gYXdhaXQgYXBpLmZpbmQoZmluZGVyLCBwYXJhbXMsIGxvY2F0aW9ucyk7XG5cbiAgLy8gU3RvcmUgaW5kaXZpZHVhbCBpdGVtcyBpbiBjYWNoZVxuICBmb3IgKGNvbnN0IHYgb2YgcmV0KSB7XG4gICAgYXdhaXQgY2FjaGVNYXAuc2V0KHYua2V5LCB2KTtcblxuICAgIC8vIFNldCBUVEwgbWV0YWRhdGEgZm9yIHRoZSBuZXdseSBjYWNoZWQgaXRlbVxuICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHYua2V5KTtcbiAgICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuXG4gICAgLy8gSGFuZGxlIGV2aWN0aW9uIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgICBjb25zdCBldmljdGVkS2V5cyA9IGF3YWl0IGNvbnRleHQuZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdiwgY2FjaGVNYXApO1xuICAgIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgICBmb3IgKGNvbnN0IGV2aWN0ZWRLZXkgb2YgZXZpY3RlZEtleXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICB9XG4gIH1cblxuICAvLyBTdG9yZSBxdWVyeSByZXN1bHQgKGl0ZW0ga2V5cykgaW4gcXVlcnkgY2FjaGVcbiAgY29uc3QgaXRlbUtleXMgPSByZXQubWFwKGl0ZW0gPT4gaXRlbS5rZXkpO1xuICBjYWNoZU1hcC5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGl0ZW1LZXlzKTtcbiAgbG9nZ2VyLmRlYnVnKCdDYWNoZWQgcXVlcnkgcmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXlDb3VudDogaXRlbUtleXMubGVuZ3RoIH0pO1xuXG4gIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhyZXQsIHBrVHlwZSkgYXMgVltdXTtcbn07XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheSxcbiAgdmFsaWRhdGVQS1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9DYWNoZUNvbnRleHRcIjtcbmltcG9ydCB7IGNyZWF0ZUZpbmRlckhhc2ggfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2ZpbmRPbmUnKTtcblxuZXhwb3J0IGNvbnN0IGZpbmRPbmUgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGZpbmRlcjogc3RyaW5nLFxuICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdLFxuICBjb250ZXh0OiBDYWNoZUNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKTogUHJvbWlzZTxbQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIFZdPiA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgnZmluZE9uZScsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyB9KTtcblxuICAvLyBHZW5lcmF0ZSBxdWVyeSBoYXNoIGZvciBjYWNoaW5nXG4gIGNvbnN0IHF1ZXJ5SGFzaCA9IGNyZWF0ZUZpbmRlckhhc2goZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyk7XG4gIGxvZ2dlci5kZWJ1ZygnR2VuZXJhdGVkIHF1ZXJ5IGhhc2ggZm9yIGZpbmRPbmUnLCB7IHF1ZXJ5SGFzaCB9KTtcblxuICAvLyBDaGVjayBpZiB3ZSBoYXZlIGNhY2hlZCBxdWVyeSByZXN1bHRzXG4gIGNvbnN0IGNhY2hlZEl0ZW1LZXlzID0gYXdhaXQgY2FjaGVNYXAuZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgaWYgKGNhY2hlZEl0ZW1LZXlzICYmIGNhY2hlZEl0ZW1LZXlzLmxlbmd0aCA+IDApIHtcbiAgICBsb2dnZXIuZGVidWcoJ1VzaW5nIGNhY2hlZCBxdWVyeSByZXN1bHRzJywgeyBjYWNoZWRLZXlDb3VudDogY2FjaGVkSXRlbUtleXMubGVuZ3RoIH0pO1xuXG4gICAgLy8gUmV0cmlldmUgdGhlIGZpcnN0IGNhY2hlZCBpdGVtIC0gaWYgbWlzc2luZywgaW52YWxpZGF0ZSB0aGUgcXVlcnkgY2FjaGVcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGNhY2hlZEl0ZW1LZXlzWzBdKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKGl0ZW0sIHBrVHlwZSkgYXMgVl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGVkIGl0ZW0gbWlzc2luZywgaW52YWxpZGF0aW5nIHF1ZXJ5IGNhY2hlJyk7XG4gICAgICBjYWNoZU1hcC5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZldGNoIGZyb20gQVBJXG4gIGNvbnN0IHJldCA9IGF3YWl0IGFwaS5maW5kT25lKGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMpO1xuXG4gIC8vIFN0b3JlIGluZGl2aWR1YWwgaXRlbSBpbiBjYWNoZVxuICBjYWNoZU1hcC5zZXQocmV0LmtleSwgcmV0KTtcblxuICAvLyBTZXQgVFRMIG1ldGFkYXRhIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkocmV0LmtleSk7XG4gIHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG5cbiAgLy8gSGFuZGxlIGV2aWN0aW9uIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHJldCwgY2FjaGVNYXApO1xuICAvLyBSZW1vdmUgZXZpY3RlZCBpdGVtcyBmcm9tIGNhY2hlXG4gIGZvciAoY29uc3QgZXZpY3RlZEtleSBvZiBldmljdGVkS2V5cykge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgYXdhaXQgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gIH1cblxuICAvLyBTdG9yZSBxdWVyeSByZXN1bHQgKHNpbmdsZSBpdGVtIGtleSkgaW4gcXVlcnkgY2FjaGVcbiAgY2FjaGVNYXAuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBbcmV0LmtleV0pO1xuICBsb2dnZXIuZGVidWcoJ0NhY2hlZCBxdWVyeSByZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleTogcmV0LmtleSB9KTtcblxuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsocmV0LCBwa1R5cGUpIGFzIFZdO1xufTtcbiIsImltcG9ydCB7XG4gIENvbUtleSxcbiAgaXNJdGVtS2V5RXF1YWwsXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBJdGVtLFxuICBQcmlLZXksXG4gIHZhbGlkYXRlUEtcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZUNvbnRleHQgfSBmcm9tIFwiLi4vQ2FjaGVDb250ZXh0XCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RmFjdG9yeSB9IGZyb20gXCIuLi9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnlcIjtcbmltcG9ydCB7IGVzdGltYXRlVmFsdWVTaXplIH0gZnJvbSBcIi4uL3V0aWxzL0NhY2hlU2l6ZVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ3NldCcpO1xuXG4vLyBOb3JtYWxpemUgYSBrZXkgdmFsdWUgdG8gc3RyaW5nIGZvciBjb25zaXN0ZW50IGNvbXBhcmlzb25cbmNvbnN0IG5vcm1hbGl6ZUtleVZhbHVlID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn07XG5cbi8vIE5vcm1hbGl6ZWQga2V5IGNvbXBhcmlzb24gZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHN0cmluZy9udW1iZXIgZGlmZmVyZW5jZXNcbmNvbnN0IGlzSXRlbUtleUVxdWFsTm9ybWFsaXplZCA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihhOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgYjogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBib29sZWFuID0+IHtcbiAgLy8gRm9yIG5vdywganVzdCBub3JtYWxpemUgdGhlIGtleXMgdG8gc3RyaW5ncyBhbmQgdXNlIHRoZSBvcmlnaW5hbCBjb21wYXJpc29uXG4gIGNvbnN0IG5vcm1hbGl6ZWRBID0gbm9ybWFsaXplS2V5KGEpO1xuICBjb25zdCBub3JtYWxpemVkQiA9IG5vcm1hbGl6ZUtleShiKTtcbiAgcmV0dXJuIGlzSXRlbUtleUVxdWFsKG5vcm1hbGl6ZWRBIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LCBub3JtYWxpemVkQiBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGEga2V5IGVmZmljaWVudGx5IHdpdGhvdXQgZGVlcCBjbG9uaW5nXG5jb25zdCBub3JtYWxpemVLZXkgPSAoa2V5OiBhbnkpOiBhbnkgPT4ge1xuICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgbGV0IG5lZWRzTm9ybWFsaXphdGlvbiA9IGZhbHNlO1xuICAgIGxldCBub3JtYWxpemVkS2V5ID0ga2V5O1xuXG4gICAgLy8gQ2hlY2sgaWYgcGsgbmVlZHMgbm9ybWFsaXphdGlvblxuICAgIGlmICgncGsnIGluIGtleSAmJiBrZXkucGsgIT09IG51bGwgJiYgdHlwZW9mIGtleS5wayAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5lZWRzTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgbGsgbmVlZHMgbm9ybWFsaXphdGlvblxuICAgIGlmICgnbGsnIGluIGtleSAmJiBrZXkubGsgIT09IG51bGwgJiYgdHlwZW9mIGtleS5sayAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5lZWRzTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgbG9jIGFycmF5IGhhcyBsayB2YWx1ZXMgdGhhdCBuZWVkIG5vcm1hbGl6YXRpb25cbiAgICBpZiAoJ2xvYycgaW4ga2V5ICYmIEFycmF5LmlzQXJyYXkoa2V5LmxvYykpIHtcbiAgICAgIGZvciAoY29uc3QgbG9jSXRlbSBvZiBrZXkubG9jKSB7XG4gICAgICAgIGlmIChsb2NJdGVtICYmICdsaycgaW4gbG9jSXRlbSAmJiBsb2NJdGVtLmxrICE9PSBudWxsICYmIHR5cGVvZiBsb2NJdGVtLmxrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5lZWRzTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbmx5IGNyZWF0ZSBhIG5ldyBvYmplY3QgaWYgbm9ybWFsaXphdGlvbiBpcyBhY3R1YWxseSBuZWVkZWRcbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKSB7XG4gICAgICBub3JtYWxpemVkS2V5ID0geyAuLi5rZXkgfTtcblxuICAgICAgLy8gTm9ybWFsaXplIHBrIHZhbHVlc1xuICAgICAgaWYgKCdwaycgaW4gbm9ybWFsaXplZEtleSAmJiBub3JtYWxpemVkS2V5LnBrICE9PSBudWxsKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkucGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LnBrKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGxrIHZhbHVlc1xuICAgICAgaWYgKCdsaycgaW4gbm9ybWFsaXplZEtleSAmJiBub3JtYWxpemVkS2V5LmxrICE9PSBudWxsKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LmxrKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGxvYyBhcnJheSBsayB2YWx1ZXNcbiAgICAgIGlmICgnbG9jJyBpbiBub3JtYWxpemVkS2V5ICYmIEFycmF5LmlzQXJyYXkobm9ybWFsaXplZEtleS5sb2MpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubG9jID0gbm9ybWFsaXplZEtleS5sb2MubWFwKChsb2NJdGVtOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAobG9jSXRlbSAmJiAnbGsnIGluIGxvY0l0ZW0gJiYgbG9jSXRlbS5sayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9jSXRlbS5sayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmxvY0l0ZW0sIGxrOiBub3JtYWxpemVLZXlWYWx1ZShsb2NJdGVtLmxrKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9jSXRlbTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRLZXk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXQgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gIHY6IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgY29udGV4dDogQ2FjaGVDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IFByb21pc2U8W0NhY2hlQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBWXT4gPT4ge1xuICBjb25zdCB7IGNhY2hlTWFwLCBwa1R5cGUsIHR0bE1hbmFnZXIsIGV2aWN0aW9uTWFuYWdlciwgZXZlbnRFbWl0dGVyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdCgnc2V0JywgeyBrZXksIHYgfSk7XG5cbiAgaWYgKCFpc1ZhbGlkSXRlbUtleShrZXkpKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdLZXkgZm9yIFNldCBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlaicsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZm9yIFNldCBpcyBub3QgYSB2YWxpZCBJdGVtS2V5Jyk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSB0aGUgaXRlbSdzIHByaW1hcnkga2V5XG4gIHZhbGlkYXRlUEsodiwgcGtUeXBlKTtcblxuICBpZiAoIWlzSXRlbUtleUVxdWFsTm9ybWFsaXplZChrZXksIHYua2V5KSkge1xuICAgIGxvZ2dlci5lcnJvcignS2V5IGRvZXMgbm90IG1hdGNoIGl0ZW0ga2V5OiAlaiAhPSAlaicsIGtleSwgdi5rZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IGRvZXMgbm90IG1hdGNoIGl0ZW0ga2V5Jyk7XG4gIH1cblxuICAvLyBHZXQgcHJldmlvdXMgaXRlbSBpZiBpdCBleGlzdHNcbiAgY29uc3QgcHJldmlvdXNJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG5cbiAgYXdhaXQgY2FjaGVNYXAuc2V0KGtleSwgdiBhcyBWKTtcblxuICAvLyBDcmVhdGUgYmFzZSBtZXRhZGF0YSBpZiBpdCBkb2Vzbid0IGV4aXN0IChuZWVkZWQgZm9yIFRUTCBhbmQgZXZpY3Rpb24pXG4gIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2FjaGVNYXAuZ2V0TWV0YWRhdGEoa2V5U3RyKTtcbiAgaWYgKCFtZXRhZGF0YSkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgYmFzZU1ldGFkYXRhID0ge1xuICAgICAga2V5OiBrZXlTdHIsXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplOiBlc3RpbWF0ZVZhbHVlU2l6ZSh2KVxuICAgIH07XG4gICAgYXdhaXQgY2FjaGVNYXAuc2V0TWV0YWRhdGEoa2V5U3RyLCBiYXNlTWV0YWRhdGEpO1xuICB9XG5cbiAgLy8gU2V0IFRUTCBtZXRhZGF0YSBmb3IgdGhlIG5ld2x5IGNhY2hlZCBpdGVtXG4gIGF3YWl0IHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG5cbiAgLy8gSGFuZGxlIGV2aWN0aW9uIGZvciB0aGUgbmV3bHkgY2FjaGVkIGl0ZW1cbiAgY29uc3QgZXZpY3RlZEtleXMgPSBhd2FpdCBldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB2LCBjYWNoZU1hcCk7XG4gIC8vIFJlbW92ZSBldmljdGVkIGl0ZW1zIGZyb20gY2FjaGVcbiAgZm9yIChjb25zdCBldmljdGVkS2V5IG9mIGV2aWN0ZWRLZXlzKSB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICBhd2FpdCBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgfVxuXG4gIC8vIEVtaXQgZXZlbnRcbiAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtU2V0KGtleSwgdiBhcyBWLCBwcmV2aW91c0l0ZW0pO1xuICBldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG5cbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLKHYsIHBrVHlwZSkgYXMgVl07XG59O1xuIiwiaW1wb3J0IHtcbiAgQWxsSXRlbVR5cGVBcnJheXMsXG4gIENvbUtleSxcbiAgaXNDb21LZXksXG4gIGlzUXVlcnlNYXRjaCxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tIFwiLi4vQ2FjaGVNYXBcIjtcbmltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhIH0gZnJvbSBcIi4uL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lcIjtcbmltcG9ydCB7IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sIGlzTG9jS2V5QXJyYXlFcXVhbCwgUXVlcnlDYWNoZUVudHJ5IH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IGVzdGltYXRlVmFsdWVTaXplIH0gZnJvbSBcIi4uL3V0aWxzL0NhY2hlU2l6ZVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJNZW1vcnlDYWNoZU1hcFwiKTtcblxuaW50ZXJmYWNlIERpY3Rpb25hcnlFbnRyeTxLLCBWPiB7XG4gIG9yaWdpbmFsS2V5OiBLO1xuICB2YWx1ZTogVjtcbn1cblxuLyoqXG4gKiBJbi1tZW1vcnkgaW1wbGVtZW50YXRpb24gb2YgQ2FjaGVNYXAgdXNpbmcgYSBwbGFpbiBvYmplY3QgYXMgdGhlIHVuZGVybHlpbmcgc3RvcmFnZS5cbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gc3RvcmVzIGFsbCBkYXRhIGluIG1lbW9yeSBhbmQgd2lsbCBiZSBsb3N0IHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlc3RhcnRzLlxuICovXG5leHBvcnQgY2xhc3MgTWVtb3J5Q2FjaGVNYXA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcblxuICBwdWJsaWMgcmVhZG9ubHkgaW1wbGVtZW50YXRpb25UeXBlID0gXCJtZW1vcnkvbWVtb3J5XCI7XG5cbiAgcHJpdmF0ZSBtYXA6IHsgW2tleTogc3RyaW5nXTogRGljdGlvbmFyeUVudHJ5PENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LCBWPiB9ID0ge307XG4gIHByaXZhdGUgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pID0+IHN0cmluZztcblxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGU6IG1hcHMgcXVlcnkgaGFzaCB0byBjYWNoZSBlbnRyeVxuICBwcml2YXRlIHF1ZXJ5UmVzdWx0Q2FjaGU6IHsgW3F1ZXJ5SGFzaDogc3RyaW5nXTogUXVlcnlDYWNoZUVudHJ5IH0gPSB7fTtcblxuICAvLyBNZXRhZGF0YSBzdG9yYWdlIGZvciBldmljdGlvbiBzdHJhdGVnaWVzXG4gIHByaXZhdGUgbWV0YWRhdGFNYXA6IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPiA9IG5ldyBNYXAoKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgdHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgaW5pdGlhbERhdGE/OiB7IFtrZXk6IHN0cmluZ106IFYgfVxuICApIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbjxDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPj4oKTtcblxuICAgIC8vIEluaXRpYWxpemUgd2l0aCBkYXRhIGlmIHByb3ZpZGVkXG4gICAgaWYgKGluaXRpYWxEYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXlTdHIsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbml0aWFsRGF0YSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBKU09OLnBhcnNlKGtleVN0cikgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz47XG4gICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgaW5pdGlhbCBkYXRhIGtleScsIHsga2V5U3RyLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXQoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgKTogUHJvbWlzZTxWIHwgbnVsbD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0JywgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuXG4gICAgaWYgKGVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSkge1xuICAgICAgLy8gVXBkYXRlIG1ldGFkYXRhIGZvciBhY2Nlc3MgdHJhY2tpbmdcbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFNYXAuZ2V0KGtleVN0cik7XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgdmFsdWU6IFYpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldCcsIHsga2V5LCB2YWx1ZSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuXG4gICAgLy8gQ3JlYXRlIG9yIHVwZGF0ZSB0aGUgaXRlbSBlbnRyeVxuICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7IG9yaWdpbmFsS2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xuXG4gICAgLy8gQ3JlYXRlIG1ldGFkYXRhIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIXRoaXMubWV0YWRhdGFNYXAuaGFzKGtleVN0cikpIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEgPSB7XG4gICAgICAgIGtleToga2V5U3RyLFxuICAgICAgICBhZGRlZEF0OiBub3csXG4gICAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgICBlc3RpbWF0ZWRTaXplOiBlc3RpbWF0ZVZhbHVlU2l6ZSh2YWx1ZSlcbiAgICAgIH07XG4gICAgICB0aGlzLm1ldGFkYXRhTWFwLnNldChrZXlTdHIsIG1ldGFkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIG1ldGFkYXRhXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFNYXAuZ2V0KGtleVN0cikhO1xuICAgICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcbiAgICAgIG1ldGFkYXRhLmVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGluY2x1ZGVzS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgcmV0dXJuICEhZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdkZWxldGUnLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgaWYgKGVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSkge1xuICAgICAgLy8gUmVtb3ZlIGFzc29jaWF0ZWQgbWV0YWRhdGEgdXNpbmcgdGhlIG9yaWdpbmFsIGtleSByZXByZXNlbnRhdGlvblxuICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoZW50cnkub3JpZ2luYWxLZXkpO1xuICAgICAgdGhpcy5tZXRhZGF0YU1hcC5kZWxldGUoa2V5U3RyKTtcblxuICAgICAgZGVsZXRlIHRoaXMubWFwW2hhc2hlZEtleV07XG5cbiAgICAgIC8vIFJlbW92ZSB0aGlzIGtleSBmcm9tIGFueSBjYWNoZWQgcXVlcnkgcmVzdWx0c1xuICAgICAgZm9yIChjb25zdCBbcXVlcnlIYXNoLCBjYWNoZUVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpKSB7XG4gICAgICAgIGNhY2hlRW50cnkuaXRlbUtleXMgPSBjYWNoZUVudHJ5Lml0ZW1LZXlzLmZpbHRlcihrID0+IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrKSAhPT0gaGFzaGVkS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlRW50cnkuaXRlbUtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGtleXMoKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10+IHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkubWFwKGVudHJ5ID0+IGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB2YWx1ZXMoKTogUHJvbWlzZTxWW10+IHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkubWFwKGVudHJ5ID0+IGVudHJ5LnZhbHVlKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIC8vIENsZWFyIHJlbGF0ZWQgbWV0YWRhdGEgYW5kIHF1ZXJ5IHJlc3VsdHMgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXG4gICAgdGhpcy5tZXRhZGF0YU1hcC5jbGVhcigpO1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFsbEluKFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8VltdPiB7XG4gICAgY29uc3QgYWxsVmFsdWVzID0gYXdhaXQgdGhpcy52YWx1ZXMoKTtcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5Jyk7XG4gICAgICByZXR1cm4gYWxsVmFsdWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ2FsbEluJywgeyBsb2NhdGlvbnMsIGNvdW50OiBhbGxWYWx1ZXMubGVuZ3RoIH0pO1xuICAgICAgcmV0dXJuIGFsbFZhbHVlcy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgICBpZiAoa2V5ICYmIGlzQ29tS2V5KGtleSkpIHtcbiAgICAgICAgICBjb25zdCBjb21LZXkgPSBrZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NhdGlvbnMsIGNvbUtleS5sb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb250YWlucyhxdWVyeTogSXRlbVF1ZXJ5LCBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnY29udGFpbnMnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG5cbiAgICByZXR1cm4gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcXVlcnlJbihcbiAgICBxdWVyeTogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+IHtcbiAgICBsb2dnZXIuZGVidWcoJ3F1ZXJ5SW4nLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG5cbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2goaXRlbSwgcXVlcnkpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbG9uZSgpOiBQcm9taXNlPE1lbW9yeUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+IHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBNZW1vcnlDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KHRoaXMudHlwZXMpO1xuICAgIC8vIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjb3B5IG9mIHRoZSBtYXAuXG4gICAgLy8gVGhpcyBpcyBhIHNoYWxsb3cgY29weSBvZiB0aGUgZW50cmllcywgc28gaXRlbXMgdGhlbXNlbHZlcyBhcmUgbm90IGRlZXAtY2xvbmVkLlxuICAgIGNvbnN0IGtleXMgPSBhd2FpdCB0aGlzLmtleXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAvLyBnZXQoKSB3aWxsIHVzZSB0aGUgY29ycmVjdCBub3JtYWxpemVkIHJldHJpZXZhbFxuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlKSB7IC8vIFNob3VsZCBoYW5kbGUgbnVsbC91bmRlZmluZWQgdmFsdWVzIGlmIHRoZXkgY2FuIGJlIHNldFxuICAgICAgICBhd2FpdCBjbG9uZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29weSBxdWVyeSByZXN1bHQgY2FjaGVcbiAgICBmb3IgKGNvbnN0IFtxdWVyeUhhc2gsIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpKSB7XG4gICAgICBjbG9uZS5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF0gPSB7XG4gICAgICAgIGl0ZW1LZXlzOiBbLi4uZW50cnkuaXRlbUtleXNdIC8vIFNoYWxsb3cgY29weSBvZiB0aGUgYXJyYXlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG4gIHB1YmxpYyBhc3luYyBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZywgaXRlbUtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnc2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleXMgfSk7XG5cbiAgICBjb25zdCBlbnRyeTogUXVlcnlDYWNoZUVudHJ5ID0ge1xuICAgICAgaXRlbUtleXM6IFsuLi5pdGVtS2V5c10gLy8gQ3JlYXRlIGEgY29weSB0byBhdm9pZCBleHRlcm5hbCBtdXRhdGlvbnNcbiAgICB9O1xuXG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF0gPSBlbnRyeTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8KENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdIHwgbnVsbD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsuLi5lbnRyeS5pdGVtS2V5c107IC8vIFJldHVybiBhIGNvcHkgdG8gYXZvaWQgZXh0ZXJuYWwgbXV0YXRpb25zXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIHJldHVybiAhIWVudHJ5O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdkZWxldGVRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZhbGlkYXRlSXRlbUtleXMoa2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlSXRlbUtleXMnLCB7IGtleXMgfSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlTG9jYXRpb24nLCB7IGxvY2F0aW9ucyB9KTtcblxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGb3IgcHJpbWFyeSBpdGVtcyAobm8gbG9jYXRpb24pLCBjbGVhciBhbGwgcHJpbWFyeSBrZXlzXG4gICAgICBjb25zdCBhbGxLZXlzID0gYXdhaXQgdGhpcy5rZXlzKCk7XG4gICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKGtleSA9PiAhaXNDb21LZXkoa2V5KSk7XG4gICAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhwcmltYXJ5S2V5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBjb250YWluZWQgaXRlbXMsIGdldCBhbGwgaXRlbXMgaW4gdGhlIGxvY2F0aW9uIGFuZCBpbnZhbGlkYXRlIHRoZW1cbiAgICAgIGNvbnN0IGl0ZW1zSW5Mb2NhdGlvbiA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICAgIGNvbnN0IGtleXNUb0ludmFsaWRhdGUgPSBpdGVtc0luTG9jYXRpb24ubWFwKGl0ZW0gPT4gaXRlbS5rZXkpO1xuICAgICAgYXdhaXQgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMoa2V5c1RvSW52YWxpZGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgYWxsIHF1ZXJ5IHJlc3VsdHMgdGhhdCBtaWdodCBiZSBhZmZlY3RlZFxuICAgIC8vIEZvciBub3csIHdlJ2xsIGNsZWFyIGFsbCBxdWVyeSByZXN1bHRzIHRvIGJlIHNhZmVcbiAgICAvLyBBIG1vcmUgc29waGlzdGljYXRlZCBhcHByb2FjaCB3b3VsZCBiZSB0byB0cmFjayB3aGljaCBxdWVyaWVzIGFyZSBsb2NhdGlvbi1zcGVjaWZpY1xuICAgIGF3YWl0IHRoaXMuY2xlYXJRdWVyeVJlc3VsdHMoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhclF1ZXJ5UmVzdWx0cygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2NsZWFyUXVlcnlSZXN1bHRzJyk7XG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlID0ge307XG4gIH1cblxuICAvLyBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgcHVibGljIGFzeW5jIGdldE1ldGFkYXRhKGtleTogc3RyaW5nKTogUHJvbWlzZTxDYWNoZUl0ZW1NZXRhZGF0YSB8IG51bGw+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YU1hcC5nZXQoa2V5KSB8fCBudWxsO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldE1ldGFkYXRhKGtleTogc3RyaW5nLCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLnNldChrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubWV0YWRhdGFNYXAuZGVsZXRlKGtleSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWxsTWV0YWRhdGEoKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4+IHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLm1ldGFkYXRhTWFwKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhck1ldGFkYXRhKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubWV0YWRhdGFNYXAuY2xlYXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRDdXJyZW50U2l6ZSgpOiBQcm9taXNlPHsgaXRlbUNvdW50OiBudW1iZXI7IHNpemVCeXRlczogbnVtYmVyIH0+IHtcbiAgICBsZXQgc2l6ZUJ5dGVzID0gMDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXModGhpcy5tYXApKSB7XG4gICAgICBzaXplQnl0ZXMgKz0gZXN0aW1hdGVWYWx1ZVNpemUoZW50cnkudmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpdGVtQ291bnQ6IE9iamVjdC5rZXlzKHRoaXMubWFwKS5sZW5ndGgsXG4gICAgICBzaXplQnl0ZXNcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFNpemVMaW1pdHMoKTogUHJvbWlzZTx7IG1heEl0ZW1zOiBudW1iZXIgfCBudWxsOyBtYXhTaXplQnl0ZXM6IG51bWJlciB8IG51bGwgfT4ge1xuICAgIC8vIEJhc2ljIE1lbW9yeUNhY2hlTWFwIGhhcyBubyBzaXplIGxpbWl0c1xuICAgIHJldHVybiB7XG4gICAgICBtYXhJdGVtczogbnVsbCxcbiAgICAgIG1heFNpemVCeXRlczogbnVsbFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEFsbEl0ZW1UeXBlQXJyYXlzLFxuICBDb21LZXksXG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhLCBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgfSBmcm9tIFwiLi9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5XCI7XG5pbXBvcnQgeyBDYWNoZUluZm8gfSBmcm9tIFwiLi9DYWNoZVwiO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgaW50ZXJmYWNlIGZvciBjYWNoZSBtYXAgaW1wbGVtZW50YXRpb25zLlxuICogRGVmaW5lcyB0aGUgY29udHJhY3QgdGhhdCBhbGwgY2FjaGUgbWFwIGltcGxlbWVudGF0aW9ucyBtdXN0IGZvbGxvdy5cbiAqXG4gKiBAdGVtcGxhdGUgViAtIFRoZSB0eXBlIG9mIHRoZSBkYXRhIG1vZGVsIGl0ZW0sIGV4dGVuZGluZyBJdGVtXG4gKiBAdGVtcGxhdGUgUyAtIFRoZSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHJlcHJlc2VudGluZyB0aGUgbW9kZWwncyBrZXkgdHlwZVxuICogQHRlbXBsYXRlIEwxLUw1IC0gT3B0aW9uYWwgc3RyaW5nIGxpdGVyYWwgdHlwZXMgZm9yIGxvY2F0aW9uIGhpZXJhcmNoeSBsZXZlbHNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENhY2hlTWFwPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IGltcGxlbWVudHMgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIHtcbiAgcHJvdGVjdGVkIHR5cGVzOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKlxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gdHlwZSBpZGVudGlmaWVyIGluIHRoZSBmb3JtYXQgXCI8Y2F0ZWdvcnk+LzxpbXBsZW1lbnRhdGlvbj5cIlxuICAgKiBFeGFtcGxlczogXCJtZW1vcnkvbWVtb3J5XCIsIFwibWVtb3J5L2VuaGFuY2VkXCIsIFwiYnJvd3Nlci9sb2NhbFN0b3JhZ2VcIlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGltcGxlbWVudGF0aW9uVHlwZTogc3RyaW5nO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcih0eXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1Pikge1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhbiBpdGVtIGJ5IGl0cyBrZXlcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBnZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8ViB8IG51bGw+O1xuXG4gIC8qKlxuICAgKiBTdG9yZSBhbiBpdGVtIHdpdGggaXRzIGtleVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHNldChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LCB2YWx1ZTogVik6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IGV4aXN0cyBpbiB0aGUgY2FjaGVcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBpbmNsdWRlc0tleShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogRGVsZXRlIGFuIGl0ZW0gYnkgaXRzIGtleVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGRlbGV0ZShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogR2V0IGFsbCBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uc1xuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGFsbEluKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxWW10+O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbnkgaXRlbXMgbWF0Y2ggdGhlIHF1ZXJ5IGluIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25zXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgY29udGFpbnMocXVlcnk6IEl0ZW1RdWVyeSwgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGluIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25zXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgcXVlcnlJbihxdWVyeTogSXRlbVF1ZXJ5LCBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8VltdPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBjYWNoZSBtYXBcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBjbG9uZSgpOiBQcm9taXNlPENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGtleXMgaW4gdGhlIGNhY2hlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3Qga2V5cygpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXT47XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdmFsdWVzIGluIHRoZSBjYWNoZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHZhbHVlcygpOiBQcm9taXNlPFZbXT47XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpdGVtcyBmcm9tIHRoZSBjYWNoZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGNsZWFyKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBTZXQgYSBxdWVyeSByZXN1bHQgYXMgYSBjb2xsZWN0aW9uIG9mIGl0ZW0ga2V5c1xuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nLCBpdGVtS2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogR2V0IGEgcXVlcnkgcmVzdWx0IGFzIGEgY29sbGVjdGlvbiBvZiBpdGVtIGtleXNcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8KENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdIHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgcXVlcnkgcmVzdWx0IGV4aXN0cyBpbiBjYWNoZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogRGVsZXRlIGEgc3BlY2lmaWMgcXVlcnkgcmVzdWx0XG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBJbnZhbGlkYXRlIGFsbCBjYWNoZWQgaXRlbXMgYnkgdGhlaXIga2V5c1xuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGludmFsaWRhdGVJdGVtS2V5cyhrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBJbnZhbGlkYXRlIGFsbCBpdGVtcyBpbiBzcGVjaWZpZWQgbG9jYXRpb25zIGFuZCBjbGVhciByZWxhdGVkIHF1ZXJ5IHJlc3VsdHNcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgcXVlcnkgcmVzdWx0IGNhY2hlIGVudHJpZXNcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBjbGVhclF1ZXJ5UmVzdWx0cygpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciBpbXBsZW1lbnRhdGlvblxuICAvLyBUaGVzZSBtZXRob2RzIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYWxsIENhY2hlTWFwIGltcGxlbWVudGF0aW9ucyB0byBzdXBwb3J0IGV2aWN0aW9uXG5cbiAgLyoqXG4gICAqIEdldCBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpdGVtXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcmV0dXJucyBNZXRhZGF0YSBpZiBleGlzdHMsIG51bGwgb3RoZXJ3aXNlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPENhY2hlSXRlbU1ldGFkYXRhIHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIFNldCBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpdGVtXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSB0byBzdG9yZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHNldE1ldGFkYXRhKGtleTogc3RyaW5nLCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgaXRlbVxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBkZWxldGVNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbWV0YWRhdGEgZW50cmllc1xuICAgKiBAcmV0dXJucyBNYXAgb2YgYWxsIG1ldGFkYXRhIGVudHJpZXNcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBnZXRBbGxNZXRhZGF0YSgpOiBQcm9taXNlPE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPj47XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBtZXRhZGF0YVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGNsZWFyTWV0YWRhdGEoKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY2FjaGUgc2l6ZSBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBjdXJyZW50IHNpemUgbWV0cmljc1xuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGdldEN1cnJlbnRTaXplKCk6IFByb21pc2U8e1xuICAgIGl0ZW1Db3VudDogbnVtYmVyO1xuICAgIHNpemVCeXRlczogbnVtYmVyO1xuICB9PjtcblxuICAvKipcbiAgICogR2V0IGNhY2hlIHNpemUgbGltaXRzXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHNpemUgbGltaXRzIChudWxsIG1lYW5zIHVubGltaXRlZClcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBnZXRTaXplTGltaXRzKCk6IFByb21pc2U8e1xuICAgIG1heEl0ZW1zOiBudW1iZXIgfCBudWxsO1xuICAgIG1heFNpemVCeXRlczogbnVtYmVyIHwgbnVsbDtcbiAgfT47XG59XG4iLCJpbXBvcnQge1xuICBBbGxJdGVtVHlwZUFycmF5cyxcbiAgQ29tS2V5LFxuICBpc0NvbUtleSxcbiAgaXNRdWVyeU1hdGNoLFxuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZU1hcCB9IGZyb20gXCIuLi9DYWNoZU1hcFwiO1xuaW1wb3J0IHsgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiwgaXNMb2NLZXlBcnJheUVxdWFsLCBRdWVyeUNhY2hlRW50cnkgfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuaW1wb3J0IHsgQ2FjaGVTaXplQ29uZmlnIH0gZnJvbSBcIi4uL09wdGlvbnNcIjtcbmltcG9ydCB7XG4gIENhY2hlSXRlbU1ldGFkYXRhXG59IGZyb20gXCIuLi9ldmljdGlvblwiO1xuaW1wb3J0IHsgZXN0aW1hdGVWYWx1ZVNpemUsIHBhcnNlU2l6ZVN0cmluZyB9IGZyb20gXCIuLi91dGlscy9DYWNoZVNpemVcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiRW5oYW5jZWRNZW1vcnlDYWNoZU1hcFwiKTtcblxuaW50ZXJmYWNlIEVuaGFuY2VkRGljdGlvbmFyeUVudHJ5PEssIFY+IHtcbiAgb3JpZ2luYWxLZXk6IEs7XG4gIHZhbHVlOiBWO1xuICBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGE7XG4gIG1ldGFkYXRhQ2xlYXJlZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogRW5oYW5jZWQgaW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIENhY2hlTWFwIHdpdGggc2l6ZSBsaW1pdHMgYW5kIGV2aWN0aW9uIHBvbGljaWVzLlxuICogU3VwcG9ydHMgYnl0ZS1iYXNlZCBhbmQgaXRlbS1jb3VudCBsaW1pdHMgd2l0aCBjb25maWd1cmFibGUgZXZpY3Rpb24gc3RyYXRlZ2llcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuaGFuY2VkTWVtb3J5Q2FjaGVNYXA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcblxuICBwdWJsaWMgcmVhZG9ubHkgaW1wbGVtZW50YXRpb25UeXBlID0gXCJtZW1vcnkvZW5oYW5jZWRcIjtcblxuICBwcml2YXRlIG1hcDogeyBba2V5OiBzdHJpbmddOiBFbmhhbmNlZERpY3Rpb25hcnlFbnRyeTxDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgVj4gfSA9IHt9O1xuICBwcml2YXRlIG5vcm1hbGl6ZWRIYXNoRnVuY3Rpb246IChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KSA9PiBzdHJpbmc7XG5cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hlOiBtYXBzIHF1ZXJ5IGhhc2ggdG8gY2FjaGUgZW50cnlcbiAgcHJpdmF0ZSBxdWVyeVJlc3VsdENhY2hlOiB7IFtxdWVyeUhhc2g6IHN0cmluZ106IFF1ZXJ5Q2FjaGVFbnRyeSB9ID0ge307XG5cbiAgLy8gU2l6ZSB0cmFja2luZ1xuICBwcml2YXRlIGN1cnJlbnRTaXplQnl0ZXM6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY3VycmVudEl0ZW1Db3VudDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBxdWVyeVJlc3VsdHNDYWNoZVNpemU6IG51bWJlciA9IDA7XG5cbiAgLy8gU2l6ZSBsaW1pdHNcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTaXplQnl0ZXM/OiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4SXRlbXM/OiBudW1iZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHR5cGVzOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIHNpemVDb25maWc/OiBDYWNoZVNpemVDb25maWcsXG4gICAgaW5pdGlhbERhdGE/OiB7IFtrZXk6IHN0cmluZ106IFYgfVxuICApIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbjxDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPj4oKTtcblxuICAgIC8vIFBhcnNlIHNpemUgY29uZmlndXJhdGlvblxuICAgIGlmIChzaXplQ29uZmlnPy5tYXhTaXplQnl0ZXMpIHtcbiAgICAgIHRoaXMubWF4U2l6ZUJ5dGVzID0gcGFyc2VTaXplU3RyaW5nKHNpemVDb25maWcubWF4U2l6ZUJ5dGVzKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGUgc2l6ZSBsaW1pdCBzZXQnLCB7IG1heFNpemVCeXRlczogdGhpcy5tYXhTaXplQnl0ZXMgfSk7XG4gICAgfVxuXG4gICAgaWYgKHNpemVDb25maWc/Lm1heEl0ZW1zKSB7XG4gICAgICB0aGlzLm1heEl0ZW1zID0gc2l6ZUNvbmZpZy5tYXhJdGVtcztcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FjaGUgaXRlbSBsaW1pdCBzZXQnLCB7IG1heEl0ZW1zOiB0aGlzLm1heEl0ZW1zIH0pO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IEV2aWN0aW9uIGlzIGhhbmRsZWQgZXh0ZXJuYWxseSAtIHRoaXMgY2FjaGUgbWFwIG9ubHkgcHJvdmlkZXMgbWV0YWRhdGEgYWNjZXNzXG5cbiAgICAvLyBJbml0aWFsaXplIHdpdGggZGF0YSBpZiBwcm92aWRlZFxuICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgZm9yIChjb25zdCBba2V5U3RyLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdGlhbERhdGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5wYXJzZShrZXlTdHIpIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+O1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGluaXRpYWwgZGF0YSBrZXknLCB7IGtleVN0ciwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICk6IFByb21pc2U8ViB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldCcsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcblxuICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBBTkQgdGhlIG5vcm1hbGl6ZWQga2V5cyBtYXRjaCBBTkQgaGFzIGEgcmVhbCB2YWx1ZVxuICAgIGlmIChlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXkgJiYgZW50cnkudmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgdmFsdWU6IFYpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldCcsIHsga2V5LCB2YWx1ZSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUodmFsdWUpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiB1cGRhdGUgdG8gZXhpc3RpbmcgZW50cnlcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICBjb25zdCBpc1VwZGF0ZSA9IGV4aXN0aW5nRW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGV4aXN0aW5nRW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXk7XG5cbiAgICBpZiAoaXNVcGRhdGUpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBlbnRyeVxuICAgICAgY29uc3Qgc2l6ZURpZmYgPSBlc3RpbWF0ZWRTaXplIC0gZXhpc3RpbmdFbnRyeS5tZXRhZGF0YS5lc3RpbWF0ZWRTaXplO1xuICAgICAgdGhpcy5jdXJyZW50U2l6ZUJ5dGVzICs9IHNpemVEaWZmO1xuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IGV4aXN0aW5nRW50cnkudmFsdWU7XG4gICAgICBleGlzdGluZ0VudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICBleGlzdGluZ0VudHJ5Lm1ldGFkYXRhLmVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZWRTaXplO1xuXG4gICAgICBsb2dnZXIudHJhY2UoJ1VwZGF0ZWQgZXhpc3RpbmcgY2FjaGUgZW50cnknLCB7XG4gICAgICAgIGtleTogaGFzaGVkS2V5LFxuICAgICAgICBzaXplRGlmZixcbiAgICAgICAgY3VycmVudFNpemU6IHRoaXMuY3VycmVudFNpemVCeXRlcyxcbiAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlICE9PSB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBuZXcgZW50cnlcbiAgICAgIGNvbnN0IG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgICAgYWRkZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgbGFzdEFjY2Vzc2VkQXQ6IERhdGUubm93KCksXG4gICAgICAgIGFjY2Vzc0NvdW50OiAwLFxuICAgICAgICBlc3RpbWF0ZWRTaXplOiBlc3RpbWF0ZWRTaXplLFxuICAgICAgICBrZXk6IGhhc2hlZEtleVxuICAgICAgfTtcblxuICAgICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHtcbiAgICAgICAgb3JpZ2luYWxLZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBtZXRhZGF0YVxuICAgICAgfTtcblxuICAgICAgdGhpcy5jdXJyZW50U2l6ZUJ5dGVzICs9IGVzdGltYXRlZFNpemU7XG4gICAgICB0aGlzLmN1cnJlbnRJdGVtQ291bnQrKztcblxuICAgICAgbG9nZ2VyLnRyYWNlKCdBZGRlZCBuZXcgY2FjaGUgZW50cnknLCB7XG4gICAgICAgIGtleTogaGFzaGVkS2V5LFxuICAgICAgICBzaXplOiBlc3RpbWF0ZWRTaXplLFxuICAgICAgICBjdXJyZW50U2l6ZTogdGhpcy5jdXJyZW50U2l6ZUJ5dGVzLFxuICAgICAgICBjdXJyZW50Q291bnQ6IHRoaXMuY3VycmVudEl0ZW1Db3VudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGluY2x1ZGVzS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgcmV0dXJuICEhZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5ICYmIGVudHJ5LnZhbHVlICE9PSBudWxsO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5kZWxldGVJbnRlcm5hbChrZXksIHRydWUsICdmaWx0ZXInKTtcbiAgfVxuXG4gIHByaXZhdGUgZGVsZXRlSW50ZXJuYWwoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgaW52YWxpZGF0ZVF1ZXJpZXM6IGJvb2xlYW4gPSBmYWxzZSwgaW52YWxpZGF0aW9uTW9kZTogJ2ZpbHRlcicgfCAncmVtb3ZlJyA9ICdyZW1vdmUnKTogdm9pZCB7XG4gICAgbG9nZ2VyLnRyYWNlKCdkZWxldGUnLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG5cbiAgICBpZiAoZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5KSB7XG4gICAgICB0aGlzLmN1cnJlbnRTaXplQnl0ZXMgLT0gZW50cnkubWV0YWRhdGEuZXN0aW1hdGVkU2l6ZTtcbiAgICAgIHRoaXMuY3VycmVudEl0ZW1Db3VudC0tO1xuICAgICAgZGVsZXRlIHRoaXMubWFwW2hhc2hlZEtleV07XG5cbiAgICAgIGxvZ2dlci50cmFjZSgnRGVsZXRlZCBjYWNoZSBlbnRyeScsIHtcbiAgICAgICAga2V5OiBoYXNoZWRLZXksXG4gICAgICAgIGZyZWVkU2l6ZTogZW50cnkubWV0YWRhdGEuZXN0aW1hdGVkU2l6ZSxcbiAgICAgICAgY3VycmVudFNpemU6IHRoaXMuY3VycmVudFNpemVCeXRlcyxcbiAgICAgICAgY3VycmVudENvdW50OiB0aGlzLmN1cnJlbnRJdGVtQ291bnRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbnZhbGlkYXRlIHF1ZXJpZXMgdGhhdCByZWZlcmVuY2UgdGhpcyBrZXkgb25seSBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChpbnZhbGlkYXRlUXVlcmllcykge1xuICAgICAgICBpZiAoaW52YWxpZGF0aW9uTW9kZSA9PT0gJ2ZpbHRlcicpIHtcbiAgICAgICAgICB0aGlzLmZpbHRlclF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZVF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGtleXMoKTogUHJvbWlzZTwoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10+IHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcClcbiAgICAgIC5maWx0ZXIoZW50cnkgPT4gZW50cnkudmFsdWUgIT09IG51bGwpXG4gICAgICAubWFwKGVudHJ5ID0+IGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB2YWx1ZXMoKTogUHJvbWlzZTxWW10+IHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcClcbiAgICAgIC5maWx0ZXIoZW50cnkgPT4gZW50cnkudmFsdWUgIT09IG51bGwpXG4gICAgICAubWFwKGVudHJ5ID0+IGVudHJ5LnZhbHVlKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ0NsZWFyaW5nIGNhY2hlJywge1xuICAgICAgaXRlbXNDbGVhcmVkOiB0aGlzLmN1cnJlbnRJdGVtQ291bnQsXG4gICAgICBieXRlc0ZyZWVkOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXNcbiAgICB9KTtcblxuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5jdXJyZW50U2l6ZUJ5dGVzID0gMDtcbiAgICB0aGlzLmN1cnJlbnRJdGVtQ291bnQgPSAwO1xuICAgIC8vIE5vdGU6IFF1ZXJ5IHJlc3VsdHMgYXJlIHByZXNlcnZlZCB3aGVuIGNsZWFyaW5nIGNhY2hlIGl0ZW1zXG4gICAgLy8gVXNlIGNsZWFyUXVlcnlSZXN1bHRzKCkgc2VwYXJhdGVseSBpZiB5b3UgbmVlZCB0byBjbGVhciBxdWVyeSBjYWNoZSBhcyB3ZWxsXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWxsSW4oXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogUHJvbWlzZTxWW10+IHtcbiAgICBjb25zdCBhbGxWYWx1ZXMgPSBhd2FpdCB0aGlzLnZhbHVlcygpO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1JldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHknKTtcbiAgICAgIHJldHVybiBhbGxWYWx1ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnYWxsSW4nLCB7IGxvY2F0aW9ucywgY291bnQ6IGFsbFZhbHVlcy5sZW5ndGggfSk7XG4gICAgICByZXR1cm4gYWxsVmFsdWVzLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gaXRlbS5rZXk7XG4gICAgICAgIGlmIChrZXkgJiYgaXNDb21LZXkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jYXRpb25zLCAoa2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KS5sb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb250YWlucyhxdWVyeTogSXRlbVF1ZXJ5LCBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnY29udGFpbnMnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHF1ZXJ5SW4oXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdxdWVyeUluJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsb25lKCk6IFByb21pc2U8Q2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4ge1xuICAgIGNvbnN0IHNpemVDb25maWc6IENhY2hlU2l6ZUNvbmZpZyA9IHt9O1xuICAgIGlmICh0aGlzLm1heFNpemVCeXRlcykge1xuICAgICAgc2l6ZUNvbmZpZy5tYXhTaXplQnl0ZXMgPSB0aGlzLm1heFNpemVCeXRlcy50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhJdGVtcykge1xuICAgICAgc2l6ZUNvbmZpZy5tYXhJdGVtcyA9IHRoaXMubWF4SXRlbXM7XG4gICAgfVxuXG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRW5oYW5jZWRNZW1vcnlDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KHRoaXMudHlwZXMsIHNpemVDb25maWcpO1xuXG4gICAgLy8gQ29weSBlbnRyaWVzICh0aGlzIHdpbGwgdHJpZ2dlciBwcm9wZXIgc2l6ZSB0cmFja2luZylcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5rZXlzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGF3YWl0IGNsb25lLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb3B5IHF1ZXJ5IHJlc3VsdHNcbiAgICBmb3IgKGNvbnN0IFtxdWVyeUhhc2gsIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpKSB7XG4gICAgICBhd2FpdCBjbG9uZS5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGVudHJ5Lml0ZW1LZXlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY2FjaGUgc3RhdGlzdGljc1xuICAgKi9cbiAgcHVibGljIGdldFN0YXRzKCk6IHtcbiAgICBjdXJyZW50U2l6ZUJ5dGVzOiBudW1iZXI7XG4gICAgY3VycmVudEl0ZW1Db3VudDogbnVtYmVyO1xuICAgIG1heFNpemVCeXRlcz86IG51bWJlcjtcbiAgICBtYXhJdGVtcz86IG51bWJlcjtcbiAgICB1dGlsaXphdGlvblBlcmNlbnQ6IHtcbiAgICAgIGJ5dGVzPzogbnVtYmVyO1xuICAgICAgaXRlbXM/OiBudW1iZXI7XG4gICAgfTtcbiAgICB9IHtcbiAgICBjb25zdCBzdGF0cyA9IHtcbiAgICAgIGN1cnJlbnRTaXplQnl0ZXM6IHRoaXMuY3VycmVudFNpemVCeXRlcyxcbiAgICAgIGN1cnJlbnRJdGVtQ291bnQ6IHRoaXMuY3VycmVudEl0ZW1Db3VudCxcbiAgICAgIG1heFNpemVCeXRlczogdGhpcy5tYXhTaXplQnl0ZXMsXG4gICAgICBtYXhJdGVtczogdGhpcy5tYXhJdGVtcyxcbiAgICAgIHV0aWxpemF0aW9uUGVyY2VudDoge30gYXMgeyBieXRlcz86IG51bWJlcjsgaXRlbXM/OiBudW1iZXIgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5tYXhTaXplQnl0ZXMpIHtcbiAgICAgIHN0YXRzLnV0aWxpemF0aW9uUGVyY2VudC5ieXRlcyA9ICh0aGlzLmN1cnJlbnRTaXplQnl0ZXMgLyB0aGlzLm1heFNpemVCeXRlcykgKiAxMDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF4SXRlbXMpIHtcbiAgICAgIHN0YXRzLnV0aWxpemF0aW9uUGVyY2VudC5pdGVtcyA9ICh0aGlzLmN1cnJlbnRJdGVtQ291bnQgLyB0aGlzLm1heEl0ZW1zKSAqIDEwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cblxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzXG4gIHB1YmxpYyBhc3luYyBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZywgaXRlbUtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnc2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleXMgfSk7XG5cbiAgICAvLyBSZW1vdmUgZXhpc3RpbmcgZW50cnkgdG8gZ2V0IGFjY3VyYXRlIHNpemUgdHJhY2tpbmdcbiAgICBpZiAocXVlcnlIYXNoIGluIHRoaXMucXVlcnlSZXN1bHRDYWNoZSkge1xuICAgICAgdGhpcy5yZW1vdmVRdWVyeVJlc3VsdEZyb21TaXplVHJhY2tpbmcocXVlcnlIYXNoKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnRyeTogUXVlcnlDYWNoZUVudHJ5ID0ge1xuICAgICAgaXRlbUtleXM6IFsuLi5pdGVtS2V5c10gLy8gQ3JlYXRlIGEgY29weSB0byBhdm9pZCBleHRlcm5hbCBtdXRhdGlvbnNcbiAgICB9O1xuXG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF0gPSBlbnRyeTtcbiAgICB0aGlzLmFkZFF1ZXJ5UmVzdWx0VG9TaXplVHJhY2tpbmcocXVlcnlIYXNoLCBlbnRyeSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG5cbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsuLi5lbnRyeS5pdGVtS2V5c107IC8vIFJldHVybiBhIGNvcHkgdG8gYXZvaWQgZXh0ZXJuYWwgbXV0YXRpb25zXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIHJldHVybiAhIWVudHJ5O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHF1ZXJ5SGFzaCBpbiB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlUXVlcnlSZXN1bHRGcm9tU2l6ZVRyYWNraW5nKHF1ZXJ5SGFzaCk7XG4gICAgICBkZWxldGUgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF07XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyUXVlcnlSZXN1bHRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICAgIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZhbGlkYXRlSXRlbUtleXMoa2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlSXRlbUtleXMnLCB7IGtleXMgfSk7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIGtleXMgdG8gaW52YWxpZGF0ZSwgc28gbm8gcXVlcmllcyBzaG91bGQgYmUgYWZmZWN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWxldGUgdGhlIGFjdHVhbCBjYWNoZSBlbnRyaWVzIHdpdGhvdXQgdHJpZ2dlcmluZyBpbmRpdmlkdWFsIHF1ZXJ5IGludmFsaWRhdGlvbnNcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0aGlzLmRlbGV0ZUludGVybmFsKGtleSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIEZvciBidWxrIGludmFsaWRhdGlvbiwgcmVtb3ZlIGVudGlyZSBxdWVyaWVzIChkb24ndCBmaWx0ZXIpXG4gICAgdGhpcy5pbnZhbGlkYXRlUXVlcmllc1JlZmVyZW5jaW5nS2V5cyhrZXlzKTtcbiAgfVxuXG4gIHByaXZhdGUgZmlsdGVyUXVlcmllc1JlZmVyZW5jaW5nS2V5cyhrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiB2b2lkIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGtleXMgdG8gdGhlaXIgaGFzaGVkIGZvcm0gZm9yIGNvbXBhcmlzb25cbiAgICBjb25zdCBoYXNoZWRLZXlzVG9JbnZhbGlkYXRlID0gbmV3IFNldChrZXlzLm1hcChrZXkgPT4gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSkpKTtcblxuICAgIC8vIEZpbHRlciBpbnZhbGlkYXRlZCBrZXlzIGZyb20gcXVlcnkgcmVzdWx0cyBpbnN0ZWFkIG9mIHJlbW92aW5nIGVudGlyZSBxdWVyaWVzXG4gICAgY29uc3QgcXVlcmllc1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgW3F1ZXJ5SGFzaCwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucXVlcnlSZXN1bHRDYWNoZSkpIHtcbiAgICAgIC8vIEZpbHRlciBvdXQgaW52YWxpZGF0ZWQga2V5cyBmcm9tIHRoZSBxdWVyeSByZXN1bHRcbiAgICAgIGNvbnN0IGZpbHRlcmVkS2V5cyA9IGVudHJ5Lml0ZW1LZXlzLmZpbHRlcihpdGVtS2V5ID0+IHtcbiAgICAgICAgY29uc3QgaGFzaGVkSXRlbUtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihpdGVtS2V5KTtcbiAgICAgICAgcmV0dXJuICFoYXNoZWRLZXlzVG9JbnZhbGlkYXRlLmhhcyhoYXNoZWRJdGVtS2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZmlsdGVyZWRLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBubyBrZXlzIHJlbWFpbiBhZnRlciBmaWx0ZXJpbmcsIHJlbW92ZSB0aGUgZW50aXJlIHF1ZXJ5XG4gICAgICAgIHF1ZXJpZXNUb1JlbW92ZS5wdXNoKHF1ZXJ5SGFzaCk7XG4gICAgICB9IGVsc2UgaWYgKGZpbHRlcmVkS2V5cy5sZW5ndGggIT09IGVudHJ5Lml0ZW1LZXlzLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiBzb21lIGtleXMgd2VyZSBmaWx0ZXJlZCBvdXQsIHVwZGF0ZSB0aGUgcXVlcnkgd2l0aCByZW1haW5pbmcga2V5c1xuICAgICAgICB0aGlzLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgZmlsdGVyZWRLZXlzKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGZpbHRlcmVkS2V5cy5sZW5ndGggPT09IGVudHJ5Lml0ZW1LZXlzLmxlbmd0aCwgbm8gY2hhbmdlcyBuZWVkZWRcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgcXVlcmllcyB0aGF0IGhhdmUgbm8gdmFsaWQga2V5cyByZW1haW5pbmdcbiAgICBxdWVyaWVzVG9SZW1vdmUuZm9yRWFjaChxdWVyeUhhc2ggPT4ge1xuICAgICAgdGhpcy5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnZhbGlkYXRlUXVlcmllc1JlZmVyZW5jaW5nS2V5cyhrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiB2b2lkIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGtleXMgdG8gdGhlaXIgaGFzaGVkIGZvcm0gZm9yIGNvbXBhcmlzb25cbiAgICBjb25zdCBoYXNoZWRLZXlzVG9JbnZhbGlkYXRlID0gbmV3IFNldChrZXlzLm1hcChrZXkgPT4gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSkpKTtcblxuICAgIC8vIENsZWFyIHF1ZXJ5IHJlc3VsdHMgdGhhdCByZWZlcmVuY2UgYW55IG9mIHRoZSBpbnZhbGlkYXRlZCBrZXlzXG4gICAgY29uc3QgcXVlcmllc1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgW3F1ZXJ5SGFzaCwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucXVlcnlSZXN1bHRDYWNoZSkpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5UmVmZXJlbmNlc0ludmFsaWRhdGVkS2V5ID0gZW50cnkuaXRlbUtleXMuc29tZShpdGVtS2V5ID0+IHtcbiAgICAgICAgY29uc3QgaGFzaGVkSXRlbUtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihpdGVtS2V5KTtcbiAgICAgICAgcmV0dXJuIGhhc2hlZEtleXNUb0ludmFsaWRhdGUuaGFzKGhhc2hlZEl0ZW1LZXkpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChxdWVyeVJlZmVyZW5jZXNJbnZhbGlkYXRlZEtleSkge1xuICAgICAgICBxdWVyaWVzVG9SZW1vdmUucHVzaChxdWVyeUhhc2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgYWZmZWN0ZWQgcXVlcmllc1xuICAgIHF1ZXJpZXNUb1JlbW92ZS5mb3JFYWNoKHF1ZXJ5SGFzaCA9PiB7XG4gICAgICB0aGlzLmRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlTG9jYXRpb24nLCB7IGxvY2F0aW9ucyB9KTtcblxuICAgIGxldCBrZXlzVG9JbnZhbGlkYXRlOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10gPSBbXTtcblxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGb3IgcHJpbWFyeSBpdGVtcyAobm8gbG9jYXRpb24pLCBjbGVhciBhbGwgcHJpbWFyeSBrZXlzXG4gICAgICBjb25zdCBhbGxLZXlzID0gYXdhaXQgdGhpcy5rZXlzKCk7XG4gICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKGtleSA9PiAhaXNDb21LZXkoa2V5KSk7XG4gICAgICBrZXlzVG9JbnZhbGlkYXRlID0gcHJpbWFyeUtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBjb250YWluZWQgaXRlbXMsIGdldCBhbGwgaXRlbXMgaW4gdGhlIGxvY2F0aW9uIGFuZCBpbnZhbGlkYXRlIHRoZW1cbiAgICAgIGNvbnN0IGl0ZW1zSW5Mb2NhdGlvbiA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICAgIGtleXNUb0ludmFsaWRhdGUgPSBpdGVtc0luTG9jYXRpb24ubWFwKGl0ZW0gPT4gaXRlbS5rZXkpO1xuICAgIH1cblxuICAgIC8vIFVzZSBpbnZhbGlkYXRlSXRlbUtleXMgd2hpY2ggd2lsbCBzZWxlY3RpdmVseSBjbGVhciBvbmx5IGFmZmVjdGVkIHF1ZXJpZXNcbiAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgcXVlcnkgcmVzdWx0IHRvIHNpemUgdHJhY2tpbmdcbiAgICovXG4gIHByaXZhdGUgYWRkUXVlcnlSZXN1bHRUb1NpemVUcmFja2luZyhxdWVyeUhhc2g6IHN0cmluZywgZW50cnk6IFF1ZXJ5Q2FjaGVFbnRyeSk6IHZvaWQge1xuICAgIC8vIEVzdGltYXRlIHNpemU6IHF1ZXJ5SGFzaCArIGl0ZW1LZXlzIGFycmF5XG4gICAgY29uc3QgaGFzaFNpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZShxdWVyeUhhc2gpO1xuICAgIGNvbnN0IGl0ZW1LZXlzU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKGVudHJ5Lml0ZW1LZXlzKTtcbiAgICBjb25zdCB0b3RhbFNpemUgPSBoYXNoU2l6ZSArIGl0ZW1LZXlzU2l6ZTtcblxuICAgIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplICs9IHRvdGFsU2l6ZTtcbiAgICBsb2dnZXIudHJhY2UoJ0FkZGVkIHF1ZXJ5IHJlc3VsdCB0byBzaXplIHRyYWNraW5nJywge1xuICAgICAgcXVlcnlIYXNoLFxuICAgICAgZXN0aW1hdGVkU2l6ZTogdG90YWxTaXplLFxuICAgICAgdG90YWxRdWVyeUNhY2hlU2l6ZTogdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgcXVlcnkgcmVzdWx0IGZyb20gc2l6ZSB0cmFja2luZ1xuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVRdWVyeVJlc3VsdEZyb21TaXplVHJhY2tpbmcocXVlcnlIYXNoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgY29uc3QgaGFzaFNpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZShxdWVyeUhhc2gpO1xuICAgICAgY29uc3QgaXRlbUtleXNTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUoZW50cnkuaXRlbUtleXMpO1xuICAgICAgY29uc3QgdG90YWxTaXplID0gaGFzaFNpemUgKyBpdGVtS2V5c1NpemU7XG5cbiAgICAgIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplID0gTWF0aC5tYXgoMCwgdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemUgLSB0b3RhbFNpemUpO1xuICAgICAgbG9nZ2VyLnRyYWNlKCdSZW1vdmVkIHF1ZXJ5IHJlc3VsdCBmcm9tIHNpemUgdHJhY2tpbmcnLCB7XG4gICAgICAgIHF1ZXJ5SGFzaCxcbiAgICAgICAgZXN0aW1hdGVkU2l6ZTogdG90YWxTaXplLFxuICAgICAgICB0b3RhbFF1ZXJ5Q2FjaGVTaXplOiB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0b3RhbCBjYWNoZSBzaXplIGluY2x1ZGluZyBxdWVyeSByZXN1bHRzXG4gICAqL1xuICBwdWJsaWMgZ2V0VG90YWxTaXplQnl0ZXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U2l6ZUJ5dGVzICsgdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemU7XG4gIH1cblxuICAvLyBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgcHVibGljIGFzeW5jIGdldE1ldGFkYXRhKGtleTogc3RyaW5nKTogUHJvbWlzZTxDYWNoZUl0ZW1NZXRhZGF0YSB8IG51bGw+IHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2tleV07XG4gICAgaWYgKGVudHJ5ICYmICFlbnRyeS5tZXRhZGF0YUNsZWFyZWQpIHtcbiAgICAgIHJldHVybiBlbnRyeS5tZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcsIG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBba2V5XTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5Lm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICBlbnRyeS5tZXRhZGF0YUNsZWFyZWQgPSBmYWxzZTsgLy8gVW5jbGVhciBtZXRhZGF0YSB3aGVuIHNldHRpbmcgbmV3IG1ldGFkYXRhXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHN5bnRoZXRpYyBlbnRyeSBmb3IgbWV0YWRhdGEtb25seSBzdG9yYWdlXG4gICAgICAvLyBUaGlzIGFsbG93cyBzZXR0aW5nIG1ldGFkYXRhIGZvciBrZXlzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gdGhlIGNhY2hlIHlldFxuICAgICAgbGV0IG9yaWdpbmFsS2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIEpTT04gKGZvciByZWFsIGNhY2hlIGtleXMpXG4gICAgICAgIG9yaWdpbmFsS2V5ID0gSlNPTi5wYXJzZShrZXkpIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIElmIG5vdCBKU09OLCBjcmVhdGUgYSBzeW50aGV0aWMgcHJpbWFyeSBrZXlcbiAgICAgICAgb3JpZ2luYWxLZXkgPSB7IGt0OiAnbWV0YWRhdGEtb25seScgYXMgUywgcGs6IGtleSB9IGFzIFByaUtleTxTPjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXBba2V5XSA9IHtcbiAgICAgICAgb3JpZ2luYWxLZXksXG4gICAgICAgIHZhbHVlOiBudWxsIGFzIGFueSwgLy8gUGxhY2Vob2xkZXIgdmFsdWVcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIG1ldGFkYXRhQ2xlYXJlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZU1ldGFkYXRhKF9rZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIE1ldGFkYXRhIGlzIGRlbGV0ZWQgd2hlbiB0aGUgaXRlbSBpcyBkZWxldGVkXG4gICAgLy8gVGhpcyBpcyBhIG5vLW9wIHNpbmNlIG1ldGFkYXRhIGlzIHBhcnQgb2YgdGhlIGl0ZW0gZW50cnlcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRBbGxNZXRhZGF0YSgpOiBQcm9taXNlPE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPj4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPigpO1xuICAgIGZvciAoY29uc3QgW2hhc2hlZEtleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubWFwKSkge1xuICAgICAgLy8gT25seSBpbmNsdWRlIG1ldGFkYXRhIGlmIGl0IGhhc24ndCBiZWVuIGNsZWFyZWRcbiAgICAgIGlmICghZW50cnkubWV0YWRhdGFDbGVhcmVkKSB7XG4gICAgICAgIG1ldGFkYXRhLnNldChoYXNoZWRLZXksIGVudHJ5Lm1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyTWV0YWRhdGEoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gTWFyayBhbGwgZW50cmllcyBhcyBoYXZpbmcgY2xlYXJlZCBtZXRhZGF0YVxuICAgIGNvbnN0IGtleXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2hhc2hlZEtleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubWFwKSkge1xuICAgICAgaWYgKGVudHJ5LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtZXRhZGF0YS1vbmx5IGVudHJ5LCByZW1vdmUgaXQgY29tcGxldGVseVxuICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChoYXNoZWRLZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlYWwgY2FjaGUgZW50cnksIG1hcmsgbWV0YWRhdGEgYXMgY2xlYXJlZFxuICAgICAgICBlbnRyeS5tZXRhZGF0YUNsZWFyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBtZXRhZGF0YS1vbmx5IGVudHJpZXNcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRDdXJyZW50U2l6ZSgpOiBQcm9taXNlPHsgaXRlbUNvdW50OiBudW1iZXI7IHNpemVCeXRlczogbnVtYmVyIH0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUNvdW50OiB0aGlzLmN1cnJlbnRJdGVtQ291bnQsXG4gICAgICBzaXplQnl0ZXM6IHRoaXMuY3VycmVudFNpemVCeXRlc1xuICAgIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0U2l6ZUxpbWl0cygpOiBQcm9taXNlPHsgbWF4SXRlbXM6IG51bWJlciB8IG51bGw7IG1heFNpemVCeXRlczogbnVtYmVyIHwgbnVsbCB9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEl0ZW1zOiB0aGlzLm1heEl0ZW1zID8/IG51bGwsXG4gICAgICBtYXhTaXplQnl0ZXM6IHRoaXMubWF4U2l6ZUJ5dGVzID8/IG51bGxcbiAgICB9O1xuICB9XG5cbn1cbiIsImltcG9ydCB7XG4gIEFsbEl0ZW1UeXBlQXJyYXlzLFxuICBDb21LZXksXG4gIGlzQ29tS2V5LFxuICBpc1F1ZXJ5TWF0Y2gsXG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlTWFwIH0gZnJvbSBcIi4uL0NhY2hlTWFwXCI7XG5pbXBvcnQgeyBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uLCBpc0xvY0tleUFycmF5RXF1YWwgfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuaW1wb3J0IHsgQ2FjaGVJdGVtTWV0YWRhdGEgfSBmcm9tIFwiLi4vZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJMb2NhbFN0b3JhZ2VDYWNoZU1hcFwiKTtcblxuLyoqXG4gKiBMb2NhbFN0b3JhZ2UgaW1wbGVtZW50YXRpb24gb2YgQ2FjaGVNYXAgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICogRGF0YSBwZXJzaXN0cyBhY3Jvc3MgYnJvd3NlciBzZXNzaW9ucyBhbmQgcGFnZSByZWxvYWRzLlxuICpcbiAqIE5vdGU6IExvY2FsU3RvcmFnZSBoYXMgYSB+NS0xME1CIGxpbWl0IGFuZCBzdG9yZXMgc3RyaW5ncyBvbmx5LlxuICogRGF0YSBpcyBzeW5jaHJvbm91cyBhbmQgc3Vydml2ZXMgYnJvd3NlciByZXN0YXJ0cy5cbiAqIFdpbGwgdGhyb3cgZXJyb3JzIGlmIHN0b3JhZ2UgcXVvdGEgaXMgZXhjZWVkZWQsIHRob3VnaCBpdCBhdHRlbXB0c1xuICogdG8gY2xlYW4gdXAgb2xkIGVudHJpZXMgZmlyc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2NhbFN0b3JhZ2VDYWNoZU1hcDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiBleHRlbmRzIENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuXG4gIHB1YmxpYyByZWFkb25seSBpbXBsZW1lbnRhdGlvblR5cGUgPSBcImJyb3dzZXIvbG9jYWxTdG9yYWdlXCI7XG5cbiAgcHJpdmF0ZSBrZXlQcmVmaXg6IHN0cmluZztcbiAgcHJpdmF0ZSBub3JtYWxpemVkSGFzaEZ1bmN0aW9uOiAoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPikgPT4gc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9SRVRSWV9BVFRFTVBUUyA9IDM7XG4gIHByaXZhdGUgcmVhZG9ubHkgQUdHUkVTU0lWRV9DTEVBTlVQX1BFUkNFTlRBR0UgPSAwLjU7IC8vIFJlbW92ZSA1MCUgb2YgZW50cmllcyB3aGVuIHF1b3RhIGV4Y2VlZGVkXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICB0eXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBrZXlQcmVmaXg6IHN0cmluZyA9ICdmamVsbC1jYWNoZSdcbiAgKSB7XG4gICAgc3VwZXIodHlwZXMpO1xuICAgIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb248Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4+KCk7XG4gIH1cblxuICBwcml2YXRlIGdldFN0b3JhZ2VLZXkoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IHN0cmluZyB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgcmV0dXJuIGAke3RoaXMua2V5UHJlZml4fToke2hhc2hlZEtleX1gO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1F1b3RhRXhjZWVkZWRFcnJvcihlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVycm9yICYmIChcbiAgICAgIGVycm9yLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InIHx8XG4gICAgICBlcnJvci5uYW1lID09PSAnTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRUQnIHx8XG4gICAgICBlcnJvci5jb2RlID09PSAyMiB8fFxuICAgICAgZXJyb3IuY29kZSA9PT0gMTAxNFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldEFsbEtleXNTdGFydGluZ1dpdGgocHJlZml4OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcga2V5cyBieSBwcmVmaXggZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IHByZWZpeCwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyeUNsZWFudXBPbGRFbnRyaWVzKGFnZ3Jlc3NpdmU6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhbGxFbnRyaWVzID0gdGhpcy5jb2xsZWN0Q2FjaGVFbnRyaWVzKCk7XG4gICAgICBpZiAoYWxsRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdObyBlbnRyaWVzIHRvIGNsZWFuIHVwJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZU9sZGVzdEVudHJpZXMoYWxsRW50cmllcywgYWdncmVzc2l2ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNsZWFudXAgb2xkIGxvY2FsU3RvcmFnZSBlbnRyaWVzJywgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbGxlY3RDYWNoZUVudHJpZXMoKTogeyBrZXk6IHN0cmluZzsgdGltZXN0YW1wOiBudW1iZXI7IHNpemU6IG51bWJlciB9W10ge1xuICAgIGNvbnN0IGFsbEVudHJpZXM6IHsga2V5OiBzdHJpbmc7IHRpbWVzdGFtcDogbnVtYmVyOyBzaXplOiBudW1iZXIgfVtdID0gW107XG4gICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHJlZ3VsYXIgY2FjaGUgZW50cmllcywgc2tpcCBtZXRhZGF0YSBhbmQgcXVlcnkgcmVzdWx0c1xuICAgICAgaWYgKGtleS5pbmNsdWRlcygnOm1ldGFkYXRhOicpIHx8IGtleS5pbmNsdWRlcygnOnF1ZXJ5OicpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBpZiAocGFyc2VkICYmIHR5cGVvZiBwYXJzZWQgPT09ICdvYmplY3QnICYmICdvcmlnaW5hbEtleScgaW4gcGFyc2VkKSB7XG4gICAgICAgICAgICBhbGxFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogcGFyc2VkLnRpbWVzdGFtcCB8fCBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBzaXplOiBzdG9yZWQubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gb3JpZ2luYWxLZXksIG1hcmsgaXQgZm9yIGRlbGV0aW9uXG4gICAgICAgICAgICBhbGxFbnRyaWVzLnB1c2goeyBrZXksIHRpbWVzdGFtcDogMCwgc2l6ZTogc3RvcmVkLmxlbmd0aCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIGl0LCBtYXJrIGl0IGZvciBkZWxldGlvbiB3aXRoIG9sZGVzdCB0aW1lc3RhbXBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdGb3VuZCBjb3JydXB0ZWQgZW50cnkgZHVyaW5nIGNsZWFudXAnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgIGFsbEVudHJpZXMucHVzaCh7IGtleSwgdGltZXN0YW1wOiAwLCBzaXplOiAwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsRW50cmllcztcbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlT2xkZXN0RW50cmllcyhhbGxFbnRyaWVzOiB7IGtleTogc3RyaW5nOyB0aW1lc3RhbXA6IG51bWJlcjsgc2l6ZTogbnVtYmVyIH1bXSwgYWdncmVzc2l2ZTogYm9vbGVhbiA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgLy8gU29ydCBieSB0aW1lc3RhbXAgKG9sZGVzdCBmaXJzdClcbiAgICBhbGxFbnRyaWVzLnNvcnQoKGEsIGIpID0+IGEudGltZXN0YW1wIC0gYi50aW1lc3RhbXApO1xuXG4gICAgLy8gVXNlIGFnZ3Jlc3NpdmUgY2xlYW51cCBwZXJjZW50YWdlIHdoZW4gcXVvdGEgZXhjZWVkZWQsIG90aGVyd2lzZSB1c2Ugbm9ybWFsIDI1JVxuICAgIGNvbnN0IGNsZWFudXBQZXJjZW50YWdlID0gYWdncmVzc2l2ZSA/IHRoaXMuQUdHUkVTU0lWRV9DTEVBTlVQX1BFUkNFTlRBR0UgOiAwLjI1O1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGFsbEVudHJpZXMubGVuZ3RoICogY2xlYW51cFBlcmNlbnRhZ2UpKTtcbiAgICBsZXQgcmVtb3ZlZENvdW50ID0gMDtcbiAgICBsZXQgcmVtb3ZlZFNpemUgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JlbW92ZSAmJiBpIDwgYWxsRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qga2V5ID0gYWxsRW50cmllc1tpXS5rZXk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJlbW92ZWRDb3VudCsrO1xuICAgICAgICByZW1vdmVkU2l6ZSArPSBhbGxFbnRyaWVzW2ldLnNpemU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgZW50cnkgZHVyaW5nIGNsZWFudXAnLCB7IGtleTogYWxsRW50cmllc1tpXS5rZXksIGVycm9yIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW1vdmVkQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCBjbGVhbnVwVHlwZSA9IGFnZ3Jlc3NpdmUgPyAnYWdncmVzc2l2ZScgOiAnbm9ybWFsJztcbiAgICAgIGxvZ2dlci5pbmZvKGBDbGVhbmVkIHVwICR7cmVtb3ZlZENvdW50fSBvbGQgbG9jYWxTdG9yYWdlIGVudHJpZXMgKCR7cmVtb3ZlZFNpemV9IGJ5dGVzKSB1c2luZyAke2NsZWFudXBUeXBlfSBjbGVhbnVwIHRvIGZyZWUgc3BhY2VgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWRDb3VudCA+IDA7XG4gIH1cblxuICBwcml2YXRlIGdldEFsbFN0b3JhZ2VLZXlzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGxLZXlzU3RhcnRpbmdXaXRoKGAke3RoaXMua2V5UHJlZml4fTpgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8ViB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldCcsIHsga2V5IH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGxldCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIC8vIEZhbGxiYWNrOiBhdHRlbXB0IGxlZ2FjeSBrZXkgd2l0aG91dCBoYXNoaW5nIChmb3IgdGVzdHMgdGhhdCBzZXQgcmF3IGtleSlcbiAgICAgIGlmICghc3RvcmVkICYmIHR5cGVvZiAoa2V5IGFzIGFueSk/Lmt0ID09PSAnc3RyaW5nJyAmJiAoa2V5IGFzIGFueSk/LnBrKSB7XG4gICAgICAgIGNvbnN0IGxlZ2FjeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTokeyhrZXkgYXMgYW55KS5rdH06JHsoa2V5IGFzIGFueSkucGt9YDtcbiAgICAgICAgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obGVnYWN5S2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgLy8gVmVyaWZ5IHRoZSBvcmlnaW5hbCBrZXkgbWF0Y2hlcyAoZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24pXG4gICAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpID09PSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC52YWx1ZSBhcyBWO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRmFpbGVkIHRvIHBhcnNlIHN0b3JlZCB2YWx1ZScsIHsga2V5LCBlcnJvcjogcGFyc2VFcnJvciB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgcmV0cmlldmluZyBmcm9tIGxvY2FsU3RvcmFnZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgdmFsdWU6IFYpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldCcsIHsga2V5LCB2YWx1ZSB9KTtcblxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgdGhpcy5NQVhfUkVUUllfQVRURU1QVFM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgICBjb25zdCB0b1N0b3JlID0ge1xuICAgICAgICAgIG9yaWdpbmFsS2V5OiBrZXksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeSh0b1N0b3JlKSk7XG5cbiAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYFN1Y2Nlc3NmdWxseSBzdG9yZWQgaXRlbSBhZnRlciAke2F0dGVtcHR9IHJldHJpZXNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47IC8vIFN1Y2Nlc3MsIGV4aXQgdGhlIHJldHJ5IGxvb3BcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdEF0dGVtcHQgPSBhdHRlbXB0ID09PSB0aGlzLk1BWF9SRVRSWV9BVFRFTVBUUyAtIDE7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRXJyb3Igc3RvcmluZyB0byBsb2NhbFN0b3JhZ2UgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHt0aGlzLk1BWF9SRVRSWV9BVFRFTVBUU30pYCwge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBpc0xhc3RBdHRlbXB0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUXVvdGFFeGNlZWRlZEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIC8vIFVzZSBpbmNyZWFzaW5nbHkgYWdncmVzc2l2ZSBjbGVhbnVwIG9uIGVhY2ggcmV0cnkgYXR0ZW1wdFxuICAgICAgICAgIGNvbnN0IHVzZUFnZ3Jlc3NpdmVDbGVhbnVwID0gYXR0ZW1wdCA+IDA7XG4gICAgICAgICAgdGhpcy50cnlDbGVhbnVwT2xkRW50cmllcyh1c2VBZ2dyZXNzaXZlQ2xlYW51cCk7XG5cbiAgICAgICAgICBpZiAoaXNMYXN0QXR0ZW1wdCkge1xuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCBmYWlsZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHN0b3JlIGl0ZW0gaW4gbG9jYWxTdG9yYWdlOiBzdG9yYWdlIHF1b3RhIGV4Y2VlZGVkIGV2ZW4gYWZ0ZXIgbXVsdGlwbGUgY2xlYW51cCBhdHRlbXB0cycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnRpbnVlIHRvIG5leHQgcmV0cnkgYXR0ZW1wdCAobm8gZGVsYXkgbmVlZGVkIGZvciBsb2NhbFN0b3JhZ2UpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3Igbm9uLXF1b3RhIGVycm9ycywgdGhyb3cgaW1tZWRpYXRlbHkgd2l0aG91dCByZXRyeVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdG9yZSBpdGVtIGluIGxvY2FsU3RvcmFnZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGluY2x1ZGVzS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24ocGFyc2VkLm9yaWdpbmFsS2V5KSA9PT0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ0ZhaWxlZCB0byBwYXJzZSBzdG9yZWQgdmFsdWUgaW4gaW5jbHVkZXNLZXknLCB7IGtleSwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgY2hlY2tpbmcga2V5IGluIGxvY2FsU3RvcmFnZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2RlbGV0ZScsIHsga2V5IH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGZyb20gbG9jYWxTdG9yYWdlJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGFsbEluKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxWW10+IHtcbiAgICBjb25zdCBhbGxLZXlzID0gdGhpcy5rZXlzKCk7XG5cbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdSZXR1cm5pbmcgYWxsIGl0ZW1zLCBMb2NLZXlzIGlzIGVtcHR5Jyk7XG4gICAgICBjb25zdCBpdGVtczogVltdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhd2FpdCBhbGxLZXlzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG9jS2V5czogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gbG9jYXRpb25zO1xuICAgICAgY29uc3QgcmVzb2x2ZWRLZXlzID0gYXdhaXQgYWxsS2V5cztcbiAgICAgIGxvZ2dlci5kZWJ1ZygnYWxsSW4nLCB7IGxvY0tleXMsIGtleXM6IHJlc29sdmVkS2V5cy5sZW5ndGggfSk7XG5cbiAgICAgIGNvbnN0IGZpbHRlcmVkS2V5cyA9IHJlc29sdmVkS2V5c1xuICAgICAgICAuZmlsdGVyKChrZXkpID0+IGtleSAmJiBpc0NvbUtleShrZXkpKVxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBDb21LZXkgPSBrZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdDb21wYXJpbmcgTG9jYXRpb24gS2V5cycsIHtcbiAgICAgICAgICAgIGxvY0tleXMsXG4gICAgICAgICAgICBDb21LZXksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NLZXlzLCBDb21LZXkubG9jKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGl0ZW1zOiBWW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZpbHRlcmVkS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5OiBJdGVtUXVlcnksIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdjb250YWlucycsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcXVlcnlJbihcbiAgICBxdWVyeTogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+IHtcbiAgICBsb2dnZXIuZGVidWcoJ3F1ZXJ5SW4nLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xvbmUoKTogUHJvbWlzZTxMb2NhbFN0b3JhZ2VDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PiB7XG4gICAgLy8gTG9jYWxTdG9yYWdlIGlzIHNoYXJlZCBnbG9iYWxseSwgc28gY2xvbmUganVzdCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIHdpdGggc2FtZSBwcmVmaXhcbiAgICByZXR1cm4gbmV3IExvY2FsU3RvcmFnZUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4odGhpcy50eXBlcywgdGhpcy5rZXlQcmVmaXgpO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZVN0b3JhZ2VFbnRyeShzdG9yYWdlS2V5OiBzdHJpbmcpOiBhbnkgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgLy8gU2tpcCBjb3JydXB0ZWQgZW50cmllc1xuICAgICAgbG9nZ2VyLmRlYnVnKCdTa2lwcGluZyBjb3JydXB0ZWQgbG9jYWxTdG9yYWdlIGVudHJ5JywgeyBzdG9yYWdlS2V5LCBlcnJvcjogcGFyc2VFcnJvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2V5cygpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXT4ge1xuICAgIGNvbnN0IGtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VTdG9yYWdlRW50cnkoc3RvcmFnZUtleSk7XG4gICAgICAgIGlmIChwYXJzZWQ/Lm9yaWdpbmFsS2V5KSB7XG4gICAgICAgICAga2V5cy5wdXNoKHBhcnNlZC5vcmlnaW5hbEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIGtleXMgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IGVycm9yIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHZhbHVlcygpOiBQcm9taXNlPFZbXT4ge1xuICAgIGNvbnN0IHZhbHVlczogVltdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVN0b3JhZ2VFbnRyeShzdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKHBhcnNlZD8udmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IGVycm9yIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdDbGVhcmluZyBsb2NhbFN0b3JhZ2UgY2FjaGUnKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgY2xlYXJpbmcgbG9jYWxTdG9yYWdlIGNhY2hlJywgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxuICBwdWJsaWMgYXN5bmMgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcsIGl0ZW1LZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG5cbiAgICBjb25zdCBlbnRyeTogYW55ID0ge1xuICAgICAgaXRlbUtleXNcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHF1ZXJ5S2V5LCBKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBxdWVyeSByZXN1bHQgaW4gbG9jYWxTdG9yYWdlJywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8KENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdIHwgbnVsbD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0ocXVlcnlLZXkpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbnRyeSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIG9sZCBmb3JtYXQgKGp1c3QgYXJyYXkpIGFuZCBuZXcgZm9ybWF0XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgLy8gT2xkIGZvcm1hdCAtIHJldHVybiBhcyBpc1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5ldyBmb3JtYXRcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtS2V5cyB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBxdWVyeSByZXN1bHQgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0ocXVlcnlLZXkpICE9PSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayBxdWVyeSByZXN1bHQgaW4gbG9jYWxTdG9yYWdlJywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlUXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShxdWVyeUtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBxdWVyeSByZXN1bHQgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGludmFsaWRhdGVJdGVtS2V5cyhrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2ludmFsaWRhdGVJdGVtS2V5cycsIHsga2V5cyB9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGtleSBkdXJpbmcgaW52YWxpZGF0aW9uJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2ludmFsaWRhdGVMb2NhdGlvbicsIHsgbG9jYXRpb25zIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEZvciBwcmltYXJ5IGl0ZW1zIChubyBsb2NhdGlvbiksIGNsZWFyIGFsbCBwcmltYXJ5IGtleXNcbiAgICAgICAgY29uc3QgYWxsS2V5cyA9IGF3YWl0IHRoaXMua2V5cygpO1xuICAgICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKGtleSA9PiAhaXNDb21LZXkoa2V5KSk7XG4gICAgICAgIGF3YWl0IHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKHByaW1hcnlLZXlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBjb250YWluZWQgaXRlbXMsIGNvbXB1dGUga2V5cyBkaXJlY3RseSBmcm9tIHN0b3JlZCBrZXlzIHRvIGF2b2lkIHZhbHVlLXNoYXBlIGFzc3VtcHRpb25zXG4gICAgICAgIGNvbnN0IGFsbEtleXMgPSBhd2FpdCB0aGlzLmtleXMoKTtcbiAgICAgICAgY29uc3Qga2V5c1RvSW52YWxpZGF0ZSA9IGFsbEtleXNcbiAgICAgICAgICAuZmlsdGVyKChrZXkpID0+IGtleSAmJiBpc0NvbUtleShrZXkpKVxuICAgICAgICAgIC5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlS2V5ID0ga2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NhdGlvbnMgYXMgYW55W10sIGNvbXBvc2l0ZUtleS5sb2MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgYWxsIHF1ZXJ5IHJlc3VsdHMgYWZ0ZXIgaW52YWxpZGF0aW5nIGl0ZW1zXG4gICAgICBhd2FpdCB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gaW52YWxpZGF0ZUxvY2F0aW9uJywgeyBsb2NhdGlvbnMsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhclF1ZXJ5UmVzdWx0cygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2NsZWFyUXVlcnlSZXN1bHRzJyk7XG4gICAgY29uc3QgcXVlcnlQcmVmaXggPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6YDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5c1RvUmVtb3ZlID0gdGhpcy5nZXRBbGxLZXlzU3RhcnRpbmdXaXRoKHF1ZXJ5UHJlZml4KTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb1JlbW92ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIHF1ZXJ5IHJlc3VsdCBmcm9tIGxvY2FsU3RvcmFnZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBxdWVyeSByZXN1bHRzIGZyb20gbG9jYWxTdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgcHVibGljIGFzeW5jIGdldE1ldGFkYXRhKGtleTogc3RyaW5nKTogUHJvbWlzZTxDYWNoZUl0ZW1NZXRhZGF0YSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKG1ldGFkYXRhS2V5KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSW52YWxpZCBKU09OIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFic2VudFxuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnSW52YWxpZCBtZXRhZGF0YSBKU09OLCB0cmVhdGluZyBhcyBudWxsJywgeyBrZXksIGVycm9yOiBlIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIG1ldGFkYXRhIGZyb20gbG9jYWxTdG9yYWdlJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldE1ldGFkYXRhKGtleTogc3RyaW5nLCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHRoaXMuTUFYX1JFVFJZX0FUVEVNUFRTOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1ldGFkYXRhS2V5LCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuXG4gICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBTdWNjZXNzZnVsbHkgc3RvcmVkIG1ldGFkYXRhIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjsgLy8gU3VjY2VzcywgZXhpdCB0aGUgcmV0cnkgbG9vcFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgaXNMYXN0QXR0ZW1wdCA9IGF0dGVtcHQgPT09IHRoaXMuTUFYX1JFVFJZX0FUVEVNUFRTIC0gMTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciBzdG9yaW5nIG1ldGFkYXRhIHRvIGxvY2FsU3RvcmFnZSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke3RoaXMuTUFYX1JFVFJZX0FUVEVNUFRTfSlgLCB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGlzTGFzdEF0dGVtcHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNRdW90YUV4Y2VlZGVkRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgLy8gVXNlIGluY3JlYXNpbmdseSBhZ2dyZXNzaXZlIGNsZWFudXAgb24gZWFjaCByZXRyeSBhdHRlbXB0XG4gICAgICAgICAgY29uc3QgdXNlQWdncmVzc2l2ZUNsZWFudXAgPSBhdHRlbXB0ID4gMDtcbiAgICAgICAgICB0aGlzLnRyeUNsZWFudXBPbGRFbnRyaWVzKHVzZUFnZ3Jlc3NpdmVDbGVhbnVwKTtcblxuICAgICAgICAgIGlmIChpc0xhc3RBdHRlbXB0KSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0IGZhaWxlZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3RvcmUgbWV0YWRhdGEgaW4gbG9jYWxTdG9yYWdlOiBzdG9yYWdlIHF1b3RhIGV4Y2VlZGVkIGV2ZW4gYWZ0ZXIgbXVsdGlwbGUgY2xlYW51cCBhdHRlbXB0cycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnRpbnVlIHRvIG5leHQgcmV0cnkgYXR0ZW1wdFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG5vbi1xdW90YSBlcnJvcnMsIHRocm93IGltbWVkaWF0ZWx5IHdpdGhvdXQgcmV0cnlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RvcmUgbWV0YWRhdGEgaW4gbG9jYWxTdG9yYWdlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlTWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG1ldGFkYXRhS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBkZWxldGluZyBtZXRhZGF0YSBmcm9tIGxvY2FsU3RvcmFnZScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRBbGxNZXRhZGF0YSgpOiBQcm9taXNlPE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPj4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhUHJlZml4ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOmA7XG4gICAgICBjb25zdCBtZXRhS2V5cyA9IHRoaXMuZ2V0QWxsS2V5c1N0YXJ0aW5nV2l0aChtZXRhZGF0YVByZWZpeCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBtZXRhS2V5cykge1xuICAgICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGtleS5zdWJzdHJpbmcobWV0YWRhdGFQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFzdG9yZWQpIGNvbnRpbnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAvLyBBbnkgdmFsaWQgSlNPTiBvYmplY3QgY2FuIGJlIG1ldGFkYXRhXG4gICAgICAgICAgaWYgKHBhcnNlZCAmJiB0eXBlb2YgcGFyc2VkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbWV0YWRhdGEuc2V0KG1ldGFkYXRhS2V5LCBwYXJzZWQgYXMgQ2FjaGVJdGVtTWV0YWRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBTa2lwIGludmFsaWQgbWV0YWRhdGEgZW50cmllc1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnU2tpcHBpbmcgaW52YWxpZCBtZXRhZGF0YSBlbnRyeScsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcgbWV0YWRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyTWV0YWRhdGEoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhUHJlZml4ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOmA7XG4gICAgICBjb25zdCBrZXlzVG9EZWxldGUgPSB0aGlzLmdldEFsbEtleXNTdGFydGluZ1dpdGgobWV0YWRhdGFQcmVmaXgpO1xuICAgICAga2V5c1RvRGVsZXRlLmZvckVhY2goa2V5ID0+IGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIG1ldGFkYXRhIGZyb20gbG9jYWxTdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRDdXJyZW50U2l6ZSgpOiBQcm9taXNlPHsgaXRlbUNvdW50OiBudW1iZXI7IHNpemVCeXRlczogbnVtYmVyIH0+IHtcbiAgICBsZXQgaXRlbUNvdW50ID0gMDtcbiAgICBsZXQgc2l6ZUJ5dGVzID0gMDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghdmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzaXplIGZvciBhbGwgZW50cmllc1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFVzZSBCbG9iIHdoZW4gYXZhaWxhYmxlIChicm93c2VyKSwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBUZXh0RW5jb2Rlci9CdWZmZXIgKG5vZGUgdGVzdCBlbnYpXG4gICAgICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2l6ZUJ5dGVzICs9IG5ldyBCbG9iKFt2YWx1ZV0pLnNpemU7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaXplQnl0ZXMgKz0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGdsb2JhbFRoaXMgYXMgYW55KS5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaXplQnl0ZXMgKz0gKChnbG9iYWxUaGlzIGFzIGFueSkuQnVmZmVyIGFzIGFueSkuYnl0ZUxlbmd0aCh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXMgYSBsYXN0IHJlc29ydCwgYXBwcm94aW1hdGUgYnkgc3RyaW5nIGxlbmd0aFxuICAgICAgICAgICAgc2l6ZUJ5dGVzICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbmx5IGNvdW50IHJlZ3VsYXIgY2FjaGUgZW50cmllcyBmb3IgaXRlbSBjb3VudFxuICAgICAgICAgIGlmICgha2V5LmluY2x1ZGVzKCc6bWV0YWRhdGE6JykgJiYgIWtleS5pbmNsdWRlcygnOnF1ZXJ5OicpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgLy8gT25seSBjb3VudCBlbnRyaWVzIHRoYXQgaGF2ZSBib3RoIG9yaWdpbmFsS2V5IGFuZCB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gJ29iamVjdCcgJiYgJ29yaWdpbmFsS2V5JyBpbiBwYXJzZWQgJiYgJ3ZhbHVlJyBpbiBwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gU2tpcCBpbnZhbGlkIGVudHJpZXMgZm9yIGl0ZW0gY291bnRcbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdJbnZhbGlkIGVudHJ5IGluIGdldEN1cnJlbnRTaXplJywgeyBrZXksIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBzaXplIGNhbGN1bGF0aW9uIGZhaWxzLCB1c2Ugc3RyaW5nIGxlbmd0aCBhcyBmYWxsYmFja1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnU2l6ZSBjYWxjdWxhdGlvbiBmYWlsZWQsIHVzaW5nIHN0cmluZyBsZW5ndGgnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgICAgc2l6ZUJ5dGVzICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGNhbGN1bGF0aW5nIHNpemUgZnJvbSBsb2NhbFN0b3JhZ2UnLCB7IGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaXRlbUNvdW50LCBzaXplQnl0ZXMgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRTaXplTGltaXRzKCk6IFByb21pc2U8eyBtYXhJdGVtczogbnVtYmVyIHwgbnVsbDsgbWF4U2l6ZUJ5dGVzOiBudW1iZXIgfCBudWxsIH0+IHtcbiAgICAvLyBMb2NhbFN0b3JhZ2UgdHlwaWNhbGx5IGhhcyBhIDUtMTBNQiBsaW1pdCwgYnV0IHdlIGNhbid0IGRldGVybWluZSB0aGUgZXhhY3QgbGltaXRcbiAgICAvLyBSZXR1cm4gY29uc2VydmF0aXZlIGVzdGltYXRlc1xuICAgIHJldHVybiB7XG4gICAgICBtYXhJdGVtczogbnVsbCwgLy8gTm8gc3BlY2lmaWMgaXRlbSBsaW1pdFxuICAgICAgbWF4U2l6ZUJ5dGVzOiA1ICogMTAyNCAqIDEwMjQgLy8gNU1CIGNvbnNlcnZhdGl2ZSBlc3RpbWF0ZVxuICAgIH07XG4gIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgQWxsSXRlbVR5cGVBcnJheXMsXG4gIENvbUtleSxcbiAgaXNDb21LZXksXG4gIGlzUXVlcnlNYXRjaCxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tIFwiLi4vQ2FjaGVNYXBcIjtcbmltcG9ydCBzYWZlU3RyaW5naWZ5IGZyb20gJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknO1xuaW1wb3J0IHsgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiwgaXNMb2NLZXlBcnJheUVxdWFsIH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhIH0gZnJvbSBcIi4uL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcFwiKTtcblxuLyoqXG4gKiBTZXNzaW9uU3RvcmFnZSBpbXBsZW1lbnRhdGlvbiBvZiBDYWNoZU1hcCBmb3IgYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gKiBEYXRhIHBlcnNpc3RzIG9ubHkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIgdGFiL3Nlc3Npb24uXG4gKlxuICogTm90ZTogU2Vzc2lvblN0b3JhZ2UgaGFzIGEgfjVNQiBsaW1pdCBhbmQgc3RvcmVzIHN0cmluZ3Mgb25seS5cbiAqIERhdGEgaXMgc3luY2hyb25vdXMgYnV0IGlzIGxvc3Qgd2hlbiB0aGUgdGFiIGlzIGNsb3NlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlc3Npb25TdG9yYWdlQ2FjaGVNYXA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcblxuICBwdWJsaWMgcmVhZG9ubHkgaW1wbGVtZW50YXRpb25UeXBlID0gXCJicm93c2VyL3Nlc3Npb25TdG9yYWdlXCI7XG5cbiAgcHJpdmF0ZSBrZXlQcmVmaXg6IHN0cmluZztcbiAgcHJpdmF0ZSBub3JtYWxpemVkSGFzaEZ1bmN0aW9uOiAoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPikgPT4gc3RyaW5nO1xuICAvLyBVc2UgYSBzZXBhcmF0ZSwgcHJpdmF0ZSB2ZXJpZmllciB0aGF0IGlzIG5vdCByZWZlcmVuY2VkIGJ5IHRlc3RzIHRvIGd1YXJkIGFnYWluc3QgdGFtcGVyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgdmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uOiAoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPikgPT4gc3RyaW5nO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICB0eXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBrZXlQcmVmaXg6IHN0cmluZyA9ICdmamVsbC1zZXNzaW9uLWNhY2hlJ1xuICApIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbjxDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPj4oKTtcbiAgICB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb248Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4+KCk7XG4gIH1cblxuICBwcml2YXRlIGdldFN0b3JhZ2VLZXkoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IHN0cmluZyB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgcmV0dXJuIGAke3RoaXMua2V5UHJlZml4fToke2hhc2hlZEtleX1gO1xuICB9XG5cbiAgLy8gVXNpbmcgZmxhdHRlZCBmb3Igc2FmZSBjaXJjdWxhciBzZXJpYWxpemF0aW9uOyBubyBtYW51YWwgcmVwbGFjZXIgbmVlZGVkXG5cbiAgcHJpdmF0ZSBnZXRBbGxTdG9yYWdlS2V5cygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb25TdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlc3Npb25TdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChgJHt0aGlzLmtleVByZWZpeH06YCkpIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcga2V5cyBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIC8vIERldGVjdCBpZiBjdXJyZW50IG5vcm1hbGl6ZWQgaGFzaCBmdW5jdGlvbiBjb2xsYXBzZXMgbXVsdGlwbGUgc3RvcmVkIGl0ZW1zIGludG8gdGhlIHNhbWUgaGFzaFxuICBwcml2YXRlIGhhc0NvbGxpc2lvbkZvckhhc2godGFyZ2V0SGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06JHt0YXJnZXRIYXNofWA7XG4gICAgICBjb25zdCByYXcgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKCFyYXcpIHJldHVybiBmYWxzZTtcblxuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyYXcpO1xuICAgICAgaWYgKCFwYXJzZWQ/Lm9yaWdpbmFsS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIElmIHZlcmlmaWNhdGlvbiBoYXNoIG1hdGNoZXMsIHRoaXMgaXMgdGhlIGNvcnJlY3QgaXRlbSAobm8gY29sbGlzaW9uKVxuICAgICAgY29uc3Qgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9IHBhcnNlZC5vcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2g7XG4gICAgICBjb25zdCBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaCA9IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSk7XG4gICAgICBpZiAoc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB2ZXJpZmljYXRpb24gaGFzaCBkb2Vzbid0IG1hdGNoLCB3ZSBoYXZlIGEgY29sbGlzaW9uXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPFYgfCBudWxsPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdnZXQnLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudEhhc2ggPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgIGlmICh0aGlzLmhhc0NvbGxpc2lvbkZvckhhc2goY3VycmVudEhhc2gpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAvLyBWZXJpZnkga2V5IHVzaW5nIGJvdGggYSBzdGFibGUgdmVyaWZpY2F0aW9uIGhhc2ggYW5kIHRoZSBwYXJzZWQgb3JpZ2luYWxLZXkgZXF1YWxpdHlcbiAgICAgICAgY29uc3Qgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaDogc3RyaW5nIHwgdW5kZWZpbmVkID0gcGFyc2VkLm9yaWdpbmFsVmVyaWZpY2F0aW9uSGFzaDtcbiAgICAgICAgY29uc3QgY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgICBjb25zdCBpc1NhbWVPcmlnaW5hbEtleSA9IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSkgPT09IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoO1xuICAgICAgICBpZiAoc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCAmJiBzdG9yZWRWZXJpZmljYXRpb25IYXNoID09PSBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaCAmJiBpc1NhbWVPcmlnaW5hbEtleSkge1xuICAgICAgICAgIGlmIChwYXJzZWQudmFsdWUgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZC52YWx1ZSBhcyBWO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGZyb20gc2Vzc2lvblN0b3JhZ2UnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIHZhbHVlOiBWKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGxvZ2dlci50cmFjZSgnc2V0JywgeyBzdG9yYWdlS2V5IH0pO1xuICAgICAgY29uc3QgdG9TdG9yZSA9IHtcbiAgICAgICAgb3JpZ2luYWxLZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIG9yaWdpbmFsVmVyaWZpY2F0aW9uSGFzaDogdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24oa2V5KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBzYWZlU3RyaW5naWZ5KHRvU3RvcmUpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBqc29uU3RyaW5nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBzdG9yaW5nIHRvIHNlc3Npb25TdG9yYWdlJywgeyBlcnJvck1lc3NhZ2U6IChlcnJvciBhcyBFcnJvcik/Lm1lc3NhZ2UgfSk7XG4gICAgICAvLyBIYW5kbGUgcXVvdGEgZXhjZWVkZWQgb3Igb3RoZXIgc2Vzc2lvblN0b3JhZ2UgZXJyb3JzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdG9yZSBpdGVtIGluIHNlc3Npb25TdG9yYWdlOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbmNsdWRlc0tleShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRIYXNoID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICBpZiAodGhpcy5oYXNDb2xsaXNpb25Gb3JIYXNoKGN1cnJlbnRIYXNoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFZlcmlmaWNhdGlvbkhhc2g6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBhcnNlZC5vcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2g7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoID0gdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3QgaXNTYW1lT3JpZ2luYWxLZXkgPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpID09PSBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaDtcbiAgICAgICAgcmV0dXJuICEhc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCAmJiBzdG9yZWRWZXJpZmljYXRpb25IYXNoID09PSBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaCAmJiBpc1NhbWVPcmlnaW5hbEtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBjaGVja2luZyBrZXkgaW4gc2Vzc2lvblN0b3JhZ2UnLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdkZWxldGUnLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBkZWxldGluZyBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBrZXksIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhbGxJbihsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8VltdPiB7XG4gICAgY29uc3QgYWxsS2V5cyA9IHRoaXMua2V5cygpO1xuXG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUmV0dXJuaW5nIGFsbCBpdGVtcywgTG9jS2V5cyBpcyBlbXB0eScpO1xuICAgICAgY29uc3QgaXRlbXM6IFZbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYXdhaXQgYWxsS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvY0tleXM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IGxvY2F0aW9ucztcbiAgICAgIGNvbnN0IHJlc29sdmVkS2V5cyA9IGF3YWl0IGFsbEtleXM7XG4gICAgICBsb2dnZXIuZGVidWcoJ2FsbEluJywgeyBsb2NLZXlzLCBrZXlzOiByZXNvbHZlZEtleXMubGVuZ3RoIH0pO1xuICAgICAgY29uc3QgZmlsdGVyZWRLZXlzID0gcmVzb2x2ZWRLZXlzXG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4ga2V5ICYmIGlzQ29tS2V5KGtleSkpXG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IENvbUtleSA9IGtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ0NvbXBhcmluZyBMb2NhdGlvbiBLZXlzJywge1xuICAgICAgICAgICAgbG9jS2V5cyxcbiAgICAgICAgICAgIENvbUtleSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaXNMb2NLZXlBcnJheUVxdWFsKGxvY0tleXMsIENvbUtleS5sb2MpO1xuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgaXRlbXM6IFZbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgZmlsdGVyZWRLZXlzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY29udGFpbnMocXVlcnk6IEl0ZW1RdWVyeSwgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2NvbnRhaW5zJywgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5zb21lKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2goaXRlbSwgcXVlcnkpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBxdWVyeUluKFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFZbXT4ge1xuICAgIGxvZ2dlci5kZWJ1ZygncXVlcnlJbicsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2goaXRlbSwgcXVlcnkpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbG9uZSgpOiBQcm9taXNlPFNlc3Npb25TdG9yYWdlQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4ge1xuICAgIC8vIFNlc3Npb25TdG9yYWdlIGlzIHNoYXJlZCBnbG9iYWxseSBmb3IgdGhlIHRhYiwgc28gY2xvbmUganVzdCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIHdpdGggc2FtZSBwcmVmaXhcbiAgICByZXR1cm4gbmV3IFNlc3Npb25TdG9yYWdlQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pih0aGlzLnR5cGVzLCB0aGlzLmtleVByZWZpeCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2V5cygpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXT4ge1xuICAgIGNvbnN0IGtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBzdG9yYWdlS2V5IG9mIHN0b3JhZ2VLZXlzKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgIGlmICghc3RvcmVkKSBjb250aW51ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBpZiAocGFyc2VkLm9yaWdpbmFsS2V5KSB7XG4gICAgICAgICAgICBrZXlzLnB1c2gocGFyc2VkLm9yaWdpbmFsS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGl0ZW1FcnJvcikge1xuICAgICAgICAgIC8vIFNraXAgaXRlbXMgdGhhdCBjYW4ndCBiZSBwYXJzZWQgb3IgYXJlIGludmFsaWRcbiAgICAgICAgICBsb2dnZXIudHJhY2UoJ1NraXBwaW5nIGludmFsaWQgc3RvcmFnZSBpdGVtJywgeyBzdG9yYWdlS2V5LCBlcnJvcjogaXRlbUVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyBrZXlzIGZyb20gc2Vzc2lvblN0b3JhZ2UnLCB7IGVycm9yIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHZhbHVlcygpOiBQcm9taXNlPFZbXT4ge1xuICAgIGNvbnN0IHZhbHVlczogVltdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKCFzdG9yZWQpIGNvbnRpbnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgIGlmIChwYXJzZWQudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGl0ZW1FcnJvcikge1xuICAgICAgICAgIC8vIFNraXAgaXRlbXMgdGhhdCBjYW4ndCBiZSBwYXJzZWQgb3IgYXJlIGludmFsaWRcbiAgICAgICAgICBsb2dnZXIudHJhY2UoJ1NraXBwaW5nIGludmFsaWQgc3RvcmFnZSBpdGVtIGZvciB2YWx1ZXMnLCB7IHN0b3JhZ2VLZXksIGVycm9yOiBpdGVtRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnQ2xlYXJpbmcgc2Vzc2lvblN0b3JhZ2UgY2FjaGUnKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBjbGVhcmluZyBzZXNzaW9uU3RvcmFnZSBjYWNoZScsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG4gIHB1YmxpYyBhc3luYyBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZywgaXRlbUtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnc2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleXMgfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcblxuICAgIGNvbnN0IGVudHJ5OiBhbnkgPSB7XG4gICAgICBpdGVtS2V5c1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QganNvblN0cmluZyA9IHNhZmVTdHJpbmdpZnkoZW50cnkpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShxdWVyeUtleSwganNvblN0cmluZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHN0b3JlIHF1ZXJ5IHJlc3VsdCBpbiBzZXNzaW9uU3RvcmFnZScsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSB8IG51bGw+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldFF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0ocXVlcnlLZXkpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbnRyeSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIG9sZCBmb3JtYXQgKGp1c3QgYXJyYXkpIGFuZCBuZXcgZm9ybWF0XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgLy8gT2xkIGZvcm1hdCAtIHJldHVybiBhcyBpc1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5ldyBmb3JtYXRcblxuICAgICAgcmV0dXJuIGVudHJ5Lml0ZW1LZXlzIHx8IG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHJldHJpZXZlIHF1ZXJ5IHJlc3VsdCBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0ocXVlcnlLZXkpICE9PSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayBxdWVyeSByZXN1bHQgaW4gc2Vzc2lvblN0b3JhZ2UnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdkZWxldGVRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0ocXVlcnlLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgcXVlcnkgcmVzdWx0IGZyb20gc2Vzc2lvblN0b3JhZ2UnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGludmFsaWRhdGVJdGVtS2V5cyhrZXlzOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2ludmFsaWRhdGVJdGVtS2V5cycsIHsga2V5cyB9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuZGVidWcoJ2ludmFsaWRhdGVMb2NhdGlvbicsIHsgbG9jYXRpb25zIH0pO1xuXG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEZvciBwcmltYXJ5IGl0ZW1zIChubyBsb2NhdGlvbiksIGNsZWFyIGFsbCBwcmltYXJ5IGtleXNcbiAgICAgIGNvbnN0IGFsbEtleXMgPSBhd2FpdCB0aGlzLmtleXMoKTtcbiAgICAgIGNvbnN0IHByaW1hcnlLZXlzID0gYWxsS2V5cy5maWx0ZXIoa2V5ID0+ICFpc0NvbUtleShrZXkpKTtcbiAgICAgIGF3YWl0IHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKHByaW1hcnlLZXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGNvbnRhaW5lZCBpdGVtcywgZ2V0IGFsbCBpdGVtcyBpbiB0aGUgbG9jYXRpb24gYW5kIGludmFsaWRhdGUgdGhlbVxuICAgICAgY29uc3QgaXRlbXNJbkxvY2F0aW9uID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgICAgY29uc3Qga2V5c1RvSW52YWxpZGF0ZSA9IGl0ZW1zSW5Mb2NhdGlvbi5tYXAoaXRlbSA9PiBpdGVtLmtleSk7XG4gICAgICBhd2FpdCB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBhbGwgcXVlcnkgcmVzdWx0cyB0aGF0IG1pZ2h0IGJlIGFmZmVjdGVkXG4gICAgYXdhaXQgdGhpcy5jbGVhclF1ZXJ5UmVzdWx0cygpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyUXVlcnlSZXN1bHRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnY2xlYXJRdWVyeVJlc3VsdHMnKTtcbiAgICBjb25zdCBxdWVyeVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeTpgO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzVG9SZW1vdmU6IHN0cmluZ1tdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb25TdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlc3Npb25TdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChxdWVyeVByZWZpeCkpIHtcbiAgICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXlzVG9SZW1vdmUuZm9yRWFjaChrZXkgPT4gc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY2xlYXIgcXVlcnkgcmVzdWx0cyBmcm9tIHNlc3Npb25TdG9yYWdlJywgeyBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgcHVibGljIGFzeW5jIGdldE1ldGFkYXRhKGtleTogc3RyaW5nKTogUHJvbWlzZTxDYWNoZUl0ZW1NZXRhZGF0YSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0obWV0YWRhdGFLZXkpO1xuICAgICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcsIG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YToke2tleX1gO1xuICAgICAgY29uc3QganNvblN0cmluZyA9IHNhZmVTdHJpbmdpZnkobWV0YWRhdGEpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtZXRhZGF0YUtleSwganNvblN0cmluZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBJZ25vcmUgcXVvdGEgZXhjZWVkZWQgZXJyb3JzIC0gc2Vzc2lvbiBzdG9yYWdlIGlzIGVwaGVtZXJhbFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YToke2tleX1gO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShtZXRhZGF0YUtleSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBJZ25vcmUgZXJyb3JzIHdoZW4gZGVsZXRpbmdcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWxsTWV0YWRhdGEoKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4oKTtcbiAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuXG4gICAgLy8gRmlyc3QgdHJ5IHN0YW5kYXJkIGl0ZXJhdGlvbiBBUElcbiAgICB0cnkge1xuICAgICAgbGV0IGZvdW5kQW55ID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb25TdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlc3Npb25TdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKCFrZXkgfHwgIWtleS5zdGFydHNXaXRoKG1ldGFkYXRhUHJlZml4KSkgY29udGludWU7XG4gICAgICAgIGZvdW5kQW55ID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGtleS5zdWJzdHJpbmcobWV0YWRhdGFQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXN0b3JlZCkgY29udGludWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXRhZGF0YS5zZXQobWV0YWRhdGFLZXksIEpTT04ucGFyc2Uoc3RvcmVkKSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIFNraXAgaW52YWxpZCBtZXRhZGF0YSBlbnRyaWVzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcgYWxsIG1ldGFkYXRhIGZyb20gc2Vzc2lvblN0b3JhZ2UnLCB7IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhck1ldGFkYXRhKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuICAgICAgY29uc3Qga2V5c1RvRGVsZXRlOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb25TdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlc3Npb25TdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChtZXRhZGF0YVByZWZpeCkpIHtcbiAgICAgICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIGVycm9yc1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRDdXJyZW50U2l6ZSgpOiBQcm9taXNlPHsgaXRlbUNvdW50OiBudW1iZXI7IHNpemVCeXRlczogbnVtYmVyIH0+IHtcbiAgICBsZXQgaXRlbUNvdW50ID0gMDtcbiAgICBsZXQgc2l6ZUJ5dGVzID0gMDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCB0cnkgdG8gcHJvYmUgc2Vzc2lvblN0b3JhZ2UgYWNjZXNzXG4gICAgICBzZXNzaW9uU3RvcmFnZS5rZXkoMCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBJZiBiYXNpYyBhY2Nlc3MgZmFpbHMsIHJldHVybiB6ZXJvcyBhcyByZXF1aXJlZCBieSB0ZXN0c1xuICAgICAgcmV0dXJuIHsgaXRlbUNvdW50OiAwLCBzaXplQnl0ZXM6IDAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBzdG9yYWdlS2V5cykge1xuICAgICAgICAvLyBPbmx5IGNvdW50IGFjdHVhbCBpdGVtcywgbm90IG1ldGFkYXRhIG9yIHF1ZXJ5IHJlc3VsdHNcbiAgICAgICAgaWYgKCFrZXkuaW5jbHVkZXMoJzptZXRhZGF0YTonKSAmJiAha2V5LmluY2x1ZGVzKCc6cXVlcnk6JykpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIC8vIE9ubHkgY291bnQgdmFsaWQgaXRlbXMgd2l0aCBwcm9wZXIgdmVyaWZpY2F0aW9uXG4gICAgICAgICAgICAgIGlmIChwYXJzZWQ/Lm9yaWdpbmFsS2V5ICYmIHBhcnNlZD8ub3JpZ2luYWxWZXJpZmljYXRpb25IYXNoID09PSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihwYXJzZWQub3JpZ2luYWxLZXkpKSB7XG4gICAgICAgICAgICAgICAgaXRlbUNvdW50Kys7XG4gICAgICAgICAgICAgICAgc2l6ZUJ5dGVzICs9IG5ldyBCbG9iKFt2YWx1ZV0pLnNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIFNraXAgaW52YWxpZCBlbnRyaWVzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBPbiBhbnkgZXJyb3IgYWZ0ZXIgaW5pdGlhbCBwcm9iZSwgcmV0dXJuIHplcm9zXG4gICAgICByZXR1cm4geyBpdGVtQ291bnQ6IDAsIHNpemVCeXRlczogMCB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGl0ZW1Db3VudCwgc2l6ZUJ5dGVzIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0U2l6ZUxpbWl0cygpOiBQcm9taXNlPHsgbWF4SXRlbXM6IG51bWJlciB8IG51bGw7IG1heFNpemVCeXRlczogbnVtYmVyIHwgbnVsbCB9PiB7XG4gICAgLy8gU2Vzc2lvblN0b3JhZ2UgdHlwaWNhbGx5IGhhcyBhIH41TUIgbGltaXRcbiAgICByZXR1cm4ge1xuICAgICAgbWF4SXRlbXM6IG51bGwsIC8vIE5vIHNwZWNpZmljIGl0ZW0gbGltaXRcbiAgICAgIG1heFNpemVCeXRlczogNSAqIDEwMjQgKiAxMDI0IC8vIDVNQiBjb25zZXJ2YXRpdmUgZXN0aW1hdGVcbiAgICB9O1xuICB9XG5cbn1cbiIsImltcG9ydCB7XG4gIEFsbEl0ZW1UeXBlQXJyYXlzLFxuICBDb21LZXksXG4gIGlzQ29tS2V5LFxuICBpc1F1ZXJ5TWF0Y2gsXG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFByaUtleVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhIH0gZnJvbSBcIi4uL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lcIjtcbmltcG9ydCB7IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sIGlzTG9jS2V5QXJyYXlFcXVhbCwgUXVlcnlDYWNoZUVudHJ5IH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IEFzeW5jSW5kZXhEQkNhY2hlTWFwIH0gZnJvbSBcIi4vQXN5bmNJbmRleERCQ2FjaGVNYXBcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tIFwiLi4vQ2FjaGVNYXBcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIkluZGV4REJDYWNoZU1hcFwiKTtcblxuaW50ZXJmYWNlIE1lbW9yeUVudHJ5PEssIFY+IHtcbiAgb3JpZ2luYWxLZXk6IEs7XG4gIHZhbHVlOiBWO1xuICBtZXRhZGF0YT86IENhY2hlSXRlbU1ldGFkYXRhO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIEluZGV4ZWREQiBDYWNoZU1hcCB3cmFwcGVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gcHJvdmlkZXMgc3luY2hyb25vdXMgbWVtb3J5IG9wZXJhdGlvbnMgd2l0aCBiYWNrZ3JvdW5kIEluZGV4ZWREQiBwZXJzaXN0ZW5jZS5cbiAqIE1lbW9yeSBvcGVyYXRpb25zIGFyZSBpbW1lZGlhdGUgd2hpbGUgSW5kZXhlZERCIG9wZXJhdGlvbnMgaGFwcGVuIGFzeW5jaHJvbm91c2x5IGluIHRoZSBiYWNrZ3JvdW5kLlxuICpcbiAqIEJlbmVmaXRzOlxuICogLSBGYXN0IG1lbW9yeSBhY2Nlc3MgZm9yIGltbWVkaWF0ZSBvcGVyYXRpb25zXG4gKiAtIEJhY2tncm91bmQgcGVyc2lzdGVuY2UgdG8gSW5kZXhlZERCIGZvciBkdXJhYmlsaXR5XG4gKiAtIFN5bmNocm9ub3VzIEFQSSBjb21wYXRpYmxlIHdpdGggb3RoZXIgQ2FjaGVNYXAgaW1wbGVtZW50YXRpb25zXG4gKiAtIEF1dG9tYXRpYyBzeW5jIGJldHdlZW4gbWVtb3J5IGFuZCBJbmRleGVkREJcbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4REJDYWNoZU1hcDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiBleHRlbmRzIENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuXG4gIHB1YmxpYyByZWFkb25seSBpbXBsZW1lbnRhdGlvblR5cGUgPSBcImJyb3dzZXIvaW5kZXhlZERCXCI7XG5cbiAgLy8gTWVtb3J5IHN0b3JhZ2VcbiAgcHJpdmF0ZSBtZW1vcnlNYXA6IHsgW2tleTogc3RyaW5nXTogTWVtb3J5RW50cnk8Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIFY+IH0gPSB7fTtcbiAgcHJpdmF0ZSBxdWVyeVJlc3VsdENhY2hlOiB7IFtxdWVyeUhhc2g6IHN0cmluZ106IFF1ZXJ5Q2FjaGVFbnRyeSB9ID0ge307XG4gIHByaXZhdGUgbWV0YWRhdGFNYXA6IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBub3JtYWxpemVkSGFzaEZ1bmN0aW9uOiAoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPikgPT4gc3RyaW5nO1xuICBwcm90ZWN0ZWQgdHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLy8gSW5kZXhlZERCIGZvciBwZXJzaXN0ZW5jZVxuICBwdWJsaWMgYXN5bmNDYWNoZTogQXN5bmNJbmRleERCQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvLyBCYWNrZ3JvdW5kIHN5bmMgbWFuYWdlbWVudFxuICBwcml2YXRlIHN5bmNJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwZW5kaW5nT3BlcmF0aW9uczogQXJyYXk8e1xuICAgIHR5cGU6ICdzZXQnIHwgJ2RlbGV0ZScgfCAnY2xlYXInO1xuICAgIGtleT86IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+O1xuICAgIHZhbHVlPzogVjtcbiAgICBtZXRhZGF0YT86IENhY2hlSXRlbU1ldGFkYXRhO1xuICAgIHNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgfT4gPSBbXTtcbiAgcHJpdmF0ZSBzZXF1ZW5jZUNvdW50ZXIgPSAwO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICB0eXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBkYk5hbWU6IHN0cmluZyA9ICdmamVsbC1pbmRleGRiLWNhY2hlJyxcbiAgICBzdG9yZU5hbWU6IHN0cmluZyA9ICdjYWNoZScsXG4gICAgdmVyc2lvbjogbnVtYmVyID0gMVxuICApIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb248Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4+KCk7XG4gICAgdGhpcy5hc3luY0NhY2hlID0gbmV3IEFzeW5jSW5kZXhEQkNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4odHlwZXMsIGRiTmFtZSwgc3RvcmVOYW1lLCB2ZXJzaW9uKTtcblxuICAgIC8vIEluaXRpYWxpemUgZnJvbSBJbmRleGVkREIgYW5kIHN0YXJ0IGJhY2tncm91bmQgc3luY1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZyb21JbmRleGVkREIoKTtcbiAgICB0aGlzLnN0YXJ0UGVyaW9kaWNTeW5jKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVGcm9tSW5kZXhlZERCKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5hc3luY0NhY2hlLmtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICAgIC8vIE9ubHkgbG9hZCBpZiBub3QgYWxyZWFkeSBpbiBtZW1vcnkgY2FjaGVcbiAgICAgICAgaWYgKCF0aGlzLm1lbW9yeU1hcFtoYXNoZWRLZXldKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmFzeW5jQ2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm1lbW9yeU1hcFtoYXNoZWRLZXldID0ge1xuICAgICAgICAgICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGluaXRpYWxpemUgZnJvbSBJbmRleGVkREIsIHVzaW5nIG1lbW9yeS1vbmx5IG1vZGU6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRQZXJpb2RpY1N5bmMoKTogdm9pZCB7XG4gICAgLy8gUHJvY2VzcyBwZW5kaW5nIG9wZXJhdGlvbnMgZXZlcnkgMTBtcyBmb3IgcmVzcG9uc2l2ZSBzeW5jaW5nXG4gICAgdGhpcy5zeW5jSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nT3BlcmF0aW9ucygpO1xuICAgIH0sIDEwKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFsuLi50aGlzLnBlbmRpbmdPcGVyYXRpb25zXTtcbiAgICB0aGlzLnBlbmRpbmdPcGVyYXRpb25zID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICBpZiAob3Aua2V5ICYmIG9wLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXN5bmNDYWNoZS5zZXQob3Aua2V5LCBvcC52YWx1ZSwgb3AubWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgIGlmIChvcC5rZXkpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3luY0NhY2hlLmRlbGV0ZShvcC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2xlYXInOlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3luY0NhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc3luYyBvcGVyYXRpb24gdG8gSW5kZXhlZERCOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTeW5jaHJvbm91cyBtZW1vcnkgb3BlcmF0aW9uc1xuXG4gIHB1YmxpYyBhc3luYyBnZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IFByb21pc2U8ViB8IG51bGw+IHtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWVtb3J5TWFwW2hhc2hlZEtleV07XG5cbiAgICBpZiAoZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5KSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sIHZhbHVlOiBWKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIENyZWF0ZSBtZXRhZGF0YVxuICAgIGNvbnN0IG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIGtleTogSlNPTi5zdHJpbmdpZnkoa2V5KSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemU6IEpTT04uc3RyaW5naWZ5KHZhbHVlKS5sZW5ndGggLy8gcm91Z2ggZXN0aW1hdGVcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIG1lbW9yeSBpbW1lZGlhdGVseVxuICAgIHRoaXMubWVtb3J5TWFwW2hhc2hlZEtleV0gPSB7XG4gICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcblxuICAgIC8vIEFkZCB0byBwZW5kaW5nIG9wZXJhdGlvbnMgZm9yIGJhY2tncm91bmQgc3luY1xuICAgIHRoaXMucGVuZGluZ09wZXJhdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWV0YWRhdGEsXG4gICAgICBzZXF1ZW5jZUlkOiArK3RoaXMuc2VxdWVuY2VDb3VudGVyXG4gICAgfSk7XG5cbiAgICAvLyBUcmlnZ2VyIGltbWVkaWF0ZSBzeW5jIGZvciBjcml0aWNhbCBvcGVyYXRpb25zXG4gICAgdGhpcy5wcm9jZXNzUGVuZGluZ09wZXJhdGlvbnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbmNsdWRlc0tleShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1lbW9yeU1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiAhIShlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG5cbiAgICAvLyBSZW1vdmUgZnJvbSBtZW1vcnkgaW1tZWRpYXRlbHlcbiAgICBkZWxldGUgdGhpcy5tZW1vcnlNYXBbaGFzaGVkS2V5XTtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLmRlbGV0ZShoYXNoZWRLZXkpO1xuXG4gICAgLy8gQWRkIHRvIHBlbmRpbmcgb3BlcmF0aW9ucyBmb3IgYmFja2dyb3VuZCBzeW5jXG4gICAgdGhpcy5wZW5kaW5nT3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAga2V5LFxuICAgICAgc2VxdWVuY2VJZDogKyt0aGlzLnNlcXVlbmNlQ291bnRlclxuICAgIH0pO1xuXG4gICAgLy8gVHJpZ2dlciBpbW1lZGlhdGUgc3luYyBmb3IgY3JpdGljYWwgb3BlcmF0aW9uc1xuICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdPcGVyYXRpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2V5cygpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXT4ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWVtb3J5TWFwKS5tYXAoZW50cnkgPT4gZW50cnkub3JpZ2luYWxLZXkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHZhbHVlcygpOiBQcm9taXNlPFZbXT4ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWVtb3J5TWFwKS5tYXAoZW50cnkgPT4gZW50cnkudmFsdWUpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIENsZWFyIG1lbW9yeSBpbW1lZGlhdGVseVxuICAgIHRoaXMubWVtb3J5TWFwID0ge307XG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlID0ge307XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5jbGVhcigpO1xuXG4gICAgLy8gQWRkIHRvIHBlbmRpbmcgb3BlcmF0aW9ucyBmb3IgYmFja2dyb3VuZCBzeW5jXG4gICAgdGhpcy5wZW5kaW5nT3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdjbGVhcicsXG4gICAgICBzZXF1ZW5jZUlkOiArK3RoaXMuc2VxdWVuY2VDb3VudGVyXG4gICAgfSk7XG5cbiAgICAvLyBUcmlnZ2VyIGltbWVkaWF0ZSBzeW5jIGZvciBjcml0aWNhbCBvcGVyYXRpb25zXG4gICAgdGhpcy5wcm9jZXNzUGVuZGluZ09wZXJhdGlvbnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhbGxJbihsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSk6IFByb21pc2U8VltdPiB7XG4gICAgY29uc3QgcmVzdWx0OiBWW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1lbW9yeU1hcCkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGVudHJ5Lm9yaWdpbmFsS2V5O1xuXG4gICAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBSZXR1cm4gYWxsIGl0ZW1zIGlmIG5vIGxvY2F0aW9ucyBzcGVjaWZpZWRcbiAgICAgICAgcmVzdWx0LnB1c2goZW50cnkudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0NvbUtleShrZXkpKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0ZW0gaXMgaW4gc3BlY2lmaWVkIGxvY2F0aW9uc1xuICAgICAgICBpZiAoaXNMb2NLZXlBcnJheUVxdWFsKChrZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pLmxvYywgbG9jYXRpb25zKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY29udGFpbnMocXVlcnk6IEl0ZW1RdWVyeSwgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMucXVlcnlJbihxdWVyeSwgbG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBxdWVyeUluKHF1ZXJ5OiBJdGVtUXVlcnksIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxWW10+IHtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuXG4gICAgaWYgKCFxdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbmRpZGF0ZXMuZmlsdGVyKGl0ZW0gPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzXG5cbiAgcHVibGljIGFzeW5jIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nLCBpdGVtS2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF0gPSB7XG4gICAgICBpdGVtS2V5c1xuICAgIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoOiBzdHJpbmcpOiBQcm9taXNlPChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSB8IG51bGw+IHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5Lml0ZW1LZXlzIDogbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBoYXNRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBxdWVyeUhhc2ggaW4gdGhpcy5xdWVyeVJlc3VsdENhY2hlO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZGVsZXRlIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyUXVlcnlSZXN1bHRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICB9XG5cbiAgLy8gSW52YWxpZGF0aW9uIG1ldGhvZHNcblxuICBwdWJsaWMgYXN5bmMgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEludmFsaWRhdGUgcXVlcnkgcmVzdWx0cyB0aGF0IGNvbnRhaW4gYW55IG9mIHRoZSBhZmZlY3RlZCBrZXlzXG4gICAgZm9yIChjb25zdCBxdWVyeUhhc2ggaW4gdGhpcy5xdWVyeVJlc3VsdENhY2hlKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5Lml0ZW1LZXlzLnNvbWUoa2V5ID0+IGtleXMuc29tZShhZmZlY3RlZEtleSA9PlxuICAgICAgICB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oYWZmZWN0ZWRLZXkpID09PSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KVxuICAgICAgKSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpdGVtc1RvRGVsZXRlOiAoQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1lbW9yeU1hcCkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGVudHJ5Lm9yaWdpbmFsS2V5O1xuXG4gICAgICBpZiAoaXNDb21LZXkoa2V5KSAmJiBpc0xvY0tleUFycmF5RXF1YWwoKGtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PikubG9jLCBsb2NhdGlvbnMpKSB7XG4gICAgICAgIGl0ZW1zVG9EZWxldGUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKGl0ZW1zVG9EZWxldGUpO1xuICB9XG5cbiAgLy8gTWV0YWRhdGEgb3BlcmF0aW9uc1xuXG4gIHB1YmxpYyBhc3luYyBnZXRNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8Q2FjaGVJdGVtTWV0YWRhdGEgfCBudWxsPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXRNZXRhZGF0YShrZXk6IHN0cmluZywgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5zZXQoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlTWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldEFsbE1ldGFkYXRhKCk6IFByb21pc2U8TWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+PiB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5tZXRhZGF0YU1hcCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYXJNZXRhZGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLmNsZWFyKCk7XG4gIH1cblxuICAvLyBTaXplIG9wZXJhdGlvbnNcblxuICBwdWJsaWMgYXN5bmMgZ2V0Q3VycmVudFNpemUoKTogUHJvbWlzZTx7IGl0ZW1Db3VudDogbnVtYmVyOyBzaXplQnl0ZXM6IG51bWJlciB9PiB7XG4gICAgY29uc3QgaXRlbUNvdW50ID0gT2JqZWN0LmtleXModGhpcy5tZW1vcnlNYXApLmxlbmd0aDtcblxuICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgc2l6ZVxuICAgIGxldCBzaXplQnl0ZXMgPSAwO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1lbW9yeU1hcCkpIHtcbiAgICAgIHNpemVCeXRlcyArPSBKU09OLnN0cmluZ2lmeShlbnRyeS52YWx1ZSkubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB7IGl0ZW1Db3VudCwgc2l6ZUJ5dGVzIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0U2l6ZUxpbWl0cygpOiBQcm9taXNlPHsgbWF4SXRlbXM6IG51bWJlciB8IG51bGw7IG1heFNpemVCeXRlczogbnVtYmVyIHwgbnVsbCB9PiB7XG4gICAgLy8gTWVtb3J5IGNhY2hlIGhhcyBubyBoYXJkIGxpbWl0cywgYnV0IEluZGV4ZWREQiBkb2VzXG4gICAgcmV0dXJuIHsgbWF4SXRlbXM6IG51bGwsIG1heFNpemVCeXRlczogbnVsbCB9O1xuICB9XG5cbiAgLy8gQ2xvbmUgb3BlcmF0aW9uXG5cbiAgcHVibGljIGFzeW5jIGNsb25lKCk6IFByb21pc2U8Q2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4ge1xuICAgIGNvbnN0IGNsb25lZCA9IG5ldyBJbmRleERCQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgIHRoaXMudHlwZXMsXG4gICAgICAnZmplbGwtaW5kZXhkYi1jYWNoZS1jbG9uZScsXG4gICAgICAnY2FjaGUtY2xvbmUnLFxuICAgICAgMVxuICAgICk7XG5cbiAgICAvLyBDb3B5IG1lbW9yeSBzdGF0ZVxuICAgIGNsb25lZC5tZW1vcnlNYXAgPSB7IC4uLnRoaXMubWVtb3J5TWFwIH07XG4gICAgY2xvbmVkLnF1ZXJ5UmVzdWx0Q2FjaGUgPSB7IC4uLnRoaXMucXVlcnlSZXN1bHRDYWNoZSB9O1xuICAgIGNsb25lZC5tZXRhZGF0YU1hcCA9IG5ldyBNYXAodGhpcy5tZXRhZGF0YU1hcCk7XG5cbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHJlc291cmNlcyB3aGVuIHRoZSBjYWNoZSBpcyBubyBsb25nZXIgbmVlZGVkXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zeW5jSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5zeW5jSW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQWxsSXRlbVR5cGVBcnJheXMsXG4gIENvbUtleSxcbiAgaXNDb21LZXksXG4gIGlzUXVlcnlNYXRjaCxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiwgaXNMb2NLZXlBcnJheUVxdWFsIH0gZnJvbSBcIi4uL25vcm1hbGl6YXRpb25cIjtcbmltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhIH0gZnJvbSBcIi4uL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHNhZmVTdHJpbmdpZnkgZnJvbSAnZmFzdC1zYWZlLXN0cmluZ2lmeSc7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJBc3luY0luZGV4REJDYWNoZU1hcFwiKTtcblxuaW50ZXJmYWNlIFN0b3JlZEl0ZW08Vj4ge1xuICBvcmlnaW5hbEtleTogQ29tS2V5PGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+IHwgUHJpS2V5PGFueT47XG4gIHZhbHVlOiBWO1xuICBtZXRhZGF0YT86IENhY2hlSXRlbU1ldGFkYXRhO1xuICB2ZXJzaW9uOiBudW1iZXI7IC8vIEZvciBmdXR1cmUgbWlncmF0aW9uIHN1cHBvcnRcbn1cblxuLyoqXG4gKiBJbmRleGVkREIgaW1wbGVtZW50YXRpb24gb2YgQ2FjaGVNYXAgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICogRGF0YSBwZXJzaXN0cyBsb25nLXRlcm0gd2l0aCBtdWNoIGxhcmdlciBzdG9yYWdlIGxpbWl0cyB0aGFuIGxvY2FsU3RvcmFnZS9zZXNzaW9uU3RvcmFnZS5cbiAqXG4gKiBOb3RlOiBJbmRleGVkREIgaXMgYXN5bmNocm9ub3VzIGFuZCBjYW4gc3RvcmUgc3RydWN0dXJlZCBkYXRhLlxuICogU3RvcmFnZSBsaW1pdCBpcyBodW5kcmVkcyBvZiBNQiBvciBtb3JlIGRlcGVuZGluZyBvbiBicm93c2VyIGFuZCB1c2VyLlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHByb21pc2VzIGZvciBhbGwgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jSW5kZXhEQkNhY2hlTWFwPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IHtcbiAgcHJvdGVjdGVkIHR5cGVzOiBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICBwcml2YXRlIGRiTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHN0b3JlTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHZlcnNpb246IG51bWJlcjtcbiAgcHJpdmF0ZSBub3JtYWxpemVkSGFzaEZ1bmN0aW9uOiAoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPikgPT4gc3RyaW5nO1xuICBwcml2YXRlIGRiUHJvbWlzZTogUHJvbWlzZTxJREJEYXRhYmFzZT4gfCBudWxsID0gbnVsbDtcblxuICAvLyBDdXJyZW50IHN0b3JhZ2UgZm9ybWF0IHZlcnNpb25cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ1VSUkVOVF9WRVJTSU9OID0gMTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgdHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgZGJOYW1lOiBzdHJpbmcgPSAnZmplbGwtaW5kZXhkYi1jYWNoZScsXG4gICAgc3RvcmVOYW1lOiBzdHJpbmcgPSAnY2FjaGUnLFxuICAgIHZlcnNpb246IG51bWJlciA9IDFcbiAgKSB7XG4gICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgIHRoaXMuZGJOYW1lID0gZGJOYW1lO1xuICAgIHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbjxDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPj4oKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0REIoKTogUHJvbWlzZTxJREJEYXRhYmFzZT4ge1xuICAgIGlmICghdGhpcy5kYlByb21pc2UpIHtcbiAgICAgIHRoaXMuZGJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiBJbmRleGVkREIgaXMgYXZhaWxhYmxlIChub3QgaW4gc2VydmVyLXNpZGUgZW52aXJvbm1lbnQpXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhlZERCID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0luZGV4ZWREQiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIG9wZW5pbmcgSW5kZXhlZERCJywgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdJbmRleGVkREIgb3BlbmVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdJbmRleGVkREIgdXBncmFkZSBuZWVkZWQnKTtcbiAgICAgICAgICBjb25zdCBkYiA9IChldmVudC50YXJnZXQgYXMgSURCT3BlbkRCUmVxdWVzdCkucmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMuc3RvcmVOYW1lKSkge1xuICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdDcmVhdGVkIG9iamVjdCBzdG9yZScsIHsgc3RvcmVOYW1lOiB0aGlzLnN0b3JlTmFtZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYlByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIGdldFN0b3JhZ2VLZXkoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTxWIHwgbnVsbD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0JywgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZG9ubHknKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KHN0b3JhZ2VLZXkpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZnJvbSBJbmRleGVkREInLCB7IGtleSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlZDogU3RvcmVkSXRlbTxWPiB8IHVuZGVmaW5lZCA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGlmIChzdG9yZWQgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKHN0b3JlZC5vcmlnaW5hbEtleSkgPT09IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgICAgICByZXNvbHZlKHN0b3JlZC52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIGdldCBvcGVyYXRpb24nLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJvdGggdGhlIHZhbHVlIGFuZCBtZXRhZGF0YSBmb3IgYW4gaXRlbVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldFdpdGhNZXRhZGF0YShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx7IHZhbHVlOiBWOyBtZXRhZGF0YT86IENhY2hlSXRlbU1ldGFkYXRhIH0gfCBudWxsPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdnZXRXaXRoTWV0YWRhdGEnLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkb25seScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQoc3RvcmFnZUtleSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyBmcm9tIEluZGV4ZWREQicsIHsga2V5LCBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RvcmVkOiBTdG9yZWRJdGVtPFY+IHwgdW5kZWZpbmVkID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgaWYgKHN0b3JlZCAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oc3RvcmVkLm9yaWdpbmFsS2V5KSA9PT0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICB2YWx1ZTogc3RvcmVkLnZhbHVlLFxuICAgICAgICAgICAgICBtZXRhZGF0YTogc3RvcmVkLm1ldGFkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBJbmRleGVkREIgZ2V0V2l0aE1ldGFkYXRhIG9wZXJhdGlvbicsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXQoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgdmFsdWU6IFYsIG1ldGFkYXRhPzogQ2FjaGVJdGVtTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldCcsIHsga2V5LCB2YWx1ZSwgaGFzTWV0YWRhdGE6ICEhbWV0YWRhdGEgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZHdyaXRlJyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcblxuICAgICAgY29uc3Qgc3RvcmVkSXRlbTogU3RvcmVkSXRlbTxWPiA9IHtcbiAgICAgICAgb3JpZ2luYWxLZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgIHZlcnNpb246IEFzeW5jSW5kZXhEQkNhY2hlTWFwLkNVUlJFTlRfVkVSU0lPTlxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChzdG9yZWRJdGVtLCBzdG9yYWdlS2V5KTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBzZXR0aW5nIGluIEluZGV4ZWREQicsIHsga2V5LCB2YWx1ZSwgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIEluZGV4ZWREQiBzZXQgb3BlcmF0aW9uJywgeyBrZXksIHZhbHVlLCBlcnJvciB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN0b3JlIGl0ZW0gaW4gSW5kZXhlZERCOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgb25seSB0aGUgbWV0YWRhdGEgZm9yIGFuIGV4aXN0aW5nIGl0ZW1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRNZXRhZGF0YShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3NldE1ldGFkYXRhJywgeyBrZXksIG1ldGFkYXRhIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHRoaXMuZ2V0V2l0aE1ldGFkYXRhKGtleSk7XG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXQoa2V5LCBleGlzdGluZy52YWx1ZSwgbWV0YWRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm5pbmcoJ0F0dGVtcHRlZCB0byBzZXQgbWV0YWRhdGEgZm9yIG5vbi1leGlzdGVudCBpdGVtJywgeyBrZXkgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIHNldE1ldGFkYXRhIG9wZXJhdGlvbicsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBtZXRhZGF0YSBpbiBJbmRleGVkREI6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGluY2x1ZGVzS2V5KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkb25seScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQoc3RvcmFnZUtleSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgY2hlY2tpbmcga2V5IGluIEluZGV4ZWREQicsIHsga2V5LCBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RvcmVkOiBTdG9yZWRJdGVtPFY+IHwgdW5kZWZpbmVkID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihzdG9yZWQub3JpZ2luYWxLZXkpID09PSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIHJlc29sdmUobWF0Y2hlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIEluZGV4ZWREQiBpbmNsdWRlc0tleSBvcGVyYXRpb24nLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZShrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdkZWxldGUnLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkd3JpdGUnKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHN0b3JhZ2VLZXkpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCJywgeyBrZXksIGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBJbmRleGVkREIgZGVsZXRlIG9wZXJhdGlvbicsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWxsSW4obG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pOiBQcm9taXNlPFZbXT4ge1xuICAgIGNvbnN0IGFsbEtleXMgPSBhd2FpdCB0aGlzLmtleXMoKTtcblxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1JldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHknKTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gYWxsS2V5cy5tYXAoa2V5ID0+IHRoaXMuZ2V0KGtleSkpO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IG51bGwpIGFzIFZbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG9jS2V5czogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gbG9jYXRpb25zO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdhbGxJbicsIHsgbG9jS2V5cywga2V5czogYWxsS2V5cy5sZW5ndGggfSk7XG4gICAgICBjb25zdCBmaWx0ZXJlZEtleXMgPSBhbGxLZXlzXG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4ga2V5ICYmIGlzQ29tS2V5KGtleSkpXG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IENvbUtleSA9IGtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ0NvbXBhcmluZyBMb2NhdGlvbiBLZXlzJywge1xuICAgICAgICAgICAgbG9jS2V5cyxcbiAgICAgICAgICAgIENvbUtleSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaXNMb2NLZXlBcnJheUVxdWFsKGxvY0tleXMsIENvbUtleS5sb2MpO1xuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBmaWx0ZXJlZEtleXMubWFwKGtleSA9PiB0aGlzLmdldChrZXkpKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBudWxsKSBhcyBWW107XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5OiBJdGVtUXVlcnksIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdjb250YWlucycsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcXVlcnlJbihcbiAgICBxdWVyeTogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+IHtcbiAgICBsb2dnZXIuZGVidWcoJ3F1ZXJ5SW4nLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogQXN5bmNJbmRleERCQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gICAgLy8gSW5kZXhlZERCIGlzIHNoYXJlZCBnbG9iYWxseSwgc28gY2xvbmUgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIHNhbWUgZGIgY29uZmlnXG4gICAgcmV0dXJuIG5ldyBBc3luY0luZGV4REJDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KHRoaXMudHlwZXMsIHRoaXMuZGJOYW1lLCB0aGlzLnN0b3JlTmFtZSwgdGhpcy52ZXJzaW9uKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBrZXlzKCk6IFByb21pc2U8KENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdPiB7XG4gICAgY29uc3Qga2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkb25seScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2V0dGluZyBrZXlzIGZyb20gSW5kZXhlZERCJywgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSAoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3Q8SURCQ3Vyc29yV2l0aFZhbHVlPikucmVzdWx0O1xuICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZDogU3RvcmVkSXRlbTxWPiA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGtleXMucHVzaChzdG9yZWQub3JpZ2luYWxLZXkpO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoa2V5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIGtleXMgb3BlcmF0aW9uJywgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBtZXRhZGF0YSBlbnRyaWVzIGZyb20gSW5kZXhlZERCXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0QWxsTWV0YWRhdGEoKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4+IHtcbiAgICBjb25zdCBtZXRhZGF0YU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4oKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIG1ldGFkYXRhIGZyb20gSW5kZXhlZERCJywgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSAoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3Q8SURCQ3Vyc29yV2l0aFZhbHVlPikucmVzdWx0O1xuICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZDogU3RvcmVkSXRlbTxWPiA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdG9yZWQubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoc3RvcmVkLm9yaWdpbmFsS2V5KTtcbiAgICAgICAgICAgICAgbWV0YWRhdGFNYXAuc2V0KGtleVN0ciwgc3RvcmVkLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhTWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBJbmRleGVkREIgZ2V0QWxsTWV0YWRhdGEgb3BlcmF0aW9uJywgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBtZXRhZGF0YU1hcDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdmFsdWVzKCk6IFByb21pc2U8VltdPiB7XG4gICAgY29uc3QgdmFsdWVzOiBWW10gPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZXR0aW5nIHZhbHVlcyBmcm9tIEluZGV4ZWREQicsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgY3Vyc29yID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0PElEQkN1cnNvcldpdGhWYWx1ZT4pLnJlc3VsdDtcbiAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWQ6IFN0b3JlZEl0ZW08Vj4gPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChzdG9yZWQudmFsdWUpO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBJbmRleGVkREIgdmFsdWVzIG9wZXJhdGlvbicsIHsgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnQ2xlYXJpbmcgSW5kZXhlZERCIGNhY2hlJyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZHdyaXRlJyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgY2xlYXJpbmcgSW5kZXhlZERCIGNhY2hlJywgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gSW5kZXhlZERCIGNsZWFyIG9wZXJhdGlvbicsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXN5bmMgUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kc1xuXG4gIGFzeW5jIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaDogc3RyaW5nLCBpdGVtS2V5czogKENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXRRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoLCBpdGVtS2V5cyB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBvcGVuIGRhdGFiYXNlIGZvciBzZXRRdWVyeVJlc3VsdCcsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGl0ZW1LZXlzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYHF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgICAgICAgY29uc3QgcHV0UmVxdWVzdCA9IHN0b3JlLnB1dChzYWZlU3RyaW5naWZ5KGVudHJ5KSwgcXVlcnlLZXkpO1xuXG4gICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgcXVlcnkgcmVzdWx0JywgeyBxdWVyeUhhc2gsIGVycm9yOiBwdXRSZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgICAgcmVqZWN0KHB1dFJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBwdXRSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gc2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8KENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KVtdIHwgbnVsbD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBvcGVuIGRhdGFiYXNlIGZvciBnZXRRdWVyeVJlc3VsdCcsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZG9ubHknKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYHF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgICAgICAgY29uc3QgZ2V0UmVxdWVzdCA9IHN0b3JlLmdldChxdWVyeUtleSk7XG5cbiAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBxdWVyeSByZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgZXJyb3I6IGdldFJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgICByZWplY3QoZ2V0UmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0UmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IEpTT04ucGFyc2UocmVzdWx0KTtcblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgYm90aCBvbGQgZm9ybWF0IChqdXN0IGFycmF5KSBhbmQgbmV3IGZvcm1hdFxuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAvLyBPbGQgZm9ybWF0IC0gcmV0dXJuIGFzIGlzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTmV3IGZvcm1hdFxuXG4gICAgICAgICAgICAgIHJlc29sdmUoZW50cnkuaXRlbUtleXMgfHwgbnVsbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHBhcnNlIHF1ZXJ5IHJlc3VsdCcsIHsgcXVlcnlIYXNoLCBlcnJvcjogcGFyc2VFcnJvciB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gZ2V0UXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBoYXNRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxvZ2dlci50cmFjZSgnaGFzUXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBoYXNRdWVyeVJlc3VsdCcsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci50cmFjZSgnZGVsZXRlUXVlcnlSZXN1bHQnLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBvcGVuIGRhdGFiYXNlIGZvciBkZWxldGVRdWVyeVJlc3VsdCcsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICBjb25zdCBxdWVyeUtleSA9IGBxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcXVlc3QgPSBzdG9yZS5kZWxldGUocXVlcnlLZXkpO1xuXG4gICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIHF1ZXJ5IHJlc3VsdCcsIHsgcXVlcnlIYXNoLCBlcnJvcjogZGVsZXRlUmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgIHJlamVjdChkZWxldGVSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIGRlbGV0ZVF1ZXJ5UmVzdWx0JywgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXM6IChDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPilbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZ2dlci5kZWJ1ZygnaW52YWxpZGF0ZUl0ZW1LZXlzJywgeyBrZXlzIH0pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbG9nZ2VyLmRlYnVnKCdpbnZhbGlkYXRlTG9jYXRpb24nLCB7IGxvY2F0aW9ucyB9KTtcblxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGb3IgcHJpbWFyeSBpdGVtcyAobm8gbG9jYXRpb24pLCB0aGlzIHdvdWxkIHJlcXVpcmUgZ2V0dGluZyBhbGwgaXRlbXMgYW5kIGZpbHRlcmluZ1xuICAgICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBjbGVhciBhbGwgcXVlcnkgcmVzdWx0c1xuICAgICAgYXdhaXQgdGhpcy5jbGVhclF1ZXJ5UmVzdWx0cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgY29udGFpbmVkIGl0ZW1zLCBnZXQgYWxsIGl0ZW1zIGluIHRoZSBsb2NhdGlvbiBhbmQgaW52YWxpZGF0ZSB0aGVtXG4gICAgICBjb25zdCBpdGVtc0luTG9jYXRpb24gPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgICBjb25zdCBrZXlzVG9JbnZhbGlkYXRlID0gaXRlbXNJbkxvY2F0aW9uLm1hcChpdGVtID0+IGl0ZW0ua2V5KTtcbiAgICAgIGF3YWl0IHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXNUb0ludmFsaWRhdGUpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFsbCBxdWVyeSByZXN1bHRzIHRoYXQgbWlnaHQgYmUgYWZmZWN0ZWRcbiAgICBhd2FpdCB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gIH1cblxuICBhc3luYyBjbGVhclF1ZXJ5UmVzdWx0cygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2NsZWFyUXVlcnlSZXN1bHRzJyk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3IgY2xlYXJRdWVyeVJlc3VsdHMnLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgLy8gVXNlIGN1cnNvciB0byBpdGVyYXRlIHRocm91Z2gga2V5cyBhbmQgZGVsZXRlIHRob3NlIHRoYXQgc3RhcnQgd2l0aCAncXVlcnk6J1xuICAgICAgICAgIGNvbnN0IGN1cnNvclJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgY29uc3Qga2V5c1RvRGVsZXRlOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gb3BlbiBjdXJzb3IgZm9yIGNsZWFyUXVlcnlSZXN1bHRzJywgeyBlcnJvcjogY3Vyc29yUmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgIHJlamVjdChjdXJzb3JSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBjdXJzb3JSZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5zdGFydHNXaXRoKCdxdWVyeTonKSkge1xuICAgICAgICAgICAgICAgIGtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBObyBtb3JlIGVudHJpZXMsIG5vdyBkZWxldGUgYWxsIHF1ZXJ5IGtleXNcbiAgICAgICAgICAgICAgaWYgKGtleXNUb0RlbGV0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IGRlbGV0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsVG9EZWxldGUgPSBrZXlzVG9EZWxldGUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKHF1ZXJ5S2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVSZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHF1ZXJ5S2V5KTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBxdWVyeSBrZXknLCB7IHF1ZXJ5S2V5LCBlcnJvcjogZGVsZXRlUmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZWRDb3VudCA9PT0gdG90YWxUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7IC8vIENvbnRpbnVlIGV2ZW4gaWYgc29tZSBkZWxldGlvbnMgZmFpbGVkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlZENvdW50ID09PSB0b3RhbFRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gY2xlYXJRdWVyeVJlc3VsdHMnLCB7IGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBJdGVtIH0gZnJvbSAnQGZqZWxsL2NvcmUnO1xuaW1wb3J0IHsgQ2FjaGVNYXAgfSBmcm9tICcuL0NhY2hlTWFwJztcbmltcG9ydCB7IE1lbW9yeUNhY2hlTWFwIH0gZnJvbSAnLi9tZW1vcnkvTWVtb3J5Q2FjaGVNYXAnO1xuaW1wb3J0IHsgRW5oYW5jZWRNZW1vcnlDYWNoZU1hcCB9IGZyb20gJy4vbWVtb3J5L0VuaGFuY2VkTWVtb3J5Q2FjaGVNYXAnO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlQ2FjaGVNYXAgfSBmcm9tICcuL2Jyb3dzZXIvTG9jYWxTdG9yYWdlQ2FjaGVNYXAnO1xuaW1wb3J0IHsgU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcCB9IGZyb20gJy4vYnJvd3Nlci9TZXNzaW9uU3RvcmFnZUNhY2hlTWFwJztcbmltcG9ydCB7IEluZGV4REJDYWNoZU1hcCB9IGZyb20gJy4vYnJvd3Nlci9JbmRleERCQ2FjaGVNYXAnO1xuXG5pbXBvcnQgeyB2YWxpZGF0ZVNpemVDb25maWcgfSBmcm9tICcuL3V0aWxzL0NhY2hlU2l6ZSc7XG5pbXBvcnQgeyBFdmljdGlvblN0cmF0ZWd5Q29uZmlncyB9IGZyb20gJy4vZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneUNvbmZpZyc7XG5cbi8qKlxuICogQXZhaWxhYmxlIGNhY2hlIHR5cGVzIGZvciB0aGUgY2FjaGUgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IHR5cGUgQ2FjaGVUeXBlID0gJ21lbW9yeScgfCAnbG9jYWxTdG9yYWdlJyB8ICdzZXNzaW9uU3RvcmFnZScgfCAnaW5kZXhlZERCJyB8ICdhc3luY0luZGV4ZWREQicgfCAnY3VzdG9tJztcblxuLyoqXG4gKiBDYWNoZSBldmljdGlvbiBwb2xpY2llcyBmb3Igd2hlbiBjYWNoZSBzaXplIGxpbWl0cyBhcmUgcmVhY2hlZFxuICovXG5leHBvcnQgdHlwZSBFdmljdGlvblBvbGljeSA9XG4gIHwgJ2xydScgICAgIC8vIExlYXN0IFJlY2VudGx5IFVzZWQgLSByZW1vdmVzIG9sZGVzdCByZWNlbnRseS1hY2Nlc3NlZCBpdGVtXG4gIHwgJ2xmdScgICAgIC8vIExlYXN0IEZyZXF1ZW50bHkgVXNlZCAtIHJlbW92ZXMgaXRlbSB3aXRoIGxvd2VzdCBhY2Nlc3MgZnJlcXVlbmN5XG4gIHwgJ2ZpZm8nICAgIC8vIEZpcnN0LUluLCBGaXJzdC1PdXQgLSByZW1vdmVzIG9sZGVzdCBhZGRlZCBpdGVtXG4gIHwgJ21ydScgICAgIC8vIE1vc3QgUmVjZW50bHkgVXNlZCAtIHJlbW92ZXMgbW9zdCByZWNlbnRseSB1c2VkIGl0ZW1cbiAgfCAncmFuZG9tJyAgLy8gUmFuZG9tIFJlcGxhY2VtZW50IC0gZXZpY3RzIGEgcmFuZG9tIGl0ZW1cbiAgfCAnYXJjJyAgICAgLy8gQWRhcHRpdmUgUmVwbGFjZW1lbnQgQ2FjaGUgLSBiYWxhbmNlcyByZWNlbmN5IGFuZCBmcmVxdWVuY3lcbiAgfCAnMnEnOyAgICAgLy8gVHdvIFF1ZXVlcyAtIGtlZXBzIHNlcGFyYXRlIExSVSBsaXN0cyBmb3IgcmVjZW50IGFuZCBmcmVxdWVudCBlbnRyaWVzXG5cbi8qKlxuICogQ2FjaGUgc2l6ZSBjb25maWd1cmF0aW9uIHN1cHBvcnRpbmcgYnl0ZXMgYW5kIGl0ZW0gY291bnQgbGltaXRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVTaXplQ29uZmlnIHtcbiAgLyoqIE1heGltdW0gY2FjaGUgc2l6ZSBpbiBieXRlcyAoZS5nLiwgJzEwMCcsICc1S0InLCAnMTBNQicsICcyR0InLCAnMUtpQicsICc1MTJNaUInKSAqL1xuICBtYXhTaXplQnl0ZXM/OiBzdHJpbmc7XG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyBpbiBjYWNoZSAqL1xuICBtYXhJdGVtcz86IG51bWJlcjtcbiAgLyoqIEBkZXByZWNhdGVkIEV2aWN0aW9uIHBvbGljeSBpcyBub3cgaGFuZGxlZCBieSBDYWNoZS1sZXZlbCBFdmljdGlvbk1hbmFnZXIgdmlhIGV2aWN0aW9uQ29uZmlnICovXG4gIGV2aWN0aW9uUG9saWN5PzogRXZpY3Rpb25Qb2xpY3k7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgSW5kZXhlZERCLWJhc2VkIGNhY2hlIG1hcHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmRleGVkREJDb25maWcge1xuICAvKiogRGF0YWJhc2UgbmFtZSAoZGVmYXVsdDogJ2ZqZWxsLWNhY2hlJykgKi9cbiAgZGJOYW1lPzogc3RyaW5nO1xuICAvKiogRGF0YWJhc2UgdmVyc2lvbiAoZGVmYXVsdDogMSkgKi9cbiAgdmVyc2lvbj86IG51bWJlcjtcbiAgLyoqIE9iamVjdCBzdG9yZSBuYW1lIChkZWZhdWx0OiAnY2FjaGUnKSAqL1xuICBzdG9yZU5hbWU/OiBzdHJpbmc7XG4gIC8qKiBTaXplIGNvbmZpZ3VyYXRpb24gZm9yIEluZGV4ZWREQiBjYWNoZSAqL1xuICBzaXplPzogQ2FjaGVTaXplQ29uZmlnO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGxvY2FsU3RvcmFnZS9zZXNzaW9uU3RvcmFnZS1iYXNlZCBjYWNoZSBtYXBzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU3RvcmFnZUNvbmZpZyB7XG4gIC8qKiBLZXkgcHJlZml4IGZvciBzdG9yYWdlIGl0ZW1zIChkZWZhdWx0OiAnZmplbGwtY2FjaGU6JykgKi9cbiAga2V5UHJlZml4Pzogc3RyaW5nO1xuICAvKiogV2hldGhlciB0byBjb21wcmVzcyBzdG9yZWQgZGF0YSAoZGVmYXVsdDogZmFsc2UpICovXG4gIGNvbXByZXNzPzogYm9vbGVhbjtcbiAgLyoqIFNpemUgY29uZmlndXJhdGlvbiBmb3Igd2ViIHN0b3JhZ2UgY2FjaGUgKi9cbiAgc2l6ZT86IENhY2hlU2l6ZUNvbmZpZztcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBtZW1vcnktYmFzZWQgY2FjaGUgbWFwc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeUNvbmZpZyB7XG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBrZWVwIGluIG1lbW9yeSAoZGVmYXVsdDogdW5saW1pdGVkKSAqL1xuICBtYXhJdGVtcz86IG51bWJlcjtcbiAgLyoqIFNpemUgY29uZmlndXJhdGlvbiBmb3IgbWVtb3J5IGNhY2hlICovXG4gIHNpemU/OiBDYWNoZVNpemVDb25maWc7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY3VzdG9tIGNhY2hlIG1hcCBpbnN0YW5jZXNcbiAqL1xuZXhwb3J0IHR5cGUgQ2FjaGVNYXBGYWN0b3J5PFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gKGt0YTogW1MsIC4uLnN0cmluZ1tdXSkgPT4gQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuLyoqXG4gKiBDYWNoZSBvcHRpb25zIGludGVyZmFjZSBmb3IgY29uZmlndXJpbmcgY2FjaGUgaW5zdGFuY2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uczxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiB7XG4gIC8qKiBUaGUgdHlwZSBvZiBjYWNoZSB0byB1c2UgKi9cbiAgY2FjaGVUeXBlOiBDYWNoZVR5cGU7XG5cbiAgLyoqIENvbmZpZ3VyYXRpb24gZm9yIEluZGV4ZWREQiBjYWNoZSB0eXBlcyAqL1xuICBpbmRleGVkREJDb25maWc/OiBJbmRleGVkREJDb25maWc7XG5cbiAgLyoqIENvbmZpZ3VyYXRpb24gZm9yIHdlYiBzdG9yYWdlIGNhY2hlIHR5cGVzICovXG4gIHdlYlN0b3JhZ2VDb25maWc/OiBXZWJTdG9yYWdlQ29uZmlnO1xuXG4gIC8qKiBDb25maWd1cmF0aW9uIGZvciBtZW1vcnkgY2FjaGUgdHlwZSAqL1xuICBtZW1vcnlDb25maWc/OiBNZW1vcnlDb25maWc7XG5cbiAgLyoqIEN1c3RvbSBjYWNoZSBtYXAgZmFjdG9yeSBmb3IgJ2N1c3RvbScgY2FjaGUgdHlwZSAqL1xuICBjdXN0b21DYWNoZU1hcEZhY3Rvcnk/OiBDYWNoZU1hcEZhY3Rvcnk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogRXZpY3Rpb24gc3RyYXRlZ3kgY29uZmlndXJhdGlvbiAtIGluZGVwZW5kZW50IG9mIGNhY2hlIGltcGxlbWVudGF0aW9uICovXG4gIGV2aWN0aW9uQ29uZmlnPzogRXZpY3Rpb25TdHJhdGVneUNvbmZpZ3M7XG5cbiAgLyoqIFdoZXRoZXIgdG8gZW5hYmxlIGRlYnVnIGxvZ2dpbmcgZm9yIGNhY2hlIG9wZXJhdGlvbnMgKi9cbiAgZW5hYmxlRGVidWdMb2dnaW5nPzogYm9vbGVhbjtcblxuICAvKiogV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IHN5bmMgd2l0aCB0aGUgQVBJIG9uIGNhY2hlIG1pc3NlcyAqL1xuICBhdXRvU3luYz86IGJvb2xlYW47XG5cbiAgLyoqIENhY2hlIGV4cGlyYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IHVubGltaXRlZCkgKi9cbiAgdHRsPzogbnVtYmVyO1xuXG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBmb3IgZmFpbGVkIG9wZXJhdGlvbnMgKi9cbiAgbWF4UmV0cmllcz86IG51bWJlcjtcblxuICAvKiogRGVsYXkgYmV0d2VlbiByZXRyeSBhdHRlbXB0cyBpbiBtaWxsaXNlY29uZHMgKi9cbiAgcmV0cnlEZWxheT86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGNhY2hlIG9wdGlvbnNcbiAqL1xuY29uc3QgREVGQVVMVF9DQUNIRV9PUFRJT05TOiBQYXJ0aWFsPE9wdGlvbnM8YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSB7XG4gIGNhY2hlVHlwZTogJ21lbW9yeScsXG4gIGVuYWJsZURlYnVnTG9nZ2luZzogZmFsc2UsXG4gIGF1dG9TeW5jOiB0cnVlLFxuICBtYXhSZXRyaWVzOiAzLFxuICByZXRyeURlbGF5OiAxMDAwLFxuICBpbmRleGVkREJDb25maWc6IHtcbiAgICBkYk5hbWU6ICdmamVsbC1jYWNoZScsXG4gICAgdmVyc2lvbjogMSxcbiAgICBzdG9yZU5hbWU6ICdjYWNoZScsXG4gICAgc2l6ZToge1xuICAgICAgZXZpY3Rpb25Qb2xpY3k6ICdscnUnXG4gICAgfVxuICB9LFxuICB3ZWJTdG9yYWdlQ29uZmlnOiB7XG4gICAga2V5UHJlZml4OiAnZmplbGwtY2FjaGU6JyxcbiAgICBjb21wcmVzczogZmFsc2UsXG4gICAgc2l6ZToge1xuICAgICAgZXZpY3Rpb25Qb2xpY3k6ICdscnUnXG4gICAgfVxuICB9LFxuICBtZW1vcnlDb25maWc6IHtcbiAgICAvLyBObyBsaW1pdHMgYnkgZGVmYXVsdFxuICAgIHNpemU6IHtcbiAgICAgIGV2aWN0aW9uUG9saWN5OiAnbHJ1J1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgY2FjaGUgb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVPcHRpb25zID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGNhY2hlT3B0aW9ucz86IFBhcnRpYWw8T3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+Pik6IE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG4gIC8vIERlZXAgY2xvbmUgbmVzdGVkIGNvbmZpZyBvYmplY3RzIHRvIHByZXZlbnQgbXV0YXRpb24gYmV0d2VlbiBpbnN0YW5jZXNcbiAgY29uc3QgaW5kZXhlZERCQ29uZmlnID0gY2FjaGVPcHRpb25zPy5pbmRleGVkREJDb25maWcgPyB7XG4gICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLmluZGV4ZWREQkNvbmZpZyxcbiAgICAuLi5jYWNoZU9wdGlvbnMuaW5kZXhlZERCQ29uZmlnLFxuICAgIHNpemU6IGNhY2hlT3B0aW9ucy5pbmRleGVkREJDb25maWcuc2l6ZSA/IHtcbiAgICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5pbmRleGVkREJDb25maWc/LnNpemUsXG4gICAgICAuLi5jYWNoZU9wdGlvbnMuaW5kZXhlZERCQ29uZmlnLnNpemVcbiAgICB9IDogREVGQVVMVF9DQUNIRV9PUFRJT05TLmluZGV4ZWREQkNvbmZpZz8uc2l6ZVxuICB9IDogeyAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMuaW5kZXhlZERCQ29uZmlnIH07XG5cbiAgY29uc3Qgd2ViU3RvcmFnZUNvbmZpZyA9IGNhY2hlT3B0aW9ucz8ud2ViU3RvcmFnZUNvbmZpZyA/IHtcbiAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMud2ViU3RvcmFnZUNvbmZpZyxcbiAgICAuLi5jYWNoZU9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZyxcbiAgICBzaXplOiBjYWNoZU9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZy5zaXplID8ge1xuICAgICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLndlYlN0b3JhZ2VDb25maWc/LnNpemUsXG4gICAgICAuLi5jYWNoZU9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZy5zaXplXG4gICAgfSA6IERFRkFVTFRfQ0FDSEVfT1BUSU9OUy53ZWJTdG9yYWdlQ29uZmlnPy5zaXplXG4gIH0gOiB7IC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy53ZWJTdG9yYWdlQ29uZmlnIH07XG5cbiAgY29uc3QgbWVtb3J5Q29uZmlnID0gY2FjaGVPcHRpb25zPy5tZW1vcnlDb25maWcgPyB7XG4gICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLm1lbW9yeUNvbmZpZyxcbiAgICAuLi5jYWNoZU9wdGlvbnMubWVtb3J5Q29uZmlnLFxuICAgIHNpemU6IGNhY2hlT3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZSA/IHtcbiAgICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5tZW1vcnlDb25maWc/LnNpemUsXG4gICAgICAuLi5jYWNoZU9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemVcbiAgICB9IDogREVGQVVMVF9DQUNIRV9PUFRJT05TLm1lbW9yeUNvbmZpZz8uc2l6ZVxuICB9IDogeyAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMubWVtb3J5Q29uZmlnIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMsXG4gICAgLi4uY2FjaGVPcHRpb25zLFxuICAgIGluZGV4ZWREQkNvbmZpZyxcbiAgICB3ZWJTdG9yYWdlQ29uZmlnLFxuICAgIG1lbW9yeUNvbmZpZ1xuICB9IGFzIE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGUgbWFwIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDYWNoZU1hcCA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBrdGE6IFtTLCAuLi5zdHJpbmdbXV0sXG4gICAgb3B0aW9uczogT3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IENhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBzd2l0Y2ggKG9wdGlvbnMuY2FjaGVUeXBlKSB7XG4gICAgY2FzZSAnbWVtb3J5JzpcbiAgICAgIC8vIFVzZSBlbmhhbmNlZCBtZW1vcnkgY2FjaGUgaWYgc2l6ZSBjb25maWd1cmF0aW9uIGlzIHByb3ZpZGVkXG4gICAgICBpZiAob3B0aW9ucy5tZW1vcnlDb25maWc/LnNpemUgJiZcbiAgICAgICAgKG9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4U2l6ZUJ5dGVzIHx8IG9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4SXRlbXMpKSB7XG4gICAgICAgIC8vIENyZWF0ZSBzaXplIGNvbmZpZyB3aXRob3V0IGV2aWN0aW9uUG9saWN5IHNpbmNlIHRoYXQncyBoYW5kbGVkIGJ5IENhY2hlLWxldmVsIEV2aWN0aW9uTWFuYWdlclxuICAgICAgICBjb25zdCBzaXplQ29uZmlnID0ge1xuICAgICAgICAgIG1heFNpemVCeXRlczogb3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZS5tYXhTaXplQnl0ZXMsXG4gICAgICAgICAgbWF4SXRlbXM6IG9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4SXRlbXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbmhhbmNlZE1lbW9yeUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oXG4gICAgICAgICAga3RhIGFzIGFueSxcbiAgICAgICAgICBzaXplQ29uZmlnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE1lbW9yeUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oa3RhIGFzIGFueSk7XG5cbiAgICBjYXNlICdsb2NhbFN0b3JhZ2UnOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JhZ2VDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBrdGEgYXMgYW55LFxuICAgICAgICBvcHRpb25zLndlYlN0b3JhZ2VDb25maWc/LmtleVByZWZpeFxuICAgICAgKTtcblxuICAgIGNhc2UgJ3Nlc3Npb25TdG9yYWdlJzpcbiAgICAgIHJldHVybiBuZXcgU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBrdGEgYXMgYW55LFxuICAgICAgICBvcHRpb25zLndlYlN0b3JhZ2VDb25maWc/LmtleVByZWZpeFxuICAgICAgKTtcblxuICAgIGNhc2UgJ2luZGV4ZWREQic6XG4gICAgICByZXR1cm4gbmV3IEluZGV4REJDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBrdGEgYXMgYW55LFxuICAgICAgICBvcHRpb25zLmluZGV4ZWREQkNvbmZpZz8uZGJOYW1lLFxuICAgICAgICBvcHRpb25zLmluZGV4ZWREQkNvbmZpZz8uc3RvcmVOYW1lLFxuICAgICAgICBvcHRpb25zLmluZGV4ZWREQkNvbmZpZz8udmVyc2lvblxuICAgICAgKTtcblxuICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICBpZiAoIW9wdGlvbnMuY3VzdG9tQ2FjaGVNYXBGYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIGNhY2hlIG1hcCBmYWN0b3J5IGlzIHJlcXVpcmVkIHdoZW4gY2FjaGVUeXBlIGlzIFwiY3VzdG9tXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmN1c3RvbUNhY2hlTWFwRmFjdG9yeShrdGEpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2FjaGUgdHlwZTogJHtvcHRpb25zLmNhY2hlVHlwZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjYWNoZSBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU9wdGlvbnMgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4ob3B0aW9uczogT3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KTogdm9pZCA9PiB7XG4gIGlmIChvcHRpb25zLmNhY2hlVHlwZSA9PT0gJ2N1c3RvbScgJiYgIW9wdGlvbnMuY3VzdG9tQ2FjaGVNYXBGYWN0b3J5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXN0b21DYWNoZU1hcEZhY3RvcnkgaXMgcmVxdWlyZWQgd2hlbiBjYWNoZVR5cGUgaXMgXCJjdXN0b21cIicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1heFJldHJpZXMgPT09ICdudW1iZXInICYmIG9wdGlvbnMubWF4UmV0cmllcyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFJldHJpZXMgbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXRyeURlbGF5ID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLnJldHJ5RGVsYXkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyeURlbGF5IG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMudHRsID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLnR0bCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0dGwgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1lbW9yeUNvbmZpZz8ubWF4SXRlbXMgPT09ICdudW1iZXInICYmIG9wdGlvbnMubWVtb3J5Q29uZmlnLm1heEl0ZW1zIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lbW9yeUNvbmZpZy5tYXhJdGVtcyBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBzaXplIGNvbmZpZ3VyYXRpb25zXG4gIGlmIChvcHRpb25zLm1lbW9yeUNvbmZpZz8uc2l6ZSkge1xuICAgIHZhbGlkYXRlU2l6ZUNvbmZpZyhvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplKTtcbiAgfVxuICBpZiAob3B0aW9ucy53ZWJTdG9yYWdlQ29uZmlnPy5zaXplKSB7XG4gICAgdmFsaWRhdGVTaXplQ29uZmlnKG9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZy5zaXplKTtcbiAgfVxuICBpZiAob3B0aW9ucy5pbmRleGVkREJDb25maWc/LnNpemUpIHtcbiAgICB2YWxpZGF0ZVNpemVDb25maWcob3B0aW9ucy5pbmRleGVkREJDb25maWcuc2l6ZSk7XG4gIH1cblxuICAvLyBCcm93c2VyIHN0b3JhZ2UgdmFsaWRhdGlvblxuICBpZiAoWydsb2NhbFN0b3JhZ2UnLCAnc2Vzc2lvblN0b3JhZ2UnXS5pbmNsdWRlcyhvcHRpb25zLmNhY2hlVHlwZSkpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBhIHJlYWwgYnJvd3NlciBlbnZpcm9ubWVudFxuICAgIGNvbnN0IGlzUmVhbEJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmICghaXNSZWFsQnJvd3Nlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbnMuY2FjaGVUeXBlfSBpcyBub3QgYXZhaWxhYmxlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50c2ApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluZGV4ZWREQiB2YWxpZGF0aW9uXG4gIGlmIChvcHRpb25zLmNhY2hlVHlwZSA9PT0gJ2luZGV4ZWREQicpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5pbmRleGVkREIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLmNhY2hlVHlwZX0gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXN5bmNJbmRleGVkREIgdmFsaWRhdGlvbiAtIHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIHN5bmNocm9ub3VzIGNhY2hlIGZhY3RvcnlcbiAgaWYgKG9wdGlvbnMuY2FjaGVUeXBlID09PSAnYXN5bmNJbmRleGVkREInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhc3luY0luZGV4ZWREQiBjYW5ub3QgYmUgdXNlZCB3aXRoIHN5bmNocm9ub3VzIGNhY2hlIGZhY3RvcnkuIFVzZSBBc3luY0luZGV4REJDYWNoZU1hcCBkaXJlY3RseSBmb3IgYXN5bmMgb3BlcmF0aW9ucy4nKTtcbiAgfVxufTtcbiIsImltcG9ydCB7XG4gIEl0ZW1cbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZU1hcCB9IGZyb20gXCIuLi9DYWNoZU1hcFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVNYXAsIE9wdGlvbnMsIHZhbGlkYXRlT3B0aW9ucyB9IGZyb20gXCIuLi9PcHRpb25zXCI7XG5pbXBvcnQgeyBDb29yZGluYXRlIH0gZnJvbSBcIkBmamVsbC9yZWdpc3RyeVwiO1xuXG5leHBvcnQgY29uc3QgcmVzZXQgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGNvb3JkaW5hdGU6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgb3B0aW9uczogT3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4pOiBQcm9taXNlPFtDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XT4gPT4ge1xuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIG9wdGlvbnMgYmVmb3JlIGNyZWF0aW5nIGNhY2hlIG1hcFxuICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjYWNoZSBtYXAgdXNpbmcgdGhlIHNhbWUgY29uZmlndXJhdGlvbiBhcyB0aGUgb3JpZ2luYWxcbiAgICBjb25zdCBjYWNoZU1hcCA9IGNyZWF0ZUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oY29vcmRpbmF0ZS5rdGEsIG9wdGlvbnMpO1xuICAgIHJldHVybiBbY2FjaGVNYXBdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFJlLXRocm93IGFueSB2YWxpZGF0aW9uIG9yIGNyZWF0aW9uIGVycm9yc1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgQ29tS2V5LCBJdGVtLCBJdGVtUXVlcnksIExvY0tleUFycmF5LCBQcmlLZXkgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCJAZmplbGwvY2xpZW50LWFwaVwiO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCJAZmplbGwvcmVnaXN0cnlcIjtcbmltcG9ydCB7IENhY2hlTWFwIH0gZnJvbSBcIi4vQ2FjaGVNYXBcIjtcbmltcG9ydCB7IGNyZWF0ZUNhY2hlQ29udGV4dCB9IGZyb20gXCIuL0NhY2hlQ29udGV4dFwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi9ldmVudHMvQ2FjaGVFdmVudEVtaXR0ZXJcIjtcblxuLy8gSW1wb3J0IGFsbCBvcGVyYXRpb24gZnVuY3Rpb25zXG5pbXBvcnQgeyBhbGwgfSBmcm9tIFwiLi9vcHMvYWxsXCI7XG5pbXBvcnQgeyBvbmUgfSBmcm9tIFwiLi9vcHMvb25lXCI7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tIFwiLi9vcHMvY3JlYXRlXCI7XG5pbXBvcnQgeyBnZXQgfSBmcm9tIFwiLi9vcHMvZ2V0XCI7XG5pbXBvcnQgeyByZXRyaWV2ZSB9IGZyb20gXCIuL29wcy9yZXRyaWV2ZVwiO1xuaW1wb3J0IHsgcmVtb3ZlIH0gZnJvbSBcIi4vb3BzL3JlbW92ZVwiO1xuaW1wb3J0IHsgdXBkYXRlIH0gZnJvbSBcIi4vb3BzL3VwZGF0ZVwiO1xuaW1wb3J0IHsgYWN0aW9uIH0gZnJvbSBcIi4vb3BzL2FjdGlvblwiO1xuaW1wb3J0IHsgYWxsQWN0aW9uIH0gZnJvbSBcIi4vb3BzL2FsbEFjdGlvblwiO1xuaW1wb3J0IHsgZmFjZXQgfSBmcm9tIFwiLi9vcHMvZmFjZXRcIjtcbmltcG9ydCB7IGFsbEZhY2V0IH0gZnJvbSBcIi4vb3BzL2FsbEZhY2V0XCI7XG5pbXBvcnQgeyBmaW5kIH0gZnJvbSBcIi4vb3BzL2ZpbmRcIjtcbmltcG9ydCB7IGZpbmRPbmUgfSBmcm9tIFwiLi9vcHMvZmluZE9uZVwiO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSBcIi4vb3BzL3NldFwiO1xuaW1wb3J0IHsgcmVzZXQgfSBmcm9tIFwiLi9vcHMvcmVzZXRcIjtcbmltcG9ydCB7IE9wdGlvbnMgfSBmcm9tIFwiLi9PcHRpb25zXCI7XG5pbXBvcnQgeyBUVExNYW5hZ2VyIH0gZnJvbSBcIi4vdHRsL1RUTE1hbmFnZXJcIjtcbmltcG9ydCB7IEV2aWN0aW9uTWFuYWdlciB9IGZyb20gXCIuL2V2aWN0aW9uL0V2aWN0aW9uTWFuYWdlclwiO1xuaW1wb3J0IHsgQ2FjaGVTdGF0c01hbmFnZXIgfSBmcm9tIFwiLi9DYWNoZVN0YXRzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0aW9uczxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbj4ge1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIHRoZSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBxdWVyeSBmcm9tIGNhY2hlIG9yIEFQSS5cbiAgICogSXRlbXMgYXJlIGNhY2hlZCBhdXRvbWF0aWNhbGx5IGFmdGVyIHJldHJpZXZhbC5cbiAgICovXG4gIGFsbChcbiAgICBxdWVyeT86IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogUHJvbWlzZTxWW10+O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBxdWVyeSBmcm9tIGNhY2hlIG9yIEFQSS5cbiAgICogSXRlbSBpcyBjYWNoZWQgYXV0b21hdGljYWxseSBhZnRlciByZXRyaWV2YWwuXG4gICAqL1xuICBvbmUoXG4gICAgcXVlcnk/OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8ViB8IG51bGw+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGl0ZW0gdmlhIEFQSSBhbmQgY2FjaGVzIGl0LlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogUHJvbWlzZTxWPjtcblxuICAvKipcbiAgICogR2V0cyBhbiBpdGVtIGJ5IGtleSBmcm9tIGNhY2hlIG9yIEFQSSBhbmQgY2FjaGVzIGl0LlxuICAgKi9cbiAgZ2V0KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz5cbiAgKTogUHJvbWlzZTxWIHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbiBpdGVtIGZyb20gY2FjaGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZnJvbSBBUEkuXG4gICAqL1xuICByZXRyaWV2ZShcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+XG4gICk6IFByb21pc2U8ViB8IG51bGw+O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gdmlhIEFQSSBhbmQgZnJvbSBjYWNoZS5cbiAgICovXG4gIHJlbW92ZShcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+XG4gICk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gaXRlbSB2aWEgQVBJIGFuZCBjYWNoZXMgdGhlIHJlc3VsdC5cbiAgICovXG4gIHVwZGF0ZShcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PlxuICApOiBQcm9taXNlPFY+O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiBhY3Rpb24gb24gYW4gaXRlbSB2aWEgQVBJIGFuZCBjYWNoZXMgdGhlIHJlc3VsdC5cbiAgICovXG4gIGFjdGlvbihcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk/OiBhbnlcbiAgKTogUHJvbWlzZTxWPjtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYW4gYWN0aW9uIG9uIGFsbCBpdGVtcyBtYXRjaGluZyBjcml0ZXJpYSB2aWEgQVBJIGFuZCBjYWNoZXMgcmVzdWx0cy5cbiAgICovXG4gIGFsbEFjdGlvbihcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5PzogYW55LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApOiBQcm9taXNlPFZbXT47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgZmFjZXQgcXVlcnkgb24gYW4gaXRlbSB2aWEgQVBJIChwYXNzLXRocm91Z2gsIG5vIGNhY2hpbmcpLlxuICAgKi9cbiAgZmFjZXQoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PlxuICApOiBQcm9taXNlPGFueT47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgZmFjZXQgcXVlcnkgb24gYWxsIGl0ZW1zIG1hdGNoaW5nIGNyaXRlcmlhIHZpYSBBUEkgKHBhc3MtdGhyb3VnaCwgbm8gY2FjaGluZykuXG4gICAqL1xuICBhbGxGYWNldChcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogUHJvbWlzZTxhbnk+O1xuXG4gIC8qKlxuICAgKiBGaW5kcyBpdGVtcyB1c2luZyBhIGZpbmRlciBtZXRob2QgdmlhIEFQSSBhbmQgY2FjaGVzIHJlc3VsdHMuXG4gICAqL1xuICBmaW5kKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKTogUHJvbWlzZTxWW10+O1xuXG4gIC8qKlxuICAgKiBGaW5kcyBhIHNpbmdsZSBpdGVtIHVzaW5nIGEgZmluZGVyIG1ldGhvZCB2aWEgQVBJIGFuZCBjYWNoZXMgcmVzdWx0LlxuICAgKi9cbiAgZmluZE9uZShcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IFByb21pc2U8Vj47XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gaXRlbSBkaXJlY3RseSBpbiBjYWNoZSB3aXRob3V0IEFQSSBjYWxsLlxuICAgKi9cbiAgc2V0KFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IFByb21pc2U8Vj47XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY2FjaGUsIGNsZWFyaW5nIGFsbCBjYWNoZWQgaXRlbXMuXG4gICAqL1xuICByZXNldCgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlT3BlcmF0aW9ucyA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBhcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGNvb3JkaW5hdGU6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBjYWNoZU1hcDogQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBwa1R5cGU6IFMsXG4gICAgb3B0aW9uczogT3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGV2ZW50RW1pdHRlcjogQ2FjaGVFdmVudEVtaXR0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICB0dGxNYW5hZ2VyOiBUVExNYW5hZ2VyLFxuICAgIGV2aWN0aW9uTWFuYWdlcjogRXZpY3Rpb25NYW5hZ2VyLFxuICAgIHN0YXRzTWFuYWdlcjogQ2FjaGVTdGF0c01hbmFnZXJcbiAgKTogT3BlcmF0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcblxuICAvLyBDcmVhdGUgdGhlIGNhY2hlIGNvbnRleHQgb25jZSBhbmQgcmV1c2UgaXQgYWNyb3NzIGFsbCBvcGVyYXRpb25zXG4gIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYWNoZUNvbnRleHQoYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCBvcHRpb25zLCBldmVudEVtaXR0ZXIsIHR0bE1hbmFnZXIsIGV2aWN0aW9uTWFuYWdlciwgc3RhdHNNYW5hZ2VyKTtcblxuICByZXR1cm4ge1xuICAgIGFsbDogKHF1ZXJ5LCBsb2NhdGlvbnMpID0+IGFsbChxdWVyeSwgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIG9uZTogKHF1ZXJ5LCBsb2NhdGlvbnMpID0+IG9uZShxdWVyeSwgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGNyZWF0ZTogKGl0ZW0sIGxvY2F0aW9ucykgPT4gY3JlYXRlKGl0ZW0sIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBnZXQ6IChrZXkpID0+IGdldChrZXksIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgcmV0cmlldmU6IChrZXkpID0+IHJldHJpZXZlKGtleSwgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICByZW1vdmU6IChrZXkpID0+IHJlbW92ZShrZXksIGNvbnRleHQpLnRoZW4oKGN0eCkgPT4gdW5kZWZpbmVkKSxcbiAgICB1cGRhdGU6IChrZXksIGl0ZW0pID0+IHVwZGF0ZShrZXksIGl0ZW0sIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgYWN0aW9uOiAoa2V5LCBhY3Rpb25OYW1lLCBib2R5KSA9PiBhY3Rpb24oa2V5LCBhY3Rpb25OYW1lLCBib2R5LCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGFsbEFjdGlvbjogKGFjdGlvbk5hbWUsIGJvZHksIGxvY2F0aW9ucykgPT4gYWxsQWN0aW9uKGFjdGlvbk5hbWUsIGJvZHksIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBmYWNldDogKGtleSwgZmFjZXROYW1lLCBwYXJhbXMpID0+IGZhY2V0KGtleSwgZmFjZXROYW1lLCBwYXJhbXMsIGNvbnRleHQpLnRoZW4ocmVzdWx0ID0+IHJlc3VsdCksXG4gICAgYWxsRmFjZXQ6IChmYWNldE5hbWUsIHBhcmFtcywgbG9jYXRpb25zKSA9PiBhbGxGYWNldChmYWNldE5hbWUsIHBhcmFtcywgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKHJlc3VsdCA9PiByZXN1bHQpLFxuICAgIGZpbmQ6IChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zKSA9PiBmaW5kKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgZmluZE9uZTogKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMpID0+IGZpbmRPbmUoZmluZGVyLCBwYXJhbXMsIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBzZXQ6IChrZXksIGl0ZW0pID0+IHNldChrZXksIGl0ZW0sIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgcmVzZXQ6ICgpID0+IHJlc2V0KGNvb3JkaW5hdGUsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKVxuICB9O1xufTtcbiIsImltcG9ydCB7XG4gIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgRXZpY3Rpb25Db250ZXh0LFxuICBFdmljdGlvblN0cmF0ZWd5XG59IGZyb20gJy4vRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQgeyBlc3RpbWF0ZVZhbHVlU2l6ZSB9IGZyb20gJy4uL3V0aWxzL0NhY2hlU2l6ZSc7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ0V2aWN0aW9uTWFuYWdlcicpO1xuXG4vKipcbiAqIE1hbmFnZXMgZXZpY3Rpb24gbG9naWMgaW5kZXBlbmRlbnRseSBvZiBDYWNoZU1hcCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBUaGlzIGNsYXNzIGNvb3JkaW5hdGVzIGJldHdlZW4gZXZpY3Rpb24gc3RyYXRlZ2llcyBhbmQgY2FjaGUgbWV0YWRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmljdGlvbk1hbmFnZXIge1xuICBwcml2YXRlIGV2aWN0aW9uU3RyYXRlZ3k6IEV2aWN0aW9uU3RyYXRlZ3kgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGV2aWN0aW9uU3RyYXRlZ3k/OiBFdmljdGlvblN0cmF0ZWd5KSB7XG4gICAgdGhpcy5ldmljdGlvblN0cmF0ZWd5ID0gZXZpY3Rpb25TdHJhdGVneSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvciB1cGRhdGUgdGhlIGV2aWN0aW9uIHN0cmF0ZWd5XG4gICAqIEBwYXJhbSBzdHJhdGVneSAtIFRoZSBldmljdGlvbiBzdHJhdGVneSB0byB1c2VcbiAgICovXG4gIHB1YmxpYyBzZXRFdmljdGlvblN0cmF0ZWd5KHN0cmF0ZWd5OiBFdmljdGlvblN0cmF0ZWd5IHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIGxvZ2dlci5kZWJ1ZygnRXZpY3Rpb24gc3RyYXRlZ3kgdXBkYXRlZCcsIHtcbiAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneT8uZ2V0U3RyYXRlZ3lOYW1lKCkgfHwgJ25vbmUnXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGV2aWN0aW9uIHN0cmF0ZWd5IG5hbWVcbiAgICogQHJldHVybnMgU3RyYXRlZ3kgbmFtZSBvciBudWxsIGlmIG5vIGV2aWN0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0RXZpY3Rpb25TdHJhdGVneU5hbWUoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuZXZpY3Rpb25TdHJhdGVneT8uZ2V0U3RyYXRlZ3lOYW1lKCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaXRlbSBhY2Nlc3MgLSB1cGRhdGUgbWV0YWRhdGEgZm9yIGV2aWN0aW9uIHN0cmF0ZWd5XG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgb25JdGVtQWNjZXNzZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5ldmljdGlvblN0cmF0ZWd5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1BY2Nlc3NlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIGV2aWN0aW9uIHN0cmF0ZWd5IG9uSXRlbUFjY2Vzc2VkJywgeyBrZXksIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaXRlbSBhZGRpdGlvbiAtIHVwZGF0ZSBtZXRhZGF0YSBhbmQgcGVyZm9ybSBldmljdGlvbiBpZiBuZWVkZWRcbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSB2YWx1ZSAtIEl0ZW0gdmFsdWUgKGZvciBzaXplIGVzdGltYXRpb24pXG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gQ2FjaGUgbWV0YWRhdGEgcHJvdmlkZXJcbiAgICogQHJldHVybnMgQXJyYXkgb2Yga2V5cyB0aGF0IHdlcmUgZXZpY3RlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIG9uSXRlbUFkZGVkPFQ+KFxuICAgIGtleTogc3RyaW5nLFxuICAgIHZhbHVlOiBULFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlclxuICApOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgZXZpY3RlZEtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgICBpZiAoIXRoaXMuZXZpY3Rpb25TdHJhdGVneSkge1xuICAgICAgcmV0dXJuIGV2aWN0ZWRLZXlzO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUodmFsdWUpO1xuICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMuY3JlYXRlRXZpY3Rpb25Db250ZXh0KG1ldGFkYXRhUHJvdmlkZXIsIGVzdGltYXRlZFNpemUpO1xuXG4gICAgICAvLyBQZXJmb3JtIGV2aWN0aW9uIGJlZm9yZSBhZGRpbmcgdGhlIG5ldyBpdGVtIGlmIG5lZWRlZFxuICAgICAgY29uc3Qga2V5c1RvRXZpY3QgPSBhd2FpdCB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kuc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCk7XG5cbiAgICAgIGZvciAoY29uc3QgZXZpY3RLZXkgb2Yga2V5c1RvRXZpY3QpIHtcbiAgICAgICAgLy8gTGV0IHRoZSBzdHJhdGVneSBrbm93IGFib3V0IHRoZSByZW1vdmFsXG4gICAgICAgIGF3YWl0IHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1SZW1vdmVkKGV2aWN0S2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICAgICAgZXZpY3RlZEtleXMucHVzaChldmljdEtleSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBhZGQgbWV0YWRhdGEgZm9yIHRoZSBuZXcgaXRlbVxuICAgICAgYXdhaXQgdGhpcy5ldmljdGlvblN0cmF0ZWd5Lm9uSXRlbUFkZGVkKGtleSwgZXN0aW1hdGVkU2l6ZSwgbWV0YWRhdGFQcm92aWRlcik7XG5cbiAgICAgIGlmIChldmljdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnSXRlbXMgZXZpY3RlZCBkdXJpbmcgYWRkaXRpb24nLCB7XG4gICAgICAgICAgbmV3S2V5OiBrZXksXG4gICAgICAgICAgZXZpY3RlZEtleXMsXG4gICAgICAgICAgc3RyYXRlZ3k6IHRoaXMuZXZpY3Rpb25TdHJhdGVneS5nZXRTdHJhdGVneU5hbWUoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBldmljdGlvbiBzdHJhdGVneSBvbkl0ZW1BZGRlZCcsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZpY3RlZEtleXM7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGl0ZW0gcmVtb3ZhbCAtIGNsZWFuIHVwIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqL1xuICBwdWJsaWMgb25JdGVtUmVtb3ZlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5ldmljdGlvblN0cmF0ZWd5Lm9uSXRlbVJlbW92ZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBldmljdGlvbiBzdHJhdGVneSBvbkl0ZW1SZW1vdmVkJywgeyBrZXksIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIG1hbnVhbCBldmljdGlvbiBjaGVja1xuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGtleXMgdGhhdCB3ZXJlIGV2aWN0ZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwZXJmb3JtRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGV2aWN0ZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLmV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBldmljdGVkS2V5cztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMuY3JlYXRlRXZpY3Rpb25Db250ZXh0KG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgICAgY29uc3Qga2V5c1RvRXZpY3QgPSBhd2FpdCB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kuc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCk7XG5cbiAgICAgIGZvciAoY29uc3QgZXZpY3RLZXkgb2Yga2V5c1RvRXZpY3QpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5ldmljdGlvblN0cmF0ZWd5Lm9uSXRlbVJlbW92ZWQoZXZpY3RLZXksIG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgICAgICBldmljdGVkS2V5cy5wdXNoKGV2aWN0S2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2aWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdNYW51YWwgZXZpY3Rpb24gcGVyZm9ybWVkJywge1xuICAgICAgICAgIGV2aWN0ZWRLZXlzLFxuICAgICAgICAgIHN0cmF0ZWd5OiB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kuZ2V0U3RyYXRlZ3lOYW1lKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gbWFudWFsIGV2aWN0aW9uJywgeyBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZpY3RlZEtleXM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgZXZpY3Rpb24gaXMgc3VwcG9ydGVkIChpLmUuLCBzdHJhdGVneSBpcyBzZXQpXG4gICAqIEByZXR1cm5zIFRydWUgaWYgZXZpY3Rpb24gaXMgc3VwcG9ydGVkXG4gICAqL1xuICBwdWJsaWMgaXNFdmljdGlvblN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ldmljdGlvblN0cmF0ZWd5ICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBldmljdGlvbiBjb250ZXh0IGZyb20gY3VycmVudCBjYWNoZSBzdGF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqIEBwYXJhbSBuZXdJdGVtU2l6ZSAtIFNpemUgb2YgaXRlbSBiZWluZyBhZGRlZCAob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIEV2aWN0aW9uIGNvbnRleHRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlRXZpY3Rpb25Db250ZXh0KFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBuZXdJdGVtU2l6ZT86IG51bWJlclxuICApOiBQcm9taXNlPEV2aWN0aW9uQ29udGV4dD4ge1xuICAgIGNvbnN0IGN1cnJlbnRTaXplID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRDdXJyZW50U2l6ZSgpO1xuICAgIGNvbnN0IGxpbWl0cyA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0U2l6ZUxpbWl0cygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRTaXplLFxuICAgICAgbGltaXRzLFxuICAgICAgbmV3SXRlbVNpemVcbiAgICB9O1xuICB9XG59XG4iLCIvKipcbiAqIEJhc2UgY29uZmlndXJhdGlvbiBpbnRlcmZhY2UgZm9yIGV2aWN0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmljdGlvblN0cmF0ZWd5Q29uZmlnIHtcbiAgLyoqIFN0cmF0ZWd5IHR5cGUgaWRlbnRpZmllciAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgTEZVIGV2aWN0aW9uIHN0cmF0ZWd5IHdpdGggZnJlcXVlbmN5IHNrZXRjaGluZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExGVUNvbmZpZyBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3lDb25maWcge1xuICByZWFkb25seSB0eXBlOiAnbGZ1JztcbiAgLyoqIERlY2F5IGZhY3RvciBmb3IgYWdpbmcgZnJlcXVlbmN5IGNvdW50cyAoMC4wIHRvIDEuMCwgZGVmYXVsdDogMC4xKSAqL1xuICBkZWNheUZhY3Rvcj86IG51bWJlcjtcbiAgLyoqIEZyZXF1ZW5jeSBkZWNheSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDYwMDAwKSAqL1xuICBkZWNheUludGVydmFsPzogbnVtYmVyO1xuICAvKiogV2lkdGggb2YgdGhlIENvdW50LU1pbiBTa2V0Y2ggKGRlZmF1bHQ6IDEwMjQpICovXG4gIHNrZXRjaFdpZHRoPzogbnVtYmVyO1xuICAvKiogRGVwdGggb2YgdGhlIENvdW50LU1pbiBTa2V0Y2ggKGRlZmF1bHQ6IDQpICovXG4gIHNrZXRjaERlcHRoPzogbnVtYmVyO1xuICAvKiogV2hldGhlciB0byB1c2UgcHJvYmFiaWxpc3RpYyBjb3VudGluZyAoZGVmYXVsdDogdHJ1ZSkgKi9cbiAgdXNlUHJvYmFiaWxpc3RpY0NvdW50aW5nPzogYm9vbGVhbjtcbiAgLyoqIE1pbmltdW0gZnJlcXVlbmN5IHRocmVzaG9sZCBiZWZvcmUgZGVjYXkgKGRlZmF1bHQ6IDEpICovXG4gIG1pbkZyZXF1ZW5jeVRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBMUlUgZXZpY3Rpb24gc3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMUlVDb25maWcgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5Q29uZmlnIHtcbiAgcmVhZG9ubHkgdHlwZTogJ2xydSc7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgRklGTyBldmljdGlvbiBzdHJhdGVneVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZJRk9Db25maWcgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5Q29uZmlnIHtcbiAgcmVhZG9ubHkgdHlwZTogJ2ZpZm8nO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIE1SVSBldmljdGlvbiBzdHJhdGVneVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1SVUNvbmZpZyBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3lDb25maWcge1xuICByZWFkb25seSB0eXBlOiAnbXJ1Jztcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBSYW5kb20gZXZpY3Rpb24gc3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSYW5kb21Db25maWcgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5Q29uZmlnIHtcbiAgcmVhZG9ubHkgdHlwZTogJ3JhbmRvbSc7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgQVJDIGV2aWN0aW9uIHN0cmF0ZWd5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQVJDQ29uZmlnIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneUNvbmZpZyB7XG4gIHJlYWRvbmx5IHR5cGU6ICdhcmMnO1xuICAvKiogTWF4aW11bSBjYWNoZSBzaXplIGZvciBBUkMgY2FsY3VsYXRpb25zICovXG4gIG1heENhY2hlU2l6ZT86IG51bWJlcjtcbiAgLyoqIEZyZXF1ZW5jeSB0aHJlc2hvbGQgZm9yIGNsYXNzaWZ5aW5nIGl0ZW1zIGFzIFwiZnJlcXVlbnRcIiB2cyBcInJlY2VudFwiIChkZWZhdWx0OiAyKSAqL1xuICBmcmVxdWVuY3lUaHJlc2hvbGQ/OiBudW1iZXI7XG4gIC8qKiBVc2UgZW5oYW5jZWQgZnJlcXVlbmN5IHRyYWNraW5nIHdpdGggZGVjYXkgKGRlZmF1bHQ6IHRydWUpICovXG4gIHVzZUVuaGFuY2VkRnJlcXVlbmN5PzogYm9vbGVhbjtcbiAgLyoqIERlY2F5IGZhY3RvciBmb3IgYWdpbmcgZnJlcXVlbmN5IHNjb3JlcyAoZGVmYXVsdDogMC4wNSkgKi9cbiAgZnJlcXVlbmN5RGVjYXlGYWN0b3I/OiBudW1iZXI7XG4gIC8qKiBEZWNheSBpbnRlcnZhbCBmb3IgZnJlcXVlbmN5IHNjb3JlcyAoZGVmYXVsdDogNjAwMDAwIC0gMTAgbWludXRlcykgKi9cbiAgZnJlcXVlbmN5RGVjYXlJbnRlcnZhbD86IG51bWJlcjtcbiAgLyoqIFVzZSBmcmVxdWVuY3ktd2VpZ2h0ZWQgc2VsZWN0aW9uIHdpdGhpbiBUMS9UMiBsaXN0cyAoZGVmYXVsdDogdHJ1ZSkgKi9cbiAgdXNlRnJlcXVlbmN5V2VpZ2h0ZWRTZWxlY3Rpb24/OiBib29sZWFuO1xuICAvKiogQWRhcHRpdmUgbGVhcm5pbmcgcmF0ZSBmb3IgdGFyZ2V0IHNpemUgYWRqdXN0bWVudHMgKGRlZmF1bHQ6IDEuMCkgKi9cbiAgYWRhcHRpdmVMZWFybmluZ1JhdGU/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgMlEgZXZpY3Rpb24gc3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUd29RdWV1ZUNvbmZpZyBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3lDb25maWcge1xuICByZWFkb25seSB0eXBlOiAnMnEnO1xuICAvKiogTWF4aW11bSBjYWNoZSBzaXplIGZvciAyUSBjYWxjdWxhdGlvbnMgKi9cbiAgbWF4Q2FjaGVTaXplPzogbnVtYmVyO1xuICAvKiogVXNlIGZyZXF1ZW5jeS1iYXNlZCBwcm9tb3Rpb24gZnJvbSByZWNlbnQgdG8gaG90IHF1ZXVlIChkZWZhdWx0OiB0cnVlKSAqL1xuICB1c2VGcmVxdWVuY3lQcm9tb3Rpb24/OiBib29sZWFuO1xuICAvKiogTWluaW11bSBhY2Nlc3MgZnJlcXVlbmN5IHJlcXVpcmVkIGZvciBwcm9tb3Rpb24gdG8gaG90IHF1ZXVlIChkZWZhdWx0OiAyKSAqL1xuICBwcm9tb3Rpb25UaHJlc2hvbGQ/OiBudW1iZXI7XG4gIC8qKiBEZWNheSBmYWN0b3IgZm9yIGFnaW5nIGZyZXF1ZW5jeSBzY29yZXMgaW4gaG90IHF1ZXVlIChkZWZhdWx0OiAwLjA1KSAqL1xuICBob3RRdWV1ZURlY2F5RmFjdG9yPzogbnVtYmVyO1xuICAvKiogRGVjYXkgaW50ZXJ2YWwgZm9yIGhvdCBxdWV1ZSBmcmVxdWVuY3kgc2NvcmVzIChkZWZhdWx0OiAzMDAwMDAgLSA1IG1pbnV0ZXMpICovXG4gIGhvdFF1ZXVlRGVjYXlJbnRlcnZhbD86IG51bWJlcjtcbiAgLyoqIFVzZSBmcmVxdWVuY3ktd2VpZ2h0ZWQgTFJVIGluIGhvdCBxdWV1ZSBpbnN0ZWFkIG9mIHB1cmUgTFJVIChkZWZhdWx0OiB0cnVlKSAqL1xuICB1c2VGcmVxdWVuY3lXZWlnaHRlZExSVT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVW5pb24gdHlwZSBmb3IgYWxsIGV2aWN0aW9uIHN0cmF0ZWd5IGNvbmZpZ3VyYXRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzID1cbiAgfCBMRlVDb25maWdcbiAgfCBMUlVDb25maWdcbiAgfCBGSUZPQ29uZmlnXG4gIHwgTVJVQ29uZmlnXG4gIHwgUmFuZG9tQ29uZmlnXG4gIHwgQVJDQ29uZmlnXG4gIHwgVHdvUXVldWVDb25maWc7XG5cbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uIHZhbHVlc1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9MRlVfQ09ORklHOiBMRlVDb25maWcgPSB7XG4gIHR5cGU6ICdsZnUnLFxuICBkZWNheUZhY3RvcjogMC4xLFxuICBkZWNheUludGVydmFsOiA2MDAwMCwgLy8gMSBtaW51dGVcbiAgc2tldGNoV2lkdGg6IDEwMjQsXG4gIHNrZXRjaERlcHRoOiA0LFxuICB1c2VQcm9iYWJpbGlzdGljQ291bnRpbmc6IHRydWUsXG4gIG1pbkZyZXF1ZW5jeVRocmVzaG9sZDogMVxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQVJDX0NPTkZJRzogQVJDQ29uZmlnID0ge1xuICB0eXBlOiAnYXJjJyxcbiAgbWF4Q2FjaGVTaXplOiAxMDAwLFxuICBmcmVxdWVuY3lUaHJlc2hvbGQ6IDIsXG4gIHVzZUVuaGFuY2VkRnJlcXVlbmN5OiB0cnVlLFxuICBmcmVxdWVuY3lEZWNheUZhY3RvcjogMC4wNSxcbiAgZnJlcXVlbmN5RGVjYXlJbnRlcnZhbDogNjAwMDAwLCAvLyAxMCBtaW51dGVzXG4gIHVzZUZyZXF1ZW5jeVdlaWdodGVkU2VsZWN0aW9uOiB0cnVlLFxuICBhZGFwdGl2ZUxlYXJuaW5nUmF0ZTogMS4wXG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UV09fUVVFVUVfQ09ORklHOiBUd29RdWV1ZUNvbmZpZyA9IHtcbiAgdHlwZTogJzJxJyxcbiAgbWF4Q2FjaGVTaXplOiAxMDAwLFxuICB1c2VGcmVxdWVuY3lQcm9tb3Rpb246IHRydWUsXG4gIHByb21vdGlvblRocmVzaG9sZDogMixcbiAgaG90UXVldWVEZWNheUZhY3RvcjogMC4wNSxcbiAgaG90UXVldWVEZWNheUludGVydmFsOiAzMDAwMDAsIC8vIDUgbWludXRlc1xuICB1c2VGcmVxdWVuY3lXZWlnaHRlZExSVTogdHJ1ZVxufTtcbiIsIi8qKlxuICogTWV0YWRhdGEgZm9yIHRyYWNraW5nIGNhY2hlIGl0ZW0gdXNhZ2UgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWNoZUl0ZW1NZXRhZGF0YSB7XG4gIC8qKiBXaGVuIHRoZSBpdGVtIHdhcyBmaXJzdCBhZGRlZCB0byBjYWNoZSAqL1xuICBhZGRlZEF0OiBudW1iZXI7XG4gIC8qKiBXaGVuIHRoZSBpdGVtIHdhcyBsYXN0IGFjY2Vzc2VkICovXG4gIGxhc3RBY2Nlc3NlZEF0OiBudW1iZXI7XG4gIC8qKiBOdW1iZXIgb2YgdGltZXMgdGhlIGl0ZW0gaGFzIGJlZW4gYWNjZXNzZWQgKi9cbiAgYWNjZXNzQ291bnQ6IG51bWJlcjtcbiAgLyoqIEVzdGltYXRlZCBzaXplIG9mIHRoZSBpdGVtIGluIGJ5dGVzICovXG4gIGVzdGltYXRlZFNpemU6IG51bWJlcjtcbiAgLyoqIEl0ZW0ga2V5IGZvciBpZGVudGlmaWNhdGlvbiAqL1xuICBrZXk6IHN0cmluZztcbiAgLyoqIEZyZXF1ZW5jeSBzY29yZSB3aXRoIGRlY2F5IGFwcGxpZWQgKGZvciBMRlUgd2l0aCBza2V0Y2hpbmcpICovXG4gIGZyZXF1ZW5jeVNjb3JlPzogbnVtYmVyO1xuICAvKiogTGFzdCB0aW1lIGZyZXF1ZW5jeSB3YXMgdXBkYXRlZCAoZm9yIGRlY2F5IGNhbGN1bGF0aW9ucykgKi9cbiAgbGFzdEZyZXF1ZW5jeVVwZGF0ZT86IG51bWJlcjtcbiAgLyoqIFJhdyBmcmVxdWVuY3kgY291bnQgYmVmb3JlIGRlY2F5ICovXG4gIHJhd0ZyZXF1ZW5jeT86IG51bWJlcjtcbiAgLyoqIEFkZGl0aW9uYWwgc3RyYXRlZ3ktc3BlY2lmaWMgbWV0YWRhdGEgKi9cbiAgc3RyYXRlZ3lEYXRhPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIENhY2hlTWFwIGltcGxlbWVudGF0aW9ucyB0byBzdXBwb3J0IG1ldGFkYXRhIHN0b3JhZ2VcbiAqIFRoaXMgYWxsb3dzIGV2aWN0aW9uIHN0cmF0ZWdpZXMgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhIGluZGVwZW5kZW50bHkgb2YgdGhlIHN0b3JhZ2UgbWVjaGFuaXNtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIEdldCBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpdGVtXG4gICAqIEBwYXJhbSBrZXkgLSBJdGVtIGtleVxuICAgKiBAcmV0dXJucyBNZXRhZGF0YSBpZiBleGlzdHMsIG51bGwgb3RoZXJ3aXNlXG4gICAqL1xuICBnZXRNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8Q2FjaGVJdGVtTWV0YWRhdGEgfCBudWxsPjtcblxuICAvKipcbiAgICogU2V0IG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGl0ZW1cbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIHRvIHN0b3JlXG4gICAqL1xuICBzZXRNZXRhZGF0YShrZXk6IHN0cmluZywgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogRGVsZXRlIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGl0ZW1cbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqL1xuICBkZWxldGVNZXRhZGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbWV0YWRhdGEgZW50cmllc1xuICAgKiBAcmV0dXJucyBNYXAgb2YgYWxsIG1ldGFkYXRhIGVudHJpZXNcbiAgICovXG4gIGdldEFsbE1ldGFkYXRhKCk6IFByb21pc2U8TWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+PjtcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG1ldGFkYXRhXG4gICAqL1xuICBjbGVhck1ldGFkYXRhKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGNhY2hlIHNpemUgaW5mb3JtYXRpb25cbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggY3VycmVudCBzaXplIG1ldHJpY3NcbiAgICovXG4gIGdldEN1cnJlbnRTaXplKCk6IFByb21pc2U8e1xuICAgIGl0ZW1Db3VudDogbnVtYmVyO1xuICAgIHNpemVCeXRlczogbnVtYmVyO1xuICB9PjtcblxuICAvKipcbiAgICogR2V0IGNhY2hlIHNpemUgbGltaXRzXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHNpemUgbGltaXRzIChudWxsIG1lYW5zIHVubGltaXRlZClcbiAgICovXG4gIGdldFNpemVMaW1pdHMoKTogUHJvbWlzZTx7XG4gICAgbWF4SXRlbXM6IG51bWJlciB8IG51bGw7XG4gICAgbWF4U2l6ZUJ5dGVzOiBudW1iZXIgfCBudWxsO1xuICB9Pjtcbn1cblxuLyoqXG4gKiBDb250ZXh0IHByb3ZpZGVkIHRvIGV2aWN0aW9uIHN0cmF0ZWdpZXMgZm9yIGRlY2lzaW9uIG1ha2luZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEV2aWN0aW9uQ29udGV4dCB7XG4gIC8qKiBDdXJyZW50IGNhY2hlIHNpemUgaW5mb3JtYXRpb24gKi9cbiAgY3VycmVudFNpemU6IHtcbiAgICBpdGVtQ291bnQ6IG51bWJlcjtcbiAgICBzaXplQnl0ZXM6IG51bWJlcjtcbiAgfTtcbiAgLyoqIENhY2hlIHNpemUgbGltaXRzICovXG4gIGxpbWl0czoge1xuICAgIG1heEl0ZW1zOiBudW1iZXIgfCBudWxsO1xuICAgIG1heFNpemVCeXRlczogbnVtYmVyIHwgbnVsbDtcbiAgfTtcbiAgLyoqIFNpemUgb2YgdGhlIGl0ZW0gYmVpbmcgYWRkZWQgKGZvciBwcm9hY3RpdmUgZXZpY3Rpb24pICovXG4gIG5ld0l0ZW1TaXplPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNhY2hlIGV2aWN0aW9uIHN0cmF0ZWdpZXMuXG4gKiBEZWZpbmVzIHRoZSBjb3JlIGNvbnRyYWN0IHRoYXQgYWxsIGV2aWN0aW9uIHBvbGljaWVzIG11c3QgaW1wbGVtZW50LlxuICpcbiAqIEV2aWN0aW9uIHN0cmF0ZWdpZXMgYXJlIG5vdyBjb21wbGV0ZWx5IGluZGVwZW5kZW50IG9mIENhY2hlTWFwIGltcGxlbWVudGF0aW9uc1xuICogYW5kIGludGVyYWN0IHRocm91Z2ggdGhlIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgLyoqXG4gICAqIFNlbGVjdCB3aGljaCBpdGVtcyBzaG91bGQgYmUgZXZpY3RlZCBiYXNlZCBvbiB0aGUgc3RyYXRlZ3kgYW5kIGNvbnRleHRcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBQcm92aWRlciBmb3IgYWNjZXNzaW5nIGNhY2hlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gQ3VycmVudCBjYWNoZSBzdGF0ZSBhbmQgbGltaXRzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGtleXMgdG8gZXZpY3QgKGVtcHR5IGFycmF5IGlmIG5vIGV2aWN0aW9uIG5lZWRlZClcbiAgICovXG4gIGFic3RyYWN0IHNlbGVjdEZvckV2aWN0aW9uKFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBjb250ZXh0OiBFdmljdGlvbkNvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT47XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBtZXRhZGF0YSB3aGVuIGFuIGl0ZW0gaXMgYWNjZXNzZWRcbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gUHJvdmlkZXIgZm9yIGFjY2Vzc2luZyBjYWNoZSBtZXRhZGF0YVxuICAgKi9cbiAgYWJzdHJhY3Qgb25JdGVtQWNjZXNzZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBtZXRhZGF0YSB3aGVuIGFuIGl0ZW0gaXMgYWRkZWRcbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSBlc3RpbWF0ZWRTaXplIC0gRXN0aW1hdGVkIHNpemUgb2YgdGhlIGl0ZW0gaW4gYnl0ZXNcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBQcm92aWRlciBmb3IgYWNjZXNzaW5nIGNhY2hlIG1ldGFkYXRhXG4gICAqL1xuICBhYnN0cmFjdCBvbkl0ZW1BZGRlZChrZXk6IHN0cmluZywgZXN0aW1hdGVkU2l6ZTogbnVtYmVyLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZFxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBQcm92aWRlciBmb3IgYWNjZXNzaW5nIGNhY2hlIG1ldGFkYXRhXG4gICAqL1xuICBhYnN0cmFjdCBvbkl0ZW1SZW1vdmVkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUvaWRlbnRpZmllciBvZiB0aGlzIGV2aWN0aW9uIHN0cmF0ZWd5XG4gICAqIEByZXR1cm5zIFN0cmluZyBpZGVudGlmaWVyIGZvciB0aGUgc3RyYXRlZ3lcbiAgICovXG4gIGFic3RyYWN0IGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBldmljdGlvbiBpcyBuZWVkZWQgYmFzZWQgb24gY3VycmVudCBjb250ZXh0XG4gICAqIEBwYXJhbSBjb250ZXh0IC0gQ3VycmVudCBjYWNoZSBzdGF0ZSBhbmQgbGltaXRzXG4gICAqIEByZXR1cm5zIFRydWUgaWYgZXZpY3Rpb24gc2hvdWxkIG9jY3VyXG4gICAqL1xuICBwcm90ZWN0ZWQgaXNFdmljdGlvbk5lZWRlZChjb250ZXh0OiBFdmljdGlvbkNvbnRleHQpOiBib29sZWFuIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTaXplLCBsaW1pdHMsIG5ld0l0ZW1TaXplID0gMCB9ID0gY29udGV4dDtcblxuICAgIC8vIENoZWNrIGl0ZW0gY291bnQgbGltaXRcbiAgICBpZiAobGltaXRzLm1heEl0ZW1zICE9PSBudWxsICYmIGN1cnJlbnRTaXplLml0ZW1Db3VudCA+PSBsaW1pdHMubWF4SXRlbXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHNpemUgbGltaXQgKGluY2x1ZGluZyBwb3RlbnRpYWwgbmV3IGl0ZW0pXG4gICAgaWYgKGxpbWl0cy5tYXhTaXplQnl0ZXMgIT09IG51bGwgJiZcbiAgICAgIChjdXJyZW50U2l6ZS5zaXplQnl0ZXMgKyBuZXdJdGVtU2l6ZSkgPiBsaW1pdHMubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGhvdyBtYW55IGl0ZW1zIG5lZWQgdG8gYmUgZXZpY3RlZFxuICAgKiBAcGFyYW0gY29udGV4dCAtIEN1cnJlbnQgY2FjaGUgc3RhdGUgYW5kIGxpbWl0c1xuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgaXRlbXMgdGhhdCBzaG91bGQgYmUgZXZpY3RlZFxuICAgKi9cbiAgcHJvdGVjdGVkIGNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dDogRXZpY3Rpb25Db250ZXh0KTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTaXplLCBsaW1pdHMsIG5ld0l0ZW1TaXplID0gMCB9ID0gY29udGV4dDtcbiAgICBsZXQgZXZpY3Rpb25Db3VudCA9IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgYmFzZWQgb24gaXRlbSBjb3VudCBsaW1pdFxuICAgIGlmIChsaW1pdHMubWF4SXRlbXMgIT09IG51bGwgJiYgY3VycmVudFNpemUuaXRlbUNvdW50ID49IGxpbWl0cy5tYXhJdGVtcykge1xuICAgICAgZXZpY3Rpb25Db3VudCA9IE1hdGgubWF4KGV2aWN0aW9uQ291bnQsIGN1cnJlbnRTaXplLml0ZW1Db3VudCAtIGxpbWl0cy5tYXhJdGVtcyArIDEpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBiYXNlZCBvbiBzaXplIGxpbWl0ICh0aGlzIGlzIG1vcmUgY29tcGxleCBhbmQgYXBwcm94aW1hdGUpXG4gICAgaWYgKGxpbWl0cy5tYXhTaXplQnl0ZXMgIT09IG51bGwgJiZcbiAgICAgIChjdXJyZW50U2l6ZS5zaXplQnl0ZXMgKyBuZXdJdGVtU2l6ZSkgPiBsaW1pdHMubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICAvLyBDb25zZXJ2YXRpdmUgZXN0aW1hdGU6IGV2aWN0IGF0IGxlYXN0IDEgaXRlbSwgcG9zc2libHkgbW9yZVxuICAgICAgY29uc3QgZXhjZXNzQnl0ZXMgPSAoY3VycmVudFNpemUuc2l6ZUJ5dGVzICsgbmV3SXRlbVNpemUpIC0gbGltaXRzLm1heFNpemVCeXRlcztcbiAgICAgIGNvbnN0IGF2Z0l0ZW1TaXplID0gY3VycmVudFNpemUuaXRlbUNvdW50ID4gMCA/IGN1cnJlbnRTaXplLnNpemVCeXRlcyAvIGN1cnJlbnRTaXplLml0ZW1Db3VudCA6IDEwMjQ7XG4gICAgICBjb25zdCBlc3RpbWF0ZWRFdmljdGlvbkNvdW50ID0gTWF0aC5jZWlsKGV4Y2Vzc0J5dGVzIC8gYXZnSXRlbVNpemUpO1xuICAgICAgZXZpY3Rpb25Db3VudCA9IE1hdGgubWF4KGV2aWN0aW9uQ291bnQsIGVzdGltYXRlZEV2aWN0aW9uQ291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBldmljdGlvbkNvdW50O1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBDYWNoZUl0ZW1NZXRhZGF0YSxcbiAgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLFxuICBFdmljdGlvbkNvbnRleHQsXG4gIEV2aWN0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnLi4vRXZpY3Rpb25TdHJhdGVneSc7XG5cbi8qKlxuICogTFJVIChMZWFzdCBSZWNlbnRseSBVc2VkKSBldmljdGlvbiBzdHJhdGVneVxuICogUmVtb3ZlcyB0aGUgaXRlbSB0aGF0IHdhcyBhY2Nlc3NlZCBsb25nZXN0IGFnb1xuICovXG5leHBvcnQgY2xhc3MgTFJVRXZpY3Rpb25TdHJhdGVneSBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBhc3luYyBzZWxlY3RGb3JFdmljdGlvbihcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgY29udGV4dDogRXZpY3Rpb25Db250ZXh0XG4gICk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBjb25zdCBrZXlzVG9FdmljdDogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFNvcnQgYnkgbGFzdEFjY2Vzc2VkQXQgYXNjZW5kaW5nIChvbGRlc3QgZmlyc3QpXG4gICAgY29uc3Qgc29ydGVkRW50cmllcyA9IEFycmF5LmZyb20oYWxsTWV0YWRhdGEuZW50cmllcygpKVxuICAgICAgLnNvcnQoKFssIGFdLCBbLCBiXSkgPT4gYS5sYXN0QWNjZXNzZWRBdCAtIGIubGFzdEFjY2Vzc2VkQXQpO1xuXG4gICAgLy8gVGFrZSB0aGUgb2xkZXN0IGl0ZW1zIHVwIHRvIGV2aWN0aW9uQ291bnRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGV2aWN0aW9uQ291bnQsIHNvcnRlZEVudHJpZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBrZXlzVG9FdmljdC5wdXNoKHNvcnRlZEVudHJpZXNbaV1bMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFjY2Vzc2VkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFkZGVkKGtleTogc3RyaW5nLCBlc3RpbWF0ZWRTaXplOiBudW1iZXIsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZVxuICAgIH07XG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbVJlbW92ZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuXG4gIGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnbHJ1JztcbiAgfVxufVxuIiwiLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9ucyBmb3IgZXZpY3Rpb24gc3RyYXRlZ3kgY29uZmlndXJhdGlvbnNcbiAqL1xuaW1wb3J0IHtcbiAgQVJDQ29uZmlnLFxuICBFdmljdGlvblN0cmF0ZWd5Q29uZmlncyxcbiAgTEZVQ29uZmlnLFxuICBUd29RdWV1ZUNvbmZpZ1xufSBmcm9tICcuL0V2aWN0aW9uU3RyYXRlZ3lDb25maWcnO1xuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGEgbnVtYmVyIGlzIHdpdGhpbiBhIHNwZWNpZmllZCByYW5nZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlclJhbmdlKFxuICB2YWx1ZTogbnVtYmVyLFxuICBtaW46IG51bWJlcixcbiAgbWF4OiBudW1iZXIsXG4gIGZpZWxkTmFtZTogc3RyaW5nXG4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGJlIGEgZmluaXRlIG51bWJlcmApO1xuICB9XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtmaWVsZE5hbWV9IG11c3QgYmUgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSwgZ290ICR7dmFsdWV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIG51bWJlciBpcyBhIHBvc2l0aXZlIGludGVnZXJcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIodmFsdWU6IG51bWJlciwgZmllbGROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGJlIGEgZmluaXRlIG51bWJlcmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtmaWVsZE5hbWV9IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBnb3QgJHt2YWx1ZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbml0aXplcyBMRlUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLCBjb3JyZWN0aW5nIGludmFsaWQgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUxGVUNvbmZpZyhjb25maWc6IFBhcnRpYWw8TEZVQ29uZmlnPik6IFBhcnRpYWw8TEZVQ29uZmlnPiB7XG4gIGNvbnN0IHNhbml0aXplZCA9IHsgLi4uY29uZmlnIH07XG5cbiAgLy8gU2FuaXRpemUgZGVjYXlGYWN0b3IgdG8gYmUgYmV0d2VlbiAwIGFuZCAxXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmRlY2F5RmFjdG9yID09PSAnbnVtYmVyJykge1xuICAgIGlmIChzYW5pdGl6ZWQuZGVjYXlGYWN0b3IgPCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGRlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuZGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuZGVjYXlGYWN0b3IgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLmRlY2F5RmFjdG9yID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKGBkZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmRlY2F5RmFjdG9yfS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgICAgc2FuaXRpemVkLmRlY2F5RmFjdG9yID0gMTtcbiAgICB9XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBkZWNheUludGVydmFsIHRvIGJlIHBvc2l0aXZlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmRlY2F5SW50ZXJ2YWwgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5kZWNheUludGVydmFsIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYGRlY2F5SW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLmRlY2F5SW50ZXJ2YWx9LiBDb3JyZWN0aW5nIHRvIDMwMDAwMC5gKTtcbiAgICBzYW5pdGl6ZWQuZGVjYXlJbnRlcnZhbCA9IDMwMDAwMDsgLy8gNSBtaW51dGVzIGRlZmF1bHRcbiAgfVxuXG4gIC8vIFNhbml0aXplIHNrZXRjaFdpZHRoIHRvIGJlIHBvc2l0aXZlIGFuZCByZWFzb25hYmxlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLnNrZXRjaFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgIGlmIChzYW5pdGl6ZWQuc2tldGNoV2lkdGggPD0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hXaWR0aCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoV2lkdGh9LiBDb3JyZWN0aW5nIHRvIDEwMjQuYCk7XG4gICAgICBzYW5pdGl6ZWQuc2tldGNoV2lkdGggPSAxMDI0O1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLnNrZXRjaFdpZHRoIDwgMTYpIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoV2lkdGggc2hvdWxkIGJlIGF0IGxlYXN0IDE2IGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlLCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoV2lkdGh9LiBDb3JyZWN0aW5nIHRvIDE2LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaFdpZHRoID0gMTY7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuc2tldGNoV2lkdGggPiA2NTUzNikge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hXaWR0aCBzaG91bGQgbm90IGV4Y2VlZCA2NTUzNiBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaFdpZHRofS4gQ29ycmVjdGluZyB0byA2NTUzNi5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hXaWR0aCA9IDY1NTM2O1xuICAgIH1cbiAgfVxuXG4gIC8vIFNhbml0aXplIHNrZXRjaERlcHRoIHRvIGJlIHBvc2l0aXZlIGFuZCByZWFzb25hYmxlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLnNrZXRjaERlcHRoID09PSAnbnVtYmVyJykge1xuICAgIGlmIChzYW5pdGl6ZWQuc2tldGNoRGVwdGggPD0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hEZXB0aCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoRGVwdGh9LiBDb3JyZWN0aW5nIHRvIDQuYCk7XG4gICAgICBzYW5pdGl6ZWQuc2tldGNoRGVwdGggPSA0O1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLnNrZXRjaERlcHRoIDwgMSkge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hEZXB0aCBzaG91bGQgYmUgYXQgbGVhc3QgMSBmb3Igb3B0aW1hbCBhY2N1cmFjeSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaERlcHRofS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaERlcHRoID0gMTtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5za2V0Y2hEZXB0aCA+IDE2KSB7XG4gICAgICBjb25zb2xlLndhcm4oYHNrZXRjaERlcHRoIHNob3VsZCBub3QgZXhjZWVkIDE2IGZvciBvcHRpbWFsIGFjY3VyYWN5LCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoRGVwdGh9LiBDb3JyZWN0aW5nIHRvIDE2LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaERlcHRoID0gMTY7XG4gICAgfVxuICB9XG5cbiAgLy8gU2FuaXRpemUgbWluRnJlcXVlbmN5VGhyZXNob2xkIHRvIGJlIHBvc2l0aXZlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA9PT0gJ251bWJlcicgJiYgc2FuaXRpemVkLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBtaW5GcmVxdWVuY3lUaHJlc2hvbGQgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLm1pbkZyZXF1ZW5jeVRocmVzaG9sZH0uIENvcnJlY3RpbmcgdG8gMS5gKTtcbiAgICBzYW5pdGl6ZWQubWluRnJlcXVlbmN5VGhyZXNob2xkID0gMTtcbiAgfVxuXG4gIHJldHVybiBzYW5pdGl6ZWQ7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIExGVSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKGFmdGVyIHNhbml0aXphdGlvbilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTEZVQ29uZmlnKGNvbmZpZzogUGFydGlhbDxMRlVDb25maWc+KTogdm9pZCB7XG4gIGlmICh0eXBlb2YgY29uZmlnLmRlY2F5RmFjdG9yID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlTnVtYmVyUmFuZ2UoY29uZmlnLmRlY2F5RmFjdG9yLCAwLjAsIDEuMCwgJ2RlY2F5RmFjdG9yJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5kZWNheUludGVydmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5kZWNheUludGVydmFsLCAnZGVjYXlJbnRlcnZhbCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcuc2tldGNoV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLnNrZXRjaFdpZHRoLCAnc2tldGNoV2lkdGgnKTtcbiAgICBpZiAoY29uZmlnLnNrZXRjaFdpZHRoIDwgMTYgfHwgY29uZmlnLnNrZXRjaFdpZHRoID4gNjU1MzYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2tldGNoV2lkdGggbXVzdCBiZSBiZXR3ZWVuIDE2IGFuZCA2NTUzNiwgZ290ICR7Y29uZmlnLnNrZXRjaFdpZHRofWApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLnNrZXRjaERlcHRoID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5za2V0Y2hEZXB0aCwgJ3NrZXRjaERlcHRoJyk7XG4gICAgaWYgKGNvbmZpZy5za2V0Y2hEZXB0aCA8IDEgfHwgY29uZmlnLnNrZXRjaERlcHRoID4gMTYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2tldGNoRGVwdGggbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE2LCBnb3QgJHtjb25maWcuc2tldGNoRGVwdGh9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcubWluRnJlcXVlbmN5VGhyZXNob2xkID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5taW5GcmVxdWVuY3lUaHJlc2hvbGQsICdtaW5GcmVxdWVuY3lUaHJlc2hvbGQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbml0aXplcyBBUkMgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLCBjb3JyZWN0aW5nIGludmFsaWQgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUFSQ0NvbmZpZyhjb25maWc6IFBhcnRpYWw8QVJDQ29uZmlnPik6IFBhcnRpYWw8QVJDQ29uZmlnPiB7XG4gIGNvbnN0IHNhbml0aXplZCA9IHsgLi4uY29uZmlnIH07XG5cbiAgLy8gU2FuaXRpemUgbWF4Q2FjaGVTaXplIHRvIGJlIHBvc2l0aXZlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLm1heENhY2hlU2l6ZSA9PT0gJ251bWJlcicgJiYgc2FuaXRpemVkLm1heENhY2hlU2l6ZSA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBtYXhDYWNoZVNpemUgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLm1heENhY2hlU2l6ZX0uIENvcnJlY3RpbmcgdG8gMTAwMC5gKTtcbiAgICBzYW5pdGl6ZWQubWF4Q2FjaGVTaXplID0gMTAwMDtcbiAgfVxuXG4gIC8vIFNhbml0aXplIGZyZXF1ZW5jeVRocmVzaG9sZCB0byBiZSBwb3NpdGl2ZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5mcmVxdWVuY3lUaHJlc2hvbGQgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5mcmVxdWVuY3lUaHJlc2hvbGQgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgZnJlcXVlbmN5VGhyZXNob2xkIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5mcmVxdWVuY3lUaHJlc2hvbGR9LiBDb3JyZWN0aW5nIHRvIDIuYCk7XG4gICAgc2FuaXRpemVkLmZyZXF1ZW5jeVRocmVzaG9sZCA9IDI7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBmcmVxdWVuY3lEZWNheUZhY3RvciB0byBiZSBiZXR3ZWVuIDAgYW5kIDFcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUZhY3RvciA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgZnJlcXVlbmN5RGVjYXlGYWN0b3IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGdvdCAke3Nhbml0aXplZC5mcmVxdWVuY3lEZWNheUZhY3Rvcn0uIENvcnJlY3RpbmcgdG8gMC5gKTtcbiAgICAgIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUZhY3RvciA9IDA7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPiAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeURlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDEuYCk7XG4gICAgICBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNhbml0aXplIGZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgdG8gYmUgcG9zaXRpdmVcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA9PT0gJ251bWJlcicgJiYgc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbH0uIENvcnJlY3RpbmcgdG8gNjAwMDAuYCk7XG4gICAgc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgPSA2MDAwMDsgLy8gMSBtaW51dGUgZGVmYXVsdFxuICB9XG5cbiAgLy8gU2FuaXRpemUgYWRhcHRpdmVMZWFybmluZ1JhdGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAxMFxuICBpZiAodHlwZW9mIHNhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoc2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlIDwgMCkge1xuICAgICAgY29uc29sZS53YXJuKGBhZGFwdGl2ZUxlYXJuaW5nUmF0ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAsIGdvdCAke3Nhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZX0uIENvcnJlY3RpbmcgdG8gMC5gKTtcbiAgICAgIHNhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA9IDA7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGUgPiAxMCkge1xuICAgICAgY29uc29sZS53YXJuKGBhZGFwdGl2ZUxlYXJuaW5nUmF0ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAsIGdvdCAke3Nhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZX0uIENvcnJlY3RpbmcgdG8gMTAuYCk7XG4gICAgICBzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGUgPSAxMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBBUkMgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIChhZnRlciBzYW5pdGl6YXRpb24pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFSQ0NvbmZpZyhjb25maWc6IFBhcnRpYWw8QVJDQ29uZmlnPik6IHZvaWQge1xuICBpZiAodHlwZW9mIGNvbmZpZy5tYXhDYWNoZVNpemUgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLm1heENhY2hlU2l6ZSwgJ21heENhY2hlU2l6ZScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcuZnJlcXVlbmN5VGhyZXNob2xkID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5mcmVxdWVuY3lUaHJlc2hvbGQsICdmcmVxdWVuY3lUaHJlc2hvbGQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlTnVtYmVyUmFuZ2UoY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yLCAwLjAsIDEuMCwgJ2ZyZXF1ZW5jeURlY2F5RmFjdG9yJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5mcmVxdWVuY3lEZWNheUludGVydmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5mcmVxdWVuY3lEZWNheUludGVydmFsLCAnZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcuYWRhcHRpdmVMZWFybmluZ1JhdGUgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVOdW1iZXJSYW5nZShjb25maWcuYWRhcHRpdmVMZWFybmluZ1JhdGUsIDAuMCwgMTAuMCwgJ2FkYXB0aXZlTGVhcm5pbmdSYXRlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW5pdGl6ZXMgVHdvUXVldWUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLCBjb3JyZWN0aW5nIGludmFsaWQgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZVR3b1F1ZXVlQ29uZmlnKGNvbmZpZzogUGFydGlhbDxUd29RdWV1ZUNvbmZpZz4pOiBQYXJ0aWFsPFR3b1F1ZXVlQ29uZmlnPiB7XG4gIGNvbnN0IHNhbml0aXplZCA9IHsgLi4uY29uZmlnIH07XG5cbiAgLy8gU2FuaXRpemUgbWF4Q2FjaGVTaXplIHRvIGJlIHBvc2l0aXZlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLm1heENhY2hlU2l6ZSA9PT0gJ251bWJlcicgJiYgc2FuaXRpemVkLm1heENhY2hlU2l6ZSA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBtYXhDYWNoZVNpemUgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLm1heENhY2hlU2l6ZX0uIENvcnJlY3RpbmcgdG8gMTAwMC5gKTtcbiAgICBzYW5pdGl6ZWQubWF4Q2FjaGVTaXplID0gMTAwMDtcbiAgfVxuXG4gIC8vIFNhbml0aXplIHByb21vdGlvblRocmVzaG9sZCB0byBiZSBwb3NpdGl2ZVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5wcm9tb3Rpb25UaHJlc2hvbGQgPT09ICdudW1iZXInICYmIHNhbml0aXplZC5wcm9tb3Rpb25UaHJlc2hvbGQgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgcHJvbW90aW9uVGhyZXNob2xkIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5wcm9tb3Rpb25UaHJlc2hvbGR9LiBDb3JyZWN0aW5nIHRvIDIuYCk7XG4gICAgc2FuaXRpemVkLnByb21vdGlvblRocmVzaG9sZCA9IDI7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBob3RRdWV1ZURlY2F5RmFjdG9yIHRvIGJlIGJldHdlZW4gMCBhbmQgMVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yID09PSAnbnVtYmVyJykge1xuICAgIGlmIChzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgaG90UXVldWVEZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA9IDA7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihgaG90UXVldWVEZWNheUZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZ290ICR7c2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDEuYCk7XG4gICAgICBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3RvciA9IDE7XG4gICAgfVxuICB9XG5cbiAgLy8gU2FuaXRpemUgaG90UXVldWVEZWNheUludGVydmFsIHRvIGJlIHBvc2l0aXZlXG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA9PT0gJ251bWJlcicgJiYgc2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBob3RRdWV1ZURlY2F5SW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbH0uIENvcnJlY3RpbmcgdG8gMzAwMDAwLmApO1xuICAgIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPSAzMDAwMDA7IC8vIDUgbWludXRlcyBkZWZhdWx0XG4gIH1cblxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBUd29RdWV1ZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKGFmdGVyIHNhbml0aXphdGlvbilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVHdvUXVldWVDb25maWcoY29uZmlnOiBQYXJ0aWFsPFR3b1F1ZXVlQ29uZmlnPik6IHZvaWQge1xuICBpZiAodHlwZW9mIGNvbmZpZy5tYXhDYWNoZVNpemUgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLm1heENhY2hlU2l6ZSwgJ21heENhY2hlU2l6ZScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcucHJvbW90aW9uVGhyZXNob2xkID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5wcm9tb3Rpb25UaHJlc2hvbGQsICdwcm9tb3Rpb25UaHJlc2hvbGQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVOdW1iZXJSYW5nZShjb25maWcuaG90UXVldWVEZWNheUZhY3RvciwgMC4wLCAxLjAsICdob3RRdWV1ZURlY2F5RmFjdG9yJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCwgJ2hvdFF1ZXVlRGVjYXlJbnRlcnZhbCcpO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGFueSBldmljdGlvbiBzdHJhdGVneSBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUV2aWN0aW9uU3RyYXRlZ3lDb25maWcoY29uZmlnOiBQYXJ0aWFsPEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzPik6IHZvaWQge1xuICBpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAoIWNvbmZpZy50eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWd1cmF0aW9uIG11c3Qgc3BlY2lmeSBhIHR5cGUnKTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkVHlwZXMgPSBbJ2xmdScsICdscnUnLCAnZmlmbycsICdtcnUnLCAncmFuZG9tJywgJ2FyYycsICcycSddO1xuICBpZiAoIXZhbGlkVHlwZXMuaW5jbHVkZXMoY29uZmlnLnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2aWN0aW9uIHN0cmF0ZWd5IHR5cGU6ICR7Y29uZmlnLnR5cGV9LiBNdXN0IGJlIG9uZSBvZjogJHt2YWxpZFR5cGVzLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICBzd2l0Y2ggKGNvbmZpZy50eXBlKSB7XG4gICAgY2FzZSAnbGZ1JzpcbiAgICAgIHZhbGlkYXRlTEZVQ29uZmlnKGNvbmZpZyBhcyBQYXJ0aWFsPExGVUNvbmZpZz4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYXJjJzpcbiAgICAgIHZhbGlkYXRlQVJDQ29uZmlnKGNvbmZpZyBhcyBQYXJ0aWFsPEFSQ0NvbmZpZz4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMnEnOlxuICAgICAgdmFsaWRhdGVUd29RdWV1ZUNvbmZpZyhjb25maWcgYXMgUGFydGlhbDxUd29RdWV1ZUNvbmZpZz4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbHJ1JzpcbiAgICBjYXNlICdmaWZvJzpcbiAgICBjYXNlICdtcnUnOlxuICAgIGNhc2UgJ3JhbmRvbSc6XG4gICAgICAvLyBUaGVzZSBzdHJhdGVnaWVzIGhhdmUgbm8gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHRvIHZhbGlkYXRlXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIGR1ZSB0byB0aGUgdHlwZSBjaGVjayBhYm92ZSwgYnV0IGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3NcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZXZpY3Rpb24gc3RyYXRlZ3kgdHlwZTogJHsoY29uZmlnIGFzIGFueSkudHlwZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbml0aXplcyBjb25maWd1cmF0aW9uIGJhc2VkIG9uIHR5cGVcbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVDb25maWdCeVR5cGUoY29uZmlnOiBQYXJ0aWFsPEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzPik6IFBhcnRpYWw8RXZpY3Rpb25TdHJhdGVneUNvbmZpZ3M+IHtcbiAgaWYgKCFjb25maWcudHlwZSkge1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBzd2l0Y2ggKGNvbmZpZy50eXBlKSB7XG4gICAgY2FzZSAnbGZ1JzpcbiAgICAgIHJldHVybiBzYW5pdGl6ZUxGVUNvbmZpZyhjb25maWcgYXMgUGFydGlhbDxMRlVDb25maWc+KTtcbiAgICBjYXNlICdhcmMnOlxuICAgICAgcmV0dXJuIHNhbml0aXplQVJDQ29uZmlnKGNvbmZpZyBhcyBQYXJ0aWFsPEFSQ0NvbmZpZz4pO1xuICAgIGNhc2UgJzJxJzpcbiAgICAgIHJldHVybiBzYW5pdGl6ZVR3b1F1ZXVlQ29uZmlnKGNvbmZpZyBhcyBQYXJ0aWFsPFR3b1F1ZXVlQ29uZmlnPik7XG4gICAgY2FzZSAnbHJ1JzpcbiAgICBjYXNlICdmaWZvJzpcbiAgICBjYXNlICdtcnUnOlxuICAgIGNhc2UgJ3JhbmRvbSc6XG4gICAgICAvLyBUaGVzZSBzdHJhdGVnaWVzIGhhdmUgbm8gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNhbml0aXplXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29uZmlnO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHZhbGlkYXRlZCBjb25maWd1cmF0aW9uIHdpdGggZGVmYXVsdHMgYXBwbGllZCBhbmQgaW52YWxpZCB2YWx1ZXMgc2FuaXRpemVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWYWxpZGF0ZWRDb25maWc8VCBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3lDb25maWdzPihcbiAgYmFzZUNvbmZpZzogVCxcbiAgdXNlckNvbmZpZzogUGFydGlhbDxUPlxuKTogVCB7XG4gIC8vIE1lcmdlIHdpdGggZGVmYXVsdHMgZmlyc3RcbiAgY29uc3QgbWVyZ2VkQ29uZmlnID0geyAuLi5iYXNlQ29uZmlnLCAuLi51c2VyQ29uZmlnIH07XG5cbiAgLy8gU2FuaXRpemUgdGhlIG1lcmdlZCBjb25maWd1cmF0aW9uXG4gIGNvbnN0IHNhbml0aXplZENvbmZpZyA9IHNhbml0aXplQ29uZmlnQnlUeXBlKG1lcmdlZENvbmZpZyk7XG5cbiAgLy8gVmFsaWRhdGUgdGhlIGZpbmFsIHNhbml0aXplZCBjb25maWd1cmF0aW9uXG4gIHZhbGlkYXRlRXZpY3Rpb25TdHJhdGVneUNvbmZpZyhzYW5pdGl6ZWRDb25maWcpO1xuXG4gIHJldHVybiBzYW5pdGl6ZWRDb25maWcgYXMgVDtcbn1cbiIsImltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhLCBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsIEV2aWN0aW9uQ29udGV4dCwgRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgREVGQVVMVF9MRlVfQ09ORklHLCBMRlVDb25maWcgfSBmcm9tICcuLi9FdmljdGlvblN0cmF0ZWd5Q29uZmlnJztcbmltcG9ydCB7IGNyZWF0ZVZhbGlkYXRlZENvbmZpZyB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3lWYWxpZGF0aW9uJztcblxuLyoqXG4gKiBIaWdoLXF1YWxpdHkgaGFzaCBmdW5jdGlvbiBmb3IgQ291bnQtTWluIFNrZXRjaCBiYXNlZCBvbiBGTlYtMWFcbiAqIFByb3ZpZGVzIGV4Y2VsbGVudCBhdmFsYW5jaGUgZWZmZWN0IGFuZCBkaXN0cmlidXRpb24gcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBmbnYxYUhhc2goa2V5OiBzdHJpbmcsIHNlZWQ6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIEZOVi0xYSBjb25zdGFudHMgZm9yIDMyLWJpdCBoYXNoXG4gIGNvbnN0IEZOVl9PRkZTRVRfQkFTSVMgPSAyMTY2MTM2MjYxO1xuICBjb25zdCBGTlZfUFJJTUUgPSAxNjc3NzYxOTtcblxuICAvLyBTdGFydCB3aXRoIHNlZWQtbW9kaWZpZWQgb2Zmc2V0IGJhc2lzIGZvciBkaWZmZXJlbnQgaGFzaCBmdW5jdGlvbnNcbiAgbGV0IGhhc2ggPSAoRk5WX09GRlNFVF9CQVNJUyBeIHNlZWQpID4+PiAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gWE9SIHdpdGggYnl0ZSB2YWx1ZVxuICAgIGhhc2ggXj0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgLy8gTXVsdGlwbHkgYnkgRk5WIHByaW1lXG4gICAgaGFzaCA9IChoYXNoICogRk5WX1BSSU1FKSA+Pj4gMDtcbiAgfVxuXG4gIC8vIEFkZGl0aW9uYWwgbWl4aW5nIGZvciBiZXR0ZXIgYXZhbGFuY2hlXG4gIGhhc2ggXj0gaGFzaCA+Pj4gMTY7XG4gIGhhc2ggPSAoaGFzaCAqIDB4ODVlYmNhNmIpID4+PiAwO1xuICBoYXNoIF49IGhhc2ggPj4+IDEzO1xuICBoYXNoID0gKGhhc2ggKiAweGMyYjJhZTM1KSA+Pj4gMDtcbiAgaGFzaCBePSBoYXNoID4+PiAxNjtcblxuICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxuLyoqXG4gKiBDb3VudC1NaW4gU2tldGNoIGZvciBwcm9iYWJpbGlzdGljIGZyZXF1ZW5jeSBjb3VudGluZ1xuICovXG5jbGFzcyBDb3VudE1pblNrZXRjaCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2tldGNoZXM6IG51bWJlcltdW107XG4gIHByaXZhdGUgcmVhZG9ubHkgd2lkdGg6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBkZXB0aDogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IHNlZWRzOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyID0gMTAyNCwgZGVwdGg6IG51bWJlciA9IDQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuc2tldGNoZXMgPSBBcnJheShkZXB0aCkuZmlsbChudWxsKS5tYXAoKCkgPT4gbmV3IEFycmF5KHdpZHRoKS5maWxsKDApKTtcbiAgICB0aGlzLnNlZWRzID0gQXJyYXkoZGVwdGgpLmZpbGwobnVsbCkubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIDIgZm9yIG9wdGltaXplZCBiaXQgbWFza2luZ1xuICAgKi9cbiAgcHJpdmF0ZSBpc1Bvd2VyT2ZUd28objogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG4gPiAwICYmIChuICYgKG4gLSAxKSkgPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBmcmVxdWVuY3kgY291bnQgZm9yIGEga2V5XG4gICAqL1xuICBpbmNyZW1lbnQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgLy8gVXNlIGJpdCBtYXNraW5nIGZvciBiZXR0ZXIgZGlzdHJpYnV0aW9uIHdoZW4gd2lkdGggaXMgcG93ZXIgb2YgMlxuICAgICAgLy8gRm9yIG5vbi1wb3dlciBvZiAyLCBmYWxsIGJhY2sgdG8gbW9kdWxvIGJ1dCB3aXRoIGltcHJvdmVkIGhhc2hcbiAgICAgIGNvbnN0IGhhc2ggPSBmbnYxYUhhc2goa2V5LCB0aGlzLnNlZWRzW2ldKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pc1Bvd2VyT2ZUd28odGhpcy53aWR0aClcbiAgICAgICAgPyBoYXNoICYgKHRoaXMud2lkdGggLSAxKVxuICAgICAgICA6IGhhc2ggJSB0aGlzLndpZHRoO1xuICAgICAgdGhpcy5za2V0Y2hlc1tpXVtpbmRleF0rKztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXN0aW1hdGUgdGhlIGZyZXF1ZW5jeSBjb3VudCBmb3IgYSBrZXlcbiAgICovXG4gIGVzdGltYXRlKGtleTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBsZXQgbWluQ291bnQgPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgLy8gVXNlIHNhbWUgaW1wcm92ZWQgaW5kZXhpbmcgYXMgaW4gaW5jcmVtZW50IG1ldGhvZFxuICAgICAgY29uc3QgaGFzaCA9IGZudjFhSGFzaChrZXksIHRoaXMuc2VlZHNbaV0pO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlzUG93ZXJPZlR3byh0aGlzLndpZHRoKVxuICAgICAgICA/IGhhc2ggJiAodGhpcy53aWR0aCAtIDEpXG4gICAgICAgIDogaGFzaCAlIHRoaXMud2lkdGg7XG4gICAgICBtaW5Db3VudCA9IE1hdGgubWluKG1pbkNvdW50LCB0aGlzLnNrZXRjaGVzW2ldW2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiBtaW5Db3VudCA9PT0gSW5maW5pdHkgPyAwIDogbWluQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgZGVjYXkgdG8gYWxsIGZyZXF1ZW5jaWVzXG4gICAqL1xuICBkZWNheShmYWN0b3I6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXB0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMud2lkdGg7IGorKykge1xuICAgICAgICB0aGlzLnNrZXRjaGVzW2ldW2pdID0gTWF0aC5mbG9vcih0aGlzLnNrZXRjaGVzW2ldW2pdICogKDEgLSBmYWN0b3IpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgYWxsIGZyZXF1ZW5jaWVzIHRvIHplcm9cbiAgICovXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXB0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMud2lkdGg7IGorKykge1xuICAgICAgICB0aGlzLnNrZXRjaGVzW2ldW2pdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMRlUgKExlYXN0IEZyZXF1ZW50bHkgVXNlZCkgZXZpY3Rpb24gc3RyYXRlZ3kgd2l0aCBmcmVxdWVuY3kgc2tldGNoaW5nIGFuZCBkZWNheVxuICogVXNlcyBwcm9iYWJpbGlzdGljIGNvdW50aW5nIGFuZCB0aW1lLWJhc2VkIGZyZXF1ZW5jeSBkZWNheSBmb3IgbW9yZSBhY2N1cmF0ZSBmcmVxdWVuY3kgZXN0aW1hdGlvblxuICogV2hlbiBjb25maWd1cmVkIHdpdGggZGVmYXVsdCBzZXR0aW5ncywgYmVoYXZlcyBsaWtlIHRyYWRpdGlvbmFsIExGVSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqL1xuZXhwb3J0IGNsYXNzIExGVUV2aWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgZ2V0U3RyYXRlZ3lOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdsZnUnO1xuICB9XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBMRlVDb25maWc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2tldGNoOiBDb3VudE1pblNrZXRjaCB8IG51bGw7XG4gIHByaXZhdGUgbGFzdERlY2F5VGltZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxMRlVDb25maWc+ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIERlZmF1bHQgdG8gYmFja3dhcmRzLWNvbXBhdGlibGUgYmVoYXZpb3IgaWYgbm8gY29uZmlnIHByb3ZpZGVkXG4gICAgY29uc3QgZGVmYXVsdEJhY2t3YXJkc0NvbXBhdGlibGUgPSB7XG4gICAgICB1c2VQcm9iYWJpbGlzdGljQ291bnRpbmc6IGZhbHNlLFxuICAgICAgZGVjYXlGYWN0b3I6IDAsXG4gICAgICBkZWNheUludGVydmFsOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgIH07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHsgLi4uREVGQVVMVF9MRlVfQ09ORklHLCAuLi5kZWZhdWx0QmFja3dhcmRzQ29tcGF0aWJsZSB9O1xuICAgIHRoaXMuY29uZmlnID0gY3JlYXRlVmFsaWRhdGVkQ29uZmlnKGJhc2VDb25maWcsIGNvbmZpZyk7XG4gICAgdGhpcy5za2V0Y2ggPSB0aGlzLmNvbmZpZy51c2VQcm9iYWJpbGlzdGljQ291bnRpbmdcbiAgICAgID8gbmV3IENvdW50TWluU2tldGNoKHRoaXMuY29uZmlnLnNrZXRjaFdpZHRoLCB0aGlzLmNvbmZpZy5za2V0Y2hEZXB0aClcbiAgICAgIDogbnVsbDtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgYXN5bmMgc2VsZWN0Rm9yRXZpY3Rpb24oXG4gICAgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLFxuICAgIGNvbnRleHQ6IEV2aWN0aW9uQ29udGV4dFxuICApOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgaWYgKGFsbE1ldGFkYXRhLnNpemUgPT09IDApIHJldHVybiBbXTtcblxuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBpZiAoZXZpY3Rpb25Db3VudCA8PSAwKSByZXR1cm4gW107XG5cbiAgICAvLyBBcHBseSBwZXJpb2RpYyBkZWNheSBpZiBuZWVkZWRcbiAgICB0aGlzLmFwcGx5UGVyaW9kaWNEZWNheSgpO1xuXG4gICAgLy8gU29ydCBpdGVtcyBieSBmcmVxdWVuY3kgKGxvd2VzdCBmaXJzdCksIHRoZW4gYnkgYWdlIChvbGRlc3QgZmlyc3QpXG4gICAgY29uc3Qgc29ydGVkRW50cmllcyA9IEFycmF5LmZyb20oYWxsTWV0YWRhdGEuZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBmcmVxQSA9IHRoaXMuZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KGFbMF0sIGFbMV0pO1xuICAgICAgY29uc3QgZnJlcUIgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShiWzBdLCBiWzFdKTtcblxuICAgICAgaWYgKGZyZXFBICE9PSBmcmVxQikge1xuICAgICAgICByZXR1cm4gZnJlcUEgLSBmcmVxQjsgLy8gTG93ZXIgZnJlcXVlbmN5IGZpcnN0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhWzFdLmxhc3RBY2Nlc3NlZEF0IC0gYlsxXS5sYXN0QWNjZXNzZWRBdDsgLy8gT2xkZXIgZmlyc3RcbiAgICB9KTtcblxuICAgIHJldHVybiBzb3J0ZWRFbnRyaWVzLnNsaWNlKDAsIGV2aWN0aW9uQ291bnQpLm1hcCgoW2tleV0pID0+IGtleSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BY2Nlc3NlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IG5vdztcbiAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuXG4gICAgLy8gVXBkYXRlIGZyZXF1ZW5jeSB0cmFja2luZ1xuICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgdGhpcy5za2V0Y2guaW5jcmVtZW50KGtleSk7XG4gICAgICBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgPSB0aGlzLnNrZXRjaC5lc3RpbWF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgPSBtZXRhZGF0YS5hY2Nlc3NDb3VudDsgLy8gVXNlIGFjY2VzcyBjb3VudCBpbiBzaW1wbGUgbW9kZVxuICAgIH1cblxuICAgIC8vIEFsd2F5cyBjYWxjdWxhdGUgZnJlcXVlbmN5IHNjb3JlIGZvciBjb25zaXN0ZW5jeVxuICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gdGhpcy5jYWxjdWxhdGVGcmVxdWVuY3lTY29yZShtZXRhZGF0YSwgbm93KTtcbiAgICBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFkZGVkKGtleTogc3RyaW5nLCBlc3RpbWF0ZWRTaXplOiBudW1iZXIsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZSxcbiAgICAgIHJhd0ZyZXF1ZW5jeTogMVxuICAgIH07XG5cbiAgICAvLyBBbHdheXMgaW5pdGlhbGl6ZSBmcmVxdWVuY3lTY29yZSBhbmQgbGFzdEZyZXF1ZW5jeVVwZGF0ZSBmb3IgY29uc2lzdGVuY3lcbiAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IDE7XG4gICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcblxuICAgIC8vIEluaXRpYWxpemUgaW4gc2tldGNoXG4gICAgaWYgKHRoaXMuc2tldGNoKSB7XG4gICAgICB0aGlzLnNrZXRjaC5pbmNyZW1lbnQoa2V5KTtcbiAgICB9XG5cbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtUmVtb3ZlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gTm90ZTogRm9yIENvdW50LU1pbiBTa2V0Y2gsIHdlIGRvbid0IHJlbW92ZSBlbnRyaWVzIGFzIGl0J3MgYSBwcm9iYWJpbGlzdGljIHN0cnVjdHVyZVxuICAgIC8vIFRoZSBkZWNheSBtZWNoYW5pc20gd2lsbCBuYXR1cmFsbHkgcmVkdWNlIHRoZSBpbXBhY3Qgb2YgcmVtb3ZlZCBpdGVtcyBvdmVyIHRpbWVcbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlZmZlY3RpdmUgZnJlcXVlbmN5IGZvciBhbiBpdGVtLCBhcHBseWluZyByZWFsLXRpbWUgZGVjYXkgaWYgbmVlZGVkXG4gICAqL1xuICBwcml2YXRlIGdldEVmZmVjdGl2ZUZyZXF1ZW5jeShfa2V5OiBzdHJpbmcsIG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IG51bWJlciB7XG4gICAgLy8gSWYgZGVjYXkgaXMgZGlzYWJsZWQsIHVzZSBzaW1wbGUgZnJlcXVlbmN5IGNvdW50aW5nXG4gICAgaWYgKCh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHJlY2VudCBmcmVxdWVuY3kgc2NvcmUsIHVzZSBpdCB3aXRoIG1pbmltYWwgZGVjYXlcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IG5vdyAtIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGU7XG4gICAgICBjb25zdCBkZWNheUFtb3VudCA9ICh0aW1lU2luY2VVcGRhdGUgLyAodGhpcy5jb25maWcuZGVjYXlJbnRlcnZhbCA/PyA2MDAwMCkpICogKHRoaXMuY29uZmlnLmRlY2F5RmFjdG9yID8/IDAuMSk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5jb25maWcubWluRnJlcXVlbmN5VGhyZXNob2xkID8/IDEsIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIHRvIHJhdyBmcmVxdWVuY3kgb3IgYWNjZXNzIGNvdW50XG4gICAgcmV0dXJuIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZnJlcXVlbmN5IHNjb3JlIHdpdGggZGVjYXkgYXBwbGllZFxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVGcmVxdWVuY3lTY29yZShtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHJhd0ZyZXEgPSBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG5cbiAgICAvLyBJZiBkZWNheSBpcyBkaXNhYmxlZCwganVzdCByZXR1cm4gcmF3IGZyZXF1ZW5jeVxuICAgIGlmICgodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IGN1cnJlbnRUaW1lIC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICBjb25zdCBkZWNheUFtb3VudCA9ICh0aW1lU2luY2VVcGRhdGUgLyAodGhpcy5jb25maWcuZGVjYXlJbnRlcnZhbCA/PyA2MDAwMCkpICogKHRoaXMuY29uZmlnLmRlY2F5RmFjdG9yID8/IDAuMSk7XG4gICAgY29uc3QgcHJldmlvdXNTY29yZSA9IG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlIHx8IHJhd0ZyZXE7XG5cbiAgICAvLyBBcHBseSBkZWNheSB0byBwcmV2aW91cyBzY29yZSBhbmQgYWRkIG5ldyBmcmVxdWVuY3kgY29udHJpYnV0aW9uXG4gICAgY29uc3QgZGVjYXllZFNjb3JlID0gcHJldmlvdXNTY29yZSAqICgxIC0gZGVjYXlBbW91bnQpO1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmNvbmZpZy5taW5GcmVxdWVuY3lUaHJlc2hvbGQgPz8gMSwgZGVjYXllZFNjb3JlICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgcGVyaW9kaWMgZGVjYXkgdG8gdGhlIGZyZXF1ZW5jeSBza2V0Y2ggYW5kIG1ldGFkYXRhXG4gICAqL1xuICBwcml2YXRlIGFwcGx5UGVyaW9kaWNEZWNheSgpOiB2b2lkIHtcbiAgICBpZiAoKHRoaXMuY29uZmlnLmRlY2F5RmFjdG9yID8/IDApID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVTaW5jZURlY2F5ID0gbm93IC0gdGhpcy5sYXN0RGVjYXlUaW1lO1xuXG4gICAgaWYgKHRpbWVTaW5jZURlY2F5ID49ICh0aGlzLmNvbmZpZy5kZWNheUludGVydmFsID8/IDYwMDAwKSkge1xuICAgICAgaWYgKHRoaXMuc2tldGNoKSB7XG4gICAgICAgIHRoaXMuc2tldGNoLmRlY2F5KHRoaXMuY29uZmlnLmRlY2F5RmFjdG9yID8/IDAuMSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBub3c7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHN0cmF0ZWd5XG4gICAqL1xuICBnZXRDb25maWcoKTogTEZVQ29uZmlnIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGZyZXF1ZW5jeSB0cmFja2luZyAodXNlZnVsIGZvciB0ZXN0aW5nIG9yIGNhY2hlIGNsZWFyaW5nKVxuICAgKi9cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2tldGNoKSB7XG4gICAgICB0aGlzLnNrZXRjaC5yZXNldCgpO1xuICAgIH1cbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBDYWNoZUl0ZW1NZXRhZGF0YSxcbiAgQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLFxuICBFdmljdGlvbkNvbnRleHQsXG4gIEV2aWN0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnLi4vRXZpY3Rpb25TdHJhdGVneSc7XG5cbi8qKlxuICogRklGTyAoRmlyc3QtSW4sIEZpcnN0LU91dCkgZXZpY3Rpb24gc3RyYXRlZ3lcbiAqIFJlbW92ZXMgdGhlIG9sZGVzdCBhZGRlZCBpdGVtIHJlZ2FyZGxlc3Mgb2YgdXNhZ2VcbiAqL1xuZXhwb3J0IGNsYXNzIEZJRk9FdmljdGlvblN0cmF0ZWd5IGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGFzeW5jIHNlbGVjdEZvckV2aWN0aW9uKFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBjb250ZXh0OiBFdmljdGlvbkNvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgaWYgKGFsbE1ldGFkYXRhLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGNvbnN0IGtleXNUb0V2aWN0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gU29ydCBieSBhZGRlZEF0IGFzY2VuZGluZyAob2xkZXN0IGZpcnN0KVxuICAgIGNvbnN0IHNvcnRlZEVudHJpZXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmVudHJpZXMoKSlcbiAgICAgIC5zb3J0KChbLCBhXSwgWywgYl0pID0+IGEuYWRkZWRBdCAtIGIuYWRkZWRBdCk7XG5cbiAgICAvLyBUYWtlIHRoZSBvbGRlc3QgaXRlbXMgdXAgdG8gZXZpY3Rpb25Db3VudFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oZXZpY3Rpb25Db3VudCwgc29ydGVkRW50cmllcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGtleXNUb0V2aWN0LnB1c2goc29ydGVkRW50cmllc1tpXVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXNUb0V2aWN0O1xuICB9XG5cbiAgYXN5bmMgb25JdGVtQWNjZXNzZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcbiAgICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgb25JdGVtQWRkZWQoa2V5OiBzdHJpbmcsIGVzdGltYXRlZFNpemU6IG51bWJlciwgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEgPSB7XG4gICAgICBrZXksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplXG4gICAgfTtcbiAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtUmVtb3ZlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG5cbiAgZ2V0U3RyYXRlZ3lOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdmaWZvJztcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2FjaGVJdGVtTWV0YWRhdGEsIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciwgRXZpY3Rpb25Db250ZXh0LCBFdmljdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vRXZpY3Rpb25TdHJhdGVneSc7XG5cbi8qKlxuICogTVJVIChNb3N0IFJlY2VudGx5IFVzZWQpIGV2aWN0aW9uIHN0cmF0ZWd5XG4gKiBSZW1vdmVzIHRoZSBtb3N0IHJlY2VudGx5IGFjY2Vzc2VkIGl0ZW1cbiAqL1xuZXhwb3J0IGNsYXNzIE1SVUV2aWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgZ2V0U3RyYXRlZ3lOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdNUlUnO1xuICB9XG4gIGFzeW5jIHNlbGVjdEZvckV2aWN0aW9uKFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBjb250ZXh0OiBFdmljdGlvbkNvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSByZXR1cm4gW107XG5cbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgaWYgKGV2aWN0aW9uQ291bnQgPD0gMCkgcmV0dXJuIFtdO1xuXG4gICAgLy8gU29ydCBpdGVtcyBieSBhY2Nlc3MgdGltZSAobmV3ZXN0IGZpcnN0KVxuICAgIGNvbnN0IHNvcnRlZEVudHJpZXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIGJbMV0ubGFzdEFjY2Vzc2VkQXQgLSBhWzFdLmxhc3RBY2Nlc3NlZEF0OyAvLyBOZXdlciBmaXJzdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNvcnRlZEVudHJpZXMuc2xpY2UoMCwgZXZpY3Rpb25Db3VudCkubWFwKChba2V5XSkgPT4ga2V5KTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFjY2Vzc2VkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhKSByZXR1cm47XG5cbiAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcblxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BZGRlZChrZXk6IHN0cmluZywgZXN0aW1hdGVkU2l6ZTogbnVtYmVyLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemVcbiAgICB9O1xuXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbVJlbW92ZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2FjaGVJdGVtTWV0YWRhdGEsXG4gIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgRXZpY3Rpb25Db250ZXh0LFxuICBFdmljdGlvblN0cmF0ZWd5XG59IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3knO1xuXG4vKipcbiAqIFJhbmRvbSBldmljdGlvbiBzdHJhdGVneVxuICogUmVtb3ZlcyBhIHJhbmRvbSBpdGVtIGZyb20gdGhlIGNhY2hlXG4gKi9cbmV4cG9ydCBjbGFzcyBSYW5kb21FdmljdGlvblN0cmF0ZWd5IGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGFzeW5jIHNlbGVjdEZvckV2aWN0aW9uKFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBjb250ZXh0OiBFdmljdGlvbkNvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgaWYgKGFsbE1ldGFkYXRhLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmtleXMoKSk7XG4gICAgY29uc3Qga2V5c1RvRXZpY3Q6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBSYW5kb21seSBzZWxlY3QgaXRlbXMgdG8gZXZpY3RcbiAgICBjb25zdCBhdmFpbGFibGVLZXlzID0gWy4uLmtleXNdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oZXZpY3Rpb25Db3VudCwgYXZhaWxhYmxlS2V5cy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXZhaWxhYmxlS2V5cy5sZW5ndGgpO1xuICAgICAga2V5c1RvRXZpY3QucHVzaChhdmFpbGFibGVLZXlzLnNwbGljZShyYW5kb21JbmRleCwgMSlbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFjY2Vzc2VkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFkZGVkKGtleTogc3RyaW5nLCBlc3RpbWF0ZWRTaXplOiBudW1iZXIsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZVxuICAgIH07XG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbVJlbW92ZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuXG4gIGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAncmFuZG9tJztcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2FjaGVJdGVtTWV0YWRhdGEsIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciwgRXZpY3Rpb25Db250ZXh0LCBFdmljdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQgeyBBUkNDb25maWcsIERFRkFVTFRfQVJDX0NPTkZJRyB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3lDb25maWcnO1xuaW1wb3J0IHsgY3JlYXRlVmFsaWRhdGVkQ29uZmlnIH0gZnJvbSAnLi4vRXZpY3Rpb25TdHJhdGVneVZhbGlkYXRpb24nO1xuXG4vKipcbiAqIEFSQyAoQWRhcHRpdmUgUmVwbGFjZW1lbnQgQ2FjaGUpIGV2aWN0aW9uIHN0cmF0ZWd5IHdpdGggZW5oYW5jZWQgZnJlcXVlbmN5IHRyYWNraW5nXG4gKiBCYWxhbmNlcyBiZXR3ZWVuIHJlY2VuY3kgKExSVSkgYW5kIGZyZXF1ZW5jeSAoTEZVKSBkeW5hbWljYWxseSB3aXRoIHNvcGhpc3RpY2F0ZWQgZnJlcXVlbmN5IGFuYWx5c2lzXG4gKi9cbmV4cG9ydCBjbGFzcyBBUkNFdmljdGlvblN0cmF0ZWd5IGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQVJDJztcbiAgfVxuICBwcml2YXRlIHJlY2VudEdob3N0cyA9IG5ldyBTZXQ8c3RyaW5nPigpOyAvLyBUMSBnaG9zdCBlbnRyaWVzXG4gIHByaXZhdGUgZnJlcXVlbnRHaG9zdHMgPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gVDIgZ2hvc3QgZW50cmllc1xuICBwcml2YXRlIHRhcmdldFJlY2VudFNpemUgPSAwOyAvLyBUYXJnZXQgc2l6ZSBmb3IgVDEgKHJlY2VudCBlbnRyaWVzKVxuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogQVJDQ29uZmlnO1xuICBwcml2YXRlIHJlYWRvbmx5IG1heEdob3N0U2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIGxhc3REZWNheVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtYXhDYWNoZVNpemU6IG51bWJlciA9IDEwMDAsIGNvbmZpZzogUGFydGlhbDxBUkNDb25maWc+ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSB7IC4uLkRFRkFVTFRfQVJDX0NPTkZJRywgbWF4Q2FjaGVTaXplIH07XG4gICAgdGhpcy5jb25maWcgPSBjcmVhdGVWYWxpZGF0ZWRDb25maWcoYmFzZUNvbmZpZywgY29uZmlnKTtcbiAgICB0aGlzLm1heEdob3N0U2l6ZSA9IHRoaXMuY29uZmlnLm1heENhY2hlU2l6ZSE7XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIGFzeW5jIHNlbGVjdEZvckV2aWN0aW9uKFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBjb250ZXh0OiBFdmljdGlvbkNvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSByZXR1cm4gW107XG5cbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgaWYgKGV2aWN0aW9uQ291bnQgPD0gMCkgcmV0dXJuIFtdO1xuXG4gICAgLy8gQXBwbHkgcGVyaW9kaWMgZGVjYXkgaWYgZW5hYmxlZFxuICAgIHRoaXMuYXBwbHlQZXJpb2RpY0RlY2F5KGFsbE1ldGFkYXRhKTtcblxuICAgIC8vIFNwbGl0IGl0ZW1zIGludG8gcmVjZW50IChUMSkgYW5kIGZyZXF1ZW50IChUMikgYmFzZWQgb24gZW5oYW5jZWQgZnJlcXVlbmN5IGFuYWx5c2lzXG4gICAgY29uc3QgcmVjZW50SXRlbXMgPSBuZXcgTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+KCk7XG4gICAgY29uc3QgZnJlcXVlbnRJdGVtcyA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4oKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbWV0YWRhdGFdIG9mIGFsbE1ldGFkYXRhKSB7XG4gICAgICBpZiAodGhpcy5pc0ZyZXF1ZW50SXRlbShtZXRhZGF0YSkpIHtcbiAgICAgICAgZnJlcXVlbnRJdGVtcy5zZXQoa2V5LCBtZXRhZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNlbnRJdGVtcy5zZXQoa2V5LCBtZXRhZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qga2V5c1RvRXZpY3Q6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgdG90YWxJdGVtcyA9IHJlY2VudEl0ZW1zLnNpemUgKyBmcmVxdWVudEl0ZW1zLnNpemU7XG4gICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IE1hdGgubWluKGV2aWN0aW9uQ291bnQsIHRvdGFsSXRlbXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgIGxldCBrZXlUb0V2aWN0OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgIGxldCBzb3VyY2VMaXN0OiBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4gfCBudWxsID0gbnVsbDtcblxuICAgICAgLy8gRGVjaWRlIHdoaWNoIGxpc3QgdG8gZXZpY3QgZnJvbSBiYXNlZCBvbiB0YXJnZXQgc2l6ZXMgYW5kIGFkYXB0aXZlIGFsZ29yaXRobVxuICAgICAgaWYgKHJlY2VudEl0ZW1zLnNpemUgPiB0aGlzLnRhcmdldFJlY2VudFNpemUgJiYgcmVjZW50SXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gRXZpY3QgZnJvbSByZWNlbnQgbGlzdCAoVDEpXG4gICAgICAgIGtleVRvRXZpY3QgPSB0aGlzLmNvbmZpZy51c2VGcmVxdWVuY3lXZWlnaHRlZFNlbGVjdGlvblxuICAgICAgICAgID8gdGhpcy5zZWxlY3RGcmVxdWVuY3lXZWlnaHRlZEZyb21JdGVtcyhyZWNlbnRJdGVtcywgJ3JlY2VudCcpXG4gICAgICAgICAgOiB0aGlzLnNlbGVjdExSVUZyb21JdGVtcyhyZWNlbnRJdGVtcyk7XG4gICAgICAgIHNvdXJjZUxpc3QgPSByZWNlbnRJdGVtcztcbiAgICAgIH0gZWxzZSBpZiAoZnJlcXVlbnRJdGVtcy5zaXplID4gMCkge1xuICAgICAgICAvLyBFdmljdCBmcm9tIGZyZXF1ZW50IGxpc3QgKFQyKVxuICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5jb25maWcudXNlRnJlcXVlbmN5V2VpZ2h0ZWRTZWxlY3Rpb25cbiAgICAgICAgICA/IHRoaXMuc2VsZWN0RnJlcXVlbmN5V2VpZ2h0ZWRGcm9tSXRlbXMoZnJlcXVlbnRJdGVtcywgJ2ZyZXF1ZW50JylcbiAgICAgICAgICA6IHRoaXMuc2VsZWN0TFJVRnJvbUl0ZW1zKGZyZXF1ZW50SXRlbXMpO1xuICAgICAgICBzb3VyY2VMaXN0ID0gZnJlcXVlbnRJdGVtcztcbiAgICAgIH0gZWxzZSBpZiAocmVjZW50SXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gRmFsbGJhY2s6IGV2aWN0IGZyb20gcmVjZW50IGlmIGl0J3MgdGhlIG9ubHkgbGlzdCB3aXRoIGl0ZW1zXG4gICAgICAgIGtleVRvRXZpY3QgPSB0aGlzLmNvbmZpZy51c2VGcmVxdWVuY3lXZWlnaHRlZFNlbGVjdGlvblxuICAgICAgICAgID8gdGhpcy5zZWxlY3RGcmVxdWVuY3lXZWlnaHRlZEZyb21JdGVtcyhyZWNlbnRJdGVtcywgJ3JlY2VudCcpXG4gICAgICAgICAgOiB0aGlzLnNlbGVjdExSVUZyb21JdGVtcyhyZWNlbnRJdGVtcyk7XG4gICAgICAgIHNvdXJjZUxpc3QgPSByZWNlbnRJdGVtcztcbiAgICAgIH1cblxuICAgICAgaWYgKGtleVRvRXZpY3QgJiYgc291cmNlTGlzdCkge1xuICAgICAgICBrZXlzVG9FdmljdC5wdXNoKGtleVRvRXZpY3QpO1xuICAgICAgICBzb3VyY2VMaXN0LmRlbGV0ZShrZXlUb0V2aWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGtleSBmb3VuZCBvciBubyBtb3JlIGl0ZW1zIGF2YWlsYWJsZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gU2FmZXR5IGNoZWNrOiBpZiB3ZSd2ZSBldmljdGVkIGFsbCBpdGVtcywgc3RvcFxuICAgICAgaWYgKHJlY2VudEl0ZW1zLnNpemUgPT09IDAgJiYgZnJlcXVlbnRJdGVtcy5zaXplID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuXG4gIHByaXZhdGUgc2VsZWN0TFJVRnJvbUl0ZW1zKGl0ZW1zOiBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAoaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IG9sZGVzdEtleTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IG9sZGVzdFRpbWUgPSBJbmZpbml0eTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBtZXRhZGF0YV0gb2YgaXRlbXMpIHtcbiAgICAgIC8vIFZhbGlkYXRlIG1ldGFkYXRhIHRvIHByZXZlbnQgY29ycnVwdGlvblxuICAgICAgaWYgKCFtZXRhZGF0YSB8fCB0eXBlb2YgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgIT09ICdudW1iZXInIHx8IG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID4gbm93KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPCBvbGRlc3RUaW1lKSB7XG4gICAgICAgIG9sZGVzdFRpbWUgPSBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdDtcbiAgICAgICAgb2xkZXN0S2V5ID0ga2V5O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHZhbGlkIGtleSBmb3VuZCB0aHJvdWdoIExSVSBsb2dpYywgZmFsbCBiYWNrIHRvIGZpcnN0IGF2YWlsYWJsZSBrZXlcbiAgICBpZiAob2xkZXN0S2V5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2xkZXN0S2V5O1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIHRvIGZpcnN0IGF2YWlsYWJsZSBrZXkgaWYgaXRlbXMgZXhpc3RcbiAgICBpZiAoaXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5ID0gaXRlbXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBmaXJzdEtleSA/PyBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgb25JdGVtQWNjZXNzZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIG1ldGFkYXRhIHRvIGF2b2lkIGRpcmVjdCBtdXRhdGlvbiBvZiBzaGFyZWQgc3RhdGVcbiAgICBjb25zdCB1cGRhdGVkTWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhID0ge1xuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IG1ldGFkYXRhLmFjY2Vzc0NvdW50ICsgMVxuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgZnJlcXVlbmN5IHRyYWNraW5nXG4gICAgdXBkYXRlZE1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSA9IHVwZGF0ZWRNZXRhZGF0YS5hY2Nlc3NDb3VudDtcblxuICAgIC8vIFVwZGF0ZSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSBpZiBlbmFibGVkXG4gICAgaWYgKHRoaXMuY29uZmlnLnVzZUVuaGFuY2VkRnJlcXVlbmN5ICYmICh0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciA/PyAwKSA+IDApIHtcbiAgICAgIHVwZGF0ZWRNZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IHRoaXMuY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUodXBkYXRlZE1ldGFkYXRhLCBub3cpO1xuICAgICAgdXBkYXRlZE1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPSBub3c7XG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IHRhcmdldCBzaXplIGJhc2VkIG9uIGdob3N0IGxpc3QgaGl0cyB3aXRoIGFkYXB0aXZlIGxlYXJuaW5nXG4gICAgY29uc3QgbGVhcm5pbmdSYXRlID0gdGhpcy5jb25maWcuYWRhcHRpdmVMZWFybmluZ1JhdGUgPz8gMS4wO1xuICAgIGxldCB0YXJnZXRBZGp1c3RlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGxlYXJuaW5nUmF0ZSA+IDApIHtcbiAgICAgIGlmICh0aGlzLnJlY2VudEdob3N0cy5oYXMoa2V5KSkge1xuICAgICAgICAvLyBIaXQgaW4gcmVjZW50IGdob3N0IGxpc3QgLSBpbmNyZWFzZSB0YXJnZXQgZm9yIHJlY2VudCBpdGVtc1xuICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICB0aGlzLnRhcmdldFJlY2VudFNpemUgPSBNYXRoLm1pbih0aGlzLnRhcmdldFJlY2VudFNpemUgKyBhZGp1c3RtZW50LCB0aGlzLm1heEdob3N0U2l6ZSk7XG4gICAgICAgIHRoaXMucmVjZW50R2hvc3RzLmRlbGV0ZShrZXkpO1xuICAgICAgICB0YXJnZXRBZGp1c3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZnJlcXVlbnRHaG9zdHMuaGFzKGtleSkpIHtcbiAgICAgICAgLy8gSGl0IGluIGZyZXF1ZW50IGdob3N0IGxpc3QgLSBkZWNyZWFzZSB0YXJnZXQgZm9yIHJlY2VudCBpdGVtc1xuICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICB0aGlzLnRhcmdldFJlY2VudFNpemUgPSBNYXRoLm1heCh0aGlzLnRhcmdldFJlY2VudFNpemUgLSBhZGp1c3RtZW50LCAwKTtcbiAgICAgICAgdGhpcy5mcmVxdWVudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICAgICAgdGFyZ2V0QWRqdXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVuIHdpdGggemVybyBsZWFybmluZyByYXRlLCByZW1vdmUgZnJvbSBnaG9zdCBsaXN0cyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgaWYgKHRoaXMucmVjZW50R2hvc3RzLmhhcyhrZXkpKSB7XG4gICAgICAgIHRoaXMucmVjZW50R2hvc3RzLmRlbGV0ZShrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZyZXF1ZW50R2hvc3RzLmhhcyhrZXkpKSB7XG4gICAgICAgIHRoaXMuZnJlcXVlbnRHaG9zdHMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgZ2hvc3QgbGlzdHMgaWYgdGhleSB3ZXJlIG1vZGlmaWVkXG4gICAgaWYgKHRhcmdldEFkanVzdGVkKSB7XG4gICAgICB0aGlzLmNsZWFudXBHaG9zdExpc3RzKCk7XG4gICAgfVxuXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIHVwZGF0ZWRNZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BZGRlZChrZXk6IHN0cmluZywgZXN0aW1hdGVkU2l6ZTogbnVtYmVyLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemUsXG4gICAgICByYXdGcmVxdWVuY3k6IDFcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBmcmVxdWVuY3kgc2NvcmUgZm9yIGRlY2F5IHRyYWNraW5nXG4gICAgaWYgKHRoaXMuY29uZmlnLnVzZUVuaGFuY2VkRnJlcXVlbmN5ICYmICh0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciA/PyAwKSA+IDApIHtcbiAgICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gMTtcbiAgICAgIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPSBub3c7XG4gICAgfVxuXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbVJlbW92ZWQoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGdob3N0IGxpc3QgdG8gYWRkIHRvIGJhc2VkIG9uIGl0ZW0gY2hhcmFjdGVyaXN0aWNzXG4gICAgaWYgKG1ldGFkYXRhICYmIHRoaXMuaXNGcmVxdWVudEl0ZW0obWV0YWRhdGEpKSB7XG4gICAgICB0aGlzLmFkZFRvRnJlcXVlbnRHaG9zdHMoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRUb1JlY2VudEdob3N0cyhrZXkpO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG1ldGFkYXRhIGZpcnN0IHRvIGF2b2lkIGFjY2Vzc2luZyBzdGFsZSBkYXRhXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuXG4gICAgLy8gRW5zdXJlIGJvdGggZ2hvc3QgbGlzdHMgc3RheSB3aXRoaW4gYm91bmRzIGFmdGVyIG1vZGlmaWNhdGlvbnNcbiAgICB0aGlzLmNsZWFudXBHaG9zdExpc3RzKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGtleSB0byByZWNlbnQgZ2hvc3QgbGlzdCB3aXRoIHByb3BlciBzaXplIG1hbmFnZW1lbnRcbiAgICovXG4gIHByaXZhdGUgYWRkVG9SZWNlbnRHaG9zdHMoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBSZW1vdmUgZnJvbSBmcmVxdWVudCBnaG9zdHMgaWYgcHJlc2VudCAoaXRlbSBtb3ZlZCBsaXN0cylcbiAgICB0aGlzLmZyZXF1ZW50R2hvc3RzLmRlbGV0ZShrZXkpO1xuXG4gICAgLy8gQWRkIHRvIHJlY2VudCBnaG9zdHNcbiAgICB0aGlzLnJlY2VudEdob3N0cy5hZGQoa2V5KTtcblxuICAgIC8vIE1haW50YWluIHNpemUgbGltaXQgYnkgcmVtb3Zpbmcgb2xkZXN0IGVudHJpZXNcbiAgICB0aGlzLmVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQodGhpcy5yZWNlbnRHaG9zdHMsIHRoaXMubWF4R2hvc3RTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQga2V5IHRvIGZyZXF1ZW50IGdob3N0IGxpc3Qgd2l0aCBwcm9wZXIgc2l6ZSBtYW5hZ2VtZW50XG4gICAqL1xuICBwcml2YXRlIGFkZFRvRnJlcXVlbnRHaG9zdHMoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBSZW1vdmUgZnJvbSByZWNlbnQgZ2hvc3RzIGlmIHByZXNlbnQgKGl0ZW0gbW92ZWQgbGlzdHMpXG4gICAgdGhpcy5yZWNlbnRHaG9zdHMuZGVsZXRlKGtleSk7XG5cbiAgICAvLyBBZGQgdG8gZnJlcXVlbnQgZ2hvc3RzXG4gICAgdGhpcy5mcmVxdWVudEdob3N0cy5hZGQoa2V5KTtcblxuICAgIC8vIE1haW50YWluIHNpemUgbGltaXQgYnkgcmVtb3Zpbmcgb2xkZXN0IGVudHJpZXNcbiAgICB0aGlzLmVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQodGhpcy5mcmVxdWVudEdob3N0cywgdGhpcy5tYXhHaG9zdFNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFudXAgZ2hvc3QgbGlzdHMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICovXG4gIHByaXZhdGUgY2xlYW51cEdob3N0TGlzdHMoKTogdm9pZCB7XG4gICAgdGhpcy5lbmZvcmNlR2hvc3RMaXN0U2l6ZUxpbWl0KHRoaXMucmVjZW50R2hvc3RzLCB0aGlzLm1heEdob3N0U2l6ZSk7XG4gICAgdGhpcy5lbmZvcmNlR2hvc3RMaXN0U2l6ZUxpbWl0KHRoaXMuZnJlcXVlbnRHaG9zdHMsIHRoaXMubWF4R2hvc3RTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmZvcmNlIHNpemUgbGltaXQgb24gYSBnaG9zdCBsaXN0IGJ5IHJlbW92aW5nIG9sZGVzdCBlbnRyaWVzXG4gICAqL1xuICBwcml2YXRlIGVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQoZ2hvc3RMaXN0OiBTZXQ8c3RyaW5nPiwgbWF4U2l6ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKG1heFNpemUgPD0gMCkge1xuICAgICAgZ2hvc3RMaXN0LmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV4Y2VzcyBlbnRyaWVzIGZyb20gdGhlIGJlZ2lubmluZyAob2xkZXN0KVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2hvc3RMaXN0LnZhbHVlcygpO1xuICAgIHdoaWxlIChnaG9zdExpc3Quc2l6ZSA+IG1heFNpemUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgIGJyZWFrOyAvLyBTYWZldHkgY2hlY2sgLSBubyBtb3JlIGl0ZW1zXG4gICAgICB9XG4gICAgICBnaG9zdExpc3QuZGVsZXRlKG5leHQudmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYW4gaXRlbSBzaG91bGQgYmUgY2xhc3NpZmllZCBhcyBmcmVxdWVudCB2cyByZWNlbnRcbiAgICovXG4gIHByaXZhdGUgaXNGcmVxdWVudEl0ZW0obWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSkge1xuICAgICAgLy8gVHJhZGl0aW9uYWwgQVJDIGJlaGF2aW9yXG4gICAgICByZXR1cm4gbWV0YWRhdGEuYWNjZXNzQ291bnQgPiAxO1xuICAgIH1cblxuICAgIC8vIEVuaGFuY2VkIGZyZXF1ZW5jeS1iYXNlZCBjbGFzc2lmaWNhdGlvblxuICAgIGNvbnN0IGZyZXF1ZW5jeSA9IHRoaXMuZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KG1ldGFkYXRhKTtcbiAgICByZXR1cm4gZnJlcXVlbmN5ID49ICh0aGlzLmNvbmZpZy5mcmVxdWVuY3lUaHJlc2hvbGQgPz8gMik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGVmZmVjdGl2ZSBmcmVxdWVuY3kgZm9yIGFuIGl0ZW0sIGFwcGx5aW5nIGRlY2F5IGlmIGVuYWJsZWRcbiAgICovXG4gIHByaXZhdGUgZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSk6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSB8fCAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSB0cmFja2luZ1xuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09ICdudW1iZXInICYmIHR5cGVvZiBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgdGltZVNpbmNlVXBkYXRlID0gbm93IC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICAgIGNvbnN0IGRlY2F5SW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUludGVydmFsID8/IDYwMDAwMDtcblxuICAgICAgLy8gT25seSBhcHBseSBkZWNheSBpZiBzaWduaWZpY2FudCB0aW1lIGhhcyBwYXNzZWRcbiAgICAgIGlmICh0aW1lU2luY2VVcGRhdGUgPiBkZWNheUludGVydmFsIC8gMTApIHsgLy8gQXBwbHkgZGVjYXkgYWZ0ZXIgMTAlIG9mIGludGVydmFsXG4gICAgICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gTWF0aC5taW4oMC45LCAodGltZVNpbmNlVXBkYXRlIC8gZGVjYXlJbnRlcnZhbCkgKiAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMC4wNSkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMSwgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byByYXcgZnJlcXVlbmN5XG4gICAgcmV0dXJuIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZnJlcXVlbmN5IHNjb3JlIHdpdGggZGVjYXkgYXBwbGllZFxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVGcmVxdWVuY3lTY29yZShtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHJhd0ZyZXEgPSBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG5cbiAgICAvLyBJZiBubyBwcmV2aW91cyBmcmVxdWVuY3kgdHJhY2tpbmcsIHN0YXJ0IHdpdGggcmF3IGZyZXF1ZW5jeVxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IGN1cnJlbnRUaW1lIC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICBjb25zdCBkZWNheUludGVydmFsID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA/PyA2MDAwMDA7XG4gICAgY29uc3QgZGVjYXlGYWN0b3IgPSB0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciA/PyAwLjA1O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRlY2F5IGFtb3VudCwgYnV0IGNhcCBpdCB0byBwcmV2ZW50IG92ZXItZGVjYXlcbiAgICBjb25zdCBkZWNheUFtb3VudCA9IE1hdGgubWluKDAuOSwgKHRpbWVTaW5jZVVwZGF0ZSAvIGRlY2F5SW50ZXJ2YWwpICogZGVjYXlGYWN0b3IpO1xuICAgIGNvbnN0IHByZXZpb3VzU2NvcmUgPSBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSB8fCByYXdGcmVxO1xuXG4gICAgLy8gQXBwbHkgZGVjYXkgdG8gcHJldmlvdXMgc2NvcmUgYW5kIGFkZCBuZXcgZnJlcXVlbmN5IGNvbnRyaWJ1dGlvblxuICAgIGNvbnN0IGRlY2F5ZWRTY29yZSA9IE1hdGgubWF4KDEsIHByZXZpb3VzU2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KDEsIGRlY2F5ZWRTY29yZSArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBldmljdGlvbiBjYW5kaWRhdGUgdXNpbmcgZnJlcXVlbmN5LXdlaWdodGVkIGFwcHJvYWNoXG4gICAqL1xuICBwcml2YXRlIHNlbGVjdEZyZXF1ZW5jeVdlaWdodGVkRnJvbUl0ZW1zKGl0ZW1zOiBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4sIGNvbnRleHQ6ICdyZWNlbnQnIHwgJ2ZyZXF1ZW50JyB8ICdmYWxsYmFjaycpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAoaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGJlc3RLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGxldCBiZXN0U2NvcmUgPSBJbmZpbml0eTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBtZXRhZGF0YV0gb2YgaXRlbXMpIHtcbiAgICAgIC8vIFZhbGlkYXRlIG1ldGFkYXRhIHRvIHByZXZlbnQgY29ycnVwdGlvblxuICAgICAgaWYgKCFtZXRhZGF0YSB8fCB0eXBlb2YgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgIT09ICdudW1iZXInIHx8IG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID4gbm93KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgd2VpZ2h0ZWQgc2NvcmUgYmFzZWQgb24gY29udGV4dFxuICAgICAgY29uc3QgZnJlcXVlbmN5ID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGEpO1xuICAgICAgY29uc3QgdGltZUZhY3RvciA9IE1hdGgubWF4KDAsIG5vdyAtIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0KTtcblxuICAgICAgbGV0IHNjb3JlOiBudW1iZXI7XG4gICAgICBpZiAoY29udGV4dCA9PT0gJ3JlY2VudCcpIHtcbiAgICAgICAgLy8gSW4gcmVjZW50IGxpc3QsIHByaW9yaXRpemUgYnkgcmVjZW5jeSBtb3JlIGhlYXZpbHlcbiAgICAgICAgc2NvcmUgPSB0aW1lRmFjdG9yICsgKDEwMDAgLyBNYXRoLm1heCgxLCBmcmVxdWVuY3kpKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gJ2ZyZXF1ZW50Jykge1xuICAgICAgICAvLyBJbiBmcmVxdWVudCBsaXN0LCBiYWxhbmNlIGZyZXF1ZW5jeSBhbmQgcmVjZW5jeVxuICAgICAgICBzY29yZSA9ICh0aW1lRmFjdG9yIC8gMTAwMCkgKyAoMTAgLyBNYXRoLm1heCgxLCBmcmVxdWVuY3kpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIC0gdXNlIGJhbGFuY2VkIGFwcHJvYWNoXG4gICAgICAgIHNjb3JlID0gKHRpbWVGYWN0b3IgLyAxMDAwKSAvIE1hdGgubWF4KDEsIGZyZXF1ZW5jeSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY29yZSA8IGJlc3RTY29yZSkge1xuICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgYmVzdEtleSA9IGtleTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyB2YWxpZCBrZXkgZm91bmQgdGhyb3VnaCBzY29yaW5nLCBmYWxsIGJhY2sgdG8gZmlyc3QgYXZhaWxhYmxlIGtleVxuICAgIGlmIChiZXN0S2V5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmVzdEtleTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBmaXJzdCBhdmFpbGFibGUga2V5IGlmIGl0ZW1zIGV4aXN0XG4gICAgaWYgKGl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdEtleSA9IGl0ZW1zLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gZmlyc3RLZXkgPz8gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBwZXJpb2RpYyBkZWNheSB0byBmcmVxdWVuY3kgc2NvcmVzXG4gICAqL1xuICBwcml2YXRlIGFwcGx5UGVyaW9kaWNEZWNheShpdGVtczogTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSB8fCAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZVNpbmNlRGVjYXkgPSBub3cgLSB0aGlzLmxhc3REZWNheVRpbWU7XG4gICAgY29uc3QgZGVjYXlJbnRlcnZhbCA9IHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgPz8gNjAwMDAwO1xuXG4gICAgaWYgKHRpbWVTaW5jZURlY2F5ID49IGRlY2F5SW50ZXJ2YWwgJiYgaXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGRlY2F5RmFjdG9yID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMC4wNTtcblxuICAgICAgLy8gQXBwbHkgZGVjYXkgdG8gYWxsIGl0ZW1zIHRoYXQgaGF2ZSBmcmVxdWVuY3kgc2NvcmVzXG4gICAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIGl0ZW1zLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHRpbWUtYmFzZWQgZGVjYXkgdG8gaGFuZGxlIGNhc2VzIHdoZXJlIG11bHRpcGxlIGludGVydmFscyBwYXNzZWRcbiAgICAgICAgICBjb25zdCBpbnRlcnZhbHNQYXNzZWQgPSB0aW1lU2luY2VEZWNheSAvIGRlY2F5SW50ZXJ2YWw7XG4gICAgICAgICAgY29uc3QgdG90YWxEZWNheSA9IE1hdGgubWluKDAuOSwgZGVjYXlGYWN0b3IgKiBpbnRlcnZhbHNQYXNzZWQpOyAvLyBDYXAgZGVjYXkgdG8gcHJldmVudCBvdmVyLWRlY2F5XG4gICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSAqICgxIC0gdG90YWxEZWNheSk7XG4gICAgICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSBNYXRoLm1heCgxLCBuZXdTY29yZSk7XG4gICAgICAgICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBub3c7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHN0cmF0ZWd5XG4gICAqL1xuICBnZXRDb25maWcoKTogQVJDQ29uZmlnIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGludGVybmFsIHN0YXRlICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gICAqL1xuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlY2VudEdob3N0cy5jbGVhcigpO1xuICAgIHRoaXMuZnJlcXVlbnRHaG9zdHMuY2xlYXIoKTtcbiAgICB0aGlzLnRhcmdldFJlY2VudFNpemUgPSAwO1xuICAgIHRoaXMubGFzdERlY2F5VGltZSA9IERhdGUubm93KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgYWRhcHRpdmUgc3RhdGUgZm9yIG1vbml0b3JpbmcvZGVidWdnaW5nXG4gICAqL1xuICBnZXRBZGFwdGl2ZVN0YXRlKCk6IHsgdGFyZ2V0UmVjZW50U2l6ZTogbnVtYmVyOyByZWNlbnRHaG9zdFNpemU6IG51bWJlcjsgZnJlcXVlbnRHaG9zdFNpemU6IG51bWJlciB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFyZ2V0UmVjZW50U2l6ZTogdGhpcy50YXJnZXRSZWNlbnRTaXplLFxuICAgICAgcmVjZW50R2hvc3RTaXplOiB0aGlzLnJlY2VudEdob3N0cy5zaXplLFxuICAgICAgZnJlcXVlbnRHaG9zdFNpemU6IHRoaXMuZnJlcXVlbnRHaG9zdHMuc2l6ZVxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhLCBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsIEV2aWN0aW9uQ29udGV4dCwgRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgREVGQVVMVF9UV09fUVVFVUVfQ09ORklHLCBUd29RdWV1ZUNvbmZpZyB9IGZyb20gJy4uL0V2aWN0aW9uU3RyYXRlZ3lDb25maWcnO1xuaW1wb3J0IHsgY3JlYXRlVmFsaWRhdGVkQ29uZmlnIH0gZnJvbSAnLi4vRXZpY3Rpb25TdHJhdGVneVZhbGlkYXRpb24nO1xuXG4vKipcbiAqIDJRIChUd28gUXVldWVzKSBldmljdGlvbiBzdHJhdGVneSB3aXRoIGVuaGFuY2VkIGZyZXF1ZW5jeSB0cmFja2luZ1xuICogTWFpbnRhaW5zIHNlcGFyYXRlIHF1ZXVlcyBmb3IgcmVjZW50IGFuZCBmcmVxdWVudGx5IGFjY2Vzc2VkIGl0ZW1zXG4gKiBVc2VzIGZyZXF1ZW5jeSBhbmFseXNpcyBmb3IgcHJvbW90aW9uIGRlY2lzaW9ucyBhbmQgd2VpZ2h0ZWQgTFJVIGluIGhvdCBxdWV1ZVxuICovXG5leHBvcnQgY2xhc3MgVHdvUXVldWVFdmljdGlvblN0cmF0ZWd5IGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGdldFN0cmF0ZWd5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnMlEnO1xuICB9XG4gIHByaXZhdGUgcmVjZW50UXVldWU6IHN0cmluZ1tdID0gW107IC8vIEExIHF1ZXVlIGZvciByZWNlbnQgaXRlbXNcbiAgcHJpdmF0ZSBob3RRdWV1ZTogc3RyaW5nW10gPSBbXTsgLy8gQW0gcXVldWUgZm9yIGhvdCBpdGVtc1xuICBwcml2YXRlIGdob3N0UXVldWUgPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gQTFvdXQgZ2hvc3QgcXVldWVcbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IFR3b1F1ZXVlQ29uZmlnO1xuICBwcml2YXRlIHJlYWRvbmx5IG1heFJlY2VudFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhHaG9zdFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSBsYXN0RGVjYXlUaW1lOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IobWF4Q2FjaGVTaXplOiBudW1iZXIgPSAxMDAwLCBjb25maWc6IFBhcnRpYWw8VHdvUXVldWVDb25maWc+ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSB7IC4uLkRFRkFVTFRfVFdPX1FVRVVFX0NPTkZJRywgbWF4Q2FjaGVTaXplIH07XG4gICAgdGhpcy5jb25maWcgPSBjcmVhdGVWYWxpZGF0ZWRDb25maWcoYmFzZUNvbmZpZywgY29uZmlnKTtcbiAgICAvLyBBbGxvY2F0ZSAyNSUgdG8gcmVjZW50IHF1ZXVlLCA3NSUgdG8gaG90IHF1ZXVlXG4gICAgdGhpcy5tYXhSZWNlbnRTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0aGlzLmNvbmZpZy5tYXhDYWNoZVNpemUhICogMC4yNSkpO1xuICAgIHRoaXMubWF4R2hvc3RTaXplID0gdGhpcy5jb25maWcubWF4Q2FjaGVTaXplITtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgYXN5bmMgc2VsZWN0Rm9yRXZpY3Rpb24oXG4gICAgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLFxuICAgIGNvbnRleHQ6IEV2aWN0aW9uQ29udGV4dFxuICApOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgaWYgKGFsbE1ldGFkYXRhLnNpemUgPT09IDApIHJldHVybiBbXTtcblxuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBpZiAoZXZpY3Rpb25Db3VudCA8PSAwKSByZXR1cm4gW107XG5cbiAgICAvLyBBcHBseSBwZXJpb2RpYyBkZWNheSBpZiBlbmFibGVkXG4gICAgYXdhaXQgdGhpcy5hcHBseVBlcmlvZGljRGVjYXkoYWxsTWV0YWRhdGEpO1xuXG4gICAgY29uc3Qga2V5c1RvRXZpY3Q6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2aWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgbGV0IGtleVRvRXZpY3Q6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAvLyBGaXJzdCB0cnkgdG8gZXZpY3QgZnJvbSByZWNlbnQgcXVldWUgKEExKSAtIGV2aWN0IG9sZGVzdCAodGFpbCkgb2YgcmVjZW50IHF1ZXVlXG4gICAgICBmb3IgKGxldCBqID0gdGhpcy5yZWNlbnRRdWV1ZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnJlY2VudFF1ZXVlW2pdO1xuICAgICAgICBpZiAoYWxsTWV0YWRhdGEuaGFzKGtleSkgJiYgIWtleXNUb0V2aWN0LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBrZXlUb0V2aWN0ID0ga2V5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIHZhbGlkIGtleSBpbiByZWNlbnQgcXVldWUsIHRyeSBob3QgcXVldWVcbiAgICAgIGlmICgha2V5VG9FdmljdCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcudXNlRnJlcXVlbmN5V2VpZ2h0ZWRMUlUpIHtcbiAgICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5zZWxlY3RGcm9tSG90UXVldWVGcmVxdWVuY3lXZWlnaHRlZChhbGxNZXRhZGF0YSwga2V5c1RvRXZpY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleVRvRXZpY3QgPSB0aGlzLnNlbGVjdEZyb21Ib3RRdWV1ZUxSVShhbGxNZXRhZGF0YSwga2V5c1RvRXZpY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlUb0V2aWN0KSB7XG4gICAgICAgIGtleXNUb0V2aWN0LnB1c2goa2V5VG9FdmljdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhazsgLy8gTm8gbW9yZSBpdGVtcyB0byBldmljdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgZXZpY3Rpb24gY2FuZGlkYXRlIGZyb20gaG90IHF1ZXVlIHVzaW5nIHRyYWRpdGlvbmFsIExSVVxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RGcm9tSG90UXVldWVMUlUoaXRlbXM6IE1hcDxzdHJpbmcsIENhY2hlSXRlbU1ldGFkYXRhPiwgZXhjbHVkZUtleXM6IHN0cmluZ1tdID0gW10pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBsZXQgb2xkZXN0S2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgb2xkZXN0VGltZSA9IEluZmluaXR5O1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5ob3RRdWV1ZSkge1xuICAgICAgaWYgKGV4Y2x1ZGVLZXlzLmluY2x1ZGVzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBpdGVtcy5nZXQoa2V5KTtcbiAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA8IG9sZGVzdFRpbWUpIHtcbiAgICAgICAgb2xkZXN0VGltZSA9IG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0O1xuICAgICAgICBvbGRlc3RLZXkgPSBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZGVzdEtleSB8fCAoaXRlbXMuc2l6ZSA+IDAgPyAoaXRlbXMua2V5cygpLm5leHQoKS52YWx1ZSA/PyBudWxsKSA6IG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBldmljdGlvbiBjYW5kaWRhdGUgZnJvbSBob3QgcXVldWUgdXNpbmcgZnJlcXVlbmN5LXdlaWdodGVkIExSVVxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RGcm9tSG90UXVldWVGcmVxdWVuY3lXZWlnaHRlZChpdGVtczogTWFwPHN0cmluZywgQ2FjaGVJdGVtTWV0YWRhdGE+LCBleGNsdWRlS2V5czogc3RyaW5nW10gPSBbXSk6IHN0cmluZyB8IG51bGwge1xuICAgIGxldCBiZXN0S2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgbG93ZXN0U2NvcmUgPSBJbmZpbml0eTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuaG90UXVldWUpIHtcbiAgICAgIGlmIChleGNsdWRlS2V5cy5pbmNsdWRlcyhrZXkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gaXRlbXMuZ2V0KGtleSk7XG4gICAgICBpZiAoIW1ldGFkYXRhKSBjb250aW51ZTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGZyZXF1ZW5jeS13ZWlnaHRlZCBzY29yZSAobG93ZXIgPSBtb3JlIGxpa2VseSB0byBldmljdClcbiAgICAgIGNvbnN0IGZyZXF1ZW5jeSA9IHRoaXMuZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KG1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IHRpbWVGYWN0b3IgPSBEYXRlLm5vdygpIC0gbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQ7XG5cbiAgICAgIC8vIFNjb3JlIGNvbWJpbmVzIGZyZXF1ZW5jeSAobG93ZXIgaXMgd29yc2UpIGFuZCByZWNlbmN5IChoaWdoZXIgaXMgd29yc2UpXG4gICAgICAvLyBOb3JtYWxpemUgdGltZSBmYWN0b3IgdG8gc2ltaWxhciBzY2FsZSBhcyBmcmVxdWVuY3lcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lRmFjdG9yID0gdGltZUZhY3RvciAvICgxMDAwICogNjApOyAvLyBDb252ZXJ0IHRvIG1pbnV0ZXNcbiAgICAgIGNvbnN0IHNjb3JlID0gbm9ybWFsaXplZFRpbWVGYWN0b3IgLyBNYXRoLm1heCgxLCBmcmVxdWVuY3kpO1xuXG4gICAgICBpZiAoc2NvcmUgPCBsb3dlc3RTY29yZSkge1xuICAgICAgICBsb3dlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICBiZXN0S2V5ID0ga2V5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0S2V5IHx8IChpdGVtcy5zaXplID4gMCA/IChpdGVtcy5rZXlzKCkubmV4dCgpLnZhbHVlID8/IG51bGwpIDogbnVsbCk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1BY2Nlc3NlZChrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IG5vdztcbiAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuXG4gICAgLy8gVXBkYXRlIGZyZXF1ZW5jeSB0cmFja2luZyBzaW1pbGFyIHRvIExGVSBzdHJhdGVneVxuICAgIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSA9IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuXG4gICAgLy8gVXBkYXRlIGZyZXF1ZW5jeSBzY29yZSB3aXRoIGRlY2F5IGlmIGVuYWJsZWRcbiAgICBpZiAoKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IHRoaXMuY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGEsIG5vdyk7XG4gICAgICBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9tb3Rpb24gZnJvbSByZWNlbnQgdG8gaG90IHF1ZXVlXG4gICAgY29uc3QgcmVjZW50SW5kZXggPSB0aGlzLnJlY2VudFF1ZXVlLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAocmVjZW50SW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBJdGVtIGlzIGluIHJlY2VudCBxdWV1ZSAtIGNoZWNrIGlmIGl0IHNob3VsZCBiZSBwcm9tb3RlZFxuICAgICAgaWYgKHRoaXMuc2hvdWxkUHJvbW90ZVRvSG90UXVldWUobWV0YWRhdGEpKSB7XG4gICAgICAgIHRoaXMucmVjZW50UXVldWUuc3BsaWNlKHJlY2VudEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5ob3RRdWV1ZS51bnNoaWZ0KGtleSk7IC8vIEFkZCB0byBmcm9udCBvZiBob3QgcXVldWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uIGluIGhvdCBxdWV1ZSAobW92ZSB0byBmcm9udClcbiAgICAgIGNvbnN0IGhvdEluZGV4ID0gdGhpcy5ob3RRdWV1ZS5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoaG90SW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuaG90UXVldWUuc3BsaWNlKGhvdEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5ob3RRdWV1ZS51bnNoaWZ0KGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIG9uSXRlbUFkZGVkKGtleTogc3RyaW5nLCBlc3RpbWF0ZWRTaXplOiBudW1iZXIsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuXG4gICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgbWV0YWRhdGEgPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgICAgZXN0aW1hdGVkU2l6ZSxcbiAgICAgICAgcmF3RnJlcXVlbmN5OiAxXG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIGZyZXF1ZW5jeSBzY29yZSBmb3IgZGVjYXkgdHJhY2tpbmdcbiAgICAgIGlmICgodGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwKSA+IDApIHtcbiAgICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSAxO1xuICAgICAgICBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgd2FzIGluIGdob3N0IHF1ZXVlIChwcm9tb3RlIHRvIGhvdClcbiAgICBpZiAodGhpcy5naG9zdFF1ZXVlLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmdob3N0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmhvdFF1ZXVlLnVuc2hpZnQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIHRvIHJlY2VudCBxdWV1ZVxuICAgICAgdGhpcy5yZWNlbnRRdWV1ZS51bnNoaWZ0KGtleSk7XG5cbiAgICAgIC8vIExpbWl0IHJlY2VudCBxdWV1ZSBzaXplXG4gICAgICBpZiAodGhpcy5yZWNlbnRRdWV1ZS5sZW5ndGggPiB0aGlzLm1heFJlY2VudFNpemUpIHtcbiAgICAgICAgY29uc3QgZXZpY3RlZCA9IHRoaXMucmVjZW50UXVldWUucG9wKCk7XG4gICAgICAgIGlmIChldmljdGVkKSB7XG4gICAgICAgICAgdGhpcy5naG9zdFF1ZXVlLmFkZChldmljdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExpbWl0IGdob3N0IHF1ZXVlIHNpemVcbiAgICBpZiAodGhpcy5naG9zdFF1ZXVlLnNpemUgPiB0aGlzLm1heEdob3N0U2l6ZSkge1xuICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLmdob3N0UXVldWUudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgaWYgKGZpcnN0S2V5KSB7XG4gICAgICAgIHRoaXMuZ2hvc3RRdWV1ZS5kZWxldGUoZmlyc3RLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cblxuICBhc3luYyBvbkl0ZW1SZW1vdmVkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBSZW1vdmUgZnJvbSBhcHByb3ByaWF0ZSBxdWV1ZVxuICAgIGNvbnN0IHJlY2VudEluZGV4ID0gdGhpcy5yZWNlbnRRdWV1ZS5pbmRleE9mKGtleSk7XG4gICAgaWYgKHJlY2VudEluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5yZWNlbnRRdWV1ZS5zcGxpY2UocmVjZW50SW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdEluZGV4ID0gdGhpcy5ob3RRdWV1ZS5pbmRleE9mKGtleSk7XG4gICAgaWYgKGhvdEluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5ob3RRdWV1ZS5zcGxpY2UoaG90SW5kZXgsIDEpO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG1ldGFkYXRhXG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhbiBpdGVtIHNob3VsZCBiZSBwcm9tb3RlZCBmcm9tIHJlY2VudCB0byBob3QgcXVldWVcbiAgICovXG4gIHByaXZhdGUgc2hvdWxkUHJvbW90ZVRvSG90UXVldWUobWV0YWRhdGE6IENhY2hlSXRlbU1ldGFkYXRhKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy51c2VGcmVxdWVuY3lQcm9tb3Rpb24pIHtcbiAgICAgIC8vIFRyYWRpdGlvbmFsIDJRIGJlaGF2aW9yIC0gcHJvbW90ZSBvbiBzZWNvbmQgYWNjZXNzXG4gICAgICByZXR1cm4gbWV0YWRhdGEuYWNjZXNzQ291bnQgPj0gMjtcbiAgICB9XG5cbiAgICAvLyBGcmVxdWVuY3ktYmFzZWQgcHJvbW90aW9uXG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5jb25maWcucHJvbW90aW9uVGhyZXNob2xkID8/IDI7XG4gICAgY29uc3QgZnJlcXVlbmN5ID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGEpO1xuICAgIHJldHVybiBmcmVxdWVuY3kgPj0gdGhyZXNob2xkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBlZmZlY3RpdmUgZnJlcXVlbmN5IGZvciBhbiBpdGVtLCBhcHBseWluZyBkZWNheSBpZiBlbmFibGVkXG4gICAqL1xuICBwcml2YXRlIGdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YTogQ2FjaGVJdGVtTWV0YWRhdGEpOiBudW1iZXIge1xuICAgIC8vIElmIGRlY2F5IGlzIGRpc2FibGVkLCB1c2UgcmF3IGZyZXF1ZW5jeVxuICAgIGlmICgodGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGZyZXF1ZW5jeSBzY29yZSB3aXRoIGRlY2F5IHRyYWNraW5nXG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG1ldGFkYXRhLmxhc3RGcmVxdWVuY3lVcGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCB0aW1lU2luY2VVcGRhdGUgPSBub3cgLSBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlO1xuICAgICAgY29uc3QgZGVjYXlBbW91bnQgPSAodGltZVNpbmNlVXBkYXRlIC8gKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA/PyAzMDAwMDApKSAqICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDAuMDUpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlICogKDEgLSBkZWNheUFtb3VudCkpO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIHRvIHJhdyBmcmVxdWVuY3lcbiAgICByZXR1cm4gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSBhcHBsaWVkXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZUZyZXF1ZW5jeVNjb3JlKG1ldGFkYXRhOiBDYWNoZUl0ZW1NZXRhZGF0YSwgY3VycmVudFRpbWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgcmF3RnJlcSA9IG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcblxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiByYXdGcmVxO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IGN1cnJlbnRUaW1lIC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICBjb25zdCBkZWNheUFtb3VudCA9ICh0aW1lU2luY2VVcGRhdGUgLyAodGhpcy5jb25maWcuaG90UXVldWVEZWNheUludGVydmFsID8/IDMwMDAwMCkpICogKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMC4wNSk7XG4gICAgY29uc3QgcHJldmlvdXNTY29yZSA9IG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlIHx8IHJhd0ZyZXE7XG5cbiAgICAvLyBBcHBseSBkZWNheSB0byBwcmV2aW91cyBzY29yZSBhbmQgYWRkIG5ldyBmcmVxdWVuY3kgY29udHJpYnV0aW9uXG4gICAgY29uc3QgZGVjYXllZFNjb3JlID0gcHJldmlvdXNTY29yZSAqICgxIC0gZGVjYXlBbW91bnQpO1xuICAgIHJldHVybiBNYXRoLm1heCgxLCBkZWNheWVkU2NvcmUgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBwZXJpb2RpYyBkZWNheSB0byBob3QgcXVldWUgaXRlbXNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYXBwbHlQZXJpb2RpY0RlY2F5KGl0ZW1zOiBNYXA8c3RyaW5nLCBDYWNoZUl0ZW1NZXRhZGF0YT4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZVNpbmNlRGVjYXkgPSBub3cgLSB0aGlzLmxhc3REZWNheVRpbWU7XG5cbiAgICBpZiAodGltZVNpbmNlRGVjYXkgPj0gKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA/PyAzMDAwMDApKSB7XG4gICAgICAvLyBPbmx5IHVwZGF0ZSBsYXN0RGVjYXlUaW1lIGlmIHdlIGFjdHVhbGx5IGhhdmUgaXRlbXMgdG8gZGVjYXlcbiAgICAgIGlmICh0aGlzLmhvdFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQXBwbHkgZGVjYXkgdG8gYWxsIGl0ZW1zIGluIGhvdCBxdWV1ZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmhvdFF1ZXVlKSB7XG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBpdGVtcy5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAobWV0YWRhdGEgJiYgdHlwZW9mIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgZGVjYXlBbW91bnQgPSAodGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwLjA1KTtcbiAgICAgICAgICAgIG1ldGFkYXRhLmZyZXF1ZW5jeVNjb3JlID0gTWF0aC5tYXgoMSwgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdERlY2F5VGltZSA9IG5vdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgc3RyYXRlZ3lcbiAgICovXG4gIGdldENvbmZpZygpOiBUd29RdWV1ZUNvbmZpZyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBpbnRlcm5hbCBzdGF0ZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICAgKi9cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5yZWNlbnRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuaG90UXVldWUgPSBbXTtcbiAgICB0aGlzLmdob3N0UXVldWUuY2xlYXIoKTtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmljdGlvblBvbGljeSB9IGZyb20gJy4uL09wdGlvbnMnO1xuaW1wb3J0IHsgRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQge1xuICBERUZBVUxUX0FSQ19DT05GSUcsXG4gIERFRkFVTFRfVFdPX1FVRVVFX0NPTkZJRyxcbiAgRXZpY3Rpb25TdHJhdGVneUNvbmZpZ3Ncbn0gZnJvbSAnLi9FdmljdGlvblN0cmF0ZWd5Q29uZmlnJztcblxuLy8gSW1wb3J0IGFsbCBzdHJhdGVneSBjbGFzc2VzXG5pbXBvcnQgeyBMUlVFdmljdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zdHJhdGVnaWVzL0xSVUV2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgTEZVRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9MRlVFdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCB7IEZJRk9FdmljdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zdHJhdGVnaWVzL0ZJRk9FdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCB7IE1SVUV2aWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvTVJVRXZpY3Rpb25TdHJhdGVneSc7XG5pbXBvcnQgeyBSYW5kb21FdmljdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zdHJhdGVnaWVzL1JhbmRvbUV2aWN0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgQVJDRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9BUkNFdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCB7IFR3b1F1ZXVlRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9Ud29RdWV1ZUV2aWN0aW9uU3RyYXRlZ3knO1xuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGV2aWN0aW9uIHN0cmF0ZWd5IGluc3RhbmNlcyB3aXRoIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2aWN0aW9uU3RyYXRlZ3koXG4gIHBvbGljeTogRXZpY3Rpb25Qb2xpY3ksXG4gIG1heENhY2hlU2l6ZT86IG51bWJlcixcbiAgY29uZmlnPzogRXZpY3Rpb25TdHJhdGVneUNvbmZpZ3Ncbik6IEV2aWN0aW9uU3RyYXRlZ3kge1xuICAvLyBIYW5kbGUgZWRnZSBjYXNlIG9mIGludmFsaWQgbWF4Q2FjaGVTaXplIGJ5IHVzaW5nIGEgcmVhc29uYWJsZSBkZWZhdWx0XG4gIGNvbnN0IHNhZmVNYXhDYWNoZVNpemUgPSAodHlwZW9mIG1heENhY2hlU2l6ZSA9PT0gJ251bWJlcicgJiYgbWF4Q2FjaGVTaXplID4gMCkgPyBtYXhDYWNoZVNpemUgOiAxMDAwO1xuXG4gIHN3aXRjaCAocG9saWN5KSB7XG4gICAgY2FzZSAnbHJ1JzpcbiAgICAgIHJldHVybiBuZXcgTFJVRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgIGNhc2UgJ2xmdSc6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxmdUNvbmZpZyA9IGNvbmZpZz8udHlwZSA9PT0gJ2xmdScgPyBjb25maWcgOiB7IHR5cGU6ICdsZnUnIGFzIGNvbnN0IH07XG4gICAgICAgIHJldHVybiBuZXcgTEZVRXZpY3Rpb25TdHJhdGVneShsZnVDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgTEZVIHN0cmF0ZWd5IGNyZWF0aW9uIGZhaWxzIGR1ZSB0byBpbnZhbGlkIGNvbmZpZywgZmFsbCBiYWNrIHRvIExSVVxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNyZWF0ZSBsZnUgc3RyYXRlZ3kgd2l0aCBwcm92aWRlZCBjb25maWd1cmF0aW9uLCBmYWxsaW5nIGJhY2sgdG8gTFJVOmAsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJVRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlICdmaWZvJzpcbiAgICAgIHJldHVybiBuZXcgRklGT0V2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICBjYXNlICdtcnUnOlxuICAgICAgcmV0dXJuIG5ldyBNUlVFdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgY2FzZSAncmFuZG9tJzpcbiAgICAgIHJldHVybiBuZXcgUmFuZG9tRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgIGNhc2UgJ2FyYyc6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFyY0NvbmZpZyA9IGNvbmZpZz8udHlwZSA9PT0gJ2FyYycgPyBjb25maWcgOiB7IC4uLkRFRkFVTFRfQVJDX0NPTkZJRywgbWF4Q2FjaGVTaXplOiBzYWZlTWF4Q2FjaGVTaXplIH07XG4gICAgICAgIGNvbnN0IGZpbmFsTWF4U2l6ZSA9IChhcmNDb25maWcubWF4Q2FjaGVTaXplICYmIGFyY0NvbmZpZy5tYXhDYWNoZVNpemUgPiAwKSA/IGFyY0NvbmZpZy5tYXhDYWNoZVNpemUgOiBzYWZlTWF4Q2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gbmV3IEFSQ0V2aWN0aW9uU3RyYXRlZ3koZmluYWxNYXhTaXplLCB7IC4uLmFyY0NvbmZpZywgbWF4Q2FjaGVTaXplOiBmaW5hbE1heFNpemUgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBBUkMgc3RyYXRlZ3kgY3JlYXRpb24gZmFpbHMgZHVlIHRvIGludmFsaWQgY29uZmlnLCBmYWxsIGJhY2sgdG8gTFJVXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY3JlYXRlIGFyYyBzdHJhdGVneSB3aXRoIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24sIGZhbGxpbmcgYmFjayB0byBMUlU6YCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlVFdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhc2UgJzJxJzoge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHdvUUNvbmZpZyA9IGNvbmZpZz8udHlwZSA9PT0gJzJxJyA/IGNvbmZpZyA6IHsgLi4uREVGQVVMVF9UV09fUVVFVUVfQ09ORklHLCBtYXhDYWNoZVNpemU6IHNhZmVNYXhDYWNoZVNpemUgfTtcbiAgICAgICAgY29uc3QgZmluYWxNYXhTaXplID0gKHR3b1FDb25maWcubWF4Q2FjaGVTaXplICYmIHR3b1FDb25maWcubWF4Q2FjaGVTaXplID4gMCkgPyB0d29RQ29uZmlnLm1heENhY2hlU2l6ZSA6IHNhZmVNYXhDYWNoZVNpemU7XG4gICAgICAgIHJldHVybiBuZXcgVHdvUXVldWVFdmljdGlvblN0cmF0ZWd5KGZpbmFsTWF4U2l6ZSwgeyAuLi50d29RQ29uZmlnLCBtYXhDYWNoZVNpemU6IGZpbmFsTWF4U2l6ZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIDJRIHN0cmF0ZWd5IGNyZWF0aW9uIGZhaWxzIGR1ZSB0byBpbnZhbGlkIGNvbmZpZywgZmFsbCBiYWNrIHRvIExSVVxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNyZWF0ZSAycSBzdHJhdGVneSB3aXRoIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24sIGZhbGxpbmcgYmFjayB0byBMUlU6YCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlVFdmljdGlvblN0cmF0ZWd5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGV2aWN0aW9uIHBvbGljeTogJHtwb2xpY3l9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogQGRlcHJlY2F0ZWQgVXNlIGNyZWF0ZUV2aWN0aW9uU3RyYXRlZ3kgd2l0aCBjb25maWcgcGFyYW1ldGVyIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2aWN0aW9uU3RyYXRlZ3lMZWdhY3kocG9saWN5OiBFdmljdGlvblBvbGljeSwgbWF4Q2FjaGVTaXplPzogbnVtYmVyKTogRXZpY3Rpb25TdHJhdGVneSB7XG4gIHJldHVybiBjcmVhdGVFdmljdGlvblN0cmF0ZWd5KHBvbGljeSwgbWF4Q2FjaGVTaXplKTtcbn1cbiIsImltcG9ydCB7IENhY2hlSXRlbU1ldGFkYXRhLCBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgfSBmcm9tICcuLi9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5JztcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSAnLi4vbG9nZ2VyJztcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnVFRMTWFuYWdlcicpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIFRUTCBiZWhhdmlvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRUTENvbmZpZyB7XG4gIC8qKiBEZWZhdWx0IFRUTCBpbiBtaWxsaXNlY29uZHMgZm9yIGFsbCBpdGVtcyAqL1xuICBkZWZhdWx0VFRMPzogbnVtYmVyO1xuICAvKiogV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIGV4cGlyZWQgaXRlbXMgKi9cbiAgYXV0b0NsZWFudXA/OiBib29sZWFuO1xuICAvKiogSW50ZXJ2YWwgZm9yIGF1dG9tYXRpYyBjbGVhbnVwIGluIG1pbGxpc2Vjb25kcyAqL1xuICBjbGVhbnVwSW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIHZhbGlkYXRlIFRUTCBvbiBhY2Nlc3MgKi9cbiAgdmFsaWRhdGVPbkFjY2Vzcz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVFRMLWF3YXJlIGl0ZW0gd3JhcHBlciB0aGF0IGV4dGVuZHMgY2FjaGUgbWV0YWRhdGFcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUVExJdGVtTWV0YWRhdGEgZXh0ZW5kcyBDYWNoZUl0ZW1NZXRhZGF0YSB7XG4gIC8qKiBFeHBpcmF0aW9uIHRpbWVzdGFtcCAoYWRkZWRBdCArIFRUTCkgKi9cbiAgZXhwaXJlc0F0PzogbnVtYmVyO1xuICAvKiogVFRMIHZhbHVlIHVzZWQgZm9yIHRoaXMgc3BlY2lmaWMgaXRlbSAqL1xuICB0dGw/OiBudW1iZXI7XG59XG5cbi8qKlxuICogTWFuYWdlcyBUVEwgKFRpbWUgVG8gTGl2ZSkgbG9naWMgaW5kZXBlbmRlbnRseSBvZiBDYWNoZU1hcCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBUaGlzIGFsbG93cyBhbnkgQ2FjaGVNYXAgdG8gc3VwcG9ydCBUVEwgd2l0aG91dCBpbXBsZW1lbnRpbmcgVFRMLXNwZWNpZmljIGxvZ2ljLlxuICovXG5leHBvcnQgY2xhc3MgVFRMTWFuYWdlciB7XG4gIHByaXZhdGUgY29uZmlnOiBUVExDb25maWc7XG4gIHByaXZhdGUgY2xlYW51cFRpbWVyPzogTm9kZUpTLlRpbWVvdXQgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogVFRMQ29uZmlnID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGF1dG9DbGVhbnVwOiB0cnVlLFxuICAgICAgY2xlYW51cEludGVydmFsOiA2MDAwMCwgLy8gMSBtaW51dGUgZGVmYXVsdFxuICAgICAgdmFsaWRhdGVPbkFjY2VzczogdHJ1ZSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWcuYXV0b0NsZWFudXAgJiYgdGhpcy5jb25maWcuY2xlYW51cEludGVydmFsKSB7XG4gICAgICB0aGlzLnN0YXJ0QXV0b0NsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgVFRMIGlzIGVuYWJsZWRcbiAgICovXG4gIHB1YmxpYyBpc1RUTEVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmNvbmZpZy5kZWZhdWx0VFRMID09PSAnbnVtYmVyJyAmJiB0aGlzLmNvbmZpZy5kZWZhdWx0VFRMID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgVFRMIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgZ2V0RGVmYXVsdFRUTCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kZWZhdWx0VFRMO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBUVEwgY29uZmlndXJhdGlvblxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUNvbmZpZyhjb25maWc6IFBhcnRpYWw8VFRMQ29uZmlnPik6IHZvaWQge1xuICAgIGNvbnN0IG9sZENvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH07XG5cbiAgICAvLyBSZXN0YXJ0IGF1dG8gY2xlYW51cCBpZiBjb25maWd1cmF0aW9uIGNoYW5nZWRcbiAgICBpZiAob2xkQ29uZmlnLmF1dG9DbGVhbnVwICE9PSB0aGlzLmNvbmZpZy5hdXRvQ2xlYW51cCB8fFxuICAgICAgb2xkQ29uZmlnLmNsZWFudXBJbnRlcnZhbCAhPT0gdGhpcy5jb25maWcuY2xlYW51cEludGVydmFsKSB7XG4gICAgICB0aGlzLnN0b3BBdXRvQ2xlYW51cCgpO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9DbGVhbnVwICYmIHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnN0YXJ0QXV0b0NsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoJ1RUTCBjb25maWd1cmF0aW9uIHVwZGF0ZWQnLCB7IGNvbmZpZzogdGhpcy5jb25maWcgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IFRUTCBtZXRhZGF0YSBmb3IgYW4gaXRlbSB3aGVuIGl0J3MgYWRkZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBvbkl0ZW1BZGRlZChcbiAgICBrZXk6IHN0cmluZyxcbiAgICBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIsXG4gICAgaXRlbVRUTD86IG51bWJlclxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuaXNUVExFbmFibGVkKCkgJiYgIWl0ZW1UVEwpIHtcbiAgICAgIHJldHVybjsgLy8gTm8gVFRMIGNvbmZpZ3VyZWRcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICBsb2dnZXIud2FybmluZygnTm8gbWV0YWRhdGEgZm91bmQgZm9yIGl0ZW0gd2hlbiBzZXR0aW5nIFRUTCcsIHsga2V5IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHR0bCA9IGl0ZW1UVEwgfHwgdGhpcy5jb25maWcuZGVmYXVsdFRUTDtcbiAgICBpZiAodHRsICYmIHR0bCA+IDApIHtcbiAgICAgIGNvbnN0IHR0bE1ldGFkYXRhOiBUVExJdGVtTWV0YWRhdGEgPSB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBleHBpcmVzQXQ6IG1ldGFkYXRhLmFkZGVkQXQgKyB0dGwsXG4gICAgICAgIHR0bFxuICAgICAgfTtcbiAgICAgIGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCB0dGxNZXRhZGF0YSk7XG5cbiAgICAgIGxvZ2dlci50cmFjZSgnVFRMIHNldCBmb3IgaXRlbScsIHsga2V5LCB0dGwsIGV4cGlyZXNBdDogdHRsTWV0YWRhdGEuZXhwaXJlc0F0IH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBpdGVtIGhhcyBleHBpcmVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaXNFeHBpcmVkKGtleTogc3RyaW5nLCBtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KSBhcyBUVExJdGVtTWV0YWRhdGE7XG4gICAgaWYgKCFtZXRhZGF0YSB8fCAhbWV0YWRhdGEuZXhwaXJlc0F0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIFRUTCBzZXRcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSBub3cgPj0gbWV0YWRhdGEuZXhwaXJlc0F0O1xuXG4gICAgaWYgKGV4cGlyZWQpIHtcbiAgICAgIGxvZ2dlci50cmFjZSgnSXRlbSBleHBpcmVkJywgeyBrZXksIGV4cGlyZXNBdDogbWV0YWRhdGEuZXhwaXJlc0F0LCBub3cgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGlyZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gaXRlbSBpcyB2YWxpZCAobm90IGV4cGlyZWQpIGJlZm9yZSByZXR1cm5pbmcgaXRcbiAgICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgdmFsaWQsIGZhbHNlIGlmIGV4cGlyZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyB2YWxpZGF0ZUl0ZW0oa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5jb25maWcudmFsaWRhdGVPbkFjY2Vzcykge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFNraXAgdmFsaWRhdGlvbiBpZiBkaXNhYmxlZFxuICAgIH1cblxuICAgIHJldHVybiAhKGF3YWl0IHRoaXMuaXNFeHBpcmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUVEwgaW5mb3JtYXRpb24gZm9yIGFuIGl0ZW1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRJdGVtVFRMSW5mbyhrZXk6IHN0cmluZywgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyKTogUHJvbWlzZTx7XG4gICAgaGFzVFRMOiBib29sZWFuO1xuICAgIHR0bD86IG51bWJlcjtcbiAgICBleHBpcmVzQXQ/OiBudW1iZXI7XG4gICAgcmVtYWluaW5nVFRMPzogbnVtYmVyO1xuICAgIGlzRXhwaXJlZDogYm9vbGVhbjtcbiAgfT4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpIGFzIFRUTEl0ZW1NZXRhZGF0YTtcblxuICAgIGlmICghbWV0YWRhdGEgfHwgIW1ldGFkYXRhLmV4cGlyZXNBdCkge1xuICAgICAgcmV0dXJuIHsgaGFzVFRMOiBmYWxzZSwgaXNFeHBpcmVkOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaXNFeHBpcmVkID0gbm93ID49IG1ldGFkYXRhLmV4cGlyZXNBdDtcbiAgICBjb25zdCByZW1haW5pbmdUVEwgPSBpc0V4cGlyZWQgPyAwIDogbWV0YWRhdGEuZXhwaXJlc0F0IC0gbm93O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc1RUTDogdHJ1ZSxcbiAgICAgIHR0bDogbWV0YWRhdGEudHRsLFxuICAgICAgZXhwaXJlc0F0OiBtZXRhZGF0YS5leHBpcmVzQXQsXG4gICAgICByZW1haW5pbmdUVEwsXG4gICAgICBpc0V4cGlyZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGV4cGlyZWQgaXRlbXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBmaW5kRXhwaXJlZEl0ZW1zKG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBleHBpcmVkS2V5czogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBtZXRhZGF0YV0gb2YgYWxsTWV0YWRhdGEpIHtcbiAgICAgIGNvbnN0IHR0bE1ldGFkYXRhID0gbWV0YWRhdGEgYXMgVFRMSXRlbU1ldGFkYXRhO1xuICAgICAgaWYgKHR0bE1ldGFkYXRhLmV4cGlyZXNBdCAmJiBub3cgPj0gdHRsTWV0YWRhdGEuZXhwaXJlc0F0KSB7XG4gICAgICAgIGV4cGlyZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhwaXJlZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdGb3VuZCBleHBpcmVkIGl0ZW1zJywgeyBjb3VudDogZXhwaXJlZEtleXMubGVuZ3RoLCBrZXlzOiBleHBpcmVkS2V5cyB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwaXJlZEtleXM7XG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgY2xlYW4gdXAgZXhwaXJlZCBpdGVtc1xuICAgKiBSZXR1cm5zIHRoZSBrZXlzIG9mIGl0ZW1zIHRoYXQgd2VyZSBleHBpcmVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY2xlYW51cEV4cGlyZWRJdGVtcyhtZXRhZGF0YVByb3ZpZGVyOiBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZEV4cGlyZWRJdGVtcyhtZXRhZGF0YVByb3ZpZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcmVtYWluaW5nIFRUTCBmb3IgYW4gaXRlbSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRSZW1haW5pbmdUVEwoa2V5OiBzdHJpbmcsIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcik6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmdldEl0ZW1UVExJbmZvKGtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgcmV0dXJuIGluZm8uaGFzVFRMID8gKGluZm8ucmVtYWluaW5nVFRMIHx8IDApIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgVFRMIGZvciBhbiBpdGVtXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZXh0ZW5kVFRMKFxuICAgIGtleTogc3RyaW5nLFxuICAgIG1ldGFkYXRhUHJvdmlkZXI6IENhY2hlTWFwTWV0YWRhdGFQcm92aWRlcixcbiAgICBhZGRpdGlvbmFsVFRMOiBudW1iZXJcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSkgYXMgVFRMSXRlbU1ldGFkYXRhO1xuICAgIGlmICghbWV0YWRhdGEgfHwgIW1ldGFkYXRhLmV4cGlyZXNBdCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBUVEwgc2V0XG4gICAgfVxuXG4gICAgbWV0YWRhdGEuZXhwaXJlc0F0ICs9IGFkZGl0aW9uYWxUVEw7XG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcblxuICAgIGxvZ2dlci50cmFjZSgnVFRMIGV4dGVuZGVkIGZvciBpdGVtJywgeyBrZXksIGFkZGl0aW9uYWxUVEwsIG5ld0V4cGlyZXNBdDogbWV0YWRhdGEuZXhwaXJlc0F0IH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IFRUTCBmb3IgYW4gaXRlbSAocmVmcmVzaCBleHBpcmF0aW9uKVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlZnJlc2hUVEwoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgbWV0YWRhdGFQcm92aWRlcjogQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyLFxuICAgIG5ld1RUTD86IG51bWJlclxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KSBhcyBUVExJdGVtTWV0YWRhdGE7XG4gICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHR0bCA9IG5ld1RUTCB8fCBtZXRhZGF0YS50dGwgfHwgdGhpcy5jb25maWcuZGVmYXVsdFRUTDtcbiAgICBpZiAoIXR0bCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBUVEwgdG8gc2V0XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0dGxNZXRhZGF0YTogVFRMSXRlbU1ldGFkYXRhID0ge1xuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICBleHBpcmVzQXQ6IG5vdyArIHR0bCxcbiAgICAgIHR0bFxuICAgIH07XG4gICAgYXdhaXQgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIHR0bE1ldGFkYXRhKTtcblxuICAgIGxvZ2dlci50cmFjZSgnVFRMIHJlZnJlc2hlZCBmb3IgaXRlbScsIHsga2V5LCB0dGwsIGV4cGlyZXNBdDogdHRsTWV0YWRhdGEuZXhwaXJlc0F0IH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGF1dG9tYXRpYyBjbGVhbnVwIG9mIGV4cGlyZWQgaXRlbXNcbiAgICovXG4gIHByaXZhdGUgc3RhcnRBdXRvQ2xlYW51cCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIHRoaXMuc3RvcEF1dG9DbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgd2lsbCBiZSBpbXBsZW1lbnRlZCB3aGVuIHdlIGludGVncmF0ZSB3aXRoIENhY2hlIGNsYXNzXG4gICAgICAgIGxvZ2dlci50cmFjZSgnQXV0byBjbGVhbnVwIHRpbWVyIHRyaWdnZXJlZCcpO1xuICAgICAgfSwgdGhpcy5jb25maWcuY2xlYW51cEludGVydmFsKTtcblxuICAgICAgbG9nZ2VyLmRlYnVnKCdBdXRvIGNsZWFudXAgc3RhcnRlZCcsIHsgaW50ZXJ2YWw6IHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhdXRvbWF0aWMgY2xlYW51cFxuICAgKi9cbiAgcHJpdmF0ZSBzdG9wQXV0b0NsZWFudXAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQXV0byBjbGVhbnVwIHN0b3BwZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW51cCByZXNvdXJjZXNcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcEF1dG9DbGVhbnVwKCk7XG4gICAgbG9nZ2VyLmRlYnVnKCdUVEwgbWFuYWdlciBkZXN0cm95ZWQnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tS2V5LCBJdGVtLCBJdGVtUXVlcnksIExvY0tleSwgTG9jS2V5QXJyYXksIFByaUtleSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHtcbiAgQW55Q2FjaGVFdmVudCxcbiAgQ2FjaGVFdmVudExpc3RlbmVyLFxuICBDYWNoZVN1YnNjcmlwdGlvbixcbiAgQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zXG59IGZyb20gXCIuL0NhY2hlRXZlbnRUeXBlc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplS2V5VmFsdWUgfSBmcm9tIFwiLi4vbm9ybWFsaXphdGlvblwiO1xuXG4vKipcbiAqIEludGVybmFsIHN1YnNjcmlwdGlvbiBkYXRhXG4gKi9cbmludGVyZmFjZSBJbnRlcm5hbFN1YnNjcmlwdGlvbjxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiB7XG4gIGlkOiBzdHJpbmc7XG4gIGxpc3RlbmVyOiBDYWNoZUV2ZW50TGlzdGVuZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgbGlzdGVuZXJSZWY/OiBXZWFrUmVmPENhY2hlRXZlbnRMaXN0ZW5lcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PjtcbiAgb3B0aW9uczogQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBkZWJvdW5jZVRpbWVyPzogTm9kZUpTLlRpbWVvdXQgfCBudWxsO1xuICBsYXN0RW1pdFRpbWU/OiBudW1iZXI7XG4gIGNyZWF0ZWRBdDogbnVtYmVyO1xuICBsYXN0QWNjZXNzVGltZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIENhY2hlIGV2ZW50IGVtaXR0ZXIgdGhhdCBtYW5hZ2VzIHN1YnNjcmlwdGlvbnMgYW5kIGV2ZW50IGRpc3BhdGNoaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWNoZUV2ZW50RW1pdHRlcjxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBJbnRlcm5hbFN1YnNjcmlwdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PigpO1xuICBwcml2YXRlIG5leHRTdWJzY3JpcHRpb25JZCA9IDE7XG4gIHByaXZhdGUgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBjbGVhbnVwSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVhZG9ubHkgQ0xFQU5VUF9JTlRFUlZBTF9NUyA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX0lOQUNUSVZFX1RJTUVfTVMgPSAzMDAwMDA7IC8vIDUgbWludXRlc1xuICBwcml2YXRlIHJlYWRvbmx5IFdFQUtfUkVGX0VOQUJMRUQgPSB0eXBlb2YgV2Vha1JlZiAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGFydFBlcmlvZGljQ2xlYW51cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBlcmlvZGljIGNsZWFudXAgb2YgaW5hY3RpdmUgc3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFBlcmlvZGljQ2xlYW51cCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwpIHJldHVybjtcblxuICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5wZXJmb3JtUGVyaW9kaWNDbGVhbnVwKCk7XG4gICAgfSwgdGhpcy5DTEVBTlVQX0lOVEVSVkFMX01TKTtcblxuICAgIC8vIERvbid0IGtlZXAgdGhlIHByb2Nlc3MgYWxpdmUganVzdCBmb3IgY2xlYW51cFxuICAgIGlmICh0aGlzLmNsZWFudXBJbnRlcnZhbC51bnJlZikge1xuICAgICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwudW5yZWYoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBwZXJpb2RpYyBjbGVhbnVwIG9mIGluYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIHByaXZhdGUgcGVyZm9ybVBlcmlvZGljQ2xlYW51cCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0b1JlbW92ZTogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2lkLCBzdWJzY3JpcHRpb25dIG9mIHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgLy8gQ2hlY2sgaWYgc3Vic2NyaXB0aW9uIGlzIGluYWN0aXZlIGZvciB0b28gbG9uZ1xuICAgICAgaWYgKCFzdWJzY3JpcHRpb24uaXNBY3RpdmUgfHxcbiAgICAgICAgKG5vdyAtIHN1YnNjcmlwdGlvbi5sYXN0QWNjZXNzVGltZSA+IHRoaXMuTUFYX0lOQUNUSVZFX1RJTUVfTVMpKSB7XG4gICAgICAgIHRvUmVtb3ZlLnB1c2goaWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgbGlzdGVuZXIgaGFzIGJlZW4gZ2FyYmFnZSBjb2xsZWN0ZWQgKGZvciB3ZWFrIHJlZmVyZW5jZXMpXG4gICAgICBpZiAodGhpcy5XRUFLX1JFRl9FTkFCTEVEICYmIHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZi5kZXJlZigpO1xuICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgdG9SZW1vdmUucHVzaChpZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgaW5hY3RpdmUgc3Vic2NyaXB0aW9uc1xuICAgIHRvUmVtb3ZlLmZvckVhY2goaWQgPT4gdGhpcy51bnN1YnNjcmliZShpZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBjYWNoZSBldmVudHNcbiAgICovXG4gIHB1YmxpYyBzdWJzY3JpYmUoXG4gICAgbGlzdGVuZXI6IENhY2hlRXZlbnRMaXN0ZW5lcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIG9wdGlvbnM6IENhY2hlU3Vic2NyaXB0aW9uT3B0aW9uczxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0ge31cbiAgKTogQ2FjaGVTdWJzY3JpcHRpb24ge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdWJzY3JpYmUgdG8gZGVzdHJveWVkIGV2ZW50IGVtaXR0ZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGBzdWJzY3JpcHRpb25fJHt0aGlzLm5leHRTdWJzY3JpcHRpb25JZCsrfWA7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbjogSW50ZXJuYWxTdWJzY3JpcHRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9IHtcbiAgICAgIGlkLFxuICAgICAgbGlzdGVuZXIsXG4gICAgICBsaXN0ZW5lclJlZjogdGhpcy5XRUFLX1JFRl9FTkFCTEVEICYmIG9wdGlvbnMudXNlV2Vha1JlZiAhPT0gZmFsc2UgP1xuICAgICAgICBuZXcgV2Vha1JlZihsaXN0ZW5lcikgOiB1bmRlZmluZWQsXG4gICAgICBvcHRpb25zLFxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NUaW1lOiBub3dcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcblxuICAgIC8vIFJldHVybiBwdWJsaWMgc3Vic2NyaXB0aW9uIGludGVyZmFjZVxuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB0aGlzLnVuc3Vic2NyaWJlKGlkKSxcbiAgICAgIGlzQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgc3ViLmxhc3RBY2Nlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViPy5pc0FjdGl2ZSA/PyBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBnZXRPcHRpb25zOiAoKSA9PiAoeyAuLi5vcHRpb25zIH0pIGFzIENhY2hlU3Vic2NyaXB0aW9uT3B0aW9uczxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIGV2ZW50c1xuICAgKi9cbiAgcHVibGljIHVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHN1YnNjcmlwdGlvbklkKTtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIGRlYm91bmNlIHRpbWVyXG4gICAgaWYgKHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIpO1xuICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHN1YnNjcmlwdGlvbi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoc3Vic2NyaXB0aW9uSWQpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhbiBldmVudCB0byBhbGwgbWF0Y2hpbmcgc3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgcHVibGljIGVtaXQoZXZlbnQ6IEFueUNhY2hlRXZlbnQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2YgdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIXN1YnNjcmlwdGlvbi5pc0FjdGl2ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvdWxkRW1pdFRvU3Vic2NyaXB0aW9uKGV2ZW50LCBzdWJzY3JpcHRpb24pKSB7XG4gICAgICAgIHRoaXMuZW1pdFRvU3Vic2NyaXB0aW9uKGV2ZW50LCBzdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY291bnQgb2YgYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIHB1YmxpYyBnZXRTdWJzY3JpcHRpb25Db3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHMgPT4gcy5pc0FjdGl2ZSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdWJzY3JpcHRpb24gZGV0YWlscyAoZm9yIGRlYnVnZ2luZylcbiAgICovXG4gIHB1YmxpYyBnZXRTdWJzY3JpcHRpb25zKCk6IEFycmF5PHsgaWQ6IHN0cmluZzsgb3B0aW9uczogQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSlcbiAgICAgIC5maWx0ZXIocyA9PiBzLmlzQWN0aXZlKVxuICAgICAgLm1hcChzID0+ICh7IGlkOiBzLmlkLCBvcHRpb25zOiB7IC4uLnMub3B0aW9ucyB9IH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBldmVudCBlbWl0dGVyIGFuZCBjbGVhbiB1cCBhbGwgc3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gU3RvcCBwZXJpb2RpYyBjbGVhbnVwXG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cEludGVydmFsKTtcbiAgICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBhbGwgZGVib3VuY2UgdGltZXJzXG4gICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2YgdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gZXZlbnQgc2hvdWxkIGJlIGVtaXR0ZWQgdG8gYSBzcGVjaWZpYyBzdWJzY3JpcHRpb25cbiAgICovXG4gIHByaXZhdGUgc2hvdWxkRW1pdFRvU3Vic2NyaXB0aW9uKFxuICAgIGV2ZW50OiBBbnlDYWNoZUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgc3Vic2NyaXB0aW9uOiBJbnRlcm5hbFN1YnNjcmlwdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc3Vic2NyaXB0aW9uO1xuXG4gICAgLy8gRmlsdGVyIGJ5IGV2ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5ldmVudFR5cGVzICYmICFvcHRpb25zLmV2ZW50VHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYnkgc3BlY2lmaWMga2V5c1xuICAgIGlmIChvcHRpb25zLmtleXMgJiYgb3B0aW9ucy5rZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICgna2V5JyBpbiBldmVudCkge1xuICAgICAgICBjb25zdCBldmVudEtleVN0ciA9IHRoaXMubm9ybWFsaXplS2V5KGV2ZW50LmtleSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXNLZXkgPSBvcHRpb25zLmtleXMuc29tZShrZXkgPT5cbiAgICAgICAgICB0aGlzLm5vcm1hbGl6ZUtleShrZXkpID09PSBldmVudEtleVN0clxuICAgICAgICApO1xuICAgICAgICBpZiAoIW1hdGNoZXNLZXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJ2FmZmVjdGVkS2V5cycgaW4gZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRLZXlTdHJzID0gZXZlbnQuYWZmZWN0ZWRLZXlzLm1hcChrZXkgPT4gdGhpcy5ub3JtYWxpemVLZXkoa2V5KSk7XG4gICAgICAgIGNvbnN0IGhhc01hdGNoaW5nS2V5ID0gb3B0aW9ucy5rZXlzLnNvbWUoa2V5ID0+XG4gICAgICAgICAgZXZlbnRLZXlTdHJzLmluY2x1ZGVzKHRoaXMubm9ybWFsaXplS2V5KGtleSkpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghaGFzTWF0Y2hpbmdLZXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV2ZW50IGRvZXNuJ3QgaGF2ZSBrZXlzLCBza2lwIGlmIHN1YnNjcmlwdGlvbiBpcyBrZXktc3BlY2lmaWNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbHRlciBieSBsb2NhdGlvbnNcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMgJiYgb3B0aW9ucy5sb2NhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKCdhZmZlY3RlZExvY2F0aW9ucycgaW4gZXZlbnQgJiYgZXZlbnQuYWZmZWN0ZWRMb2NhdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2F0aW9uc01hdGNoKG9wdGlvbnMubG9jYXRpb25zLCBldmVudC5hZmZlY3RlZExvY2F0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJ2xvY2F0aW9ucycgaW4gZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2F0aW9uc01hdGNoKG9wdGlvbnMubG9jYXRpb25zLCBldmVudC5sb2NhdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCdrZXknIGluIGV2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpdGVtIGtleSBtYXRjaGVzIHRoZSBsb2NhdGlvbiBmaWx0ZXJcbiAgICAgICAgaWYgKCF0aGlzLmtleU1hdGNoZXNMb2NhdGlvbnMoZXZlbnQua2V5LCBvcHRpb25zLmxvY2F0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV2ZW50IGRvZXNuJ3QgaGF2ZSBsb2NhdGlvbiBpbmZvLCBza2lwIGlmIHN1YnNjcmlwdGlvbiBpcyBsb2NhdGlvbi1zcGVjaWZpY1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGJ5IHF1ZXJ5ICh0aGlzIGlzIG1vcmUgY29tcGxleCBhbmQgYXBwcm94aW1hdGUpXG4gICAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICAgIGlmICgncXVlcnknIGluIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5xdWVyaWVzTWF0Y2gob3B0aW9ucy5xdWVyeSwgZXZlbnQucXVlcnkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLXF1ZXJ5IGV2ZW50cywgd2UgY2FuJ3QgZWFzaWx5IGRldGVybWluZSBpZiB0aGV5IG1hdGNoIGEgcXVlcnkgZmlsdGVyXG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgZW5oYW5jZWQgd2l0aCBtb3JlIHNvcGhpc3RpY2F0ZWQgcXVlcnkgbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBldmVudCB0byBhIHNwZWNpZmljIHN1YnNjcmlwdGlvbiwgaGFuZGxpbmcgZGVib3VuY2luZ1xuICAgKi9cbiAgcHJpdmF0ZSBlbWl0VG9TdWJzY3JpcHRpb24oXG4gICAgZXZlbnQ6IEFueUNhY2hlRXZlbnQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBzdWJzY3JpcHRpb246IEludGVybmFsU3Vic2NyaXB0aW9uPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGxhc3QgYWNjZXNzIHRpbWUgZm9yIGNsZWFudXAgcHVycG9zZXNcbiAgICBzdWJzY3JpcHRpb24ubGFzdEFjY2Vzc1RpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gR2V0IHRoZSBsaXN0ZW5lciwgZWl0aGVyIGRpcmVjdGx5IG9yIGZyb20gd2VhayByZWZlcmVuY2VcbiAgICBsZXQgbGlzdGVuZXIgPSBzdWJzY3JpcHRpb24ubGlzdGVuZXI7XG4gICAgaWYgKHRoaXMuV0VBS19SRUZfRU5BQkxFRCAmJiBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYpIHtcbiAgICAgIGNvbnN0IHdlYWtMaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZi5kZXJlZigpO1xuICAgICAgaWYgKCF3ZWFrTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gTGlzdGVuZXIgaGFzIGJlZW4gZ2FyYmFnZSBjb2xsZWN0ZWQsIG1hcmsgYXMgaW5hY3RpdmVcbiAgICAgICAgc3Vic2NyaXB0aW9uLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyID0gd2Vha0xpc3RlbmVyO1xuICAgIH1cblxuICAgIGlmICghc3Vic2NyaXB0aW9uLm9wdGlvbnMuZGVib3VuY2VNcykge1xuICAgICAgLy8gTm8gZGVib3VuY2luZywgZW1pdCBpbW1lZGlhdGVseVxuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVMaXN0ZW5lckVycm9yKGVycm9yLCBldmVudCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBleGlzdGluZyBkZWJvdW5jZSB0aW1lclxuICAgIGlmIChzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZXQgbmV3IGRlYm91bmNlIHRpbWVyXG4gICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uaXNBY3RpdmUpIHtcbiAgICAgICAgLy8gUmUtY2hlY2sgbGlzdGVuZXIgYXZhaWxhYmlsaXR5IGZvciB3ZWFrIHJlZmVyZW5jZXNcbiAgICAgICAgbGV0IGN1cnJlbnRMaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lcjtcbiAgICAgICAgaWYgKHRoaXMuV0VBS19SRUZfRU5BQkxFRCAmJiBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYpIHtcbiAgICAgICAgICBjb25zdCB3ZWFrTGlzdGVuZXIgPSBzdWJzY3JpcHRpb24ubGlzdGVuZXJSZWYuZGVyZWYoKTtcbiAgICAgICAgICBpZiAoIXdlYWtMaXN0ZW5lcikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRMaXN0ZW5lciA9IHdlYWtMaXN0ZW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY3VycmVudExpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24ubGFzdEVtaXRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUxpc3RlbmVyRXJyb3IoZXJyb3IsIGV2ZW50LCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDbGVhciB0aGUgdGltZXIgcmVmZXJlbmNlIHRvIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgIH0sIHN1YnNjcmlwdGlvbi5vcHRpb25zLmRlYm91bmNlTXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBhIGtleSBmb3IgY29tcGFyaXNvblxuICAgKi9cbiAgcHJpdmF0ZSBub3JtYWxpemVLZXkoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSwgKGssIHYpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVLZXlWYWx1ZSh2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBhIGxvY2F0aW9uIGtleSBmb3IgY29tcGFyaXNvblxuICAgKi9cbiAgcHJpdmF0ZSBub3JtYWxpemVMb2NLZXkoa2V5OiBMb2NLZXk8TDEgfCBMMiB8IEwzIHwgTDQgfCBMNT4pOiBzdHJpbmcge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXksIChrLCB2KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplS2V5VmFsdWUodik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gbG9jYXRpb24gYXJyYXlzIG1hdGNoXG4gICAqIEZpbHRlciBsb2NhdGlvbnMgbXVzdCBiZSBhIHByZWZpeCBvZiBldmVudCBsb2NhdGlvbnMgKGluIG9yZGVyKVxuICAgKi9cbiAgcHJpdmF0ZSBsb2NhdGlvbnNNYXRjaChcbiAgICBmaWx0ZXI6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSxcbiAgICBldmVudExvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIEVtcHR5IGZpbHRlciBvbmx5IG1hdGNoZXMgZW1wdHkgZXZlbnQgbG9jYXRpb25zXG4gICAgaWYgKGZpbHRlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBldmVudExvY2F0aW9ucy5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGNhbm5vdCBiZSBsb25nZXIgdGhhbiBldmVudCBsb2NhdGlvbnNcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCA+IGV2ZW50TG9jYXRpb25zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGZpbHRlciBsb2NhdGlvbnMgYXJlIGEgcHJlZml4IG9mIGV2ZW50IGxvY2F0aW9uc1xuICAgIHJldHVybiBmaWx0ZXIuZXZlcnkoKGZpbHRlckxvYywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50TG9jID0gZXZlbnRMb2NhdGlvbnNbaW5kZXhdO1xuICAgICAgLy8gTG9jS2V5IGhhcyBkaWZmZXJlbnQgc3RydWN0dXJlIGZyb20gQ29tS2V5L1ByaUtleSwgc28gd2UgbmVlZCB0byBub3JtYWxpemUgdXNpbmcgdGhlaXIgb3duIHByb3BlcnRpZXNcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUtleShmaWx0ZXJMb2MgYXMgYW55KSA9PT0gdGhpcy5ub3JtYWxpemVLZXkoZXZlbnRMb2MgYXMgYW55KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtleSBtYXRjaGVzIGxvY2F0aW9uIGZpbHRlcnNcbiAgICovXG4gIHByaXZhdGUga2V5TWF0Y2hlc0xvY2F0aW9ucyhcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGZpbHRlckxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIElmIGtleSBpcyBhIENvbUtleSwgY2hlY2sgaWYgaXRzIGxvY2F0aW9ucyBtYXRjaCB0aGUgZmlsdGVyXG4gICAgaWYgKCdsb2MnIGluIGtleSAmJiBrZXkubG9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbnNNYXRjaChmaWx0ZXJMb2NhdGlvbnMsIGtleS5sb2MpO1xuICAgIH1cblxuICAgIC8vIFByaUtleSBkb2Vzbid0IGhhdmUgbG9jYXRpb25zLCBzbyBvbmx5IG1hdGNoZXMgaWYgZmlsdGVyIGlzIGVtcHR5XG4gICAgcmV0dXJuIGZpbHRlckxvY2F0aW9ucy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIHF1ZXJpZXMgbWF0Y2ggKGltcHJvdmVkIGNvbXBhcmlzb24pXG4gICAqL1xuICBwcml2YXRlIHF1ZXJpZXNNYXRjaChmaWx0ZXJRdWVyeTogSXRlbVF1ZXJ5LCBldmVudFF1ZXJ5OiBJdGVtUXVlcnkpOiBib29sZWFuIHtcbiAgICAvLyBOb3JtYWxpemUgcXVlcmllcyBmb3IgY29uc2lzdGVudCBjb21wYXJpc29uXG4gICAgY29uc3Qgbm9ybWFsaXplID0gKG9iajogYW55KTogYW55ID0+IHtcbiAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBvYmo7XG4gICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybiBvYmo7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcChub3JtYWxpemUpLnNvcnQoKTtcblxuICAgICAgY29uc3Qgc29ydGVkOiBhbnkgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG9iaikuc29ydCgpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgc29ydGVkW2tleV0gPSBub3JtYWxpemUob2JqW2tleV0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydGVkO1xuICAgIH07XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplKGZpbHRlclF1ZXJ5KSkgPT09IEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZShldmVudFF1ZXJ5KSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGVycm9ycyB0aGF0IG9jY3VyIGluIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgcHJpdmF0ZSBoYW5kbGVMaXN0ZW5lckVycm9yKFxuICAgIGVycm9yOiB1bmtub3duLFxuICAgIGV2ZW50OiBBbnlDYWNoZUV2ZW50PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgc3Vic2NyaXB0aW9uOiBJbnRlcm5hbFN1YnNjcmlwdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGVycm9yT2JqID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpO1xuXG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vcHRpb25zLm9uRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5vcHRpb25zLm9uRXJyb3IoZXJyb3JPYmosIGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGhhbmRsZXJFcnJvcikge1xuICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaGFuZGxlciBpdHNlbGYgdGhyb3dzLCBsb2cgYm90aCBlcnJvcnNcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY2FjaGUgZXZlbnQgbGlzdGVuZXI6JywgZXJyb3JPYmopO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBoYW5kbGVyOicsIGhhbmRsZXJFcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNhY2hlIGV2ZW50IGxpc3RlbmVyOicsIGVycm9yT2JqKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ2FjaGUgc3RhdGlzdGljcyB0cmFja2luZyBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWNoZVN0YXRzIHtcbiAgLyoqIFRvdGFsIG51bWJlciBvZiBjYWNoZSByZXF1ZXN0cyAoZ2V0L3JldHJpZXZlIG9wZXJhdGlvbnMpICovXG4gIG51bVJlcXVlc3RzOiBudW1iZXI7XG4gIC8qKiBUb3RhbCBudW1iZXIgb2YgY2FjaGUgbWlzc2VzIChpdGVtcyBub3QgZm91bmQgaW4gY2FjaGUpICovXG4gIG51bU1pc3NlczogbnVtYmVyO1xuICAvKiogVG90YWwgbnVtYmVyIG9mIGNhY2hlIGhpdHMgKGl0ZW1zIGZvdW5kIGluIGNhY2hlKSAqL1xuICBudW1IaXRzOiBudW1iZXI7XG4gIC8qKiBUb3RhbCBudW1iZXIgb2Ygc3Vic2NyaXB0aW9uIHJlcXVlc3RzICovXG4gIG51bVN1YnNjcmlwdGlvbnM6IG51bWJlcjtcbiAgLyoqIFRvdGFsIG51bWJlciBvZiB1bnN1YnNjcmlwdGlvbiByZXF1ZXN0cyAqL1xuICBudW1VbnN1YnNjcmlwdGlvbnM6IG51bWJlcjtcbiAgLyoqIEN1cnJlbnQgbnVtYmVyIG9mIGFjdGl2ZSBzdWJzY3JpcHRpb25zICovXG4gIGFjdGl2ZVN1YnNjcmlwdGlvbnM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDYWNoZSBzdGF0aXN0aWNzIG1hbmFnZXIgdGhhdCB0cmFja3MgdmFyaW91cyBjYWNoZSBtZXRyaWNzXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWNoZVN0YXRzTWFuYWdlciB7XG4gIHByaXZhdGUgc3RhdHM6IENhY2hlU3RhdHMgPSB7XG4gICAgbnVtUmVxdWVzdHM6IDAsXG4gICAgbnVtTWlzc2VzOiAwLFxuICAgIG51bUhpdHM6IDAsXG4gICAgbnVtU3Vic2NyaXB0aW9uczogMCxcbiAgICBudW1VbnN1YnNjcmlwdGlvbnM6IDAsXG4gICAgYWN0aXZlU3Vic2NyaXB0aW9uczogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHJlcXVlc3QgY291bnRlclxuICAgKi9cbiAgaW5jcmVtZW50UmVxdWVzdHMoKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0cy5udW1SZXF1ZXN0cysrO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgY2FjaGUgaGl0IGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudEhpdHMoKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0cy5udW1IaXRzKys7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBjYWNoZSBtaXNzIGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudE1pc3NlcygpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRzLm51bU1pc3NlcysrO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgc3Vic2NyaXB0aW9uIGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudFN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0cy5udW1TdWJzY3JpcHRpb25zKys7XG4gICAgdGhpcy5zdGF0cy5hY3RpdmVTdWJzY3JpcHRpb25zKys7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSB1bnN1YnNjcmlwdGlvbiBjb3VudGVyXG4gICAqL1xuICBpbmNyZW1lbnRVbnN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0cy5udW1VbnN1YnNjcmlwdGlvbnMrKztcbiAgICBpZiAodGhpcy5zdGF0cy5hY3RpdmVTdWJzY3JpcHRpb25zID4gMCkge1xuICAgICAgdGhpcy5zdGF0cy5hY3RpdmVTdWJzY3JpcHRpb25zLS07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgc3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0U3RhdHMoKTogQ2FjaGVTdGF0cyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5zdGF0cyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBzdGF0aXN0aWNzIHRvIHplcm9cbiAgICovXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICBudW1SZXF1ZXN0czogMCxcbiAgICAgIG51bU1pc3NlczogMCxcbiAgICAgIG51bUhpdHM6IDAsXG4gICAgICBudW1TdWJzY3JpcHRpb25zOiAwLFxuICAgICAgbnVtVW5zdWJzY3JpcHRpb25zOiAwLFxuICAgICAgYWN0aXZlU3Vic2NyaXB0aW9uczogMFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IEl0ZW0gfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEluc3RhbmNlIGFzIEJhc2VJbnN0YW5jZSwgQ29vcmRpbmF0ZSwgUmVnaXN0cnkgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiQGZqZWxsL2NsaWVudC1hcGlcIjtcbmltcG9ydCB7IENhY2hlTWFwIH0gZnJvbSBcIi4vQ2FjaGVNYXBcIjtcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdGlvbnMsIE9wZXJhdGlvbnMgfSBmcm9tIFwiLi9PcGVyYXRpb25zXCI7XG5pbXBvcnQgeyBjcmVhdGVDYWNoZU1hcCwgY3JlYXRlT3B0aW9ucywgT3B0aW9ucyB9IGZyb20gXCIuL09wdGlvbnNcIjtcbmltcG9ydCB7IEV2aWN0aW9uTWFuYWdlciB9IGZyb20gXCIuL2V2aWN0aW9uL0V2aWN0aW9uTWFuYWdlclwiO1xuaW1wb3J0IHsgY3JlYXRlRXZpY3Rpb25TdHJhdGVneSB9IGZyb20gXCIuL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lGYWN0b3J5XCI7XG5pbXBvcnQgeyBUVExNYW5hZ2VyIH0gZnJvbSBcIi4vdHRsL1RUTE1hbmFnZXJcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RW1pdHRlciB9IGZyb20gXCIuL2V2ZW50cy9DYWNoZUV2ZW50RW1pdHRlclwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudExpc3RlbmVyLCBDYWNoZVN1YnNjcmlwdGlvbiwgQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zIH0gZnJvbSBcIi4vZXZlbnRzL0NhY2hlRXZlbnRUeXBlc1wiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEZhY3RvcnkgfSBmcm9tIFwiLi9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnlcIjtcbmltcG9ydCB7IENhY2hlU3RhdHMsIENhY2hlU3RhdHNNYW5hZ2VyIH0gZnJvbSBcIi4vQ2FjaGVTdGF0c1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdDYWNoZScpO1xuXG4vKipcbiAqIENhY2hlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb24gZXhwb3NlZCB0byBjbGllbnQgYXBwbGljYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVJbmZvIHtcbiAgLyoqIFRoZSBpbXBsZW1lbnRhdGlvbiB0eXBlIGluIGZvcm1hdCBcIjxjYXRlZ29yeT4vPGltcGxlbWVudGF0aW9uPlwiICovXG4gIGltcGxlbWVudGF0aW9uVHlwZTogc3RyaW5nO1xuICAvKiogVGhlIGV2aWN0aW9uIHBvbGljeSBiZWluZyB1c2VkIChpZiBhbnkpICovXG4gIGV2aWN0aW9uUG9saWN5Pzogc3RyaW5nO1xuICAvKiogRGVmYXVsdCBUVEwgaW4gbWlsbGlzZWNvbmRzIChpZiBjb25maWd1cmVkKSAqL1xuICBkZWZhdWx0VFRMPzogbnVtYmVyO1xuICAvKiogV2hldGhlciBUVEwgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24gKi9cbiAgc3VwcG9ydHNUVEw6IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIGV2aWN0aW9uIGlzIHN1cHBvcnRlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uICovXG4gIHN1cHBvcnRzRXZpY3Rpb246IGJvb2xlYW47XG59XG5cbi8qKlxuICogVGhlIENhY2hlIGludGVyZmFjZSBleHRlbmRzIHRoZSBiYXNlIEluc3RhbmNlIGZyb20gQGZqZWxsL3JlZ2lzdHJ5IGFuZCBhZGRzIGNhY2hlIG9wZXJhdGlvbnNcbiAqIGZvciBpbnRlcmFjdGluZyB3aXRoIGNhY2hlZCBkYXRhLlxuICpcbiAqIFRoZSBpbnRlcmZhY2UgZXh0ZW5kcyB0aGUgYmFzZSBJbnN0YW5jZSAod2hpY2ggcHJvdmlkZXMgY29vcmRpbmF0ZSBhbmQgcmVnaXN0cnkpIHdpdGg6XG4gKiAtIGFwaTogUHJvdmlkZXMgbWV0aG9kcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBzZXJ2ZXIgQVBJXG4gKiAtIGNhY2hlTWFwOiBMb2NhbCBjYWNoZSBzdG9yYWdlIGZvciBpdGVtc1xuICogLSBvcGVyYXRpb25zOiBBbGwgY2FjaGUgb3BlcmF0aW9ucyAoZ2V0LCBzZXQsIGFsbCwgZXRjLikgdGhhdCB3b3JrIHdpdGggYm90aCBjYWNoZSBhbmQgQVBJXG4gKlxuICogQHRlbXBsYXRlIFYgLSBUaGUgdHlwZSBvZiB0aGUgZGF0YSBtb2RlbCBpdGVtLCBleHRlbmRpbmcgSXRlbVxuICogQHRlbXBsYXRlIFMgLSBUaGUgc3RyaW5nIGxpdGVyYWwgdHlwZSByZXByZXNlbnRpbmcgdGhlIG1vZGVsJ3Mga2V5IHR5cGVcbiAqIEB0ZW1wbGF0ZSBMMS1MNSAtIE9wdGlvbmFsIHN0cmluZyBsaXRlcmFsIHR5cGVzIGZvciBsb2NhdGlvbiBoaWVyYXJjaHkgbGV2ZWxzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGU8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBCYXNlSW5zdGFuY2U8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gIC8qKiBUaGUgQVBJIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBzZXJ2ZXIgZW5kcG9pbnRzICovXG4gIGFwaTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgLyoqIFRoZSBjYWNoZSBtYXAgdGhhdCBzdG9yZXMgY2FjaGVkIGl0ZW1zICovXG4gIGNhY2hlTWFwOiBDYWNoZU1hcDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKiBBbGwgY2FjaGUgb3BlcmF0aW9ucyB0aGF0IHdvcmsgd2l0aCBib3RoIGNhY2hlIGFuZCBBUEkgKi9cbiAgb3BlcmF0aW9uczogT3BlcmF0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKiBDYWNoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgKi9cbiAgb3B0aW9ucz86IE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogRXZlbnQgZW1pdHRlciBmb3IgY2FjaGUgZXZlbnRzICovXG4gIGV2ZW50RW1pdHRlcjogQ2FjaGVFdmVudEVtaXR0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAvKiogRXZpY3Rpb24gbWFuYWdlciBmb3IgaGFuZGxpbmcgY2FjaGUgZXZpY3Rpb24gaW5kZXBlbmRlbnRseSBvZiBzdG9yYWdlICovXG4gIGV2aWN0aW9uTWFuYWdlcjogRXZpY3Rpb25NYW5hZ2VyO1xuXG4gIC8qKiBUVEwgbWFuYWdlciBmb3IgaGFuZGxpbmcgdGltZS10by1saXZlIGluZGVwZW5kZW50bHkgb2Ygc3RvcmFnZSAqL1xuICB0dGxNYW5hZ2VyOiBUVExNYW5hZ2VyO1xuXG4gIC8qKiBTdGF0aXN0aWNzIG1hbmFnZXIgZm9yIHRyYWNraW5nIGNhY2hlIG1ldHJpY3MgKi9cbiAgc3RhdHNNYW5hZ2VyOiBDYWNoZVN0YXRzTWFuYWdlcjtcblxuICAvKipcbiAgICogR2V0IGNhY2hlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb24gZm9yIGNsaWVudCBhcHBsaWNhdGlvbnNcbiAgICogUHJvdmlkZXMgdmlzaWJpbGl0eSBpbnRvIGltcGxlbWVudGF0aW9uIHR5cGUsIGV2aWN0aW9uIHBvbGljeSwgVFRMIHNldHRpbmdzLCBhbmQgY2FwYWJpbGl0aWVzXG4gICAqL1xuICBnZXRDYWNoZUluZm8oKTogQ2FjaGVJbmZvO1xuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBjYWNoZSBzdGF0aXN0aWNzXG4gICAqIEByZXR1cm5zIEN1cnJlbnQgY2FjaGUgc3RhdGlzdGljcyBpbmNsdWRpbmcgaGl0cywgbWlzc2VzLCByZXF1ZXN0cywgYW5kIHN1YnNjcmlwdGlvbiBjb3VudHNcbiAgICovXG4gIGdldFN0YXRzKCk6IENhY2hlU3RhdHM7XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBjYWNoZSBldmVudHNcbiAgICogQHBhcmFtIGxpc3RlbmVyIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVudHMgb2NjdXJcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgZmlsdGVycyBmb3Igd2hpY2ggZXZlbnRzIHRvIHJlY2VpdmVcbiAgICogQHJldHVybnMgU3Vic2NyaXB0aW9uIG9iamVjdCB3aXRoIHVuc3Vic2NyaWJlIG1ldGhvZFxuICAgKi9cbiAgc3Vic2NyaWJlKFxuICAgIGxpc3RlbmVyOiBDYWNoZUV2ZW50TGlzdGVuZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBvcHRpb25zPzogQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogQ2FjaGVTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gY2FjaGUgZXZlbnRzXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gU3Vic2NyaXB0aW9uIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHN1YnNjcmlwdGlvbiB3YXMgZm91bmQgYW5kIGNhbmNlbGxlZFxuICAgKi9cbiAgdW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uOiBDYWNoZVN1YnNjcmlwdGlvbik6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGNhY2hlIGFuZCBjbGVhbiB1cCBhbGwgcmVzb3VyY2VzXG4gICAqL1xuICBkZXN0cm95KCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDYWNoZSA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBhcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGNvb3JkaW5hdGU6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICByZWdpc3RyeTogUmVnaXN0cnksXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8T3B0aW9uczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PlxuICApOiBDYWNoZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgbG9nZ2VyLmRlYnVnKCdjcmVhdGVDYWNoZScsIHsgY29vcmRpbmF0ZSwgcmVnaXN0cnksIG9wdGlvbnMgfSk7XG5cbiAgLy8gQ3JlYXRlIGNvbXBsZXRlIG9wdGlvbnMgd2l0aCBkZWZhdWx0c1xuICBjb25zdCBjb21wbGV0ZU9wdGlvbnMgPSBjcmVhdGVPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIENyZWF0ZSB0aGUgY2FjaGUgbWFwIHVzaW5nIHRoZSBvcHRpb25zXG4gIGNvbnN0IGNhY2hlTWFwID0gY3JlYXRlQ2FjaGVNYXA8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pihjb29yZGluYXRlLmt0YSwgY29tcGxldGVPcHRpb25zKTtcblxuICAvLyBHZXQgdGhlIHByaW1hcnkga2V5IHR5cGUgZnJvbSB0aGUgY29vcmRpbmF0ZVxuICBjb25zdCBwa1R5cGUgPSBjb29yZGluYXRlLmt0YVswXSBhcyBTO1xuXG4gIC8vIENyZWF0ZSBldmVudCBlbWl0dGVyXG4gIGNvbnN0IGV2ZW50RW1pdHRlciA9IG5ldyBDYWNoZUV2ZW50RW1pdHRlcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KCk7XG5cbiAgLy8gQ3JlYXRlIGV2aWN0aW9uIG1hbmFnZXJcbiAgY29uc3QgZXZpY3Rpb25NYW5hZ2VyID0gbmV3IEV2aWN0aW9uTWFuYWdlcigpO1xuXG4gIC8vIERldGVybWluZSBldmljdGlvbiBjb25maWd1cmF0aW9uIC0gcHJpb3JpdGl6ZSB0b3AtbGV2ZWwgZXZpY3Rpb25Db25maWdcbiAgY29uc3QgZXZpY3Rpb25Db25maWcgPSBjb21wbGV0ZU9wdGlvbnMuZXZpY3Rpb25Db25maWc7XG4gIGlmICghZXZpY3Rpb25Db25maWcgJiZcbiAgICBjb21wbGV0ZU9wdGlvbnMubWVtb3J5Q29uZmlnPy5zaXplPy5ldmljdGlvblBvbGljeSAmJlxuICAgIChjb21wbGV0ZU9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4SXRlbXMgfHwgY29tcGxldGVPcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heFNpemVCeXRlcykpIHtcbiAgfVxuXG4gIGlmIChldmljdGlvbkNvbmZpZykge1xuICAgIC8vIFNldCBldmljdGlvbiBzdHJhdGVneSBmcm9tIHVuaWZpZWQgY29uZmlnXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjcmVhdGVFdmljdGlvblN0cmF0ZWd5KFxuICAgICAgZXZpY3Rpb25Db25maWcudHlwZSB8fCAnbHJ1JyxcbiAgICAgIGNvbXBsZXRlT3B0aW9ucy5tZW1vcnlDb25maWc/Lm1heEl0ZW1zLFxuICAgICAgZXZpY3Rpb25Db25maWdcbiAgICApO1xuICAgIGV2aWN0aW9uTWFuYWdlci5zZXRFdmljdGlvblN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBUVEwgbWFuYWdlciB3aXRoIHByb3BlciBjb25maWd1cmF0aW9uIHByaW9yaXR5OiBtZW1vcnlDb25maWcudHRsIHx8IHR0bFxuICBjb25zdCB0dGxNYW5hZ2VyID0gbmV3IFRUTE1hbmFnZXIoe1xuICAgIGRlZmF1bHRUVEw6IGNvbXBsZXRlT3B0aW9ucy50dGwsXG4gICAgYXV0b0NsZWFudXA6IHRydWUsXG4gICAgdmFsaWRhdGVPbkFjY2VzczogdHJ1ZVxuICB9KTtcblxuICAvLyBDcmVhdGUgc3RhdGlzdGljcyBtYW5hZ2VyXG4gIGNvbnN0IHN0YXRzTWFuYWdlciA9IG5ldyBDYWNoZVN0YXRzTWFuYWdlcigpO1xuXG4gIC8vIE5vdGU6IEV2aWN0aW9uTWFuYWdlciBvcGVyYXRlcyBpbmRlcGVuZGVudGx5IG9mIENhY2hlTWFwIGltcGxlbWVudGF0aW9uc1xuICAvLyBhbmQgaXMgcGFzc2VkIHRocm91Z2ggQ2FjaGVDb250ZXh0IHRvIG9wZXJhdGlvbnMgZm9yIGV4dGVybmFsIGV2aWN0aW9uIG1hbmFnZW1lbnRcblxuICAvLyBDcmVhdGUgb3BlcmF0aW9ucyB3aXRoIGV2ZW50IGVtaXR0ZXIsIGV2aWN0aW9uIG1hbmFnZXIsIGFuZCBzdGF0cyBtYW5hZ2VyXG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVPcGVyYXRpb25zKGFwaSwgY29vcmRpbmF0ZSwgY2FjaGVNYXAsIHBrVHlwZSwgY29tcGxldGVPcHRpb25zLCBldmVudEVtaXR0ZXIsIHR0bE1hbmFnZXIsIGV2aWN0aW9uTWFuYWdlciwgc3RhdHNNYW5hZ2VyKTtcblxuICBjb25zdCBjYWNoZTogQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9IHtcbiAgICBjb29yZGluYXRlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGFwaSxcbiAgICBjYWNoZU1hcCxcbiAgICBvcGVyYXRpb25zLFxuICAgIG9wdGlvbnM6IGNvbXBsZXRlT3B0aW9ucyxcbiAgICBldmVudEVtaXR0ZXIsXG4gICAgZXZpY3Rpb25NYW5hZ2VyLFxuICAgIHR0bE1hbmFnZXIsXG4gICAgc3RhdHNNYW5hZ2VyLFxuICAgIGdldENhY2hlSW5mbzogKCkgPT4ge1xuICAgICAgY29uc3QgZXZpY3Rpb25TdHJhdGVneU5hbWUgPSBldmljdGlvbk1hbmFnZXIuZ2V0RXZpY3Rpb25TdHJhdGVneU5hbWUoKTtcbiAgICAgIGNvbnN0IGNhY2hlSW5mbzogQ2FjaGVJbmZvID0ge1xuICAgICAgICBpbXBsZW1lbnRhdGlvblR5cGU6IGNhY2hlTWFwLmltcGxlbWVudGF0aW9uVHlwZSxcbiAgICAgICAgZGVmYXVsdFRUTDogdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCksXG4gICAgICAgIC8vIENhY2hlIHN1cHBvcnRzIFRUTCBpZiB0aGUgQ2FjaGVNYXAgc3VwcG9ydHMgaXQgT1IgaWYgVFRMIGlzIGNvbmZpZ3VyZWRcbiAgICAgICAgc3VwcG9ydHNUVEw6IChjYWNoZU1hcCBhcyBhbnkpLnN1cHBvcnRzVFRMPy4oKSB8fCAhIXR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpLFxuICAgICAgICBzdXBwb3J0c0V2aWN0aW9uOiBldmljdGlvbk1hbmFnZXIuaXNFdmljdGlvblN1cHBvcnRlZCgpXG4gICAgICB9O1xuXG4gICAgICBpZiAoZXZpY3Rpb25TdHJhdGVneU5hbWUpIHtcbiAgICAgICAgY2FjaGVJbmZvLmV2aWN0aW9uUG9saWN5ID0gZXZpY3Rpb25TdHJhdGVneU5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZUluZm87XG4gICAgfSxcbiAgICBnZXRTdGF0czogKCkgPT4gc3RhdHNNYW5hZ2VyLmdldFN0YXRzKCksXG4gICAgc3Vic2NyaWJlOiAobGlzdGVuZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRTdWJzY3JpcHRpb25zKCk7XG4gICAgICByZXR1cm4gZXZlbnRFbWl0dGVyLnN1YnNjcmliZShsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICB1bnN1YnNjcmliZTogKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXZlbnRFbWl0dGVyLnVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbi5pZCk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRVbnN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cCBldmVudCBlbWl0dGVyXG4gICAgICBldmVudEVtaXR0ZXIuZGVzdHJveSgpO1xuXG4gICAgICAvLyBDbGVhbiB1cCBUVEwgbWFuYWdlclxuICAgICAgaWYgKHR0bE1hbmFnZXIgJiYgdHlwZW9mIHR0bE1hbmFnZXIuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0dGxNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdXAgZXZpY3Rpb24gbWFuYWdlciAoRXZpY3Rpb25NYW5hZ2VyIGRvZXNuJ3QgbmVlZCBleHBsaWNpdCBjbGVhbnVwKVxuICAgICAgLy8gZXZpY3Rpb25NYW5hZ2VyIGlzIHN0YXRlbGVzcyBhbmQgZG9lc24ndCByZXF1aXJlIGRlc3RydWN0aW9uXG5cbiAgICAgIC8vIENsZWFuIHVwIGNhY2hlIG1hcCBpZiBpdCBoYXMgYSBkZXN0cm95IG1ldGhvZFxuICAgICAgaWYgKGNhY2hlTWFwICYmIHR5cGVvZiAoY2FjaGVNYXAgYXMgYW55KS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIChjYWNoZU1hcCBhcyBhbnkpLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm90aWZ5IENhY2hlRXZlbnRGYWN0b3J5IHRoYXQgYW4gaW5zdGFuY2UgaXMgYmVpbmcgZGVzdHJveWVkXG4gICAgICBDYWNoZUV2ZW50RmFjdG9yeS5kZXN0cm95SW5zdGFuY2UoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzQ2FjaGUgPSAoY2FjaGU6IGFueSk6IGNhY2hlIGlzIENhY2hlPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4gPT4ge1xuICByZXR1cm4gY2FjaGUgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgY2FjaGUgPT09ICdvYmplY3QnICYmXG4gICAgJ2Nvb3JkaW5hdGUnIGluIGNhY2hlICYmXG4gICAgJ3JlZ2lzdHJ5JyBpbiBjYWNoZSAmJlxuICAgICdhcGknIGluIGNhY2hlICYmXG4gICAgJ2NhY2hlTWFwJyBpbiBjYWNoZSAmJlxuICAgICdvcGVyYXRpb25zJyBpbiBjYWNoZTtcbn07XG4iLCJpbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiQGZqZWxsL2NsaWVudC1hcGlcIjtcbmltcG9ydCB7IEluc3RhbmNlRmFjdG9yeSBhcyBCYXNlSW5zdGFuY2VGYWN0b3J5LCBSZWdpc3RyeSwgUmVnaXN0cnlIdWIgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBJbnN0YW5jZSB9IGZyb20gXCIuL0luc3RhbmNlXCI7XG5pbXBvcnQgeyBDb29yZGluYXRlIH0gZnJvbSBcIkBmamVsbC9yZWdpc3RyeVwiO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0aW9ucyB9IGZyb20gXCIuL09wZXJhdGlvbnNcIjtcbmltcG9ydCB7IGNyZWF0ZUNhY2hlTWFwLCBjcmVhdGVPcHRpb25zLCBPcHRpb25zLCB2YWxpZGF0ZU9wdGlvbnMgfSBmcm9tIFwiLi9PcHRpb25zXCI7XG5pbXBvcnQgeyBUVExNYW5hZ2VyIH0gZnJvbSBcIi4vdHRsL1RUTE1hbmFnZXJcIjtcbmltcG9ydCB7IEV2aWN0aW9uTWFuYWdlciB9IGZyb20gXCIuL2V2aWN0aW9uL0V2aWN0aW9uTWFuYWdlclwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi9ldmVudHMvQ2FjaGVFdmVudEVtaXR0ZXJcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBDYWNoZVN0YXRzTWFuYWdlciB9IGZyb20gXCIuL0NhY2hlU3RhdHNcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIkluc3RhbmNlRmFjdG9yeVwiKTtcblxuZXhwb3J0IHR5cGUgSW5zdGFuY2VGYWN0b3J5PFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gKFxuICBhcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+XG4pID0+IEJhc2VJbnN0YW5jZUZhY3Rvcnk8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBjYWNoZSBpbnN0YW5jZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUluc3RhbmNlRmFjdG9yeSA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBhcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIG9wdGlvbnM/OiBQYXJ0aWFsPE9wdGlvbnM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj5cbiAgKTogQmFzZUluc3RhbmNlRmFjdG9yeTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcblxuICAvLyBDcmVhdGUgYW5kIHZhbGlkYXRlIGEgdGVtcGxhdGUgb2Ygb3B0aW9ucyAtIHRoaXMgdmFsaWRhdGVzIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gIGNvbnN0IHRlbXBsYXRlT3B0aW9ucyA9IGNyZWF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gIHZhbGlkYXRlT3B0aW9ucyh0ZW1wbGF0ZU9wdGlvbnMpO1xuXG4gIHJldHVybiAoY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBjb250ZXh0OiB7IHJlZ2lzdHJ5OiBSZWdpc3RyeSwgcmVnaXN0cnlIdWI/OiBSZWdpc3RyeUh1YiB9KSA9PiB7XG4gICAgLy8gQ3JlYXRlIGZyZXNoIG9wdGlvbnMgZm9yIGVhY2ggaW5zdGFuY2UgdG8gZW5zdXJlIGltbXV0YWJpbGl0eVxuICAgIGNvbnN0IGluc3RhbmNlT3B0aW9ucyA9IGNyZWF0ZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBsb2dnZXIuZGVidWcoXCJDcmVhdGluZyBjYWNoZSBpbnN0YW5jZVwiLCB7XG4gICAgICBjb29yZGluYXRlLFxuICAgICAgcmVnaXN0cnk6IGNvbnRleHQucmVnaXN0cnksXG4gICAgICBhcGksXG4gICAgICBjYWNoZVR5cGU6IGluc3RhbmNlT3B0aW9ucy5jYWNoZVR5cGUsXG4gICAgICBvcHRpb25zOiBpbnN0YW5jZU9wdGlvbnNcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgY2FjaGUgbWFwIGJhc2VkIG9uIG9wdGlvbnNcbiAgICBjb25zdCBjYWNoZU1hcCA9IGNyZWF0ZUNhY2hlTWFwPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oY29vcmRpbmF0ZS5rdGEsIGluc3RhbmNlT3B0aW9ucyk7XG4gICAgY29uc3QgcGtUeXBlID0gY29vcmRpbmF0ZS5rdGFbMF0gYXMgUztcblxuICAgIC8vIENyZWF0ZSBwcm9wZXIgbWFuYWdlcnMgaW5zdGVhZCBvZiBtb2Nrc1xuICAgIGNvbnN0IGV2ZW50RW1pdHRlciA9IG5ldyBDYWNoZUV2ZW50RW1pdHRlcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KCk7XG4gICAgY29uc3QgdHRsTWFuYWdlciA9IG5ldyBUVExNYW5hZ2VyKHtcbiAgICAgIGRlZmF1bHRUVEw6IGluc3RhbmNlT3B0aW9ucy50dGwsXG4gICAgICBhdXRvQ2xlYW51cDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlT25BY2Nlc3M6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBldmljdGlvbk1hbmFnZXIgPSBuZXcgRXZpY3Rpb25NYW5hZ2VyKCk7XG4gICAgY29uc3Qgc3RhdHNNYW5hZ2VyID0gbmV3IENhY2hlU3RhdHNNYW5hZ2VyKCk7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IGNyZWF0ZU9wZXJhdGlvbnMoXG4gICAgICBhcGksIGNvb3JkaW5hdGUsIGNhY2hlTWFwLCBwa1R5cGUsIGluc3RhbmNlT3B0aW9ucywgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIHN0YXRzTWFuYWdlcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHJlZ2lzdHJ5OiBjb250ZXh0LnJlZ2lzdHJ5LFxuICAgICAgYXBpLFxuICAgICAgY2FjaGVNYXAsXG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgb3B0aW9uczogaW5zdGFuY2VPcHRpb25zLFxuICAgICAgZXZlbnRFbWl0dGVyLFxuICAgICAgdHRsTWFuYWdlcixcbiAgICAgIGV2aWN0aW9uTWFuYWdlcixcbiAgICAgIGdldENhY2hlSW5mbzogKCkgPT4ge1xuICAgICAgICBjb25zdCBldmljdGlvblN0cmF0ZWd5TmFtZSA9IGV2aWN0aW9uTWFuYWdlci5nZXRFdmljdGlvblN0cmF0ZWd5TmFtZSgpO1xuICAgICAgICBjb25zdCBjYWNoZUluZm8gPSB7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25UeXBlOiBjYWNoZU1hcC5pbXBsZW1lbnRhdGlvblR5cGUsXG4gICAgICAgICAgZGVmYXVsdFRUTDogdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCksXG4gICAgICAgICAgc3VwcG9ydHNUVEw6IChjYWNoZU1hcCBhcyBhbnkpLnN1cHBvcnRzVFRMPy4oKSB8fCAhIXR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpLFxuICAgICAgICAgIHN1cHBvcnRzRXZpY3Rpb246IGV2aWN0aW9uTWFuYWdlci5pc0V2aWN0aW9uU3VwcG9ydGVkKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2aWN0aW9uU3RyYXRlZ3lOYW1lKSB7XG4gICAgICAgICAgKGNhY2hlSW5mbyBhcyBhbnkpLmV2aWN0aW9uUG9saWN5ID0gZXZpY3Rpb25TdHJhdGVneU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlSW5mbztcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmU6IChsaXN0ZW5lciwgb3B0aW9ucykgPT4gZXZlbnRFbWl0dGVyLnN1YnNjcmliZShsaXN0ZW5lciwgb3B0aW9ucyksXG4gICAgICB1bnN1YnNjcmliZTogKHN1YnNjcmlwdGlvbikgPT4gZXZlbnRFbWl0dGVyLnVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbi5pZCksXG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdHRsTWFuYWdlci5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHRsTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRFbWl0dGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9IGFzIEluc3RhbmNlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gIH07XG59O1xuIiwiXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuaW1wb3J0IHsgSXRlbSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSwgUmVnaXN0cnkgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiQGZqZWxsL2NsaWVudC1hcGlcIjtcbmltcG9ydCB7IENhY2hlLCBjcmVhdGVDYWNoZSB9IGZyb20gXCIuL0NhY2hlXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJJbnN0YW5jZVwiKTtcblxuLyoqXG4gKiBUaGUgQ2FjaGUgSW5zdGFuY2UgaW50ZXJmYWNlIHJlcHJlc2VudHMgYSBjYWNoZSBtb2RlbCBpbnN0YW5jZSB0aGF0IGV4dGVuZHMgdGhlIGJhc2UgSW5zdGFuY2VcbiAqIGZyb20gQGZqZWxsL3JlZ2lzdHJ5IGFuZCBhZGRzIGNhY2hlIG9wZXJhdGlvbnMgZm9yIGludGVyYWN0aW5nIHdpdGggY2FjaGVkIGRhdGEuXG4gKlxuICogVGhpcyBpcyBhIHR5cGUgYWxpYXMgZm9yIHRoZSBDYWNoZSBpbnRlcmZhY2UuIEJvdGggQ2FjaGUgYW5kIEluc3RhbmNlIHJlZmVyIHRvIHRoZSBzYW1lXG4gKiBjYWNoZSBpbnRlcmZhY2UgLSBJbnN0YW5jZSBleGlzdHMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYW5kIGNvbnNpc3RlbmN5IHdpdGggb3RoZXJcbiAqIEZqZWxsIHBhY2thZ2VzIHRoYXQgZXhwb3J0IEluc3RhbmNlIHR5cGVzLlxuICpcbiAqIEB0ZW1wbGF0ZSBWIC0gVGhlIHR5cGUgb2YgdGhlIGRhdGEgbW9kZWwgaXRlbSwgZXh0ZW5kaW5nIEl0ZW1cbiAqIEB0ZW1wbGF0ZSBTIC0gVGhlIHN0cmluZyBsaXRlcmFsIHR5cGUgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCdzIGtleSB0eXBlXG4gKiBAdGVtcGxhdGUgTDEtTDUgLSBPcHRpb25hbCBzdHJpbmcgbGl0ZXJhbCB0eXBlcyBmb3IgbG9jYXRpb24gaGllcmFyY2h5IGxldmVsc1xuICovXG5leHBvcnQgdHlwZSBJbnN0YW5jZTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9IENhY2hlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnN0YW5jZSA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICByZWdpc3RyeTogUmVnaXN0cnksXG4gICAgY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGFwaTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8aW1wb3J0KCcuL09wdGlvbnMnKS5PcHRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+XG4gICk6IEluc3RhbmNlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBsb2dnZXIuZGVidWcoXCJjcmVhdGVJbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIGFwaSwgcmVnaXN0cnksIG9wdGlvbnMgfSk7XG4gIHJldHVybiBjcmVhdGVDYWNoZShhcGksIGNvb3JkaW5hdGUsIHJlZ2lzdHJ5LCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzSW5zdGFuY2UgPSAoaW5zdGFuY2U6IGFueSk6IGluc3RhbmNlIGlzIEluc3RhbmNlPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4gPT4ge1xuICByZXR1cm4gaW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnICYmXG4gICAgJ2Nvb3JkaW5hdGUnIGluIGluc3RhbmNlICYmXG4gICAgJ3JlZ2lzdHJ5JyBpbiBpbnN0YW5jZSAmJlxuICAgICdhcGknIGluIGluc3RhbmNlICYmXG4gICAgJ2NhY2hlTWFwJyBpbiBpbnN0YW5jZSAmJlxuICAgICdvcGVyYXRpb25zJyBpbiBpbnN0YW5jZTtcbn1cbiIsIlxuaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gXCIuL0NhY2hlXCI7XG5pbXBvcnQgeyBDYWNoZU1hcCB9IGZyb20gXCIuL0NhY2hlTWFwXCI7XG5pbXBvcnQgeyBDYWNoZUV2ZW50RW1pdHRlciB9IGZyb20gXCIuL2V2ZW50cy9DYWNoZUV2ZW50RW1pdHRlclwiO1xuaW1wb3J0IHsgQ2FjaGVFdmVudExpc3RlbmVyLCBDYWNoZVN1YnNjcmlwdGlvbiwgQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zIH0gZnJvbSBcIi4vZXZlbnRzL0NhY2hlRXZlbnRUeXBlc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnSXRlbUFnZ3JlZ2F0b3InKTtcblxuZXhwb3J0IGludGVyZmFjZSBBZ2dyZWdhdG9yPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IGV4dGVuZHMgQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gIC8vIENhY2hlIG9wZXJhdGlvbnMgZXhwb3NlZCBkaXJlY3RseSBmb3IgYWdncmVnYXRvclxuICBhbGw6IChcbiAgICBxdWVyeT86IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFZbXT47XG5cbiAgb25lOiAoXG4gICAgcXVlcnk/OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbiAgYWN0aW9uOiAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5PzogYW55XG4gICkgPT4gUHJvbWlzZTxWPjtcblxuICBhbGxBY3Rpb246IChcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5PzogYW55LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8VltdPjtcblxuICBhbGxGYWNldDogKFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8YW55PjtcblxuICBjcmVhdGU6IChcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICkgPT4gUHJvbWlzZTxWPjtcblxuICBnZXQ6IChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+XG4gICkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbiAgcmV0cmlldmU6IChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+XG4gICkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbiAgcmVtb3ZlOiAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPlxuICApID0+IFByb21pc2U8dm9pZD47XG5cbiAgdXBkYXRlOiAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj5cbiAgKSA9PiBQcm9taXNlPFY+O1xuXG4gIGZhY2V0OiAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PlxuICApID0+IFByb21pc2U8YW55PjtcblxuICBmaW5kOiAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8VltdPjtcblxuICBmaW5kT25lOiAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8Vj47XG5cbiAgc2V0OiAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKSA9PiBQcm9taXNlPFY+O1xuXG4gIHJlc2V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIHBvcHVsYXRlOiAoaXRlbTogVikgPT4gUHJvbWlzZTxWPjtcbiAgcG9wdWxhdGVBZ2dyZWdhdGU6IChrZXk6IHN0cmluZywgaXRlbTogVikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcG9wdWxhdGVFdmVudDogKGtleTogc3RyaW5nLCBpdGVtOiBWKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKiBFdmVudCBlbWl0dGVyIGZvciBjYWNoZSBldmVudHMgKi9cbiAgZXZlbnRFbWl0dGVyOiBDYWNoZUV2ZW50RW1pdHRlcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gY2FjaGUgZXZlbnRzXG4gICAqL1xuICBzdWJzY3JpYmUoXG4gICAgbGlzdGVuZXI6IENhY2hlRXZlbnRMaXN0ZW5lcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIG9wdGlvbnM/OiBDYWNoZVN1YnNjcmlwdGlvbk9wdGlvbnM8UywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBDYWNoZVN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBjYWNoZSBldmVudHNcbiAgICovXG4gIHVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbjogQ2FjaGVTdWJzY3JpcHRpb24pOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlQ29uZmlnIHsgY2FjaGU6IGFueSwgb3B0aW9uYWw6IGJvb2xlYW4gfVxuXG5leHBvcnQgaW50ZXJmYWNlIEFnZ3JlZ2F0ZUNvbmZpZyB7IFtrZXk6IHN0cmluZ106IChDYWNoZUNvbmZpZykgfVxuXG5leHBvcnQgY29uc3QgdG9DYWNoZUNvbmZpZyA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihjb25maWc6IENhY2hlQ29uZmlnIHwgQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pik6IENhY2hlQ29uZmlnID0+IHtcbiAgbGV0IGNhY2hlQ29uZmlnOiBDYWNoZUNvbmZpZztcbiAgaWYgKChjb25maWcgYXMgQ2FjaGVDb25maWcpLm9wdGlvbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWNoZUNvbmZpZyA9IHsgY2FjaGU6IGNvbmZpZyBhcyBhbnksIG9wdGlvbmFsOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNhY2hlQ29uZmlnID0gY29uZmlnIGFzIENhY2hlQ29uZmlnO1xuICB9XG4gIHJldHVybiBjYWNoZUNvbmZpZztcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUFnZ3JlZ2F0b3IgPSBhc3luYyA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGNhY2hlOiBDYWNoZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICB7IGFnZ3JlZ2F0ZXMgPSB7fSwgZXZlbnRzID0ge30gfTpcbiAgICB7XG4gICAgICBhZ2dyZWdhdGVzPzogQWdncmVnYXRlQ29uZmlnLFxuICAgICAgZXZlbnRzPzogQWdncmVnYXRlQ29uZmlnXG4gICAgfVxuKTogUHJvbWlzZTxBZ2dyZWdhdG9yPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+ID0+IHtcblxuICBjb25zdCBwb3B1bGF0ZSA9IGFzeW5jIChpdGVtOiBWKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3BvcHVsYXRlJywgeyBpdGVtIH0pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFnZ3JlZ2F0ZXMpIHtcbiAgICAgIGF3YWl0IHBvcHVsYXRlQWdncmVnYXRlKGtleSwgaXRlbSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGV2ZW50cykge1xuICAgICAgYXdhaXQgcG9wdWxhdGVFdmVudChrZXksIGl0ZW0pO1xuICAgIH1cbiAgICBsb2dnZXIuZGVmYXVsdCgncG9wdWxhdGUgZG9uZScsIHsgaXRlbSB9KTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIGNvbnN0IHBvcHVsYXRlQWdncmVnYXRlID0gYXN5bmMgKGtleTogc3RyaW5nLCBpdGVtOiBWKSA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3BvcHVsYXRlIGFnZ3JlZ2F0ZSBrZXknLCB7IGtleSB9KTtcbiAgICBjb25zdCBjYWNoZUNvbmZpZyA9IHRvQ2FjaGVDb25maWcoYWdncmVnYXRlc1trZXldKTtcbiAgICBpZiAoaXRlbS5yZWZzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjYWNoZUNvbmZpZy5vcHRpb25hbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdJdGVtIGRvZXMgbm90IGhhdmUgcmVmcyBhbiBpcyBub3Qgb3B0aW9uYWwgJywgeyBpdGVtIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gZG9lcyBub3QgaGF2ZSByZWZzIGFuIGlzIG5vdCBvcHRpb25hbCAnICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW0uZXZlbnRzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpdGVtLmV2ZW50cywga2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSBpdGVtLmV2ZW50c1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpdGVtLnJlZnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY2FjaGVDb25maWcub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignSXRlbSBkb2VzIG5vdCBoYXZlIG1hbmRhdG9yeSByZWYgd2l0aCBrZXksIG5vdCBvcHRpb25hbCAnLCB7IGtleSwgaXRlbSB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIGRvZXMgbm90IGhhdmUgbWFuZGF0b3J5IHJlZiB3aXRoIGtleSwgbm90IG9wdGlvbmFsICcgK1xuICAgICAgICAgIGtleSArICcgJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtLmV2ZW50cyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlbS5ldmVudHMsIGtleSkpIHtcbiAgICAgICAgICBkZWxldGUgaXRlbS5ldmVudHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHJlZiA9IGl0ZW0ucmVmc1trZXldO1xuXG4gICAgICBsb2dnZXIuZGVmYXVsdCgnQUdHIFJldHJpZXZpbmcgSXRlbSBpbiBQb3B1bGF0ZScsIHsga2V5OiByZWYgfSk7XG4gICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgY2FjaGVDb25maWcuY2FjaGUub3BlcmF0aW9ucy5yZXRyaWV2ZShyZWYpO1xuICAgICAgaWYgKG5ld0l0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uYWdncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXRlbS5hZ2dzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5hZ2dzW2tleV0gPSB7XG4gICAgICAgICAga2V5OiByZWYsXG4gICAgICAgICAgaXRlbTogbmV3SXRlbSBhcyBJdGVtLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEknbSBub3QgYSBiaWcgZmFuIHRoYXQgdGhpcyBqdXN0IFwiYXV0b21hdGljYWxseVwiIGFzc3VtZXMgdGhhdCB0aGUgXCJieVwiIGtleSBpbiBldmVudCBpcyBhIHJlZi5cbiAgY29uc3QgcG9wdWxhdGVFdmVudCA9IGFzeW5jIChrZXk6IHN0cmluZywgaXRlbTogVikgPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdwb3B1bGF0ZSBldmVudCBrZXknLCB7IGtleSB9KTtcbiAgICBjb25zdCBjYWNoZUNvbmZpZyA9IHRvQ2FjaGVDb25maWcoZXZlbnRzW2tleV0pO1xuXG4gICAgaWYgKGl0ZW0uZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSXRlbSBkb2VzIG5vdCBoYXZlIGV2ZW50cyAnICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICAgIH0gZWxzZSBpZiAoaXRlbS5ldmVudHNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY2FjaGVDb25maWcub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignSXRlbSBkb2VzIG5vdCBoYXZlIG1hbmRhdG9yeSBldmVudCB3aXRoIGtleScsIHsga2V5LCBpdGVtIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gZG9lcyBub3QgaGF2ZSBtYW5kYXRvcnkgZXZlbnQgd2l0aCBrZXkgJyArIGtleSArICcgJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXZlbnQgPSBpdGVtLmV2ZW50c1trZXldO1xuXG4gICAgICBpZiAoZXZlbnQuYnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgJ3BvcHVsYXRlRXZlbnQgd2l0aCBhbiBFdmVudCB0aGF0IGRvZXMgbm90IGhhdmUgYnknLCB7IGV2ZW50LCBpazogaXRlbS5rZXksIGV2ZW50S2V5OiBrZXkgfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9wdWxhdGVFdmVudCB3aXRoIGFuIEV2ZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBieTogJyArIEpTT04uc3RyaW5naWZ5KHsga2V5IH0pKTtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmRlZmF1bHQoJ0VWRU5UIFJldHJpZXZpbmcgSXRlbSBpbiBQb3B1bGF0ZScsIHsga2V5OiBldmVudC5ieSB9KTtcbiAgICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCBjYWNoZUNvbmZpZy5jYWNoZS5vcGVyYXRpb25zLnJldHJpZXZlKGV2ZW50LmJ5KTtcbiAgICAgIGlmIChuZXdJdGVtKSB7XG4gICAgICAgIGV2ZW50LmFnZyA9IG5ld0l0ZW0gYXMgSXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBhbGwgPSBhc3luYyAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTpcbiAgICBQcm9taXNlPFZbXT4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdhbGwnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmFsbChxdWVyeSwgbG9jYXRpb25zKTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbSkgPT4gcG9wdWxhdGUoaXRlbSkpKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbXM7XG4gIH1cblxuICBjb25zdCBvbmUgPSBhc3luYyAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTpcbiAgICBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ29uZScsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5vbmUocXVlcnksIGxvY2F0aW9ucyk7XG4gICAgbGV0IHBvcHVsYXRlZEl0ZW0gPSBudWxsO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9XG5cbiAgY29uc3QgYWN0aW9uID0gYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keTogYW55ID0ge30sXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdhY3Rpb24nLCB7IGtleSwgYWN0aW9uLCBib2R5IH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmFjdGlvbihrZXksIGFjdGlvbiwgYm9keSk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9XG5cbiAgY29uc3QgYWxsQWN0aW9uID0gYXN5bmMgKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnYWN0aW9uJywgeyBhY3Rpb24sIGJvZHksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWxsQWN0aW9uKGFjdGlvbiwgYm9keSwgbG9jYXRpb25zKTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbTogVikgPT4gcG9wdWxhdGUoaXRlbSkpKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbXM7XG4gIH1cblxuICBjb25zdCBhbGxGYWNldCA9IGFzeW5jIChcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdhbGxGYWNldCcsIHsgZmFjZXQsIHBhcmFtcywgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5hbGxGYWNldChmYWNldCwgcGFyYW1zLCBsb2NhdGlvbnMpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZSA9IGFzeW5jIChcbiAgICB2OiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnY3JlYXRlJywgeyB2LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuY3JlYXRlKHYsIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9XG5cbiAgY29uc3QgZ2V0ID0gYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICk6IFByb21pc2U8ViB8IG51bGw+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZ2V0JywgeyBrZXkgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZ2V0KGtleSk7XG4gICAgbGV0IHBvcHVsYXRlZEl0ZW0gPSBudWxsO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9XG5cbiAgY29uc3QgcmV0cmlldmUgPSBhc3luYyAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgKTogUHJvbWlzZTxWIHwgbnVsbD4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdyZXRyaWV2ZScsIHsga2V5IH0pO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJldHJpZXZlKGtleSk7XG4gICAgbGV0IHBvcHVsYXRlZEl0ZW0gPSBudWxsO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9XG5cbiAgY29uc3QgcmVtb3ZlID0gYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdyZW1vdmUnLCB7IGtleSB9KTtcbiAgICBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJlbW92ZShrZXkpO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlID0gYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgdjogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgndXBkYXRlJywgeyBrZXksIHYgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMudXBkYXRlKGtleSwgdik7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9XG5cbiAgLy8gRmFjZXRzIGFyZSBhIHBhc3MtdGhydSBmb3IgYWdncmVnYXRvcnNcbiAgY29uc3QgZmFjZXQgPSBhc3luYyAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBmYWNldDogc3RyaW5nLFxuICApOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdmYWNldCcsIHsga2V5LCBmYWNldCB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZmFjZXQoa2V5LCBmYWNldCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgY29uc3QgZmluZCA9IGFzeW5jIChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZmluZCcsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZmluZChmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zKTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbTogVikgPT4gcG9wdWxhdGUoaXRlbSkpKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbXM7XG4gIH1cblxuICBjb25zdCBmaW5kT25lID0gYXN5bmMgKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZmluZCcsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5maW5kT25lKGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfVxuXG4gIGNvbnN0IHNldCA9IGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIHY6IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgnc2V0JywgeyBrZXksIHYgfSk7XG5cbiAgICAvLyBUT0RPOiBUaGVyZSBzaG91bGQgYmUgc29tZSBpbnB1dCB2YWxpZGF0aW9uIGhlcmUgdG8gZW5zdXJlIGEgdmFsaWQgaXRlbS5cbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5zZXQoa2V5LCB2KTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH1cblxuICBjb25zdCByZXNldCA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJlc2V0KCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIENhY2hlIHByb3BlcnRpZXNcbiAgICBjb29yZGluYXRlOiBjYWNoZS5jb29yZGluYXRlLFxuICAgIHJlZ2lzdHJ5OiBjYWNoZS5yZWdpc3RyeSxcbiAgICBhcGk6IGNhY2hlLmFwaSxcbiAgICBjYWNoZU1hcDogY2FjaGUuY2FjaGVNYXAsXG4gICAgb3BlcmF0aW9uczogY2FjaGUub3BlcmF0aW9ucyxcbiAgICBldmljdGlvbk1hbmFnZXI6IGNhY2hlLmV2aWN0aW9uTWFuYWdlcixcbiAgICB0dGxNYW5hZ2VyOiBjYWNoZS50dGxNYW5hZ2VyLFxuICAgIHN0YXRzTWFuYWdlcjogY2FjaGUuc3RhdHNNYW5hZ2VyLFxuICAgIGdldFN0YXRzOiBjYWNoZS5nZXRTdGF0cy5iaW5kKGNhY2hlKSxcbiAgICBnZXRDYWNoZUluZm86IGNhY2hlLmdldENhY2hlSW5mby5iaW5kKGNhY2hlKSxcbiAgICAvLyBDYWNoZSBvcGVyYXRpb25zIGV4cG9zZWQgZGlyZWN0bHlcbiAgICBhbGwsXG4gICAgb25lLFxuICAgIGFjdGlvbixcbiAgICBhbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQsXG4gICAgY3JlYXRlLFxuICAgIGdldCxcbiAgICByZXRyaWV2ZSxcbiAgICByZW1vdmUsXG4gICAgdXBkYXRlLFxuICAgIGZhY2V0LFxuICAgIGZpbmQsXG4gICAgZmluZE9uZSxcbiAgICByZXNldCxcbiAgICBzZXQsXG4gICAgLy8gQWdncmVnYXRvci1zcGVjaWZpYyBvcGVyYXRpb25zXG4gICAgcG9wdWxhdGUsXG4gICAgcG9wdWxhdGVBZ2dyZWdhdGUsXG4gICAgcG9wdWxhdGVFdmVudCxcbiAgICAvLyBFdmVudCBzeXN0ZW1cbiAgICBldmVudEVtaXR0ZXI6IGNhY2hlLmV2ZW50RW1pdHRlcixcbiAgICBzdWJzY3JpYmU6IChsaXN0ZW5lciwgb3B0aW9ucykgPT4gY2FjaGUuc3Vic2NyaWJlKGxpc3RlbmVyLCBvcHRpb25zKSxcbiAgICB1bnN1YnNjcmliZTogKHN1YnNjcmlwdGlvbikgPT4gY2FjaGUudW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uKSxcbiAgICBkZXN0cm95OiAoKSA9PiBjYWNoZS5kZXN0cm95KClcbiAgfVxufVxuIiwiaW1wb3J0IExpYkxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQge1xuICBSZWdpc3RyeSBhcyBCYXNlUmVnaXN0cnksXG4gIGNyZWF0ZVJlZ2lzdHJ5IGFzIGNyZWF0ZUJhc2VSZWdpc3RyeSxcbiAgUmVnaXN0cnlGYWN0b3J5LFxuICBSZWdpc3RyeUh1YlxufSBmcm9tICdAZmplbGwvcmVnaXN0cnknO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiUmVnaXN0cnlcIik7XG5cbi8qKlxuICogRXh0ZW5kZWQgUmVnaXN0cnkgaW50ZXJmYWNlIGZvciBjYWNoZS1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cnkgZXh0ZW5kcyBCYXNlUmVnaXN0cnkge1xuICB0eXBlOiAnY2FjaGUnO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGNhY2hlIHJlZ2lzdHJpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZ2lzdHJ5RmFjdG9yeSA9ICgpOiBSZWdpc3RyeUZhY3RvcnkgPT4ge1xuICByZXR1cm4gKHR5cGU6IHN0cmluZywgcmVnaXN0cnlIdWI/OiBSZWdpc3RyeUh1Yik6IEJhc2VSZWdpc3RyeSA9PiB7XG4gICAgaWYgKHR5cGUgIT09ICdjYWNoZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FjaGUgcmVnaXN0cnkgZmFjdG9yeSBjYW4gb25seSBjcmVhdGUgJ2NhY2hlJyB0eXBlIHJlZ2lzdHJpZXMsIGdvdDogJHt0eXBlfWApO1xuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZyhcIkNyZWF0aW5nIGNhY2hlIHJlZ2lzdHJ5XCIsIHsgdHlwZSwgcmVnaXN0cnlIdWIgfSk7XG5cbiAgICBjb25zdCBiYXNlUmVnaXN0cnkgPSBjcmVhdGVCYXNlUmVnaXN0cnkodHlwZSwgcmVnaXN0cnlIdWIpO1xuXG4gICAgLy8gQ2FzdCB0byBSZWdpc3RyeSBmb3IgdHlwZSBzYWZldHlcbiAgICByZXR1cm4gYmFzZVJlZ2lzdHJ5IGFzIFJlZ2lzdHJ5O1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNhY2hlIHJlZ2lzdHJ5IGluc3RhbmNlXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWdpc3RyeSA9IChyZWdpc3RyeUh1Yj86IFJlZ2lzdHJ5SHViKTogUmVnaXN0cnkgPT4ge1xuICBjb25zdCBiYXNlUmVnaXN0cnkgPSBjcmVhdGVCYXNlUmVnaXN0cnkoJ2NhY2hlJywgcmVnaXN0cnlIdWIpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uYmFzZVJlZ2lzdHJ5LFxuICB9IGFzIFJlZ2lzdHJ5O1xufTtcbiJdLCJuYW1lcyI6WyJ2YWxpZGF0ZVBLIiwiTm90Rm91bmRFcnJvciIsImxvZ2dlciIsImtleVN0ciIsImlzVmFsaWRJdGVtS2V5IiwiYWN0aW9uIiwiZmFjZXQiLCJub3JtYWxpemVLZXlWYWx1ZSIsImlzQ29tS2V5IiwiaXNRdWVyeU1hdGNoIiwiQ29tS2V5Iiwic2FmZVN0cmluZ2lmeSIsIm9wdGlvbnMiLCJhbGwiLCJvbmUiLCJhbGxBY3Rpb24iLCJhbGxGYWNldCIsImNyZWF0ZSIsImdldCIsInJldHJpZXZlIiwicmVtb3ZlIiwidXBkYXRlIiwiZmluZCIsImZpbmRPbmUiLCJzZXQiLCJyZXNldCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/@fjell/core/dist/index.js":
/*!*************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/core/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItemService: () => (/* binding */ AItemService),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   IFactory: () => (/* binding */ IFactory),\n/* harmony export */   IQFactory: () => (/* binding */ IQFactory),\n/* harmony export */   abbrevAgg: () => (/* binding */ abbrevAgg),\n/* harmony export */   abbrevCompoundCondition: () => (/* binding */ abbrevCompoundCondition),\n/* harmony export */   abbrevCondition: () => (/* binding */ abbrevCondition),\n/* harmony export */   abbrevIK: () => (/* binding */ abbrevIK),\n/* harmony export */   abbrevLKA: () => (/* binding */ abbrevLKA),\n/* harmony export */   abbrevQuery: () => (/* binding */ abbrevQuery),\n/* harmony export */   abbrevRef: () => (/* binding */ abbrevRef),\n/* harmony export */   cPK: () => (/* binding */ cPK),\n/* harmony export */   constructPriKey: () => (/* binding */ constructPriKey),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   generateKeyArray: () => (/* binding */ generateKeyArray),\n/* harmony export */   ikToLKA: () => (/* binding */ ikToLKA),\n/* harmony export */   isComItem: () => (/* binding */ isComItem),\n/* harmony export */   isComKey: () => (/* binding */ isComKey),\n/* harmony export */   isComKeyEqual: () => (/* binding */ isComKeyEqual),\n/* harmony export */   isComKeyEqualNormalized: () => (/* binding */ isComKeyEqualNormalized),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isItemKey: () => (/* binding */ isItemKey),\n/* harmony export */   isItemKeyEqual: () => (/* binding */ isItemKeyEqual),\n/* harmony export */   isItemKeyEqualNormalized: () => (/* binding */ isItemKeyEqualNormalized),\n/* harmony export */   isLocKey: () => (/* binding */ isLocKey),\n/* harmony export */   isLocKeyEqual: () => (/* binding */ isLocKeyEqual),\n/* harmony export */   isLocKeyEqualNormalized: () => (/* binding */ isLocKeyEqualNormalized),\n/* harmony export */   isPriItem: () => (/* binding */ isPriItem),\n/* harmony export */   isPriKey: () => (/* binding */ isPriKey),\n/* harmony export */   isPriKeyEqual: () => (/* binding */ isPriKeyEqual),\n/* harmony export */   isPriKeyEqualNormalized: () => (/* binding */ isPriKeyEqualNormalized),\n/* harmony export */   isQueryMatch: () => (/* binding */ isQueryMatch),\n/* harmony export */   isValidComKey: () => (/* binding */ isValidComKey),\n/* harmony export */   isValidItemKey: () => (/* binding */ isValidItemKey),\n/* harmony export */   isValidLocKey: () => (/* binding */ isValidLocKey),\n/* harmony export */   isValidLocKeyArray: () => (/* binding */ isValidLocKeyArray),\n/* harmony export */   isValidPriKey: () => (/* binding */ isValidPriKey),\n/* harmony export */   itemKeyToLocKeyArray: () => (/* binding */ itemKeyToLocKeyArray),\n/* harmony export */   lkaToIK: () => (/* binding */ lkaToIK),\n/* harmony export */   locKeyArrayToItemKey: () => (/* binding */ locKeyArrayToItemKey),\n/* harmony export */   paramsToQuery: () => (/* binding */ paramsToQuery),\n/* harmony export */   primaryType: () => (/* binding */ primaryType),\n/* harmony export */   queryToParams: () => (/* binding */ queryToParams),\n/* harmony export */   toKeyTypeArray: () => (/* binding */ toKeyTypeArray),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys),\n/* harmony export */   validatePK: () => (/* binding */ validatePK)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/../fjell-cache/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! luxon */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/luxon.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/core\");\nvar logger_default = LibLogger;\n\n// src/dictionary.ts\nvar logger = logger_default.get(\"Dictionary\");\nvar Dictionary = class _Dictionary {\n  map = {};\n  hashFunction = (key) => JSON.stringify(key);\n  constructor(map, hashFunction) {\n    if (hashFunction) {\n      this.hashFunction = hashFunction;\n    }\n    if (map) {\n      Object.entries(map).forEach(([hashedKey, value]) => {\n        try {\n          const originalKey = JSON.parse(hashedKey);\n          this.map[hashedKey] = { originalKey, value };\n        } catch {\n          logger.warning(\"Cannot recover original key from legacy map entry\", { hashedKey });\n        }\n      });\n    }\n  }\n  set(key, item) {\n    logger.trace(\"set\", { key, item });\n    const hashedKey = this.hashFunction(key);\n    this.map[hashedKey] = { originalKey: key, value: item };\n  }\n  get(key) {\n    logger.trace(\"get\", { key });\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry && this.keysEqual(entry.originalKey, key) ? entry.value : null;\n  }\n  keysEqual(key1, key2) {\n    return key1 === key2;\n  }\n  delete(key) {\n    logger.trace(\"delete\", { key });\n    const hashedKey = this.hashFunction(key);\n    delete this.map[hashedKey];\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  includesKey(key) {\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry ? this.keysEqual(entry.originalKey, key) : false;\n  }\n  clone() {\n    const clonedMap = {};\n    Object.entries(this.map).forEach(([hashedKey, entry]) => {\n      clonedMap[hashedKey] = entry.value;\n    });\n    const clone = new _Dictionary(clonedMap, this.hashFunction);\n    clone.map = Object.assign({}, this.map);\n    return clone;\n  }\n};\n\n// src/item/IFactory.ts\n\n\n// src/key/KUtils.ts\nvar logger2 = logger_default.get(\"KUtils\");\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && (normalizedKey.pk !== void 0 && normalizedKey.pk !== null)) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && (normalizedKey.lk !== void 0 && normalizedKey.lk !== null)) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && (locItem.lk !== void 0 && locItem.lk !== null)) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return JSON.stringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isPriKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isPriKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.pk) === normalizeKeyValue(b.pk) && a.kt === b.kt;\n};\nvar isLocKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isLocKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.lk) === normalizeKeyValue(b.lk) && a.kt === b.kt;\n};\nvar isComKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isComKeyEqualNormalized\", { a, b });\n  if (a && b && isPriKeyEqualNormalized({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqualNormalized(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isItemKeyEqualNormalized\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqualNormalized(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqualNormalized(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqual = (a, b) => {\n  logger2.trace(\"isKeyEqual\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqual(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqual(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isPriKeyEqual = (a, b) => {\n  logger2.trace(\"isPriKeyEqual\", { a, b });\n  return a && b && a.pk === b.pk && a.kt === b.kt;\n};\nvar isLocKeyEqual = (a, b) => {\n  logger2.trace(\"isLocKeyEqual\", { a, b });\n  return a && b && a.lk === b.lk && a.kt === b.kt;\n};\nvar isComKeyEqual = (a, b) => {\n  logger2.trace(\"isComKeyEqual\", { a, b });\n  if (a && b && isPriKeyEqual({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqual(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKey = (key) => {\n  logger2.trace(\"isItemKey\", { key });\n  return key !== void 0 && (isComKey(key) || isPriKey(key));\n};\nvar isComKey = (key) => {\n  logger2.trace(\"isComKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc !== void 0 && key.loc.length > 0);\n};\nvar isPriKey = (key) => {\n  logger2.trace(\"isPriKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc === void 0 || key.loc.length === 0);\n};\nvar isLocKey = (key) => {\n  logger2.trace(\"isLocKey\", { key });\n  return key !== void 0 && (key.lk !== void 0 && key.kt !== void 0);\n};\nvar generateKeyArray = (key) => {\n  logger2.trace(\"generateKeyArray\", { key });\n  const keys = [];\n  if (isComKey(key) || isPriKey(key)) {\n    if (isComKey(key)) {\n      const comKey = key;\n      keys.push({ pk: comKey.pk, kt: comKey.kt });\n      for (let i = 0; i < comKey.loc.length; i++) {\n        keys.push(comKey.loc[i]);\n      }\n    } else {\n      keys.push(key);\n    }\n  } else {\n    const locKeys = key;\n    for (let i = 0; i < locKeys.length; i++) {\n      keys.push(locKeys[i]);\n    }\n  }\n  return keys;\n};\nvar constructPriKey = (pk, kt) => {\n  logger2.trace(\"constructPriKey\", { pk, kt });\n  let pri;\n  if (typeof pk === \"string\" || typeof pk === \"number\") {\n    pri = { kt, pk };\n  } else {\n    pri = pk;\n  }\n  return pri;\n};\nvar cPK = constructPriKey;\nvar toKeyTypeArray = (ik) => {\n  logger2.trace(\"toKeyTypeArray\", { ik });\n  if (isComKey(ik)) {\n    const ck = ik;\n    return [ck.kt, ...ck.loc.map((l) => l.kt)];\n  } else {\n    return [ik.kt];\n  }\n};\nvar abbrevIK = (ik) => {\n  logger2.trace(\"abbrevIK\", { ik });\n  if (ik) {\n    if (isComKey(ik)) {\n      const ck = ik;\n      return `${ck.kt}:${ck.pk}:${ck.loc.map((l) => `${l.kt}:${l.lk}`).join(\",\")}`;\n    } else {\n      return `${ik.kt}:${ik.pk}`;\n    }\n  } else {\n    return \"null IK\";\n  }\n};\nvar abbrevLKA = (keyArray) => {\n  logger2.trace(\"abbrevLKA\", { keyArray });\n  if (keyArray === void 0 || keyArray === null) {\n    return \"null LKA\";\n  } else {\n    return keyArray.map((key) => {\n      if (key) {\n        return `${key.kt}:${key.lk}`;\n      } else {\n        return key;\n      }\n    }).join(\",\");\n  }\n};\nvar primaryType = (ik) => {\n  logger2.trace(\"primaryType\", { ik });\n  if (isComKey(ik)) {\n    return ik.kt;\n  } else {\n    return ik.kt;\n  }\n};\nvar itemKeyToLocKeyArray = (ik) => {\n  logger2.trace(\"itemKeyToLocKeyArray\", { ik: abbrevIK(ik) });\n  let lka = [];\n  if (isComKey(ik)) {\n    const ck = ik;\n    lka = [{ kt: ck.kt, lk: ck.pk }, ...ck.loc];\n  } else {\n    const pk = ik;\n    lka = [{ kt: pk.kt, lk: pk.pk }];\n  }\n  logger2.trace(\"itemKeyToLocKeyArray Results\", { ik: abbrevIK(ik), lka: abbrevLKA(lka) });\n  return lka;\n};\nvar ikToLKA = itemKeyToLocKeyArray;\nvar locKeyArrayToItemKey = (lka) => {\n  logger2.trace(\"locKeyArrayToItemKey\", { lka: abbrevLKA(lka) });\n  if (lka && lka.length === 1) {\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    return priKey;\n  } else if (lka && lka.length > 1 && lka[0] !== void 0) {\n    const locs = lka.slice(1);\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    const comKey = { kt: priKey.kt, pk: priKey.pk, loc: locs };\n    return comKey;\n  } else {\n    throw new Error(\"locKeyArrayToItemKey: lka is undefined or empty\");\n  }\n};\nvar isValidPriKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.pk !== void 0 && key.pk !== null && key.pk !== \"\" && key.pk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.lk !== void 0 && key.lk !== null && key.lk !== \"\" && key.lk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKeyArray = (keyArray) => {\n  return keyArray !== void 0 && keyArray !== null && keyArray.every(isValidLocKey);\n};\nvar isValidComKey = (key) => {\n  return key !== void 0 && key !== null && isValidPriKey(key) && isValidLocKeyArray(key.loc);\n};\nvar isValidItemKey = (key) => {\n  return isComKey(key) && isValidComKey(key) || isPriKey(key) && isValidPriKey(key);\n};\nvar lkaToIK = locKeyArrayToItemKey;\n\n// src/item/IFactory.ts\nvar IFactory = class _IFactory {\n  item = {};\n  constructor(props = {}) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n  }\n  addRef(i, name) {\n    const ik = i.key;\n    const refName = name || primaryType(ik);\n    if (!this.item.refs) {\n      this.item.refs = {};\n    }\n    this.item.refs[refName] = ik;\n    return this;\n  }\n  static addRef(i, name) {\n    return new _IFactory().addRef(i, name);\n  }\n  addDefaultEvents() {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    const now = /* @__PURE__ */ new Date();\n    if (!this.item.events.created) {\n      this.item.events.created = { at: now };\n    }\n    if (!this.item.events.updated) {\n      this.item.events.updated = { at: now };\n    }\n    if (!this.item.events.deleted) {\n      this.item.events.deleted = { at: null };\n    }\n    return this;\n  }\n  addEvent(name, at, by) {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    this.item.events[name] = { at, by };\n    return this;\n  }\n  static addEvent(name, at, by) {\n    return new _IFactory().addEvent(name, at, by);\n  }\n  addProp(name, value) {\n    this.item[name] = value;\n    return this;\n  }\n  static addProp(name, value) {\n    return new _IFactory().addProp(name, value);\n  }\n  addProps(props) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n    return this;\n  }\n  static addProps(props) {\n    return new _IFactory().addProps(props);\n  }\n  toItem() {\n    return this.item;\n  }\n};\n\n// src/AItemService.ts\nvar AItemService = class {\n  pkType;\n  parentService = null;\n  constructor(pkType, parentService) {\n    this.pkType = pkType;\n    if (parentService) {\n      this.parentService = parentService;\n    }\n  }\n  getPkType = () => {\n    return this.pkType;\n  };\n  getKeyTypes = () => {\n    let keyTypes = [this.getPkType()];\n    if (this.parentService) {\n      keyTypes = keyTypes.concat(this.parentService.getKeyTypes());\n    }\n    return keyTypes;\n  };\n};\n\n// src/item/ItemQuery.ts\nvar isCondition = (condition) => {\n  return (typeof condition.column === \"string\" && (Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"string\")) || Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"number\") || typeof condition.value === \"string\" || typeof condition.value === \"number\" || typeof condition.value === \"boolean\" || condition.value instanceof Date) && (condition.operator ? typeof condition.operator === \"string\" : true);\n};\n\n// src/item/IQFactory.ts\nvar IQFactory = class _IQFactory {\n  query = {};\n  constructor(query = {}) {\n    this.query = query;\n  }\n  orderBy(field, direction = \"asc\") {\n    if (!this.query.orderBy) {\n      this.query.orderBy = [];\n    }\n    this.query.orderBy.push({ field, direction });\n    return this;\n  }\n  agg(name, query) {\n    if (!this.query.aggs) {\n      this.query.aggs = {};\n    }\n    this.query.aggs[name] = query;\n    return this;\n  }\n  event(name, query) {\n    if (!this.query.events) {\n      this.query.events = {};\n    }\n    this.query.events[name] = query;\n    return this;\n  }\n  conditions(conditions, compoundType = \"AND\") {\n    for (const condition of conditions) {\n      if (!isCondition(condition)) {\n        throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n      }\n    }\n    if (!this.query.compoundCondition) {\n      this.query.compoundCondition = {\n        compoundType,\n        conditions\n      };\n    } else {\n      const compoundCondition = {\n        compoundType,\n        conditions\n      };\n      this.query.compoundCondition.conditions.push(compoundCondition);\n    }\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  // TODO: right now, we're only supporting PK refs for queries.  Should add support for CKs\n  pk(kt, pk, name) {\n    if (!this.query.refs) {\n      this.query.refs = {};\n    }\n    const refName = name || kt;\n    this.query.refs[refName] = cPK(pk, kt);\n    return this;\n  }\n  condition(column, value, operator = \"==\") {\n    const condition = { column, value, operator };\n    if (isCondition(condition)) {\n      if (!this.query.compoundCondition) {\n        this.query.compoundCondition = {\n          compoundType: \"AND\",\n          conditions: []\n        };\n      }\n      this.query.compoundCondition.conditions.push(condition);\n      return this;\n    } else {\n      throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n    }\n  }\n  static all() {\n    const iqFactory = new _IQFactory();\n    return iqFactory;\n  }\n  static orderBy(field, direction = \"asc\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.orderBy(field, direction);\n  }\n  static agg(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.agg(name, query);\n  }\n  static event(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.event(name, query);\n  }\n  static limit(limit) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.limit(limit);\n  }\n  static offset(offset) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.offset(offset);\n  }\n  static pk(kt, pk, name) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.pk(kt, pk, name);\n  }\n  static condition(column, value, operator = \"==\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.condition(column, value, operator);\n  }\n  static conditions(conditions, compoundType = \"AND\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.conditions(conditions, compoundType);\n  }\n  toQuery() {\n    return this.query;\n  }\n};\n\n// src/item/IQUtils.ts\n\nvar logger3 = logger_default.get(\"IQUtils\");\nvar queryToParams = (query) => {\n  const params = {};\n  if (query.compoundCondition) {\n    params.compoundCondition = JSON.stringify(query.compoundCondition);\n  }\n  if (query.refs) {\n    params.refs = JSON.stringify(query.refs);\n  }\n  if (query.limit) {\n    params.limit = query.limit;\n  }\n  if (query.offset) {\n    params.offset = query.offset;\n  }\n  if (query.aggs) {\n    params.aggs = JSON.stringify(query.aggs);\n  }\n  if (query.events) {\n    params.events = JSON.stringify(query.events);\n  }\n  return params;\n};\nvar dateTimeReviver = function(key, value) {\n  if (typeof value === \"string\") {\n    const parsedDate = luxon__WEBPACK_IMPORTED_MODULE_2__.DateTime.fromISO(value);\n    if (parsedDate.isValid) {\n      return parsedDate.toJSDate();\n      ;\n    }\n  }\n  return value;\n};\nvar paramsToQuery = (params) => {\n  const query = {};\n  if (params.compoundCondition) {\n    query.compoundCondition = JSON.parse(params.compoundCondition);\n  }\n  if (params.refs) {\n    query.refs = JSON.parse(params.refs);\n  }\n  if (params.limit) {\n    query.limit = Number(params.limit);\n  }\n  if (params.offset) {\n    query.offset = Number(params.offset);\n  }\n  if (params.aggs) {\n    query.aggs = JSON.parse(params.aggs);\n  }\n  if (params.events) {\n    query.events = JSON.parse(params.events, dateTimeReviver);\n  }\n  return query;\n};\nvar isRefQueryMatch = (refKey, queryRef, references) => {\n  logger3.trace(\"doesRefMatch\", { queryRef, references });\n  logger3.debug(\"Comparing Ref\", { refKey, itemRef: references[refKey], queryRef });\n  return isItemKeyEqual(queryRef, references[refKey]);\n};\nvar isCompoundConditionQueryMatch = (queryCondition, item) => {\n  if (queryCondition.compoundType === \"AND\") {\n    return queryCondition.conditions.every(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  } else {\n    return queryCondition.conditions.some(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  }\n};\nvar isConditionQueryMatch = (queryCondition, item) => {\n  const propKey = queryCondition.column;\n  logger3.trace(\"doesConditionMatch\", { propKey, queryCondition, item });\n  if (item[propKey] === void 0) {\n    logger3.debug(\"Item does not contain prop under key\", { propKey, item });\n    return false;\n  }\n  logger3.debug(\"Comparing Condition\", { propKey, itemProp: item[propKey], queryCondition });\n  let result = false;\n  switch (queryCondition.operator) {\n    case \"==\":\n      result = item[propKey] === queryCondition.value;\n      break;\n    case \"!=\":\n      result = item[propKey] !== queryCondition.value;\n      break;\n    case \">\":\n      result = item[propKey] > queryCondition.value;\n      break;\n    case \">=\":\n      result = item[propKey] >= queryCondition.value;\n      break;\n    case \"<\":\n      result = item[propKey] < queryCondition.value;\n      break;\n    case \"<=\":\n      result = item[propKey] <= queryCondition.value;\n      break;\n    case \"in\":\n      result = queryCondition.value.includes(item[propKey]);\n      break;\n    case \"not-in\":\n      result = !queryCondition.value.includes(item[propKey]);\n      break;\n    case \"array-contains\":\n      result = item[propKey].includes(queryCondition.value);\n      break;\n    case \"array-contains-any\":\n      result = queryCondition.value.some((value) => item[propKey].includes(value));\n      break;\n  }\n  return result;\n};\nvar isAggQueryMatch = (aggKey, aggQuery, agg) => {\n  const aggItem = agg.item;\n  logger3.debug(\"Comparing Agg\", { aggKey, aggItem, aggQuery });\n  return isQueryMatch(aggItem, aggQuery);\n};\nvar isEventQueryMatch = (eventKey, eventQuery, item) => {\n  if (!item.events[eventKey]) {\n    logger3.debug(\"Item does not contain event under key\", { eventKey, events: item.events });\n    return false;\n  } else {\n    const itemEvent = item.events[eventKey];\n    if (itemEvent.at !== null) {\n      if (eventQuery.start && !(eventQuery.start.getTime() <= itemEvent.at.getTime())) {\n        logger3.debug(\"Item date before event start query\", { eventQuery, itemEvent });\n        return false;\n      }\n      if (eventQuery.end && !(eventQuery.end.getTime() > itemEvent.at.getTime())) {\n        logger3.debug(\"Item date after event end query\", { eventQuery, itemEvent });\n        return false;\n      }\n    } else {\n      logger3.debug(\"Item event does contains a null at\", { itemEvent });\n      return false;\n    }\n    return true;\n  }\n};\nvar isQueryMatch = (item, query) => {\n  logger3.trace(\"isMatch\", { item, query });\n  if (query.refs && item.refs) {\n    for (const key in query.refs) {\n      const queryRef = query.refs[key];\n      if (!isRefQueryMatch(key, queryRef, item.refs)) return false;\n    }\n  } else if (query.refs && !item.refs) {\n    logger3.debug(\"Query contains refs but item does not have refs\", { query, item });\n    return false;\n  }\n  if (query.compoundCondition && item) {\n    if (!isCompoundConditionQueryMatch(query.compoundCondition, item)) return false;\n  }\n  if (query.events && item.events) {\n    for (const key in query.events) {\n      const queryEvent = query.events[key];\n      if (!isEventQueryMatch(key, queryEvent, item)) return false;\n    }\n    return true;\n  }\n  if (query.aggs && item.aggs) {\n    for (const key in query.aggs) {\n      const aggQuery = query.aggs[key];\n      if (item.aggs[key] && !isAggQueryMatch(key, aggQuery, item.aggs[key])) return false;\n    }\n  }\n  if (query.aggs && !item.aggs) {\n    logger3.debug(\"Query contains aggs but item does not have aggs\", { query, item });\n    return false;\n  }\n  return true;\n};\nvar abbrevQuery = (query) => {\n  const abbrev = [\"IQ\"];\n  if (query) {\n    if (query.refs) {\n      for (const key in query.refs) {\n        const ref = abbrevRef(key, query.refs[key]);\n        abbrev.push(ref);\n      }\n    }\n    if (query.compoundCondition) {\n      const props = abbrevCompoundCondition(query.compoundCondition);\n      abbrev.push(props);\n    }\n    if (query.aggs) {\n      for (const key in query.aggs) {\n        const agg = abbrevAgg(key, query.aggs[key]);\n        abbrev.push(agg);\n      }\n    }\n    if (query.events) {\n      const events = `(E${Object.keys(query.events).join(\",\")})`;\n      abbrev.push(events);\n    }\n    if (query.limit) {\n      abbrev.push(`L${query.limit}`);\n    }\n    if (query.offset) {\n      abbrev.push(`O${query.offset}`);\n    }\n  } else {\n    abbrev.push(\"(empty)\");\n  }\n  return abbrev.join(\" \");\n};\nvar abbrevRef = (key, ref) => {\n  if (isPriKey(ref)) {\n    const priKey = ref;\n    return `R(${key},${priKey.kt},${priKey.pk})`;\n  } else {\n    const comKey = ref;\n    return `R(${key},${JSON.stringify(comKey)})`;\n  }\n};\nvar abbrevAgg = (key, agg) => {\n  return `A(${key},${abbrevQuery(agg)})`;\n};\nvar abbrevCompoundCondition = (compoundCondition) => {\n  return `CC(${compoundCondition.compoundType},${compoundCondition.conditions ? compoundCondition.conditions.map(abbrevCondition).join(\",\") : \"No Conditions\"})`;\n};\nvar abbrevCondition = (condition) => {\n  if (isCondition(condition)) {\n    return `(${condition.column},${condition.value},${condition.operator})`;\n  } else {\n    return abbrevCompoundCondition(condition);\n  }\n};\n\n// src/item/IUtils.ts\nvar logger4 = logger_default.get(\"IUtils\");\nvar validatePKForItem = (item, pkType) => {\n  if (!item) {\n    logger4.error(\"Validating PK, Item is undefined\", { item });\n    throw new Error(\"Validating PK, Item is undefined\");\n  }\n  if (!item.key) {\n    logger4.error(\"Validating PK, Item does not have a key\", { item });\n    throw new Error(\"Validating PK, Item does not have a key\");\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray[0] !== pkType) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, pkType });\n    throw new Error(`Item does not have the correct primary key type. Expected ${pkType}, got ${keyTypeArray[0]}`);\n  }\n  return item;\n};\nvar validatePK = (input, pkType) => {\n  logger4.trace(\"Checking Return Type\", { input });\n  if (Array.isArray(input)) {\n    return input.map((item) => validatePKForItem(item, pkType));\n  }\n  return validatePKForItem(input, pkType);\n};\nvar validateKeys = (item, keyTypes) => {\n  logger4.trace(\"Checking Return Type\", { item });\n  if (!item) {\n    throw new Error(\"validating keys, item is undefined\");\n  }\n  if (!item.key) {\n    throw new Error(\"validating keys, item does not have a key: \" + JSON.stringify(item));\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray.length !== keyTypes.length) {\n    throw new Error(`Item does not have the correct number of keys. Expected ${keyTypes.length}, but got ${keyTypeArray.length}`);\n  }\n  const match = JSON.stringify(keyTypeArray) === JSON.stringify(keyTypes);\n  if (!match) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, thisKeyTypes: keyTypes });\n    throw new Error(`Item does not have the correct key types. Expected [${keyTypes.join(\", \")}], but got [${keyTypeArray.join(\", \")}]`);\n  }\n  return item;\n};\nvar isPriItem = (item) => {\n  return !!(item && item.key && isPriKey(item.key));\n};\nvar isComItem = (item) => {\n  return !!(item && item.key && isComKey(item.key));\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvQGZqZWxsL2NvcmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDcUM7QUFDckMsZ0JBQWdCLGdFQUFpQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxVQUFVO0FBQ1YsZ0ZBQWdGLFdBQVc7QUFDM0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ2tDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25ELDBDQUEwQyxvQkFBb0IsSUFBSSxvQkFBb0I7QUFDdEY7QUFDQSxzQkFBc0Isa0JBQWtC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QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGdCQUFnQixZQUFZLG9CQUFvQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0NBQXNDO0FBQ3JGLDJFQUEyRSxvQkFBb0IsY0FBYyx3QkFBd0I7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0RFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9jb3JlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xvZ2dlci50c1xuaW1wb3J0IExvZ2dpbmcgZnJvbSBcIkBmamVsbC9sb2dnaW5nXCI7XG52YXIgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoXCJAZmplbGwvY29yZVwiKTtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExpYkxvZ2dlcjtcblxuLy8gc3JjL2RpY3Rpb25hcnkudHNcbnZhciBsb2dnZXIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJEaWN0aW9uYXJ5XCIpO1xudmFyIERpY3Rpb25hcnkgPSBjbGFzcyBfRGljdGlvbmFyeSB7XG4gIG1hcCA9IHt9O1xuICBoYXNoRnVuY3Rpb24gPSAoa2V5KSA9PiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICBjb25zdHJ1Y3RvcihtYXAsIGhhc2hGdW5jdGlvbikge1xuICAgIGlmIChoYXNoRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuaGFzaEZ1bmN0aW9uID0gaGFzaEZ1bmN0aW9uO1xuICAgIH1cbiAgICBpZiAobWFwKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhtYXApLmZvckVhY2goKFtoYXNoZWRLZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsS2V5ID0gSlNPTi5wYXJzZShoYXNoZWRLZXkpO1xuICAgICAgICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7IG9yaWdpbmFsS2V5LCB2YWx1ZSB9O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBsb2dnZXIud2FybmluZyhcIkNhbm5vdCByZWNvdmVyIG9yaWdpbmFsIGtleSBmcm9tIGxlZ2FjeSBtYXAgZW50cnlcIiwgeyBoYXNoZWRLZXkgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzZXQoa2V5LCBpdGVtKSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwic2V0XCIsIHsga2V5LCBpdGVtIH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHsgb3JpZ2luYWxLZXk6IGtleSwgdmFsdWU6IGl0ZW0gfTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiZ2V0XCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiBlbnRyeSAmJiB0aGlzLmtleXNFcXVhbChlbnRyeS5vcmlnaW5hbEtleSwga2V5KSA/IGVudHJ5LnZhbHVlIDogbnVsbDtcbiAgfVxuICBrZXlzRXF1YWwoa2V5MSwga2V5Mikge1xuICAgIHJldHVybiBrZXkxID09PSBrZXkyO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICBsb2dnZXIudHJhY2UoXCJkZWxldGVcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBkZWxldGUgdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS5vcmlnaW5hbEtleSk7XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSk7XG4gIH1cbiAgaW5jbHVkZXNLZXkoa2V5KSB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgcmV0dXJuIGVudHJ5ID8gdGhpcy5rZXlzRXF1YWwoZW50cnkub3JpZ2luYWxLZXksIGtleSkgOiBmYWxzZTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZWRNYXAgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLm1hcCkuZm9yRWFjaCgoW2hhc2hlZEtleSwgZW50cnldKSA9PiB7XG4gICAgICBjbG9uZWRNYXBbaGFzaGVkS2V5XSA9IGVudHJ5LnZhbHVlO1xuICAgIH0pO1xuICAgIGNvbnN0IGNsb25lID0gbmV3IF9EaWN0aW9uYXJ5KGNsb25lZE1hcCwgdGhpcy5oYXNoRnVuY3Rpb24pO1xuICAgIGNsb25lLm1hcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWFwKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn07XG5cbi8vIHNyYy9pdGVtL0lGYWN0b3J5LnRzXG5pbXBvcnQgZGVlcG1lcmdlIGZyb20gXCJkZWVwbWVyZ2VcIjtcblxuLy8gc3JjL2tleS9LVXRpbHMudHNcbnZhciBsb2dnZXIyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiS1V0aWxzXCIpO1xudmFyIG5vcm1hbGl6ZUtleVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufTtcbnZhciBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gKCkgPT4ge1xuICByZXR1cm4gKGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG4gICAgICBpZiAoXCJwa1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgKG5vcm1hbGl6ZWRLZXkucGsgIT09IHZvaWQgMCAmJiBub3JtYWxpemVkS2V5LnBrICE9PSBudWxsKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LnBrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5wayk7XG4gICAgICB9XG4gICAgICBpZiAoXCJsa1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgKG5vcm1hbGl6ZWRLZXkubGsgIT09IHZvaWQgMCAmJiBub3JtYWxpemVkS2V5LmxrICE9PSBudWxsKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5sayk7XG4gICAgICB9XG4gICAgICBpZiAoXCJsb2NcIiBpbiBub3JtYWxpemVkS2V5ICYmIEFycmF5LmlzQXJyYXkobm9ybWFsaXplZEtleS5sb2MpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubG9jID0gbm9ybWFsaXplZEtleS5sb2MubWFwKChsb2NJdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGxvY0l0ZW0gJiYgXCJsa1wiIGluIGxvY0l0ZW0gJiYgKGxvY0l0ZW0ubGsgIT09IHZvaWQgMCAmJiBsb2NJdGVtLmxrICE9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubG9jSXRlbSwgbGs6IG5vcm1hbGl6ZUtleVZhbHVlKGxvY0l0ZW0ubGspIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NJdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIH07XG59O1xudmFyIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzUHJpS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBub3JtYWxpemVLZXlWYWx1ZShhLnBrKSA9PT0gbm9ybWFsaXplS2V5VmFsdWUoYi5waykgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIG5vcm1hbGl6ZUtleVZhbHVlKGEubGspID09PSBub3JtYWxpemVLZXlWYWx1ZShiLmxrKSAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0NvbUtleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0NvbUtleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIGlmIChhICYmIGIgJiYgaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQoeyBrdDogYS5rdCwgcGs6IGEucGsgfSwgeyBrdDogYi5rdCwgcGs6IGIucGsgfSkpIHtcbiAgICBpZiAoYS5sb2MubGVuZ3RoID09PSBiLmxvYy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0xvY0tleUVxdWFsTm9ybWFsaXplZChhLmxvY1tpXSwgYi5sb2NbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzSXRlbUtleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIGlmIChpc0NvbUtleShhKSAmJiBpc0NvbUtleShiKSkge1xuICAgIHJldHVybiBpc0NvbUtleUVxdWFsTm9ybWFsaXplZChhLCBiKTtcbiAgfSBlbHNlIGlmIChpc1ByaUtleShhKSAmJiBpc1ByaUtleShiKSkge1xuICAgIGlmIChpc0NvbUtleShhKSB8fCBpc0NvbUtleShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQoYSwgYik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0l0ZW1LZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0tleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGlzQ29tS2V5KGEpICYmIGlzQ29tS2V5KGIpKSB7XG4gICAgcmV0dXJuIGlzQ29tS2V5RXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoaXNQcmlLZXkoYSkgJiYgaXNQcmlLZXkoYikpIHtcbiAgICBpZiAoaXNDb21LZXkoYSkgfHwgaXNDb21LZXkoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlzUHJpS2V5RXF1YWwoYSwgYik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc1ByaUtleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzUHJpS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIGEucGsgPT09IGIucGsgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNMb2NLZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0xvY0tleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBhLmxrID09PSBiLmxrICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzQ29tS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNDb21LZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIGlmIChhICYmIGIgJiYgaXNQcmlLZXlFcXVhbCh7IGt0OiBhLmt0LCBwazogYS5wayB9LCB7IGt0OiBiLmt0LCBwazogYi5wayB9KSkge1xuICAgIGlmIChhLmxvYy5sZW5ndGggPT09IGIubG9jLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTG9jS2V5RXF1YWwoYS5sb2NbaV0sIGIubG9jW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzSXRlbUtleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzSXRlbUtleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChpc0NvbUtleShrZXkpIHx8IGlzUHJpS2V5KGtleSkpO1xufTtcbnZhciBpc0NvbUtleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzQ29tS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGtleS5wayAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gdm9pZCAwKSAmJiAoa2V5LmxvYyAhPT0gdm9pZCAwICYmIGtleS5sb2MubGVuZ3RoID4gMCk7XG59O1xudmFyIGlzUHJpS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNQcmlLZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoa2V5LnBrICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSB2b2lkIDApICYmIChrZXkubG9jID09PSB2b2lkIDAgfHwga2V5LmxvYy5sZW5ndGggPT09IDApO1xufTtcbnZhciBpc0xvY0tleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzTG9jS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGtleS5sayAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gdm9pZCAwKTtcbn07XG52YXIgZ2VuZXJhdGVLZXlBcnJheSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImdlbmVyYXRlS2V5QXJyYXlcIiwgeyBrZXkgfSk7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgaWYgKGlzQ29tS2V5KGtleSkgfHwgaXNQcmlLZXkoa2V5KSkge1xuICAgIGlmIChpc0NvbUtleShrZXkpKSB7XG4gICAgICBjb25zdCBjb21LZXkgPSBrZXk7XG4gICAgICBrZXlzLnB1c2goeyBwazogY29tS2V5LnBrLCBrdDogY29tS2V5Lmt0IH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21LZXkubG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleXMucHVzaChjb21LZXkubG9jW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxvY0tleXMgPSBrZXk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2gobG9jS2V5c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciBjb25zdHJ1Y3RQcmlLZXkgPSAocGssIGt0KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJjb25zdHJ1Y3RQcmlLZXlcIiwgeyBwaywga3QgfSk7XG4gIGxldCBwcmk7XG4gIGlmICh0eXBlb2YgcGsgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBrID09PSBcIm51bWJlclwiKSB7XG4gICAgcHJpID0geyBrdCwgcGsgfTtcbiAgfSBlbHNlIHtcbiAgICBwcmkgPSBwaztcbiAgfVxuICByZXR1cm4gcHJpO1xufTtcbnZhciBjUEsgPSBjb25zdHJ1Y3RQcmlLZXk7XG52YXIgdG9LZXlUeXBlQXJyYXkgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcInRvS2V5VHlwZUFycmF5XCIsIHsgaWsgfSk7XG4gIGlmIChpc0NvbUtleShpaykpIHtcbiAgICBjb25zdCBjayA9IGlrO1xuICAgIHJldHVybiBbY2sua3QsIC4uLmNrLmxvYy5tYXAoKGwpID0+IGwua3QpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2lrLmt0XTtcbiAgfVxufTtcbnZhciBhYmJyZXZJSyA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiYWJicmV2SUtcIiwgeyBpayB9KTtcbiAgaWYgKGlrKSB7XG4gICAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgICAgY29uc3QgY2sgPSBpaztcbiAgICAgIHJldHVybiBgJHtjay5rdH06JHtjay5wa306JHtjay5sb2MubWFwKChsKSA9PiBgJHtsLmt0fToke2wubGt9YCkuam9pbihcIixcIil9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke2lrLmt0fToke2lrLnBrfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm51bGwgSUtcIjtcbiAgfVxufTtcbnZhciBhYmJyZXZMS0EgPSAoa2V5QXJyYXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImFiYnJldkxLQVwiLCB7IGtleUFycmF5IH0pO1xuICBpZiAoa2V5QXJyYXkgPT09IHZvaWQgMCB8fCBrZXlBcnJheSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGwgTEtBXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUFycmF5Lm1hcCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBgJHtrZXkua3R9OiR7a2V5LmxrfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgIH0pLmpvaW4oXCIsXCIpO1xuICB9XG59O1xudmFyIHByaW1hcnlUeXBlID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJwcmltYXJ5VHlwZVwiLCB7IGlrIH0pO1xuICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgcmV0dXJuIGlrLmt0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpay5rdDtcbiAgfVxufTtcbnZhciBpdGVtS2V5VG9Mb2NLZXlBcnJheSA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXRlbUtleVRvTG9jS2V5QXJyYXlcIiwgeyBpazogYWJicmV2SUsoaWspIH0pO1xuICBsZXQgbGthID0gW107XG4gIGlmIChpc0NvbUtleShpaykpIHtcbiAgICBjb25zdCBjayA9IGlrO1xuICAgIGxrYSA9IFt7IGt0OiBjay5rdCwgbGs6IGNrLnBrIH0sIC4uLmNrLmxvY107XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcGsgPSBpaztcbiAgICBsa2EgPSBbeyBrdDogcGsua3QsIGxrOiBway5wayB9XTtcbiAgfVxuICBsb2dnZXIyLnRyYWNlKFwiaXRlbUtleVRvTG9jS2V5QXJyYXkgUmVzdWx0c1wiLCB7IGlrOiBhYmJyZXZJSyhpayksIGxrYTogYWJicmV2TEtBKGxrYSkgfSk7XG4gIHJldHVybiBsa2E7XG59O1xudmFyIGlrVG9MS0EgPSBpdGVtS2V5VG9Mb2NLZXlBcnJheTtcbnZhciBsb2NLZXlBcnJheVRvSXRlbUtleSA9IChsa2EpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImxvY0tleUFycmF5VG9JdGVtS2V5XCIsIHsgbGthOiBhYmJyZXZMS0EobGthKSB9KTtcbiAgaWYgKGxrYSAmJiBsa2EubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgcHJpS2V5ID0gY1BLKGxrYVswXS5saywgbGthWzBdLmt0KTtcbiAgICByZXR1cm4gcHJpS2V5O1xuICB9IGVsc2UgaWYgKGxrYSAmJiBsa2EubGVuZ3RoID4gMSAmJiBsa2FbMF0gIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGxvY3MgPSBsa2Euc2xpY2UoMSk7XG4gICAgY29uc3QgcHJpS2V5ID0gY1BLKGxrYVswXS5saywgbGthWzBdLmt0KTtcbiAgICBjb25zdCBjb21LZXkgPSB7IGt0OiBwcmlLZXkua3QsIHBrOiBwcmlLZXkucGssIGxvYzogbG9jcyB9O1xuICAgIHJldHVybiBjb21LZXk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9jS2V5QXJyYXlUb0l0ZW1LZXk6IGxrYSBpcyB1bmRlZmluZWQgb3IgZW1wdHlcIik7XG4gIH1cbn07XG52YXIgaXNWYWxpZFByaUtleSA9IChrZXkpID0+IHtcbiAgY29uc3QgdmFsaWQgPSBrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IG51bGwgJiYgKGtleS5wayAhPT0gdm9pZCAwICYmIGtleS5wayAhPT0gbnVsbCAmJiBrZXkucGsgIT09IFwiXCIgJiYga2V5LnBrICE9PSBcIm51bGxcIikgJiYgKGtleS5rdCAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gbnVsbCAmJiBrZXkua3QgIT09IFwiXCIgJiYga2V5Lmt0ICE9PSBcIm51bGxcIik7XG4gIHJldHVybiB2YWxpZDtcbn07XG52YXIgaXNWYWxpZExvY0tleSA9IChrZXkpID0+IHtcbiAgY29uc3QgdmFsaWQgPSBrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IG51bGwgJiYgKGtleS5sayAhPT0gdm9pZCAwICYmIGtleS5sayAhPT0gbnVsbCAmJiBrZXkubGsgIT09IFwiXCIgJiYga2V5LmxrICE9PSBcIm51bGxcIikgJiYgKGtleS5rdCAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gbnVsbCAmJiBrZXkua3QgIT09IFwiXCIgJiYga2V5Lmt0ICE9PSBcIm51bGxcIik7XG4gIHJldHVybiB2YWxpZDtcbn07XG52YXIgaXNWYWxpZExvY0tleUFycmF5ID0gKGtleUFycmF5KSA9PiB7XG4gIHJldHVybiBrZXlBcnJheSAhPT0gdm9pZCAwICYmIGtleUFycmF5ICE9PSBudWxsICYmIGtleUFycmF5LmV2ZXJ5KGlzVmFsaWRMb2NLZXkpO1xufTtcbnZhciBpc1ZhbGlkQ29tS2V5ID0gKGtleSkgPT4ge1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSBudWxsICYmIGlzVmFsaWRQcmlLZXkoa2V5KSAmJiBpc1ZhbGlkTG9jS2V5QXJyYXkoa2V5LmxvYyk7XG59O1xudmFyIGlzVmFsaWRJdGVtS2V5ID0gKGtleSkgPT4ge1xuICByZXR1cm4gaXNDb21LZXkoa2V5KSAmJiBpc1ZhbGlkQ29tS2V5KGtleSkgfHwgaXNQcmlLZXkoa2V5KSAmJiBpc1ZhbGlkUHJpS2V5KGtleSk7XG59O1xudmFyIGxrYVRvSUsgPSBsb2NLZXlBcnJheVRvSXRlbUtleTtcblxuLy8gc3JjL2l0ZW0vSUZhY3RvcnkudHNcbnZhciBJRmFjdG9yeSA9IGNsYXNzIF9JRmFjdG9yeSB7XG4gIGl0ZW0gPSB7fTtcbiAgY29uc3RydWN0b3IocHJvcHMgPSB7fSkge1xuICAgIHRoaXMuaXRlbSA9IGRlZXBtZXJnZSh0aGlzLml0ZW0sIHByb3BzKTtcbiAgfVxuICBhZGRSZWYoaSwgbmFtZSkge1xuICAgIGNvbnN0IGlrID0gaS5rZXk7XG4gICAgY29uc3QgcmVmTmFtZSA9IG5hbWUgfHwgcHJpbWFyeVR5cGUoaWspO1xuICAgIGlmICghdGhpcy5pdGVtLnJlZnMpIHtcbiAgICAgIHRoaXMuaXRlbS5yZWZzID0ge307XG4gICAgfVxuICAgIHRoaXMuaXRlbS5yZWZzW3JlZk5hbWVdID0gaWs7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZFJlZihpLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRSZWYoaSwgbmFtZSk7XG4gIH1cbiAgYWRkRGVmYXVsdEV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzLmNyZWF0ZWQpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMuY3JlYXRlZCA9IHsgYXQ6IG5vdyB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMudXBkYXRlZCkge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cy51cGRhdGVkID0geyBhdDogbm93IH07XG4gICAgfVxuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cy5kZWxldGVkKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzLmRlbGV0ZWQgPSB7IGF0OiBudWxsIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZEV2ZW50KG5hbWUsIGF0LCBieSkge1xuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cykge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLml0ZW0uZXZlbnRzW25hbWVdID0geyBhdCwgYnkgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkRXZlbnQobmFtZSwgYXQsIGJ5KSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRFdmVudChuYW1lLCBhdCwgYnkpO1xuICB9XG4gIGFkZFByb3AobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLml0ZW1bbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkUHJvcChuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkUHJvcChuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgYWRkUHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLml0ZW0gPSBkZWVwbWVyZ2UodGhpcy5pdGVtLCBwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRQcm9wcyhwcm9wcyk7XG4gIH1cbiAgdG9JdGVtKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW07XG4gIH1cbn07XG5cbi8vIHNyYy9BSXRlbVNlcnZpY2UudHNcbnZhciBBSXRlbVNlcnZpY2UgPSBjbGFzcyB7XG4gIHBrVHlwZTtcbiAgcGFyZW50U2VydmljZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBrVHlwZSwgcGFyZW50U2VydmljZSkge1xuICAgIHRoaXMucGtUeXBlID0gcGtUeXBlO1xuICAgIGlmIChwYXJlbnRTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnBhcmVudFNlcnZpY2UgPSBwYXJlbnRTZXJ2aWNlO1xuICAgIH1cbiAgfVxuICBnZXRQa1R5cGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMucGtUeXBlO1xuICB9O1xuICBnZXRLZXlUeXBlcyA9ICgpID0+IHtcbiAgICBsZXQga2V5VHlwZXMgPSBbdGhpcy5nZXRQa1R5cGUoKV07XG4gICAgaWYgKHRoaXMucGFyZW50U2VydmljZSkge1xuICAgICAga2V5VHlwZXMgPSBrZXlUeXBlcy5jb25jYXQodGhpcy5wYXJlbnRTZXJ2aWNlLmdldEtleVR5cGVzKCkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VHlwZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvaXRlbS9JdGVtUXVlcnkudHNcbnZhciBpc0NvbmRpdGlvbiA9IChjb25kaXRpb24pID0+IHtcbiAgcmV0dXJuICh0eXBlb2YgY29uZGl0aW9uLmNvbHVtbiA9PT0gXCJzdHJpbmdcIiAmJiAoQXJyYXkuaXNBcnJheShjb25kaXRpb24udmFsdWUpICYmIGNvbmRpdGlvbi52YWx1ZS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpKSB8fCBBcnJheS5pc0FycmF5KGNvbmRpdGlvbi52YWx1ZSkgJiYgY29uZGl0aW9uLnZhbHVlLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIikgfHwgdHlwZW9mIGNvbmRpdGlvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY29uZGl0aW9uLnZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb25kaXRpb24udmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IGNvbmRpdGlvbi52YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmIChjb25kaXRpb24ub3BlcmF0b3IgPyB0eXBlb2YgY29uZGl0aW9uLm9wZXJhdG9yID09PSBcInN0cmluZ1wiIDogdHJ1ZSk7XG59O1xuXG4vLyBzcmMvaXRlbS9JUUZhY3RvcnkudHNcbnZhciBJUUZhY3RvcnkgPSBjbGFzcyBfSVFGYWN0b3J5IHtcbiAgcXVlcnkgPSB7fTtcbiAgY29uc3RydWN0b3IocXVlcnkgPSB7fSkge1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfVxuICBvcmRlckJ5KGZpZWxkLCBkaXJlY3Rpb24gPSBcImFzY1wiKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5Lm9yZGVyQnkpIHtcbiAgICAgIHRoaXMucXVlcnkub3JkZXJCeSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5Lm9yZGVyQnkucHVzaCh7IGZpZWxkLCBkaXJlY3Rpb24gfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWdnKG5hbWUsIHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LmFnZ3MpIHtcbiAgICAgIHRoaXMucXVlcnkuYWdncyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5LmFnZ3NbbmFtZV0gPSBxdWVyeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBldmVudChuYW1lLCBxdWVyeSkge1xuICAgIGlmICghdGhpcy5xdWVyeS5ldmVudHMpIHtcbiAgICAgIHRoaXMucXVlcnkuZXZlbnRzID0ge307XG4gICAgfVxuICAgIHRoaXMucXVlcnkuZXZlbnRzW25hbWVdID0gcXVlcnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29uZGl0aW9ucyhjb25kaXRpb25zLCBjb21wb3VuZFR5cGUgPSBcIkFORFwiKSB7XG4gICAgZm9yIChjb25zdCBjb25kaXRpb24gb2YgY29uZGl0aW9ucykge1xuICAgICAgaWYgKCFpc0NvbmRpdGlvbihjb25kaXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb25kaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoY29uZGl0aW9uKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICBjb21wb3VuZFR5cGUsXG4gICAgICAgIGNvbmRpdGlvbnNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICBjb21wb3VuZFR5cGUsXG4gICAgICAgIGNvbmRpdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMucHVzaChjb21wb3VuZENvbmRpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpbWl0KGxpbWl0KSB7XG4gICAgdGhpcy5xdWVyeS5saW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLnF1ZXJ5Lm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvLyBUT0RPOiByaWdodCBub3csIHdlJ3JlIG9ubHkgc3VwcG9ydGluZyBQSyByZWZzIGZvciBxdWVyaWVzLiAgU2hvdWxkIGFkZCBzdXBwb3J0IGZvciBDS3NcbiAgcGsoa3QsIHBrLCBuYW1lKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LnJlZnMpIHtcbiAgICAgIHRoaXMucXVlcnkucmVmcyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCByZWZOYW1lID0gbmFtZSB8fCBrdDtcbiAgICB0aGlzLnF1ZXJ5LnJlZnNbcmVmTmFtZV0gPSBjUEsocGssIGt0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb25kaXRpb24oY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IgPSBcIj09XCIpIHtcbiAgICBjb25zdCBjb25kaXRpb24gPSB7IGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yIH07XG4gICAgaWYgKGlzQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgIGlmICghdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICAgIGNvbXBvdW5kVHlwZTogXCJBTkRcIixcbiAgICAgICAgICBjb25kaXRpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29uZGl0aW9uOiAke0pTT04uc3RyaW5naWZ5KGNvbmRpdGlvbil9YCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhbGwoKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5O1xuICB9XG4gIHN0YXRpYyBvcmRlckJ5KGZpZWxkLCBkaXJlY3Rpb24gPSBcImFzY1wiKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5Lm9yZGVyQnkoZmllbGQsIGRpcmVjdGlvbik7XG4gIH1cbiAgc3RhdGljIGFnZyhuYW1lLCBxdWVyeSkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5hZ2cobmFtZSwgcXVlcnkpO1xuICB9XG4gIHN0YXRpYyBldmVudChuYW1lLCBxdWVyeSkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5ldmVudChuYW1lLCBxdWVyeSk7XG4gIH1cbiAgc3RhdGljIGxpbWl0KGxpbWl0KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmxpbWl0KGxpbWl0KTtcbiAgfVxuICBzdGF0aWMgb2Zmc2V0KG9mZnNldCkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5vZmZzZXQob2Zmc2V0KTtcbiAgfVxuICBzdGF0aWMgcGsoa3QsIHBrLCBuYW1lKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LnBrKGt0LCBwaywgbmFtZSk7XG4gIH1cbiAgc3RhdGljIGNvbmRpdGlvbihjb2x1bW4sIHZhbHVlLCBvcGVyYXRvciA9IFwiPT1cIikge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5jb25kaXRpb24oY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IpO1xuICB9XG4gIHN0YXRpYyBjb25kaXRpb25zKGNvbmRpdGlvbnMsIGNvbXBvdW5kVHlwZSA9IFwiQU5EXCIpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuY29uZGl0aW9ucyhjb25kaXRpb25zLCBjb21wb3VuZFR5cGUpO1xuICB9XG4gIHRvUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cbn07XG5cbi8vIHNyYy9pdGVtL0lRVXRpbHMudHNcbmltcG9ydCAqIGFzIGx1eG9uIGZyb20gXCJsdXhvblwiO1xudmFyIGxvZ2dlcjMgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJUVV0aWxzXCIpO1xudmFyIHF1ZXJ5VG9QYXJhbXMgPSAocXVlcnkpID0+IHtcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIGlmIChxdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgIHBhcmFtcy5jb21wb3VuZENvbmRpdGlvbiA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgfVxuICBpZiAocXVlcnkucmVmcykge1xuICAgIHBhcmFtcy5yZWZzID0gSlNPTi5zdHJpbmdpZnkocXVlcnkucmVmcyk7XG4gIH1cbiAgaWYgKHF1ZXJ5LmxpbWl0KSB7XG4gICAgcGFyYW1zLmxpbWl0ID0gcXVlcnkubGltaXQ7XG4gIH1cbiAgaWYgKHF1ZXJ5Lm9mZnNldCkge1xuICAgIHBhcmFtcy5vZmZzZXQgPSBxdWVyeS5vZmZzZXQ7XG4gIH1cbiAgaWYgKHF1ZXJ5LmFnZ3MpIHtcbiAgICBwYXJhbXMuYWdncyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LmFnZ3MpO1xuICB9XG4gIGlmIChxdWVyeS5ldmVudHMpIHtcbiAgICBwYXJhbXMuZXZlbnRzID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuZXZlbnRzKTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcbnZhciBkYXRlVGltZVJldml2ZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBwYXJzZWREYXRlID0gbHV4b24uRGF0ZVRpbWUuZnJvbUlTTyh2YWx1ZSk7XG4gICAgaWYgKHBhcnNlZERhdGUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERhdGUudG9KU0RhdGUoKTtcbiAgICAgIDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBwYXJhbXNUb1F1ZXJ5ID0gKHBhcmFtcykgPT4ge1xuICBjb25zdCBxdWVyeSA9IHt9O1xuICBpZiAocGFyYW1zLmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgcXVlcnkuY29tcG91bmRDb25kaXRpb24gPSBKU09OLnBhcnNlKHBhcmFtcy5jb21wb3VuZENvbmRpdGlvbik7XG4gIH1cbiAgaWYgKHBhcmFtcy5yZWZzKSB7XG4gICAgcXVlcnkucmVmcyA9IEpTT04ucGFyc2UocGFyYW1zLnJlZnMpO1xuICB9XG4gIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICBxdWVyeS5saW1pdCA9IE51bWJlcihwYXJhbXMubGltaXQpO1xuICB9XG4gIGlmIChwYXJhbXMub2Zmc2V0KSB7XG4gICAgcXVlcnkub2Zmc2V0ID0gTnVtYmVyKHBhcmFtcy5vZmZzZXQpO1xuICB9XG4gIGlmIChwYXJhbXMuYWdncykge1xuICAgIHF1ZXJ5LmFnZ3MgPSBKU09OLnBhcnNlKHBhcmFtcy5hZ2dzKTtcbiAgfVxuICBpZiAocGFyYW1zLmV2ZW50cykge1xuICAgIHF1ZXJ5LmV2ZW50cyA9IEpTT04ucGFyc2UocGFyYW1zLmV2ZW50cywgZGF0ZVRpbWVSZXZpdmVyKTtcbiAgfVxuICByZXR1cm4gcXVlcnk7XG59O1xudmFyIGlzUmVmUXVlcnlNYXRjaCA9IChyZWZLZXksIHF1ZXJ5UmVmLCByZWZlcmVuY2VzKSA9PiB7XG4gIGxvZ2dlcjMudHJhY2UoXCJkb2VzUmVmTWF0Y2hcIiwgeyBxdWVyeVJlZiwgcmVmZXJlbmNlcyB9KTtcbiAgbG9nZ2VyMy5kZWJ1ZyhcIkNvbXBhcmluZyBSZWZcIiwgeyByZWZLZXksIGl0ZW1SZWY6IHJlZmVyZW5jZXNbcmVmS2V5XSwgcXVlcnlSZWYgfSk7XG4gIHJldHVybiBpc0l0ZW1LZXlFcXVhbChxdWVyeVJlZiwgcmVmZXJlbmNlc1tyZWZLZXldKTtcbn07XG52YXIgaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2ggPSAocXVlcnlDb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgaWYgKHF1ZXJ5Q29uZGl0aW9uLmNvbXBvdW5kVHlwZSA9PT0gXCJBTkRcIikge1xuICAgIHJldHVybiBxdWVyeUNvbmRpdGlvbi5jb25kaXRpb25zLmV2ZXJ5KFxuICAgICAgKGNvbmRpdGlvbikgPT4gaXNDb25kaXRpb24oY29uZGl0aW9uKSA/IGlzQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pIDogaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHF1ZXJ5Q29uZGl0aW9uLmNvbmRpdGlvbnMuc29tZShcbiAgICAgIChjb25kaXRpb24pID0+IGlzQ29uZGl0aW9uKGNvbmRpdGlvbikgPyBpc0NvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKSA6IGlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSlcbiAgICApO1xuICB9XG59O1xudmFyIGlzQ29uZGl0aW9uUXVlcnlNYXRjaCA9IChxdWVyeUNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICBjb25zdCBwcm9wS2V5ID0gcXVlcnlDb25kaXRpb24uY29sdW1uO1xuICBsb2dnZXIzLnRyYWNlKFwiZG9lc0NvbmRpdGlvbk1hdGNoXCIsIHsgcHJvcEtleSwgcXVlcnlDb25kaXRpb24sIGl0ZW0gfSk7XG4gIGlmIChpdGVtW3Byb3BLZXldID09PSB2b2lkIDApIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkb2VzIG5vdCBjb250YWluIHByb3AgdW5kZXIga2V5XCIsIHsgcHJvcEtleSwgaXRlbSB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbG9nZ2VyMy5kZWJ1ZyhcIkNvbXBhcmluZyBDb25kaXRpb25cIiwgeyBwcm9wS2V5LCBpdGVtUHJvcDogaXRlbVtwcm9wS2V5XSwgcXVlcnlDb25kaXRpb24gfSk7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgc3dpdGNoIChxdWVyeUNvbmRpdGlvbi5vcGVyYXRvcikge1xuICAgIGNhc2UgXCI9PVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA9PT0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiIT1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gIT09IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIj5cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPiBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI+PVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA+PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI8XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldIDwgcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPD1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPD0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5cIjpcbiAgICAgIHJlc3VsdCA9IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlLmluY2x1ZGVzKGl0ZW1bcHJvcEtleV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vdC1pblwiOlxuICAgICAgcmVzdWx0ID0gIXF1ZXJ5Q29uZGl0aW9uLnZhbHVlLmluY2x1ZGVzKGl0ZW1bcHJvcEtleV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFycmF5LWNvbnRhaW5zXCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldLmluY2x1ZGVzKHF1ZXJ5Q29uZGl0aW9uLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhcnJheS1jb250YWlucy1hbnlcIjpcbiAgICAgIHJlc3VsdCA9IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlLnNvbWUoKHZhbHVlKSA9PiBpdGVtW3Byb3BLZXldLmluY2x1ZGVzKHZhbHVlKSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBpc0FnZ1F1ZXJ5TWF0Y2ggPSAoYWdnS2V5LCBhZ2dRdWVyeSwgYWdnKSA9PiB7XG4gIGNvbnN0IGFnZ0l0ZW0gPSBhZ2cuaXRlbTtcbiAgbG9nZ2VyMy5kZWJ1ZyhcIkNvbXBhcmluZyBBZ2dcIiwgeyBhZ2dLZXksIGFnZ0l0ZW0sIGFnZ1F1ZXJ5IH0pO1xuICByZXR1cm4gaXNRdWVyeU1hdGNoKGFnZ0l0ZW0sIGFnZ1F1ZXJ5KTtcbn07XG52YXIgaXNFdmVudFF1ZXJ5TWF0Y2ggPSAoZXZlbnRLZXksIGV2ZW50UXVlcnksIGl0ZW0pID0+IHtcbiAgaWYgKCFpdGVtLmV2ZW50c1tldmVudEtleV0pIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkb2VzIG5vdCBjb250YWluIGV2ZW50IHVuZGVyIGtleVwiLCB7IGV2ZW50S2V5LCBldmVudHM6IGl0ZW0uZXZlbnRzIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpdGVtRXZlbnQgPSBpdGVtLmV2ZW50c1tldmVudEtleV07XG4gICAgaWYgKGl0ZW1FdmVudC5hdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV2ZW50UXVlcnkuc3RhcnQgJiYgIShldmVudFF1ZXJ5LnN0YXJ0LmdldFRpbWUoKSA8PSBpdGVtRXZlbnQuYXQuZ2V0VGltZSgpKSkge1xuICAgICAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkYXRlIGJlZm9yZSBldmVudCBzdGFydCBxdWVyeVwiLCB7IGV2ZW50UXVlcnksIGl0ZW1FdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50UXVlcnkuZW5kICYmICEoZXZlbnRRdWVyeS5lbmQuZ2V0VGltZSgpID4gaXRlbUV2ZW50LmF0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZGF0ZSBhZnRlciBldmVudCBlbmQgcXVlcnlcIiwgeyBldmVudFF1ZXJ5LCBpdGVtRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZXZlbnQgZG9lcyBjb250YWlucyBhIG51bGwgYXRcIiwgeyBpdGVtRXZlbnQgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIGlzUXVlcnlNYXRjaCA9IChpdGVtLCBxdWVyeSkgPT4ge1xuICBsb2dnZXIzLnRyYWNlKFwiaXNNYXRjaFwiLCB7IGl0ZW0sIHF1ZXJ5IH0pO1xuICBpZiAocXVlcnkucmVmcyAmJiBpdGVtLnJlZnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5yZWZzKSB7XG4gICAgICBjb25zdCBxdWVyeVJlZiA9IHF1ZXJ5LnJlZnNba2V5XTtcbiAgICAgIGlmICghaXNSZWZRdWVyeU1hdGNoKGtleSwgcXVlcnlSZWYsIGl0ZW0ucmVmcykpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocXVlcnkucmVmcyAmJiAhaXRlbS5yZWZzKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIlF1ZXJ5IGNvbnRhaW5zIHJlZnMgYnV0IGl0ZW0gZG9lcyBub3QgaGF2ZSByZWZzXCIsIHsgcXVlcnksIGl0ZW0gfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChxdWVyeS5jb21wb3VuZENvbmRpdGlvbiAmJiBpdGVtKSB7XG4gICAgaWYgKCFpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChxdWVyeS5jb21wb3VuZENvbmRpdGlvbiwgaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocXVlcnkuZXZlbnRzICYmIGl0ZW0uZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkuZXZlbnRzKSB7XG4gICAgICBjb25zdCBxdWVyeUV2ZW50ID0gcXVlcnkuZXZlbnRzW2tleV07XG4gICAgICBpZiAoIWlzRXZlbnRRdWVyeU1hdGNoKGtleSwgcXVlcnlFdmVudCwgaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHF1ZXJ5LmFnZ3MgJiYgaXRlbS5hZ2dzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkuYWdncykge1xuICAgICAgY29uc3QgYWdnUXVlcnkgPSBxdWVyeS5hZ2dzW2tleV07XG4gICAgICBpZiAoaXRlbS5hZ2dzW2tleV0gJiYgIWlzQWdnUXVlcnlNYXRjaChrZXksIGFnZ1F1ZXJ5LCBpdGVtLmFnZ3Nba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHF1ZXJ5LmFnZ3MgJiYgIWl0ZW0uYWdncykge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJRdWVyeSBjb250YWlucyBhZ2dzIGJ1dCBpdGVtIGRvZXMgbm90IGhhdmUgYWdnc1wiLCB7IHF1ZXJ5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgYWJicmV2UXVlcnkgPSAocXVlcnkpID0+IHtcbiAgY29uc3QgYWJicmV2ID0gW1wiSVFcIl07XG4gIGlmIChxdWVyeSkge1xuICAgIGlmIChxdWVyeS5yZWZzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5yZWZzKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IGFiYnJldlJlZihrZXksIHF1ZXJ5LnJlZnNba2V5XSk7XG4gICAgICAgIGFiYnJldi5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgICAgY29uc3QgcHJvcHMgPSBhYmJyZXZDb21wb3VuZENvbmRpdGlvbihxdWVyeS5jb21wb3VuZENvbmRpdGlvbik7XG4gICAgICBhYmJyZXYucHVzaChwcm9wcyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5hZ2dzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5hZ2dzKSB7XG4gICAgICAgIGNvbnN0IGFnZyA9IGFiYnJldkFnZyhrZXksIHF1ZXJ5LmFnZ3Nba2V5XSk7XG4gICAgICAgIGFiYnJldi5wdXNoKGFnZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeS5ldmVudHMpIHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGAoRSR7T2JqZWN0LmtleXMocXVlcnkuZXZlbnRzKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIGFiYnJldi5wdXNoKGV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5saW1pdCkge1xuICAgICAgYWJicmV2LnB1c2goYEwke3F1ZXJ5LmxpbWl0fWApO1xuICAgIH1cbiAgICBpZiAocXVlcnkub2Zmc2V0KSB7XG4gICAgICBhYmJyZXYucHVzaChgTyR7cXVlcnkub2Zmc2V0fWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhYmJyZXYucHVzaChcIihlbXB0eSlcIik7XG4gIH1cbiAgcmV0dXJuIGFiYnJldi5qb2luKFwiIFwiKTtcbn07XG52YXIgYWJicmV2UmVmID0gKGtleSwgcmVmKSA9PiB7XG4gIGlmIChpc1ByaUtleShyZWYpKSB7XG4gICAgY29uc3QgcHJpS2V5ID0gcmVmO1xuICAgIHJldHVybiBgUigke2tleX0sJHtwcmlLZXkua3R9LCR7cHJpS2V5LnBrfSlgO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbUtleSA9IHJlZjtcbiAgICByZXR1cm4gYFIoJHtrZXl9LCR7SlNPTi5zdHJpbmdpZnkoY29tS2V5KX0pYDtcbiAgfVxufTtcbnZhciBhYmJyZXZBZ2cgPSAoa2V5LCBhZ2cpID0+IHtcbiAgcmV0dXJuIGBBKCR7a2V5fSwke2FiYnJldlF1ZXJ5KGFnZyl9KWA7XG59O1xudmFyIGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uID0gKGNvbXBvdW5kQ29uZGl0aW9uKSA9PiB7XG4gIHJldHVybiBgQ0MoJHtjb21wb3VuZENvbmRpdGlvbi5jb21wb3VuZFR5cGV9LCR7Y29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucyA/IGNvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMubWFwKGFiYnJldkNvbmRpdGlvbikuam9pbihcIixcIikgOiBcIk5vIENvbmRpdGlvbnNcIn0pYDtcbn07XG52YXIgYWJicmV2Q29uZGl0aW9uID0gKGNvbmRpdGlvbikgPT4ge1xuICBpZiAoaXNDb25kaXRpb24oY29uZGl0aW9uKSkge1xuICAgIHJldHVybiBgKCR7Y29uZGl0aW9uLmNvbHVtbn0sJHtjb25kaXRpb24udmFsdWV9LCR7Y29uZGl0aW9uLm9wZXJhdG9yfSlgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhYmJyZXZDb21wb3VuZENvbmRpdGlvbihjb25kaXRpb24pO1xuICB9XG59O1xuXG4vLyBzcmMvaXRlbS9JVXRpbHMudHNcbnZhciBsb2dnZXI0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSVV0aWxzXCIpO1xudmFyIHZhbGlkYXRlUEtGb3JJdGVtID0gKGl0ZW0sIHBrVHlwZSkgPT4ge1xuICBpZiAoIWl0ZW0pIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBpcyB1bmRlZmluZWRcIiwgeyBpdGVtIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gaXMgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICghaXRlbS5rZXkpIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5XCIsIHsgaXRlbSB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGRvZXMgbm90IGhhdmUgYSBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5VHlwZUFycmF5ID0gdG9LZXlUeXBlQXJyYXkoaXRlbS5rZXkpO1xuICBpZiAoa2V5VHlwZUFycmF5WzBdICE9PSBwa1R5cGUpIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiS2V5IFR5cGUgQXJyYXkgTWlzbWF0Y2hcIiwgeyBrZXlUeXBlQXJyYXksIHBrVHlwZSB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBwcmltYXJ5IGtleSB0eXBlLiBFeHBlY3RlZCAke3BrVHlwZX0sIGdvdCAke2tleVR5cGVBcnJheVswXX1gKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG52YXIgdmFsaWRhdGVQSyA9IChpbnB1dCwgcGtUeXBlKSA9PiB7XG4gIGxvZ2dlcjQudHJhY2UoXCJDaGVja2luZyBSZXR1cm4gVHlwZVwiLCB7IGlucHV0IH0pO1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiB2YWxpZGF0ZVBLRm9ySXRlbShpdGVtLCBwa1R5cGUpKTtcbiAgfVxuICByZXR1cm4gdmFsaWRhdGVQS0Zvckl0ZW0oaW5wdXQsIHBrVHlwZSk7XG59O1xudmFyIHZhbGlkYXRlS2V5cyA9IChpdGVtLCBrZXlUeXBlcykgPT4ge1xuICBsb2dnZXI0LnRyYWNlKFwiQ2hlY2tpbmcgUmV0dXJuIFR5cGVcIiwgeyBpdGVtIH0pO1xuICBpZiAoIWl0ZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWxpZGF0aW5nIGtleXMsIGl0ZW0gaXMgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICghaXRlbS5rZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWxpZGF0aW5nIGtleXMsIGl0ZW0gZG9lcyBub3QgaGF2ZSBhIGtleTogXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gIH1cbiAgY29uc3Qga2V5VHlwZUFycmF5ID0gdG9LZXlUeXBlQXJyYXkoaXRlbS5rZXkpO1xuICBpZiAoa2V5VHlwZUFycmF5Lmxlbmd0aCAhPT0ga2V5VHlwZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGtleXMuIEV4cGVjdGVkICR7a2V5VHlwZXMubGVuZ3RofSwgYnV0IGdvdCAke2tleVR5cGVBcnJheS5sZW5ndGh9YCk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBKU09OLnN0cmluZ2lmeShrZXlUeXBlQXJyYXkpID09PSBKU09OLnN0cmluZ2lmeShrZXlUeXBlcyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiS2V5IFR5cGUgQXJyYXkgTWlzbWF0Y2hcIiwgeyBrZXlUeXBlQXJyYXksIHRoaXNLZXlUeXBlczoga2V5VHlwZXMgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3Qga2V5IHR5cGVzLiBFeHBlY3RlZCBbJHtrZXlUeXBlcy5qb2luKFwiLCBcIil9XSwgYnV0IGdvdCBbJHtrZXlUeXBlQXJyYXkuam9pbihcIiwgXCIpfV1gKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG52YXIgaXNQcmlJdGVtID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuICEhKGl0ZW0gJiYgaXRlbS5rZXkgJiYgaXNQcmlLZXkoaXRlbS5rZXkpKTtcbn07XG52YXIgaXNDb21JdGVtID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuICEhKGl0ZW0gJiYgaXRlbS5rZXkgJiYgaXNDb21LZXkoaXRlbS5rZXkpKTtcbn07XG5leHBvcnQge1xuICBBSXRlbVNlcnZpY2UsXG4gIERpY3Rpb25hcnksXG4gIElGYWN0b3J5LFxuICBJUUZhY3RvcnksXG4gIGFiYnJldkFnZyxcbiAgYWJicmV2Q29tcG91bmRDb25kaXRpb24sXG4gIGFiYnJldkNvbmRpdGlvbixcbiAgYWJicmV2SUssXG4gIGFiYnJldkxLQSxcbiAgYWJicmV2UXVlcnksXG4gIGFiYnJldlJlZixcbiAgY1BLLFxuICBjb25zdHJ1Y3RQcmlLZXksXG4gIGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sXG4gIGdlbmVyYXRlS2V5QXJyYXksXG4gIGlrVG9MS0EsXG4gIGlzQ29tSXRlbSxcbiAgaXNDb21LZXksXG4gIGlzQ29tS2V5RXF1YWwsXG4gIGlzQ29tS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc0NvbmRpdGlvbixcbiAgaXNJdGVtS2V5LFxuICBpc0l0ZW1LZXlFcXVhbCxcbiAgaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc0xvY0tleSxcbiAgaXNMb2NLZXlFcXVhbCxcbiAgaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzUHJpSXRlbSxcbiAgaXNQcmlLZXksXG4gIGlzUHJpS2V5RXF1YWwsXG4gIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc1F1ZXJ5TWF0Y2gsXG4gIGlzVmFsaWRDb21LZXksXG4gIGlzVmFsaWRJdGVtS2V5LFxuICBpc1ZhbGlkTG9jS2V5LFxuICBpc1ZhbGlkTG9jS2V5QXJyYXksXG4gIGlzVmFsaWRQcmlLZXksXG4gIGl0ZW1LZXlUb0xvY0tleUFycmF5LFxuICBsa2FUb0lLLFxuICBsb2NLZXlBcnJheVRvSXRlbUtleSxcbiAgcGFyYW1zVG9RdWVyeSxcbiAgcHJpbWFyeVR5cGUsXG4gIHF1ZXJ5VG9QYXJhbXMsXG4gIHRvS2V5VHlwZUFycmF5LFxuICB2YWxpZGF0ZUtleXMsXG4gIHZhbGlkYXRlUEtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/@fjell/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/@fjell/http-api/dist/index.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/http-api/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   ForbiddenError: () => (/* binding */ ForbiddenError),\n/* harmony export */   GoneError: () => (/* binding */ GoneError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   MethodNotAllowedError: () => (/* binding */ MethodNotAllowedError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),\n/* harmony export */   RequestTimeoutError: () => (/* binding */ RequestTimeoutError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   ServiceUnavailableError: () => (/* binding */ ServiceUnavailableError),\n/* harmony export */   TooManyRequestsError: () => (/* binding */ TooManyRequestsError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   connectMethod: () => (/* binding */ connectMethod),\n/* harmony export */   deleteMethod: () => (/* binding */ deleteMethod2),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getHttp: () => (/* binding */ getHttp),\n/* harmony export */   getHttpApi: () => (/* binding */ getHttpApi),\n/* harmony export */   getHttpFile: () => (/* binding */ getHttpFile),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   optionsMethod: () => (/* binding */ optionsMethod),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   patchMethod: () => (/* binding */ patchMethod),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   postFileMethod: () => (/* binding */ postFileMethod2),\n/* harmony export */   postMethod: () => (/* binding */ postMethod),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   putMethod: () => (/* binding */ putMethod),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   traceMethod: () => (/* binding */ traceMethod),\n/* harmony export */   uploadAsyncMethod: () => (/* binding */ uploadAsyncMethod2)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// src/errors.ts\nvar APIError = class _APIError extends Error {\n  httpResponseCode;\n  path;\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, options2);\n    this.httpResponseCode = httpResponseCode;\n    this.path = path;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, _APIError);\n    }\n  }\n};\nvar ClientError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar BadRequestError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 400, options2);\n  }\n};\nvar UnauthorizedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 401, options2);\n  }\n};\nvar ForbiddenError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 403, options2);\n  }\n};\nvar NotFoundError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 404, options2);\n  }\n};\nvar MethodNotAllowedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 405, options2);\n  }\n};\nvar RequestTimeoutError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 408, options2);\n  }\n};\nvar ConflictError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 409, options2);\n  }\n};\nvar GoneError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 410, options2);\n  }\n};\nvar TooManyRequestsError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 429, options2);\n  }\n};\nvar ServerError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar InternalServerError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 500, options2);\n  }\n};\nvar NotImplementedError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 501, options2);\n  }\n};\nvar ServiceUnavailableError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 503, options2);\n  }\n};\n\n// src/api/util.ts\nvar getParameterValue = (value) => {\n  if (value) {\n    return value instanceof Date ? value.toISOString() : value.toString();\n  } else {\n    return \"\";\n  }\n};\nvar generateQueryParameters = (params) => Object.keys(params).length > 0 ? \"?\" + Object.keys(params).filter(\n  (key) => params[key] !== void 0 && (typeof params[key] === \"string\" && params[key].length === 0) === false\n).map((key) => {\n  let value;\n  if (params[key] === false) {\n    value = \"false\";\n  } else {\n    value = params[key];\n  }\n  return `${key}=${encodeURIComponent(getParameterValue(value))}`;\n}).join(\"&\") : \"\";\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/http-api\");\nvar logger_default = LibLogger;\n\n// src/api/http.ts\nvar logger = logger_default.get(\"api\", \"http\");\nfunction getHttp(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, body = {}, httpOptions = {}) => {\n    logger.trace(\"http\", { method, path, body, httpOptions });\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const headers = {};\n    if (!options2.skipContentType) {\n      headers[\"Content-Type\"] = options2.contentType;\n    }\n    headers[\"Accept\"] = options2.accept;\n    headers[\"X-Client-Name\"] = config.clientName;\n    const debugOptions = {\n      ...options2,\n      method,\n      path,\n      body\n    };\n    await populateAuthHeader(options2.isAuthenticated, headers);\n    logger.debug(\"http Request: %j, %j\", method, path);\n    const fetchOptions = {\n      method,\n      headers,\n      credentials: options2.requestCredentials\n    };\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      fetchOptions.body = body ? options2.isJsonBody ? JSON.stringify(body) : body : null;\n    }\n    const response = await fetch(\n      `${config.url}${path}${generateQueryParameters(options2.params)}`,\n      fetchOptions\n    );\n    let returnValue;\n    returnValue = await response.text();\n    if (response.status >= 400) {\n      let error;\n      if (response.status >= 500) {\n        if (response.status === 500) {\n          error = new InternalServerError(response.statusText, path, debugOptions);\n        } else if (response.status === 501) {\n          error = new NotImplementedError(response.statusText, path, debugOptions);\n        } else if (response.status === 503) {\n          error = new ServiceUnavailableError(response.statusText, path, debugOptions);\n        } else {\n          error = new ServerError(response.statusText, path, response.status, debugOptions);\n        }\n      } else {\n        if (response.status === 400) {\n          error = new BadRequestError(response.statusText, path, debugOptions);\n        } else if (response.status === 401) {\n          error = new UnauthorizedError(response.statusText, path, debugOptions);\n        } else if (response.status === 403) {\n          error = new ForbiddenError(response.statusText, path, debugOptions);\n        } else if (response.status === 404) {\n          error = new NotFoundError(response.statusText, path, debugOptions);\n        } else if (response.status === 405) {\n          error = new MethodNotAllowedError(response.statusText, path, debugOptions);\n        } else if (response.status === 408) {\n          error = new RequestTimeoutError(response.statusText, path, debugOptions);\n        } else if (response.status === 409) {\n          error = new ConflictError(response.statusText, path, debugOptions);\n        } else if (response.status === 410) {\n          error = new GoneError(response.statusText, path, debugOptions);\n        } else if (response.status === 429) {\n          error = new TooManyRequestsError(response.statusText, path, debugOptions);\n        } else {\n          error = new ClientError(response.statusText, path, response.status, debugOptions);\n        }\n      }\n      throw error;\n    }\n    if (options2.isJson) {\n      try {\n        returnValue = JSON.parse(returnValue);\n        logger.default(\"API RESPONSE JSON: %j\", { status: response.status, body: returnValue });\n      } catch (e) {\n        logger.error(\"Error parsing JSON\", { message: e.message, stack: e.stack, returnValue });\n        throw e;\n      }\n    } else {\n      logger.default(\"API RESPONSE TEXT: %j\", { status: response.status, body: returnValue });\n    }\n    return returnValue;\n  };\n}\n\n// src/api/deleteMethod.ts\nvar logger2 = logger_default.get(\"api\", \"deleteMethod\");\nfunction deleteMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, deleteOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...deleteOptions\n    };\n    logger2.debug(\"httpDelete Request: %j, %j\", path, options2);\n    const s = await http(\n      \"DELETE\",\n      path,\n      body,\n      options2\n    );\n    logger2.default(\"httpDelete Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/getMethod.ts\nvar logger3 = logger_default.get(\"api\", \"getMethod\");\nfunction getMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger3.debug(\"httpGet Request: %j, %j\", path, options2);\n    const s = await http(\"GET\", path, null, options2);\n    logger3.default(\"httpGet Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/postMethod.ts\nvar logger4 = logger_default.get(\"api\", \"postMethod\");\nfunction postMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger4.debug(\"httpPost Request: %j, %j\", path, options2);\n    const s = await http(\"POST\", path, body, options2);\n    logger4.default(\"httpPost Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/putMethod.ts\nvar logger5 = logger_default.get(\"api\", \"putMethod\");\nfunction putMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger5.debug(\"httpPut Request: %j, %j\", path, options2);\n    const s = await http(\"PUT\", path, body, options2);\n    logger5.default(\"httpPut Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/optionsMethod.ts\nvar logger6 = logger_default.get(\"api\", \"optionsMethod\");\nfunction optionsMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger6.debug(\"httpOptions Request: %j, %j\", path, opts);\n    const s = await http(\"OPTIONS\", path, null, opts);\n    logger6.default(\"httpOptions Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/connectMethod.ts\nvar logger7 = logger_default.get(\"api\", \"connectMethod\");\nfunction connectMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger7.debug(\"httpConnect Request: %j, %j\", path, opts);\n    const s = await http(\"CONNECT\", path, null, opts);\n    logger7.default(\"httpConnect Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/traceMethod.ts\nvar logger8 = logger_default.get(\"api\", \"traceMethod\");\nfunction traceMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger8.debug(\"httpTrace Request: %j, %j\", path, opts);\n    const s = await http(\"TRACE\", path, null, opts);\n    logger8.default(\"httpTrace Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/patchMethod.ts\nvar logger9 = logger_default.get(\"api\", \"patchMethod\");\nfunction patchMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger9.debug(\"httpPatch Request: %j, %j\", path, opts);\n    const s = await http(\"PATCH\", path, body, opts);\n    logger9.default(\"httpPatch Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/httpFile.ts\nfunction getHttpFile(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, file, httpFileOptions = {}, body = {}, headers = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpFileOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    try {\n      headers[\"Accept\"] = options2.accept;\n      headers[\"X-Client-Name\"] = config.clientName;\n      await populateAuthHeader(options2.isAuthenticated, headers);\n      const bodyData = new FormData();\n      Object.keys(body).forEach((key) => {\n        bodyData.set(key, body[key]);\n      });\n      bodyData.set(\"file\", new Blob([new Uint8Array(file.buffer)]), file.bufferName);\n      const response = await fetch(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        {\n          method,\n          headers,\n          body: bodyData,\n          credentials: options2.requestCredentials\n        }\n      );\n      const returnValue = options2.isJson ? await response.json() : await response.text();\n      if (response.status >= 400) {\n        console.error(\n          `Error executing API request httpFile, status: ${response.status}: ` + JSON.stringify({ method, path, params: options2.params, body, returnValue })\n        );\n        throw new Error(options2.isJson ? returnValue.message : returnValue);\n      }\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api/postFileMethod.ts\nvar logger10 = logger_default.get(\"api\", \"postFileMethod\");\nfunction postFileMethod(apiParams) {\n  const httpFile = getHttpFile(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, headers = {}, file, postFileOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...postFileOptions\n    };\n    logger10.debug(\"httpPostFileData Request: %s, %j\", path, options2);\n    logger10.default(\"httpPostFileData Request Body: %j\", body);\n    const s = await httpFile(\n      \"POST\",\n      path,\n      file,\n      options2,\n      body,\n      headers\n    );\n    logger10.default(\"httpPostFileData Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/uploadAsyncMethod.ts\nfunction uploadAsyncMethod(apiParams) {\n  const getOptionDefaults = () => ({\n    method: \"POST\",\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    fieldName: \"file\",\n    headers: {}\n  });\n  return async (path, uri, uploadAsyncOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(),\n      ...uploadAsyncOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const uploadAsyncFile = apiParams.uploadAsyncFile;\n    try {\n      options2.headers[\"Accept\"] = options2.accept;\n      await populateAuthHeader(options2.isAuthenticated, options2.headers);\n      const result = await uploadAsyncFile(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        uri,\n        options2.method,\n        \"multipart\",\n        options2.fieldName,\n        options2.headers\n      );\n      const returnValue = options2.isJson ? JSON.parse(result.body) : result.body;\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${options2.method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api.ts\nvar getHttpApi = (apiParams) => {\n  const httpDelete = deleteMethod(apiParams);\n  const httpGet = getMethod(apiParams);\n  const httpPost = postMethod(apiParams);\n  const httpPut = putMethod(apiParams);\n  const httpOptions = optionsMethod(apiParams);\n  const httpConnect = connectMethod(apiParams);\n  const httpTrace = traceMethod(apiParams);\n  const httpPatch = patchMethod(apiParams);\n  const httpPostFile = postFileMethod(apiParams);\n  const uploadAsync = uploadAsyncMethod(apiParams);\n  return {\n    httpDelete,\n    httpGet,\n    httpPut,\n    httpPost,\n    httpPostFile,\n    uploadAsync,\n    httpOptions,\n    httpConnect,\n    httpTrace,\n    httpPatch\n  };\n};\n\n// src/simple-api.ts\nvar defaultApiParams = {\n  config: {\n    url: \"\",\n    requestCredentials: \"same-origin\",\n    clientName: \"fjell-http-api-examples\"\n  },\n  populateAuthHeader: async (isAuthenticated, headers) => {\n    if (isAuthenticated) {\n      headers[\"Authorization\"] = \"Bearer example-token\";\n    }\n  },\n  uploadAsyncFile: async () => {\n    return {\n      headers: {},\n      status: 200,\n      mimeType: \"application/json\",\n      body: JSON.stringify({ success: true })\n    };\n  }\n};\nvar getImpl = getMethod(defaultApiParams);\nvar postImpl = postMethod(defaultApiParams);\nvar putImpl = putMethod(defaultApiParams);\nvar optionsImpl = optionsMethod(defaultApiParams);\nvar connectImpl = connectMethod(defaultApiParams);\nvar traceImpl = traceMethod(defaultApiParams);\nvar patchImpl = patchMethod(defaultApiParams);\nvar deleteImpl = deleteMethod(defaultApiParams);\nvar postFileImpl = postFileMethod(defaultApiParams);\nvar uploadAsyncImpl = uploadAsyncMethod(defaultApiParams);\nvar get = (path, options2) => {\n  return getImpl(path, options2);\n};\nvar post = (path, body, options2) => {\n  return postImpl(path, body, options2);\n};\nvar put = (path, body, options2) => {\n  return putImpl(path, body, options2);\n};\nvar deleteMethod2 = (path, body, options2) => {\n  return deleteImpl(path, body, options2);\n};\nvar options = (path, opts) => {\n  return optionsImpl(path, opts);\n};\nvar connect = (path, opts) => {\n  return connectImpl(path, opts);\n};\nvar trace = (path, opts) => {\n  return traceImpl(path, opts);\n};\nvar patch = (path, body, opts) => {\n  return patchImpl(path, body, opts);\n};\nvar postFileMethod2 = (path, file, options2) => {\n  const fileBuffer = {\n    buffer: Buffer.from([]),\n    // Placeholder - would need proper File reading in browser\n    bufferName: file.name\n  };\n  return postFileImpl(path, {}, {}, fileBuffer, options2);\n};\nvar uploadAsyncMethod2 = (path, uri, options2) => {\n  return uploadAsyncImpl(path, uri, options2);\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvQGZqZWxsL2h0dHAtYXBpL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLElBQUksR0FBRyw2Q0FBNkM7QUFDaEUsQ0FBQzs7QUFFRDtBQUNx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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRDQUE0QyxpQkFBaUIsRUFBRSxNQUFNLEVBQUU7QUFDdkU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFxQ0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvQGZqZWxsL2h0dHAtYXBpL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy50c1xudmFyIEFQSUVycm9yID0gY2xhc3MgX0FQSUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBodHRwUmVzcG9uc2VDb2RlO1xuICBwYXRoO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMyKTtcbiAgICB0aGlzLmh0dHBSZXNwb25zZUNvZGUgPSBodHRwUmVzcG9uc2VDb2RlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBfQVBJRXJyb3IpO1xuICAgIH1cbiAgfVxufTtcbnZhciBDbGllbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBCYWRSZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAwLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgVW5hdXRob3JpemVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAxLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgRm9yYmlkZGVuRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDAzLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDQsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBNZXRob2ROb3RBbGxvd2VkRXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA1LCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgUmVxdWVzdFRpbWVvdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDgsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBDb25mbGljdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwOSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIEdvbmVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MTAsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBUb29NYW55UmVxdWVzdHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MjksIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBTZXJ2ZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBJbnRlcm5hbFNlcnZlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAwLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgTm90SW1wbGVtZW50ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIDUwMSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAzLCBvcHRpb25zMik7XG4gIH1cbn07XG5cbi8vIHNyYy9hcGkvdXRpbC50c1xudmFyIGdldFBhcmFtZXRlclZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyB2YWx1ZS50b0lTT1N0cmluZygpIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcbnZhciBnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyA9IChwYXJhbXMpID0+IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMCA/IFwiP1wiICsgT2JqZWN0LmtleXMocGFyYW1zKS5maWx0ZXIoXG4gIChrZXkpID0+IHBhcmFtc1trZXldICE9PSB2b2lkIDAgJiYgKHR5cGVvZiBwYXJhbXNba2V5XSA9PT0gXCJzdHJpbmdcIiAmJiBwYXJhbXNba2V5XS5sZW5ndGggPT09IDApID09PSBmYWxzZVxuKS5tYXAoKGtleSkgPT4ge1xuICBsZXQgdmFsdWU7XG4gIGlmIChwYXJhbXNba2V5XSA9PT0gZmFsc2UpIHtcbiAgICB2YWx1ZSA9IFwiZmFsc2VcIjtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICB9XG4gIHJldHVybiBgJHtrZXl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtZXRlclZhbHVlKHZhbHVlKSl9YDtcbn0pLmpvaW4oXCImXCIpIDogXCJcIjtcblxuLy8gc3JjL2xvZ2dlci50c1xuaW1wb3J0IExvZ2dpbmcgZnJvbSBcIkBmamVsbC9sb2dnaW5nXCI7XG52YXIgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoXCJAZmplbGwvaHR0cC1hcGlcIik7XG52YXIgbG9nZ2VyX2RlZmF1bHQgPSBMaWJMb2dnZXI7XG5cbi8vIHNyYy9hcGkvaHR0cC50c1xudmFyIGxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcImh0dHBcIik7XG5mdW5jdGlvbiBnZXRIdHRwKGFwaVBhcmFtcykge1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAobWV0aG9kLCBwYXRoLCBib2R5ID0ge30sIGh0dHBPcHRpb25zID0ge30pID0+IHtcbiAgICBsb2dnZXIudHJhY2UoXCJodHRwXCIsIHsgbWV0aG9kLCBwYXRoLCBib2R5LCBodHRwT3B0aW9ucyB9KTtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5odHRwT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgY29uZmlnID0gYXBpUGFyYW1zLmNvbmZpZztcbiAgICBjb25zdCBwb3B1bGF0ZUF1dGhIZWFkZXIgPSBhcGlQYXJhbXMucG9wdWxhdGVBdXRoSGVhZGVyO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAoIW9wdGlvbnMyLnNraXBDb250ZW50VHlwZSkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IG9wdGlvbnMyLmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gb3B0aW9uczIuYWNjZXB0O1xuICAgIGhlYWRlcnNbXCJYLUNsaWVudC1OYW1lXCJdID0gY29uZmlnLmNsaWVudE5hbWU7XG4gICAgY29uc3QgZGVidWdPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9uczIsXG4gICAgICBtZXRob2QsXG4gICAgICBwYXRoLFxuICAgICAgYm9keVxuICAgIH07XG4gICAgYXdhaXQgcG9wdWxhdGVBdXRoSGVhZGVyKG9wdGlvbnMyLmlzQXV0aGVudGljYXRlZCwgaGVhZGVycyk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cCBSZXF1ZXN0OiAlaiwgJWpcIiwgbWV0aG9kLCBwYXRoKTtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMyLnJlcXVlc3RDcmVkZW50aWFsc1xuICAgIH07XG4gICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBmZXRjaE9wdGlvbnMuYm9keSA9IGJvZHkgPyBvcHRpb25zMi5pc0pzb25Cb2R5ID8gSlNPTi5zdHJpbmdpZnkoYm9keSkgOiBib2R5IDogbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke2NvbmZpZy51cmx9JHtwYXRofSR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMob3B0aW9uczIucGFyYW1zKX1gLFxuICAgICAgZmV0Y2hPcHRpb25zXG4gICAgKTtcbiAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgcmV0dXJuVmFsdWUgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEludGVybmFsU2VydmVyRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IE5vdEltcGxlbWVudGVkRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMykge1xuICAgICAgICAgIGVycm9yID0gbmV3IFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgU2VydmVyRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgcmVzcG9uc2Uuc3RhdHVzLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBCYWRSZXF1ZXN0RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFVuYXV0aG9yaXplZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBGb3JiaWRkZW5FcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgTm90Rm91bmRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgTWV0aG9kTm90QWxsb3dlZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDgpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBSZXF1ZXN0VGltZW91dEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBDb25mbGljdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MTApIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBHb25lRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFRvb01hbnlSZXF1ZXN0c0Vycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgQ2xpZW50RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgcmVzcG9uc2Uuc3RhdHVzLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMyLmlzSnNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBKU09OLnBhcnNlKHJldHVyblZhbHVlKTtcbiAgICAgICAgbG9nZ2VyLmRlZmF1bHQoXCJBUEkgUkVTUE9OU0UgSlNPTjogJWpcIiwgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgYm9keTogcmV0dXJuVmFsdWUgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHBhcnNpbmcgSlNPTlwiLCB7IG1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2ssIHJldHVyblZhbHVlIH0pO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVmYXVsdChcIkFQSSBSRVNQT05TRSBURVhUOiAlalwiLCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBib2R5OiByZXR1cm5WYWx1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL2RlbGV0ZU1ldGhvZC50c1xudmFyIGxvZ2dlcjIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJkZWxldGVNZXRob2RcIik7XG5mdW5jdGlvbiBkZWxldGVNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBib2R5ID0ge30sIGRlbGV0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmRlbGV0ZU9wdGlvbnNcbiAgICB9O1xuICAgIGxvZ2dlcjIuZGVidWcoXCJodHRwRGVsZXRlIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXG4gICAgICBcIkRFTEVURVwiLFxuICAgICAgcGF0aCxcbiAgICAgIGJvZHksXG4gICAgICBvcHRpb25zMlxuICAgICk7XG4gICAgbG9nZ2VyMi5kZWZhdWx0KFwiaHR0cERlbGV0ZSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL2dldE1ldGhvZC50c1xudmFyIGxvZ2dlcjMgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJnZXRNZXRob2RcIik7XG5mdW5jdGlvbiBnZXRNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBnZXRPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5nZXRPcHRpb25zXG4gICAgfTtcbiAgICBsb2dnZXIzLmRlYnVnKFwiaHR0cEdldCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9uczIpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiR0VUXCIsIHBhdGgsIG51bGwsIG9wdGlvbnMyKTtcbiAgICBsb2dnZXIzLmRlZmF1bHQoXCJodHRwR2V0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvcG9zdE1ldGhvZC50c1xudmFyIGxvZ2dlcjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwb3N0TWV0aG9kXCIpO1xuZnVuY3Rpb24gcG9zdE1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIGJvZHkgPSB7fSwgZ2V0T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uZ2V0T3B0aW9uc1xuICAgIH07XG4gICAgbG9nZ2VyNC5kZWJ1ZyhcImh0dHBQb3N0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJQT1NUXCIsIHBhdGgsIGJvZHksIG9wdGlvbnMyKTtcbiAgICBsb2dnZXI0LmRlZmF1bHQoXCJodHRwUG9zdCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3B1dE1ldGhvZC50c1xudmFyIGxvZ2dlcjUgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwdXRNZXRob2RcIik7XG5mdW5jdGlvbiBwdXRNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBib2R5ID0ge30sIGdldE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmdldE9wdGlvbnNcbiAgICB9O1xuICAgIGxvZ2dlcjUuZGVidWcoXCJodHRwUHV0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJQVVRcIiwgcGF0aCwgYm9keSwgb3B0aW9uczIpO1xuICAgIGxvZ2dlcjUuZGVmYXVsdChcImh0dHBQdXQgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9vcHRpb25zTWV0aG9kLnRzXG52YXIgbG9nZ2VyNiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcIm9wdGlvbnNNZXRob2RcIik7XG5mdW5jdGlvbiBvcHRpb25zTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgb3B0aW9uczIgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9O1xuICAgIGxvZ2dlcjYuZGVidWcoXCJodHRwT3B0aW9ucyBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJPUFRJT05TXCIsIHBhdGgsIG51bGwsIG9wdHMpO1xuICAgIGxvZ2dlcjYuZGVmYXVsdChcImh0dHBPcHRpb25zIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvY29ubmVjdE1ldGhvZC50c1xudmFyIGxvZ2dlcjcgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJjb25uZWN0TWV0aG9kXCIpO1xuZnVuY3Rpb24gY29ubmVjdE1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIG9wdGlvbnMyID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLm9wdGlvbnMyXG4gICAgfTtcbiAgICBsb2dnZXI3LmRlYnVnKFwiaHR0cENvbm5lY3QgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwKFwiQ09OTkVDVFwiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXI3LmRlZmF1bHQoXCJodHRwQ29ubmVjdCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3RyYWNlTWV0aG9kLnRzXG52YXIgbG9nZ2VyOCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcInRyYWNlTWV0aG9kXCIpO1xuZnVuY3Rpb24gdHJhY2VNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBvcHRpb25zMiA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH07XG4gICAgbG9nZ2VyOC5kZWJ1ZyhcImh0dHBUcmFjZSBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJUUkFDRVwiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXI4LmRlZmF1bHQoXCJodHRwVHJhY2UgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9wYXRjaE1ldGhvZC50c1xudmFyIGxvZ2dlcjkgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwYXRjaE1ldGhvZFwiKTtcbmZ1bmN0aW9uIHBhdGNoTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgYm9keSA9IHt9LCBvcHRpb25zMiA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH07XG4gICAgbG9nZ2VyOS5kZWJ1ZyhcImh0dHBQYXRjaCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJQQVRDSFwiLCBwYXRoLCBib2R5LCBvcHRzKTtcbiAgICBsb2dnZXI5LmRlZmF1bHQoXCJodHRwUGF0Y2ggUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9odHRwRmlsZS50c1xuZnVuY3Rpb24gZ2V0SHR0cEZpbGUoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAobWV0aG9kLCBwYXRoLCBmaWxlLCBodHRwRmlsZU9wdGlvbnMgPSB7fSwgYm9keSA9IHt9LCBoZWFkZXJzID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5odHRwRmlsZU9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IGFwaVBhcmFtcy5jb25maWc7XG4gICAgY29uc3QgcG9wdWxhdGVBdXRoSGVhZGVyID0gYXBpUGFyYW1zLnBvcHVsYXRlQXV0aEhlYWRlcjtcbiAgICB0cnkge1xuICAgICAgaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMyLmFjY2VwdDtcbiAgICAgIGhlYWRlcnNbXCJYLUNsaWVudC1OYW1lXCJdID0gY29uZmlnLmNsaWVudE5hbWU7XG4gICAgICBhd2FpdCBwb3B1bGF0ZUF1dGhIZWFkZXIob3B0aW9uczIuaXNBdXRoZW50aWNhdGVkLCBoZWFkZXJzKTtcbiAgICAgIGNvbnN0IGJvZHlEYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBPYmplY3Qua2V5cyhib2R5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgYm9keURhdGEuc2V0KGtleSwgYm9keVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgYm9keURhdGEuc2V0KFwiZmlsZVwiLCBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoZmlsZS5idWZmZXIpXSksIGZpbGUuYnVmZmVyTmFtZSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMyLnBhcmFtcyl9YCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGJvZHlEYXRhLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zMi5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3B0aW9uczIuaXNKc29uID8gYXdhaXQgcmVzcG9uc2UuanNvbigpIDogYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIEFQSSByZXF1ZXN0IGh0dHBGaWxlLCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfTogYCArIEpTT04uc3RyaW5naWZ5KHsgbWV0aG9kLCBwYXRoLCBwYXJhbXM6IG9wdGlvbnMyLnBhcmFtcywgYm9keSwgcmV0dXJuVmFsdWUgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMyLmlzSnNvbiA/IHJldHVyblZhbHVlLm1lc3NhZ2UgOiByZXR1cm5WYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdCBodHRwICR7bWV0aG9kfSAke3BhdGh9ICR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMoXG4gICAgICAgICAgb3B0aW9uczIucGFyYW1zXG4gICAgICAgICl9YCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYXBpL3Bvc3RGaWxlTWV0aG9kLnRzXG52YXIgbG9nZ2VyMTAgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhcGlcIiwgXCJwb3N0RmlsZU1ldGhvZFwiKTtcbmZ1bmN0aW9uIHBvc3RGaWxlTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwRmlsZSA9IGdldEh0dHBGaWxlKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgYm9keSA9IHt9LCBoZWFkZXJzID0ge30sIGZpbGUsIHBvc3RGaWxlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ucG9zdEZpbGVPcHRpb25zXG4gICAgfTtcbiAgICBsb2dnZXIxMC5kZWJ1ZyhcImh0dHBQb3N0RmlsZURhdGEgUmVxdWVzdDogJXMsICVqXCIsIHBhdGgsIG9wdGlvbnMyKTtcbiAgICBsb2dnZXIxMC5kZWZhdWx0KFwiaHR0cFBvc3RGaWxlRGF0YSBSZXF1ZXN0IEJvZHk6ICVqXCIsIGJvZHkpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCBodHRwRmlsZShcbiAgICAgIFwiUE9TVFwiLFxuICAgICAgcGF0aCxcbiAgICAgIGZpbGUsXG4gICAgICBvcHRpb25zMixcbiAgICAgIGJvZHksXG4gICAgICBoZWFkZXJzXG4gICAgKTtcbiAgICBsb2dnZXIxMC5kZWZhdWx0KFwiaHR0cFBvc3RGaWxlRGF0YSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3VwbG9hZEFzeW5jTWV0aG9kLnRzXG5mdW5jdGlvbiB1cGxvYWRBc3luY01ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoKSA9PiAoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgZmllbGROYW1lOiBcImZpbGVcIixcbiAgICBoZWFkZXJzOiB7fVxuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCB1cmksIHVwbG9hZEFzeW5jT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cygpLFxuICAgICAgLi4udXBsb2FkQXN5bmNPcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBhcGlQYXJhbXMuY29uZmlnO1xuICAgIGNvbnN0IHBvcHVsYXRlQXV0aEhlYWRlciA9IGFwaVBhcmFtcy5wb3B1bGF0ZUF1dGhIZWFkZXI7XG4gICAgY29uc3QgdXBsb2FkQXN5bmNGaWxlID0gYXBpUGFyYW1zLnVwbG9hZEFzeW5jRmlsZTtcbiAgICB0cnkge1xuICAgICAgb3B0aW9uczIuaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMyLmFjY2VwdDtcbiAgICAgIGF3YWl0IHBvcHVsYXRlQXV0aEhlYWRlcihvcHRpb25zMi5pc0F1dGhlbnRpY2F0ZWQsIG9wdGlvbnMyLmhlYWRlcnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkQXN5bmNGaWxlKFxuICAgICAgICBgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMyLnBhcmFtcyl9YCxcbiAgICAgICAgdXJpLFxuICAgICAgICBvcHRpb25zMi5tZXRob2QsXG4gICAgICAgIFwibXVsdGlwYXJ0XCIsXG4gICAgICAgIG9wdGlvbnMyLmZpZWxkTmFtZSxcbiAgICAgICAgb3B0aW9uczIuaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3B0aW9uczIuaXNKc29uID8gSlNPTi5wYXJzZShyZXN1bHQuYm9keSkgOiByZXN1bHQuYm9keTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIEFQSSByZXF1ZXN0IGh0dHAgJHtvcHRpb25zMi5tZXRob2R9ICR7cGF0aH0gJHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhcbiAgICAgICAgICBvcHRpb25zMi5wYXJhbXNcbiAgICAgICAgKX1gLFxuICAgICAgICBlXG4gICAgICApO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hcGkudHNcbnZhciBnZXRIdHRwQXBpID0gKGFwaVBhcmFtcykgPT4ge1xuICBjb25zdCBodHRwRGVsZXRlID0gZGVsZXRlTWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBHZXQgPSBnZXRNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cFBvc3QgPSBwb3N0TWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBQdXQgPSBwdXRNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cE9wdGlvbnMgPSBvcHRpb25zTWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBDb25uZWN0ID0gY29ubmVjdE1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwVHJhY2UgPSB0cmFjZU1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwUGF0Y2ggPSBwYXRjaE1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwUG9zdEZpbGUgPSBwb3N0RmlsZU1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCB1cGxvYWRBc3luYyA9IHVwbG9hZEFzeW5jTWV0aG9kKGFwaVBhcmFtcyk7XG4gIHJldHVybiB7XG4gICAgaHR0cERlbGV0ZSxcbiAgICBodHRwR2V0LFxuICAgIGh0dHBQdXQsXG4gICAgaHR0cFBvc3QsXG4gICAgaHR0cFBvc3RGaWxlLFxuICAgIHVwbG9hZEFzeW5jLFxuICAgIGh0dHBPcHRpb25zLFxuICAgIGh0dHBDb25uZWN0LFxuICAgIGh0dHBUcmFjZSxcbiAgICBodHRwUGF0Y2hcbiAgfTtcbn07XG5cbi8vIHNyYy9zaW1wbGUtYXBpLnRzXG52YXIgZGVmYXVsdEFwaVBhcmFtcyA9IHtcbiAgY29uZmlnOiB7XG4gICAgdXJsOiBcIlwiLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgIGNsaWVudE5hbWU6IFwiZmplbGwtaHR0cC1hcGktZXhhbXBsZXNcIlxuICB9LFxuICBwb3B1bGF0ZUF1dGhIZWFkZXI6IGFzeW5jIChpc0F1dGhlbnRpY2F0ZWQsIGhlYWRlcnMpID0+IHtcbiAgICBpZiAoaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmVhcmVyIGV4YW1wbGUtdG9rZW5cIjtcbiAgICB9XG4gIH0sXG4gIHVwbG9hZEFzeW5jRmlsZTogYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzdWNjZXNzOiB0cnVlIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBnZXRJbXBsID0gZ2V0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIHBvc3RJbXBsID0gcG9zdE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBwdXRJbXBsID0gcHV0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIG9wdGlvbnNJbXBsID0gb3B0aW9uc01ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBjb25uZWN0SW1wbCA9IGNvbm5lY3RNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgdHJhY2VJbXBsID0gdHJhY2VNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgcGF0Y2hJbXBsID0gcGF0Y2hNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgZGVsZXRlSW1wbCA9IGRlbGV0ZU1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBwb3N0RmlsZUltcGwgPSBwb3N0RmlsZU1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciB1cGxvYWRBc3luY0ltcGwgPSB1cGxvYWRBc3luY01ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBnZXQgPSAocGF0aCwgb3B0aW9uczIpID0+IHtcbiAgcmV0dXJuIGdldEltcGwocGF0aCwgb3B0aW9uczIpO1xufTtcbnZhciBwb3N0ID0gKHBhdGgsIGJvZHksIG9wdGlvbnMyKSA9PiB7XG4gIHJldHVybiBwb3N0SW1wbChwYXRoLCBib2R5LCBvcHRpb25zMik7XG59O1xudmFyIHB1dCA9IChwYXRoLCBib2R5LCBvcHRpb25zMikgPT4ge1xuICByZXR1cm4gcHV0SW1wbChwYXRoLCBib2R5LCBvcHRpb25zMik7XG59O1xudmFyIGRlbGV0ZU1ldGhvZDIgPSAocGF0aCwgYm9keSwgb3B0aW9uczIpID0+IHtcbiAgcmV0dXJuIGRlbGV0ZUltcGwocGF0aCwgYm9keSwgb3B0aW9uczIpO1xufTtcbnZhciBvcHRpb25zID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgcmV0dXJuIG9wdGlvbnNJbXBsKHBhdGgsIG9wdHMpO1xufTtcbnZhciBjb25uZWN0ID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgcmV0dXJuIGNvbm5lY3RJbXBsKHBhdGgsIG9wdHMpO1xufTtcbnZhciB0cmFjZSA9IChwYXRoLCBvcHRzKSA9PiB7XG4gIHJldHVybiB0cmFjZUltcGwocGF0aCwgb3B0cyk7XG59O1xudmFyIHBhdGNoID0gKHBhdGgsIGJvZHksIG9wdHMpID0+IHtcbiAgcmV0dXJuIHBhdGNoSW1wbChwYXRoLCBib2R5LCBvcHRzKTtcbn07XG52YXIgcG9zdEZpbGVNZXRob2QyID0gKHBhdGgsIGZpbGUsIG9wdGlvbnMyKSA9PiB7XG4gIGNvbnN0IGZpbGVCdWZmZXIgPSB7XG4gICAgYnVmZmVyOiBCdWZmZXIuZnJvbShbXSksXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3b3VsZCBuZWVkIHByb3BlciBGaWxlIHJlYWRpbmcgaW4gYnJvd3NlclxuICAgIGJ1ZmZlck5hbWU6IGZpbGUubmFtZVxuICB9O1xuICByZXR1cm4gcG9zdEZpbGVJbXBsKHBhdGgsIHt9LCB7fSwgZmlsZUJ1ZmZlciwgb3B0aW9uczIpO1xufTtcbnZhciB1cGxvYWRBc3luY01ldGhvZDIgPSAocGF0aCwgdXJpLCBvcHRpb25zMikgPT4ge1xuICByZXR1cm4gdXBsb2FkQXN5bmNJbXBsKHBhdGgsIHVyaSwgb3B0aW9uczIpO1xufTtcbmV4cG9ydCB7XG4gIEFQSUVycm9yLFxuICBCYWRSZXF1ZXN0RXJyb3IsXG4gIENsaWVudEVycm9yLFxuICBDb25mbGljdEVycm9yLFxuICBGb3JiaWRkZW5FcnJvcixcbiAgR29uZUVycm9yLFxuICBJbnRlcm5hbFNlcnZlckVycm9yLFxuICBNZXRob2ROb3RBbGxvd2VkRXJyb3IsXG4gIE5vdEZvdW5kRXJyb3IsXG4gIE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIFJlcXVlc3RUaW1lb3V0RXJyb3IsXG4gIFNlcnZlckVycm9yLFxuICBTZXJ2aWNlVW5hdmFpbGFibGVFcnJvcixcbiAgVG9vTWFueVJlcXVlc3RzRXJyb3IsXG4gIFVuYXV0aG9yaXplZEVycm9yLFxuICBjb25uZWN0LFxuICBjb25uZWN0TWV0aG9kLFxuICBkZWxldGVNZXRob2QyIGFzIGRlbGV0ZU1ldGhvZCxcbiAgZ2V0LFxuICBnZXRIdHRwLFxuICBnZXRIdHRwQXBpLFxuICBnZXRIdHRwRmlsZSxcbiAgZ2V0TWV0aG9kLFxuICBvcHRpb25zLFxuICBvcHRpb25zTWV0aG9kLFxuICBwYXRjaCxcbiAgcGF0Y2hNZXRob2QsXG4gIHBvc3QsXG4gIHBvc3RGaWxlTWV0aG9kMiBhcyBwb3N0RmlsZU1ldGhvZCxcbiAgcG9zdE1ldGhvZCxcbiAgcHV0LFxuICBwdXRNZXRob2QsXG4gIHRyYWNlLFxuICB0cmFjZU1ldGhvZCxcbiAgdXBsb2FkQXN5bmNNZXRob2QyIGFzIHVwbG9hZEFzeW5jTWV0aG9kXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/@fjell/http-api/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/@fjell/logging/dist/index.js":
/*!****************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/logging/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvQGZqZWxsL2xvZ2dpbmcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxLQUFLO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFNcEI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvQGZqZWxsL2xvZ2dpbmcvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvTG9nRm9ybWF0LnRzXG52YXIgTG9nRm9ybWF0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KExvZ0Zvcm1hdF9leHBvcnRzLCB7XG4gIExvZ0Zvcm1hdHM6ICgpID0+IExvZ0Zvcm1hdHMsXG4gIFNUUlVDVFVSRUQ6ICgpID0+IFNUUlVDVFVSRUQsXG4gIFRFWFQ6ICgpID0+IFRFWFQsXG4gIGdldENvbmZpZzogKCkgPT4gZ2V0Q29uZmlnXG59KTtcbnZhciBURVhUID0ge1xuICBuYW1lOiBcIlRFWFRcIixcbiAgZGVzY3JpcHRpb246IFwiVGV4dCBmb3JtYXRcIlxufTtcbnZhciBTVFJVQ1RVUkVEID0ge1xuICBuYW1lOiBcIlNUUlVDVFVSRURcIixcbiAgZGVzY3JpcHRpb246IFwiU3RydWN0dXJlZCBmb3JtYXRcIlxufTtcbnZhciBMb2dGb3JtYXRzID0gW1xuICBURVhULFxuICBTVFJVQ1RVUkVEXG5dO1xudmFyIGdldENvbmZpZyA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0Zvcm1hdHMuZmluZCgoY29uZmlnMikgPT4gY29uZmlnMi5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG9nIEZvcm1hdCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8vIHNyYy9Mb2dMZXZlbC50c1xudmFyIExvZ0xldmVsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KExvZ0xldmVsX2V4cG9ydHMsIHtcbiAgQUxFUlQ6ICgpID0+IEFMRVJULFxuICBDUklUSUNBTDogKCkgPT4gQ1JJVElDQUwsXG4gIERFQlVHOiAoKSA9PiBERUJVRyxcbiAgREVGQVVMVDogKCkgPT4gREVGQVVMVCxcbiAgRU1FUkdFTkNZOiAoKSA9PiBFTUVSR0VOQ1ksXG4gIEVSUk9SOiAoKSA9PiBFUlJPUixcbiAgSU5GTzogKCkgPT4gSU5GTyxcbiAgTG9nTGV2ZWxzOiAoKSA9PiBMb2dMZXZlbHMsXG4gIE5PVElDRTogKCkgPT4gTk9USUNFLFxuICBUUkFDRTogKCkgPT4gVFJBQ0UsXG4gIFdBUk5JTkc6ICgpID0+IFdBUk5JTkcsXG4gIGdldENvbmZpZzogKCkgPT4gZ2V0Q29uZmlnMlxufSk7XG52YXIgRU1FUkdFTkNZID0ge1xuICBuYW1lOiBcIkVNRVJHRU5DWVwiLFxuICB2YWx1ZTogMFxufTtcbnZhciBBTEVSVCA9IHtcbiAgbmFtZTogXCJBTEVSVFwiLFxuICB2YWx1ZTogMVxufTtcbnZhciBDUklUSUNBTCA9IHtcbiAgbmFtZTogXCJDUklUSUNBTFwiLFxuICB2YWx1ZTogMlxufTtcbnZhciBFUlJPUiA9IHtcbiAgbmFtZTogXCJFUlJPUlwiLFxuICB2YWx1ZTogM1xufTtcbnZhciBXQVJOSU5HID0ge1xuICBuYW1lOiBcIldBUk5JTkdcIixcbiAgdmFsdWU6IDRcbn07XG52YXIgTk9USUNFID0ge1xuICBuYW1lOiBcIk5PVElDRVwiLFxuICB2YWx1ZTogNVxufTtcbnZhciBJTkZPID0ge1xuICBuYW1lOiBcIklORk9cIixcbiAgdmFsdWU6IDZcbn07XG52YXIgREVCVUcgPSB7XG4gIG5hbWU6IFwiREVCVUdcIixcbiAgdmFsdWU6IDdcbn07XG52YXIgVFJBQ0UgPSB7XG4gIG5hbWU6IFwiVFJBQ0VcIixcbiAgdmFsdWU6IDhcbn07XG52YXIgREVGQVVMVCA9IHtcbiAgbmFtZTogXCJERUZBVUxUXCIsXG4gIHZhbHVlOiA5XG59O1xudmFyIExvZ0xldmVscyA9IFtcbiAgRU1FUkdFTkNZLFxuICBBTEVSVCxcbiAgQ1JJVElDQUwsXG4gIEVSUk9SLFxuICBXQVJOSU5HLFxuICBOT1RJQ0UsXG4gIElORk8sXG4gIERFQlVHLFxuICBUUkFDRSxcbiAgREVGQVVMVFxuXTtcbnZhciBnZXRDb25maWcyID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gTG9nTGV2ZWxzLmZpbmQoKGNvbmZpZzIpID0+IGNvbmZpZzIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBMZXZlbCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8vIHNyYy9jb25maWcudHNcbnZhciBkZWZhdWx0TG9nTGV2ZWwgPSBJTkZPO1xudmFyIGRlZmF1bHRMb2dGb3JtYXQgPSBURVhUO1xudmFyIGRlZmF1bHRMb2dnaW5nQ29uZmlnID0ge1xuICBsb2dMZXZlbDogZGVmYXVsdExvZ0xldmVsLFxuICBsb2dGb3JtYXQ6IGRlZmF1bHRMb2dGb3JtYXQsXG4gIG92ZXJyaWRlczoge30sXG4gIGZsb29kQ29udHJvbDoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHRocmVzaG9sZDogMTAsXG4gICAgdGltZWZyYW1lOiAxZTNcbiAgICAvLyAxIHNlY29uZFxuICB9XG59O1xudmFyIGNvbnZlcnRPdmVycmlkZXMgPSAob3ZlcnJpZGVzKSA9PiB7XG4gIGNvbnN0IGNvbnZlcnRlZE92ZXJyaWRlcyA9IHt9O1xuICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMob3ZlcnJpZGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGNvbnZlcnRlZE92ZXJyaWRlc1trZXldID0geyBsb2dMZXZlbDogdmFsdWUubG9nTGV2ZWwgPyBnZXRDb25maWcyKHZhbHVlLmxvZ0xldmVsKSA6IGRlZmF1bHRMb2dMZXZlbCB9O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPdmVycmlkZXM7XG59O1xudmFyIGNvbnZlcnRDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbG9nTGV2ZWw6IGNvbmZpZy5sb2dMZXZlbCA/IGdldENvbmZpZzIoY29uZmlnLmxvZ0xldmVsKSA6IGRlZmF1bHRMb2dMZXZlbCxcbiAgICBsb2dGb3JtYXQ6IGNvbmZpZy5sb2dGb3JtYXQgPyBnZXRDb25maWcoY29uZmlnLmxvZ0Zvcm1hdCkgOiBkZWZhdWx0TG9nRm9ybWF0LFxuICAgIG92ZXJyaWRlczogY29udmVydE92ZXJyaWRlcyhjb25maWcub3ZlcnJpZGVzKSxcbiAgICBmbG9vZENvbnRyb2w6IHtcbiAgICAgIC4uLmRlZmF1bHRMb2dnaW5nQ29uZmlnLmZsb29kQ29udHJvbCxcbiAgICAgIC4uLmNvbmZpZy5mbG9vZENvbnRyb2wgfHwge31cbiAgICB9XG4gIH07XG59O1xudmFyIGNvbmZpZ3VyZUxvZ2dpbmcgPSAoKSA9PiB7XG4gIGxldCBjb25maWcgPSB7fTtcbiAgY29uc3QgbG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkxPR0dJTkdfQ09ORklHO1xuICBjb25zdCBleHBvTG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBjb25zdCBuZXh0TG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBsZXQgbG9nTGV2ZWxFbnYgPSBwcm9jZXNzLmVudi5MT0dfTEVWRUw7XG4gIGxldCBsb2dGb3JtYXRFbnYgPSBwcm9jZXNzLmVudi5MT0dfRk9STUFUO1xuICBpZiAobG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKGxvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIExPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwb0xvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShleHBvTG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gRVhQT19QVUJMSUNfTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0TG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKG5leHRMb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnZlcnRlZENvbmZpZyA9IGNvbnZlcnRDb25maWcoY29uZmlnKTtcbiAgaWYgKGxvZ0xldmVsRW52KSB7XG4gICAgbG9nTGV2ZWxFbnYgPSBsb2dMZXZlbEVudj8udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBsb2dMZXZlbENvbmZpZyA9IGdldENvbmZpZzIobG9nTGV2ZWxFbnYpO1xuICAgIGNvbnZlcnRlZENvbmZpZy5sb2dMZXZlbCA9IGxvZ0xldmVsQ29uZmlnO1xuICB9XG4gIGlmIChsb2dGb3JtYXRFbnYpIHtcbiAgICBsb2dGb3JtYXRFbnYgPSBsb2dGb3JtYXRFbnYudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBsb2dGb3JtYXRDb25maWcgPSBnZXRDb25maWcobG9nRm9ybWF0RW52KTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nRm9ybWF0ID0gbG9nRm9ybWF0Q29uZmlnO1xuICB9XG4gIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZywgLi4uY29udmVydGVkQ29uZmlnIH07XG4gIHJldHVybiBmaW5hbENvbmZpZztcbn07XG5cbi8vIHNyYy9Xcml0ZXIudHNcbnZhciBjcmVhdGVXcml0ZXIgPSAoZm9ybWF0dGVyLCBsb2dNZXRob2QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVzcGVjdEluamVjdGVkTWV0aG9kID0gZmFsc2UsXG4gICAgZXJyb3JNZXRob2QgPSBjb25zb2xlLmVycm9yLFxuICAgIHdhcm5pbmdNZXRob2QgPSBjb25zb2xlLndhcm4sXG4gICAgaW5mb01ldGhvZCA9IGNvbnNvbGUubG9nXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4ge1xuICAgIHdyaXRlOiAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgICBsZXQgZmluYWxMb2dNZXRob2QgPSBsb2dNZXRob2Q7XG4gICAgICBpZiAoIXJlc3BlY3RJbmplY3RlZE1ldGhvZCkge1xuICAgICAgICBpZiAobGV2ZWwubmFtZSA9PT0gRVJST1IubmFtZSB8fCBsZXZlbC5uYW1lID09PSBDUklUSUNBTC5uYW1lIHx8IGxldmVsLm5hbWUgPT09IEFMRVJULm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gRU1FUkdFTkNZLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGVycm9yTWV0aG9kO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsLm5hbWUgPT09IFdBUk5JTkcubmFtZSkge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gd2FybmluZ01ldGhvZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGluZm9NZXRob2Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmFsTG9nTWV0aG9kKGZvcm1hdHRlci5mb3JtYXRMb2cobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2Zvcm1hdHRlci50c1xuaW1wb3J0IHV0aWwgZnJvbSBcInV0aWxcIjtcbnZhciBzYWZlSW5zcGVjdCA9IChvYmopID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KG9iaik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgW09iamVjdDogJHt0eXBlb2Ygb2JqfV1gO1xuICB9XG59O1xudmFyIHNhZmVGb3JtYXQgPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1dGlsLmZvcm1hdChtZXNzYWdlLCAuLi5hcmdzKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGAke21lc3NhZ2V9ICR7c2FmZUluc3BlY3QoYXJncyl9YDtcbiAgfVxufTtcbnZhciBjcmVhdGVGb3JtYXR0ZXIgPSAobG9nRm9ybWF0KSA9PiB7XG4gIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJURVhUXCIpIHtcbiAgICByZXR1cm4gZ2V0VGV4dEZvcm1hdHRlcigpO1xuICB9IGVsc2UgaWYgKGxvZ0Zvcm1hdC5uYW1lID09PSBcIlNUUlVDVFVSRURcIikge1xuICAgIHJldHVybiBnZXRTdHJ1Y3R1cmVkRm9ybWF0dGVyKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxvZyBmb3JtYXQ6ICR7bG9nRm9ybWF0Lm5hbWV9YCk7XG59O1xudmFyIGdldFRleHRGb3JtYXR0ZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGZvcm1hdExvZyA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG4gICAgbGV0IGxvZ01lc3NhZ2U7XG4gICAgaWYgKHBheWxvYWQuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBwYXlsb2FkLm1lc3NhZ2U7XG4gICAgfSBlbHNlIGlmIChoYXNTcGVjaWZpZXJzKSB7XG4gICAgICBsb2dNZXNzYWdlID0gc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBgJHtwYXlsb2FkLm1lc3NhZ2V9ICR7c2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCgkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpfSkgWyR7bGV2ZWwubmFtZX1dIC0gWyR7Y29vcmRpbmF0ZXMuY2F0ZWdvcnl9XSAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9ICR7bG9nTWVzc2FnZX1gO1xuICB9O1xuICBjb25zdCB0aW1lck1lc3NhZ2UgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgcmFuZG9tSW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU2KTtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UyID0gYCgkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpfSkgWyR7bGV2ZWwubmFtZX1dIC0gWyR7Y29vcmRpbmF0ZXMuY2F0ZWdvcnl9XSAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9ICR7c2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSl9ICR7c2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKX0gJHtyYW5kb21JbnR9YDtcbiAgICByZXR1cm4gdGltZXJNZXNzYWdlMjtcbiAgfTtcbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gVEVYVCB9O1xufTtcbnZhciBnZXRTdHJ1Y3R1cmVkRm9ybWF0dGVyID0gKCkgPT4ge1xuICBjb25zdCBmb3JtYXRMb2cgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3Qgc2V2ZXJpdHkgPSBsZXZlbC5uYW1lO1xuICAgIGNvbnN0IGhhc1NwZWNpZmllcnMgPSAvJVtzZGppZm9PJV0vLnRlc3QocGF5bG9hZC5tZXNzYWdlKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc2V2ZXJpdHksXG4gICAgICBtZXNzYWdlOiBoYXNTcGVjaWZpZXJzID8gc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSkgOiBwYXlsb2FkLm1lc3NhZ2UsXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vbGFiZWxzXCI6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBgJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfWBcbiAgICAgIH0sXG4gICAgICAuLi4haGFzU3BlY2lmaWVycyAmJiBwYXlsb2FkLmRhdGEubGVuZ3RoID4gMCAmJiB7IGRhdGE6IHNhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSkgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB0aW1lck1lc3NhZ2UgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3Qgc2V2ZXJpdHkgPSBsZXZlbC5uYW1lO1xuICAgIGNvbnN0IHJhbmRvbUludCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSksXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vbGFiZWxzXCI6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBgJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfWBcbiAgICAgIH0sXG4gICAgICBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL3NwYW5JZFwiOiBTdHJpbmcocmFuZG9tSW50KVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4geyBmb3JtYXRMb2csIHRpbWVyTWVzc2FnZSwgZ2V0TG9nRm9ybWF0OiAoKSA9PiBTVFJVQ1RVUkVEIH07XG59O1xuXG4vLyBzcmMvRmxvb2RDb250cm9sLnRzXG5pbXBvcnQgdXRpbDIgZnJvbSBcInV0aWxcIjtcbnZhciBoYXNoID0gKG1lc3NhZ2UsIGRhdGEpID0+IHtcbiAgY29uc3QgZGF0YVN0cmluZyA9IGRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB1dGlsMi5pbnNwZWN0KGl0ZW0pO1xuICAgIH1cbiAgfSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGAke21lc3NhZ2V9JHtkYXRhU3RyaW5nfWA7XG59O1xudmFyIEZsb29kQ29udHJvbCA9IGNsYXNzIHtcbiAgY29uZmlnO1xuICBoaXN0b3J5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3VwcHJlc3NlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNsZWFudXBUaW1lciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuY2xlYW51cCgpLCB0aGlzLmNvbmZpZy50aW1lZnJhbWUgKiAyKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChjb25zdCBbaGFzaDIsIHRpbWVzdGFtcHNdIG9mIHRoaXMuaGlzdG9yeS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHJlY2VudFRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmZpbHRlcihcbiAgICAgICAgKHRpbWVzdGFtcCkgPT4gbm93IC0gdGltZXN0YW1wIDwgdGhpcy5jb25maWcudGltZWZyYW1lXG4gICAgICApO1xuICAgICAgaWYgKHJlY2VudFRpbWVzdGFtcHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmhpc3Rvcnkuc2V0KGhhc2gyLCByZWNlbnRUaW1lc3RhbXBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5kZWxldGUoaGFzaDIpO1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuZGVsZXRlKGhhc2gyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2sobWVzc2FnZSwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIFwibG9nXCI7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSAodGhpcy5oaXN0b3J5LmdldChtZXNzYWdlSGFzaCkgfHwgW10pLmZpbHRlcihcbiAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICk7XG4gICAgdGltZXN0YW1wcy5wdXNoKG5vdyk7XG4gICAgdGhpcy5oaXN0b3J5LnNldChtZXNzYWdlSGFzaCwgdGltZXN0YW1wcyk7XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID4gdGhpcy5jb25maWcudGhyZXNob2xkKSB7XG4gICAgICBjb25zdCBzdXBwcmVzc2VkSW5mbyA9IHRoaXMuc3VwcHJlc3NlZC5nZXQobWVzc2FnZUhhc2gpO1xuICAgICAgaWYgKHN1cHByZXNzZWRJbmZvKSB7XG4gICAgICAgIHN1cHByZXNzZWRJbmZvLmNvdW50Kys7XG4gICAgICAgIHJldHVybiBcInN1cHByZXNzXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuc2V0KG1lc3NhZ2VIYXNoLCB7IGNvdW50OiAxLCBmaXJzdFRpbWVzdGFtcDogdGltZXN0YW1wc1swXSwgc3VtbWFyeUxvZ2dlZDogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiBcInN1cHByZXNzXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnN1cHByZXNzZWQuaGFzKG1lc3NhZ2VIYXNoKSkge1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuZGVsZXRlKG1lc3NhZ2VIYXNoKTtcbiAgICAgICAgcmV0dXJuIFwicmVzdW1lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcImxvZ1wiO1xuICB9XG4gIGdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSB7XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBoYXNoKG1lc3NhZ2UsIGRhdGEpO1xuICAgIHJldHVybiB0aGlzLnN1cHByZXNzZWQuZ2V0KG1lc3NhZ2VIYXNoKT8uY291bnQgfHwgMDtcbiAgfVxufTtcblxuLy8gc3JjL0xvZ2dlci50c1xudmFyIGNyZWF0ZUxvZ2dlciA9IChsb2dGb3JtYXQsIGxvZ0xldmVsLCBjb29yZGluYXRlcywgZmxvb2RDb250cm9sQ29uZmlnLCB3cml0ZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihsb2dGb3JtYXQpO1xuICBjb25zdCBmbG9vZENvbnRyb2wgPSBmbG9vZENvbnRyb2xDb25maWcuZW5hYmxlZCA/IG5ldyBGbG9vZENvbnRyb2woZmxvb2RDb250cm9sQ29uZmlnKSA6IG51bGw7XG4gIGNvbnN0IGxvZ0Z1bmN0aW9uID0gY29uc29sZS5sb2c7XG4gIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlcihmb3JtYXR0ZXIsIGxvZ0Z1bmN0aW9uLCB3cml0ZXJPcHRpb25zKTtcbiAgY29uc3Qgd3JpdGUgPSAobGV2ZWwsIG1lc3NhZ2UsIGRhdGEpID0+IHtcbiAgICBpZiAobG9nTGV2ZWwudmFsdWUgPCBsZXZlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGVjayA9IGZsb29kQ29udHJvbCA/IGZsb29kQ29udHJvbC5jaGVjayhtZXNzYWdlLCBkYXRhKSA6IFwibG9nXCI7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgbWVzc2FnZSwgZGF0YSB9O1xuICAgIHN3aXRjaCAoY2hlY2spIHtcbiAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN1cHByZXNzXCI6XG4gICAgICAgIGlmIChmbG9vZENvbnRyb2wgJiYgZmxvb2RDb250cm9sLmdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICBjb25zdCBuZXdQYXlsb2FkID0geyBtZXNzYWdlOiBgU3RhcnRlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZWAsIGRhdGE6IFtdIH07XG4gICAgICAgICAgd3JpdGVyLndyaXRlKG9yaWdpbmFsTGV2ZWwsIGNvb3JkaW5hdGVzLCBuZXdQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZXN1bWVcIjoge1xuICAgICAgICBjb25zdCBjb3VudCA9IGZsb29kQ29udHJvbCA/IGZsb29kQ29udHJvbC5nZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkgOiAwO1xuICAgICAgICBjb25zdCByZXN1bWVQYXlsb2FkID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IGBTdG9wcGVkIHN1cHByZXNzaW5nIHJlcGVhdGVkIGxvZyBtZXNzYWdlLiBTdXBwcmVzc2VkICR7Y291bnR9IHRpbWVzLmAsXG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcmVzdW1lUGF5bG9hZCk7XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXJ0VGltZUxvZ2dlciA9IChsb2dMZXZlbDIsIGNvb3JkaW5hdGVzMiwgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHRpbWVyTWVzc2FnZSA9IGZvcm1hdHRlci50aW1lck1lc3NhZ2UobG9nTGV2ZWwyLCBjb29yZGluYXRlczIsIHBheWxvYWQpO1xuICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWUodGltZXJNZXNzYWdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWVFbmQodGltZXJNZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgICBsb2c6ICguLi5kYXRhKSA9PiB7XG4gICAgICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWVMb2codGltZXJNZXNzYWdlLCAuLi5kYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGVtZXJnZW5jeTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEVNRVJHRU5DWSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBhbGVydDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEFMRVJULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGNyaXRpY2FsOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoQ1JJVElDQUwsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShFUlJPUiwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB3YXJuaW5nOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoV0FSTklORywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBub3RpY2U6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShOT1RJQ0UsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgaW5mbzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKElORk8sIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShERUJVRywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0cmFjZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKFRSQUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlZmF1bHQ6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShERUZBVUxULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHRpbWU6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG4gICAgICByZXR1cm4gc3RhcnRUaW1lTG9nZ2VyKGxvZ0xldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgfSxcbiAgICBnZXQ6ICguLi5hZGRpdGlvbmFsQ29tcG9uZW50cykgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihsb2dGb3JtYXQsIGxvZ0xldmVsLCB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogWy4uLmNvb3JkaW5hdGVzLmNvbXBvbmVudHMsIC4uLmFkZGl0aW9uYWxDb21wb25lbnRzXVxuICAgICAgfSwgZmxvb2RDb250cm9sQ29uZmlnLCB3cml0ZXJPcHRpb25zKTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgIGlmIChmbG9vZENvbnRyb2wpIHtcbiAgICAgICAgZmxvb2RDb250cm9sLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbG9nZ2luZy50c1xudmFyIGdldExvZ2dlciA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ3VyZUxvZ2dpbmcoKTtcbiAgY29uc3QgbG9nZ2VyID0gY3JlYXRlQmFzZUxvZ2dlcihuYW1lLCBjb25maWcpO1xuICByZXR1cm4gbG9nZ2VyO1xufTtcbnZhciBjcmVhdGVCYXNlTG9nZ2VyID0gKG5hbWUsIGNvbmZpZykgPT4ge1xuICBsZXQgeyBsb2dMZXZlbCB9ID0gY29uZmlnO1xuICBjb25zdCB7IGxvZ0Zvcm1hdCwgZmxvb2RDb250cm9sIH0gPSBjb25maWc7XG4gIGNvbnN0IG92ZXJyaWRlcyA9IGNvbmZpZy5vdmVycmlkZXM7XG4gIGlmIChvdmVycmlkZXMgJiYgb3ZlcnJpZGVzW25hbWVdKSB7XG4gICAgbG9nTGV2ZWwgPSBvdmVycmlkZXNbbmFtZV0ubG9nTGV2ZWw7XG4gIH1cbiAgY29uc3QgY29vcmRpbmF0ZXMgPSB7IGNhdGVnb3J5OiBuYW1lLCBjb21wb25lbnRzOiBbXSB9O1xuICByZXR1cm4gY3JlYXRlTG9nZ2VyKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBmbG9vZENvbnRyb2wpO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IHsgZ2V0TG9nZ2VyIH07XG5leHBvcnQge1xuICBMb2dGb3JtYXRfZXhwb3J0cyBhcyBMb2dGb3JtYXQsXG4gIExvZ0xldmVsX2V4cG9ydHMgYXMgTG9nTGV2ZWwsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZ2V0TG9nZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/@fjell/registry/dist/index.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/@fjell/registry/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-cache/node_modules/@fjell/logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = (kta, scopes = []) => {\n  const ktArray = Array.isArray(kta) ? kta : [kta];\n  const toString = () => {\n    logger.debug(\"toString\", { kta, scopes });\n    return `${ktArray.join(\", \")} - ${scopes.join(\", \")}`;\n  };\n  logger.debug(\"createCoordinate\", { kta: ktArray, scopes, toString });\n  return { kta: ktArray, scopes, toString };\n};\n\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate) => {\n  logger2.debug(\"createInstance\", { coordinate, registry });\n  return { coordinate, registry };\n};\nvar isInstance = (instance) => {\n  return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n\n// src/RegistryStats.ts\nvar RegistryStats = class {\n  totalCalls = 0;\n  // Map structure: ktaKey -> scopeKey -> clientKey -> count\n  coordinateCalls = /* @__PURE__ */ new Map();\n  /**\n   * Records a get() call for the specified coordinate and client\n   */\n  recordGetCall(kta, scopes, client) {\n    this.totalCalls++;\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    if (!this.coordinateCalls.has(ktaKey)) {\n      this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n    }\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap.has(scopeKey)) {\n      scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n    }\n    const clientMap = scopeMap.get(scopeKey);\n    const currentCount = clientMap.get(clientKey) || 0;\n    clientMap.set(clientKey, currentCount + 1);\n  }\n  /**\n   * Gets the current statistics snapshot\n   */\n  getStatistics() {\n    const coordinateCallRecords = [];\n    let serviceCalls = 0;\n    let applicationCalls = 0;\n    let unidentifiedCalls = 0;\n    for (const [ktaKey, scopeMap] of this.coordinateCalls) {\n      for (const [scopeKey, clientMap] of scopeMap) {\n        const clientCalls = [];\n        let totalCount = 0;\n        for (const [clientKey, count] of clientMap) {\n          const client = this.parseClientKey(clientKey);\n          if (client !== null) {\n            clientCalls.push({ client, count });\n          }\n          totalCount += count;\n          if (clientKey === \"__no_client__\") {\n            unidentifiedCalls += count;\n          } else if (typeof client === \"string\") {\n            applicationCalls += count;\n          } else if (client !== null) {\n            serviceCalls += count;\n          }\n        }\n        coordinateCallRecords.push({\n          kta: ktaKey.split(\".\"),\n          scopes: this.parseScopeKey(scopeKey),\n          count: totalCount,\n          clientCalls: [...clientCalls]\n          // Return a copy\n        });\n      }\n    }\n    return {\n      totalGetCalls: this.totalCalls,\n      coordinateCallRecords: [...coordinateCallRecords],\n      // Return a copy\n      clientSummary: {\n        serviceCalls,\n        applicationCalls,\n        unidentifiedCalls\n      }\n    };\n  }\n  /**\n   * Gets call count for a specific coordinate combination\n   */\n  getCallCount(kta, scopes) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    let total = 0;\n    for (const count of clientMap.values()) {\n      total += count;\n    }\n    return total;\n  }\n  /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */\n  getCallCountByClient(kta, scopes, client) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    return clientMap.get(clientKey) || 0;\n  }\n  /**\n   * Gets total calls for a specific kta (across all scopes)\n   */\n  getTotalCallsForKta(kta) {\n    const ktaKey = kta.join(\".\");\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    let total = 0;\n    for (const clientMap of scopeMap.values()) {\n      for (const count of clientMap.values()) {\n        total += count;\n      }\n    }\n    return total;\n  }\n  /**\n   * Gets all unique kta paths that have been called\n   */\n  getCalledKtaPaths() {\n    const ktaPaths = [];\n    for (const ktaKey of this.coordinateCalls.keys()) {\n      ktaPaths.push(ktaKey.split(\".\"));\n    }\n    return ktaPaths;\n  }\n  /**\n   * Creates a normalized scope key from scopes array\n   */\n  createScopeKey(scopes) {\n    if (scopes.length === 0) return \"__no_scopes__\";\n    return [...scopes].sort().join(\",\");\n  }\n  /**\n   * Parses a scope key back to scopes array\n   */\n  parseScopeKey(scopeKey) {\n    if (scopeKey === \"__no_scopes__\") return [];\n    return scopeKey.split(\",\");\n  }\n  /**\n   * Creates a normalized client key from client identifier\n   */\n  createClientKey(client) {\n    if (!client) return \"__no_client__\";\n    if (typeof client === \"string\") {\n      return `app:${client}`;\n    }\n    const coordKey = `${client.coordinate.kta.join(\".\")};${this.createScopeKey(client.coordinate.scopes)}`;\n    return `service:${client.registryType}:${coordKey}`;\n  }\n  /**\n   * Parses a client key back to client identifier\n   */\n  parseClientKey(clientKey) {\n    if (clientKey === \"__no_client__\") return null;\n    if (clientKey.startsWith(\"app:\")) {\n      return clientKey.substring(4);\n    }\n    if (clientKey.startsWith(\"service:\")) {\n      const parts = clientKey.substring(8).split(\":\");\n      if (parts.length !== 2) return null;\n      const registryType = parts[0];\n      const coordParts = parts[1].split(\";\");\n      if (coordParts.length !== 2) return null;\n      const kta = coordParts[0].split(\".\");\n      const scopes = this.parseScopeKey(coordParts[1]);\n      return {\n        registryType,\n        coordinate: { kta, scopes }\n      };\n    }\n    return null;\n  }\n};\n\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes) => {\n  if (!requestedScopes || requestedScopes.length === 0) {\n    const firstInstance = scopedInstances[0]?.instance;\n    if (!firstInstance) {\n      throw new Error(\"No instances available\");\n    }\n    return firstInstance;\n  }\n  const matchingInstance = scopedInstances.find((scopedInstance) => {\n    if (!scopedInstance.scopes) return false;\n    return requestedScopes.every(\n      (scope) => scopedInstance.scopes && scopedInstance.scopes.includes(scope)\n    );\n  });\n  if (!matchingInstance) {\n    throw new Error(`No instance found matching scopes: ${requestedScopes.join(\", \")}`);\n  }\n  return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub) => {\n  const instanceTree = {};\n  const registryStats = new RegistryStats();\n  const createProxiedRegistry = (callingCoordinate) => {\n    const serviceClient = {\n      registryType: type,\n      coordinate: {\n        kta: callingCoordinate.kta,\n        scopes: callingCoordinate.scopes\n      }\n    };\n    return {\n      ...registry,\n      get: (kta, options) => {\n        const clientToUse = options?.client || serviceClient;\n        return registry.get(kta, { ...options, client: clientToUse });\n      }\n    };\n  };\n  const createInstance2 = (kta, scopes, factory) => {\n    logger3.debug(`Creating and registering instance for key path and scopes`, kta, scopes, `in registry type: ${type}`);\n    const coordinate = createCoordinate(kta, scopes);\n    const proxiedRegistry = createProxiedRegistry(coordinate);\n    const instance = factory(coordinate, {\n      registry: proxiedRegistry,\n      registryHub\n    });\n    if (!isInstance(instance)) {\n      throw new Error(`Factory did not return a valid instance for: ${kta.join(\".\")}`);\n    }\n    registerInternal(kta, instance, { scopes });\n    return instance;\n  };\n  const registerInternal = (kta, instance, options) => {\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    logger3.debug(`Registering instance for key path and scopes`, keyPath, options?.scopes, `in registry type: ${type}`);\n    if (!isInstance(instance)) {\n      throw new Error(`Attempting to register a non-instance: ${kta.join(\".\")}`);\n    }\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        currentLevel[keyType] = {\n          instances: [],\n          children: isLeaf ? null : {}\n        };\n      }\n      if (isLeaf) {\n        currentLevel[keyType].instances.push({\n          scopes: options?.scopes,\n          instance\n        });\n      } else {\n        if (!currentLevel[keyType].children) {\n          currentLevel[keyType].children = {};\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n  };\n  const register = (kta, instance, options) => {\n    logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n    registerInternal(kta, instance, options);\n  };\n  const get = (kta, options) => {\n    registryStats.recordGetCall(kta, options?.scopes, options?.client);\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        throw new Error(`Instance not found for key path: ${kta.join(\".\")}, Missing key: ${keyType}`);\n      }\n      if (isLeaf) {\n        const scopedInstances = currentLevel[keyType].instances;\n        if (scopedInstances.length === 0) {\n          throw new Error(`No instances registered for key path: ${kta.join(\".\")}`);\n        }\n        return findScopedInstance(scopedInstances, options?.scopes);\n      } else {\n        if (!currentLevel[keyType].children) {\n          throw new Error(`Instance not found for key path: ${kta.join(\".\")}, No children for: ${keyType}`);\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n    return null;\n  };\n  const getCoordinates = () => {\n    const coordinates = [];\n    const traverseTree = (node) => {\n      for (const keyType in node) {\n        const treeNode = node[keyType];\n        for (const scopedInstance of treeNode.instances) {\n          coordinates.push(scopedInstance.instance.coordinate);\n        }\n        if (treeNode.children) {\n          traverseTree(treeNode.children);\n        }\n      }\n    };\n    traverseTree(instanceTree);\n    return coordinates;\n  };\n  const getStatistics = () => {\n    return registryStats.getStatistics();\n  };\n  const registry = {\n    type,\n    registryHub,\n    createInstance: createInstance2,\n    register,\n    get,\n    getCoordinates,\n    getStatistics,\n    instanceTree\n  };\n  return registry;\n};\n\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n  registryType;\n  context;\n  constructor(message, registryType, context) {\n    super(message);\n    this.name = this.constructor.name;\n    this.registryType = registryType;\n    this.context = context;\n    const ErrorConstructor = Error;\n    if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n      ErrorConstructor.captureStackTrace(this, this.constructor);\n    }\n  }\n  getDetails() {\n    const details = [this.message];\n    if (this.registryType) {\n      details.push(`Registry Type: ${this.registryType}`);\n    }\n    if (this.context) {\n      details.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n    }\n    return details.join(\"\\n\");\n  }\n};\nvar RegistryCreationError = class extends RegistryError {\n  constructor(type, reason, context) {\n    super(`Failed to create registry of type '${type}': ${reason}`, type, context);\n  }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n  keyPath;\n  factoryResult;\n  constructor(keyPath, factoryResult, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Factory did not return a valid instance for: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof factoryResult}`,\n      registryType,\n      { keyPath, factoryResult: typeof factoryResult }\n    );\n    this.keyPath = keyPath;\n    this.factoryResult = factoryResult;\n  }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n  keyPath;\n  attemptedRegistration;\n  constructor(keyPath, attemptedRegistration, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Attempting to register a non-instance: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof attemptedRegistration}`,\n      registryType,\n      { keyPath, attemptedRegistration: typeof attemptedRegistration }\n    );\n    this.keyPath = keyPath;\n    this.attemptedRegistration = attemptedRegistration;\n  }\n};\n\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n  hubType;\n  constructor(message, hubType, context) {\n    const enrichedContext = hubType ? { ...context, hubType } : context;\n    super(message, \"\", enrichedContext);\n    this.hubType = hubType;\n  }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n  duplicateType;\n  constructor(type, context) {\n    super(\n      `Registry already registered under type: ${type}. Each registry type must be unique within a registry hub.`,\n      \"\",\n      { ...context, duplicateType: type }\n    );\n    this.duplicateType = type;\n  }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n  requestedType;\n  availableTypes;\n  constructor(requestedType, availableTypes = [], context) {\n    let message = `No registry registered under type: ${requestedType}`;\n    if (availableTypes.length > 0) {\n      message += `. Available types: [${availableTypes.join(\", \")}]`;\n    }\n    super(message, \"\", { ...context, requestedType, availableTypes });\n    this.requestedType = requestedType;\n    this.availableTypes = availableTypes;\n  }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n  factoryError;\n  attemptedType;\n  constructor(type, factoryError, context) {\n    super(\n      `Registry factory failed to create registry of type '${type}': ${factoryError.message}`,\n      \"\",\n      { ...context, attemptedType: type, originalError: factoryError.message }\n    );\n    this.factoryError = factoryError;\n    this.attemptedType = type;\n  }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n  factoryResult;\n  attemptedType;\n  constructor(type, factoryResult, context) {\n    super(\n      `Registry factory returned invalid registry for type '${type}'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: ${typeof factoryResult}`,\n      \"\",\n      { ...context, attemptedType: type, factoryResult: typeof factoryResult }\n    );\n    this.factoryResult = factoryResult;\n    this.attemptedType = type;\n  }\n};\n\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = () => {\n  const registries = {};\n  const createRegistry2 = (type, factory) => {\n    logger4.debug(`Creating new registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    const registry = factory(type, hub);\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    registries[type] = registry;\n    logger4.debug(`Successfully created and registered new registry with type: ${type}`);\n    return registry;\n  };\n  const registerRegistry = (registry) => {\n    const type = registry.type;\n    logger4.debug(`Registering registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    registries[type] = registry;\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    logger4.debug(`Successfully registered registry with type: ${type}`);\n  };\n  const get = (type, kta, options) => {\n    logger4.debug(`Looking up instance for type: ${type}, kta: ${kta.join(\".\")}, scopes: ${options?.scopes?.join(\",\") || \"none\"}`);\n    const registry = registries[type];\n    if (!registry) {\n      const availableTypes = Object.keys(registries);\n      throw new RegistryTypeNotFoundError(type, availableTypes);\n    }\n    return registry.get(kta, options);\n  };\n  const getRegistry = (type) => {\n    return registries[type] || null;\n  };\n  const getRegisteredTypes = () => {\n    return Object.keys(registries);\n  };\n  const unregisterRegistry = (type) => {\n    if (registries[type]) {\n      delete registries[type];\n      logger4.debug(`Unregistered registry under type: ${type}`);\n      return true;\n    }\n    return false;\n  };\n  const getAllCoordinates = () => {\n    const allCoordinates = [];\n    for (const registryType in registries) {\n      const registry = registries[registryType];\n      const coordinates = registry.getCoordinates();\n      coordinates.forEach((coordinate) => {\n        allCoordinates.push({\n          coordinate,\n          registryType\n        });\n      });\n    }\n    logger4.debug(`Retrieved ${allCoordinates.length} total coordinates from ${Object.keys(registries).length} registries`);\n    return allCoordinates;\n  };\n  const hub = {\n    createRegistry: createRegistry2,\n    registerRegistry,\n    get,\n    getRegistry,\n    getRegisteredTypes,\n    getAllCoordinates,\n    unregisterRegistry\n  };\n  return hub;\n};\n\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n  keyPath;\n  constructor(message, keyPath, registryType, context) {\n    super(message, registryType, { ...context, keyPath });\n    this.keyPath = keyPath;\n  }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n  missingKey;\n  constructor(keyPath, missingKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    let message = `Instance not found for key path: ${keyPathStr}`;\n    if (missingKey) {\n      message += `, Missing key: ${missingKey}`;\n    }\n    super(message, keyPath, registryType, { ...context, missingKey });\n    this.missingKey = missingKey;\n  }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances registered for key path: ${keyPathStr}. The key path exists in the registry tree but contains no instances.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances available for key path: ${keyPathStr}. This typically indicates an internal registry state issue.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n  requestedScopes;\n  availableScopes;\n  constructor(keyPath, requestedScopes, availableScopes = [], registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    const scopesStr = requestedScopes.join(\", \");\n    const availableScopesStr = availableScopes.map((scopes) => `[${scopes.join(\", \")}]`).join(\", \");\n    let message = `No instance found matching scopes: ${scopesStr} for key path: ${keyPathStr}`;\n    if (availableScopes.length > 0) {\n      message += `. Available scopes: ${availableScopesStr}`;\n    }\n    super(message, keyPath, registryType, { requestedScopes, availableScopes });\n    this.requestedScopes = requestedScopes;\n    this.availableScopes = availableScopes;\n  }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n  parentKey;\n  constructor(keyPath, parentKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Instance not found for key path: ${keyPathStr}, No children for: ${parentKey}. The path cannot be traversed further as '${parentKey}' has no child nodes.`,\n      keyPath,\n      registryType,\n      { ...context, parentKey }\n    );\n    this.parentKey = parentKey;\n  }\n};\n\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n  kta;\n  scopes;\n  constructor(message, kta, scopes, context) {\n    super(message, \"\", { ...context, kta, scopes });\n    this.kta = kta;\n    this.scopes = scopes;\n  }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n  constructor(kta, scopes, reason, context) {\n    super(\n      `Invalid coordinate parameters: ${reason}. KTA: ${JSON.stringify(kta)}, Scopes: [${scopes.join(\", \")}]`,\n      kta,\n      scopes,\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidKTAError = class extends CoordinateError {\n  constructor(kta, reason, context) {\n    super(\n      `Invalid KTA (Key Type Array): ${reason}. Expected string or array of strings, got: ${JSON.stringify(kta)}`,\n      kta,\n      [],\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidScopesError = class extends CoordinateError {\n  invalidScopes;\n  constructor(scopes, invalidScopes, reason, context) {\n    super(\n      `Invalid scopes: ${reason}. Invalid scope values: ${JSON.stringify(invalidScopes)}`,\n      null,\n      scopes.filter((s) => typeof s === \"string\"),\n      { ...context, reason, invalidScopes }\n    );\n    this.invalidScopes = invalidScopes;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvQGZqZWxsL3JlZ2lzdHJ5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNxQztBQUNyQyxnQkFBZ0IsZ0VBQWlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QyxjQUFjLG9CQUFvQixJQUFJLGtCQUFrQjtBQUN4RDtBQUNBLHFDQUFxQyxnQ0FBZ0M7QUFDckUsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBMkJFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL0BmamVsbC9yZWdpc3RyeS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9sb2dnZXIudHNcbmltcG9ydCBMb2dnaW5nIGZyb20gXCJAZmplbGwvbG9nZ2luZ1wiO1xudmFyIExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKFwiQGZqZWxsL3JlZ2lzdHJ5XCIpO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTGliTG9nZ2VyO1xuXG4vLyBzcmMvQ29vcmRpbmF0ZS50c1xudmFyIGxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkNvb3JkaW5hdGVcIik7XG52YXIgY3JlYXRlQ29vcmRpbmF0ZSA9IChrdGEsIHNjb3BlcyA9IFtdKSA9PiB7XG4gIGNvbnN0IGt0QXJyYXkgPSBBcnJheS5pc0FycmF5KGt0YSkgPyBrdGEgOiBba3RhXTtcbiAgY29uc3QgdG9TdHJpbmcgPSAoKSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKFwidG9TdHJpbmdcIiwgeyBrdGEsIHNjb3BlcyB9KTtcbiAgICByZXR1cm4gYCR7a3RBcnJheS5qb2luKFwiLCBcIil9IC0gJHtzY29wZXMuam9pbihcIiwgXCIpfWA7XG4gIH07XG4gIGxvZ2dlci5kZWJ1ZyhcImNyZWF0ZUNvb3JkaW5hdGVcIiwgeyBrdGE6IGt0QXJyYXksIHNjb3BlcywgdG9TdHJpbmcgfSk7XG4gIHJldHVybiB7IGt0YToga3RBcnJheSwgc2NvcGVzLCB0b1N0cmluZyB9O1xufTtcblxuLy8gc3JjL0luc3RhbmNlLnRzXG52YXIgbG9nZ2VyMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkluc3RhbmNlXCIpO1xudmFyIGNyZWF0ZUluc3RhbmNlID0gKHJlZ2lzdHJ5LCBjb29yZGluYXRlKSA9PiB7XG4gIGxvZ2dlcjIuZGVidWcoXCJjcmVhdGVJbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5IH0pO1xuICByZXR1cm4geyBjb29yZGluYXRlLCByZWdpc3RyeSB9O1xufTtcbnZhciBpc0luc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIHJldHVybiBpbnN0YW5jZSAhPT0gbnVsbCAmJiBpbnN0YW5jZSAhPT0gdm9pZCAwICYmIGluc3RhbmNlLmNvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBpbnN0YW5jZS5yZWdpc3RyeSAhPT0gdm9pZCAwO1xufTtcblxuLy8gc3JjL1JlZ2lzdHJ5U3RhdHMudHNcbnZhciBSZWdpc3RyeVN0YXRzID0gY2xhc3Mge1xuICB0b3RhbENhbGxzID0gMDtcbiAgLy8gTWFwIHN0cnVjdHVyZToga3RhS2V5IC0+IHNjb3BlS2V5IC0+IGNsaWVudEtleSAtPiBjb3VudFxuICBjb29yZGluYXRlQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogUmVjb3JkcyBhIGdldCgpIGNhbGwgZm9yIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBhbmQgY2xpZW50XG4gICAqL1xuICByZWNvcmRHZXRDYWxsKGt0YSwgc2NvcGVzLCBjbGllbnQpIHtcbiAgICB0aGlzLnRvdGFsQ2FsbHMrKztcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG4gICAgY29uc3QgY2xpZW50S2V5ID0gdGhpcy5jcmVhdGVDbGllbnRLZXkoY2xpZW50KTtcbiAgICBpZiAoIXRoaXMuY29vcmRpbmF0ZUNhbGxzLmhhcyhrdGFLZXkpKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVDYWxscy5zZXQoa3RhS2V5LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwLmhhcyhzY29wZUtleSkpIHtcbiAgICAgIHNjb3BlTWFwLnNldChzY29wZUtleSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgY29uc3QgY3VycmVudENvdW50ID0gY2xpZW50TWFwLmdldChjbGllbnRLZXkpIHx8IDA7XG4gICAgY2xpZW50TWFwLnNldChjbGllbnRLZXksIGN1cnJlbnRDb3VudCArIDEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRpc3RpY3Mgc25hcHNob3RcbiAgICovXG4gIGdldFN0YXRpc3RpY3MoKSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZUNhbGxSZWNvcmRzID0gW107XG4gICAgbGV0IHNlcnZpY2VDYWxscyA9IDA7XG4gICAgbGV0IGFwcGxpY2F0aW9uQ2FsbHMgPSAwO1xuICAgIGxldCB1bmlkZW50aWZpZWRDYWxscyA9IDA7XG4gICAgZm9yIChjb25zdCBba3RhS2V5LCBzY29wZU1hcF0gb2YgdGhpcy5jb29yZGluYXRlQ2FsbHMpIHtcbiAgICAgIGZvciAoY29uc3QgW3Njb3BlS2V5LCBjbGllbnRNYXBdIG9mIHNjb3BlTWFwKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudENhbGxzID0gW107XG4gICAgICAgIGxldCB0b3RhbENvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBbY2xpZW50S2V5LCBjb3VudF0gb2YgY2xpZW50TWFwKSB7XG4gICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5wYXJzZUNsaWVudEtleShjbGllbnRLZXkpO1xuICAgICAgICAgIGlmIChjbGllbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsaWVudENhbGxzLnB1c2goeyBjbGllbnQsIGNvdW50IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbENvdW50ICs9IGNvdW50O1xuICAgICAgICAgIGlmIChjbGllbnRLZXkgPT09IFwiX19ub19jbGllbnRfX1wiKSB7XG4gICAgICAgICAgICB1bmlkZW50aWZpZWRDYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjbGllbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZpY2VDYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRpbmF0ZUNhbGxSZWNvcmRzLnB1c2goe1xuICAgICAgICAgIGt0YToga3RhS2V5LnNwbGl0KFwiLlwiKSxcbiAgICAgICAgICBzY29wZXM6IHRoaXMucGFyc2VTY29wZUtleShzY29wZUtleSksXG4gICAgICAgICAgY291bnQ6IHRvdGFsQ291bnQsXG4gICAgICAgICAgY2xpZW50Q2FsbHM6IFsuLi5jbGllbnRDYWxsc11cbiAgICAgICAgICAvLyBSZXR1cm4gYSBjb3B5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxHZXRDYWxsczogdGhpcy50b3RhbENhbGxzLFxuICAgICAgY29vcmRpbmF0ZUNhbGxSZWNvcmRzOiBbLi4uY29vcmRpbmF0ZUNhbGxSZWNvcmRzXSxcbiAgICAgIC8vIFJldHVybiBhIGNvcHlcbiAgICAgIGNsaWVudFN1bW1hcnk6IHtcbiAgICAgICAgc2VydmljZUNhbGxzLFxuICAgICAgICBhcHBsaWNhdGlvbkNhbGxzLFxuICAgICAgICB1bmlkZW50aWZpZWRDYWxsc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgY2FsbCBjb3VudCBmb3IgYSBzcGVjaWZpYyBjb29yZGluYXRlIGNvbWJpbmF0aW9uXG4gICAqL1xuICBnZXRDYWxsQ291bnQoa3RhLCBzY29wZXMpIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcbiAgICBjb25zdCBjbGllbnRNYXAgPSBzY29wZU1hcC5nZXQoc2NvcGVLZXkpO1xuICAgIGlmICghY2xpZW50TWFwKSByZXR1cm4gMDtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgY291bnQgb2YgY2xpZW50TWFwLnZhbHVlcygpKSB7XG4gICAgICB0b3RhbCArPSBjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGNhbGwgY291bnQgZm9yIGEgc3BlY2lmaWMgY29vcmRpbmF0ZSBjb21iaW5hdGlvbiBmcm9tIGEgc3BlY2lmaWMgY2xpZW50XG4gICAqL1xuICBnZXRDYWxsQ291bnRCeUNsaWVudChrdGEsIHNjb3BlcywgY2xpZW50KSB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IGNsaWVudEtleSA9IHRoaXMuY3JlYXRlQ2xpZW50S2V5KGNsaWVudCk7XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcbiAgICBjb25zdCBjbGllbnRNYXAgPSBzY29wZU1hcC5nZXQoc2NvcGVLZXkpO1xuICAgIGlmICghY2xpZW50TWFwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gY2xpZW50TWFwLmdldChjbGllbnRLZXkpIHx8IDA7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdG90YWwgY2FsbHMgZm9yIGEgc3BlY2lmaWMga3RhIChhY3Jvc3MgYWxsIHNjb3BlcylcbiAgICovXG4gIGdldFRvdGFsQ2FsbHNGb3JLdGEoa3RhKSB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcCkgcmV0dXJuIDA7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IGNsaWVudE1hcCBvZiBzY29wZU1hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjb3VudCBvZiBjbGllbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgdG90YWwgKz0gY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbGwgdW5pcXVlIGt0YSBwYXRocyB0aGF0IGhhdmUgYmVlbiBjYWxsZWRcbiAgICovXG4gIGdldENhbGxlZEt0YVBhdGhzKCkge1xuICAgIGNvbnN0IGt0YVBhdGhzID0gW107XG4gICAgZm9yIChjb25zdCBrdGFLZXkgb2YgdGhpcy5jb29yZGluYXRlQ2FsbHMua2V5cygpKSB7XG4gICAgICBrdGFQYXRocy5wdXNoKGt0YUtleS5zcGxpdChcIi5cIikpO1xuICAgIH1cbiAgICByZXR1cm4ga3RhUGF0aHM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBub3JtYWxpemVkIHNjb3BlIGtleSBmcm9tIHNjb3BlcyBhcnJheVxuICAgKi9cbiAgY3JlYXRlU2NvcGVLZXkoc2NvcGVzKSB7XG4gICAgaWYgKHNjb3Blcy5sZW5ndGggPT09IDApIHJldHVybiBcIl9fbm9fc2NvcGVzX19cIjtcbiAgICByZXR1cm4gWy4uLnNjb3Blc10uc29ydCgpLmpvaW4oXCIsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBzY29wZSBrZXkgYmFjayB0byBzY29wZXMgYXJyYXlcbiAgICovXG4gIHBhcnNlU2NvcGVLZXkoc2NvcGVLZXkpIHtcbiAgICBpZiAoc2NvcGVLZXkgPT09IFwiX19ub19zY29wZXNfX1wiKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHNjb3BlS2V5LnNwbGl0KFwiLFwiKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5vcm1hbGl6ZWQgY2xpZW50IGtleSBmcm9tIGNsaWVudCBpZGVudGlmaWVyXG4gICAqL1xuICBjcmVhdGVDbGllbnRLZXkoY2xpZW50KSB7XG4gICAgaWYgKCFjbGllbnQpIHJldHVybiBcIl9fbm9fY2xpZW50X19cIjtcbiAgICBpZiAodHlwZW9mIGNsaWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGBhcHA6JHtjbGllbnR9YDtcbiAgICB9XG4gICAgY29uc3QgY29vcmRLZXkgPSBgJHtjbGllbnQuY29vcmRpbmF0ZS5rdGEuam9pbihcIi5cIil9OyR7dGhpcy5jcmVhdGVTY29wZUtleShjbGllbnQuY29vcmRpbmF0ZS5zY29wZXMpfWA7XG4gICAgcmV0dXJuIGBzZXJ2aWNlOiR7Y2xpZW50LnJlZ2lzdHJ5VHlwZX06JHtjb29yZEtleX1gO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBjbGllbnQga2V5IGJhY2sgdG8gY2xpZW50IGlkZW50aWZpZXJcbiAgICovXG4gIHBhcnNlQ2xpZW50S2V5KGNsaWVudEtleSkge1xuICAgIGlmIChjbGllbnRLZXkgPT09IFwiX19ub19jbGllbnRfX1wiKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoY2xpZW50S2V5LnN0YXJ0c1dpdGgoXCJhcHA6XCIpKSB7XG4gICAgICByZXR1cm4gY2xpZW50S2V5LnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgaWYgKGNsaWVudEtleS5zdGFydHNXaXRoKFwic2VydmljZTpcIikpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gY2xpZW50S2V5LnN1YnN0cmluZyg4KS5zcGxpdChcIjpcIik7XG4gICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5VHlwZSA9IHBhcnRzWzBdO1xuICAgICAgY29uc3QgY29vcmRQYXJ0cyA9IHBhcnRzWzFdLnNwbGl0KFwiO1wiKTtcbiAgICAgIGlmIChjb29yZFBhcnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBrdGEgPSBjb29yZFBhcnRzWzBdLnNwbGl0KFwiLlwiKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMucGFyc2VTY29wZUtleShjb29yZFBhcnRzWzFdKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgICAgY29vcmRpbmF0ZTogeyBrdGEsIHNjb3BlcyB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gc3JjL1JlZ2lzdHJ5LnRzXG52YXIgbG9nZ2VyMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIlJlZ2lzdHJ5XCIpO1xudmFyIGZpbmRTY29wZWRJbnN0YW5jZSA9IChzY29wZWRJbnN0YW5jZXMsIHJlcXVlc3RlZFNjb3BlcykgPT4ge1xuICBpZiAoIXJlcXVlc3RlZFNjb3BlcyB8fCByZXF1ZXN0ZWRTY29wZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgZmlyc3RJbnN0YW5jZSA9IHNjb3BlZEluc3RhbmNlc1swXT8uaW5zdGFuY2U7XG4gICAgaWYgKCFmaXJzdEluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBpbnN0YW5jZXMgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RJbnN0YW5jZTtcbiAgfVxuICBjb25zdCBtYXRjaGluZ0luc3RhbmNlID0gc2NvcGVkSW5zdGFuY2VzLmZpbmQoKHNjb3BlZEluc3RhbmNlKSA9PiB7XG4gICAgaWYgKCFzY29wZWRJbnN0YW5jZS5zY29wZXMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVxdWVzdGVkU2NvcGVzLmV2ZXJ5KFxuICAgICAgKHNjb3BlKSA9PiBzY29wZWRJbnN0YW5jZS5zY29wZXMgJiYgc2NvcGVkSW5zdGFuY2Uuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKVxuICAgICk7XG4gIH0pO1xuICBpZiAoIW1hdGNoaW5nSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluc3RhbmNlIGZvdW5kIG1hdGNoaW5nIHNjb3BlczogJHtyZXF1ZXN0ZWRTY29wZXMuam9pbihcIiwgXCIpfWApO1xuICB9XG4gIHJldHVybiBtYXRjaGluZ0luc3RhbmNlLmluc3RhbmNlO1xufTtcbnZhciBjcmVhdGVSZWdpc3RyeSA9ICh0eXBlLCByZWdpc3RyeUh1YikgPT4ge1xuICBjb25zdCBpbnN0YW5jZVRyZWUgPSB7fTtcbiAgY29uc3QgcmVnaXN0cnlTdGF0cyA9IG5ldyBSZWdpc3RyeVN0YXRzKCk7XG4gIGNvbnN0IGNyZWF0ZVByb3hpZWRSZWdpc3RyeSA9IChjYWxsaW5nQ29vcmRpbmF0ZSkgPT4ge1xuICAgIGNvbnN0IHNlcnZpY2VDbGllbnQgPSB7XG4gICAgICByZWdpc3RyeVR5cGU6IHR5cGUsXG4gICAgICBjb29yZGluYXRlOiB7XG4gICAgICAgIGt0YTogY2FsbGluZ0Nvb3JkaW5hdGUua3RhLFxuICAgICAgICBzY29wZXM6IGNhbGxpbmdDb29yZGluYXRlLnNjb3Blc1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlZ2lzdHJ5LFxuICAgICAgZ2V0OiAoa3RhLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudFRvVXNlID0gb3B0aW9ucz8uY2xpZW50IHx8IHNlcnZpY2VDbGllbnQ7XG4gICAgICAgIHJldHVybiByZWdpc3RyeS5nZXQoa3RhLCB7IC4uLm9wdGlvbnMsIGNsaWVudDogY2xpZW50VG9Vc2UgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlSW5zdGFuY2UyID0gKGt0YSwgc2NvcGVzLCBmYWN0b3J5KSA9PiB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhgQ3JlYXRpbmcgYW5kIHJlZ2lzdGVyaW5nIGluc3RhbmNlIGZvciBrZXkgcGF0aCBhbmQgc2NvcGVzYCwga3RhLCBzY29wZXMsIGBpbiByZWdpc3RyeSB0eXBlOiAke3R5cGV9YCk7XG4gICAgY29uc3QgY29vcmRpbmF0ZSA9IGNyZWF0ZUNvb3JkaW5hdGUoa3RhLCBzY29wZXMpO1xuICAgIGNvbnN0IHByb3hpZWRSZWdpc3RyeSA9IGNyZWF0ZVByb3hpZWRSZWdpc3RyeShjb29yZGluYXRlKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZhY3RvcnkoY29vcmRpbmF0ZSwge1xuICAgICAgcmVnaXN0cnk6IHByb3hpZWRSZWdpc3RyeSxcbiAgICAgIHJlZ2lzdHJ5SHViXG4gICAgfSk7XG4gICAgaWYgKCFpc0luc3RhbmNlKGluc3RhbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWN0b3J5IGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2UgZm9yOiAke2t0YS5qb2luKFwiLlwiKX1gKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJJbnRlcm5hbChrdGEsIGluc3RhbmNlLCB7IHNjb3BlcyB9KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG4gIGNvbnN0IHJlZ2lzdGVySW50ZXJuYWwgPSAoa3RhLCBpbnN0YW5jZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGtleVBhdGggPSBbLi4ua3RhXS5yZXZlcnNlKCk7XG4gICAgbGV0IGN1cnJlbnRMZXZlbCA9IGluc3RhbmNlVHJlZTtcbiAgICBsb2dnZXIzLmRlYnVnKGBSZWdpc3RlcmluZyBpbnN0YW5jZSBmb3Iga2V5IHBhdGggYW5kIHNjb3Blc2AsIGtleVBhdGgsIG9wdGlvbnM/LnNjb3BlcywgYGluIHJlZ2lzdHJ5IHR5cGU6ICR7dHlwZX1gKTtcbiAgICBpZiAoIWlzSW5zdGFuY2UoaW5zdGFuY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBub24taW5zdGFuY2U6ICR7a3RhLmpvaW4oXCIuXCIpfWApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleVBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleVR5cGUgPSBrZXlQYXRoW2ldO1xuICAgICAgY29uc3QgaXNMZWFmID0gaSA9PT0ga2V5UGF0aC5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0pIHtcbiAgICAgICAgY3VycmVudExldmVsW2tleVR5cGVdID0ge1xuICAgICAgICAgIGluc3RhbmNlczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IGlzTGVhZiA/IG51bGwgOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0uaW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgIHNjb3Blczogb3B0aW9ucz8uc2NvcGVzLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZWdpc3RlciA9IChrdGEsIGluc3RhbmNlLCBvcHRpb25zKSA9PiB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIlVzaW5nIGRlcHJlY2F0ZWQgcmVnaXN0ZXIgbWV0aG9kLiBDb25zaWRlciB1c2luZyBjcmVhdGVJbnN0YW5jZSBpbnN0ZWFkLlwiKTtcbiAgICByZWdpc3RlckludGVybmFsKGt0YSwgaW5zdGFuY2UsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBnZXQgPSAoa3RhLCBvcHRpb25zKSA9PiB7XG4gICAgcmVnaXN0cnlTdGF0cy5yZWNvcmRHZXRDYWxsKGt0YSwgb3B0aW9ucz8uc2NvcGVzLCBvcHRpb25zPy5jbGllbnQpO1xuICAgIGNvbnN0IGtleVBhdGggPSBbLi4ua3RhXS5yZXZlcnNlKCk7XG4gICAgbGV0IGN1cnJlbnRMZXZlbCA9IGluc3RhbmNlVHJlZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleVBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleVR5cGUgPSBrZXlQYXRoW2ldO1xuICAgICAgY29uc3QgaXNMZWFmID0gaSA9PT0ga2V5UGF0aC5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKFwiLlwiKX0sIE1pc3Npbmcga2V5OiAke2tleVR5cGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZEluc3RhbmNlcyA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5pbnN0YW5jZXM7XG4gICAgICAgIGlmIChzY29wZWRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnN0YW5jZXMgcmVnaXN0ZXJlZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oXCIuXCIpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kU2NvcGVkSW5zdGFuY2Uoc2NvcGVkSW5zdGFuY2VzLCBvcHRpb25zPy5zY29wZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oXCIuXCIpfSwgTm8gY2hpbGRyZW4gZm9yOiAke2tleVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgZ2V0Q29vcmRpbmF0ZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICBjb25zdCB0cmF2ZXJzZVRyZWUgPSAobm9kZSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXlUeXBlIGluIG5vZGUpIHtcbiAgICAgICAgY29uc3QgdHJlZU5vZGUgPSBub2RlW2tleVR5cGVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlZEluc3RhbmNlIG9mIHRyZWVOb2RlLmluc3RhbmNlcykge1xuICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goc2NvcGVkSW5zdGFuY2UuaW5zdGFuY2UuY29vcmRpbmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdHJhdmVyc2VUcmVlKHRyZWVOb2RlLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdHJhdmVyc2VUcmVlKGluc3RhbmNlVHJlZSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9O1xuICBjb25zdCBnZXRTdGF0aXN0aWNzID0gKCkgPT4ge1xuICAgIHJldHVybiByZWdpc3RyeVN0YXRzLmdldFN0YXRpc3RpY3MoKTtcbiAgfTtcbiAgY29uc3QgcmVnaXN0cnkgPSB7XG4gICAgdHlwZSxcbiAgICByZWdpc3RyeUh1YixcbiAgICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlSW5zdGFuY2UyLFxuICAgIHJlZ2lzdGVyLFxuICAgIGdldCxcbiAgICBnZXRDb29yZGluYXRlcyxcbiAgICBnZXRTdGF0aXN0aWNzLFxuICAgIGluc3RhbmNlVHJlZVxuICB9O1xuICByZXR1cm4gcmVnaXN0cnk7XG59O1xuXG4vLyBzcmMvZXJyb3JzL1JlZ2lzdHJ5RXJyb3IudHNcbnZhciBSZWdpc3RyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIHJlZ2lzdHJ5VHlwZTtcbiAgY29udGV4dDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMucmVnaXN0cnlUeXBlID0gcmVnaXN0cnlUeXBlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29uc3QgRXJyb3JDb25zdHJ1Y3RvciA9IEVycm9yO1xuICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3Rvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBFcnJvckNvbnN0cnVjdG9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgfVxuICBnZXREZXRhaWxzKCkge1xuICAgIGNvbnN0IGRldGFpbHMgPSBbdGhpcy5tZXNzYWdlXTtcbiAgICBpZiAodGhpcy5yZWdpc3RyeVR5cGUpIHtcbiAgICAgIGRldGFpbHMucHVzaChgUmVnaXN0cnkgVHlwZTogJHt0aGlzLnJlZ2lzdHJ5VHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgZGV0YWlscy5wdXNoKGBDb250ZXh0OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY29udGV4dCwgbnVsbCwgMil9YCk7XG4gICAgfVxuICAgIHJldHVybiBkZXRhaWxzLmpvaW4oXCJcXG5cIik7XG4gIH1cbn07XG52YXIgUmVnaXN0cnlDcmVhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAgY29uc3RydWN0b3IodHlwZSwgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoYEZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cnkgb2YgdHlwZSAnJHt0eXBlfSc6ICR7cmVhc29ufWAsIHR5cGUsIGNvbnRleHQpO1xuICB9XG59O1xudmFyIEludmFsaWRGYWN0b3J5UmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrZXlQYXRoO1xuICBmYWN0b3J5UmVzdWx0O1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBmYWN0b3J5UmVzdWx0LCByZWdpc3RyeVR5cGUpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBGYWN0b3J5IGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2UgZm9yOiAke2tleVBhdGhTdHJ9LiBFeHBlY3RlZCBpbnN0YW5jZSB3aXRoICdjb29yZGluYXRlJyBhbmQgJ3JlZ2lzdHJ5JyBwcm9wZXJ0aWVzLCBnb3Q6ICR7dHlwZW9mIGZhY3RvcnlSZXN1bHR9YCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsga2V5UGF0aCwgZmFjdG9yeVJlc3VsdDogdHlwZW9mIGZhY3RvcnlSZXN1bHQgfVxuICAgICk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICB0aGlzLmZhY3RvcnlSZXN1bHQgPSBmYWN0b3J5UmVzdWx0O1xuICB9XG59O1xudmFyIEludmFsaWRJbnN0YW5jZVJlZ2lzdHJhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga2V5UGF0aDtcbiAgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uO1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBhdHRlbXB0ZWRSZWdpc3RyYXRpb24sIHJlZ2lzdHJ5VHlwZSkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBub24taW5zdGFuY2U6ICR7a2V5UGF0aFN0cn0uIEV4cGVjdGVkIGluc3RhbmNlIHdpdGggJ2Nvb3JkaW5hdGUnIGFuZCAncmVnaXN0cnknIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgYXR0ZW1wdGVkUmVnaXN0cmF0aW9ufWAsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IGtleVBhdGgsIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjogdHlwZW9mIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbiB9XG4gICAgKTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaXN0cmF0aW9uID0gYXR0ZW1wdGVkUmVnaXN0cmF0aW9uO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL1JlZ2lzdHJ5SHViRXJyb3IudHNcbnZhciBSZWdpc3RyeUh1YkVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAgaHViVHlwZTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaHViVHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGVucmljaGVkQ29udGV4dCA9IGh1YlR5cGUgPyB7IC4uLmNvbnRleHQsIGh1YlR5cGUgfSA6IGNvbnRleHQ7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJcIiwgZW5yaWNoZWRDb250ZXh0KTtcbiAgICB0aGlzLmh1YlR5cGUgPSBodWJUeXBlO1xuICB9XG59O1xudmFyIER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgZHVwbGljYXRlVHlwZTtcbiAgY29uc3RydWN0b3IodHlwZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGFscmVhZHkgcmVnaXN0ZXJlZCB1bmRlciB0eXBlOiAke3R5cGV9LiBFYWNoIHJlZ2lzdHJ5IHR5cGUgbXVzdCBiZSB1bmlxdWUgd2l0aGluIGEgcmVnaXN0cnkgaHViLmAsXG4gICAgICBcIlwiLFxuICAgICAgeyAuLi5jb250ZXh0LCBkdXBsaWNhdGVUeXBlOiB0eXBlIH1cbiAgICApO1xuICAgIHRoaXMuZHVwbGljYXRlVHlwZSA9IHR5cGU7XG4gIH1cbn07XG52YXIgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIHJlcXVlc3RlZFR5cGU7XG4gIGF2YWlsYWJsZVR5cGVzO1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0ZWRUeXBlLCBhdmFpbGFibGVUeXBlcyA9IFtdLCBjb250ZXh0KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgTm8gcmVnaXN0cnkgcmVnaXN0ZXJlZCB1bmRlciB0eXBlOiAke3JlcXVlc3RlZFR5cGV9YDtcbiAgICBpZiAoYXZhaWxhYmxlVHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZSArPSBgLiBBdmFpbGFibGUgdHlwZXM6IFske2F2YWlsYWJsZVR5cGVzLmpvaW4oXCIsIFwiKX1dYDtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSwgXCJcIiwgeyAuLi5jb250ZXh0LCByZXF1ZXN0ZWRUeXBlLCBhdmFpbGFibGVUeXBlcyB9KTtcbiAgICB0aGlzLnJlcXVlc3RlZFR5cGUgPSByZXF1ZXN0ZWRUeXBlO1xuICAgIHRoaXMuYXZhaWxhYmxlVHlwZXMgPSBhdmFpbGFibGVUeXBlcztcbiAgfVxufTtcbnZhciBSZWdpc3RyeUZhY3RvcnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIGZhY3RvcnlFcnJvcjtcbiAgYXR0ZW1wdGVkVHlwZTtcbiAgY29uc3RydWN0b3IodHlwZSwgZmFjdG9yeUVycm9yLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVnaXN0cnkgZmFjdG9yeSBmYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJ5IG9mIHR5cGUgJyR7dHlwZX0nOiAke2ZhY3RvcnlFcnJvci5tZXNzYWdlfWAsXG4gICAgICBcIlwiLFxuICAgICAgeyAuLi5jb250ZXh0LCBhdHRlbXB0ZWRUeXBlOiB0eXBlLCBvcmlnaW5hbEVycm9yOiBmYWN0b3J5RXJyb3IubWVzc2FnZSB9XG4gICAgKTtcbiAgICB0aGlzLmZhY3RvcnlFcnJvciA9IGZhY3RvcnlFcnJvcjtcbiAgICB0aGlzLmF0dGVtcHRlZFR5cGUgPSB0eXBlO1xuICB9XG59O1xudmFyIEludmFsaWRSZWdpc3RyeUZhY3RvcnlSZXN1bHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIGZhY3RvcnlSZXN1bHQ7XG4gIGF0dGVtcHRlZFR5cGU7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGZhY3RvcnlSZXN1bHQsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBmYWN0b3J5IHJldHVybmVkIGludmFsaWQgcmVnaXN0cnkgZm9yIHR5cGUgJyR7dHlwZX0nLiBFeHBlY3RlZCByZWdpc3RyeSB3aXRoICd0eXBlJywgJ2dldCcsICdyZWdpc3RlcicsIGFuZCAnY3JlYXRlSW5zdGFuY2UnIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgZmFjdG9yeVJlc3VsdH1gLFxuICAgICAgXCJcIixcbiAgICAgIHsgLi4uY29udGV4dCwgYXR0ZW1wdGVkVHlwZTogdHlwZSwgZmFjdG9yeVJlc3VsdDogdHlwZW9mIGZhY3RvcnlSZXN1bHQgfVxuICAgICk7XG4gICAgdGhpcy5mYWN0b3J5UmVzdWx0ID0gZmFjdG9yeVJlc3VsdDtcbiAgICB0aGlzLmF0dGVtcHRlZFR5cGUgPSB0eXBlO1xuICB9XG59O1xuXG4vLyBzcmMvUmVnaXN0cnlIdWIudHNcbnZhciBsb2dnZXI0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiUmVnaXN0cnlIdWJcIik7XG52YXIgY3JlYXRlUmVnaXN0cnlIdWIgPSAoKSA9PiB7XG4gIGNvbnN0IHJlZ2lzdHJpZXMgPSB7fTtcbiAgY29uc3QgY3JlYXRlUmVnaXN0cnkyID0gKHR5cGUsIGZhY3RvcnkpID0+IHtcbiAgICBsb2dnZXI0LmRlYnVnKGBDcmVhdGluZyBuZXcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gICAgaWYgKHJlZ2lzdHJpZXNbdHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG4gICAgY29uc3QgcmVnaXN0cnkgPSBmYWN0b3J5KHR5cGUsIGh1Yik7XG4gICAgaWYgKCEoXCJyZWdpc3RyeUh1YlwiIGluIHJlZ2lzdHJ5KSB8fCByZWdpc3RyeS5yZWdpc3RyeUh1YiAhPT0gaHViKSB7XG4gICAgICByZWdpc3RyeS5yZWdpc3RyeUh1YiA9IGh1YjtcbiAgICB9XG4gICAgcmVnaXN0cmllc1t0eXBlXSA9IHJlZ2lzdHJ5O1xuICAgIGxvZ2dlcjQuZGVidWcoYFN1Y2Nlc3NmdWxseSBjcmVhdGVkIGFuZCByZWdpc3RlcmVkIG5ldyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH07XG4gIGNvbnN0IHJlZ2lzdGVyUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcbiAgICBjb25zdCB0eXBlID0gcmVnaXN0cnkudHlwZTtcbiAgICBsb2dnZXI0LmRlYnVnKGBSZWdpc3RlcmluZyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yKHR5cGUpO1xuICAgIH1cbiAgICByZWdpc3RyaWVzW3R5cGVdID0gcmVnaXN0cnk7XG4gICAgaWYgKCEoXCJyZWdpc3RyeUh1YlwiIGluIHJlZ2lzdHJ5KSB8fCByZWdpc3RyeS5yZWdpc3RyeUh1YiAhPT0gaHViKSB7XG4gICAgICByZWdpc3RyeS5yZWdpc3RyeUh1YiA9IGh1YjtcbiAgICB9XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gIH07XG4gIGNvbnN0IGdldCA9ICh0eXBlLCBrdGEsIG9wdGlvbnMpID0+IHtcbiAgICBsb2dnZXI0LmRlYnVnKGBMb29raW5nIHVwIGluc3RhbmNlIGZvciB0eXBlOiAke3R5cGV9LCBrdGE6ICR7a3RhLmpvaW4oXCIuXCIpfSwgc2NvcGVzOiAke29wdGlvbnM/LnNjb3Blcz8uam9pbihcIixcIikgfHwgXCJub25lXCJ9YCk7XG4gICAgY29uc3QgcmVnaXN0cnkgPSByZWdpc3RyaWVzW3R5cGVdO1xuICAgIGlmICghcmVnaXN0cnkpIHtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVR5cGVzID0gT2JqZWN0LmtleXMocmVnaXN0cmllcyk7XG4gICAgICB0aHJvdyBuZXcgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvcih0eXBlLCBhdmFpbGFibGVUeXBlcyk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3RyeS5nZXQoa3RhLCBvcHRpb25zKTtcbiAgfTtcbiAgY29uc3QgZ2V0UmVnaXN0cnkgPSAodHlwZSkgPT4ge1xuICAgIHJldHVybiByZWdpc3RyaWVzW3R5cGVdIHx8IG51bGw7XG4gIH07XG4gIGNvbnN0IGdldFJlZ2lzdGVyZWRUeXBlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cmllcyk7XG4gIH07XG4gIGNvbnN0IHVucmVnaXN0ZXJSZWdpc3RyeSA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHJlZ2lzdHJpZXNbdHlwZV0pIHtcbiAgICAgIGRlbGV0ZSByZWdpc3RyaWVzW3R5cGVdO1xuICAgICAgbG9nZ2VyNC5kZWJ1ZyhgVW5yZWdpc3RlcmVkIHJlZ2lzdHJ5IHVuZGVyIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGdldEFsbENvb3JkaW5hdGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGFsbENvb3JkaW5hdGVzID0gW107XG4gICAgZm9yIChjb25zdCByZWdpc3RyeVR5cGUgaW4gcmVnaXN0cmllcykge1xuICAgICAgY29uc3QgcmVnaXN0cnkgPSByZWdpc3RyaWVzW3JlZ2lzdHJ5VHlwZV07XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IHJlZ2lzdHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBjb29yZGluYXRlcy5mb3JFYWNoKChjb29yZGluYXRlKSA9PiB7XG4gICAgICAgIGFsbENvb3JkaW5hdGVzLnB1c2goe1xuICAgICAgICAgIGNvb3JkaW5hdGUsXG4gICAgICAgICAgcmVnaXN0cnlUeXBlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxvZ2dlcjQuZGVidWcoYFJldHJpZXZlZCAke2FsbENvb3JkaW5hdGVzLmxlbmd0aH0gdG90YWwgY29vcmRpbmF0ZXMgZnJvbSAke09iamVjdC5rZXlzKHJlZ2lzdHJpZXMpLmxlbmd0aH0gcmVnaXN0cmllc2ApO1xuICAgIHJldHVybiBhbGxDb29yZGluYXRlcztcbiAgfTtcbiAgY29uc3QgaHViID0ge1xuICAgIGNyZWF0ZVJlZ2lzdHJ5OiBjcmVhdGVSZWdpc3RyeTIsXG4gICAgcmVnaXN0ZXJSZWdpc3RyeSxcbiAgICBnZXQsXG4gICAgZ2V0UmVnaXN0cnksXG4gICAgZ2V0UmVnaXN0ZXJlZFR5cGVzLFxuICAgIGdldEFsbENvb3JkaW5hdGVzLFxuICAgIHVucmVnaXN0ZXJSZWdpc3RyeVxuICB9O1xuICByZXR1cm4gaHViO1xufTtcblxuLy8gc3JjL2Vycm9ycy9JbnN0YW5jZUVycm9yLnRzXG52YXIgSW5zdGFuY2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGtleVBhdGg7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHJlZ2lzdHJ5VHlwZSwgeyAuLi5jb250ZXh0LCBrZXlQYXRoIH0pO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gIH1cbn07XG52YXIgSW5zdGFuY2VOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgbWlzc2luZ0tleTtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgbWlzc2luZ0tleSwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgbGV0IG1lc3NhZ2UgPSBgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfWA7XG4gICAgaWYgKG1pc3NpbmdLZXkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCwgTWlzc2luZyBrZXk6ICR7bWlzc2luZ0tleX1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBrZXlQYXRoLCByZWdpc3RyeVR5cGUsIHsgLi4uY29udGV4dCwgbWlzc2luZ0tleSB9KTtcbiAgICB0aGlzLm1pc3NpbmdLZXkgPSBtaXNzaW5nS2V5O1xuICB9XG59O1xudmFyIE5vSW5zdGFuY2VzUmVnaXN0ZXJlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgTm8gaW5zdGFuY2VzIHJlZ2lzdGVyZWQgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9LiBUaGUga2V5IHBhdGggZXhpc3RzIGluIHRoZSByZWdpc3RyeSB0cmVlIGJ1dCBjb250YWlucyBubyBpbnN0YW5jZXMuYCxcbiAgICAgIGtleVBhdGgsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxufTtcbnZhciBOb0luc3RhbmNlc0F2YWlsYWJsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgTm8gaW5zdGFuY2VzIGF2YWlsYWJsZSBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0uIFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyBhbiBpbnRlcm5hbCByZWdpc3RyeSBzdGF0ZSBpc3N1ZS5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG59O1xudmFyIFNjb3BlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIHJlcXVlc3RlZFNjb3BlcztcbiAgYXZhaWxhYmxlU2NvcGVzO1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCByZXF1ZXN0ZWRTY29wZXMsIGF2YWlsYWJsZVNjb3BlcyA9IFtdLCByZWdpc3RyeVR5cGUpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZXNTdHIgPSByZXF1ZXN0ZWRTY29wZXMuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVNjb3Blc1N0ciA9IGF2YWlsYWJsZVNjb3Blcy5tYXAoKHNjb3BlcykgPT4gYFske3Njb3Blcy5qb2luKFwiLCBcIil9XWApLmpvaW4oXCIsIFwiKTtcbiAgICBsZXQgbWVzc2FnZSA9IGBObyBpbnN0YW5jZSBmb3VuZCBtYXRjaGluZyBzY29wZXM6ICR7c2NvcGVzU3RyfSBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn1gO1xuICAgIGlmIChhdmFpbGFibGVTY29wZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZSArPSBgLiBBdmFpbGFibGUgc2NvcGVzOiAke2F2YWlsYWJsZVNjb3Blc1N0cn1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBrZXlQYXRoLCByZWdpc3RyeVR5cGUsIHsgcmVxdWVzdGVkU2NvcGVzLCBhdmFpbGFibGVTY29wZXMgfSk7XG4gICAgdGhpcy5yZXF1ZXN0ZWRTY29wZXMgPSByZXF1ZXN0ZWRTY29wZXM7XG4gICAgdGhpcy5hdmFpbGFibGVTY29wZXMgPSBhdmFpbGFibGVTY29wZXM7XG4gIH1cbn07XG52YXIgTm9DaGlsZHJlbkF2YWlsYWJsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgcGFyZW50S2V5O1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBwYXJlbnRLZXksIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0sIE5vIGNoaWxkcmVuIGZvcjogJHtwYXJlbnRLZXl9LiBUaGUgcGF0aCBjYW5ub3QgYmUgdHJhdmVyc2VkIGZ1cnRoZXIgYXMgJyR7cGFyZW50S2V5fScgaGFzIG5vIGNoaWxkIG5vZGVzLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyAuLi5jb250ZXh0LCBwYXJlbnRLZXkgfVxuICAgICk7XG4gICAgdGhpcy5wYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvQ29vcmRpbmF0ZUVycm9yLnRzXG52YXIgQ29vcmRpbmF0ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga3RhO1xuICBzY29wZXM7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGt0YSwgc2NvcGVzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJcIiwgeyAuLi5jb250ZXh0LCBrdGEsIHNjb3BlcyB9KTtcbiAgICB0aGlzLmt0YSA9IGt0YTtcbiAgICB0aGlzLnNjb3BlcyA9IHNjb3BlcztcbiAgfVxufTtcbnZhciBJbnZhbGlkQ29vcmRpbmF0ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrdGEsIHNjb3BlcywgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBjb29yZGluYXRlIHBhcmFtZXRlcnM6ICR7cmVhc29ufS4gS1RBOiAke0pTT04uc3RyaW5naWZ5KGt0YSl9LCBTY29wZXM6IFske3Njb3Blcy5qb2luKFwiLCBcIil9XWAsXG4gICAgICBrdGEsXG4gICAgICBzY29wZXMsXG4gICAgICB7IC4uLmNvbnRleHQsIHJlYXNvbiB9XG4gICAgKTtcbiAgfVxufTtcbnZhciBJbnZhbGlkS1RBRXJyb3IgPSBjbGFzcyBleHRlbmRzIENvb3JkaW5hdGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGt0YSwgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBLVEEgKEtleSBUeXBlIEFycmF5KTogJHtyZWFzb259LiBFeHBlY3RlZCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncywgZ290OiAke0pTT04uc3RyaW5naWZ5KGt0YSl9YCxcbiAgICAgIGt0YSxcbiAgICAgIFtdLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24gfVxuICAgICk7XG4gIH1cbn07XG52YXIgSW52YWxpZFNjb3Blc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBpbnZhbGlkU2NvcGVzO1xuICBjb25zdHJ1Y3RvcihzY29wZXMsIGludmFsaWRTY29wZXMsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgc2NvcGVzOiAke3JlYXNvbn0uIEludmFsaWQgc2NvcGUgdmFsdWVzOiAke0pTT04uc3RyaW5naWZ5KGludmFsaWRTY29wZXMpfWAsXG4gICAgICBudWxsLFxuICAgICAgc2NvcGVzLmZpbHRlcigocykgPT4gdHlwZW9mIHMgPT09IFwic3RyaW5nXCIpLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24sIGludmFsaWRTY29wZXMgfVxuICAgICk7XG4gICAgdGhpcy5pbnZhbGlkU2NvcGVzID0gaW52YWxpZFNjb3BlcztcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENvb3JkaW5hdGVFcnJvcixcbiAgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IsXG4gIEluc3RhbmNlRXJyb3IsXG4gIEluc3RhbmNlTm90Rm91bmRFcnJvcixcbiAgSW52YWxpZENvb3JkaW5hdGVFcnJvcixcbiAgSW52YWxpZEZhY3RvcnlSZXN1bHRFcnJvcixcbiAgSW52YWxpZEluc3RhbmNlUmVnaXN0cmF0aW9uRXJyb3IsXG4gIEludmFsaWRLVEFFcnJvcixcbiAgSW52YWxpZFJlZ2lzdHJ5RmFjdG9yeVJlc3VsdEVycm9yLFxuICBJbnZhbGlkU2NvcGVzRXJyb3IsXG4gIE5vQ2hpbGRyZW5BdmFpbGFibGVFcnJvcixcbiAgTm9JbnN0YW5jZXNBdmFpbGFibGVFcnJvcixcbiAgTm9JbnN0YW5jZXNSZWdpc3RlcmVkRXJyb3IsXG4gIFJlZ2lzdHJ5Q3JlYXRpb25FcnJvcixcbiAgUmVnaXN0cnlFcnJvcixcbiAgUmVnaXN0cnlGYWN0b3J5RXJyb3IsXG4gIFJlZ2lzdHJ5SHViRXJyb3IsXG4gIFJlZ2lzdHJ5U3RhdHMsXG4gIFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IsXG4gIFNjb3BlTm90Rm91bmRFcnJvcixcbiAgY3JlYXRlQ29vcmRpbmF0ZSxcbiAgY3JlYXRlSW5zdGFuY2UsXG4gIGNyZWF0ZVJlZ2lzdHJ5LFxuICBjcmVhdGVSZWdpc3RyeUh1YixcbiAgaXNJbnN0YW5jZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/@fjell/registry/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/deepmerge/dist/cjs.js":
/*!*********************************************************!*\
  !*** ../fjell-cache/node_modules/deepmerge/dist/cjs.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/deepmerge/dist/cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/fast-safe-stringify/index.js":
/*!****************************************************************!*\
  !*** ../fjell-cache/node_modules/fast-safe-stringify/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcblxudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSdcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSAnW0NpcmN1bGFyXSdcblxudmFyIGFyciA9IFtdXG52YXIgcmVwbGFjZXJTdGFjayA9IFtdXG5cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIGRlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKVxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzZXRSZXBsYWNlIChyZXBsYWNlLCB2YWwsIGssIHBhcmVudCkge1xuICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspXG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudCwgaywgeyB2YWx1ZTogcmVwbGFjZSB9KVxuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2VcbiAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY2lyYyAodmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDFcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpXG4gIH1cblxuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmpcbiAgdmFyIHJlc1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJylcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHBhcmVudFtrXSA9IHRtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcFxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyAocmVwbGFjZXIpIHtcbiAgcmVwbGFjZXIgPVxuICAgIHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gcmVwbGFjZXJcbiAgICAgIDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV1cbiAgICAgICAgaWYgKHBhcnRbMV0gPT09IGtleSAmJiBwYXJ0WzBdID09PSB2YWwpIHtcbiAgICAgICAgICB2YWwgPSBwYXJ0WzJdXG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/fast-safe-stringify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js":
/*!*********************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/datetime.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DateTime),\n/* harmony export */   friendlyDateTime: () => (/* binding */ friendlyDateTime)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/info.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_diff_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./impl/diff.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/diff.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./impl/tokenParser.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/tokenParser.js\");\n/* harmony import */ var _impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./impl/conversions.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/conversions.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/invalid.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid DateTime\";\nconst MAX_DATE = 8.64e15;\n\nfunction unsupportedZone(zone) {\n  return new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unsupported zone\", `the zone \"${zone.name}\" is not supported`);\n}\n\n// we cache week data on the DT object and this intermediates the cache\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedWeekData(dt) {\n  if (dt.weekData === null) {\n    dt.weekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(dt.c);\n  }\n  return dt.weekData;\n}\n\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedLocalWeekData(dt) {\n  if (dt.localWeekData === null) {\n    dt.localWeekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(\n      dt.c,\n      dt.loc.getMinDaysInFirstWeek(),\n      dt.loc.getStartOfWeek()\n    );\n  }\n  return dt.localWeekData;\n}\n\n// clone really means, \"make a new object with these modifications\". all \"setters\" really use this\n// to create a new object while only changing some of the properties\nfunction clone(inst, alts) {\n  const current = {\n    ts: inst.ts,\n    zone: inst.zone,\n    c: inst.c,\n    o: inst.o,\n    loc: inst.loc,\n    invalid: inst.invalid,\n  };\n  return new DateTime({ ...current, ...alts, old: current });\n}\n\n// find the right offset a given local time. The o input is our guess, which determines which\n// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)\nfunction fixOffset(localTS, o, tz) {\n  // Our UTC time is just a guess because our offset is just a guess\n  let utcGuess = localTS - o * 60 * 1000;\n\n  // Test whether the zone matches the offset for this ts\n  const o2 = tz.offset(utcGuess);\n\n  // If so, offset didn't change and we're done\n  if (o === o2) {\n    return [utcGuess, o];\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= (o2 - o) * 60 * 1000;\n\n  // If that gives us the local time we want, we're done\n  const o3 = tz.offset(utcGuess);\n  if (o2 === o3) {\n    return [utcGuess, o2];\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];\n}\n\n// convert an epoch timestamp into a calendar object with the given offset\nfunction tsToObj(ts, offset) {\n  ts += offset * 60 * 1000;\n\n  const d = new Date(ts);\n\n  return {\n    year: d.getUTCFullYear(),\n    month: d.getUTCMonth() + 1,\n    day: d.getUTCDate(),\n    hour: d.getUTCHours(),\n    minute: d.getUTCMinutes(),\n    second: d.getUTCSeconds(),\n    millisecond: d.getUTCMilliseconds(),\n  };\n}\n\n// convert a calendar object to a epoch timestamp\nfunction objToTS(obj, offset, zone) {\n  return fixOffset((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(obj), offset, zone);\n}\n\n// create a new DT instance by adding a duration, adjusting for DSTs\nfunction adjustTime(inst, dur) {\n  const oPre = inst.o,\n    year = inst.c.year + Math.trunc(dur.years),\n    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,\n    c = {\n      ...inst.c,\n      year,\n      month,\n      day:\n        Math.min(inst.c.day, (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(year, month)) +\n        Math.trunc(dur.days) +\n        Math.trunc(dur.weeks) * 7,\n    },\n    millisToAdd = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject({\n      years: dur.years - Math.trunc(dur.years),\n      quarters: dur.quarters - Math.trunc(dur.quarters),\n      months: dur.months - Math.trunc(dur.months),\n      weeks: dur.weeks - Math.trunc(dur.weeks),\n      days: dur.days - Math.trunc(dur.days),\n      hours: dur.hours,\n      minutes: dur.minutes,\n      seconds: dur.seconds,\n      milliseconds: dur.milliseconds,\n    }).as(\"milliseconds\"),\n    localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(c);\n\n  let [ts, o] = fixOffset(localTS, oPre, inst.zone);\n\n  if (millisToAdd !== 0) {\n    ts += millisToAdd;\n    // that could have changed the offset by going over a DST, but we want to keep the ts the same\n    o = inst.zone.offset(ts);\n  }\n\n  return { ts, o };\n}\n\n// helper useful in turning the results of parsing into real dates\n// by handling the zone options\nfunction parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {\n  const { setZone, zone } = opts;\n  if ((parsed && Object.keys(parsed).length !== 0) || parsedZone) {\n    const interpretationZone = parsedZone || zone,\n      inst = DateTime.fromObject(parsed, {\n        ...opts,\n        zone: interpretationZone,\n        specificOffset,\n      });\n    return setZone ? inst : inst.setZone(zone);\n  } else {\n    return DateTime.invalid(\n      new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unparsable\", `the input \"${text}\" can't be parsed as ${format}`)\n    );\n  }\n}\n\n// if you want to output a technical format (e.g. RFC 2822), this helper\n// helps handle the details\nfunction toTechFormat(dt, format, allowZ = true) {\n  return dt.isValid\n    ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(_impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create(\"en-US\"), {\n        allowZ,\n        forceSimple: true,\n      }).formatDateTimeFromString(dt, format)\n    : null;\n}\n\nfunction toISODate(o, extended, precision) {\n  const longFormat = o.c.year > 9999 || o.c.year < 0;\n  let c = \"\";\n  if (longFormat && o.c.year >= 0) c += \"+\";\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.year, longFormat ? 6 : 4);\n  if (precision === \"year\") return c;\n  if (extended) {\n    c += \"-\";\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n    c += \"-\";\n  } else {\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n  }\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.day);\n  return c;\n}\n\nfunction toISOTime(\n  o,\n  extended,\n  suppressSeconds,\n  suppressMilliseconds,\n  includeOffset,\n  extendedZone,\n  precision\n) {\n  let showSeconds = !suppressSeconds || o.c.millisecond !== 0 || o.c.second !== 0,\n    c = \"\";\n  switch (precision) {\n    case \"day\":\n    case \"month\":\n    case \"year\":\n      break;\n    default:\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.hour);\n      if (precision === \"hour\") break;\n      if (extended) {\n        c += \":\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += \":\";\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      } else {\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      }\n      if (precision === \"second\") break;\n      if (showSeconds && (!suppressMilliseconds || o.c.millisecond !== 0)) {\n        c += \".\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.millisecond, 3);\n      }\n  }\n\n  if (includeOffset) {\n    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {\n      c += \"Z\";\n    } else if (o.o < 0) {\n      c += \"-\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o % 60));\n    } else {\n      c += \"+\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o % 60));\n    }\n  }\n\n  if (extendedZone) {\n    c += \"[\" + o.zone.ianaName + \"]\";\n  }\n  return c;\n}\n\n// defaults for unspecified units in the supported calendars\nconst defaultUnitValues = {\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultWeekUnitValues = {\n    weekNumber: 1,\n    weekday: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultOrdinalUnitValues = {\n    ordinal: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  };\n\n// Units in the supported calendars, sorted by bigness\nconst orderedUnits = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"],\n  orderedWeekUnits = [\n    \"weekYear\",\n    \"weekNumber\",\n    \"weekday\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\",\n  ],\n  orderedOrdinalUnits = [\"year\", \"ordinal\", \"hour\", \"minute\", \"second\", \"millisecond\"];\n\n// standardize case and plurality in units\nfunction normalizeUnit(unit) {\n  const normalized = {\n    year: \"year\",\n    years: \"year\",\n    month: \"month\",\n    months: \"month\",\n    day: \"day\",\n    days: \"day\",\n    hour: \"hour\",\n    hours: \"hour\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    second: \"second\",\n    seconds: \"second\",\n    millisecond: \"millisecond\",\n    milliseconds: \"millisecond\",\n    weekday: \"weekday\",\n    weekdays: \"weekday\",\n    weeknumber: \"weekNumber\",\n    weeksnumber: \"weekNumber\",\n    weeknumbers: \"weekNumber\",\n    weekyear: \"weekYear\",\n    weekyears: \"weekYear\",\n    ordinal: \"ordinal\",\n  }[unit.toLowerCase()];\n\n  if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidUnitError(unit);\n\n  return normalized;\n}\n\nfunction normalizeUnitWithLocalWeeks(unit) {\n  switch (unit.toLowerCase()) {\n    case \"localweekday\":\n    case \"localweekdays\":\n      return \"localWeekday\";\n    case \"localweeknumber\":\n    case \"localweeknumbers\":\n      return \"localWeekNumber\";\n    case \"localweekyear\":\n    case \"localweekyears\":\n      return \"localWeekYear\";\n    default:\n      return normalizeUnit(unit);\n  }\n}\n\n// cache offsets for zones based on the current timestamp when this function is\n// first called. When we are handling a datetime from components like (year,\n// month, day, hour) in a time zone, we need a guess about what the timezone\n// offset is so that we can convert into a UTC timestamp. One way is to find the\n// offset of now in the zone. The actual date may have a different offset (for\n// example, if we handle a date in June while we're in December in a zone that\n// observes DST), but we can check and adjust that.\n//\n// When handling many dates, calculating the offset for now every time is\n// expensive. It's just a guess, so we can cache the offset to use even if we\n// are right on a time change boundary (we'll just correct in the other\n// direction). Using a timestamp from first read is a slight optimization for\n// handling dates close to the current date, since those dates will usually be\n// in the same offset (we could set the timestamp statically, instead). We use a\n// single timestamp for all zones to make things a bit more predictable.\n//\n// This is safe for quickDT (used by local() and utc()) because we don't fill in\n// higher-order units from tsNow (as we do in fromObject, this requires that\n// offset is calculated from tsNow).\n/**\n * @param {Zone} zone\n * @return {number}\n */\nfunction guessOffsetForZone(zone) {\n  if (zoneOffsetTs === undefined) {\n    zoneOffsetTs = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  // Do not cache anything but IANA zones, because it is not safe to do so.\n  // Guessing an offset which is not present in the zone can cause wrong results from fixOffset\n  if (zone.type !== \"iana\") {\n    return zone.offset(zoneOffsetTs);\n  }\n  const zoneName = zone.name;\n  let offsetGuess = zoneOffsetGuessCache.get(zoneName);\n  if (offsetGuess === undefined) {\n    offsetGuess = zone.offset(zoneOffsetTs);\n    zoneOffsetGuessCache.set(zoneName, offsetGuess);\n  }\n  return offsetGuess;\n}\n\n// this is a dumbed down version of fromObject() that runs about 60% faster\n// but doesn't do any validation, makes a bunch of assumptions about what units\n// are present, and so on.\nfunction quickDT(obj, opts) {\n  const zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  if (!zone.isValid) {\n    return DateTime.invalid(unsupportedZone(zone));\n  }\n\n  const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n\n  let ts, o;\n\n  // assume we have the higher-order units\n  if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj.year)) {\n    for (const u of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj[u])) {\n        obj[u] = defaultUnitValues[u];\n      }\n    }\n\n    const invalid = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(obj) || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(obj);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    const offsetProvis = guessOffsetForZone(zone);\n    [ts, o] = objToTS(obj, offsetProvis, zone);\n  } else {\n    ts = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  return new DateTime({ ts, zone, loc, o });\n}\n\nfunction diffRelative(start, end, opts) {\n  const round = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.round) ? true : opts.round,\n    rounding = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.rounding) ? \"trunc\" : opts.rounding,\n    format = (c, unit) => {\n      c = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.roundTo)(c, round || opts.calendary ? 0 : 2, opts.calendary ? \"round\" : rounding);\n      const formatter = end.loc.clone(opts).relFormatter(opts);\n      return formatter.format(c, unit);\n    },\n    differ = (unit) => {\n      if (opts.calendary) {\n        if (!end.hasSame(start, unit)) {\n          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);\n        } else return 0;\n      } else {\n        return end.diff(start, unit).get(unit);\n      }\n    };\n\n  if (opts.unit) {\n    return format(differ(opts.unit), opts.unit);\n  }\n\n  for (const unit of opts.units) {\n    const count = differ(unit);\n    if (Math.abs(count) >= 1) {\n      return format(count, unit);\n    }\n  }\n  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);\n}\n\nfunction lastOpts(argList) {\n  let opts = {},\n    args;\n  if (argList.length > 0 && typeof argList[argList.length - 1] === \"object\") {\n    opts = argList[argList.length - 1];\n    args = Array.from(argList).slice(0, argList.length - 1);\n  } else {\n    args = Array.from(argList);\n  }\n  return [opts, args];\n}\n\n/**\n * Timestamp to use for cached zone offset guesses (exposed for test)\n */\nlet zoneOffsetTs;\n/**\n * Cache for zone offset guesses (exposed for test).\n *\n * This optimizes quickDT via guessOffsetForZone to avoid repeated calls of\n * zone.offset().\n */\nconst zoneOffsetGuessCache = new Map();\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},\n * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.\n * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nclass DateTime {\n  /**\n   * @access private\n   */\n  constructor(config) {\n    const zone = config.zone || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone;\n\n    let invalid =\n      config.invalid ||\n      (Number.isNaN(config.ts) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null) ||\n      (!zone.isValid ? unsupportedZone(zone) : null);\n    /**\n     * @access private\n     */\n    this.ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(config.ts) ? _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now() : config.ts;\n\n    let c = null,\n      o = null;\n    if (!invalid) {\n      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);\n\n      if (unchanged) {\n        [c, o] = [config.old.c, config.old.o];\n      } else {\n        // If an offset has been passed and we have not been called from\n        // clone(), we can trust it and avoid the offset calculation.\n        const ot = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(config.o) && !config.old ? config.o : zone.offset(this.ts);\n        c = tsToObj(this.ts, ot);\n        invalid = Number.isNaN(c.year) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null;\n        c = invalid ? null : c;\n        o = invalid ? null : ot;\n      }\n    }\n\n    /**\n     * @access private\n     */\n    this._zone = zone;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.invalid = invalid;\n    /**\n     * @access private\n     */\n    this.weekData = null;\n    /**\n     * @access private\n     */\n    this.localWeekData = null;\n    /**\n     * @access private\n     */\n    this.c = c;\n    /**\n     * @access private\n     */\n    this.o = o;\n    /**\n     * @access private\n     */\n    this.isLuxonDateTime = true;\n  }\n\n  // CONSTRUCT\n\n  /**\n   * Create a DateTime for the current instant, in the system's time zone.\n   *\n   * Use Settings to override these default values if needed.\n   * @example DateTime.now().toISO() //~> now in the ISO format\n   * @return {DateTime}\n   */\n  static now() {\n    return new DateTime({});\n  }\n\n  /**\n   * Create a local DateTime\n   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month, 1-indexed\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @example DateTime.local()                                  //~> now\n   * @example DateTime.local({ zone: \"America/New_York\" })      //~> now, in US east coast time\n   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00\n   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00\n   * @example DateTime.local(2017, 3, 12, { locale: \"fr\" })     //~> 2017-03-12T00:00:00, with a French locale\n   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00\n   * @example DateTime.local(2017, 3, 12, 5, { zone: \"utc\" })   //~> 2017-03-12T05:00:00, in UTC\n   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765\n   * @return {DateTime}\n   */\n  static local() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime in UTC\n   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.utc()                                              //~> now\n   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z\n   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: \"fr\" })          //~> 2017-03-12T05:45:00Z with a French locale\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: \"fr\" }) //~> 2017-03-12T05:45:10.765Z with a French locale\n   * @return {DateTime}\n   */\n  static utc() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n\n    opts.zone = _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].utcInstance;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime from a JavaScript Date object. Uses the default zone.\n   * @param {Date} date - a JavaScript Date object\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @return {DateTime}\n   */\n  static fromJSDate(date, options = {}) {\n    const ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isDate)(date) ? date.valueOf() : NaN;\n    if (Number.isNaN(ts)) {\n      return DateTime.invalid(\"invalid input\");\n    }\n\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    return new DateTime({\n      ts: ts,\n      zone: zoneToUse,\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n    });\n  }\n\n  /**\n   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} milliseconds - a number of milliseconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromMillis(milliseconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(milliseconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`\n      );\n    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {\n      // this isn't perfect because we can still end up out of range because of additional shifting, but it's a start\n      return DateTime.invalid(\"Timestamp out of range\");\n    } else {\n      return new DateTime({\n        ts: milliseconds,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} seconds - a number of seconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromSeconds(seconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(seconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromSeconds requires a numerical input\");\n    } else {\n      return new DateTime({\n        ts: seconds * 1000,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.year - a year, such as 1987\n   * @param {number} obj.month - a month, 1-12\n   * @param {number} obj.day - a day of the month, 1-31, depending on the month\n   * @param {number} obj.ordinal - day of the year, 1-365 or 366\n   * @param {number} obj.weekYear - an ISO week year\n   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n   * @param {number} obj.localWeekYear - a week year, according to the locale\n   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale\n   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale\n   * @param {number} obj.hour - hour of the day, 0-23\n   * @param {number} obj.minute - minute of the hour, 0-59\n   * @param {number} obj.second - second of the minute, 0-59\n   * @param {number} obj.millisecond - millisecond of the second, 0-999\n   * @param {Object} opts - options for creating this DateTime\n   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()\n   * @param {string} [opts.locale='system\\'s locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })\n   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: \"en-US\" }).toISODate() //=> '2021-12-26'\n   * @return {DateTime}\n   */\n  static fromObject(obj, opts = {}) {\n    obj = obj || {};\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(obj, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, loc);\n\n    const tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now(),\n      offsetProvis = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.specificOffset)\n        ? opts.specificOffset\n        : zoneToUse.offset(tsNow),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    // cases:\n    // just a weekday -> this week's instance of that weekday, no worries\n    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error\n    // (gregorian month or day) + ordinal -> error\n    // otherwise just use weeks or ordinals or gregorian, depending on what's specified\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);\n\n    // configure ourselves to deal with gregorian dates or week stuff\n    let units,\n      defaultValues,\n      objNow = tsToObj(tsNow, offsetProvis);\n    if (useWeekData) {\n      units = orderedWeekUnits;\n      defaultValues = defaultWeekUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(objNow, minDaysInFirstWeek, startOfWeek);\n    } else if (containsOrdinal) {\n      units = orderedOrdinalUnits;\n      defaultValues = defaultOrdinalUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(objNow);\n    } else {\n      units = orderedUnits;\n      defaultValues = defaultUnitValues;\n    }\n\n    // set default values for missing stuff\n    let foundFirst = false;\n    for (const u of units) {\n      const v = normalized[u];\n      if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(v)) {\n        foundFirst = true;\n      } else if (foundFirst) {\n        normalized[u] = defaultValues[u];\n      } else {\n        normalized[u] = objNow[u];\n      }\n    }\n\n    // make sure the values we have are in range\n    const higherOrderInvalid = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidWeekData)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidOrdinalData)(normalized)\n        : (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(normalized),\n      invalid = higherOrderInvalid || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(normalized);\n\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    // compute the actual time\n    const gregorian = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)(normalized)\n        : normalized,\n      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),\n      inst = new DateTime({\n        ts: tsFinal,\n        zone: zoneToUse,\n        o: offsetFinal,\n        loc,\n      });\n\n    // gregorian data + weekday serves only to validate\n    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {\n      return DateTime.invalid(\n        \"mismatched weekday\",\n        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`\n      );\n    }\n\n    if (!inst.isValid) {\n      return DateTime.invalid(inst.invalid);\n    }\n\n    return inst;\n  }\n\n  /**\n   * Create a DateTime from an ISO 8601 string\n   * @param {string} text - the ISO string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n   * @example DateTime.fromISO('2016-W05-4')\n   * @return {DateTime}\n   */\n  static fromISO(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseISODate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"ISO 8601\", text);\n  }\n\n  /**\n   * Create a DateTime from an RFC 2822 string\n   * @param {string} text - the RFC 2822 string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n   * @return {DateTime}\n   */\n  static fromRFC2822(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseRFC2822Date)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"RFC 2822\", text);\n  }\n\n  /**\n   * Create a DateTime from an HTTP header date\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @param {string} text - the HTTP header date\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n   * @return {DateTime}\n   */\n  static fromHTTP(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseHTTPDate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"HTTP\", opts);\n  }\n\n  /**\n   * Create a DateTime from an input string and format string.\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromFormat(text, fmt, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(fmt)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromFormat requires an input string and a format\");\n    }\n\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      }),\n      [vals, parsedZone, specificOffset, invalid] = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.parseFromTokens)(localeToUse, text, fmt);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    } else {\n      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);\n    }\n  }\n\n  /**\n   * @deprecated use fromFormat instead\n   */\n  static fromString(text, fmt, opts = {}) {\n    return DateTime.fromFormat(text, fmt, opts);\n  }\n\n  /**\n   * Create a DateTime from a SQL date, time, or datetime\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale\n   * @param {string} text - the string to parse\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @example DateTime.fromSQL('2017-05-15')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n   * @example DateTime.fromSQL('09:12:34.342')\n   * @return {DateTime}\n   */\n  static fromSQL(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseSQL)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"SQL\", text);\n  }\n\n  /**\n   * Create an invalid DateTime.\n   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {DateTime}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"need to specify a reason the DateTime is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidDateTimeError(invalid);\n    } else {\n      return new DateTime({ invalid });\n    }\n  }\n\n  /**\n   * Check if an object is an instance of DateTime. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDateTime(o) {\n    return (o && o.isLuxonDateTime) || false;\n  }\n\n  /**\n   * Produce the format string for a set of options\n   * @param formatOpts\n   * @param localeOpts\n   * @returns {string}\n   */\n  static parseFormatForOpts(formatOpts, localeOpts = {}) {\n    const tokenList = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.formatOptsToTokens)(formatOpts, _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join(\"\");\n  }\n\n  /**\n   * Produce the the fully expanded format token for the locale\n   * Does NOT quote characters, so quoted tokens will not round trip correctly\n   * @param fmt\n   * @param localeOpts\n   * @returns {string}\n   */\n  static expandFormat(fmt, localeOpts = {}) {\n    const expanded = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.expandMacroTokens)(_impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseFormat(fmt), _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return expanded.map((t) => t.val).join(\"\");\n  }\n\n  static resetCache() {\n    zoneOffsetTs = undefined;\n    zoneOffsetGuessCache.clear();\n  }\n\n  // INFO\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7\n   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4\n   * @return {number}\n   */\n  get(unit) {\n    return this[unit];\n  }\n\n  /**\n   * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n   * * The DateTime was created by an operation on another invalid date\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get outputCalendar() {\n    return this.isValid ? this.loc.outputCalendar : null;\n  }\n\n  /**\n   * Get the time zone associated with this DateTime.\n   * @type {Zone}\n   */\n  get zone() {\n    return this._zone;\n  }\n\n  /**\n   * Get the name of the time zone.\n   * @type {string}\n   */\n  get zoneName() {\n    return this.isValid ? this.zone.name : null;\n  }\n\n  /**\n   * Get the year\n   * @example DateTime.local(2017, 5, 25).year //=> 2017\n   * @type {number}\n   */\n  get year() {\n    return this.isValid ? this.c.year : NaN;\n  }\n\n  /**\n   * Get the quarter\n   * @example DateTime.local(2017, 5, 25).quarter //=> 2\n   * @type {number}\n   */\n  get quarter() {\n    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\n  }\n\n  /**\n   * Get the month (1-12).\n   * @example DateTime.local(2017, 5, 25).month //=> 5\n   * @type {number}\n   */\n  get month() {\n    return this.isValid ? this.c.month : NaN;\n  }\n\n  /**\n   * Get the day of the month (1-30ish).\n   * @example DateTime.local(2017, 5, 25).day //=> 25\n   * @type {number}\n   */\n  get day() {\n    return this.isValid ? this.c.day : NaN;\n  }\n\n  /**\n   * Get the hour of the day (0-23).\n   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n   * @type {number}\n   */\n  get hour() {\n    return this.isValid ? this.c.hour : NaN;\n  }\n\n  /**\n   * Get the minute of the hour (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n   * @type {number}\n   */\n  get minute() {\n    return this.isValid ? this.c.minute : NaN;\n  }\n\n  /**\n   * Get the second of the minute (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n   * @type {number}\n   */\n  get second() {\n    return this.isValid ? this.c.second : NaN;\n  }\n\n  /**\n   * Get the millisecond of the second (0-999).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n   * @type {number}\n   */\n  get millisecond() {\n    return this.isValid ? this.c.millisecond : NaN;\n  }\n\n  /**\n   * Get the week year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015\n   * @type {number}\n   */\n  get weekYear() {\n    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the week number of the week year (1-52ish).\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21\n   * @type {number}\n   */\n  get weekNumber() {\n    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the day of the week.\n   * 1 is Monday and 7 is Sunday\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 11, 31).weekday //=> 4\n   * @type {number}\n   */\n  get weekday() {\n    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Returns true if this date is on a weekend according to the locale, false otherwise\n   * @returns {boolean}\n   */\n  get isWeekend() {\n    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);\n  }\n\n  /**\n   * Get the day of the week according to the locale.\n   * 1 is the first day of the week and 7 is the last day of the week.\n   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,\n   * @returns {number}\n   */\n  get localWeekday() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,\n   * because the week can start on different days of the week (see localWeekday) and because a different number of days\n   * is required for a week to count as the first week of a year.\n   * @returns {number}\n   */\n  get localWeekNumber() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)\n   * differently, see localWeekNumber.\n   * @returns {number}\n   */\n  get localWeekYear() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the ordinal (meaning the day of the year)\n   * @example DateTime.local(2017, 5, 25).ordinal //=> 145\n   * @type {number|DateTime}\n   */\n  get ordinal() {\n    return this.isValid ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c).ordinal : NaN;\n  }\n\n  /**\n   * Get the human readable short month name, such as 'Oct'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct\n   * @type {string}\n   */\n  get monthShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"short\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable long month name, such as 'October'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthLong //=> October\n   * @type {string}\n   */\n  get monthLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"long\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable short weekday, such as 'Mon'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n   * @type {string}\n   */\n  get weekdayShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"short\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the human readable long weekday, such as 'Monday'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n   * @type {string}\n   */\n  get weekdayLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"long\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the UTC offset of this DateTime in minutes\n   * @example DateTime.now().offset //=> -240\n   * @example DateTime.utc().offset //=> 0\n   * @type {number}\n   */\n  get offset() {\n    return this.isValid ? +this.o : NaN;\n  }\n\n  /**\n   * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameShort() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"short\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameLong() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"long\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get whether this zone's offset ever changes, as in a DST.\n   * @type {boolean}\n   */\n  get isOffsetFixed() {\n    return this.isValid ? this.zone.isUniversal : null;\n  }\n\n  /**\n   * Get whether the DateTime is in a DST.\n   * @type {boolean}\n   */\n  get isInDST() {\n    if (this.isOffsetFixed) {\n      return false;\n    } else {\n      return (\n        this.offset > this.set({ month: 1, day: 1 }).offset ||\n        this.offset > this.set({ month: 5 }).offset\n      );\n    }\n  }\n\n  /**\n   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC\n   * in this DateTime's zone. During DST changes local time can be ambiguous, for example\n   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.\n   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.\n   * @returns {DateTime[]}\n   */\n  getPossibleOffsets() {\n    if (!this.isValid || this.isOffsetFixed) {\n      return [this];\n    }\n    const dayMs = 86400000;\n    const minuteMs = 60000;\n    const localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(this.c);\n    const oEarlier = this.zone.offset(localTS - dayMs);\n    const oLater = this.zone.offset(localTS + dayMs);\n\n    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);\n    const o2 = this.zone.offset(localTS - oLater * minuteMs);\n    if (o1 === o2) {\n      return [this];\n    }\n    const ts1 = localTS - o1 * minuteMs;\n    const ts2 = localTS - o2 * minuteMs;\n    const c1 = tsToObj(ts1, o1);\n    const c2 = tsToObj(ts2, o2);\n    if (\n      c1.hour === c2.hour &&\n      c1.minute === c2.minute &&\n      c1.second === c2.second &&\n      c1.millisecond === c2.millisecond\n    ) {\n      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];\n    }\n    return [this];\n  }\n\n  /**\n   * Returns true if this DateTime is in a leap year, false otherwise\n   * @example DateTime.local(2016).isInLeapYear //=> true\n   * @example DateTime.local(2013).isInLeapYear //=> false\n   * @type {boolean}\n   */\n  get isInLeapYear() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isLeapYear)(this.year);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's month\n   * @example DateTime.local(2016, 2).daysInMonth //=> 29\n   * @example DateTime.local(2016, 3).daysInMonth //=> 31\n   * @type {number}\n   */\n  get daysInMonth() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(this.year, this.month);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's year\n   * @example DateTime.local(2016).daysInYear //=> 366\n   * @example DateTime.local(2013).daysInYear //=> 365\n   * @type {number}\n   */\n  get daysInYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInYear)(this.year) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2004).weeksInWeekYear //=> 53\n   * @example DateTime.local(2013).weeksInWeekYear //=> 52\n   * @type {number}\n   */\n  get weeksInWeekYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(this.weekYear) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's local week year\n   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52\n   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53\n   * @type {number}\n   */\n  get weeksInLocalWeekYear() {\n    return this.isValid\n      ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(\n          this.localWeekYear,\n          this.loc.getMinDaysInFirstWeek(),\n          this.loc.getStartOfWeek()\n        )\n      : NaN;\n  }\n\n  /**\n   * Returns the resolved Intl options for this DateTime.\n   * This is useful in understanding the behavior of formatting methods\n   * @param {Object} opts - the same options as toLocaleString\n   * @return {Object}\n   */\n  resolvedLocaleOptions(opts = {}) {\n    const { locale, numberingSystem, calendar } = _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(\n      this.loc.clone(opts),\n      opts\n    ).resolvedOptions(this);\n    return { locale, numberingSystem, outputCalendar: calendar };\n  }\n\n  // TRANSFORM\n\n  /**\n   * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to {@link DateTime#setZone}('utc')\n   * @param {number} [offset=0] - optionally, an offset from UTC in minutes\n   * @param {Object} [opts={}] - options to pass to `setZone()`\n   * @return {DateTime}\n   */\n  toUTC(offset = 0, opts = {}) {\n    return this.setZone(_zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance(offset), opts);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to `setZone('local')`\n   * @return {DateTime}\n   */\n  toLocal() {\n    return this.setZone(_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n   *\n   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.\n   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.\n   * @return {DateTime}\n   */\n  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {\n    zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (zone.equals(this.zone)) {\n      return this;\n    } else if (!zone.isValid) {\n      return DateTime.invalid(unsupportedZone(zone));\n    } else {\n      let newTS = this.ts;\n      if (keepLocalTime || keepCalendarTime) {\n        const offsetGuess = zone.offset(this.ts);\n        const asObj = this.toObject();\n        [newTS] = objToTS(asObj, offsetGuess, zone);\n      }\n      return clone(this, { ts: newTS, zone });\n    }\n  }\n\n  /**\n   * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\n   * @param {Object} properties - the properties to set\n   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\n   * @return {DateTime}\n   */\n  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });\n    return clone(this, { loc });\n  }\n\n  /**\n   * \"Set\" the locale. Returns a newly-constructed DateTime.\n   * Just a convenient alias for reconfigure({ locale })\n   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')\n   * @return {DateTime}\n   */\n  setLocale(locale) {\n    return this.reconfigure({ locale });\n  }\n\n  /**\n   * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n   * You can only set units with this method; for \"setting\" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.\n   *\n   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.\n   * They cannot be mixed with ISO-week units like `weekday`.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dt.set({ year: 2017 })\n   * @example dt.set({ hour: 8, minute: 30 })\n   * @example dt.set({ weekday: 5 })\n   * @example dt.set({ year: 2005, ordinal: 234 })\n   * @return {DateTime}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(values, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, this.loc);\n\n    const settingWeekStuff =\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekYear) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekNumber) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekday),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    let mixed;\n    if (settingWeekStuff) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(\n        { ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },\n        minDaysInFirstWeek,\n        startOfWeek\n      );\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal)) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)({ ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c), ...normalized });\n    } else {\n      mixed = { ...this.toObject(), ...normalized };\n\n      // if we didn't set the day but we ended up on an overflow date,\n      // use the last day of the right month\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day)) {\n        mixed.day = Math.min((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(mixed.year, mixed.month), mixed.day);\n      }\n    }\n\n    const [ts, o] = objToTS(mixed, this.o, this.zone);\n    return clone(this, { ts, o });\n  }\n\n  /**\n   * Add a period of time to this DateTime and return the resulting DateTime\n   *\n   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @example DateTime.now().plus(123) //~> in 123 milliseconds\n   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday\n   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n   * @return {DateTime}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration);\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * Subtract a period of time to this DateTime and return the resulting DateTime\n   * See {@link DateTime#plus}\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   @return {DateTime}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration).negate();\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * \"Set\" this DateTime to the beginning of a unit of time.\n   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n   * @return {DateTime}\n   */\n  startOf(unit, { useLocaleWeeks = false } = {}) {\n    if (!this.isValid) return this;\n\n    const o = {},\n      normalizedUnit = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit(unit);\n    switch (normalizedUnit) {\n      case \"years\":\n        o.month = 1;\n      // falls through\n      case \"quarters\":\n      case \"months\":\n        o.day = 1;\n      // falls through\n      case \"weeks\":\n      case \"days\":\n        o.hour = 0;\n      // falls through\n      case \"hours\":\n        o.minute = 0;\n      // falls through\n      case \"minutes\":\n        o.second = 0;\n      // falls through\n      case \"seconds\":\n        o.millisecond = 0;\n        break;\n      case \"milliseconds\":\n        break;\n      // no default, invalid units throw in normalizeUnit()\n    }\n\n    if (normalizedUnit === \"weeks\") {\n      if (useLocaleWeeks) {\n        const startOfWeek = this.loc.getStartOfWeek();\n        const { weekday } = this;\n        if (weekday < startOfWeek) {\n          o.weekNumber = this.weekNumber - 1;\n        }\n        o.weekday = startOfWeek;\n      } else {\n        o.weekday = 1;\n      }\n    }\n\n    if (normalizedUnit === \"quarters\") {\n      const q = Math.ceil(this.month / 3);\n      o.month = (q - 1) * 3 + 1;\n    }\n\n    return this.set(o);\n  }\n\n  /**\n   * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n   * @return {DateTime}\n   */\n  endOf(unit, opts) {\n    return this.isValid\n      ? this.plus({ [unit]: 1 })\n          .startOf(unit, opts)\n          .minus(1)\n      : this;\n  }\n\n  // OUTPUT\n\n  /**\n   * Returns a string representation of this DateTime formatted according to the specified format string.\n   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.\n   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation\n   * of the DateTime in the assigned locale.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toLocaleString(); //=> 4/20/2017\n   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'\n   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), formatOpts).formatDateTime(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an array of format \"parts\", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\n   * @example DateTime.now().toLocaleParts(); //=> [\n   *                                   //=>   { type: 'day', value: '25' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'month', value: '05' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'year', value: '1982' }\n   *                                   //=> ]\n   */\n  toLocaleParts(opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), opts).formatDateTimeParts(this)\n      : [];\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n   * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'\n   * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'\n   * @return {string|null}\n   */\n  toISO({\n    format = \"extended\",\n    suppressSeconds = false,\n    suppressMilliseconds = false,\n    includeOffset = true,\n    extendedZone = false,\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    const ext = format === \"extended\";\n\n    let c = toISODate(this, ext, precision);\n    if (orderedUnits.indexOf(precision) >= 3) c += \"T\";\n    c += toISOTime(\n      this,\n      ext,\n      suppressSeconds,\n      suppressMilliseconds,\n      includeOffset,\n      extendedZone,\n      precision\n    );\n    return c;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's date component\n   * @param {Object} opts - options\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.\n   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'\n   * @return {string|null}\n   */\n  toISODate({ format = \"extended\", precision = \"day\" } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, format === \"extended\", normalizeUnit(precision));\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's week date\n   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n   * @return {string}\n   */\n  toISOWeekDate() {\n    return toTechFormat(this, \"kkkk-'W'WW-c\");\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's time component\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'\n   * @return {string}\n   */\n  toISOTime({\n    suppressMilliseconds = false,\n    suppressSeconds = false,\n    includeOffset = true,\n    includePrefix = false,\n    extendedZone = false,\n    format = \"extended\",\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    let c = includePrefix && orderedUnits.indexOf(precision) >= 3 ? \"T\" : \"\";\n    return (\n      c +\n      toISOTime(\n        this,\n        format === \"extended\",\n        suppressSeconds,\n        suppressMilliseconds,\n        includeOffset,\n        extendedZone,\n        precision\n      )\n    );\n  }\n\n  /**\n   * Returns an RFC 2822-compatible string representation of this DateTime\n   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n   * @return {string}\n   */\n  toRFC2822() {\n    return toTechFormat(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\", false);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.\n   * Specifically, the string conforms to RFC 1123.\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n   * @return {string}\n   */\n  toHTTP() {\n    return toTechFormat(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\");\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Date\n   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n   * @return {string|null}\n   */\n  toSQLDate() {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Time\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc().toSQL() //=> '05:15:16.345'\n   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n   * @return {string}\n   */\n  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {\n    let fmt = \"HH:mm:ss.SSS\";\n\n    if (includeZone || includeOffset) {\n      if (includeOffsetSpace) {\n        fmt += \" \";\n      }\n      if (includeZone) {\n        fmt += \"z\";\n      } else if (includeOffset) {\n        fmt += \"ZZ\";\n      }\n    }\n\n    return toTechFormat(this, fmt, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n   * @return {string}\n   */\n  toSQL(opts = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for debugging\n   * @return {string}\n   */\n  toString() {\n    return this.isValid ? this.toISO() : INVALID;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;\n    } else {\n      return `DateTime { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime.\n   * @return {number}\n   */\n  toMillis() {\n    return this.isValid ? this.ts : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.\n   * @return {number}\n   */\n  toSeconds() {\n    return this.isValid ? this.ts / 1000 : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (as a whole number) of this DateTime.\n   * @return {number}\n   */\n  toUnixInteger() {\n    return this.isValid ? Math.floor(this.ts / 1000) : NaN;\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a BSON serializable equivalent to this DateTime.\n   * @return {Date}\n   */\n  toBSON() {\n    return this.toJSDate();\n  }\n\n  /**\n   * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n   * @param opts - options for generating the object\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\n   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n   * @return {Object}\n   */\n  toObject(opts = {}) {\n    if (!this.isValid) return {};\n\n    const base = { ...this.c };\n\n    if (opts.includeConfig) {\n      base.outputCalendar = this.outputCalendar;\n      base.numberingSystem = this.loc.numberingSystem;\n      base.locale = this.loc.locale;\n    }\n    return base;\n  }\n\n  /**\n   * Returns a JavaScript Date equivalent to this DateTime.\n   * @return {Date}\n   */\n  toJSDate() {\n    return new Date(this.isValid ? this.ts : NaN);\n  }\n\n  // COMPARE\n\n  /**\n   * Return the difference between two DateTimes as a Duration.\n   * @param {DateTime} otherDateTime - the DateTime to compare this one to\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example\n   * var i1 = DateTime.fromISO('1982-05-25T09:45'),\n   *     i2 = DateTime.fromISO('1983-10-14T10:30');\n   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n   * @return {Duration}\n   */\n  diff(otherDateTime, unit = \"milliseconds\", opts = {}) {\n    if (!this.isValid || !otherDateTime.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].invalid(\"created by diffing an invalid DateTime\");\n    }\n\n    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };\n\n    const units = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.maybeArray)(unit).map(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit),\n      otherIsLater = otherDateTime.valueOf() > this.valueOf(),\n      earlier = otherIsLater ? this : otherDateTime,\n      later = otherIsLater ? otherDateTime : this,\n      diffed = (0,_impl_diff_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(earlier, later, units, durOpts);\n\n    return otherIsLater ? diffed.negate() : diffed;\n  }\n\n  /**\n   * Return the difference between this DateTime and right now.\n   * See {@link DateTime#diff}\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  diffNow(unit = \"milliseconds\", opts = {}) {\n    return this.diff(DateTime.now(), unit, opts);\n  }\n\n  /**\n   * Return an Interval spanning between this DateTime and another DateTime\n   * @param {DateTime} otherDateTime - the other end point of the Interval\n   * @return {Interval|DateTime}\n   */\n  until(otherDateTime) {\n    return this.isValid ? _interval_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDateTimes(this, otherDateTime) : this;\n  }\n\n  /**\n   * Return whether this DateTime is in the same unit of time as another DateTime.\n   * Higher-order units must also be identical for this function to return `true`.\n   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.\n   * @param {DateTime} otherDateTime - the other DateTime\n   * @param {string} unit - the unit of time to check sameness on\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used\n   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n   * @return {boolean}\n   */\n  hasSame(otherDateTime, unit, opts) {\n    if (!this.isValid) return false;\n\n    const inputMs = otherDateTime.valueOf();\n    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });\n    return (\n      adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts)\n    );\n  }\n\n  /**\n   * Equality check\n   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.\n   * To compare just the millisecond values, use `+dt1 === +dt2`.\n   * @param {DateTime} other - the other DateTime\n   * @return {boolean}\n   */\n  equals(other) {\n    return (\n      this.isValid &&\n      other.isValid &&\n      this.valueOf() === other.valueOf() &&\n      this.zone.equals(other.zone) &&\n      this.loc.equals(other.loc)\n    );\n  }\n\n  /**\n   * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\n   * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} [options.style=\"long\"] - the style of units, must be \"long\", \"short\", or \"narrow\"\n   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of \"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", or \"seconds\"\n   * @param {boolean} [options.round=true] - whether to round the numbers in the output.\n   * @param {string} [options.rounding=\"trunc\"] - rounding method to use when rounding the numbers in the output. Can be \"trunc\" (toward zero), \"expand\" (away from zero), \"round\", \"floor\", or \"ceil\".\n   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n   * @example DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"\n   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n   */\n  toRelative(options = {}) {\n    if (!this.isValid) return null;\n    const base = options.base || DateTime.fromObject({}, { zone: this.zone }),\n      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;\n    let units = [\"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\"];\n    let unit = options.unit;\n    if (Array.isArray(options.unit)) {\n      units = options.unit;\n      unit = undefined;\n    }\n    return diffRelative(base, this.plus(padding), {\n      ...options,\n      numeric: \"always\",\n      units,\n      unit,\n    });\n  }\n\n  /**\n   * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"years\", \"quarters\", \"months\", \"weeks\", or \"days\"\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n   * @example DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"maana\"\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n   */\n  toRelativeCalendar(options = {}) {\n    if (!this.isValid) return null;\n\n    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {\n      ...options,\n      numeric: \"auto\",\n      units: [\"years\", \"months\", \"days\"],\n      calendary: true,\n    });\n  }\n\n  /**\n   * Return the min of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum\n   * @return {DateTime} the min DateTime, or undefined if called with no argument\n   */\n  static min(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"min requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.min);\n  }\n\n  /**\n   * Return the max of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum\n   * @return {DateTime} the max DateTime, or undefined if called with no argument\n   */\n  static max(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"max requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.max);\n  }\n\n  // MISC\n\n  /**\n   * Explain how a string would be parsed by fromFormat()\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see description)\n   * @param {Object} options - options taken by fromFormat()\n   * @return {Object}\n   */\n  static fromFormatExplain(text, fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.explainFromTokens)(localeToUse, text, fmt);\n  }\n\n  /**\n   * @deprecated use fromFormatExplain instead\n   */\n  static fromStringExplain(text, fmt, options = {}) {\n    return DateTime.fromFormatExplain(text, fmt, options);\n  }\n\n  /**\n   * Build a parser for `fmt` using the given locale. This parser can be passed\n   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This\n   * can be used to optimize cases where many dates need to be parsed in a\n   * specific format.\n   *\n   * @param {String} fmt - the format the string is expected to be in (see\n   * description)\n   * @param {Object} options - options used to set locale and numberingSystem\n   * for parser\n   * @returns {TokenParser} - opaque object to be used\n   */\n  static buildFormatParser(fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return new _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.TokenParser(localeToUse, fmt);\n  }\n\n  /**\n   * Create a DateTime from an input string and format parser.\n   *\n   * The format parser must have been created with the same locale as this call.\n   *\n   * @param {String} text - the string to parse\n   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}\n   * @param {Object} opts - options taken by fromFormat()\n   * @returns {DateTime}\n   */\n  static fromFormatParser(text, formatParser, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(formatParser)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        \"fromFormatParser requires an input string and a format parser\"\n      );\n    }\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n\n    if (!localeToUse.equals(formatParser.locale)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromFormatParser called with a locale of ${localeToUse}, ` +\n          `but the format parser was created for ${formatParser.locale}`\n      );\n    }\n\n    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);\n\n    if (invalidReason) {\n      return DateTime.invalid(invalidReason);\n    } else {\n      return parseDataToDateTime(\n        result,\n        zone,\n        opts,\n        `format ${formatParser.format}`,\n        text,\n        specificOffset\n      );\n    }\n  }\n\n  // FORMAT PRESETS\n\n  /**\n   * {@link DateTime#toLocaleString} format like 10/14/1983\n   * @type {Object}\n   */\n  static get DATE_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE_WITH_SECONDS;\n  }\n}\n\n/**\n * @private\n */\nfunction friendlyDateTime(dateTimeish) {\n  if (DateTime.isDateTime(dateTimeish)) {\n    return dateTimeish;\n  } else if (dateTimeish && dateTimeish.valueOf && (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(dateTimeish.valueOf())) {\n    return DateTime.fromJSDate(dateTimeish);\n  } else if (dateTimeish && typeof dateTimeish === \"object\") {\n    return DateTime.fromObject(dateTimeish);\n  } else {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`\n    );\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2RhdGV0aW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNBO0FBQ0E7QUFDUjtBQUNlO0FBQ2E7QUFDbkI7QUFlZDtBQUMyQjtBQUNqQjtBQUM4RDtBQU9qRTtBQVlBO0FBQ2M7QUFNeEI7QUFDbUI7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHlEQUFPLGtDQUFrQyxVQUFVO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNFQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0VBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQVk7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVc7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0Isb0RBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksK0NBQStDLHVEQUFRO0FBQzNEO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGNBQWMsNkRBQW9CO0FBQ2xDLG9DQUFvQyxZQUFZLFlBQVksbUJBQW1CO0FBQy9FO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2RhdGV0aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IEludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQge1xuICBpc1VuZGVmaW5lZCxcbiAgbWF5YmVBcnJheSxcbiAgaXNEYXRlLFxuICBpc051bWJlcixcbiAgYmVzdEJ5LFxuICBkYXlzSW5Nb250aCxcbiAgZGF5c0luWWVhcixcbiAgaXNMZWFwWWVhcixcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG4gIG9ialRvTG9jYWxUUyxcbiAgcGFkU3RhcnQsXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCBkaWZmIGZyb20gXCIuL2ltcGwvZGlmZi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VSRkMyODIyRGF0ZSwgcGFyc2VJU09EYXRlLCBwYXJzZUhUVFBEYXRlLCBwYXJzZVNRTCB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIHBhcnNlRnJvbVRva2VucyxcbiAgZXhwbGFpbkZyb21Ub2tlbnMsXG4gIGZvcm1hdE9wdHNUb1Rva2VucyxcbiAgZXhwYW5kTWFjcm9Ub2tlbnMsXG4gIFRva2VuUGFyc2VyLFxufSBmcm9tIFwiLi9pbXBsL3Rva2VuUGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBncmVnb3JpYW5Ub1dlZWssXG4gIHdlZWtUb0dyZWdvcmlhbixcbiAgZ3JlZ29yaWFuVG9PcmRpbmFsLFxuICBvcmRpbmFsVG9HcmVnb3JpYW4sXG4gIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhLFxuICBoYXNJbnZhbGlkV2Vla0RhdGEsXG4gIGhhc0ludmFsaWRPcmRpbmFsRGF0YSxcbiAgaGFzSW52YWxpZFRpbWVEYXRhLFxuICB1c2VzTG9jYWxXZWVrVmFsdWVzLFxuICBpc29XZWVrZGF5VG9Mb2NhbCxcbn0gZnJvbSBcIi4vaW1wbC9jb252ZXJzaW9ucy5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcixcbiAgSW52YWxpZFVuaXRFcnJvcixcbiAgSW52YWxpZERhdGVUaW1lRXJyb3IsXG59IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbmNvbnN0IE1BWF9EQVRFID0gOC42NGUxNTtcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRab25lKHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5zdXBwb3J0ZWQgem9uZVwiLCBgdGhlIHpvbmUgXCIke3pvbmUubmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5cbi8vIHdlIGNhY2hlIHdlZWsgZGF0YSBvbiB0aGUgRFQgb2JqZWN0IGFuZCB0aGlzIGludGVybWVkaWF0ZXMgdGhlIGNhY2hlXG4vKipcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IGR0XG4gKi9cbmZ1bmN0aW9uIHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEoZHQpIHtcbiAgaWYgKGR0LndlZWtEYXRhID09PSBudWxsKSB7XG4gICAgZHQud2Vla0RhdGEgPSBncmVnb3JpYW5Ub1dlZWsoZHQuYyk7XG4gIH1cbiAgcmV0dXJuIGR0LndlZWtEYXRhO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IGR0XG4gKi9cbmZ1bmN0aW9uIHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YShkdCkge1xuICBpZiAoZHQubG9jYWxXZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LmxvY2FsV2Vla0RhdGEgPSBncmVnb3JpYW5Ub1dlZWsoXG4gICAgICBkdC5jLFxuICAgICAgZHQubG9jLmdldE1pbkRheXNJbkZpcnN0V2VlaygpLFxuICAgICAgZHQubG9jLmdldFN0YXJ0T2ZXZWVrKClcbiAgICApO1xuICB9XG4gIHJldHVybiBkdC5sb2NhbFdlZWtEYXRhO1xufVxuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMsIFwibWFrZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGVzZSBtb2RpZmljYXRpb25zXCIuIGFsbCBcInNldHRlcnNcIiByZWFsbHkgdXNlIHRoaXNcbi8vIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2hpbGUgb25seSBjaGFuZ2luZyBzb21lIG9mIHRoZSBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBjbG9uZShpbnN0LCBhbHRzKSB7XG4gIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgdHM6IGluc3QudHMsXG4gICAgem9uZTogaW5zdC56b25lLFxuICAgIGM6IGluc3QuYyxcbiAgICBvOiBpbnN0Lm8sXG4gICAgbG9jOiBpbnN0LmxvYyxcbiAgICBpbnZhbGlkOiBpbnN0LmludmFsaWQsXG4gIH07XG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyAuLi5jdXJyZW50LCAuLi5hbHRzLCBvbGQ6IGN1cnJlbnQgfSk7XG59XG5cbi8vIGZpbmQgdGhlIHJpZ2h0IG9mZnNldCBhIGdpdmVuIGxvY2FsIHRpbWUuIFRoZSBvIGlucHV0IGlzIG91ciBndWVzcywgd2hpY2ggZGV0ZXJtaW5lcyB3aGljaFxuLy8gb2Zmc2V0IHdlJ2xsIHBpY2sgaW4gYW1iaWd1b3VzIGNhc2VzIChlLmcuIHRoZXJlIGFyZSB0d28gMyBBTXMgYi9jIEZhbGxiYWNrIERTVClcbmZ1bmN0aW9uIGZpeE9mZnNldChsb2NhbFRTLCBvLCB0eikge1xuICAvLyBPdXIgVVRDIHRpbWUgaXMganVzdCBhIGd1ZXNzIGJlY2F1c2Ugb3VyIG9mZnNldCBpcyBqdXN0IGEgZ3Vlc3NcbiAgbGV0IHV0Y0d1ZXNzID0gbG9jYWxUUyAtIG8gKiA2MCAqIDEwMDA7XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHRoZSB6b25lIG1hdGNoZXMgdGhlIG9mZnNldCBmb3IgdGhpcyB0c1xuICBjb25zdCBvMiA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG5cbiAgLy8gSWYgc28sIG9mZnNldCBkaWRuJ3QgY2hhbmdlIGFuZCB3ZSdyZSBkb25lXG4gIGlmIChvID09PSBvMikge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG9dO1xuICB9XG5cbiAgLy8gSWYgbm90LCBjaGFuZ2UgdGhlIHRzIGJ5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBvZmZzZXRcbiAgdXRjR3Vlc3MgLT0gKG8yIC0gbykgKiA2MCAqIDEwMDA7XG5cbiAgLy8gSWYgdGhhdCBnaXZlcyB1cyB0aGUgbG9jYWwgdGltZSB3ZSB3YW50LCB3ZSdyZSBkb25lXG4gIGNvbnN0IG8zID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcbiAgaWYgKG8yID09PSBvMykge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG8yXTtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZGlmZmVyZW50LCB3ZSdyZSBpbiBhIGhvbGUgdGltZS4gVGhlIG9mZnNldCBoYXMgY2hhbmdlZCwgYnV0IHRoZSB3ZSBkb24ndCBhZGp1c3QgdGhlIHRpbWVcbiAgcmV0dXJuIFtsb2NhbFRTIC0gTWF0aC5taW4obzIsIG8zKSAqIDYwICogMTAwMCwgTWF0aC5tYXgobzIsIG8zKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gZXBvY2ggdGltZXN0YW1wIGludG8gYSBjYWxlbmRhciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0XG5mdW5jdGlvbiB0c1RvT2JqKHRzLCBvZmZzZXQpIHtcbiAgdHMgKz0gb2Zmc2V0ICogNjAgKiAxMDAwO1xuXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbW9udGg6IGQuZ2V0VVRDTW9udGgoKSArIDEsXG4gICAgZGF5OiBkLmdldFVUQ0RhdGUoKSxcbiAgICBob3VyOiBkLmdldFVUQ0hvdXJzKCksXG4gICAgbWludXRlOiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBzZWNvbmQ6IGQuZ2V0VVRDU2Vjb25kcygpLFxuICAgIG1pbGxpc2Vjb25kOiBkLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICB9O1xufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgZXBvY2ggdGltZXN0YW1wXG5mdW5jdGlvbiBvYmpUb1RTKG9iaiwgb2Zmc2V0LCB6b25lKSB7XG4gIHJldHVybiBmaXhPZmZzZXQob2JqVG9Mb2NhbFRTKG9iaiksIG9mZnNldCwgem9uZSk7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBEVCBpbnN0YW5jZSBieSBhZGRpbmcgYSBkdXJhdGlvbiwgYWRqdXN0aW5nIGZvciBEU1RzXG5mdW5jdGlvbiBhZGp1c3RUaW1lKGluc3QsIGR1cikge1xuICBjb25zdCBvUHJlID0gaW5zdC5vLFxuICAgIHllYXIgPSBpbnN0LmMueWVhciArIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICBtb250aCA9IGluc3QuYy5tb250aCArIE1hdGgudHJ1bmMoZHVyLm1vbnRocykgKyBNYXRoLnRydW5jKGR1ci5xdWFydGVycykgKiAzLFxuICAgIGMgPSB7XG4gICAgICAuLi5pbnN0LmMsXG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXk6XG4gICAgICAgIE1hdGgubWluKGluc3QuYy5kYXksIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci5kYXlzKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLndlZWtzKSAqIDcsXG4gICAgfSxcbiAgICBtaWxsaXNUb0FkZCA9IER1cmF0aW9uLmZyb21PYmplY3Qoe1xuICAgICAgeWVhcnM6IGR1ci55ZWFycyAtIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICAgIHF1YXJ0ZXJzOiBkdXIucXVhcnRlcnMgLSBNYXRoLnRydW5jKGR1ci5xdWFydGVycyksXG4gICAgICBtb250aHM6IGR1ci5tb250aHMgLSBNYXRoLnRydW5jKGR1ci5tb250aHMpLFxuICAgICAgd2Vla3M6IGR1ci53ZWVrcyAtIE1hdGgudHJ1bmMoZHVyLndlZWtzKSxcbiAgICAgIGRheXM6IGR1ci5kYXlzIC0gTWF0aC50cnVuYyhkdXIuZGF5cyksXG4gICAgICBob3VyczogZHVyLmhvdXJzLFxuICAgICAgbWludXRlczogZHVyLm1pbnV0ZXMsXG4gICAgICBzZWNvbmRzOiBkdXIuc2Vjb25kcyxcbiAgICAgIG1pbGxpc2Vjb25kczogZHVyLm1pbGxpc2Vjb25kcyxcbiAgICB9KS5hcyhcIm1pbGxpc2Vjb25kc1wiKSxcbiAgICBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKGMpO1xuXG4gIGxldCBbdHMsIG9dID0gZml4T2Zmc2V0KGxvY2FsVFMsIG9QcmUsIGluc3Quem9uZSk7XG5cbiAgaWYgKG1pbGxpc1RvQWRkICE9PSAwKSB7XG4gICAgdHMgKz0gbWlsbGlzVG9BZGQ7XG4gICAgLy8gdGhhdCBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlIG9mZnNldCBieSBnb2luZyBvdmVyIGEgRFNULCBidXQgd2Ugd2FudCB0byBrZWVwIHRoZSB0cyB0aGUgc2FtZVxuICAgIG8gPSBpbnN0LnpvbmUub2Zmc2V0KHRzKTtcbiAgfVxuXG4gIHJldHVybiB7IHRzLCBvIH07XG59XG5cbi8vIGhlbHBlciB1c2VmdWwgaW4gdHVybmluZyB0aGUgcmVzdWx0cyBvZiBwYXJzaW5nIGludG8gcmVhbCBkYXRlc1xuLy8gYnkgaGFuZGxpbmcgdGhlIHpvbmUgb3B0aW9uc1xuZnVuY3Rpb24gcGFyc2VEYXRhVG9EYXRlVGltZShwYXJzZWQsIHBhcnNlZFpvbmUsIG9wdHMsIGZvcm1hdCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpIHtcbiAgY29uc3QgeyBzZXRab25lLCB6b25lIH0gPSBvcHRzO1xuICBpZiAoKHBhcnNlZCAmJiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCAhPT0gMCkgfHwgcGFyc2VkWm9uZSkge1xuICAgIGNvbnN0IGludGVycHJldGF0aW9uWm9uZSA9IHBhcnNlZFpvbmUgfHwgem9uZSxcbiAgICAgIGluc3QgPSBEYXRlVGltZS5mcm9tT2JqZWN0KHBhcnNlZCwge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB6b25lOiBpbnRlcnByZXRhdGlvblpvbmUsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgcmV0dXJuIHNldFpvbmUgPyBpbnN0IDogaW5zdC5zZXRab25lKHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgbmV3IEludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzICR7Zm9ybWF0fWApXG4gICAgKTtcbiAgfVxufVxuXG4vLyBpZiB5b3Ugd2FudCB0byBvdXRwdXQgYSB0ZWNobmljYWwgZm9ybWF0IChlLmcuIFJGQyAyODIyKSwgdGhpcyBoZWxwZXJcbi8vIGhlbHBzIGhhbmRsZSB0aGUgZGV0YWlsc1xuZnVuY3Rpb24gdG9UZWNoRm9ybWF0KGR0LCBmb3JtYXQsIGFsbG93WiA9IHRydWUpIHtcbiAgcmV0dXJuIGR0LmlzVmFsaWRcbiAgICA/IEZvcm1hdHRlci5jcmVhdGUoTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpLCB7XG4gICAgICAgIGFsbG93WixcbiAgICAgICAgZm9yY2VTaW1wbGU6IHRydWUsXG4gICAgICB9KS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZvcm1hdClcbiAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSVNPRGF0ZShvLCBleHRlbmRlZCwgcHJlY2lzaW9uKSB7XG4gIGNvbnN0IGxvbmdGb3JtYXQgPSBvLmMueWVhciA+IDk5OTkgfHwgby5jLnllYXIgPCAwO1xuICBsZXQgYyA9IFwiXCI7XG4gIGlmIChsb25nRm9ybWF0ICYmIG8uYy55ZWFyID49IDApIGMgKz0gXCIrXCI7XG4gIGMgKz0gcGFkU3RhcnQoby5jLnllYXIsIGxvbmdGb3JtYXQgPyA2IDogNCk7XG4gIGlmIChwcmVjaXNpb24gPT09IFwieWVhclwiKSByZXR1cm4gYztcbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgaWYgKHByZWNpc2lvbiA9PT0gXCJtb250aFwiKSByZXR1cm4gYztcbiAgICBjICs9IFwiLVwiO1xuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBpZiAocHJlY2lzaW9uID09PSBcIm1vbnRoXCIpIHJldHVybiBjO1xuICB9XG4gIGMgKz0gcGFkU3RhcnQoby5jLmRheSk7XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiB0b0lTT1RpbWUoXG4gIG8sXG4gIGV4dGVuZGVkLFxuICBzdXBwcmVzc1NlY29uZHMsXG4gIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICBpbmNsdWRlT2Zmc2V0LFxuICBleHRlbmRlZFpvbmUsXG4gIHByZWNpc2lvblxuKSB7XG4gIGxldCBzaG93U2Vjb25kcyA9ICFzdXBwcmVzc1NlY29uZHMgfHwgby5jLm1pbGxpc2Vjb25kICE9PSAwIHx8IG8uYy5zZWNvbmQgIT09IDAsXG4gICAgYyA9IFwiXCI7XG4gIHN3aXRjaCAocHJlY2lzaW9uKSB7XG4gICAgY2FzZSBcImRheVwiOlxuICAgIGNhc2UgXCJtb250aFwiOlxuICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYyArPSBwYWRTdGFydChvLmMuaG91cik7XG4gICAgICBpZiAocHJlY2lzaW9uID09PSBcImhvdXJcIikgYnJlYWs7XG4gICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgYyArPSBcIjpcIjtcbiAgICAgICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gXCJtaW51dGVcIikgYnJlYWs7XG4gICAgICAgIGlmIChzaG93U2Vjb25kcykge1xuICAgICAgICAgIGMgKz0gXCI6XCI7XG4gICAgICAgICAgYyArPSBwYWRTdGFydChvLmMuc2Vjb25kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gXCJtaW51dGVcIikgYnJlYWs7XG4gICAgICAgIGlmIChzaG93U2Vjb25kcykge1xuICAgICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLnNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcmVjaXNpb24gPT09IFwic2Vjb25kXCIpIGJyZWFrO1xuICAgICAgaWYgKHNob3dTZWNvbmRzICYmICghc3VwcHJlc3NNaWxsaXNlY29uZHMgfHwgby5jLm1pbGxpc2Vjb25kICE9PSAwKSkge1xuICAgICAgICBjICs9IFwiLlwiO1xuICAgICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taWxsaXNlY29uZCwgMyk7XG4gICAgICB9XG4gIH1cblxuICBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgIGlmIChvLmlzT2Zmc2V0Rml4ZWQgJiYgby5vZmZzZXQgPT09IDAgJiYgIWV4dGVuZGVkWm9uZSkge1xuICAgICAgYyArPSBcIlpcIjtcbiAgICB9IGVsc2UgaWYgKG8ubyA8IDApIHtcbiAgICAgIGMgKz0gXCItXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAvIDYwKSk7XG4gICAgICBjICs9IFwiOlwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gJSA2MCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjICs9IFwiK1wiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKG8ubyAvIDYwKSk7XG4gICAgICBjICs9IFwiOlwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKG8ubyAlIDYwKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4dGVuZGVkWm9uZSkge1xuICAgIGMgKz0gXCJbXCIgKyBvLnpvbmUuaWFuYU5hbWUgKyBcIl1cIjtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuLy8gZGVmYXVsdHMgZm9yIHVuc3BlY2lmaWVkIHVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzXG5jb25zdCBkZWZhdWx0VW5pdFZhbHVlcyA9IHtcbiAgICBtb250aDogMSxcbiAgICBkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9LFxuICBkZWZhdWx0V2Vla1VuaXRWYWx1ZXMgPSB7XG4gICAgd2Vla051bWJlcjogMSxcbiAgICB3ZWVrZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzID0ge1xuICAgIG9yZGluYWw6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9O1xuXG4vLyBVbml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFycywgc29ydGVkIGJ5IGJpZ25lc3NcbmNvbnN0IG9yZGVyZWRVbml0cyA9IFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSxcbiAgb3JkZXJlZFdlZWtVbml0cyA9IFtcbiAgICBcIndlZWtZZWFyXCIsXG4gICAgXCJ3ZWVrTnVtYmVyXCIsXG4gICAgXCJ3ZWVrZGF5XCIsXG4gICAgXCJob3VyXCIsXG4gICAgXCJtaW51dGVcIixcbiAgICBcInNlY29uZFwiLFxuICAgIFwibWlsbGlzZWNvbmRcIixcbiAgXSxcbiAgb3JkZXJlZE9yZGluYWxVbml0cyA9IFtcInllYXJcIiwgXCJvcmRpbmFsXCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdO1xuXG4vLyBzdGFuZGFyZGl6ZSBjYXNlIGFuZCBwbHVyYWxpdHkgaW4gdW5pdHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgIHllYXI6IFwieWVhclwiLFxuICAgIHllYXJzOiBcInllYXJcIixcbiAgICBtb250aDogXCJtb250aFwiLFxuICAgIG1vbnRoczogXCJtb250aFwiLFxuICAgIGRheTogXCJkYXlcIixcbiAgICBkYXlzOiBcImRheVwiLFxuICAgIGhvdXI6IFwiaG91clwiLFxuICAgIGhvdXJzOiBcImhvdXJcIixcbiAgICBtaW51dGU6IFwibWludXRlXCIsXG4gICAgbWludXRlczogXCJtaW51dGVcIixcbiAgICBxdWFydGVyOiBcInF1YXJ0ZXJcIixcbiAgICBxdWFydGVyczogXCJxdWFydGVyXCIsXG4gICAgc2Vjb25kOiBcInNlY29uZFwiLFxuICAgIHNlY29uZHM6IFwic2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRcIixcbiAgICB3ZWVrZGF5OiBcIndlZWtkYXlcIixcbiAgICB3ZWVrZGF5czogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3NudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtudW1iZXJzOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVreWVhcjogXCJ3ZWVrWWVhclwiLFxuICAgIHdlZWt5ZWFyczogXCJ3ZWVrWWVhclwiLFxuICAgIG9yZGluYWw6IFwib3JkaW5hbFwiLFxuICB9W3VuaXQudG9Mb3dlckNhc2UoKV07XG5cbiAgaWYgKCFub3JtYWxpemVkKSB0aHJvdyBuZXcgSW52YWxpZFVuaXRFcnJvcih1bml0KTtcblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdFdpdGhMb2NhbFdlZWtzKHVuaXQpIHtcbiAgc3dpdGNoICh1bml0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwibG9jYWx3ZWVrZGF5XCI6XG4gICAgY2FzZSBcImxvY2Fsd2Vla2RheXNcIjpcbiAgICAgIHJldHVybiBcImxvY2FsV2Vla2RheVwiO1xuICAgIGNhc2UgXCJsb2NhbHdlZWtudW1iZXJcIjpcbiAgICBjYXNlIFwibG9jYWx3ZWVrbnVtYmVyc1wiOlxuICAgICAgcmV0dXJuIFwibG9jYWxXZWVrTnVtYmVyXCI7XG4gICAgY2FzZSBcImxvY2Fsd2Vla3llYXJcIjpcbiAgICBjYXNlIFwibG9jYWx3ZWVreWVhcnNcIjpcbiAgICAgIHJldHVybiBcImxvY2FsV2Vla1llYXJcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVuaXQodW5pdCk7XG4gIH1cbn1cblxuLy8gY2FjaGUgb2Zmc2V0cyBmb3Igem9uZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgdGltZXN0YW1wIHdoZW4gdGhpcyBmdW5jdGlvbiBpc1xuLy8gZmlyc3QgY2FsbGVkLiBXaGVuIHdlIGFyZSBoYW5kbGluZyBhIGRhdGV0aW1lIGZyb20gY29tcG9uZW50cyBsaWtlICh5ZWFyLFxuLy8gbW9udGgsIGRheSwgaG91cikgaW4gYSB0aW1lIHpvbmUsIHdlIG5lZWQgYSBndWVzcyBhYm91dCB3aGF0IHRoZSB0aW1lem9uZVxuLy8gb2Zmc2V0IGlzIHNvIHRoYXQgd2UgY2FuIGNvbnZlcnQgaW50byBhIFVUQyB0aW1lc3RhbXAuIE9uZSB3YXkgaXMgdG8gZmluZCB0aGVcbi8vIG9mZnNldCBvZiBub3cgaW4gdGhlIHpvbmUuIFRoZSBhY3R1YWwgZGF0ZSBtYXkgaGF2ZSBhIGRpZmZlcmVudCBvZmZzZXQgKGZvclxuLy8gZXhhbXBsZSwgaWYgd2UgaGFuZGxlIGEgZGF0ZSBpbiBKdW5lIHdoaWxlIHdlJ3JlIGluIERlY2VtYmVyIGluIGEgem9uZSB0aGF0XG4vLyBvYnNlcnZlcyBEU1QpLCBidXQgd2UgY2FuIGNoZWNrIGFuZCBhZGp1c3QgdGhhdC5cbi8vXG4vLyBXaGVuIGhhbmRsaW5nIG1hbnkgZGF0ZXMsIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQgZm9yIG5vdyBldmVyeSB0aW1lIGlzXG4vLyBleHBlbnNpdmUuIEl0J3MganVzdCBhIGd1ZXNzLCBzbyB3ZSBjYW4gY2FjaGUgdGhlIG9mZnNldCB0byB1c2UgZXZlbiBpZiB3ZVxuLy8gYXJlIHJpZ2h0IG9uIGEgdGltZSBjaGFuZ2UgYm91bmRhcnkgKHdlJ2xsIGp1c3QgY29ycmVjdCBpbiB0aGUgb3RoZXJcbi8vIGRpcmVjdGlvbikuIFVzaW5nIGEgdGltZXN0YW1wIGZyb20gZmlyc3QgcmVhZCBpcyBhIHNsaWdodCBvcHRpbWl6YXRpb24gZm9yXG4vLyBoYW5kbGluZyBkYXRlcyBjbG9zZSB0byB0aGUgY3VycmVudCBkYXRlLCBzaW5jZSB0aG9zZSBkYXRlcyB3aWxsIHVzdWFsbHkgYmVcbi8vIGluIHRoZSBzYW1lIG9mZnNldCAod2UgY291bGQgc2V0IHRoZSB0aW1lc3RhbXAgc3RhdGljYWxseSwgaW5zdGVhZCkuIFdlIHVzZSBhXG4vLyBzaW5nbGUgdGltZXN0YW1wIGZvciBhbGwgem9uZXMgdG8gbWFrZSB0aGluZ3MgYSBiaXQgbW9yZSBwcmVkaWN0YWJsZS5cbi8vXG4vLyBUaGlzIGlzIHNhZmUgZm9yIHF1aWNrRFQgKHVzZWQgYnkgbG9jYWwoKSBhbmQgdXRjKCkpIGJlY2F1c2Ugd2UgZG9uJ3QgZmlsbCBpblxuLy8gaGlnaGVyLW9yZGVyIHVuaXRzIGZyb20gdHNOb3cgKGFzIHdlIGRvIGluIGZyb21PYmplY3QsIHRoaXMgcmVxdWlyZXMgdGhhdFxuLy8gb2Zmc2V0IGlzIGNhbGN1bGF0ZWQgZnJvbSB0c05vdykuXG4vKipcbiAqIEBwYXJhbSB7Wm9uZX0gem9uZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBndWVzc09mZnNldEZvclpvbmUoem9uZSkge1xuICBpZiAoem9uZU9mZnNldFRzID09PSB1bmRlZmluZWQpIHtcbiAgICB6b25lT2Zmc2V0VHMgPSBTZXR0aW5ncy5ub3coKTtcbiAgfVxuXG4gIC8vIERvIG5vdCBjYWNoZSBhbnl0aGluZyBidXQgSUFOQSB6b25lcywgYmVjYXVzZSBpdCBpcyBub3Qgc2FmZSB0byBkbyBzby5cbiAgLy8gR3Vlc3NpbmcgYW4gb2Zmc2V0IHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIHRoZSB6b25lIGNhbiBjYXVzZSB3cm9uZyByZXN1bHRzIGZyb20gZml4T2Zmc2V0XG4gIGlmICh6b25lLnR5cGUgIT09IFwiaWFuYVwiKSB7XG4gICAgcmV0dXJuIHpvbmUub2Zmc2V0KHpvbmVPZmZzZXRUcyk7XG4gIH1cbiAgY29uc3Qgem9uZU5hbWUgPSB6b25lLm5hbWU7XG4gIGxldCBvZmZzZXRHdWVzcyA9IHpvbmVPZmZzZXRHdWVzc0NhY2hlLmdldCh6b25lTmFtZSk7XG4gIGlmIChvZmZzZXRHdWVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0R3Vlc3MgPSB6b25lLm9mZnNldCh6b25lT2Zmc2V0VHMpO1xuICAgIHpvbmVPZmZzZXRHdWVzc0NhY2hlLnNldCh6b25lTmFtZSwgb2Zmc2V0R3Vlc3MpO1xuICB9XG4gIHJldHVybiBvZmZzZXRHdWVzcztcbn1cblxuLy8gdGhpcyBpcyBhIGR1bWJlZCBkb3duIHZlcnNpb24gb2YgZnJvbU9iamVjdCgpIHRoYXQgcnVucyBhYm91dCA2MCUgZmFzdGVyXG4vLyBidXQgZG9lc24ndCBkbyBhbnkgdmFsaWRhdGlvbiwgbWFrZXMgYSBidW5jaCBvZiBhc3N1bXB0aW9ucyBhYm91dCB3aGF0IHVuaXRzXG4vLyBhcmUgcHJlc2VudCwgYW5kIHNvIG9uLlxuZnVuY3Rpb24gcXVpY2tEVChvYmosIG9wdHMpIHtcbiAgY29uc3Qgem9uZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmUpKTtcbiAgfVxuXG4gIGNvbnN0IGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpO1xuXG4gIGxldCB0cywgbztcblxuICAvLyBhc3N1bWUgd2UgaGF2ZSB0aGUgaGlnaGVyLW9yZGVyIHVuaXRzXG4gIGlmICghaXNVbmRlZmluZWQob2JqLnllYXIpKSB7XG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKG9ialt1XSkpIHtcbiAgICAgICAgb2JqW3VdID0gZGVmYXVsdFVuaXRWYWx1ZXNbdV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG9iaik7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldFByb3ZpcyA9IGd1ZXNzT2Zmc2V0Rm9yWm9uZSh6b25lKTtcbiAgICBbdHMsIG9dID0gb2JqVG9UUyhvYmosIG9mZnNldFByb3Zpcywgem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdHMgPSBTZXR0aW5ncy5ub3coKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyB0cywgem9uZSwgbG9jLCBvIH0pO1xufVxuXG5mdW5jdGlvbiBkaWZmUmVsYXRpdmUoc3RhcnQsIGVuZCwgb3B0cykge1xuICBjb25zdCByb3VuZCA9IGlzVW5kZWZpbmVkKG9wdHMucm91bmQpID8gdHJ1ZSA6IG9wdHMucm91bmQsXG4gICAgcm91bmRpbmcgPSBpc1VuZGVmaW5lZChvcHRzLnJvdW5kaW5nKSA/IFwidHJ1bmNcIiA6IG9wdHMucm91bmRpbmcsXG4gICAgZm9ybWF0ID0gKGMsIHVuaXQpID0+IHtcbiAgICAgIGMgPSByb3VuZFRvKGMsIHJvdW5kIHx8IG9wdHMuY2FsZW5kYXJ5ID8gMCA6IDIsIG9wdHMuY2FsZW5kYXJ5ID8gXCJyb3VuZFwiIDogcm91bmRpbmcpO1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gZW5kLmxvYy5jbG9uZShvcHRzKS5yZWxGb3JtYXR0ZXIob3B0cyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChjLCB1bml0KTtcbiAgICB9LFxuICAgIGRpZmZlciA9ICh1bml0KSA9PiB7XG4gICAgICBpZiAob3B0cy5jYWxlbmRhcnkpIHtcbiAgICAgICAgaWYgKCFlbmQuaGFzU2FtZShzdGFydCwgdW5pdCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kLnN0YXJ0T2YodW5pdCkuZGlmZihzdGFydC5zdGFydE9mKHVuaXQpLCB1bml0KS5nZXQodW5pdCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgaWYgKG9wdHMudW5pdCkge1xuICAgIHJldHVybiBmb3JtYXQoZGlmZmVyKG9wdHMudW5pdCksIG9wdHMudW5pdCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHVuaXQgb2Ygb3B0cy51bml0cykge1xuICAgIGNvbnN0IGNvdW50ID0gZGlmZmVyKHVuaXQpO1xuICAgIGlmIChNYXRoLmFicyhjb3VudCkgPj0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3RhcnQgPiBlbmQgPyAtMCA6IDAsIG9wdHMudW5pdHNbb3B0cy51bml0cy5sZW5ndGggLSAxXSk7XG59XG5cbmZ1bmN0aW9uIGxhc3RPcHRzKGFyZ0xpc3QpIHtcbiAgbGV0IG9wdHMgPSB7fSxcbiAgICBhcmdzO1xuICBpZiAoYXJnTGlzdC5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBvcHRzID0gYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpLnNsaWNlKDAsIGFyZ0xpc3QubGVuZ3RoIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCk7XG4gIH1cbiAgcmV0dXJuIFtvcHRzLCBhcmdzXTtcbn1cblxuLyoqXG4gKiBUaW1lc3RhbXAgdG8gdXNlIGZvciBjYWNoZWQgem9uZSBvZmZzZXQgZ3Vlc3NlcyAoZXhwb3NlZCBmb3IgdGVzdClcbiAqL1xubGV0IHpvbmVPZmZzZXRUcztcbi8qKlxuICogQ2FjaGUgZm9yIHpvbmUgb2Zmc2V0IGd1ZXNzZXMgKGV4cG9zZWQgZm9yIHRlc3QpLlxuICpcbiAqIFRoaXMgb3B0aW1pemVzIHF1aWNrRFQgdmlhIGd1ZXNzT2Zmc2V0Rm9yWm9uZSB0byBhdm9pZCByZXBlYXRlZCBjYWxscyBvZlxuICogem9uZS5vZmZzZXQoKS5cbiAqL1xuY29uc3Qgem9uZU9mZnNldEd1ZXNzQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQSBEYXRlVGltZSBpcyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgc3BlY2lmaWMgZGF0ZSBhbmQgdGltZSBhbmQgYWNjb21wYW55aW5nIG1ldGhvZHMuIEl0IGNvbnRhaW5zIGNsYXNzIGFuZCBpbnN0YW5jZSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEEgRGF0ZVRpbWUgY29tcHJpc2VzIG9mOlxuICogKiBBIHRpbWVzdGFtcC4gRWFjaCBEYXRlVGltZSBpbnN0YW5jZSByZWZlcnMgdG8gYSBzcGVjaWZpYyBtaWxsaXNlY29uZCBvZiB0aGUgVW5peCBlcG9jaC5cbiAqICogQSB0aW1lIHpvbmUuIEVhY2ggaW5zdGFuY2UgaXMgY29uc2lkZXJlZCBpbiB0aGUgY29udGV4dCBvZiBhIHNwZWNpZmljIHpvbmUgKGJ5IGRlZmF1bHQgdGhlIGxvY2FsIHN5c3RlbSdzIHpvbmUpLlxuICogKiBDb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdGhhdCBlZmZlY3QgaG93IG91dHB1dCBzdHJpbmdzIGFyZSBmb3JtYXR0ZWQsIHN1Y2ggYXMgYGxvY2FsZWAsIGBudW1iZXJpbmdTeXN0ZW1gLCBhbmQgYG91dHB1dENhbGVuZGFyYC5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmdW5jdGlvbmFsaXR5IGl0IHByb3ZpZGVzOlxuICpcbiAqICogKipDcmVhdGlvbioqOiBUbyBjcmVhdGUgYSBEYXRlVGltZSBmcm9tIGl0cyBjb21wb25lbnRzLCB1c2Ugb25lIG9mIGl0cyBmYWN0b3J5IGNsYXNzIG1ldGhvZHM6IHtAbGluayBEYXRlVGltZS5sb2NhbH0sIHtAbGluayBEYXRlVGltZS51dGN9LCBhbmQgKG1vc3QgZmxleGlibHkpIHtAbGluayBEYXRlVGltZS5mcm9tT2JqZWN0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgc3RhbmRhcmQgc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tSVNPfSwge0BsaW5rIERhdGVUaW1lLmZyb21IVFRQfSwgYW5kIHtAbGluayBEYXRlVGltZS5mcm9tUkZDMjgyMn0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIGN1c3RvbSBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21Gb3JtYXR9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBuYXRpdmUgSlMgZGF0ZSwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tSlNEYXRlfS5cbiAqICogKipHcmVnb3JpYW4gY2FsZW5kYXIgYW5kIHRpbWUqKjogVG8gZXhhbWluZSB0aGUgR3JlZ29yaWFuIHByb3BlcnRpZXMgb2YgYSBEYXRlVGltZSBpbmRpdmlkdWFsbHkgKGkuZSBhcyBvcHBvc2VkIHRvIGNvbGxlY3RpdmVseSB0aHJvdWdoIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0pLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN5ZWFyfSwge0BsaW5rIERhdGVUaW1lI21vbnRofSxcbiAqIHtAbGluayBEYXRlVGltZSNkYXl9LCB7QGxpbmsgRGF0ZVRpbWUjaG91cn0sIHtAbGluayBEYXRlVGltZSNtaW51dGV9LCB7QGxpbmsgRGF0ZVRpbWUjc2Vjb25kfSwge0BsaW5rIERhdGVUaW1lI21pbGxpc2Vjb25kfSBhY2Nlc3NvcnMuXG4gKiAqICoqV2VlayBjYWxlbmRhcioqOiBGb3IgSVNPIHdlZWsgY2FsZW5kYXIgYXR0cmlidXRlcywgc2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjd2Vla1llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjd2Vla051bWJlcn0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjd2Vla2RheX0gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgdGhlIHtAbGluayBEYXRlVGltZSNsb2NhbGV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKjogVG8gdHJhbnNmb3JtIHRoZSBEYXRlVGltZSBpbnRvIG90aGVyIERhdGVUaW1lcywgdXNlIHtAbGluayBEYXRlVGltZSNzZXR9LCB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0sIHtAbGluayBEYXRlVGltZSNzZXRMb2NhbGV9LCB7QGxpbmsgRGF0ZVRpbWUucGx1c30sIHtAbGluayBEYXRlVGltZSNtaW51c30sIHtAbGluayBEYXRlVGltZSNlbmRPZn0sIHtAbGluayBEYXRlVGltZSNzdGFydE9mfSwge0BsaW5rIERhdGVUaW1lI3RvVVRDfSwgYW5kIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfS5cbiAqICogKipPdXRwdXQqKjogVG8gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlfSwge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmVDYWxlbmRhcn0sIHtAbGluayBEYXRlVGltZSN0b0pTT059LCB7QGxpbmsgRGF0ZVRpbWUjdG9JU099LCB7QGxpbmsgRGF0ZVRpbWUjdG9IVFRQfSwge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSwge0BsaW5rIERhdGVUaW1lI3RvUkZDMjgyMn0sIHtAbGluayBEYXRlVGltZSN0b1N0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0sIHtAbGluayBEYXRlVGltZSN0b01pbGxpc30gYW5kIHtAbGluayBEYXRlVGltZSN0b0pTRGF0ZX0uXG4gKlxuICogVGhlcmUncyBwbGVudHkgb3RoZXJzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uLCB0aW1lIHpvbmVzLCBhbHRlcm5hdGl2ZSBjYWxlbmRhcnMsIHZhbGlkaXR5LCBhbmQgc28gb24sIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVRpbWUge1xuICAvKipcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCB6b25lID0gY29uZmlnLnpvbmUgfHwgU2V0dGluZ3MuZGVmYXVsdFpvbmU7XG5cbiAgICBsZXQgaW52YWxpZCA9XG4gICAgICBjb25maWcuaW52YWxpZCB8fFxuICAgICAgKE51bWJlci5pc05hTihjb25maWcudHMpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbCkgfHxcbiAgICAgICghem9uZS5pc1ZhbGlkID8gdW5zdXBwb3J0ZWRab25lKHpvbmUpIDogbnVsbCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cyA9IGlzVW5kZWZpbmVkKGNvbmZpZy50cykgPyBTZXR0aW5ncy5ub3coKSA6IGNvbmZpZy50cztcblxuICAgIGxldCBjID0gbnVsbCxcbiAgICAgIG8gPSBudWxsO1xuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gY29uZmlnLm9sZCAmJiBjb25maWcub2xkLnRzID09PSB0aGlzLnRzICYmIGNvbmZpZy5vbGQuem9uZS5lcXVhbHMoem9uZSk7XG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgW2MsIG9dID0gW2NvbmZpZy5vbGQuYywgY29uZmlnLm9sZC5vXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCBoYXMgYmVlbiBwYXNzZWQgYW5kIHdlIGhhdmUgbm90IGJlZW4gY2FsbGVkIGZyb21cbiAgICAgICAgLy8gY2xvbmUoKSwgd2UgY2FuIHRydXN0IGl0IGFuZCBhdm9pZCB0aGUgb2Zmc2V0IGNhbGN1bGF0aW9uLlxuICAgICAgICBjb25zdCBvdCA9IGlzTnVtYmVyKGNvbmZpZy5vKSAmJiAhY29uZmlnLm9sZCA/IGNvbmZpZy5vIDogem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGMgPSB0c1RvT2JqKHRoaXMudHMsIG90KTtcbiAgICAgICAgaW52YWxpZCA9IE51bWJlci5pc05hTihjLnllYXIpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbDtcbiAgICAgICAgYyA9IGludmFsaWQgPyBudWxsIDogYztcbiAgICAgICAgbyA9IGludmFsaWQgPyBudWxsIDogb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxXZWVrRGF0YSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jID0gYztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm8gPSBvO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkRhdGVUaW1lID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIENPTlNUUlVDVFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmb3IgdGhlIGN1cnJlbnQgaW5zdGFudCwgaW4gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICpcbiAgICogVXNlIFNldHRpbmdzIHRvIG92ZXJyaWRlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oKSAvL34+IG5vdyBpbiB0aGUgSVNPIGZvcm1hdFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7fSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbG9jYWwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5ZWFyXSAtIFRoZSBjYWxlbmRhciB5ZWFyLiBJZiBvbWl0dGVkIChhcyBpbiwgY2FsbCBgbG9jYWwoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKHsgem9uZTogXCJBbWVyaWNhL05ld19Zb3JrXCIgfSkgICAgICAvL34+IG5vdywgaW4gVVMgZWFzdCBjb2FzdCB0aW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCB7IGxvY2FsZTogXCJmclwiIH0pICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDAsIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCB7IHpvbmU6IFwidXRjXCIgfSkgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDAsIGluIFVUQ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUpICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbG9jYWwoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBpbiBVVENcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5ZWFyXSAtIFRoZSBjYWxlbmRhciB5ZWFyLiBJZiBvbWl0dGVkIChhcyBpbiwgY2FsbCBgdXRjKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53ZWVrU2V0dGluZ3NdIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgdXRjKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG5cbiAgICBvcHRzLnpvbmUgPSBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21KU0RhdGUoZGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHMgPSBpc0RhdGUoZGF0ZSkgPyBkYXRlLnZhbHVlT2YoKSA6IE5hTjtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYGZyb21NaWxsaXMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXQsIGJ1dCByZWNlaXZlZCBhICR7dHlwZW9mIG1pbGxpc2Vjb25kc30gd2l0aCB2YWx1ZSAke21pbGxpc2Vjb25kc31gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmRzIDwgLU1BWF9EQVRFIHx8IG1pbGxpc2Vjb25kcyA+IE1BWF9EQVRFKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHBlcmZlY3QgYmVjYXVzZSB3ZSBjYW4gc3RpbGwgZW5kIHVwIG91dCBvZiByYW5nZSBiZWNhdXNlIG9mIGFkZGl0aW9uYWwgc2hpZnRpbmcsIGJ1dCBpdCdzIGEgc3RhcnRcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFwiVGltZXN0YW1wIG91dCBvZiByYW5nZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBtaWxsaXNlY29uZHMsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzIC0gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU2Vjb25kcyhzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKHNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tU2Vjb25kcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBzZWNvbmRzICogMTAwMCxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXInIGFuZCAnaG91cicgd2l0aCByZWFzb25hYmxlIGRlZmF1bHRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyIC0gYSB5ZWFyLCBzdWNoIGFzIDE5ODdcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aCAtIGEgbW9udGgsIDEtMTJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXkgLSBhIGRheSBvZiB0aGUgbW9udGgsIDEtMzEsIGRlcGVuZGluZyBvbiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5vcmRpbmFsIC0gZGF5IG9mIHRoZSB5ZWFyLCAxLTM2NSBvciAzNjZcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrWWVhciAtIGFuIElTTyB3ZWVrIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrTnVtYmVyIC0gYW4gSVNPIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrZGF5IC0gYW4gSVNPIHdlZWtkYXksIDEtNywgd2hlcmUgMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubG9jYWxXZWVrWWVhciAtIGEgd2VlayB5ZWFyLCBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmxvY2FsV2Vla051bWJlciAtIGEgd2VlayBudW1iZXIsIGJldHdlZW4gMSBhbmQgNTIgb3IgNTMsIGRlcGVuZGluZyBvbiB0aGUgeWVhciwgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5sb2NhbFdlZWtkYXkgLSBhIHdlZWtkYXksIDEtNywgd2hlcmUgMSBpcyB0aGUgZmlyc3QgYW5kIDcgaXMgdGhlIGxhc3QgZGF5IG9mIHRoZSB3ZWVrLCBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXIgLSBob3VyIG9mIHRoZSBkYXksIDAtMjNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGUgLSBtaW51dGUgb2YgdGhlIGhvdXIsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmQgLSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kIC0gbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgMC05OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBpbnRlcnByZXQgdGhlIG51bWJlcnMgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHpvbmUuIENhbiB0YWtlIGFueSB2YWx1ZSB0YWtlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc2V0Wm9uZSgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbVxcJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIsIG1vbnRoOiA1LCBkYXk6IDI1fSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIgfSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSkgLy9+PiB0b2RheSBhdCAxMDoyNjowNlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICd1dGMnIH0pLFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdsb2NhbCcgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnQW1lcmljYS9OZXdfWW9yaycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHdlZWtZZWFyOiAyMDE2LCB3ZWVrTnVtYmVyOiAyLCB3ZWVrZGF5OiAzIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzIwMTYtMDEtMTMnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBsb2NhbFdlZWtZZWFyOiAyMDIyLCBsb2NhbFdlZWtOdW1iZXI6IDEsIGxvY2FsV2Vla2RheTogMSB9LCB7IGxvY2FsZTogXCJlbi1VU1wiIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzIwMjEtMTItMjYnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBvYmogPSBvYmogfHwge307XG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRzLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZVVuaXRXaXRoTG9jYWxXZWVrcyk7XG4gICAgY29uc3QgeyBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrIH0gPSB1c2VzTG9jYWxXZWVrVmFsdWVzKG5vcm1hbGl6ZWQsIGxvYyk7XG5cbiAgICBjb25zdCB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgb2Zmc2V0UHJvdmlzID0gIWlzVW5kZWZpbmVkKG9wdHMuc3BlY2lmaWNPZmZzZXQpXG4gICAgICAgID8gb3B0cy5zcGVjaWZpY09mZnNldFxuICAgICAgICA6IHpvbmVUb1VzZS5vZmZzZXQodHNOb3cpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIC8vIGNhc2VzOlxuICAgIC8vIGp1c3QgYSB3ZWVrZGF5IC0+IHRoaXMgd2VlaydzIGluc3RhbmNlIG9mIHRoYXQgd2Vla2RheSwgbm8gd29ycmllc1xuICAgIC8vIChncmVnb3JpYW4gZGF0YSBvciBvcmRpbmFsKSArICh3ZWVrWWVhciBvciB3ZWVrTnVtYmVyKSAtPiBlcnJvclxuICAgIC8vIChncmVnb3JpYW4gbW9udGggb3IgZGF5KSArIG9yZGluYWwgLT4gZXJyb3JcbiAgICAvLyBvdGhlcndpc2UganVzdCB1c2Ugd2Vla3Mgb3Igb3JkaW5hbHMgb3IgZ3JlZ29yaWFuLCBkZXBlbmRpbmcgb24gd2hhdCdzIHNwZWNpZmllZFxuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZVdlZWtEYXRhID0gZGVmaW5pdGVXZWVrRGVmIHx8IChub3JtYWxpemVkLndlZWtkYXkgJiYgIWNvbnRhaW5zR3JlZ29yKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBvdXJzZWx2ZXMgdG8gZGVhbCB3aXRoIGdyZWdvcmlhbiBkYXRlcyBvciB3ZWVrIHN0dWZmXG4gICAgbGV0IHVuaXRzLFxuICAgICAgZGVmYXVsdFZhbHVlcyxcbiAgICAgIG9iak5vdyA9IHRzVG9PYmoodHNOb3csIG9mZnNldFByb3Zpcyk7XG4gICAgaWYgKHVzZVdlZWtEYXRhKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRXZWVrVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdFdlZWtVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9XZWVrKG9iak5vdywgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2Vlayk7XG4gICAgfSBlbHNlIGlmIChjb250YWluc09yZGluYWwpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZE9yZGluYWxVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub09yZGluYWwob2JqTm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdFVuaXRWYWx1ZXM7XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBtaXNzaW5nIHN0dWZmXG4gICAgbGV0IGZvdW5kRmlyc3QgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHUgb2YgdW5pdHMpIHtcbiAgICAgIGNvbnN0IHYgPSBub3JtYWxpemVkW3VdO1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2KSkge1xuICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRGaXJzdCkge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gZGVmYXVsdFZhbHVlc1t1XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBvYmpOb3dbdV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSB2YWx1ZXMgd2UgaGF2ZSBhcmUgaW4gcmFuZ2VcbiAgICBjb25zdCBoaWdoZXJPcmRlckludmFsaWQgPSB1c2VXZWVrRGF0YVxuICAgICAgICA/IGhhc0ludmFsaWRXZWVrRGF0YShub3JtYWxpemVkLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKVxuICAgICAgICA6IGNvbnRhaW5zT3JkaW5hbFxuICAgICAgICA/IGhhc0ludmFsaWRPcmRpbmFsRGF0YShub3JtYWxpemVkKVxuICAgICAgICA6IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG5vcm1hbGl6ZWQpLFxuICAgICAgaW52YWxpZCA9IGhpZ2hlck9yZGVySW52YWxpZCB8fCBoYXNJbnZhbGlkVGltZURhdGEobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgYWN0dWFsIHRpbWVcbiAgICBjb25zdCBncmVnb3JpYW4gPSB1c2VXZWVrRGF0YVxuICAgICAgICA/IHdlZWtUb0dyZWdvcmlhbihub3JtYWxpemVkLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKVxuICAgICAgICA6IGNvbnRhaW5zT3JkaW5hbFxuICAgICAgICA/IG9yZGluYWxUb0dyZWdvcmlhbihub3JtYWxpemVkKVxuICAgICAgICA6IG5vcm1hbGl6ZWQsXG4gICAgICBbdHNGaW5hbCwgb2Zmc2V0RmluYWxdID0gb2JqVG9UUyhncmVnb3JpYW4sIG9mZnNldFByb3Zpcywgem9uZVRvVXNlKSxcbiAgICAgIGluc3QgPSBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogdHNGaW5hbCxcbiAgICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgICBvOiBvZmZzZXRGaW5hbCxcbiAgICAgICAgbG9jLFxuICAgICAgfSk7XG5cbiAgICAvLyBncmVnb3JpYW4gZGF0YSArIHdlZWtkYXkgc2VydmVzIG9ubHkgdG8gdmFsaWRhdGVcbiAgICBpZiAobm9ybWFsaXplZC53ZWVrZGF5ICYmIGNvbnRhaW5zR3JlZ29yICYmIG9iai53ZWVrZGF5ICE9PSBpbnN0LndlZWtkYXkpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgICBcIm1pc21hdGNoZWQgd2Vla2RheVwiLFxuICAgICAgICBgeW91IGNhbid0IHNwZWNpZnkgYm90aCBhIHdlZWtkYXkgb2YgJHtub3JtYWxpemVkLndlZWtkYXl9IGFuZCBhIGRhdGUgb2YgJHtpbnN0LnRvSVNPKCl9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWluc3QuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW5zdC5pbnZhbGlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIElTTyA4NjAxIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLndlZWtTZXR0aW5nc10gLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnLCB7c2V0Wm9uZTogdHJ1ZX0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJywge3pvbmU6ICd1dGMnfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi1XMDUtNCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VJU09EYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSVNPIDg2MDFcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgdGhlIG9mZnNldCBpcyBhbHdheXMgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjM6MTIgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJ0ZyaSwgMjUgTm92IDIwMTYgMTM6MjM6MTIgKzA2MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjMgWicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21SRkMyODIyKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlUkZDMjgyMkRhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJSRkMgMjgyMlwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIEhUVFAgZGF0ZXMgYXJlIGFsd2F5cyBpbiBVVEMsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIHRoZSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZy4gRm9yIEhUVFAgZGF0ZXMsIHRoaXMgaXMgYWx3YXlzIFVUQywgc28gdGhpcyBvcHRpb24gaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgem9uZWAgb3B0aW9uIHRvICd1dGMnLCBidXQgdGhpcyBvcHRpb24gaXMgaW5jbHVkZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggc2ltaWxhciBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biBOb3YgIDYgMDg6NDk6MzcgMTk5NCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21IVFRQKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSFRUUERhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJIVFRQXCIsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gaW5wdXQgc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL3BhcnNpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSB0aGUgbGluayBiZWxvdyBmb3IgdGhlIGZvcm1hdHMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGV4dCkgfHwgaXNVbmRlZmluZWQoZm10KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbUZvcm1hdCByZXF1aXJlcyBhbiBpbnB1dCBzdHJpbmcgYW5kIGEgZm9ybWF0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0cyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSksXG4gICAgICBbdmFscywgcGFyc2VkWm9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRdID0gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgYGZvcm1hdCAke2ZtdH1gLCB0ZXh0LCBzcGVjaWZpY09mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgU1FMIGRhdGUsIHRpbWUsIG9yIGRhdGV0aW1lXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNScpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnLCB7IHNldFpvbmU6IHRydWUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInLCB7IHpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcwOToxMjozNC4zNDInKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU1FMKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlU1FMKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiU1FMXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEYXRlVGltZSBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0ZVRpbWVFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlVGltZS4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRGF0ZVRpbWUobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EYXRlVGltZSkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgZm9ybWF0IHN0cmluZyBmb3IgYSBzZXQgb2Ygb3B0aW9uc1xuICAgKiBAcGFyYW0gZm9ybWF0T3B0c1xuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlRm9ybWF0Rm9yT3B0cyhmb3JtYXRPcHRzLCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCB0b2tlbkxpc3QgPSBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiAhdG9rZW5MaXN0ID8gbnVsbCA6IHRva2VuTGlzdC5tYXAoKHQpID0+ICh0ID8gdC52YWwgOiBudWxsKSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSB0aGUgZnVsbHkgZXhwYW5kZWQgZm9ybWF0IHRva2VuIGZvciB0aGUgbG9jYWxlXG4gICAqIERvZXMgTk9UIHF1b3RlIGNoYXJhY3RlcnMsIHNvIHF1b3RlZCB0b2tlbnMgd2lsbCBub3Qgcm91bmQgdHJpcCBjb3JyZWN0bHlcbiAgICogQHBhcmFtIGZtdFxuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGV4cGFuZEZvcm1hdChmbXQsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gZXhwYW5kZWQubWFwKCh0KSA9PiB0LnZhbCkuam9pbihcIlwiKTtcbiAgfVxuXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIHpvbmVPZmZzZXRUcyA9IHVuZGVmaW5lZDtcbiAgICB6b25lT2Zmc2V0R3Vlc3NDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLy8gSU5GT1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdtb250aCcpOyAvLz0+IDdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdkYXknKTsgLy89PiA0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbdW5pdF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyB2YWxpZC4gSW52YWxpZCBEYXRlVGltZXMgb2NjdXIgd2hlbjpcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgZnJvbSBpbnZhbGlkIGNhbGVuZGFyIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSAxM3RoIG1vbnRoIG9yIEZlYnJ1YXJ5IDMwXG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGJ5IGFuIG9wZXJhdGlvbiBvbiBhbm90aGVyIGludmFsaWQgZGF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIERhdGVUaW1lIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2FsZSBvZiBhIERhdGVUaW1lLCBzdWNoICdlbi1HQicuIFRoZSBsb2NhbGUgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIERhdGVUaW1lLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0cHV0IGNhbGVuZGFyIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2lzbGFtaWMnLiBUaGUgb3V0cHV0IGNhbGVuZGFyIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aW1lIHpvbmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgZ2V0IHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgem9uZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5uYW1lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnllYXIgLy89PiAyMDE3XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnllYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5xdWFydGVyIC8vPT4gMlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguY2VpbCh0aGlzLmMubW9udGggLyAzKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoICgxLTEyKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm1vbnRoIC8vPT4gNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubW9udGggOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoICgxLTMwaXNoKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLmRheSAvLz0+IDI1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91ciBvZiB0aGUgZGF5ICgwLTIzKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDkpLmhvdXIgLy89PiA5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmhvdXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGUgb2YgdGhlIGhvdXIgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzApLm1pbnV0ZSAvLz0+IDMwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWludXRlIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kIG9mIHRoZSBtaW51dGUgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyKS5zZWNvbmQgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQgKDAtOTk5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1MiwgNjU0KS5taWxsaXNlY29uZCAvLz0+IDY1NFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWlsbGlzZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDEyLCAzMSkud2Vla1llYXIgLy89PiAyMDE1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyICgxLTUyaXNoKS5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS53ZWVrTnVtYmVyIC8vPT4gMjFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTEsIDMxKS53ZWVrZGF5IC8vPT4gNFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRlIGlzIG9uIGEgd2Vla2VuZCBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzV2Vla2VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkICYmIHRoaXMubG9jLmdldFdlZWtlbmREYXlzKCkuaW5jbHVkZXModGhpcy53ZWVrZGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2VlayBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZS5cbiAgICogMSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGFuZCA3IGlzIHRoZSBsYXN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICogSWYgdGhlIGxvY2FsZSBhc3NpZ25zIFN1bmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCB0aGVuIGEgZGF0ZSB3aGljaCBpcyBhIFN1bmRheSB3aWxsIHJldHVybiAxLFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvY2FsV2Vla2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyIGFjY29yZGluZyB0byB0aGUgbG9jYWxlLiBEaWZmZXJlbnQgbG9jYWxlcyBhc3NpZ24gd2VlayBudW1iZXJzIGRpZmZlcmVudGx5LFxuICAgKiBiZWNhdXNlIHRoZSB3ZWVrIGNhbiBzdGFydCBvbiBkaWZmZXJlbnQgZGF5cyBvZiB0aGUgd2VlayAoc2VlIGxvY2FsV2Vla2RheSkgYW5kIGJlY2F1c2UgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGRheXNcbiAgICogaXMgcmVxdWlyZWQgZm9yIGEgd2VlayB0byBjb3VudCBhcyB0aGUgZmlyc3Qgd2VlayBvZiBhIHllYXIuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbG9jYWxXZWVrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEodGhpcykud2Vla051bWJlciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgeWVhciBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZS4gRGlmZmVyZW50IGxvY2FsZXMgYXNzaWduIHdlZWsgbnVtYmVycyAoYW5kIHRoZXJlZm9yIHdlZWsgeWVhcnMpXG4gICAqIGRpZmZlcmVudGx5LCBzZWUgbG9jYWxXZWVrTnVtYmVyLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvY2FsV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yZGluYWwgKG1lYW5pbmcgdGhlIGRheSBvZiB0aGUgeWVhcilcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm9yZGluYWwgLy89PiAxNDVcbiAgICogQHR5cGUge251bWJlcnxEYXRlVGltZX1cbiAgICovXG4gIGdldCBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKS5vcmRpbmFsIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhTaG9ydCAvLz0+IE9jdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdG9iZXInLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aExvbmcgLy89PiBPY3RvYmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCB3ZWVrZGF5LCBzdWNoIGFzICdNb24nLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5U2hvcnQgLy89PiBNb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5U2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyB3ZWVrZGF5LCBzdWNoIGFzICdNb25kYXknLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5TG9uZyAvLz0+IE1vbmRheVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVRDIG9mZnNldCBvZiB0aGlzIERhdGVUaW1lIGluIG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkub2Zmc2V0IC8vPT4gLTI0MFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5vZmZzZXQgLy89PiAwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyArdGhpcy5vIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFU1RcIiBvciBcIkVEVFwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lU2hvcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcInNob3J0XCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9uZyBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiIG9yIFwiRWFzdGVybiBEYXlsaWdodCBUaW1lXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVMb25nKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJsb25nXCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoaXMgem9uZSdzIG9mZnNldCBldmVyIGNoYW5nZXMsIGFzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc09mZnNldEZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUuaXNVbml2ZXJzYWwgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkRTVCgpIHtcbiAgICBpZiAodGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogMSwgZGF5OiAxIH0pLm9mZnNldCB8fFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDUgfSkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhvc2UgRGF0ZVRpbWVzIHdoaWNoIGhhdmUgdGhlIHNhbWUgbG9jYWwgdGltZSBhcyB0aGlzIERhdGVUaW1lLCBidXQgYSBkaWZmZXJlbnQgb2Zmc2V0IGZyb20gVVRDXG4gICAqIGluIHRoaXMgRGF0ZVRpbWUncyB6b25lLiBEdXJpbmcgRFNUIGNoYW5nZXMgbG9jYWwgdGltZSBjYW4gYmUgYW1iaWd1b3VzLCBmb3IgZXhhbXBsZVxuICAgKiBgMjAyMy0xMC0yOVQwMjozMDowMGAgaW4gYEV1cm9wZS9CZXJsaW5gIGNhbiBoYXZlIG9mZnNldCBgKzAxOjAwYCBvciBgKzAyOjAwYC5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYm90aCBwb3NzaWJsZSBEYXRlVGltZXMgaWYgdGhpcyBEYXRlVGltZSdzIGxvY2FsIHRpbWUgaXMgYW1iaWd1b3VzLlxuICAgKiBAcmV0dXJucyB7RGF0ZVRpbWVbXX1cbiAgICovXG4gIGdldFBvc3NpYmxlT2Zmc2V0cygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCB0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGNvbnN0IGRheU1zID0gODY0MDAwMDA7XG4gICAgY29uc3QgbWludXRlTXMgPSA2MDAwMDtcbiAgICBjb25zdCBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKHRoaXMuYyk7XG4gICAgY29uc3Qgb0VhcmxpZXIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBkYXlNcyk7XG4gICAgY29uc3Qgb0xhdGVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTICsgZGF5TXMpO1xuXG4gICAgY29uc3QgbzEgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvRWFybGllciAqIG1pbnV0ZU1zKTtcbiAgICBjb25zdCBvMiA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIG9MYXRlciAqIG1pbnV0ZU1zKTtcbiAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCB0czEgPSBsb2NhbFRTIC0gbzEgKiBtaW51dGVNcztcbiAgICBjb25zdCB0czIgPSBsb2NhbFRTIC0gbzIgKiBtaW51dGVNcztcbiAgICBjb25zdCBjMSA9IHRzVG9PYmoodHMxLCBvMSk7XG4gICAgY29uc3QgYzIgPSB0c1RvT2JqKHRzMiwgbzIpO1xuICAgIGlmIChcbiAgICAgIGMxLmhvdXIgPT09IGMyLmhvdXIgJiZcbiAgICAgIGMxLm1pbnV0ZSA9PT0gYzIubWludXRlICYmXG4gICAgICBjMS5zZWNvbmQgPT09IGMyLnNlY29uZCAmJlxuICAgICAgYzEubWlsbGlzZWNvbmQgPT09IGMyLm1pbGxpc2Vjb25kXG4gICAgKSB7XG4gICAgICByZXR1cm4gW2Nsb25lKHRoaXMsIHsgdHM6IHRzMSB9KSwgY2xvbmUodGhpcywgeyB0czogdHMyIH0pXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmlzSW5MZWFwWWVhciAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkxlYXBZZWFyKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMykuZGF5c0luTW9udGggLy89PiAzMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGRheXNJblllYXIodGhpcy55ZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB3ZWVrc0luV2Vla1llYXIodGhpcy53ZWVrWWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyBsb2NhbCB3ZWVrIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAyMCwgNiwge2xvY2FsZTogJ2VuLVVTJ30pLndlZWtzSW5Mb2NhbFdlZWtZZWFyIC8vPT4gNTJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAyMCwgNiwge2xvY2FsZTogJ2RlLURFJ30pLndlZWtzSW5Mb2NhbFdlZWtZZWFyIC8vPT4gNTNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrc0luTG9jYWxXZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IHdlZWtzSW5XZWVrWWVhcihcbiAgICAgICAgICB0aGlzLmxvY2FsV2Vla1llYXIsXG4gICAgICAgICAgdGhpcy5sb2MuZ2V0TWluRGF5c0luRmlyc3RXZWVrKCksXG4gICAgICAgICAgdGhpcy5sb2MuZ2V0U3RhcnRPZldlZWsoKVxuICAgICAgICApXG4gICAgICA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBJbnRsIG9wdGlvbnMgZm9yIHRoaXMgRGF0ZVRpbWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGJlaGF2aW9yIG9mIGZvcm1hdHRpbmcgbWV0aG9kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHRoZSBzYW1lIG9wdGlvbnMgYXMgdG9Mb2NhbGVTdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZWRMb2NhbGVPcHRpb25zKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBGb3JtYXR0ZXIuY3JlYXRlKFxuICAgICAgdGhpcy5sb2MuY2xvbmUob3B0cyksXG4gICAgICBvcHRzXG4gICAgKS5yZXNvbHZlZE9wdGlvbnModGhpcyk7XG4gICAgcmV0dXJuIHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyOiBjYWxlbmRhciB9O1xuICB9XG5cbiAgLy8gVFJBTlNGT1JNXG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBVVEMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0oJ3V0YycpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gb3B0aW9uYWxseSwgYW4gb2Zmc2V0IGZyb20gVVRDIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIG9wdGlvbnMgdG8gcGFzcyB0byBgc2V0Wm9uZSgpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvVVRDKG9mZnNldCA9IDAsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKG9mZnNldCksIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byB0aGUgaG9zdCdzIGxvY2FsIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgc2V0Wm9uZSgnbG9jYWwnKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b0xvY2FsKCkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBzcGVjaWZpZWQgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc2V0dGVyIGtlZXBzIHRoZSB1bmRlcmx5aW5nIHRpbWUgdGhlIHNhbWUgKGFzIGluLCB0aGUgc2FtZSB0aW1lc3RhbXApLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIHJlcG9ydCBkaWZmZXJlbnQgbG9jYWwgdGltZXMgYW5kIGNvbnNpZGVyIERTVHMgd2hlbiBtYWtpbmcgY29tcHV0YXRpb25zLCBhcyB3aXRoIHtAbGluayBEYXRlVGltZSNwbHVzfS4gWW91IG1heSB3aXNoIHRvIHVzZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0gYW5kIHtAbGluayBEYXRlVGltZSN0b1VUQ30gd2hpY2ggcHJvdmlkZSBzaW1wbGUgY29udmVuaWVuY2Ugd3JhcHBlcnMgZm9yIGNvbW1vbmx5IHVzZWQgem9uZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gYSB6b25lIGlkZW50aWZpZXIuIEFzIGEgc3RyaW5nLCB0aGF0IGNhbiBiZSBhbnkgSUFOQSB6b25lIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBmaXhlZC1vZmZzZXQgbmFtZSBvZiB0aGUgZm9ybSAnVVRDKzMnLCBvciB0aGUgc3RyaW5ncyAnbG9jYWwnIG9yICd1dGMnLiBZb3UgbWF5IGFsc28gc3VwcGx5IGFuIGluc3RhbmNlIG9mIGEge0BsaW5rIERhdGVUaW1lI1pvbmV9IGNsYXNzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5rZWVwTG9jYWxUaW1lPWZhbHNlXSAtIElmIHRydWUsIGFkanVzdCB0aGUgdW5kZXJseWluZyB0aW1lIHNvIHRoYXQgdGhlIGxvY2FsIHRpbWUgc3RheXMgdGhlIHNhbWUsIGJ1dCBpbiB0aGUgdGFyZ2V0IHpvbmUuIFlvdSBzaG91bGQgcmFyZWx5IG5lZWQgdGhpcy5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRab25lKHpvbmUsIHsga2VlcExvY2FsVGltZSA9IGZhbHNlLCBrZWVwQ2FsZW5kYXJUaW1lID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgem9uZSA9IG5vcm1hbGl6ZVpvbmUoem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLnpvbmUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKCF6b25lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdUUyA9IHRoaXMudHM7XG4gICAgICBpZiAoa2VlcExvY2FsVGltZSB8fCBrZWVwQ2FsZW5kYXJUaW1lKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGNvbnN0IGFzT2JqID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgICBbbmV3VFNdID0gb2JqVG9UUyhhc09iaiwgb2Zmc2V0R3Vlc3MsIHpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdHM6IG5ld1RTLCB6b25lIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3Igb3V0cHV0Q2FsZW5kYXIuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSB0aGUgcHJvcGVydGllcyB0byBzZXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcmVjb25maWd1cmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5sb2MuY2xvbmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgbG9jIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBKdXN0IGEgY29udmVuaWVudCBhbGlhcyBmb3IgcmVjb25maWd1cmUoeyBsb2NhbGUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnNldExvY2FsZSgnZW4tR0InKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIFlvdSBjYW4gb25seSBzZXQgdW5pdHMgd2l0aCB0aGlzIG1ldGhvZDsgZm9yIFwic2V0dGluZ1wiIG1ldGFkYXRhLCBzZWUge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSBhbmQge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhbHNvIHN1cHBvcnRzIHNldHRpbmcgbG9jYWxlLWJhc2VkIHdlZWsgdW5pdHMsIGkuZS4gYGxvY2FsV2Vla2RheWAsIGBsb2NhbFdlZWtOdW1iZXJgIGFuZCBgbG9jYWxXZWVrWWVhcmAuXG4gICAqIFRoZXkgY2Fubm90IGJlIG1peGVkIHdpdGggSVNPLXdlZWsgdW5pdHMgbGlrZSBgd2Vla2RheWAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IGhvdXI6IDgsIG1pbnV0ZTogMzAgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgd2Vla2RheTogNSB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDA1LCBvcmRpbmFsOiAyMzQgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIG5vcm1hbGl6ZVVuaXRXaXRoTG9jYWxXZWVrcyk7XG4gICAgY29uc3QgeyBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrIH0gPSB1c2VzTG9jYWxXZWVrVmFsdWVzKG5vcm1hbGl6ZWQsIHRoaXMubG9jKTtcblxuICAgIGNvbnN0IHNldHRpbmdXZWVrU3R1ZmYgPVxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrWWVhcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla051bWJlcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla2RheSksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyO1xuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGxldCBtaXhlZDtcbiAgICBpZiAoc2V0dGluZ1dlZWtTdHVmZikge1xuICAgICAgbWl4ZWQgPSB3ZWVrVG9HcmVnb3JpYW4oXG4gICAgICAgIHsgLi4uZ3JlZ29yaWFuVG9XZWVrKHRoaXMuYywgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayksIC4uLm5vcm1hbGl6ZWQgfSxcbiAgICAgICAgbWluRGF5c0luRmlyc3RXZWVrLFxuICAgICAgICBzdGFydE9mV2Vla1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpKSB7XG4gICAgICBtaXhlZCA9IG9yZGluYWxUb0dyZWdvcmlhbih7IC4uLmdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLCAuLi5ub3JtYWxpemVkIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaXhlZCA9IHsgLi4udGhpcy50b09iamVjdCgpLCAuLi5ub3JtYWxpemVkIH07XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBzZXQgdGhlIGRheSBidXQgd2UgZW5kZWQgdXAgb24gYW4gb3ZlcmZsb3cgZGF0ZSxcbiAgICAgIC8vIHVzZSB0aGUgbGFzdCBkYXkgb2YgdGhlIHJpZ2h0IG1vbnRoXG4gICAgICBpZiAoaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpKSB7XG4gICAgICAgIG1peGVkLmRheSA9IE1hdGgubWluKGRheXNJbk1vbnRoKG1peGVkLnllYXIsIG1peGVkLm1vbnRoKSwgbWl4ZWQuZGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbdHMsIG9dID0gb2JqVG9UUyhtaXhlZCwgdGhpcy5vLCB0aGlzLnpvbmUpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzLCBvIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqXG4gICAqIEFkZGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgb3IgbWlsbGlzZWNvbmRzIGluY3JlYXNlcyB0aGUgdGltZXN0YW1wIGJ5IHRoZSByaWdodCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBBZGRpbmcgZGF5cywgbW9udGhzLCBvciB5ZWFycyBzaGlmdHMgdGhlIGNhbGVuZGFyLCBhY2NvdW50aW5nIGZvciBEU1RzIGFuZCBsZWFwIHllYXJzIGFsb25nIHRoZSB3YXkuIFRodXMsIGBkdC5wbHVzKHsgaG91cnM6IDI0IH0pYCBtYXkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHRpbWUgdGhhbiBgZHQucGx1cyh7IGRheXM6IDEgfSlgIGlmIHRoZXJlJ3MgYSBEU1Qgc2hpZnQgaW4gYmV0d2Vlbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKDEyMykgLy9+PiBpbiAxMjMgbWlsbGlzZWNvbmRzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBtaW51dGVzOiAxNSB9KSAvL34+IGluIDE1IG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkgLy9+PiB0aGlzIHRpbWUgdG9tb3Jyb3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IC0xIH0pIC8vfj4gdGhpcyB0aW1lIHllc3RlcmRheVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0IGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNwbHVzfVxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbikubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIGFkanVzdFRpbWUodGhpcywgZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSB1bml0IG9mIHRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGJlZ2lubmluZyBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudXNlTG9jYWxlV2Vla3M9ZmFsc2VdIC0gSWYgdHJ1ZSwgdXNlIHdlZWtzIGJhc2VkIG9uIHRoZSBsb2NhbGUsIGkuZS4gdXNlIHRoZSBsb2NhbGUtZGVwZW5kZW50IHN0YXJ0IG9mIHRoZSB3ZWVrXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ21vbnRoJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3llYXInKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignd2VlaycpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAzJywgd2Vla3MgYWx3YXlzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2RheScpLnRvSVNPVGltZSgpOyAvLz0+ICcwMDowMC4wMDAtMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdob3VyJykudG9JU09UaW1lKCk7IC8vPT4gJzA1OjAwOjAwLjAwMC0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGFydE9mKHVuaXQsIHsgdXNlTG9jYWxlV2Vla3MgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBvID0ge30sXG4gICAgICBub3JtYWxpemVkVW5pdCA9IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCk7XG4gICAgc3dpdGNoIChub3JtYWxpemVkVW5pdCkge1xuICAgICAgY2FzZSBcInllYXJzXCI6XG4gICAgICAgIG8ubW9udGggPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInF1YXJ0ZXJzXCI6XG4gICAgICBjYXNlIFwibW9udGhzXCI6XG4gICAgICAgIG8uZGF5ID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJ3ZWVrc1wiOlxuICAgICAgY2FzZSBcImRheXNcIjpcbiAgICAgICAgby5ob3VyID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICBvLm1pbnV0ZSA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBvLnNlY29uZCA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICBvLm1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlsbGlzZWNvbmRzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gbm8gZGVmYXVsdCwgaW52YWxpZCB1bml0cyB0aHJvdyBpbiBub3JtYWxpemVVbml0KClcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZFVuaXQgPT09IFwid2Vla3NcIikge1xuICAgICAgaWYgKHVzZUxvY2FsZVdlZWtzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZXZWVrID0gdGhpcy5sb2MuZ2V0U3RhcnRPZldlZWsoKTtcbiAgICAgICAgY29uc3QgeyB3ZWVrZGF5IH0gPSB0aGlzO1xuICAgICAgICBpZiAod2Vla2RheSA8IHN0YXJ0T2ZXZWVrKSB7XG4gICAgICAgICAgby53ZWVrTnVtYmVyID0gdGhpcy53ZWVrTnVtYmVyIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBvLndlZWtkYXkgPSBzdGFydE9mV2VlaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLmNlaWwodGhpcy5tb250aCAvIDMpO1xuICAgICAgby5tb250aCA9IChxIC0gMSkgKiAzICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQobyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBlbmQgKG1lYW5pbmcgdGhlIGxhc3QgbWlsbGlzZWNvbmQpIG9mIGEgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGVuZCBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudXNlTG9jYWxlV2Vla3M9ZmFsc2VdIC0gSWYgdHJ1ZSwgdXNlIHdlZWtzIGJhc2VkIG9uIHRoZSBsb2NhbGUsIGkuZS4gdXNlIHRoZSBsb2NhbGUtZGVwZW5kZW50IHN0YXJ0IG9mIHRoZSB3ZWVrXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCdtb250aCcpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZigneWVhcicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMTItMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignd2VlaycpLnRvSVNPKCk7IC8vID0+ICcyMDE0LTAzLTA5VDIzOjU5OjU5Ljk5OS0wNTowMCcsIHdlZWtzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdkYXknKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdob3VyJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QwNTo1OTo1OS45OTktMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgZW5kT2YodW5pdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gdGhpcy5wbHVzKHsgW3VuaXRdOiAxIH0pXG4gICAgICAgICAgLnN0YXJ0T2YodW5pdCwgb3B0cylcbiAgICAgICAgICAubWludXMoMSlcbiAgICAgIDogdGhpcztcbiAgfVxuXG4gIC8vIE9VVFBVVFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGUgZm9ybWF0dGluZyB0b29sLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9mb3JtYXR0aW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBBcHIgMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZnInKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdChcIkhIICdob3VycyBhbmQnIG1tICdtaW51dGVzJ1wiKSAvLz0+ICcyMCBob3VycyBhbmQgNTUgbWludXRlcydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MucmVkZWZhdWx0VG9FTihvcHRzKSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXMgYERhdGVUaW1lLkRBVEVfRlVMTGAgb3IgYERhdGVUaW1lLlRJTUVfU0lNUExFYC5cbiAgICogVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBEYXRlVGltZSBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0T3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiA0LzIwLzIwMTdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdlbi1nYicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gJzIwLzA0LzIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gJ0FwcmlsIDIwLCAyMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnInIH0pOyAvLz0+ICcyOCBhb8O7dCAyMDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gJzExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFVElNRV9TSE9SVCk7IC8vPT4gJzQvMjAvMjAxNywgMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ2xvbmcnLCBtb250aDogJ2xvbmcnLCBkYXk6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1cnNkYXksIEFwcmlsIDIwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1LCBBcHIgMjAsIDExOjI3IEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcsIGhvdXJDeWNsZTogJ2gyMycgfSk7IC8vPT4gJzExOjMyJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdERhdGVUaW1lKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmb3JtYXQgXCJwYXJ0c1wiLCBtZWFuaW5nIGluZGl2aWR1YWwgdG9rZW5zIGFsb25nIHdpdGggbWV0YWRhdGEuIFRoaXMgaXMgYWxsb3dzIGNhbGxlcnMgdG8gcG9zdC1wcm9jZXNzIGluZGl2aWR1YWwgc2VjdGlvbnMgb2YgdGhlIGZvcm1hdHRlZCBvdXRwdXQuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0L2Zvcm1hdFRvUGFydHNcbiAgICogQHBhcmFtIG9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMsIHNhbWUgYXMgYHRvTG9jYWxlU3RyaW5nYC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVQYXJ0cygpOyAvLz0+IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdkYXknLCB2YWx1ZTogJzI1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbW9udGgnLCB2YWx1ZTogJzA1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAneWVhcicsIHZhbHVlOiAnMTk4MicgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiBdXG4gICAqL1xuICB0b0xvY2FsZVBhcnRzKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgb3B0cykuZm9ybWF0RGF0ZVRpbWVQYXJ0cyh0aGlzKVxuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9ZmFsc2VdIC0gYWRkIHRoZSB0aW1lIHpvbmUgZm9ybWF0IGV4dGVuc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByZWNpc2lvbj0nbWlsbGlzZWNvbmRzJ10gLSB0cnVuY2F0ZSBvdXRwdXQgdG8gZGVzaXJlZCBwcmVzaWNpb246ICd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnIG9yICdtaWxsaXNlY29uZHMnLiBXaGVuIHByZWNpc2lvbiBhbmQgc3VwcHJlc3NTZWNvbmRzIG9yIHN1cHByZXNzTWlsbGlzZWNvbmRzIGFyZSB1c2VkIHRvZ2V0aGVyLCBwcmVjaXNpb24gc2V0cyB0aGUgbWF4aW11bSB1bml0IHNob3duIGluIHRoZSBvdXRwdXQsIGhvd2V2ZXIgc2Vjb25kcyBvciBtaWxsaXNlY29uZHMgd2lsbCBzdGlsbCBiZSBzdXBwcmVzc2VkIGlmIHRoZXkgYXJlIDAuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgzLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBwcmVjaXNpb246ICdkYXknIH0pIC8vPT4gJzIwMTctMDQtMjJaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IHByZWNpc2lvbjogJ21pbnV0ZScgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0N1onXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICAgKi9cbiAgdG9JU08oe1xuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICAgIHByZWNpc2lvbiA9IFwibWlsbGlzZWNvbmRzXCIsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcmVjaXNpb24gPSBub3JtYWxpemVVbml0KHByZWNpc2lvbik7XG4gICAgY29uc3QgZXh0ID0gZm9ybWF0ID09PSBcImV4dGVuZGVkXCI7XG5cbiAgICBsZXQgYyA9IHRvSVNPRGF0ZSh0aGlzLCBleHQsIHByZWNpc2lvbik7XG4gICAgaWYgKG9yZGVyZWRVbml0cy5pbmRleE9mKHByZWNpc2lvbikgPj0gMykgYyArPSBcIlRcIjtcbiAgICBjICs9IHRvSVNPVGltZShcbiAgICAgIHRoaXMsXG4gICAgICBleHQsXG4gICAgICBzdXBwcmVzc1NlY29uZHMsXG4gICAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgICAgIGluY2x1ZGVPZmZzZXQsXG4gICAgICBleHRlbmRlZFpvbmUsXG4gICAgICBwcmVjaXNpb25cbiAgICApO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgZGF0ZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJlY2lzaW9uPSdkYXknXSAtIHRydW5jYXRlIG91dHB1dCB0byBkZXNpcmVkIHByZWNpc2lvbjogJ3llYXJzJywgJ21vbnRocycsIG9yICdkYXlzJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxOTgyMDUyNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoeyBwcmVjaXNpb246ICdtb250aCcgfSkgLy89PiAnMTk4Mi0wNSdcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gICAqL1xuICB0b0lTT0RhdGUoeyBmb3JtYXQgPSBcImV4dGVuZGVkXCIsIHByZWNpc2lvbiA9IFwiZGF5XCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiLCBub3JtYWxpemVVbml0KHByZWNpc2lvbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3Mgd2VlayBkYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09XZWVrRGF0ZSgpIC8vPT4gJzE5ODItVzIxLTInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPV2Vla0RhdGUoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcImtra2stJ1cnV1ctY1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHRpbWUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT10cnVlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wcmVjaXNpb249J21pbGxpc2Vjb25kcyddIC0gdHJ1bmNhdGUgb3V0cHV0IHRvIGRlc2lyZWQgcHJlc2ljaW9uOiAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJyBvciAnbWlsbGlzZWNvbmRzJy4gV2hlbiBwcmVjaXNpb24gYW5kIHN1cHByZXNzU2Vjb25kcyBvciBzdXBwcmVzc01pbGxpc2Vjb25kcyBhcmUgdXNlZCB0b2dldGhlciwgcHJlY2lzaW9uIHNldHMgdGhlIG1heGltdW0gdW5pdCBzaG93biBpbiB0aGUgb3V0cHV0LCBob3dldmVyIHNlY29uZHMgb3IgbWlsbGlzZWNvbmRzIHdpbGwgc3RpbGwgYmUgc3VwcHJlc3NlZCBpZiB0aGV5IGFyZSAwLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSgpIC8vPT4gJzA3OjM0OjE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMDc6MzRaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcwNzM0MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QwNzozNDoxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0LCBzZWNvbmQ6IDU2IH0pLnRvSVNPVGltZSh7IHByZWNpc2lvbjogJ21pbnV0ZScgfSkgLy89PiAnMDc6MzRaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUoe1xuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgaW5jbHVkZVByZWZpeCA9IGZhbHNlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgICBwcmVjaXNpb24gPSBcIm1pbGxpc2Vjb25kc1wiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJlY2lzaW9uID0gbm9ybWFsaXplVW5pdChwcmVjaXNpb24pO1xuICAgIGxldCBjID0gaW5jbHVkZVByZWZpeCAmJiBvcmRlcmVkVW5pdHMuaW5kZXhPZihwcmVjaXNpb24pID49IDMgPyBcIlRcIiA6IFwiXCI7XG4gICAgcmV0dXJuIChcbiAgICAgIGMgK1xuICAgICAgdG9JU09UaW1lKFxuICAgICAgICB0aGlzLFxuICAgICAgICBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIixcbiAgICAgICAgc3VwcHJlc3NTZWNvbmRzLFxuICAgICAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgICAgICAgaW5jbHVkZU9mZnNldCxcbiAgICAgICAgZXh0ZW5kZWRab25lLFxuICAgICAgICBwcmVjaXNpb25cbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuIFRoZSBvdXRwdXQgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiBHTVQuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gICAqL1xuICB0b1NRTERhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXRTcGFjZT10cnVlXSAtIGluY2x1ZGUgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHRpbWUgYW5kIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVab25lOiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxUaW1lKHsgaW5jbHVkZU9mZnNldCA9IHRydWUsIGluY2x1ZGVab25lID0gZmFsc2UsIGluY2x1ZGVPZmZzZXRTcGFjZSA9IHRydWUgfSA9IHt9KSB7XG4gICAgbGV0IGZtdCA9IFwiSEg6bW06c3MuU1NTXCI7XG5cbiAgICBpZiAoaW5jbHVkZVpvbmUgfHwgaW5jbHVkZU9mZnNldCkge1xuICAgICAgaWYgKGluY2x1ZGVPZmZzZXRTcGFjZSkge1xuICAgICAgICBmbXQgKz0gXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZVpvbmUpIHtcbiAgICAgICAgZm10ICs9IFwielwiO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICAgIGZtdCArPSBcIlpaXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBmbXQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IHRydWUgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUwob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnRvU1FMRGF0ZSgpfSAke3RoaXMudG9TUUxUaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9JU08oKSA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB0aGUgUkVQTC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGBEYXRlVGltZSB7IHRzOiAke3RoaXMudG9JU08oKX0sIHpvbmU6ICR7dGhpcy56b25lLm5hbWV9LCBsb2NhbGU6ICR7dGhpcy5sb2NhbGV9IH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYERhdGVUaW1lIHsgSW52YWxpZCwgcmVhc29uOiAke3RoaXMuaW52YWxpZFJlYXNvbn0gfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLiBBbGlhcyBvZiB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyAoaW5jbHVkaW5nIG1pbGxpc2Vjb25kcyBpbiB0aGUgZnJhY3Rpb25hbCBwYXJ0KSBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgKGFzIGEgd2hvbGUgbnVtYmVyKSBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1VuaXhJbnRlZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmZsb29yKHRoaXMudHMgLyAxMDAwKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQlNPTiBzZXJpYWxpemFibGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNEYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEYXRlVGltZSdzIHllYXIsIG1vbnRoLCBkYXksIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQ29uZmlnPWZhbHNlXSAtIGluY2x1ZGUgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGluIHRoZSBvdXRwdXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3Qob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcblxuICAgIGNvbnN0IGJhc2UgPSB7IC4uLnRoaXMuYyB9O1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5vdXRwdXRDYWxlbmRhciA9IHRoaXMub3V0cHV0Q2FsZW5kYXI7XG4gICAgICBiYXNlLm51bWJlcmluZ1N5c3RlbSA9IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIGJhc2UubG9jYWxlID0gdGhpcy5sb2MubG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBEYXRlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfVxuXG4gIC8vIENPTVBBUkVcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIERhdGVUaW1lcyBhcyBhIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIERhdGVUaW1lIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGkxID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4Mi0wNS0yNVQwOTo0NScpLFxuICAgKiAgICAgaTIgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgzLTEwLTE0VDEwOjMwJyk7XG4gICAqIGkyLmRpZmYoaTEpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogNDM4MDc1MDAwMDAgfVxuICAgKiBpMi5kaWZmKGkxLCAnaG91cnMnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTIxNjguNzUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LjAzMTI1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cycsICdob3VycyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOSwgaG91cnM6IDAuNzUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmYob3RoZXJEYXRlVGltZSwgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlckRhdGVUaW1lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwiY3JlYXRlZCBieSBkaWZmaW5nIGFuIGludmFsaWQgRGF0ZVRpbWVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyT3B0cyA9IHsgbG9jYWxlOiB0aGlzLmxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgLi4ub3B0cyB9O1xuXG4gICAgY29uc3QgdW5pdHMgPSBtYXliZUFycmF5KHVuaXQpLm1hcChEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIG90aGVySXNMYXRlciA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpID4gdGhpcy52YWx1ZU9mKCksXG4gICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICBsYXRlciA9IG90aGVySXNMYXRlciA/IG90aGVyRGF0ZVRpbWUgOiB0aGlzLFxuICAgICAgZGlmZmVkID0gZGlmZihlYXJsaWVyLCBsYXRlciwgdW5pdHMsIGR1ck9wdHMpO1xuXG4gICAgcmV0dXJuIG90aGVySXNMYXRlciA/IGRpZmZlZC5uZWdhdGUoKSA6IGRpZmZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmZOb3codW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmRpZmYoRGF0ZVRpbWUubm93KCksIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCBzcGFubmluZyBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIGFub3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBlbmQgcG9pbnQgb2YgdGhlIEludGVydmFsXG4gICAqIEByZXR1cm4ge0ludGVydmFsfERhdGVUaW1lfVxuICAgKi9cbiAgdW50aWwob3RoZXJEYXRlVGltZSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHRoaXMsIG90aGVyRGF0ZVRpbWUpIDogdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIERhdGVUaW1lIGlzIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZSBhcyBhbm90aGVyIERhdGVUaW1lLlxuICAgKiBIaWdoZXItb3JkZXIgdW5pdHMgbXVzdCBhbHNvIGJlIGlkZW50aWNhbCBmb3IgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYHRydWVgLlxuICAgKiBOb3RlIHRoYXQgdGltZSB6b25lcyBhcmUgKippZ25vcmVkKiogaW4gdGhpcyBjb21wYXJpc29uLCB3aGljaCBjb21wYXJlcyB0aGUgKipsb2NhbCoqIGNhbGVuZGFyIHRpbWUuIFVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0gdG8gY29udmVydCBvbmUgb2YgdGhlIGRhdGVzIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudXNlTG9jYWxlV2Vla3M9ZmFsc2VdIC0gSWYgdHJ1ZSwgdXNlIHdlZWtzIGJhc2VkIG9uIHRoZSBsb2NhbGUsIGkuZS4gdXNlIHRoZSBsb2NhbGUtZGVwZW5kZW50IHN0YXJ0IG9mIHRoZSB3ZWVrOyBvbmx5IHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZSBpcyB1c2VkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLmhhc1NhbWUob3RoZXJEVCwgJ2RheScpOyAvL34+IHRydWUgaWYgb3RoZXJEVCBpcyBpbiB0aGUgc2FtZSBjdXJyZW50IGNhbGVuZGFyIGRheVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZShvdGhlckRhdGVUaW1lLCB1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGlucHV0TXMgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKTtcbiAgICBjb25zdCBhZGp1c3RlZFRvWm9uZSA9IHRoaXMuc2V0Wm9uZShvdGhlckRhdGVUaW1lLnpvbmUsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKFxuICAgICAgYWRqdXN0ZWRUb1pvbmUuc3RhcnRPZih1bml0LCBvcHRzKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gYWRqdXN0ZWRUb1pvbmUuZW5kT2YodW5pdCwgb3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEYXRlVGltZXMgYXJlIGVxdWFsIGlmIGFuZCBvbmx5IGlmIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIG1pbGxpc2Vjb25kLCBoYXZlIHRoZSBzYW1lIHpvbmUgYW5kIGxvY2F0aW9uLCBhbmQgYXJlIGJvdGggdmFsaWQuXG4gICAqIFRvIGNvbXBhcmUganVzdCB0aGUgbWlsbGlzZWNvbmQgdmFsdWVzLCB1c2UgYCtkdDEgPT09ICtkdDJgLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlciAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNWYWxpZCAmJlxuICAgICAgb3RoZXIuaXNWYWxpZCAmJlxuICAgICAgdGhpcy52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKSAmJlxuICAgICAgdGhpcy56b25lLmVxdWFscyhvdGhlci56b25lKSAmJlxuICAgICAgdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0aGlzIHRpbWUgcmVsYXRpdmUgdG8gbm93LCBzdWNoIGFzIFwiaW4gdHdvIGRheXNcIi4gQ2FuIG9ubHkgaW50ZXJuYXRpb25hbGl6ZSBpZiB5b3VyXG4gICAqIHBsYXRmb3JtIHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LiBSb3VuZHMgdG93YXJkcyB6ZXJvIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdHlsZT1cImxvbmdcIl0gLSB0aGUgc3R5bGUgb2YgdW5pdHMsIG11c3QgYmUgXCJsb25nXCIsIFwic2hvcnRcIiwgb3IgXCJuYXJyb3dcIlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdCBvciBhcnJheSBvZiB1bml0czsgaWYgb21pdHRlZCwgb3IgYW4gYXJyYXksIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSBiZXN0IHVuaXQuIFVzZSBhbiBhcnJheSBvciBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIG9yIFwic2Vjb25kc1wiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHJvdW5kIHRoZSBudW1iZXJzIGluIHRoZSBvdXRwdXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yb3VuZGluZz1cInRydW5jXCJdIC0gcm91bmRpbmcgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nIHRoZSBudW1iZXJzIGluIHRoZSBvdXRwdXQuIENhbiBiZSBcInRydW5jXCIgKHRvd2FyZCB6ZXJvKSwgXCJleHBhbmRcIiAoYXdheSBmcm9tIHplcm8pLCBcInJvdW5kXCIsIFwiZmxvb3JcIiwgb3IgXCJjZWlsXCIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nPTBdIC0gcGFkZGluZyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgYWxsb3dzIHlvdSB0byByb3VuZCB1cCB0aGUgcmVzdWx0IGlmIGl0IGZpdHMgaW5zaWRlIHRoZSB0aHJlc2hvbGQuIERvbid0IHVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIHtyb3VuZDogZmFsc2V9IGJlY2F1c2UgdGhlIGRlY2ltYWwgb3V0cHV0IHdpbGwgaW5jbHVkZSB0aGUgcGFkZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJpbiAxIGRheVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnRvUmVsYXRpdmUoeyBkYXlzOiAxIH0pIC8vPT4gXCJkZW50cm8gZGUgMSBkw61hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nID8gKHRoaXMgPCBiYXNlID8gLW9wdGlvbnMucGFkZGluZyA6IG9wdGlvbnMucGFkZGluZykgOiAwO1xuICAgIGxldCB1bml0cyA9IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl07XG4gICAgbGV0IHVuaXQgPSBvcHRpb25zLnVuaXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51bml0KSkge1xuICAgICAgdW5pdHMgPSBvcHRpb25zLnVuaXQ7XG4gICAgICB1bml0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKGJhc2UsIHRoaXMucGx1cyhwYWRkaW5nKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYWx3YXlzXCIsXG4gICAgICB1bml0cyxcbiAgICAgIHVuaXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXksIHN1Y2ggYXMgXCJ5ZXN0ZXJkYXlcIiBvciBcIm5leHQgbW9udGhcIi5cbiAgICogT25seSBpbnRlcm5hdGlvbmFsaXplcyBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCJ0b21vcnJvd1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiXCJtYcOxYW5hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRlbWFpblwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlQ2FsZW5kYXIob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksIHRoaXMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImF1dG9cIixcbiAgICAgIHVuaXRzOiBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIl0sXG4gICAgICBjYWxlbmRhcnk6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW4gb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1pbmltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtaW4gRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1pbiguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWluIHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1pbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXggb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1heGltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtYXggRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1heCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4IHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1heCk7XG4gIH1cblxuICAvLyBNSVNDXG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gaG93IGEgc3RyaW5nIHdvdWxkIGJlIHBhcnNlZCBieSBmcm9tRm9ybWF0KClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSBkZXNjcmlwdGlvbilcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRha2VuIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdGlvbnMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIHJldHVybiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdEV4cGxhaW4gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmdFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBwYXJzZXIgZm9yIGBmbXRgIHVzaW5nIHRoZSBnaXZlbiBsb2NhbGUuIFRoaXMgcGFyc2VyIGNhbiBiZSBwYXNzZWRcbiAgICogdG8ge0BsaW5rIERhdGVUaW1lLmZyb21Gb3JtYXRQYXJzZXJ9IHRvIGEgcGFyc2UgYSBkYXRlIGluIHRoaXMgZm9ybWF0LiBUaGlzXG4gICAqIGNhbiBiZSB1c2VkIHRvIG9wdGltaXplIGNhc2VzIHdoZXJlIG1hbnkgZGF0ZXMgbmVlZCB0byBiZSBwYXJzZWQgaW4gYVxuICAgKiBzcGVjaWZpYyBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZVxuICAgKiBkZXNjcmlwdGlvbilcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHVzZWQgdG8gc2V0IGxvY2FsZSBhbmQgbnVtYmVyaW5nU3lzdGVtXG4gICAqIGZvciBwYXJzZXJcbiAgICogQHJldHVybnMge1Rva2VuUGFyc2VyfSAtIG9wYXF1ZSBvYmplY3QgdG8gYmUgdXNlZFxuICAgKi9cbiAgc3RhdGljIGJ1aWxkRm9ybWF0UGFyc2VyKGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRva2VuUGFyc2VyKGxvY2FsZVRvVXNlLCBmbXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gaW5wdXQgc3RyaW5nIGFuZCBmb3JtYXQgcGFyc2VyLlxuICAgKlxuICAgKiBUaGUgZm9ybWF0IHBhcnNlciBtdXN0IGhhdmUgYmVlbiBjcmVhdGVkIHdpdGggdGhlIHNhbWUgbG9jYWxlIGFzIHRoaXMgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7VG9rZW5QYXJzZXJ9IGZvcm1hdFBhcnNlciAtIHBhcnNlciBmcm9tIHtAbGluayBEYXRlVGltZS5idWlsZEZvcm1hdFBhcnNlcn1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRha2VuIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcmV0dXJucyB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdFBhcnNlcih0ZXh0LCBmb3JtYXRQYXJzZXIsIG9wdHMgPSB7fSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmb3JtYXRQYXJzZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIFwiZnJvbUZvcm1hdFBhcnNlciByZXF1aXJlcyBhbiBpbnB1dCBzdHJpbmcgYW5kIGEgZm9ybWF0IHBhcnNlclwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdHMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgaWYgKCFsb2NhbGVUb1VzZS5lcXVhbHMoZm9ybWF0UGFyc2VyLmxvY2FsZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYGZyb21Gb3JtYXRQYXJzZXIgY2FsbGVkIHdpdGggYSBsb2NhbGUgb2YgJHtsb2NhbGVUb1VzZX0sIGAgK1xuICAgICAgICAgIGBidXQgdGhlIGZvcm1hdCBwYXJzZXIgd2FzIGNyZWF0ZWQgZm9yICR7Zm9ybWF0UGFyc2VyLmxvY2FsZX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbiB9ID0gZm9ybWF0UGFyc2VyLmV4cGxhaW5Gcm9tVG9rZW5zKHRleHQpO1xuXG4gICAgaWYgKGludmFsaWRSZWFzb24pIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWRSZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZShcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICB6b25lLFxuICAgICAgICBvcHRzLFxuICAgICAgICBgZm9ybWF0ICR7Zm9ybWF0UGFyc2VyLmZvcm1hdH1gLFxuICAgICAgICB0ZXh0LFxuICAgICAgICBzcGVjaWZpY09mZnNldFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBGT1JNQVQgUFJFU0VUU1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlIDEwLzE0LzE5ODNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCBPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdUdWVzZGF5LCBPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRURUJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgMTQgT2N0IDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyaWVuZGx5RGF0ZVRpbWUoZGF0ZVRpbWVpc2gpIHtcbiAgaWYgKERhdGVUaW1lLmlzRGF0ZVRpbWUoZGF0ZVRpbWVpc2gpKSB7XG4gICAgcmV0dXJuIGRhdGVUaW1laXNoO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIGRhdGVUaW1laXNoLnZhbHVlT2YgJiYgaXNOdW1iZXIoZGF0ZVRpbWVpc2gudmFsdWVPZigpKSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tSlNEYXRlKGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiB0eXBlb2YgZGF0ZVRpbWVpc2ggPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdChkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgYFVua25vd24gZGF0ZXRpbWUgYXJndW1lbnQ6ICR7ZGF0ZVRpbWVpc2h9LCBvZiB0eXBlICR7dHlwZW9mIGRhdGVUaW1laXNofWBcbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/duration.js":
/*!*********************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/duration.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accurateMatrix: () => (/* binding */ accurateMatrix),\n/* harmony export */   casualMatrix: () => (/* binding */ casualMatrix),\n/* harmony export */   daysInMonthAccurate: () => (/* binding */ daysInMonthAccurate),\n/* harmony export */   daysInYearAccurate: () => (/* binding */ daysInYearAccurate),\n/* harmony export */   \"default\": () => (/* binding */ Duration),\n/* harmony export */   lowOrderMatrix: () => (/* binding */ lowOrderMatrix)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\");\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Duration\";\n\n// unit conversion constants\nconst lowOrderMatrix = {\n    weeks: {\n      days: 7,\n      hours: 7 * 24,\n      minutes: 7 * 24 * 60,\n      seconds: 7 * 24 * 60 * 60,\n      milliseconds: 7 * 24 * 60 * 60 * 1000,\n    },\n    days: {\n      hours: 24,\n      minutes: 24 * 60,\n      seconds: 24 * 60 * 60,\n      milliseconds: 24 * 60 * 60 * 1000,\n    },\n    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },\n    minutes: { seconds: 60, milliseconds: 60 * 1000 },\n    seconds: { milliseconds: 1000 },\n  },\n  casualMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: 52,\n      days: 365,\n      hours: 365 * 24,\n      minutes: 365 * 24 * 60,\n      seconds: 365 * 24 * 60 * 60,\n      milliseconds: 365 * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: 13,\n      days: 91,\n      hours: 91 * 24,\n      minutes: 91 * 24 * 60,\n      seconds: 91 * 24 * 60 * 60,\n      milliseconds: 91 * 24 * 60 * 60 * 1000,\n    },\n    months: {\n      weeks: 4,\n      days: 30,\n      hours: 30 * 24,\n      minutes: 30 * 24 * 60,\n      seconds: 30 * 24 * 60 * 60,\n      milliseconds: 30 * 24 * 60 * 60 * 1000,\n    },\n\n    ...lowOrderMatrix,\n  },\n  daysInYearAccurate = 146097.0 / 400,\n  daysInMonthAccurate = 146097.0 / 4800,\n  accurateMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: daysInYearAccurate / 7,\n      days: daysInYearAccurate,\n      hours: daysInYearAccurate * 24,\n      minutes: daysInYearAccurate * 24 * 60,\n      seconds: daysInYearAccurate * 24 * 60 * 60,\n      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: daysInYearAccurate / 28,\n      days: daysInYearAccurate / 4,\n      hours: (daysInYearAccurate * 24) / 4,\n      minutes: (daysInYearAccurate * 24 * 60) / 4,\n      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,\n      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,\n    },\n    months: {\n      weeks: daysInMonthAccurate / 7,\n      days: daysInMonthAccurate,\n      hours: daysInMonthAccurate * 24,\n      minutes: daysInMonthAccurate * 24 * 60,\n      seconds: daysInMonthAccurate * 24 * 60 * 60,\n      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,\n    },\n    ...lowOrderMatrix,\n  };\n\n// units ordered by size\nconst orderedUnits = [\n  \"years\",\n  \"quarters\",\n  \"months\",\n  \"weeks\",\n  \"days\",\n  \"hours\",\n  \"minutes\",\n  \"seconds\",\n  \"milliseconds\",\n];\n\nconst reverseUnits = orderedUnits.slice(0).reverse();\n\n// clone really means \"create another instance just like this one, but with these changes\"\nfunction clone(dur, alts, clear = false) {\n  // deep merge for vals\n  const conf = {\n    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },\n    loc: dur.loc.clone(alts.loc),\n    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,\n    matrix: alts.matrix || dur.matrix,\n  };\n  return new Duration(conf);\n}\n\nfunction durationToMillis(matrix, vals) {\n  let sum = vals.milliseconds ?? 0;\n  for (const unit of reverseUnits.slice(1)) {\n    if (vals[unit]) {\n      sum += vals[unit] * matrix[unit][\"milliseconds\"];\n    }\n  }\n  return sum;\n}\n\n// NB: mutates parameters\nfunction normalizeValues(matrix, vals) {\n  // the logic below assumes the overall value of the duration is positive\n  // if this is not the case, factor is used to make it so\n  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;\n\n  orderedUnits.reduceRight((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const previousVal = vals[previous] * factor;\n        const conv = matrix[current][previous];\n\n        // if (previousVal < 0):\n        // lower order unit is negative (e.g. { years: 2, days: -2 })\n        // normalize this by reducing the higher order unit by the appropriate amount\n        // and increasing the lower order unit\n        // this can never make the higher order unit negative, because this function only operates\n        // on positive durations, so the amount of time represented by the lower order unit cannot\n        // be larger than the higher order unit\n        // else:\n        // lower order unit is positive (e.g. { years: 2, days: 450 } or { years: -2, days: 450 })\n        // in this case we attempt to convert as much as possible from the lower order unit into\n        // the higher order one\n        //\n        // Math.floor takes care of both of these cases, rounding away from 0\n        // if previousVal < 0 it makes the absolute value larger\n        // if previousVal >= it makes the absolute value smaller\n        const rollUp = Math.floor(previousVal / conv);\n        vals[current] += rollUp * factor;\n        vals[previous] -= rollUp * conv * factor;\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n\n  // try to convert any decimals into smaller units if possible\n  // for example for { years: 2.5, days: 0, seconds: 0 } we want to get { years: 2, days: 182, hours: 12 }\n  orderedUnits.reduce((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const fraction = vals[previous] % 1;\n        vals[previous] -= fraction;\n        vals[current] += fraction * matrix[previous][current];\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n}\n\n// Remove all properties with a value of 0 from an object\nfunction removeZeroes(vals) {\n  const newVals = {};\n  for (const [key, value] of Object.entries(vals)) {\n    if (value !== 0) {\n      newVals[key] = value;\n    }\n  }\n  return newVals;\n}\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nclass Duration {\n  /**\n   * @private\n   */\n  constructor(config) {\n    const accurate = config.conversionAccuracy === \"longterm\" || false;\n    let matrix = accurate ? accurateMatrix : casualMatrix;\n\n    if (config.matrix) {\n      matrix = config.matrix;\n    }\n\n    /**\n     * @access private\n     */\n    this.values = config.values;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.matrix = matrix;\n    /**\n     * @access private\n     */\n    this.isLuxonDuration = true;\n  }\n\n  /**\n   * Create Duration from a number of milliseconds.\n   * @param {number} count of milliseconds\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  static fromMillis(count, opts) {\n    return Duration.fromObject({ milliseconds: count }, opts);\n  }\n\n  /**\n   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n   * If this object is empty then a zero milliseconds duration is returned.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.years\n   * @param {number} obj.quarters\n   * @param {number} obj.months\n   * @param {number} obj.weeks\n   * @param {number} obj.days\n   * @param {number} obj.hours\n   * @param {number} obj.minutes\n   * @param {number} obj.seconds\n   * @param {number} obj.milliseconds\n   * @param {Object} [opts=[]] - options for creating this Duration\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the custom conversion system to use\n   * @return {Duration}\n   */\n  static fromObject(obj, opts = {}) {\n    if (obj == null || typeof obj !== \"object\") {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Duration.fromObject: argument expected to be an object, got ${\n          obj === null ? \"null\" : typeof obj\n        }`\n      );\n    }\n\n    return new Duration({\n      values: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(obj, Duration.normalizeUnit),\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromObject(opts),\n      conversionAccuracy: opts.conversionAccuracy,\n      matrix: opts.matrix,\n    });\n  }\n\n  /**\n   * Create a Duration from DurationLike.\n   *\n   * @param {Object | number | Duration} durationLike\n   * One of:\n   * - object with keys like 'years' and 'hours'.\n   * - number representing milliseconds\n   * - Duration instance\n   * @return {Duration}\n   */\n  static fromDurationLike(durationLike) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(durationLike)) {\n      return Duration.fromMillis(durationLike);\n    } else if (Duration.isDuration(durationLike)) {\n      return durationLike;\n    } else if (typeof durationLike === \"object\") {\n      return Duration.fromObject(durationLike);\n    } else {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`\n      );\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 duration string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the preset conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n   * @return {Duration}\n   */\n  static fromISO(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISODuration)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 time string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @return {Duration}\n   */\n  static fromISOTime(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISOTimeOnly)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create an invalid Duration.\n   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Duration}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidDurationError(invalid);\n    } else {\n      return new Duration({ invalid });\n    }\n  }\n\n  /**\n   * @private\n   */\n  static normalizeUnit(unit) {\n    const normalized = {\n      year: \"years\",\n      years: \"years\",\n      quarter: \"quarters\",\n      quarters: \"quarters\",\n      month: \"months\",\n      months: \"months\",\n      week: \"weeks\",\n      weeks: \"weeks\",\n      day: \"days\",\n      days: \"days\",\n      hour: \"hours\",\n      hours: \"hours\",\n      minute: \"minutes\",\n      minutes: \"minutes\",\n      second: \"seconds\",\n      seconds: \"seconds\",\n      millisecond: \"milliseconds\",\n      milliseconds: \"milliseconds\",\n    }[unit ? unit.toLowerCase() : unit];\n\n    if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUnitError(unit);\n\n    return normalized;\n  }\n\n  /**\n   * Check if an object is a Duration. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDuration(o) {\n    return (o && o.isLuxonDuration) || false;\n  }\n\n  /**\n   * Get  the locale of a Duration, such 'en-GB'\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n   * * `S` for milliseconds\n   * * `s` for seconds\n   * * `m` for minutes\n   * * `h` for hours\n   * * `d` for days\n   * * `w` for weeks\n   * * `M` for months\n   * * `y` for years\n   * Notes:\n   * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n   * * Tokens can be escaped by wrapping with single quotes.\n   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - options\n   * @param {boolean} [opts.floor=true] - floor numerical values\n   * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n   * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"+6 +2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"-6 -2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"negativeLargestOnly\" }) //=> \"-6 2\"\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    // reverse-compat since 1.2; we always round down now, never up, and we do it by default\n    const fmtOpts = {\n      ...opts,\n      floor: opts.round !== false && opts.floor !== false,\n    };\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(this.loc, fmtOpts).formatDurationFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a string representation of a Duration with all units included.\n   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options\n   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.\n   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.\n   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero\n   * @example\n   * ```js\n   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })\n   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'\n   * dur.toHuman({ listStyle: \"long\" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'\n   * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 mth, 0 wks, 5 hr, 6 min'\n   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'\n   * ```\n   */\n  toHuman(opts = {}) {\n    if (!this.isValid) return INVALID;\n\n    const showZeros = opts.showZeros !== false;\n\n    const l = orderedUnits\n      .map((unit) => {\n        const val = this.values[unit];\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(val) || (val === 0 && !showZeros)) {\n          return null;\n        }\n        return this.loc\n          .numberFormatter({ style: \"unit\", unitDisplay: \"long\", ...opts, unit: unit.slice(0, -1) })\n          .format(val);\n      })\n      .filter((n) => n);\n\n    return this.loc\n      .listFormatter({ type: \"conjunction\", style: opts.listStyle || \"narrow\", ...opts })\n      .format(l);\n  }\n\n  /**\n   * Returns a JavaScript object with this Duration's values.\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n   * @return {Object}\n   */\n  toObject() {\n    if (!this.isValid) return {};\n    return { ...this.values };\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n   * @return {string}\n   */\n  toISO() {\n    // we could use the formatter, but this is an easier way to get the minimum string\n    if (!this.isValid) return null;\n\n    let s = \"P\";\n    if (this.years !== 0) s += this.years + \"Y\";\n    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\n    if (this.weeks !== 0) s += this.weeks + \"W\";\n    if (this.days !== 0) s += this.days + \"D\";\n    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)\n      s += \"T\";\n    if (this.hours !== 0) s += this.hours + \"H\";\n    if (this.minutes !== 0) s += this.minutes + \"M\";\n    if (this.seconds !== 0 || this.milliseconds !== 0)\n      // this will handle \"floating point madness\" by removing extra decimal places\n      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken\n      s += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.roundTo)(this.seconds + this.milliseconds / 1000, 3) + \"S\";\n    if (s === \"P\") s += \"T0S\";\n    return s;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n   * @return {string}\n   */\n  toISOTime(opts = {}) {\n    if (!this.isValid) return null;\n\n    const millis = this.toMillis();\n    if (millis < 0 || millis >= 86400000) return null;\n\n    opts = {\n      suppressMilliseconds: false,\n      suppressSeconds: false,\n      includePrefix: false,\n      format: \"extended\",\n      ...opts,\n      includeOffset: false,\n    };\n\n    const dateTime = _datetime_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromMillis(millis, { zone: \"UTC\" });\n    return dateTime.toISOTime(opts);\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n   * @return {string}\n   */\n  toString() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a string representation of this Duration appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Duration { values: ${JSON.stringify(this.values)} }`;\n    } else {\n      return `Duration { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration.\n   * @return {number}\n   */\n  toMillis() {\n    if (!this.isValid) return NaN;\n\n    return durationToMillis(this.matrix, this.values);\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration),\n      result = {};\n\n    for (const k of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(dur.values, k) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(this.values, k)) {\n        result[k] = dur.get(k) + this.get(k);\n      }\n    }\n\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration);\n    return this.plus(dur.negate());\n  }\n\n  /**\n   * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === \"hours\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n   * @return {Duration}\n   */\n  mapUnits(fn) {\n    if (!this.isValid) return this;\n    const result = {};\n    for (const k of Object.keys(this.values)) {\n      result[k] = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.asNumber)(fn(this.values[k], k));\n    }\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n   * @return {number}\n   */\n  get(unit) {\n    return this[Duration.normalizeUnit(unit)];\n  }\n\n  /**\n   * \"Set\" the values of specified units. Return a newly-constructed Duration.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dur.set({ years: 2017 })\n   * @example dur.set({ hours: 8, minutes: 30 })\n   * @return {Duration}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const mixed = { ...this.values, ...(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(values, Duration.normalizeUnit) };\n    return clone(this, { values: mixed });\n  }\n\n  /**\n   * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n   * @example dur.reconfigure({ locale: 'en-GB' })\n   * @return {Duration}\n   */\n  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem });\n    const opts = { loc, matrix, conversionAccuracy };\n    return clone(this, opts);\n  }\n\n  /**\n   * Return the length of the duration in the specified unit.\n   * @param {string} unit - a unit such as 'minutes' or 'days'\n   * @example Duration.fromObject({years: 1}).as('days') //=> 365\n   * @example Duration.fromObject({years: 1}).as('months') //=> 12\n   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\n   * @return {number}\n   */\n  as(unit) {\n    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\n  }\n\n  /**\n   * Reduce this Duration to its canonical representation in its current units.\n   * Assuming the overall value of the Duration is positive, this means:\n   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)\n   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise\n   *   the overall value would be negative, see third example)\n   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)\n   *\n   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.\n   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }\n   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }\n   * @return {Duration}\n   */\n  normalize() {\n    if (!this.isValid) return this;\n    const vals = this.toObject();\n    normalizeValues(this.matrix, vals);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Rescale units to its largest representation\n   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }\n   * @return {Duration}\n   */\n  rescale() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.normalize().shiftToAll().toObject());\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Convert this Duration into its representation in a different set of units.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n   * @return {Duration}\n   */\n  shiftTo(...units) {\n    if (!this.isValid) return this;\n\n    if (units.length === 0) {\n      return this;\n    }\n\n    units = units.map((u) => Duration.normalizeUnit(u));\n\n    const built = {},\n      accumulated = {},\n      vals = this.toObject();\n    let lastUnit;\n\n    for (const k of orderedUnits) {\n      if (units.indexOf(k) >= 0) {\n        lastUnit = k;\n\n        let own = 0;\n\n        // anything we haven't boiled down yet should get boiled to this unit\n        for (const ak in accumulated) {\n          own += this.matrix[ak][k] * accumulated[ak];\n          accumulated[ak] = 0;\n        }\n\n        // plus anything that's already in this unit\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n          own += vals[k];\n        }\n\n        // only keep the integer part for now in the hopes of putting any decimal part\n        // into a smaller unit later\n        const i = Math.trunc(own);\n        built[k] = i;\n        accumulated[k] = (own * 1000 - i * 1000) / 1000;\n\n        // otherwise, keep it in the wings to boil it later\n      } else if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n        accumulated[k] = vals[k];\n      }\n    }\n\n    // anything leftover becomes the decimal for the last unit\n    // lastUnit must be defined since units is not empty\n    for (const key in accumulated) {\n      if (accumulated[key] !== 0) {\n        built[lastUnit] +=\n          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\n      }\n    }\n\n    normalizeValues(this.matrix, built);\n    return clone(this, { values: built }, true);\n  }\n\n  /**\n   * Shift this Duration to all available units.\n   * Same as shiftTo(\"years\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"milliseconds\")\n   * @return {Duration}\n   */\n  shiftToAll() {\n    if (!this.isValid) return this;\n    return this.shiftTo(\n      \"years\",\n      \"months\",\n      \"weeks\",\n      \"days\",\n      \"hours\",\n      \"minutes\",\n      \"seconds\",\n      \"milliseconds\"\n    );\n  }\n\n  /**\n   * Return the negative of this Duration.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n   * @return {Duration}\n   */\n  negate() {\n    if (!this.isValid) return this;\n    const negated = {};\n    for (const k of Object.keys(this.values)) {\n      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];\n    }\n    return clone(this, { values: negated }, true);\n  }\n\n  /**\n   * Removes all units with values equal to 0 from this Duration.\n   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }\n   * @return {Duration}\n   */\n  removeZeros() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.values);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Get the years.\n   * @type {number}\n   */\n  get years() {\n    return this.isValid ? this.values.years || 0 : NaN;\n  }\n\n  /**\n   * Get the quarters.\n   * @type {number}\n   */\n  get quarters() {\n    return this.isValid ? this.values.quarters || 0 : NaN;\n  }\n\n  /**\n   * Get the months.\n   * @type {number}\n   */\n  get months() {\n    return this.isValid ? this.values.months || 0 : NaN;\n  }\n\n  /**\n   * Get the weeks\n   * @type {number}\n   */\n  get weeks() {\n    return this.isValid ? this.values.weeks || 0 : NaN;\n  }\n\n  /**\n   * Get the days.\n   * @type {number}\n   */\n  get days() {\n    return this.isValid ? this.values.days || 0 : NaN;\n  }\n\n  /**\n   * Get the hours.\n   * @type {number}\n   */\n  get hours() {\n    return this.isValid ? this.values.hours || 0 : NaN;\n  }\n\n  /**\n   * Get the minutes.\n   * @type {number}\n   */\n  get minutes() {\n    return this.isValid ? this.values.minutes || 0 : NaN;\n  }\n\n  /**\n   * Get the seconds.\n   * @return {number}\n   */\n  get seconds() {\n    return this.isValid ? this.values.seconds || 0 : NaN;\n  }\n\n  /**\n   * Get the milliseconds.\n   * @return {number}\n   */\n  get milliseconds() {\n    return this.isValid ? this.values.milliseconds || 0 : NaN;\n  }\n\n  /**\n   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n   * on invalid DateTimes or Intervals.\n   * @return {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this Duration became invalid, or null if the Duration is valid\n   * @return {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Equality check\n   * Two Durations are equal iff they have the same units and the same values for each unit.\n   * @param {Duration} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    if (!this.loc.equals(other.loc)) {\n      return false;\n    }\n\n    function eq(v1, v2) {\n      // Consider 0 and undefined as equal\n      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;\n      return v1 === v2;\n    }\n\n    for (const u of orderedUnits) {\n      if (!eq(this.values[u], other.values[u])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2R1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJGO0FBQy9DO0FBQ0o7QUFDRjtBQUNxQztBQVFuRDtBQUNhO0FBQ0E7O0FBRXJDOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLDZEQUE2RDtBQUMxRSxlQUFlLHNDQUFzQztBQUNyRCxlQUFlLG9CQUFvQjtBQUNuQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DLEdBQUc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywwREFBVztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0IsS0FBSyxzQkFBc0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHVCQUF1QixrQ0FBa0MsaUJBQWlCO0FBQzFFO0FBQ0EsU0FBUywwREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRWQUE0ViwwQkFBMEIscUJBQXFCO0FBQzNZO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQkFBMEIsR0FBRywwQkFBMEIsTUFBTSx1QkFBdUI7QUFDakksOEJBQThCLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLDZCQUE2QjtBQUN2Tyw2QkFBNkIsdUJBQXVCLEtBQUssZ0NBQWdDO0FBQ3pGLHFFQUFxRSxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUIsT0FBTyxzQkFBc0I7QUFDeFAseUVBQXlFLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixPQUFPO0FBQ3JKO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1REFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxnQkFBZ0IsNERBQW9CO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLGNBQWMsOERBQWU7QUFDN0IsV0FBVyx1REFBTTtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxRQUFRLHVEQUFRO0FBQ2hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLGdCQUFnQiw0REFBb0I7QUFDcEMscUNBQXFDLGNBQWMsVUFBVSxvQkFBb0I7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHVFQUF1RTtBQUN2RSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELGNBQWM7QUFDZDtBQUNBO0FBQ0EscUJBQXFCLHNFQUFnQjtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOLDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EscUVBQXFFO0FBQ3JFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsNkRBQTZEO0FBQzdELDhEQUE4RDtBQUM5RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHFCQUFxQixzRUFBZ0I7QUFDckM7QUFDQTtBQUNBLE1BQU07QUFDTiwwREFBMEQsS0FBSztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQW9CO0FBQ3BDOztBQUVBLHNDQUFzQyx3REFBTyxnQkFBZ0Isd0RBQU87O0FBRXBFLFFBQVEsb0RBQVE7QUFDaEIsZ0JBQWdCLDREQUFvQjtBQUNwQyxNQUFNO0FBQ04sNEJBQTRCLFNBQVM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCwrQkFBK0Isd0RBQWdCOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHdCQUF3QjtBQUM5RyxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLHdDQUF3QztBQUNyRCxvQ0FBb0MsK0JBQStCO0FBQ25FLG9DQUFvQywrQkFBK0I7QUFDbkUsb0NBQW9DLCtCQUErQjtBQUNuRSxvQ0FBb0MscUJBQXFCLG9CQUFvQixpQkFBaUI7QUFDOUYsb0NBQW9DLHVCQUF1QixvQkFBb0IsaUJBQWlCO0FBQ2hHLG9DQUFvQyx1QkFBdUIsb0JBQW9CLGlDQUFpQztBQUNoSCxjQUFjO0FBQ2Q7QUFDQSx5QkFBeUI7QUFDekIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EscUNBQXFDLDJDQUEyQztBQUNoRjtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNFO0FBQ25HO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsdUJBQXVCLGlFQUFpRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCLG9CQUFvQjtBQUN2RixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Qsb0NBQW9DLHdCQUF3QjtBQUM1RCxvQ0FBb0MsV0FBVztBQUMvQyxvQ0FBb0MsWUFBWTtBQUNoRCxvQ0FBb0MsaUJBQWlCO0FBQ3JELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNEQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsb0NBQW9DLFdBQVc7QUFDL0Msb0NBQW9DLFdBQVcsY0FBYyw0QkFBNEI7QUFDekYsb0NBQW9DLFdBQVcsY0FBYyx1QkFBdUI7QUFDcEYsb0NBQW9DLFdBQVcsY0FBYyxxQkFBcUI7QUFDbEYsb0NBQW9DLFdBQVcsY0FBYyxpQkFBaUI7QUFDOUUsY0FBYztBQUNkO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsb0RBQVEsc0JBQXNCLGFBQWE7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVSw4QkFBOEI7QUFDakUsTUFBTTtBQUNOLHlCQUF5QixtQkFBbUIscUJBQXFCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsNkRBQWMsbUJBQW1CLDZEQUFjO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLG9DQUFvQyx1QkFBdUIsOEJBQThCO0FBQ3pGLG9DQUFvQyx1QkFBdUIsdURBQXVEO0FBQ2xILGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFRO0FBQzFCO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLG1DQUFtQyxrQkFBa0I7QUFDckQsbUNBQW1DLGtCQUFrQjtBQUNyRCxtQ0FBbUMsa0JBQWtCO0FBQ3JELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLHdCQUF3QixhQUFhO0FBQ3JDLHdCQUF3Qix1QkFBdUI7QUFDL0MsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CLDhEQUFlO0FBQ3RELHlCQUF5QixlQUFlO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pELGNBQWM7QUFDZDtBQUNBLGdCQUFnQixzREFBc0QsSUFBSTtBQUMxRSxpQ0FBaUMseUJBQXlCO0FBQzFELG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFVBQVU7QUFDN0MsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0IsZ0NBQWdDO0FBQzFGLG9DQUFvQyxZQUFZLGdDQUFnQztBQUNoRixvQ0FBb0MseUJBQXlCLGdDQUFnQztBQUM3RixvQ0FBb0MsK0JBQStCLGdDQUFnQztBQUNuRyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCLDhCQUE4QjtBQUN2RixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1Qix1REFBdUQ7QUFDbEgsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx1REFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFNBQVMsdURBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsZUFBZTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1Qiw2QkFBNkI7QUFDeEYsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QyxrQ0FBa0M7QUFDL0csY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2R1cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkRHVyYXRpb25FcnJvciwgSW52YWxpZFVuaXRFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUlTT0R1cmF0aW9uLCBwYXJzZUlTT1RpbWVPbmx5IH0gZnJvbSBcIi4vaW1wbC9yZWdleFBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgYXNOdW1iZXIsXG4gIGhhc093blByb3BlcnR5LFxuICBpc051bWJlcixcbiAgaXNVbmRlZmluZWQsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIER1cmF0aW9uXCI7XG5cbi8vIHVuaXQgY29udmVyc2lvbiBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBsb3dPcmRlck1hdHJpeCA9IHtcbiAgICB3ZWVrczoge1xuICAgICAgZGF5czogNyxcbiAgICAgIGhvdXJzOiA3ICogMjQsXG4gICAgICBtaW51dGVzOiA3ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgZGF5czoge1xuICAgICAgaG91cnM6IDI0LFxuICAgICAgbWludXRlczogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGhvdXJzOiB7IG1pbnV0ZXM6IDYwLCBzZWNvbmRzOiA2MCAqIDYwLCBtaWxsaXNlY29uZHM6IDYwICogNjAgKiAxMDAwIH0sXG4gICAgbWludXRlczogeyBzZWNvbmRzOiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDEwMDAgfSxcbiAgICBzZWNvbmRzOiB7IG1pbGxpc2Vjb25kczogMTAwMCB9LFxuICB9LFxuICBjYXN1YWxNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiA1MixcbiAgICAgIGRheXM6IDM2NSxcbiAgICAgIGhvdXJzOiAzNjUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDM2NSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBxdWFydGVyczoge1xuICAgICAgbW9udGhzOiAzLFxuICAgICAgd2Vla3M6IDEzLFxuICAgICAgZGF5czogOTEsXG4gICAgICBob3VyczogOTEgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDkxICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBtb250aHM6IHtcbiAgICAgIHdlZWtzOiA0LFxuICAgICAgZGF5czogMzAsXG4gICAgICBob3VyczogMzAgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDMwICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcblxuICAgIC4uLmxvd09yZGVyTWF0cml4LFxuICB9LFxuICBkYXlzSW5ZZWFyQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQwMCxcbiAgZGF5c0luTW9udGhBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDgwMCxcbiAgYWNjdXJhdGVNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0LFxuICAgICAgbWludXRlczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gMjgsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA0LFxuICAgICAgaG91cnM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCkgLyA0LFxuICAgICAgbWludXRlczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjApIC8gNCxcbiAgICAgIHNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjApIC8gNCxcbiAgICAgIG1pbGxpc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIC8gNCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IGRheXNJbk1vbnRoQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luTW9udGhBY2N1cmF0ZSxcbiAgICAgIGhvdXJzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH07XG5cbi8vIHVuaXRzIG9yZGVyZWQgYnkgc2l6ZVxuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1xuICBcInllYXJzXCIsXG4gIFwicXVhcnRlcnNcIixcbiAgXCJtb250aHNcIixcbiAgXCJ3ZWVrc1wiLFxuICBcImRheXNcIixcbiAgXCJob3Vyc1wiLFxuICBcIm1pbnV0ZXNcIixcbiAgXCJzZWNvbmRzXCIsXG4gIFwibWlsbGlzZWNvbmRzXCIsXG5dO1xuXG5jb25zdCByZXZlcnNlVW5pdHMgPSBvcmRlcmVkVW5pdHMuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMgXCJjcmVhdGUgYW5vdGhlciBpbnN0YW5jZSBqdXN0IGxpa2UgdGhpcyBvbmUsIGJ1dCB3aXRoIHRoZXNlIGNoYW5nZXNcIlxuZnVuY3Rpb24gY2xvbmUoZHVyLCBhbHRzLCBjbGVhciA9IGZhbHNlKSB7XG4gIC8vIGRlZXAgbWVyZ2UgZm9yIHZhbHNcbiAgY29uc3QgY29uZiA9IHtcbiAgICB2YWx1ZXM6IGNsZWFyID8gYWx0cy52YWx1ZXMgOiB7IC4uLmR1ci52YWx1ZXMsIC4uLihhbHRzLnZhbHVlcyB8fCB7fSkgfSxcbiAgICBsb2M6IGR1ci5sb2MuY2xvbmUoYWx0cy5sb2MpLFxuICAgIGNvbnZlcnNpb25BY2N1cmFjeTogYWx0cy5jb252ZXJzaW9uQWNjdXJhY3kgfHwgZHVyLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICBtYXRyaXg6IGFsdHMubWF0cml4IHx8IGR1ci5tYXRyaXgsXG4gIH07XG4gIHJldHVybiBuZXcgRHVyYXRpb24oY29uZik7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSB7XG4gIGxldCBzdW0gPSB2YWxzLm1pbGxpc2Vjb25kcyA/PyAwO1xuICBmb3IgKGNvbnN0IHVuaXQgb2YgcmV2ZXJzZVVuaXRzLnNsaWNlKDEpKSB7XG4gICAgaWYgKHZhbHNbdW5pdF0pIHtcbiAgICAgIHN1bSArPSB2YWxzW3VuaXRdICogbWF0cml4W3VuaXRdW1wibWlsbGlzZWNvbmRzXCJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZXMobWF0cml4LCB2YWxzKSB7XG4gIC8vIHRoZSBsb2dpYyBiZWxvdyBhc3N1bWVzIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBkdXJhdGlvbiBpcyBwb3NpdGl2ZVxuICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgZmFjdG9yIGlzIHVzZWQgdG8gbWFrZSBpdCBzb1xuICBjb25zdCBmYWN0b3IgPSBkdXJhdGlvblRvTWlsbGlzKG1hdHJpeCwgdmFscykgPCAwID8gLTEgOiAxO1xuXG4gIG9yZGVyZWRVbml0cy5yZWR1Y2VSaWdodCgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWwgPSB2YWxzW3ByZXZpb3VzXSAqIGZhY3RvcjtcbiAgICAgICAgY29uc3QgY29udiA9IG1hdHJpeFtjdXJyZW50XVtwcmV2aW91c107XG5cbiAgICAgICAgLy8gaWYgKHByZXZpb3VzVmFsIDwgMCk6XG4gICAgICAgIC8vIGxvd2VyIG9yZGVyIHVuaXQgaXMgbmVnYXRpdmUgKGUuZy4geyB5ZWFyczogMiwgZGF5czogLTIgfSlcbiAgICAgICAgLy8gbm9ybWFsaXplIHRoaXMgYnkgcmVkdWNpbmcgdGhlIGhpZ2hlciBvcmRlciB1bml0IGJ5IHRoZSBhcHByb3ByaWF0ZSBhbW91bnRcbiAgICAgICAgLy8gYW5kIGluY3JlYXNpbmcgdGhlIGxvd2VyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gdGhpcyBjYW4gbmV2ZXIgbWFrZSB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgbmVnYXRpdmUsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IG9wZXJhdGVzXG4gICAgICAgIC8vIG9uIHBvc2l0aXZlIGR1cmF0aW9ucywgc28gdGhlIGFtb3VudCBvZiB0aW1lIHJlcHJlc2VudGVkIGJ5IHRoZSBsb3dlciBvcmRlciB1bml0IGNhbm5vdFxuICAgICAgICAvLyBiZSBsYXJnZXIgdGhhbiB0aGUgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gZWxzZTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBwb3NpdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiA0NTAgfSBvciB7IHllYXJzOiAtMiwgZGF5czogNDUwIH0pXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBhdHRlbXB0IHRvIGNvbnZlcnQgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBsb3dlciBvcmRlciB1bml0IGludG9cbiAgICAgICAgLy8gdGhlIGhpZ2hlciBvcmRlciBvbmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWF0aC5mbG9vciB0YWtlcyBjYXJlIG9mIGJvdGggb2YgdGhlc2UgY2FzZXMsIHJvdW5kaW5nIGF3YXkgZnJvbSAwXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsIDwgMCBpdCBtYWtlcyB0aGUgYWJzb2x1dGUgdmFsdWUgbGFyZ2VyXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsID49IGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBzbWFsbGVyXG4gICAgICAgIGNvbnN0IHJvbGxVcCA9IE1hdGguZmxvb3IocHJldmlvdXNWYWwgLyBjb252KTtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSByb2xsVXAgKiBmYWN0b3I7XG4gICAgICAgIHZhbHNbcHJldmlvdXNdIC09IHJvbGxVcCAqIGNvbnYgKiBmYWN0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG5cbiAgLy8gdHJ5IHRvIGNvbnZlcnQgYW55IGRlY2ltYWxzIGludG8gc21hbGxlciB1bml0cyBpZiBwb3NzaWJsZVxuICAvLyBmb3IgZXhhbXBsZSBmb3IgeyB5ZWFyczogMi41LCBkYXlzOiAwLCBzZWNvbmRzOiAwIH0gd2Ugd2FudCB0byBnZXQgeyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICBvcmRlcmVkVW5pdHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IHZhbHNbcHJldmlvdXNdICUgMTtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gZnJhY3Rpb247XG4gICAgICAgIHZhbHNbY3VycmVudF0gKz0gZnJhY3Rpb24gKiBtYXRyaXhbcHJldmlvdXNdW2N1cnJlbnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gIH0sIG51bGwpO1xufVxuXG4vLyBSZW1vdmUgYWxsIHByb3BlcnRpZXMgd2l0aCBhIHZhbHVlIG9mIDAgZnJvbSBhbiBvYmplY3RcbmZ1bmN0aW9uIHJlbW92ZVplcm9lcyh2YWxzKSB7XG4gIGNvbnN0IG5ld1ZhbHMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFscykpIHtcbiAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgIG5ld1ZhbHNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VmFscztcbn1cblxuLyoqXG4gKiBBIER1cmF0aW9uIG9iamVjdCByZXByZXNlbnRzIGEgcGVyaW9kIG9mIHRpbWUsIGxpa2UgXCIyIG1vbnRoc1wiIG9yIFwiMSBkYXksIDEgaG91clwiLiBDb25jZXB0dWFsbHksIGl0J3MganVzdCBhIG1hcCBvZiB1bml0cyB0byB0aGVpciBxdWFudGl0aWVzLCBhY2NvbXBhbmllZCBieSBzb21lIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBhbmQgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS4gVGhleSBjYW4gYmUgdXNlZCBvbiB0aGVpciBvd24gb3IgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBMdXhvbiB0eXBlczsgZm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHtAbGluayBEYXRlVGltZSNwbHVzfSB0byBhZGQgYSBEdXJhdGlvbiBvYmplY3QgdG8gYSBEYXRlVGltZSwgcHJvZHVjaW5nIGFub3RoZXIgRGF0ZVRpbWUuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBEdXJhdGlvbjpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYSBEdXJhdGlvbiwgdXNlIHtAbGluayBEdXJhdGlvbi5mcm9tTWlsbGlzfSwge0BsaW5rIER1cmF0aW9uLmZyb21PYmplY3R9LCBvciB7QGxpbmsgRHVyYXRpb24uZnJvbUlTT30uXG4gKiAqICoqVW5pdCB2YWx1ZXMqKiBTZWUgdGhlIHtAbGluayBEdXJhdGlvbiN5ZWFyc30sIHtAbGluayBEdXJhdGlvbiNtb250aHN9LCB7QGxpbmsgRHVyYXRpb24jd2Vla3N9LCB7QGxpbmsgRHVyYXRpb24jZGF5c30sIHtAbGluayBEdXJhdGlvbiNob3Vyc30sIHtAbGluayBEdXJhdGlvbiNtaW51dGVzfSwge0BsaW5rIER1cmF0aW9uI3NlY29uZHN9LCB7QGxpbmsgRHVyYXRpb24jbWlsbGlzZWNvbmRzfSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSAge0BsaW5rIER1cmF0aW9uI2xvY2FsZX0gYW5kIHtAbGluayBEdXJhdGlvbiNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBuZXcgRHVyYXRpb25zIG91dCBvZiBvbGQgb25lcyB1c2Uge0BsaW5rIER1cmF0aW9uI3BsdXN9LCB7QGxpbmsgRHVyYXRpb24jbWludXN9LCB7QGxpbmsgRHVyYXRpb24jbm9ybWFsaXplfSwge0BsaW5rIER1cmF0aW9uI3NldH0sIHtAbGluayBEdXJhdGlvbiNyZWNvbmZpZ3VyZX0sIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSwgYW5kIHtAbGluayBEdXJhdGlvbiNuZWdhdGV9LlxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIER1cmF0aW9uIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIER1cmF0aW9uI2FzfSwge0BsaW5rIER1cmF0aW9uI3RvSVNPfSwge0BsaW5rIER1cmF0aW9uI3RvRm9ybWF0fSwgYW5kIHtAbGluayBEdXJhdGlvbiN0b0pTT059XG4gKlxuICogVGhlcmUncyBhcmUgbW9yZSBtZXRob2RzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uIGFuZCB2YWxpZGl0eSwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdXJhdGlvbiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjdXJhdGUgPSBjb25maWcuY29udmVyc2lvbkFjY3VyYWN5ID09PSBcImxvbmd0ZXJtXCIgfHwgZmFsc2U7XG4gICAgbGV0IG1hdHJpeCA9IGFjY3VyYXRlID8gYWNjdXJhdGVNYXRyaXggOiBjYXN1YWxNYXRyaXg7XG5cbiAgICBpZiAoY29uZmlnLm1hdHJpeCkge1xuICAgICAgbWF0cml4ID0gY29uZmlnLm1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlcyA9IGNvbmZpZy52YWx1ZXM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGFjY3VyYXRlID8gXCJsb25ndGVybVwiIDogXCJjYXN1YWxcIjtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRHVyYXRpb24gZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBvZiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogY291bnQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPVtdXSAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjdXN0b20gY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgRHVyYXRpb24uZnJvbU9iamVjdDogYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBnb3QgJHtcbiAgICAgICAgICBvYmogPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBvYmpcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICB2YWx1ZXM6IG5vcm1hbGl6ZU9iamVjdChvYmosIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICAgIGNvbnZlcnNpb25BY2N1cmFjeTogb3B0cy5jb252ZXJzaW9uQWNjdXJhY3ksXG4gICAgICBtYXRyaXg6IG9wdHMubWF0cml4LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gRHVyYXRpb25MaWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IER1cmF0aW9ufSBkdXJhdGlvbkxpa2VcbiAgICogT25lIG9mOlxuICAgKiAtIG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiAtIG51bWJlciByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzXG4gICAqIC0gRHVyYXRpb24gaW5zdGFuY2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbkxpa2UpIHtcbiAgICBpZiAoaXNOdW1iZXIoZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2UgaWYgKER1cmF0aW9uLmlzRHVyYXRpb24oZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIGR1cmF0aW9uTGlrZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbkxpa2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYFVua25vd24gZHVyYXRpb24gYXJndW1lbnQgJHtkdXJhdGlvbkxpa2V9IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25MaWtlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgZHVyYXRpb24gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgfVt1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogdW5pdF07XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRHVyYXRpb24uIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRHVyYXRpb24pIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCAgdGhlIGxvY2FsZSBvZiBhIER1cmF0aW9uLCBzdWNoICdlbi1HQidcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYHdgIGZvciB3ZWVrc1xuICAgKiAqIGBNYCBmb3IgbW9udGhzXG4gICAqICogYHlgIGZvciB5ZWFyc1xuICAgKiBOb3RlczpcbiAgICogKiBBZGQgcGFkZGluZyBieSByZXBlYXRpbmcgdGhlIHRva2VuLCBlLmcuIFwieXlcIiBwYWRzIHRoZSB5ZWFycyB0byB0d28gZGlnaXRzLCBcImhoaGhcIiBwYWRzIHRoZSBob3VycyBvdXQgdG8gZm91ciBkaWdpdHNcbiAgICogKiBUb2tlbnMgY2FuIGJlIGVzY2FwZWQgYnkgd3JhcHBpbmcgd2l0aCBzaW5nbGUgcXVvdGVzLlxuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAcGFyYW0geyduZWdhdGl2ZSd8J2FsbCd8J25lZ2F0aXZlTGFyZ2VzdE9ubHknfSBbb3B0cy5zaWduTW9kZT1uZWdhdGl2ZV0gLSBIb3cgdG8gaGFuZGxlIHNpZ25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInkgZCBzXCIpIC8vPT4gXCIxIDYgMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInl5IGRkIHNzc1wiKSAvLz0+IFwiMDEgMDYgMDAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwiTSBTXCIpIC8vPT4gXCIxMiA1MTg0MDIwMDBcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcImQgc1wiLCB7IHNpZ25Nb2RlOiBcImFsbFwiIH0pIC8vPT4gXCIrNiArMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAtNiwgc2Vjb25kczogLTIgfSkudG9Gb3JtYXQoXCJkIHNcIiwgeyBzaWduTW9kZTogXCJhbGxcIiB9KSAvLz0+IFwiLTYgLTJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogLTYsIHNlY29uZHM6IC0yIH0pLnRvRm9ybWF0KFwiZCBzXCIsIHsgc2lnbk1vZGU6IFwibmVnYXRpdmVMYXJnZXN0T25seVwiIH0pIC8vPT4gXCItNiAyXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgY29uc3QgZm10T3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2UsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MsIGZtdE9wdHMpLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIER1cmF0aW9uIHdpdGggYWxsIHVuaXRzIGluY2x1ZGVkLlxuICAgKiBUbyBtb2RpZnkgaXRzIGJlaGF2aW9yLCB1c2UgYGxpc3RTdHlsZWAgYW5kIGFueSBJbnRsLk51bWJlckZvcm1hdCBvcHRpb24sIHRob3VnaCBgdW5pdERpc3BsYXlgIGlzIGVzcGVjaWFsbHkgcmVsZXZhbnQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bC9OdW1iZXJGb3JtYXQvTnVtYmVyRm9ybWF0I29wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBGb3JtYXR0aW5nIG9wdGlvbnMuIEFjY2VwdHMgdGhlIHNhbWUga2V5cyBhcyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgdGhlIG5hdGl2ZSBgSW50bC5OdW1iZXJGb3JtYXRgIGNvbnN0cnVjdG9yLCBhcyB3ZWxsIGFzIGBsaXN0U3R5bGVgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubGlzdFN0eWxlPSduYXJyb3cnXSAtIEhvdyB0byBmb3JtYXQgdGhlIG1lcmdlZCBsaXN0LiBDb3JyZXNwb25kcyB0byB0aGUgYHN0eWxlYCBwcm9wZXJ0eSBvZiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgdGhlIG5hdGl2ZSBgSW50bC5MaXN0Rm9ybWF0YCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zaG93WmVyb3M9dHJ1ZV0gLSBTaG93IGFsbCB1bml0cyBwcmV2aW91c2x5IHVzZWQgYnkgdGhlIGR1cmF0aW9uIGV2ZW4gaWYgdGhleSBhcmUgemVyb1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogMSwgd2Vla3M6IDAsIGhvdXJzOiA1LCBtaW51dGVzOiA2IH0pXG4gICAqIGR1ci50b0h1bWFuKCkgLy89PiAnMSBtb250aCwgMCB3ZWVrcywgNSBob3VycywgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IGxpc3RTdHlsZTogXCJsb25nXCIgfSkgLy89PiAnMSBtb250aCwgMCB3ZWVrcywgNSBob3VycywgYW5kIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyB1bml0RGlzcGxheTogXCJzaG9ydFwiIH0pIC8vPT4gJzEgbXRoLCAwIHdrcywgNSBociwgNiBtaW4nXG4gICAqIGR1ci50b0h1bWFuKHsgc2hvd1plcm9zOiBmYWxzZSB9KSAvLz0+ICcxIG1vbnRoLCA1IGhvdXJzLCA2IG1pbnV0ZXMnXG4gICAqIGBgYFxuICAgKi9cbiAgdG9IdW1hbihvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG5cbiAgICBjb25zdCBzaG93WmVyb3MgPSBvcHRzLnNob3daZXJvcyAhPT0gZmFsc2U7XG5cbiAgICBjb25zdCBsID0gb3JkZXJlZFVuaXRzXG4gICAgICAubWFwKCh1bml0KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsdWVzW3VuaXRdO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsKSB8fCAodmFsID09PSAwICYmICFzaG93WmVyb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAgICAgLm51bWJlckZvcm1hdHRlcih7IHN0eWxlOiBcInVuaXRcIiwgdW5pdERpc3BsYXk6IFwibG9uZ1wiLCAuLi5vcHRzLCB1bml0OiB1bml0LnNsaWNlKDAsIC0xKSB9KVxuICAgICAgICAgIC5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChuKSA9PiBuKTtcblxuICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgLmxpc3RGb3JtYXR0ZXIoeyB0eXBlOiBcImNvbmp1bmN0aW9uXCIsIHN0eWxlOiBvcHRzLmxpc3RTdHlsZSB8fCBcIm5hcnJvd1wiLCAuLi5vcHRzIH0pXG4gICAgICAuZm9ybWF0KGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRHVyYXRpb24ncyB2YWx1ZXMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHsgLi4udGhpcy52YWx1ZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAzLCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1AzWVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDQsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDRNVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNSB9KS50b0lTTygpIC8vPT4gJ1A1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDUgfSkudG9JU08oKSAvLz0+ICdQVDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA2IH0pLnRvSVNPKCkgLy89PiAnUFQwLjAwNlMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKCkge1xuICAgIC8vIHdlIGNvdWxkIHVzZSB0aGUgZm9ybWF0dGVyLCBidXQgdGhpcyBpcyBhbiBlYXNpZXIgd2F5IHRvIGdldCB0aGUgbWluaW11bSBzdHJpbmdcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgcyA9IFwiUFwiO1xuICAgIGlmICh0aGlzLnllYXJzICE9PSAwKSBzICs9IHRoaXMueWVhcnMgKyBcIllcIjtcbiAgICBpZiAodGhpcy5tb250aHMgIT09IDAgfHwgdGhpcy5xdWFydGVycyAhPT0gMCkgcyArPSB0aGlzLm1vbnRocyArIHRoaXMucXVhcnRlcnMgKiAzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMud2Vla3MgIT09IDApIHMgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgIGlmICh0aGlzLmRheXMgIT09IDApIHMgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDAgfHwgdGhpcy5taW51dGVzICE9PSAwIHx8IHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIHMgKz0gXCJUXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDApIHMgKz0gdGhpcy5ob3VycyArIFwiSFwiO1xuICAgIGlmICh0aGlzLm1pbnV0ZXMgIT09IDApIHMgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIC8vIHRoaXMgd2lsbCBoYW5kbGUgXCJmbG9hdGluZyBwb2ludCBtYWRuZXNzXCIgYnkgcmVtb3ZpbmcgZXh0cmEgZGVjaW1hbCBwbGFjZXNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU4ODAwNC9pcy1mbG9hdGluZy1wb2ludC1tYXRoLWJyb2tlblxuICAgICAgcyArPSByb3VuZFRvKHRoaXMuc2Vjb25kcyArIHRoaXMubWlsbGlzZWNvbmRzIC8gMTAwMCwgMykgKyBcIlNcIjtcbiAgICBpZiAocyA9PT0gXCJQXCIpIHMgKz0gXCJUMFNcIjtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiwgZm9ybWF0dGVkIGFzIGEgdGltZSBvZiBkYXkuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGR1cmF0aW9uIGlzIGludmFsaWQsIG5lZ2F0aXZlLCBvciBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoKSAvLz0+ICcxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NNaWxsaXNlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDA6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTEwMDAwLjAwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IG1pbGxpcyA9IHRoaXMudG9NaWxsaXMoKTtcbiAgICBpZiAobWlsbGlzIDwgMCB8fCBtaWxsaXMgPj0gODY0MDAwMDApIHJldHVybiBudWxsO1xuXG4gICAgb3B0cyA9IHtcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzU2Vjb25kczogZmFsc2UsXG4gICAgICBpbmNsdWRlUHJlZml4OiBmYWxzZSxcbiAgICAgIGZvcm1hdDogXCJleHRlbmRlZFwiLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIGluY2x1ZGVPZmZzZXQ6IGZhbHNlLFxuICAgIH07XG5cbiAgICBjb25zdCBkYXRlVGltZSA9IERhdGVUaW1lLmZyb21NaWxsaXMobWlsbGlzLCB7IHpvbmU6IFwiVVRDXCIgfSk7XG4gICAgcmV0dXJuIGRhdGVUaW1lLnRvSVNPVGltZShvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB0aGUgUkVQTC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGBEdXJhdGlvbiB7IHZhbHVlczogJHtKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyl9IH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYER1cmF0aW9uIHsgSW52YWxpZCwgcmVhc29uOiAke3RoaXMuaW52YWxpZFJlYXNvbn0gfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uVG9NaWxsaXModGhpcy5tYXRyaXgsIHRoaXMudmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLiBBbGlhcyBvZiB7QGxpbmsgdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gbG9uZ2VyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIHNob3J0ZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBsdXMoZHVyLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGlzIER1cmF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB1bml0LiBBcml0eSBpcyAxIG9yIDI6IHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBhbmQsIG9wdGlvbmFsbHksIHRoZSB1bml0IG5hbWUuIE11c3QgcmV0dXJuIGEgbnVtYmVyLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKHggPT4geCAqIDIpIC8vPT4geyBob3VyczogMiwgbWludXRlczogNjAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKCh4LCB1KSA9PiB1ID09PSBcImhvdXJzXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSwgbWF0cml4IH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0gfSk7XG4gICAgY29uc3Qgb3B0cyA9IHsgbG9jLCBtYXRyaXgsIGNvbnZlcnNpb25BY2N1cmFjeSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgZHVyYXRpb24gaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGVzJyBvciAnZGF5cydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnZGF5cycpIC8vPT4gMzY1XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ21vbnRocycpIC8vPT4gMTJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IDYwfSkuYXMoJ2RheXMnKSAvLz0+IDIuNVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlIHRoaXMgRHVyYXRpb24gdG8gaXRzIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBpbiBpdHMgY3VycmVudCB1bml0cy5cbiAgICogQXNzdW1pbmcgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIER1cmF0aW9uIGlzIHBvc2l0aXZlLCB0aGlzIG1lYW5zOlxuICAgKiAtIGV4Y2Vzc2l2ZSB2YWx1ZXMgZm9yIGxvd2VyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gaGlnaGVyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZpcnN0IGFuZCBzZWNvbmQgZXhhbXBsZSlcbiAgICogLSBuZWdhdGl2ZSBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlciBvcmRlciB1bml0cyAodGhlcmUgbXVzdCBiZSBzdWNoIGEgaGlnaGVyIG9yZGVyIHVuaXQsIG90aGVyd2lzZVxuICAgKiAgIHRoZSBvdmVyYWxsIHZhbHVlIHdvdWxkIGJlIG5lZ2F0aXZlLCBzZWUgdGhpcmQgZXhhbXBsZSlcbiAgICogLSBmcmFjdGlvbmFsIHZhbHVlcyBmb3IgaGlnaGVyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXItb3JkZXIgdW5pdHMgKGlmIHBvc3NpYmxlLCBzZWUgZm91cnRoIGV4YW1wbGUpXG4gICAqXG4gICAqIElmIHRoZSBvdmVyYWxsIHZhbHVlIGlzIG5lZ2F0aXZlLCB0aGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYHRoaXMubmVnYXRlKCkubm9ybWFsaXplKCkubmVnYXRlKClgLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDIsIGRheXM6IDUwMDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDE1LCBkYXlzOiAyNTUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiA1MDAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMiwgbWludXRlczogLTQ1IH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMTUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDIuNSwgZGF5czogMCwgaG91cnM6IDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDIsIGRheXM6IDE4MiwgaG91cnM6IDEyIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCB2YWxzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzY2FsZSB1bml0cyB0byBpdHMgbGFyZ2VzdCByZXByZXNlbnRhdGlvblxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA5MDAwMCB9KS5yZXNjYWxlKCkudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogMSwgc2Vjb25kczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlc2NhbGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSByZW1vdmVaZXJvZXModGhpcy5ub3JtYWxpemUoKS5zaGlmdFRvQWxsKCkudG9PYmplY3QoKSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyBEdXJhdGlvbiBpbnRvIGl0cyByZXByZXNlbnRhdGlvbiBpbiBhIGRpZmZlcmVudCBzZXQgb2YgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkuc2hpZnRUbygnbWludXRlcycsICdtaWxsaXNlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiA2MCwgbWlsbGlzZWNvbmRzOiAzMDAwMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUbyguLi51bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVuaXRzID0gdW5pdHMubWFwKCh1KSA9PiBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHUpKTtcblxuICAgIGNvbnN0IGJ1aWx0ID0ge30sXG4gICAgICBhY2N1bXVsYXRlZCA9IHt9LFxuICAgICAgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBsZXQgbGFzdFVuaXQ7XG5cbiAgICBmb3IgKGNvbnN0IGsgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAodW5pdHMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgIGxhc3RVbml0ID0gaztcblxuICAgICAgICBsZXQgb3duID0gMDtcblxuICAgICAgICAvLyBhbnl0aGluZyB3ZSBoYXZlbid0IGJvaWxlZCBkb3duIHlldCBzaG91bGQgZ2V0IGJvaWxlZCB0byB0aGlzIHVuaXRcbiAgICAgICAgZm9yIChjb25zdCBhayBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgICAgIG93biArPSB0aGlzLm1hdHJpeFtha11ba10gKiBhY2N1bXVsYXRlZFtha107XG4gICAgICAgICAgYWNjdW11bGF0ZWRbYWtdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgdGhhdCdzIGFscmVhZHkgaW4gdGhpcyB1bml0XG4gICAgICAgIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICAgIG93biArPSB2YWxzW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBrZWVwIHRoZSBpbnRlZ2VyIHBhcnQgZm9yIG5vdyBpbiB0aGUgaG9wZXMgb2YgcHV0dGluZyBhbnkgZGVjaW1hbCBwYXJ0XG4gICAgICAgIC8vIGludG8gYSBzbWFsbGVyIHVuaXQgbGF0ZXJcbiAgICAgICAgY29uc3QgaSA9IE1hdGgudHJ1bmMob3duKTtcbiAgICAgICAgYnVpbHRba10gPSBpO1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IChvd24gKiAxMDAwIC0gaSAqIDEwMDApIC8gMTAwMDtcblxuICAgICAgICAvLyBvdGhlcndpc2UsIGtlZXAgaXQgaW4gdGhlIHdpbmdzIHRvIGJvaWwgaXQgbGF0ZXJcbiAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSB2YWxzW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGxlZnRvdmVyIGJlY29tZXMgdGhlIGRlY2ltYWwgZm9yIHRoZSBsYXN0IHVuaXRcbiAgICAvLyBsYXN0VW5pdCBtdXN0IGJlIGRlZmluZWQgc2luY2UgdW5pdHMgaXMgbm90IGVtcHR5XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgIGlmIChhY2N1bXVsYXRlZFtrZXldICE9PSAwKSB7XG4gICAgICAgIGJ1aWx0W2xhc3RVbml0XSArPVxuICAgICAgICAgIGtleSA9PT0gbGFzdFVuaXQgPyBhY2N1bXVsYXRlZFtrZXldIDogYWNjdW11bGF0ZWRba2V5XSAvIHRoaXMubWF0cml4W2xhc3RVbml0XVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vcm1hbGl6ZVZhbHVlcyh0aGlzLm1hdHJpeCwgYnVpbHQpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogYnVpbHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2hpZnQgdGhpcyBEdXJhdGlvbiB0byBhbGwgYXZhaWxhYmxlIHVuaXRzLlxuICAgKiBTYW1lIGFzIHNoaWZ0VG8oXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIilcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvQWxsKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5zaGlmdFRvKFxuICAgICAgXCJ5ZWFyc1wiLFxuICAgICAgXCJtb250aHNcIixcbiAgICAgIFwid2Vla3NcIixcbiAgICAgIFwiZGF5c1wiLFxuICAgICAgXCJob3Vyc1wiLFxuICAgICAgXCJtaW51dGVzXCIsXG4gICAgICBcInNlY29uZHNcIixcbiAgICAgIFwibWlsbGlzZWNvbmRzXCJcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmVnYXRpdmUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5uZWdhdGUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogLTEsIHNlY29uZHM6IC0zMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbmVnYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBuZWdhdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKSkge1xuICAgICAgbmVnYXRlZFtrXSA9IHRoaXMudmFsdWVzW2tdID09PSAwID8gMCA6IC10aGlzLnZhbHVlc1trXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBuZWdhdGVkIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHVuaXRzIHdpdGggdmFsdWVzIGVxdWFsIHRvIDAgZnJvbSB0aGlzIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDIsIGRheXM6IDAsIGhvdXJzOiAwLCBtaW51dGVzOiAwIH0pLnJlbW92ZVplcm9zKCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDIgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlbW92ZVplcm9zKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gcmVtb3ZlWmVyb2VzKHRoaXMudmFsdWVzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMueWVhcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5xdWFydGVycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGhzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRocygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubW9udGhzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy53ZWVrcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5kYXlzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3Vycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuaG91cnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWludXRlcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWlsbGlzZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkLiBJbnZhbGlkIGR1cmF0aW9ucyBhcmUgcmV0dXJuZWQgYnkgZGlmZiBvcGVyYXRpb25zXG4gICAqIG9uIGludmFsaWQgRGF0ZVRpbWVzIG9yIEludGVydmFscy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRHVyYXRpb25zIGFyZSBlcXVhbCBpZmYgdGhleSBoYXZlIHRoZSBzYW1lIHVuaXRzIGFuZCB0aGUgc2FtZSB2YWx1ZXMgZm9yIGVhY2ggdW5pdC5cbiAgICogQHBhcmFtIHtEdXJhdGlvbn0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKHYxLCB2Mikge1xuICAgICAgLy8gQ29uc2lkZXIgMCBhbmQgdW5kZWZpbmVkIGFzIGVxdWFsXG4gICAgICBpZiAodjEgPT09IHVuZGVmaW5lZCB8fCB2MSA9PT0gMCkgcmV0dXJuIHYyID09PSB1bmRlZmluZWQgfHwgdjIgPT09IDA7XG4gICAgICByZXR1cm4gdjEgPT09IHYyO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICghZXEodGhpcy52YWx1ZXNbdV0sIG90aGVyLnZhbHVlc1t1XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/duration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js":
/*!*******************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingSpecificationError: () => (/* binding */ ConflictingSpecificationError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDateTimeError: () => (/* binding */ InvalidDateTimeError),\n/* harmony export */   InvalidDurationError: () => (/* binding */ InvalidDurationError),\n/* harmony export */   InvalidIntervalError: () => (/* binding */ InvalidIntervalError),\n/* harmony export */   InvalidUnitError: () => (/* binding */ InvalidUnitError),\n/* harmony export */   ZoneIsAbstractError: () => (/* binding */ ZoneIsAbstractError)\n/* harmony export */ });\n// these aren't really private, but nor are they really useful to document\n\n/**\n * @private\n */\nclass LuxonError extends Error {}\n\n/**\n * @private\n */\nclass InvalidDateTimeError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid DateTime: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidIntervalError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Interval: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidDurationError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Duration: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass ConflictingSpecificationError extends LuxonError {}\n\n/**\n * @private\n */\nclass InvalidUnitError extends LuxonError {\n  constructor(unit) {\n    super(`Invalid unit ${unit}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidArgumentError extends LuxonError {}\n\n/**\n * @private\n */\nclass ZoneIsAbstractError extends LuxonError {\n  constructor() {\n    super(\"Zone is an abstract class\");\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGVzZSBhcmVuJ3QgcmVhbGx5IHByaXZhdGUsIGJ1dCBub3IgYXJlIHRoZXkgcmVhbGx5IHVzZWZ1bCB0byBkb2N1bWVudFxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEx1eG9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRGF0ZVRpbWVFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEYXRlVGltZTogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEludGVydmFsRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgSW50ZXJ2YWw6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREdXJhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIER1cmF0aW9uOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuaXRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgc3VwZXIoYEludmFsaWQgdW5pdCAke3VuaXR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFpvbmVJc0Fic3RyYWN0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJab25lIGlzIGFuIGFic3RyYWN0IGNsYXNzXCIpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/conversions.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/conversions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dayOfWeek: () => (/* binding */ dayOfWeek),\n/* harmony export */   gregorianToOrdinal: () => (/* binding */ gregorianToOrdinal),\n/* harmony export */   gregorianToWeek: () => (/* binding */ gregorianToWeek),\n/* harmony export */   hasInvalidGregorianData: () => (/* binding */ hasInvalidGregorianData),\n/* harmony export */   hasInvalidOrdinalData: () => (/* binding */ hasInvalidOrdinalData),\n/* harmony export */   hasInvalidTimeData: () => (/* binding */ hasInvalidTimeData),\n/* harmony export */   hasInvalidWeekData: () => (/* binding */ hasInvalidWeekData),\n/* harmony export */   isoWeekdayToLocal: () => (/* binding */ isoWeekdayToLocal),\n/* harmony export */   ordinalToGregorian: () => (/* binding */ ordinalToGregorian),\n/* harmony export */   usesLocalWeekValues: () => (/* binding */ usesLocalWeekValues),\n/* harmony export */   weekToGregorian: () => (/* binding */ weekToGregorian)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _invalid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invalid.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\");\n\n\n\n\nconst nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n\nfunction unitOutOfRange(unit, value) {\n  return new _invalid_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n    \"unit out of range\",\n    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`\n  );\n}\n\nfunction dayOfWeek(year, month, day) {\n  const d = new Date(Date.UTC(year, month - 1, day));\n\n  if (year < 100 && year >= 0) {\n    d.setUTCFullYear(d.getUTCFullYear() - 1900);\n  }\n\n  const js = d.getUTCDay();\n\n  return js === 0 ? 7 : js;\n}\n\nfunction computeOrdinal(year, month, day) {\n  return day + ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder)[month - 1];\n}\n\nfunction uncomputeOrdinal(year, ordinal) {\n  const table = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder,\n    month0 = table.findIndex((i) => i < ordinal),\n    day = ordinal - table[month0];\n  return { month: month0 + 1, day };\n}\n\nfunction isoWeekdayToLocal(isoWeekday, startOfWeek) {\n  return ((isoWeekday - startOfWeek + 7) % 7) + 1;\n}\n\n/**\n * @private\n */\n\nfunction gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { year, month, day } = gregObj,\n    ordinal = computeOrdinal(year, month, day),\n    weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);\n\n  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7),\n    weekYear;\n\n  if (weekNumber < 1) {\n    weekYear = year - 1;\n    weekNumber = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(weekYear, minDaysInFirstWeek, startOfWeek);\n  } else if (weekNumber > (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(year, minDaysInFirstWeek, startOfWeek)) {\n    weekYear = year + 1;\n    weekNumber = 1;\n  } else {\n    weekYear = year;\n  }\n\n  return { weekYear, weekNumber, weekday, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregObj) };\n}\n\nfunction weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { weekYear, weekNumber, weekday } = weekData,\n    weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek),\n    yearInDays = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n\n  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek,\n    year;\n\n  if (ordinal < 1) {\n    year = weekYear - 1;\n    ordinal += (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(year);\n  } else if (ordinal > yearInDays) {\n    year = weekYear + 1;\n    ordinal -= (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n  } else {\n    year = weekYear;\n  }\n\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(weekData) };\n}\n\nfunction gregorianToOrdinal(gregData) {\n  const { year, month, day } = gregData;\n  const ordinal = computeOrdinal(year, month, day);\n  return { year, ordinal, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregData) };\n}\n\nfunction ordinalToGregorian(ordinalData) {\n  const { year, ordinal } = ordinalData;\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(ordinalData) };\n}\n\n/**\n * Check if local week units like localWeekday are used in obj.\n * If so, validates that they are not mixed with ISO week units and then copies them to the normal week unit properties.\n * Modifies obj in-place!\n * @param obj the object values\n */\nfunction usesLocalWeekValues(obj, loc) {\n  const hasLocaleWeekData =\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear);\n  if (hasLocaleWeekData) {\n    const hasIsoWeekData =\n      !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekday) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekNumber) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekYear);\n\n    if (hasIsoWeekData) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingSpecificationError(\n        \"Cannot mix locale-based week fields with ISO-based week fields\"\n      );\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday)) obj.weekday = obj.localWeekday;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;\n    delete obj.localWeekday;\n    delete obj.localWeekNumber;\n    delete obj.localWeekYear;\n    return {\n      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),\n      startOfWeek: loc.getStartOfWeek(),\n    };\n  } else {\n    return { minDaysInFirstWeek: 4, startOfWeek: 1 };\n  }\n}\n\nfunction hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.weekYear),\n    validWeek = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(\n      obj.weekNumber,\n      1,\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(obj.weekYear, minDaysInFirstWeek, startOfWeek)\n    ),\n    validWeekday = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.weekday, 1, 7);\n\n  if (!validYear) {\n    return unitOutOfRange(\"weekYear\", obj.weekYear);\n  } else if (!validWeek) {\n    return unitOutOfRange(\"week\", obj.weekNumber);\n  } else if (!validWeekday) {\n    return unitOutOfRange(\"weekday\", obj.weekday);\n  } else return false;\n}\n\nfunction hasInvalidOrdinalData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validOrdinal = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.ordinal, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(obj.year));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validOrdinal) {\n    return unitOutOfRange(\"ordinal\", obj.ordinal);\n  } else return false;\n}\n\nfunction hasInvalidGregorianData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validMonth = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.month, 1, 12),\n    validDay = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.day, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInMonth)(obj.year, obj.month));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validMonth) {\n    return unitOutOfRange(\"month\", obj.month);\n  } else if (!validDay) {\n    return unitOutOfRange(\"day\", obj.day);\n  } else return false;\n}\n\nfunction hasInvalidTimeData(obj) {\n  const { hour, minute, second, millisecond } = obj;\n  const validHour =\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(hour, 0, 23) ||\n      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),\n    validMinute = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(minute, 0, 59),\n    validSecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(second, 0, 59),\n    validMillisecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(millisecond, 0, 999);\n\n  if (!validHour) {\n    return unitOutOfRange(\"hour\", hour);\n  } else if (!validMinute) {\n    return unitOutOfRange(\"minute\", minute);\n  } else if (!validSecond) {\n    return unitOutOfRange(\"second\", second);\n  } else if (!validMillisecond) {\n    return unitOutOfRange(\"millisecond\", millisecond);\n  } else return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTbUI7QUFDZ0I7QUFDMEI7O0FBRTdEO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1EQUFPO0FBQ3BCO0FBQ0EscUJBQXFCLE9BQU8sV0FBVyxhQUFhLFNBQVMsS0FBSztBQUNsRTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isb0RBQVU7QUFDMUI7O0FBRUE7QUFDQSxnQkFBZ0Isb0RBQVU7QUFDMUI7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIseURBQWU7QUFDaEMsSUFBSSxzQkFBc0IseURBQWU7QUFDekM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFdBQVcsa0NBQWtDLG9EQUFVO0FBQ3ZEOztBQUVPO0FBQ1AsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQSxpQkFBaUIsb0RBQVU7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0RBQVU7QUFDekIsSUFBSTtBQUNKO0FBQ0EsZUFBZSxvREFBVTtBQUN6QixJQUFJO0FBQ0o7QUFDQTs7QUFFQSxVQUFVLGFBQWE7QUFDdkIsV0FBVyxxQkFBcUIsb0RBQVU7QUFDMUM7O0FBRU87QUFDUCxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBLFdBQVcsa0JBQWtCLG9EQUFVO0FBQ3ZDOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxhQUFhO0FBQ3ZCLFdBQVcscUJBQXFCLG9EQUFVO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxLQUFLLHFEQUFXO0FBQ2hCLEtBQUsscURBQVc7QUFDaEIsS0FBSyxxREFBVztBQUNoQjtBQUNBO0FBQ0EsT0FBTyxxREFBVyxrQkFBa0IscURBQVcscUJBQXFCLHFEQUFXOztBQUUvRTtBQUNBLGdCQUFnQixxRUFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBVztBQUNwQixTQUFTLHFEQUFXO0FBQ3BCLFNBQVMscURBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRU87QUFDUCxvQkFBb0IsbURBQVM7QUFDN0IsZ0JBQWdCLHdEQUFjO0FBQzlCO0FBQ0E7QUFDQSxNQUFNLHlEQUFlO0FBQ3JCO0FBQ0EsbUJBQW1CLHdEQUFjOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVPO0FBQ1Asb0JBQW9CLG1EQUFTO0FBQzdCLG1CQUFtQix3REFBYyxpQkFBaUIsb0RBQVU7O0FBRTVEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRU87QUFDUCxvQkFBb0IsbURBQVM7QUFDN0IsaUJBQWlCLHdEQUFjO0FBQy9CLGVBQWUsd0RBQWMsYUFBYSxxREFBVzs7QUFFckQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFTztBQUNQLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0EsTUFBTSx3REFBYztBQUNwQjtBQUNBLGtCQUFrQix3REFBYztBQUNoQyxrQkFBa0Isd0RBQWM7QUFDaEMsdUJBQXVCLHdEQUFjOztBQUVyQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9jb252ZXJzaW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpbnRlZ2VyQmV0d2VlbixcbiAgaXNMZWFwWWVhcixcbiAgdGltZU9iamVjdCxcbiAgZGF5c0luWWVhcixcbiAgZGF5c0luTW9udGgsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgaXNJbnRlZ2VyLFxuICBpc1VuZGVmaW5lZCxcbn0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW52YWxpZC5qc1wiO1xuaW1wb3J0IHsgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5cbmNvbnN0IG5vbkxlYXBMYWRkZXIgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdLFxuICBsZWFwTGFkZGVyID0gWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1XTtcblxuZnVuY3Rpb24gdW5pdE91dE9mUmFuZ2UodW5pdCwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFxuICAgIFwidW5pdCBvdXQgb2YgcmFuZ2VcIixcbiAgICBgeW91IHNwZWNpZmllZCAke3ZhbHVlfSAob2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0pIGFzIGEgJHt1bml0fSwgd2hpY2ggaXMgaW52YWxpZGBcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXG4gIGlmICh5ZWFyIDwgMTAwICYmIHllYXIgPj0gMCkge1xuICAgIGQuc2V0VVRDRnVsbFllYXIoZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCk7XG4gIH1cblxuICBjb25zdCBqcyA9IGQuZ2V0VVRDRGF5KCk7XG5cbiAgcmV0dXJuIGpzID09PSAwID8gNyA6IGpzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIHJldHVybiBkYXkgKyAoaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyKVttb250aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpIHtcbiAgY29uc3QgdGFibGUgPSBpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIsXG4gICAgbW9udGgwID0gdGFibGUuZmluZEluZGV4KChpKSA9PiBpIDwgb3JkaW5hbCksXG4gICAgZGF5ID0gb3JkaW5hbCAtIHRhYmxlW21vbnRoMF07XG4gIHJldHVybiB7IG1vbnRoOiBtb250aDAgKyAxLCBkYXkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzb1dlZWtkYXlUb0xvY2FsKGlzb1dlZWtkYXksIHN0YXJ0T2ZXZWVrKSB7XG4gIHJldHVybiAoKGlzb1dlZWtkYXkgLSBzdGFydE9mV2VlayArIDcpICUgNykgKyAxO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvV2VlayhncmVnT2JqLCBtaW5EYXlzSW5GaXJzdFdlZWsgPSA0LCBzdGFydE9mV2VlayA9IDEpIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnT2JqLFxuICAgIG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSxcbiAgICB3ZWVrZGF5ID0gaXNvV2Vla2RheVRvTG9jYWwoZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpLCBzdGFydE9mV2Vlayk7XG5cbiAgbGV0IHdlZWtOdW1iZXIgPSBNYXRoLmZsb29yKChvcmRpbmFsIC0gd2Vla2RheSArIDE0IC0gbWluRGF5c0luRmlyc3RXZWVrKSAvIDcpLFxuICAgIHdlZWtZZWFyO1xuXG4gIGlmICh3ZWVrTnVtYmVyIDwgMSkge1xuICAgIHdlZWtZZWFyID0geWVhciAtIDE7XG4gICAgd2Vla051bWJlciA9IHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2Vlayk7XG4gIH0gZWxzZSBpZiAod2Vla051bWJlciA+IHdlZWtzSW5XZWVrWWVhcih5ZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKSkge1xuICAgIHdlZWtZZWFyID0geWVhciArIDE7XG4gICAgd2Vla051bWJlciA9IDE7XG4gIH0gZWxzZSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyO1xuICB9XG5cbiAgcmV0dXJuIHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXksIC4uLnRpbWVPYmplY3QoZ3JlZ09iaikgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtUb0dyZWdvcmlhbih3ZWVrRGF0YSwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXkgfSA9IHdlZWtEYXRhLFxuICAgIHdlZWtkYXlPZkphbjQgPSBpc29XZWVrZGF5VG9Mb2NhbChkYXlPZldlZWsod2Vla1llYXIsIDEsIG1pbkRheXNJbkZpcnN0V2VlayksIHN0YXJ0T2ZXZWVrKSxcbiAgICB5ZWFySW5EYXlzID0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG5cbiAgbGV0IG9yZGluYWwgPSB3ZWVrTnVtYmVyICogNyArIHdlZWtkYXkgLSB3ZWVrZGF5T2ZKYW40IC0gNyArIG1pbkRheXNJbkZpcnN0V2VlayxcbiAgICB5ZWFyO1xuXG4gIGlmIChvcmRpbmFsIDwgMSkge1xuICAgIHllYXIgPSB3ZWVrWWVhciAtIDE7XG4gICAgb3JkaW5hbCArPSBkYXlzSW5ZZWFyKHllYXIpO1xuICB9IGVsc2UgaWYgKG9yZGluYWwgPiB5ZWFySW5EYXlzKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyICsgMTtcbiAgICBvcmRpbmFsIC09IGRheXNJblllYXIod2Vla1llYXIpO1xuICB9IGVsc2Uge1xuICAgIHllYXIgPSB3ZWVrWWVhcjtcbiAgfVxuXG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdCh3ZWVrRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvT3JkaW5hbChncmVnRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdEYXRhO1xuICBjb25zdCBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSk7XG4gIHJldHVybiB7IHllYXIsIG9yZGluYWwsIC4uLnRpbWVPYmplY3QoZ3JlZ0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcmRpbmFsVG9HcmVnb3JpYW4ob3JkaW5hbERhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBvcmRpbmFsIH0gPSBvcmRpbmFsRGF0YTtcbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KG9yZGluYWxEYXRhKSB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGxvY2FsIHdlZWsgdW5pdHMgbGlrZSBsb2NhbFdlZWtkYXkgYXJlIHVzZWQgaW4gb2JqLlxuICogSWYgc28sIHZhbGlkYXRlcyB0aGF0IHRoZXkgYXJlIG5vdCBtaXhlZCB3aXRoIElTTyB3ZWVrIHVuaXRzIGFuZCB0aGVuIGNvcGllcyB0aGVtIHRvIHRoZSBub3JtYWwgd2VlayB1bml0IHByb3BlcnRpZXMuXG4gKiBNb2RpZmllcyBvYmogaW4tcGxhY2UhXG4gKiBAcGFyYW0gb2JqIHRoZSBvYmplY3QgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VzTG9jYWxXZWVrVmFsdWVzKG9iaiwgbG9jKSB7XG4gIGNvbnN0IGhhc0xvY2FsZVdlZWtEYXRhID1cbiAgICAhaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla2RheSkgfHxcbiAgICAhaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla051bWJlcikgfHxcbiAgICAhaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla1llYXIpO1xuICBpZiAoaGFzTG9jYWxlV2Vla0RhdGEpIHtcbiAgICBjb25zdCBoYXNJc29XZWVrRGF0YSA9XG4gICAgICAhaXNVbmRlZmluZWQob2JqLndlZWtkYXkpIHx8ICFpc1VuZGVmaW5lZChvYmoud2Vla051bWJlcikgfHwgIWlzVW5kZWZpbmVkKG9iai53ZWVrWWVhcik7XG5cbiAgICBpZiAoaGFzSXNvV2Vla0RhdGEpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW5ub3QgbWl4IGxvY2FsZS1iYXNlZCB3ZWVrIGZpZWxkcyB3aXRoIElTTy1iYXNlZCB3ZWVrIGZpZWxkc1wiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtkYXkpKSBvYmoud2Vla2RheSA9IG9iai5sb2NhbFdlZWtkYXk7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrTnVtYmVyKSkgb2JqLndlZWtOdW1iZXIgPSBvYmoubG9jYWxXZWVrTnVtYmVyO1xuICAgIGlmICghaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla1llYXIpKSBvYmoud2Vla1llYXIgPSBvYmoubG9jYWxXZWVrWWVhcjtcbiAgICBkZWxldGUgb2JqLmxvY2FsV2Vla2RheTtcbiAgICBkZWxldGUgb2JqLmxvY2FsV2Vla051bWJlcjtcbiAgICBkZWxldGUgb2JqLmxvY2FsV2Vla1llYXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbkRheXNJbkZpcnN0V2VlazogbG9jLmdldE1pbkRheXNJbkZpcnN0V2VlaygpLFxuICAgICAgc3RhcnRPZldlZWs6IGxvYy5nZXRTdGFydE9mV2VlaygpLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgbWluRGF5c0luRmlyc3RXZWVrOiA0LCBzdGFydE9mV2VlazogMSB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkV2Vla0RhdGEob2JqLCBtaW5EYXlzSW5GaXJzdFdlZWsgPSA0LCBzdGFydE9mV2VlayA9IDEpIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai53ZWVrWWVhciksXG4gICAgdmFsaWRXZWVrID0gaW50ZWdlckJldHdlZW4oXG4gICAgICBvYmoud2Vla051bWJlcixcbiAgICAgIDEsXG4gICAgICB3ZWVrc0luV2Vla1llYXIob2JqLndlZWtZZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKVxuICAgICksXG4gICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vla051bWJlcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgdmFsaWREYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmouZGF5LCAxLCBkYXlzSW5Nb250aChvYmoueWVhciwgb2JqLm1vbnRoKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNb250aCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1vbnRoXCIsIG9iai5tb250aCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkRGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiZGF5XCIsIG9iai5kYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFRpbWVEYXRhKG9iaikge1xuICBjb25zdCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9ID0gb2JqO1xuICBjb25zdCB2YWxpZEhvdXIgPVxuICAgICAgaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8XG4gICAgICAoaG91ciA9PT0gMjQgJiYgbWludXRlID09PSAwICYmIHNlY29uZCA9PT0gMCAmJiBtaWxsaXNlY29uZCA9PT0gMCksXG4gICAgdmFsaWRNaW51dGUgPSBpbnRlZ2VyQmV0d2VlbihtaW51dGUsIDAsIDU5KSxcbiAgICB2YWxpZFNlY29uZCA9IGludGVnZXJCZXR3ZWVuKHNlY29uZCwgMCwgNTkpLFxuICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/conversions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/diff.js":
/*!**********************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/diff.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../duration.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/duration.js\");\n\n\nfunction dayDiff(earlier, later) {\n  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf(\"day\").valueOf(),\n    ms = utcDayStart(later) - utcDayStart(earlier);\n  return Math.floor(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(ms).as(\"days\"));\n}\n\nfunction highOrderDiffs(cursor, later, units) {\n  const differs = [\n    [\"years\", (a, b) => b.year - a.year],\n    [\"quarters\", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],\n    [\"months\", (a, b) => b.month - a.month + (b.year - a.year) * 12],\n    [\n      \"weeks\",\n      (a, b) => {\n        const days = dayDiff(a, b);\n        return (days - (days % 7)) / 7;\n      },\n    ],\n    [\"days\", dayDiff],\n  ];\n\n  const results = {};\n  const earlier = cursor;\n  let lowestOrder, highWater;\n\n  /* This loop tries to diff using larger units first.\n     If we overshoot, we backtrack and try the next smaller unit.\n     \"cursor\" starts out at the earlier timestamp and moves closer and closer to \"later\"\n     as we use smaller and smaller units.\n     highWater keeps track of where we would be if we added one more of the smallest unit,\n     this is used later to potentially convert any difference smaller than the smallest higher order unit\n     into a fraction of that smallest higher order unit\n  */\n  for (const [unit, differ] of differs) {\n    if (units.indexOf(unit) >= 0) {\n      lowestOrder = unit;\n\n      results[unit] = differ(cursor, later);\n      highWater = earlier.plus(results);\n\n      if (highWater > later) {\n        // we overshot the end point, backtrack cursor by 1\n        results[unit]--;\n        cursor = earlier.plus(results);\n\n        // if we are still overshooting now, we need to backtrack again\n        // this happens in certain situations when diffing times in different zones,\n        // because this calculation ignores time zones\n        if (cursor > later) {\n          // keep the \"overshot by 1\" around as highWater\n          highWater = cursor;\n          // backtrack cursor by 1\n          results[unit]--;\n          cursor = earlier.plus(results);\n        }\n      } else {\n        cursor = highWater;\n      }\n    }\n  }\n\n  return [cursor, results, highWater, lowestOrder];\n}\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(earlier, later, units, opts) {\n  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);\n\n  const remainingMillis = later - cursor;\n\n  const lowerOrderUnits = units.filter(\n    (u) => [\"hours\", \"minutes\", \"seconds\", \"milliseconds\"].indexOf(u) >= 0\n  );\n\n  if (lowerOrderUnits.length === 0) {\n    if (highWater < later) {\n      highWater = cursor.plus({ [lowestOrder]: 1 });\n    }\n\n    if (highWater !== cursor) {\n      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);\n    }\n  }\n\n  const duration = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject(results, opts);\n\n  if (lowerOrderUnits.length > 0) {\n    return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(remainingMillis, opts)\n      .shiftTo(...lowerOrderUnits)\n      .plus(duration);\n  } else {\n    return duration;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQzs7QUFFdEM7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0Esb0JBQW9CLG9EQUFRO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVU7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvREFBUTs7QUFFM0I7QUFDQSxXQUFXLG9EQUFRO0FBQ25CO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWZmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gZGF5RGlmZihlYXJsaWVyLCBsYXRlcikge1xuICBjb25zdCB1dGNEYXlTdGFydCA9IChkdCkgPT4gZHQudG9VVEMoMCwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pLnN0YXJ0T2YoXCJkYXlcIikudmFsdWVPZigpLFxuICAgIG1zID0gdXRjRGF5U3RhcnQobGF0ZXIpIC0gdXRjRGF5U3RhcnQoZWFybGllcik7XG4gIHJldHVybiBNYXRoLmZsb29yKER1cmF0aW9uLmZyb21NaWxsaXMobXMpLmFzKFwiZGF5c1wiKSk7XG59XG5cbmZ1bmN0aW9uIGhpZ2hPcmRlckRpZmZzKGN1cnNvciwgbGF0ZXIsIHVuaXRzKSB7XG4gIGNvbnN0IGRpZmZlcnMgPSBbXG4gICAgW1wieWVhcnNcIiwgKGEsIGIpID0+IGIueWVhciAtIGEueWVhcl0sXG4gICAgW1wicXVhcnRlcnNcIiwgKGEsIGIpID0+IGIucXVhcnRlciAtIGEucXVhcnRlciArIChiLnllYXIgLSBhLnllYXIpICogNF0sXG4gICAgW1wibW9udGhzXCIsIChhLCBiKSA9PiBiLm1vbnRoIC0gYS5tb250aCArIChiLnllYXIgLSBhLnllYXIpICogMTJdLFxuICAgIFtcbiAgICAgIFwid2Vla3NcIixcbiAgICAgIChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGRheXMgPSBkYXlEaWZmKGEsIGIpO1xuICAgICAgICByZXR1cm4gKGRheXMgLSAoZGF5cyAlIDcpKSAvIDc7XG4gICAgICB9LFxuICAgIF0sXG4gICAgW1wiZGF5c1wiLCBkYXlEaWZmXSxcbiAgXTtcblxuICBjb25zdCByZXN1bHRzID0ge307XG4gIGNvbnN0IGVhcmxpZXIgPSBjdXJzb3I7XG4gIGxldCBsb3dlc3RPcmRlciwgaGlnaFdhdGVyO1xuXG4gIC8qIFRoaXMgbG9vcCB0cmllcyB0byBkaWZmIHVzaW5nIGxhcmdlciB1bml0cyBmaXJzdC5cbiAgICAgSWYgd2Ugb3ZlcnNob290LCB3ZSBiYWNrdHJhY2sgYW5kIHRyeSB0aGUgbmV4dCBzbWFsbGVyIHVuaXQuXG4gICAgIFwiY3Vyc29yXCIgc3RhcnRzIG91dCBhdCB0aGUgZWFybGllciB0aW1lc3RhbXAgYW5kIG1vdmVzIGNsb3NlciBhbmQgY2xvc2VyIHRvIFwibGF0ZXJcIlxuICAgICBhcyB3ZSB1c2Ugc21hbGxlciBhbmQgc21hbGxlciB1bml0cy5cbiAgICAgaGlnaFdhdGVyIGtlZXBzIHRyYWNrIG9mIHdoZXJlIHdlIHdvdWxkIGJlIGlmIHdlIGFkZGVkIG9uZSBtb3JlIG9mIHRoZSBzbWFsbGVzdCB1bml0LFxuICAgICB0aGlzIGlzIHVzZWQgbGF0ZXIgdG8gcG90ZW50aWFsbHkgY29udmVydCBhbnkgZGlmZmVyZW5jZSBzbWFsbGVyIHRoYW4gdGhlIHNtYWxsZXN0IGhpZ2hlciBvcmRlciB1bml0XG4gICAgIGludG8gYSBmcmFjdGlvbiBvZiB0aGF0IHNtYWxsZXN0IGhpZ2hlciBvcmRlciB1bml0XG4gICovXG4gIGZvciAoY29uc3QgW3VuaXQsIGRpZmZlcl0gb2YgZGlmZmVycykge1xuICAgIGlmICh1bml0cy5pbmRleE9mKHVuaXQpID49IDApIHtcbiAgICAgIGxvd2VzdE9yZGVyID0gdW5pdDtcblxuICAgICAgcmVzdWx0c1t1bml0XSA9IGRpZmZlcihjdXJzb3IsIGxhdGVyKTtcbiAgICAgIGhpZ2hXYXRlciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcblxuICAgICAgaWYgKGhpZ2hXYXRlciA+IGxhdGVyKSB7XG4gICAgICAgIC8vIHdlIG92ZXJzaG90IHRoZSBlbmQgcG9pbnQsIGJhY2t0cmFjayBjdXJzb3IgYnkgMVxuICAgICAgICByZXN1bHRzW3VuaXRdLS07XG4gICAgICAgIGN1cnNvciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgc3RpbGwgb3ZlcnNob290aW5nIG5vdywgd2UgbmVlZCB0byBiYWNrdHJhY2sgYWdhaW5cbiAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB3aGVuIGRpZmZpbmcgdGltZXMgaW4gZGlmZmVyZW50IHpvbmVzLFxuICAgICAgICAvLyBiZWNhdXNlIHRoaXMgY2FsY3VsYXRpb24gaWdub3JlcyB0aW1lIHpvbmVzXG4gICAgICAgIGlmIChjdXJzb3IgPiBsYXRlcikge1xuICAgICAgICAgIC8vIGtlZXAgdGhlIFwib3ZlcnNob3QgYnkgMVwiIGFyb3VuZCBhcyBoaWdoV2F0ZXJcbiAgICAgICAgICBoaWdoV2F0ZXIgPSBjdXJzb3I7XG4gICAgICAgICAgLy8gYmFja3RyYWNrIGN1cnNvciBieSAxXG4gICAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICAgIGN1cnNvciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gaGlnaFdhdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgb3B0cykge1xuICBsZXQgW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl0gPSBoaWdoT3JkZXJEaWZmcyhlYXJsaWVyLCBsYXRlciwgdW5pdHMpO1xuXG4gIGNvbnN0IHJlbWFpbmluZ01pbGxpcyA9IGxhdGVyIC0gY3Vyc29yO1xuXG4gIGNvbnN0IGxvd2VyT3JkZXJVbml0cyA9IHVuaXRzLmZpbHRlcihcbiAgICAodSkgPT4gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiXS5pbmRleE9mKHUpID49IDBcbiAgKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChoaWdoV2F0ZXIgPCBsYXRlcikge1xuICAgICAgaGlnaFdhdGVyID0gY3Vyc29yLnBsdXMoeyBbbG93ZXN0T3JkZXJdOiAxIH0pO1xuICAgIH1cblxuICAgIGlmIChoaWdoV2F0ZXIgIT09IGN1cnNvcikge1xuICAgICAgcmVzdWx0c1tsb3dlc3RPcmRlcl0gPSAocmVzdWx0c1tsb3dlc3RPcmRlcl0gfHwgMCkgKyByZW1haW5pbmdNaWxsaXMgLyAoaGlnaFdhdGVyIC0gY3Vyc29yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkdXJhdGlvbiA9IER1cmF0aW9uLmZyb21PYmplY3QocmVzdWx0cywgb3B0cyk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMocmVtYWluaW5nTWlsbGlzLCBvcHRzKVxuICAgICAgLnNoaWZ0VG8oLi4ubG93ZXJPcmRlclVuaXRzKVxuICAgICAgLnBsdXMoZHVyYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/diff.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/digits.js":
/*!************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/digits.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   digitRegex: () => (/* binding */ digitRegex),\n/* harmony export */   parseDigits: () => (/* binding */ parseDigits),\n/* harmony export */   resetDigitRegexCache: () => (/* binding */ resetDigitRegexCache)\n/* harmony export */ });\nconst numberingSystems = {\n  arab: \"[\\u0660-\\u0669]\",\n  arabext: \"[\\u06F0-\\u06F9]\",\n  bali: \"[\\u1B50-\\u1B59]\",\n  beng: \"[\\u09E6-\\u09EF]\",\n  deva: \"[\\u0966-\\u096F]\",\n  fullwide: \"[\\uFF10-\\uFF19]\",\n  gujr: \"[\\u0AE6-\\u0AEF]\",\n  hanidec: \"[|||||||||]\",\n  khmr: \"[\\u17E0-\\u17E9]\",\n  knda: \"[\\u0CE6-\\u0CEF]\",\n  laoo: \"[\\u0ED0-\\u0ED9]\",\n  limb: \"[\\u1946-\\u194F]\",\n  mlym: \"[\\u0D66-\\u0D6F]\",\n  mong: \"[\\u1810-\\u1819]\",\n  mymr: \"[\\u1040-\\u1049]\",\n  orya: \"[\\u0B66-\\u0B6F]\",\n  tamldec: \"[\\u0BE6-\\u0BEF]\",\n  telu: \"[\\u0C66-\\u0C6F]\",\n  thai: \"[\\u0E50-\\u0E59]\",\n  tibt: \"[\\u0F20-\\u0F29]\",\n  latn: \"\\\\d\",\n};\n\nconst numberingSystemsUTF16 = {\n  arab: [1632, 1641],\n  arabext: [1776, 1785],\n  bali: [6992, 7001],\n  beng: [2534, 2543],\n  deva: [2406, 2415],\n  fullwide: [65296, 65303],\n  gujr: [2790, 2799],\n  khmr: [6112, 6121],\n  knda: [3302, 3311],\n  laoo: [3792, 3801],\n  limb: [6470, 6479],\n  mlym: [3430, 3439],\n  mong: [6160, 6169],\n  mymr: [4160, 4169],\n  orya: [2918, 2927],\n  tamldec: [3046, 3055],\n  telu: [3174, 3183],\n  thai: [3664, 3673],\n  tibt: [3872, 3881],\n};\n\nconst hanidecChars = numberingSystems.hanidec.replace(/[\\[|\\]]/g, \"\").split(\"\");\n\nfunction parseDigits(str) {\n  let value = parseInt(str, 10);\n  if (isNaN(value)) {\n    value = \"\";\n    for (let i = 0; i < str.length; i++) {\n      const code = str.charCodeAt(i);\n\n      if (str[i].search(numberingSystems.hanidec) !== -1) {\n        value += hanidecChars.indexOf(str[i]);\n      } else {\n        for (const key in numberingSystemsUTF16) {\n          const [min, max] = numberingSystemsUTF16[key];\n          if (code >= min && code <= max) {\n            value += code - min;\n          }\n        }\n      }\n    }\n    return parseInt(value, 10);\n  } else {\n    return value;\n  }\n}\n\n// cache of {numberingSystem: {append: regex}}\nconst digitRegexCache = new Map();\nfunction resetDigitRegexCache() {\n  digitRegexCache.clear();\n}\n\nfunction digitRegex({ numberingSystem }, append = \"\") {\n  const ns = numberingSystem || \"latn\";\n\n  let appendCache = digitRegexCache.get(ns);\n  if (appendCache === undefined) {\n    appendCache = new Map();\n    digitRegexCache.set(ns, appendCache);\n  }\n  let regex = appendCache.get(append);\n  if (regex === undefined) {\n    regex = new RegExp(`${numberingSystems[ns]}${append}`);\n    appendCache.set(append, regex);\n  }\n\n  return regex;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlnaXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDTztBQUNQO0FBQ0E7O0FBRU8sc0JBQXNCLGlCQUFpQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsRUFBRSxPQUFPO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlnaXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG51bWJlcmluZ1N5c3RlbXMgPSB7XG4gIGFyYWI6IFwiW1xcdTA2NjAtXFx1MDY2OV1cIixcbiAgYXJhYmV4dDogXCJbXFx1MDZGMC1cXHUwNkY5XVwiLFxuICBiYWxpOiBcIltcXHUxQjUwLVxcdTFCNTldXCIsXG4gIGJlbmc6IFwiW1xcdTA5RTYtXFx1MDlFRl1cIixcbiAgZGV2YTogXCJbXFx1MDk2Ni1cXHUwOTZGXVwiLFxuICBmdWxsd2lkZTogXCJbXFx1RkYxMC1cXHVGRjE5XVwiLFxuICBndWpyOiBcIltcXHUwQUU2LVxcdTBBRUZdXCIsXG4gIGhhbmlkZWM6IFwiW+OAh3zkuIB85LqMfOS4iXzlm5t85LqUfOWFrXzkuIN85YWrfOS5nV1cIixcbiAga2htcjogXCJbXFx1MTdFMC1cXHUxN0U5XVwiLFxuICBrbmRhOiBcIltcXHUwQ0U2LVxcdTBDRUZdXCIsXG4gIGxhb286IFwiW1xcdTBFRDAtXFx1MEVEOV1cIixcbiAgbGltYjogXCJbXFx1MTk0Ni1cXHUxOTRGXVwiLFxuICBtbHltOiBcIltcXHUwRDY2LVxcdTBENkZdXCIsXG4gIG1vbmc6IFwiW1xcdTE4MTAtXFx1MTgxOV1cIixcbiAgbXltcjogXCJbXFx1MTA0MC1cXHUxMDQ5XVwiLFxuICBvcnlhOiBcIltcXHUwQjY2LVxcdTBCNkZdXCIsXG4gIHRhbWxkZWM6IFwiW1xcdTBCRTYtXFx1MEJFRl1cIixcbiAgdGVsdTogXCJbXFx1MEM2Ni1cXHUwQzZGXVwiLFxuICB0aGFpOiBcIltcXHUwRTUwLVxcdTBFNTldXCIsXG4gIHRpYnQ6IFwiW1xcdTBGMjAtXFx1MEYyOV1cIixcbiAgbGF0bjogXCJcXFxcZFwiLFxufTtcblxuY29uc3QgbnVtYmVyaW5nU3lzdGVtc1VURjE2ID0ge1xuICBhcmFiOiBbMTYzMiwgMTY0MV0sXG4gIGFyYWJleHQ6IFsxNzc2LCAxNzg1XSxcbiAgYmFsaTogWzY5OTIsIDcwMDFdLFxuICBiZW5nOiBbMjUzNCwgMjU0M10sXG4gIGRldmE6IFsyNDA2LCAyNDE1XSxcbiAgZnVsbHdpZGU6IFs2NTI5NiwgNjUzMDNdLFxuICBndWpyOiBbMjc5MCwgMjc5OV0sXG4gIGtobXI6IFs2MTEyLCA2MTIxXSxcbiAga25kYTogWzMzMDIsIDMzMTFdLFxuICBsYW9vOiBbMzc5MiwgMzgwMV0sXG4gIGxpbWI6IFs2NDcwLCA2NDc5XSxcbiAgbWx5bTogWzM0MzAsIDM0MzldLFxuICBtb25nOiBbNjE2MCwgNjE2OV0sXG4gIG15bXI6IFs0MTYwLCA0MTY5XSxcbiAgb3J5YTogWzI5MTgsIDI5MjddLFxuICB0YW1sZGVjOiBbMzA0NiwgMzA1NV0sXG4gIHRlbHU6IFszMTc0LCAzMTgzXSxcbiAgdGhhaTogWzM2NjQsIDM2NzNdLFxuICB0aWJ0OiBbMzg3MiwgMzg4MV0sXG59O1xuXG5jb25zdCBoYW5pZGVjQ2hhcnMgPSBudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMucmVwbGFjZSgvW1xcW3xcXF1dL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEaWdpdHMoc3RyKSB7XG4gIGxldCB2YWx1ZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgdmFsdWUgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChzdHJbaV0uc2VhcmNoKG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYykgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlICs9IGhhbmlkZWNDaGFycy5pbmRleE9mKHN0cltpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBudW1iZXJpbmdTeXN0ZW1zVVRGMTYpIHtcbiAgICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gbnVtYmVyaW5nU3lzdGVtc1VURjE2W2tleV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gbWluICYmIGNvZGUgPD0gbWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjb2RlIC0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLy8gY2FjaGUgb2Yge251bWJlcmluZ1N5c3RlbToge2FwcGVuZDogcmVnZXh9fVxuY29uc3QgZGlnaXRSZWdleENhY2hlID0gbmV3IE1hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RGlnaXRSZWdleENhY2hlKCkge1xuICBkaWdpdFJlZ2V4Q2FjaGUuY2xlYXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZ2l0UmVnZXgoeyBudW1iZXJpbmdTeXN0ZW0gfSwgYXBwZW5kID0gXCJcIikge1xuICBjb25zdCBucyA9IG51bWJlcmluZ1N5c3RlbSB8fCBcImxhdG5cIjtcblxuICBsZXQgYXBwZW5kQ2FjaGUgPSBkaWdpdFJlZ2V4Q2FjaGUuZ2V0KG5zKTtcbiAgaWYgKGFwcGVuZENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICBhcHBlbmRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBkaWdpdFJlZ2V4Q2FjaGUuc2V0KG5zLCBhcHBlbmRDYWNoZSk7XG4gIH1cbiAgbGV0IHJlZ2V4ID0gYXBwZW5kQ2FjaGUuZ2V0KGFwcGVuZCk7XG4gIGlmIChyZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVnZXggPSBuZXcgUmVnRXhwKGAke251bWJlcmluZ1N5c3RlbXNbbnNdfSR7YXBwZW5kfWApO1xuICAgIGFwcGVuZENhY2hlLnNldChhcHBlbmQsIHJlZ2V4KTtcbiAgfVxuXG4gIHJldHVybiByZWdleDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/digits.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/english.js":
/*!*************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/english.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eraForDateTime: () => (/* binding */ eraForDateTime),\n/* harmony export */   eras: () => (/* binding */ eras),\n/* harmony export */   erasLong: () => (/* binding */ erasLong),\n/* harmony export */   erasNarrow: () => (/* binding */ erasNarrow),\n/* harmony export */   erasShort: () => (/* binding */ erasShort),\n/* harmony export */   formatRelativeTime: () => (/* binding */ formatRelativeTime),\n/* harmony export */   formatString: () => (/* binding */ formatString),\n/* harmony export */   meridiemForDateTime: () => (/* binding */ meridiemForDateTime),\n/* harmony export */   meridiems: () => (/* binding */ meridiems),\n/* harmony export */   monthForDateTime: () => (/* binding */ monthForDateTime),\n/* harmony export */   months: () => (/* binding */ months),\n/* harmony export */   monthsLong: () => (/* binding */ monthsLong),\n/* harmony export */   monthsNarrow: () => (/* binding */ monthsNarrow),\n/* harmony export */   monthsShort: () => (/* binding */ monthsShort),\n/* harmony export */   weekdayForDateTime: () => (/* binding */ weekdayForDateTime),\n/* harmony export */   weekdays: () => (/* binding */ weekdays),\n/* harmony export */   weekdaysLong: () => (/* binding */ weekdaysLong),\n/* harmony export */   weekdaysNarrow: () => (/* binding */ weekdaysNarrow),\n/* harmony export */   weekdaysShort: () => (/* binding */ weekdaysShort)\n/* harmony export */ });\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n\n\n\nfunction stringify(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\n\n/**\n * @private\n */\n\nconst monthsLong = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n];\n\nconst monthsShort = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\nconst monthsNarrow = [\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"];\n\nfunction months(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...monthsNarrow];\n    case \"short\":\n      return [...monthsShort];\n    case \"long\":\n      return [...monthsLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"];\n    case \"2-digit\":\n      return [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\n    default:\n      return null;\n  }\n}\n\nconst weekdaysLong = [\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\",\n];\n\nconst weekdaysShort = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n\nconst weekdaysNarrow = [\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\"];\n\nfunction weekdays(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...weekdaysNarrow];\n    case \"short\":\n      return [...weekdaysShort];\n    case \"long\":\n      return [...weekdaysLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n    default:\n      return null;\n  }\n}\n\nconst meridiems = [\"AM\", \"PM\"];\n\nconst erasLong = [\"Before Christ\", \"Anno Domini\"];\n\nconst erasShort = [\"BC\", \"AD\"];\n\nconst erasNarrow = [\"B\", \"A\"];\n\nfunction eras(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...erasNarrow];\n    case \"short\":\n      return [...erasShort];\n    case \"long\":\n      return [...erasLong];\n    default:\n      return null;\n  }\n}\n\nfunction meridiemForDateTime(dt) {\n  return meridiems[dt.hour < 12 ? 0 : 1];\n}\n\nfunction weekdayForDateTime(dt, length) {\n  return weekdays(length)[dt.weekday - 1];\n}\n\nfunction monthForDateTime(dt, length) {\n  return months(length)[dt.month - 1];\n}\n\nfunction eraForDateTime(dt, length) {\n  return eras(length)[dt.year < 0 ? 0 : 1];\n}\n\nfunction formatRelativeTime(unit, count, numeric = \"always\", narrow = false) {\n  const units = {\n    years: [\"year\", \"yr.\"],\n    quarters: [\"quarter\", \"qtr.\"],\n    months: [\"month\", \"mo.\"],\n    weeks: [\"week\", \"wk.\"],\n    days: [\"day\", \"day\", \"days\"],\n    hours: [\"hour\", \"hr.\"],\n    minutes: [\"minute\", \"min.\"],\n    seconds: [\"second\", \"sec.\"],\n  };\n\n  const lastable = [\"hours\", \"minutes\", \"seconds\"].indexOf(unit) === -1;\n\n  if (numeric === \"auto\" && lastable) {\n    const isDay = unit === \"days\";\n    switch (count) {\n      case 1:\n        return isDay ? \"tomorrow\" : `next ${units[unit][0]}`;\n      case -1:\n        return isDay ? \"yesterday\" : `last ${units[unit][0]}`;\n      case 0:\n        return isDay ? \"today\" : `this ${units[unit][0]}`;\n      default: // fall through\n    }\n  }\n\n  const isInPast = Object.is(count, -0) || count < 0,\n    fmtValue = Math.abs(count),\n    singular = fmtValue === 1,\n    lilUnits = units[unit],\n    fmtUnit = narrow\n      ? singular\n        ? lilUnits[1]\n        : lilUnits[2] || lilUnits[1]\n      : singular\n      ? units[unit][0]\n      : unit;\n  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;\n}\n\nfunction formatString(knownFormat) {\n  // these all have the offsets removed because we don't have access to them\n  // without all the intl stuff this is backfilling\n  const filtered = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.pick)(knownFormat, [\n      \"weekday\",\n      \"era\",\n      \"year\",\n      \"month\",\n      \"day\",\n      \"hour\",\n      \"minute\",\n      \"second\",\n      \"timeZoneName\",\n      \"hourCycle\",\n    ]),\n    key = stringify(filtered),\n    dateTimeHuge = \"EEEE, LLLL d, yyyy, h:mm a\";\n  switch (key) {\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_SHORT):\n      return \"M/d/yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED):\n      return \"LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED_WITH_WEEKDAY):\n      return \"EEE, LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_FULL):\n      return \"LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_HUGE):\n      return \"EEEE, LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_SIMPLE):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SECONDS):\n      return \"h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SHORT_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_LONG_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_SIMPLE):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SECONDS):\n      return \"HH:mm:ss\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SHORT_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_LONG_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT):\n      return \"M/d/yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED):\n      return \"LLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL):\n      return \"LLLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE):\n      return dateTimeHuge;\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT_WITH_SECONDS):\n      return \"M/d/yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_SECONDS):\n      return \"LLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_WEEKDAY):\n      return \"EEE, d LLL yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL_WITH_SECONDS):\n      return \"LLLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE_WITH_SECONDS):\n      return \"EEEE, LLLL d, yyyy, h:mm:ss a\";\n    default:\n      return dateTimeHuge;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDUDs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQSw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVUsRUFBRSxTQUFTLGFBQWEsVUFBVSxFQUFFLFFBQVE7QUFDN0U7O0FBRU87QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQWtCO0FBQ3JDO0FBQ0EsbUJBQW1CLGlEQUFnQjtBQUNuQztBQUNBLG1CQUFtQiw4REFBNkI7QUFDaEQ7QUFDQSxtQkFBbUIsa0RBQWlCO0FBQ3BDO0FBQ0EsbUJBQW1CLGtEQUFpQjtBQUNwQztBQUNBLG1CQUFtQixvREFBbUI7QUFDdEM7QUFDQSxtQkFBbUIsMERBQXlCO0FBQzVDO0FBQ0EsbUJBQW1CLCtEQUE4QjtBQUNqRDtBQUNBLG1CQUFtQiw4REFBNkI7QUFDaEQ7QUFDQSxtQkFBbUIsdURBQXNCO0FBQ3pDO0FBQ0EsbUJBQW1CLDZEQUE0QjtBQUMvQztBQUNBLG1CQUFtQixrRUFBaUM7QUFDcEQ7QUFDQSxtQkFBbUIsaUVBQWdDO0FBQ25EO0FBQ0EsbUJBQW1CLHVEQUFzQjtBQUN6QztBQUNBLG1CQUFtQixxREFBb0I7QUFDdkM7QUFDQSxtQkFBbUIsc0RBQXFCO0FBQ3hDO0FBQ0EsbUJBQW1CLHNEQUFxQjtBQUN4QztBQUNBLG1CQUFtQixvRUFBbUM7QUFDdEQ7QUFDQSxtQkFBbUIsa0VBQWlDO0FBQ3BEO0FBQ0EsbUJBQW1CLGtFQUFpQztBQUNwRDtBQUNBLG1CQUFtQixtRUFBa0M7QUFDckQ7QUFDQSxtQkFBbUIsbUVBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2VuZ2xpc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwaWNrIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIE9iamVjdC5rZXlzKG9iaikuc29ydCgpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBjb25zdCBtb250aHNMb25nID0gW1xuICBcIkphbnVhcnlcIixcbiAgXCJGZWJydWFyeVwiLFxuICBcIk1hcmNoXCIsXG4gIFwiQXByaWxcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5lXCIsXG4gIFwiSnVseVwiLFxuICBcIkF1Z3VzdFwiLFxuICBcIlNlcHRlbWJlclwiLFxuICBcIk9jdG9iZXJcIixcbiAgXCJOb3ZlbWJlclwiLFxuICBcIkRlY2VtYmVyXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzU2hvcnQgPSBbXG4gIFwiSmFuXCIsXG4gIFwiRmViXCIsXG4gIFwiTWFyXCIsXG4gIFwiQXByXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuXCIsXG4gIFwiSnVsXCIsXG4gIFwiQXVnXCIsXG4gIFwiU2VwXCIsXG4gIFwiT2N0XCIsXG4gIFwiTm92XCIsXG4gIFwiRGVjXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzTmFycm93ID0gW1wiSlwiLCBcIkZcIiwgXCJNXCIsIFwiQVwiLCBcIk1cIiwgXCJKXCIsIFwiSlwiLCBcIkFcIiwgXCJTXCIsIFwiT1wiLCBcIk5cIiwgXCJEXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGNhc2UgXCIyLWRpZ2l0XCI6XG4gICAgICByZXR1cm4gW1wiMDFcIiwgXCIwMlwiLCBcIjAzXCIsIFwiMDRcIiwgXCIwNVwiLCBcIjA2XCIsIFwiMDdcIiwgXCIwOFwiLCBcIjA5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNMb25nID0gW1xuICBcIk1vbmRheVwiLFxuICBcIlR1ZXNkYXlcIixcbiAgXCJXZWRuZXNkYXlcIixcbiAgXCJUaHVyc2RheVwiLFxuICBcIkZyaWRheVwiLFxuICBcIlNhdHVyZGF5XCIsXG4gIFwiU3VuZGF5XCIsXG5dO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNTaG9ydCA9IFtcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTmFycm93ID0gW1wiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCIsIFwiU1wiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1lcmlkaWVtcyA9IFtcIkFNXCIsIFwiUE1cIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTG9uZyA9IFtcIkJlZm9yZSBDaHJpc3RcIiwgXCJBbm5vIERvbWluaVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNTaG9ydCA9IFtcIkJDXCIsIFwiQURcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTmFycm93ID0gW1wiQlwiLCBcIkFcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc0xvbmddO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyaWRpZW1Gb3JEYXRlVGltZShkdCkge1xuICByZXR1cm4gbWVyaWRpZW1zW2R0LmhvdXIgPCAxMiA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiB3ZWVrZGF5cyhsZW5ndGgpW2R0LndlZWtkYXkgLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gbW9udGhzKGxlbmd0aClbZHQubW9udGggLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGVyYXMobGVuZ3RoKVtkdC55ZWFyIDwgMCA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgbnVtZXJpYyA9IFwiYWx3YXlzXCIsIG5hcnJvdyA9IGZhbHNlKSB7XG4gIGNvbnN0IHVuaXRzID0ge1xuICAgIHllYXJzOiBbXCJ5ZWFyXCIsIFwieXIuXCJdLFxuICAgIHF1YXJ0ZXJzOiBbXCJxdWFydGVyXCIsIFwicXRyLlwiXSxcbiAgICBtb250aHM6IFtcIm1vbnRoXCIsIFwibW8uXCJdLFxuICAgIHdlZWtzOiBbXCJ3ZWVrXCIsIFwid2suXCJdLFxuICAgIGRheXM6IFtcImRheVwiLCBcImRheVwiLCBcImRheXNcIl0sXG4gICAgaG91cnM6IFtcImhvdXJcIiwgXCJoci5cIl0sXG4gICAgbWludXRlczogW1wibWludXRlXCIsIFwibWluLlwiXSxcbiAgICBzZWNvbmRzOiBbXCJzZWNvbmRcIiwgXCJzZWMuXCJdLFxuICB9O1xuXG4gIGNvbnN0IGxhc3RhYmxlID0gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXS5pbmRleE9mKHVuaXQpID09PSAtMTtcblxuICBpZiAobnVtZXJpYyA9PT0gXCJhdXRvXCIgJiYgbGFzdGFibGUpIHtcbiAgICBjb25zdCBpc0RheSA9IHVuaXQgPT09IFwiZGF5c1wiO1xuICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b21vcnJvd1wiIDogYG5leHQgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ5ZXN0ZXJkYXlcIiA6IGBsYXN0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b2RheVwiIDogYHRoaXMgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgZGVmYXVsdDogLy8gZmFsbCB0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaXNJblBhc3QgPSBPYmplY3QuaXMoY291bnQsIC0wKSB8fCBjb3VudCA8IDAsXG4gICAgZm10VmFsdWUgPSBNYXRoLmFicyhjb3VudCksXG4gICAgc2luZ3VsYXIgPSBmbXRWYWx1ZSA9PT0gMSxcbiAgICBsaWxVbml0cyA9IHVuaXRzW3VuaXRdLFxuICAgIGZtdFVuaXQgPSBuYXJyb3dcbiAgICAgID8gc2luZ3VsYXJcbiAgICAgICAgPyBsaWxVbml0c1sxXVxuICAgICAgICA6IGxpbFVuaXRzWzJdIHx8IGxpbFVuaXRzWzFdXG4gICAgICA6IHNpbmd1bGFyXG4gICAgICA/IHVuaXRzW3VuaXRdWzBdXG4gICAgICA6IHVuaXQ7XG4gIHJldHVybiBpc0luUGFzdCA/IGAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9IGFnb2AgOiBgaW4gJHtmbXRWYWx1ZX0gJHtmbXRVbml0fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJpbmcoa25vd25Gb3JtYXQpIHtcbiAgLy8gdGhlc2UgYWxsIGhhdmUgdGhlIG9mZnNldHMgcmVtb3ZlZCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoZW1cbiAgLy8gd2l0aG91dCBhbGwgdGhlIGludGwgc3R1ZmYgdGhpcyBpcyBiYWNrZmlsbGluZ1xuICBjb25zdCBmaWx0ZXJlZCA9IHBpY2soa25vd25Gb3JtYXQsIFtcbiAgICAgIFwid2Vla2RheVwiLFxuICAgICAgXCJlcmFcIixcbiAgICAgIFwieWVhclwiLFxuICAgICAgXCJtb250aFwiLFxuICAgICAgXCJkYXlcIixcbiAgICAgIFwiaG91clwiLFxuICAgICAgXCJtaW51dGVcIixcbiAgICAgIFwic2Vjb25kXCIsXG4gICAgICBcInRpbWVab25lTmFtZVwiLFxuICAgICAgXCJob3VyQ3ljbGVcIixcbiAgICBdKSxcbiAgICBrZXkgPSBzdHJpbmdpZnkoZmlsdGVyZWQpLFxuICAgIGRhdGVUaW1lSHVnZSA9IFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9IVUdFKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiSEg6bW06c3NcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0UpOlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBkIExMTCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/english.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formats.js":
/*!*************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/formats.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DATETIME_FULL: () => (/* binding */ DATETIME_FULL),\n/* harmony export */   DATETIME_FULL_WITH_SECONDS: () => (/* binding */ DATETIME_FULL_WITH_SECONDS),\n/* harmony export */   DATETIME_HUGE: () => (/* binding */ DATETIME_HUGE),\n/* harmony export */   DATETIME_HUGE_WITH_SECONDS: () => (/* binding */ DATETIME_HUGE_WITH_SECONDS),\n/* harmony export */   DATETIME_MED: () => (/* binding */ DATETIME_MED),\n/* harmony export */   DATETIME_MED_WITH_SECONDS: () => (/* binding */ DATETIME_MED_WITH_SECONDS),\n/* harmony export */   DATETIME_MED_WITH_WEEKDAY: () => (/* binding */ DATETIME_MED_WITH_WEEKDAY),\n/* harmony export */   DATETIME_SHORT: () => (/* binding */ DATETIME_SHORT),\n/* harmony export */   DATETIME_SHORT_WITH_SECONDS: () => (/* binding */ DATETIME_SHORT_WITH_SECONDS),\n/* harmony export */   DATE_FULL: () => (/* binding */ DATE_FULL),\n/* harmony export */   DATE_HUGE: () => (/* binding */ DATE_HUGE),\n/* harmony export */   DATE_MED: () => (/* binding */ DATE_MED),\n/* harmony export */   DATE_MED_WITH_WEEKDAY: () => (/* binding */ DATE_MED_WITH_WEEKDAY),\n/* harmony export */   DATE_SHORT: () => (/* binding */ DATE_SHORT),\n/* harmony export */   TIME_24_SIMPLE: () => (/* binding */ TIME_24_SIMPLE),\n/* harmony export */   TIME_24_WITH_LONG_OFFSET: () => (/* binding */ TIME_24_WITH_LONG_OFFSET),\n/* harmony export */   TIME_24_WITH_SECONDS: () => (/* binding */ TIME_24_WITH_SECONDS),\n/* harmony export */   TIME_24_WITH_SHORT_OFFSET: () => (/* binding */ TIME_24_WITH_SHORT_OFFSET),\n/* harmony export */   TIME_SIMPLE: () => (/* binding */ TIME_SIMPLE),\n/* harmony export */   TIME_WITH_LONG_OFFSET: () => (/* binding */ TIME_WITH_LONG_OFFSET),\n/* harmony export */   TIME_WITH_SECONDS: () => (/* binding */ TIME_WITH_SECONDS),\n/* harmony export */   TIME_WITH_SHORT_OFFSET: () => (/* binding */ TIME_WITH_SHORT_OFFSET)\n/* harmony export */ });\n/**\n * @private\n */\n\nconst n = \"numeric\",\n  s = \"short\",\n  l = \"long\";\n\nconst DATE_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n};\n\nconst DATE_MED = {\n  year: n,\n  month: s,\n  day: n,\n};\n\nconst DATE_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n};\n\nconst DATE_FULL = {\n  year: n,\n  month: l,\n  day: n,\n};\n\nconst DATE_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n};\n\nconst TIME_SIMPLE = {\n  hour: n,\n  minute: n,\n};\n\nconst TIME_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst TIME_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst TIME_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n\nconst TIME_24_SIMPLE = {\n  hour: n,\n  minute: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: s,\n};\n\nconst TIME_24_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: l,\n};\n\nconst DATETIME_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_SHORT_WITH_SECONDS = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_MED_WITH_SECONDS = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_FULL = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_FULL_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  timeZoneName: l,\n};\n\nconst DATETIME_HUGE_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IG4gPSBcIm51bWVyaWNcIixcbiAgcyA9IFwic2hvcnRcIixcbiAgbCA9IFwibG9uZ1wiO1xuXG5leHBvcnQgY29uc3QgREFURV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formats.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formatter.js":
/*!***************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/formatter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Formatter)\n/* harmony export */ });\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n\n\n\n\nfunction stringifyTokens(splits, tokenToString) {\n  let s = \"\";\n  for (const token of splits) {\n    if (token.literal) {\n      s += token.val;\n    } else {\n      s += tokenToString(token.val);\n    }\n  }\n  return s;\n}\n\nconst macroTokenToFormatOpts = {\n  D: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_SHORT,\n  DD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_MED,\n  DDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_FULL,\n  DDDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_HUGE,\n  t: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_SIMPLE,\n  tt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SECONDS,\n  ttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SHORT_OFFSET,\n  tttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_LONG_OFFSET,\n  T: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_SIMPLE,\n  TT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SECONDS,\n  TTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SHORT_OFFSET,\n  TTTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_LONG_OFFSET,\n  f: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT,\n  ff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED,\n  fff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL,\n  ffff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE,\n  F: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT_WITH_SECONDS,\n  FF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED_WITH_SECONDS,\n  FFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL_WITH_SECONDS,\n  FFFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE_WITH_SECONDS,\n};\n\n/**\n * @private\n */\n\nclass Formatter {\n  static create(locale, opts = {}) {\n    return new Formatter(locale, opts);\n  }\n\n  static parseFormat(fmt) {\n    // white-space is always considered a literal in user-provided formats\n    // the \" \" token has a special meaning (see unitForToken)\n\n    let current = null,\n      currentFull = \"\",\n      bracketed = false;\n    const splits = [];\n    for (let i = 0; i < fmt.length; i++) {\n      const c = fmt.charAt(i);\n      if (c === \"'\") {\n        // turn '' into a literal signal quote instead of just skipping the empty literal\n        if (currentFull.length > 0 || bracketed) {\n          splits.push({\n            literal: bracketed || /^\\s+$/.test(currentFull),\n            val: currentFull === \"\" ? \"'\" : currentFull,\n          });\n        }\n        current = null;\n        currentFull = \"\";\n        bracketed = !bracketed;\n      } else if (bracketed) {\n        currentFull += c;\n      } else if (c === current) {\n        currentFull += c;\n      } else {\n        if (currentFull.length > 0) {\n          splits.push({ literal: /^\\s+$/.test(currentFull), val: currentFull });\n        }\n        currentFull = c;\n        current = c;\n      }\n    }\n\n    if (currentFull.length > 0) {\n      splits.push({ literal: bracketed || /^\\s+$/.test(currentFull), val: currentFull });\n    }\n\n    return splits;\n  }\n\n  static macroTokenToFormatOpts(token) {\n    return macroTokenToFormatOpts[token];\n  }\n\n  constructor(locale, formatOpts) {\n    this.opts = formatOpts;\n    this.loc = locale;\n    this.systemLoc = null;\n  }\n\n  formatWithSystemDefault(dt, opts) {\n    if (this.systemLoc === null) {\n      this.systemLoc = this.loc.redefaultToSystem();\n    }\n    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });\n    return df.format();\n  }\n\n  dtFormatter(dt, opts = {}) {\n    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });\n  }\n\n  formatDateTime(dt, opts) {\n    return this.dtFormatter(dt, opts).format();\n  }\n\n  formatDateTimeParts(dt, opts) {\n    return this.dtFormatter(dt, opts).formatToParts();\n  }\n\n  formatInterval(interval, opts) {\n    const df = this.dtFormatter(interval.start, opts);\n    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());\n  }\n\n  resolvedOptions(dt, opts) {\n    return this.dtFormatter(dt, opts).resolvedOptions();\n  }\n\n  num(n, p = 0, signDisplay = undefined) {\n    // we get some perf out of doing this here, annoyingly\n    if (this.opts.forceSimple) {\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.padStart)(n, p);\n    }\n\n    const opts = { ...this.opts };\n\n    if (p > 0) {\n      opts.padTo = p;\n    }\n    if (signDisplay) {\n      opts.signDisplay = signDisplay;\n    }\n\n    return this.loc.numberFormatter(opts).format(n);\n  }\n\n  formatDateTimeFromString(dt, fmt) {\n    const knownEnglish = this.loc.listingMode() === \"en\",\n      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== \"gregory\",\n      string = (opts, extract) => this.loc.extract(dt, opts, extract),\n      formatOffset = (opts) => {\n        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {\n          return \"Z\";\n        }\n\n        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : \"\";\n      },\n      meridiem = () =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.meridiemForDateTime(dt)\n          : string({ hour: \"numeric\", hourCycle: \"h12\" }, \"dayperiod\"),\n      month = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.monthForDateTime(dt, length)\n          : string(standalone ? { month: length } : { month: length, day: \"numeric\" }, \"month\"),\n      weekday = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.weekdayForDateTime(dt, length)\n          : string(\n              standalone ? { weekday: length } : { weekday: length, month: \"long\", day: \"numeric\" },\n              \"weekday\"\n            ),\n      maybeMacro = (token) => {\n        const formatOpts = Formatter.macroTokenToFormatOpts(token);\n        if (formatOpts) {\n          return this.formatWithSystemDefault(dt, formatOpts);\n        } else {\n          return token;\n        }\n      },\n      era = (length) =>\n        knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_0__.eraForDateTime(dt, length) : string({ era: length }, \"era\"),\n      tokenToString = (token) => {\n        // Where possible: https://cldr.unicode.org/translation/date-time/date-time-symbols\n        switch (token) {\n          // ms\n          case \"S\":\n            return this.num(dt.millisecond);\n          case \"u\":\n          // falls through\n          case \"SSS\":\n            return this.num(dt.millisecond, 3);\n          // seconds\n          case \"s\":\n            return this.num(dt.second);\n          case \"ss\":\n            return this.num(dt.second, 2);\n          // fractional seconds\n          case \"uu\":\n            return this.num(Math.floor(dt.millisecond / 10), 2);\n          case \"uuu\":\n            return this.num(Math.floor(dt.millisecond / 100));\n          // minutes\n          case \"m\":\n            return this.num(dt.minute);\n          case \"mm\":\n            return this.num(dt.minute, 2);\n          // hours\n          case \"h\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);\n          case \"hh\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);\n          case \"H\":\n            return this.num(dt.hour);\n          case \"HH\":\n            return this.num(dt.hour, 2);\n          // offset\n          case \"Z\":\n            // like +6\n            return formatOffset({ format: \"narrow\", allowZ: this.opts.allowZ });\n          case \"ZZ\":\n            // like +06:00\n            return formatOffset({ format: \"short\", allowZ: this.opts.allowZ });\n          case \"ZZZ\":\n            // like +0600\n            return formatOffset({ format: \"techie\", allowZ: this.opts.allowZ });\n          case \"ZZZZ\":\n            // like EST\n            return dt.zone.offsetName(dt.ts, { format: \"short\", locale: this.loc.locale });\n          case \"ZZZZZ\":\n            // like Eastern Standard Time\n            return dt.zone.offsetName(dt.ts, { format: \"long\", locale: this.loc.locale });\n          // zone\n          case \"z\":\n            // like America/New_York\n            return dt.zoneName;\n          // meridiems\n          case \"a\":\n            return meridiem();\n          // dates\n          case \"d\":\n            return useDateTimeFormatter ? string({ day: \"numeric\" }, \"day\") : this.num(dt.day);\n          case \"dd\":\n            return useDateTimeFormatter ? string({ day: \"2-digit\" }, \"day\") : this.num(dt.day, 2);\n          // weekdays - standalone\n          case \"c\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"ccc\":\n            // like 'Tues'\n            return weekday(\"short\", true);\n          case \"cccc\":\n            // like 'Tuesday'\n            return weekday(\"long\", true);\n          case \"ccccc\":\n            // like 'T'\n            return weekday(\"narrow\", true);\n          // weekdays - format\n          case \"E\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"EEE\":\n            // like 'Tues'\n            return weekday(\"short\", false);\n          case \"EEEE\":\n            // like 'Tuesday'\n            return weekday(\"long\", false);\n          case \"EEEEE\":\n            // like 'T'\n            return weekday(\"narrow\", false);\n          // months - standalone\n          case \"L\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"LL\":\n            // like 01, doesn't seem to work\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"LLL\":\n            // like Jan\n            return month(\"short\", true);\n          case \"LLLL\":\n            // like January\n            return month(\"long\", true);\n          case \"LLLLL\":\n            // like J\n            return month(\"narrow\", true);\n          // months - format\n          case \"M\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"MM\":\n            // like 01\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"MMM\":\n            // like Jan\n            return month(\"short\", false);\n          case \"MMMM\":\n            // like January\n            return month(\"long\", false);\n          case \"MMMMM\":\n            // like J\n            return month(\"narrow\", false);\n          // years\n          case \"y\":\n            // like 2014\n            return useDateTimeFormatter ? string({ year: \"numeric\" }, \"year\") : this.num(dt.year);\n          case \"yy\":\n            // like 14\n            return useDateTimeFormatter\n              ? string({ year: \"2-digit\" }, \"year\")\n              : this.num(dt.year.toString().slice(-2), 2);\n          case \"yyyy\":\n            // like 0012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 4);\n          case \"yyyyyy\":\n            // like 000012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 6);\n          // eras\n          case \"G\":\n            // like AD\n            return era(\"short\");\n          case \"GG\":\n            // like Anno Domini\n            return era(\"long\");\n          case \"GGGGG\":\n            return era(\"narrow\");\n          case \"kk\":\n            return this.num(dt.weekYear.toString().slice(-2), 2);\n          case \"kkkk\":\n            return this.num(dt.weekYear, 4);\n          case \"W\":\n            return this.num(dt.weekNumber);\n          case \"WW\":\n            return this.num(dt.weekNumber, 2);\n          case \"n\":\n            return this.num(dt.localWeekNumber);\n          case \"nn\":\n            return this.num(dt.localWeekNumber, 2);\n          case \"ii\":\n            return this.num(dt.localWeekYear.toString().slice(-2), 2);\n          case \"iiii\":\n            return this.num(dt.localWeekYear, 4);\n          case \"o\":\n            return this.num(dt.ordinal);\n          case \"ooo\":\n            return this.num(dt.ordinal, 3);\n          case \"q\":\n            // like 1\n            return this.num(dt.quarter);\n          case \"qq\":\n            // like 01\n            return this.num(dt.quarter, 2);\n          case \"X\":\n            return this.num(Math.floor(dt.ts / 1000));\n          case \"x\":\n            return this.num(dt.ts);\n          default:\n            return maybeMacro(token);\n        }\n      };\n\n    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);\n  }\n\n  formatDurationFromString(dur, fmt) {\n    const invertLargest = this.opts.signMode === \"negativeLargestOnly\" ? -1 : 1;\n    const tokenToField = (token) => {\n        switch (token[0]) {\n          case \"S\":\n            return \"milliseconds\";\n          case \"s\":\n            return \"seconds\";\n          case \"m\":\n            return \"minutes\";\n          case \"h\":\n            return \"hours\";\n          case \"d\":\n            return \"days\";\n          case \"w\":\n            return \"weeks\";\n          case \"M\":\n            return \"months\";\n          case \"y\":\n            return \"years\";\n          default:\n            return null;\n        }\n      },\n      tokenToString = (lildur, info) => (token) => {\n        const mapped = tokenToField(token);\n        if (mapped) {\n          const inversionFactor =\n            info.isNegativeDuration && mapped !== info.largestUnit ? invertLargest : 1;\n          let signDisplay;\n          if (this.opts.signMode === \"negativeLargestOnly\" && mapped !== info.largestUnit) {\n            signDisplay = \"never\";\n          } else if (this.opts.signMode === \"all\") {\n            signDisplay = \"always\";\n          } else {\n            // \"auto\" and \"negative\" are the same, but \"auto\" has better support\n            signDisplay = \"auto\";\n          }\n          return this.num(lildur.get(mapped) * inversionFactor, token.length, signDisplay);\n        } else {\n          return token;\n        }\n      },\n      tokens = Formatter.parseFormat(fmt),\n      realTokens = tokens.reduce(\n        (found, { literal, val }) => (literal ? found : found.concat(val)),\n        []\n      ),\n      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t)),\n      durationInfo = {\n        isNegativeDuration: collapsed < 0,\n        // this relies on \"collapsed\" being based on \"shiftTo\", which builds up the object\n        // in order\n        largestUnit: Object.keys(collapsed.values)[0],\n      };\n    return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDQTtBQUNIOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLG1EQUFrQjtBQUN2QixNQUFNLGlEQUFnQjtBQUN0QixPQUFPLGtEQUFpQjtBQUN4QixRQUFRLGtEQUFpQjtBQUN6QixLQUFLLG9EQUFtQjtBQUN4QixNQUFNLDBEQUF5QjtBQUMvQixPQUFPLCtEQUE4QjtBQUNyQyxRQUFRLDhEQUE2QjtBQUNyQyxLQUFLLHVEQUFzQjtBQUMzQixNQUFNLDZEQUE0QjtBQUNsQyxPQUFPLGtFQUFpQztBQUN4QyxRQUFRLGlFQUFnQztBQUN4QyxLQUFLLHVEQUFzQjtBQUMzQixNQUFNLHFEQUFvQjtBQUMxQixPQUFPLHNEQUFxQjtBQUM1QixRQUFRLHNEQUFxQjtBQUM3QixLQUFLLG9FQUFtQztBQUN4QyxNQUFNLGtFQUFpQztBQUN2QyxPQUFPLG1FQUFrQztBQUN6QyxRQUFRLG1FQUFrQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZixpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLHNEQUFzRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1FQUFtRTtBQUN2Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixzQ0FBc0MsdUJBQXVCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0RBQVE7QUFDckI7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxZQUFZLDREQUEyQjtBQUN2QyxxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQSxZQUFZLHlEQUF3QjtBQUNwQyxrQ0FBa0MsZ0JBQWdCLElBQUksK0JBQStCO0FBQ3JGO0FBQ0E7QUFDQSxZQUFZLDJEQUEwQjtBQUN0QztBQUNBLDZCQUE2QixrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1QkFBdUIsdURBQXNCLHdCQUF3QixhQUFhO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0Esa0NBQWtDLDJDQUEyQztBQUM3RTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0EsK0NBQStDLDBDQUEwQztBQUN6RjtBQUNBO0FBQ0EsK0NBQStDLHlDQUF5QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0dGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwYWRTdGFydCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW5zKHNwbGl0cywgdG9rZW5Ub1N0cmluZykge1xuICBsZXQgcyA9IFwiXCI7XG4gIGZvciAoY29uc3QgdG9rZW4gb2Ygc3BsaXRzKSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHMgKz0gdG9rZW4udmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzICs9IHRva2VuVG9TdHJpbmcodG9rZW4udmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHMgPSB7XG4gIEQ6IEZvcm1hdHMuREFURV9TSE9SVCxcbiAgREQ6IEZvcm1hdHMuREFURV9NRUQsXG4gIERERDogRm9ybWF0cy5EQVRFX0ZVTEwsXG4gIEREREQ6IEZvcm1hdHMuREFURV9IVUdFLFxuICB0OiBGb3JtYXRzLlRJTUVfU0lNUExFLFxuICB0dDogRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyxcbiAgdHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VULFxuICBUOiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFLFxuICBUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIFRUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VULFxuICBmOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JULFxuICBmZjogRm9ybWF0cy5EQVRFVElNRV9NRUQsXG4gIGZmZjogRm9ybWF0cy5EQVRFVElNRV9GVUxMLFxuICBmZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0UsXG4gIEY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTLFxuICBGRjogRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTLFxuICBGRkY6IEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVyKGxvY2FsZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VGb3JtYXQoZm10KSB7XG4gICAgLy8gd2hpdGUtc3BhY2UgaXMgYWx3YXlzIGNvbnNpZGVyZWQgYSBsaXRlcmFsIGluIHVzZXItcHJvdmlkZWQgZm9ybWF0c1xuICAgIC8vIHRoZSBcIiBcIiB0b2tlbiBoYXMgYSBzcGVjaWFsIG1lYW5pbmcgKHNlZSB1bml0Rm9yVG9rZW4pXG5cbiAgICBsZXQgY3VycmVudCA9IG51bGwsXG4gICAgICBjdXJyZW50RnVsbCA9IFwiXCIsXG4gICAgICBicmFja2V0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZtdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgLy8gdHVybiAnJyBpbnRvIGEgbGl0ZXJhbCBzaWduYWwgcXVvdGUgaW5zdGVhZCBvZiBqdXN0IHNraXBwaW5nIHRoZSBlbXB0eSBsaXRlcmFsXG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwIHx8IGJyYWNrZXRlZCkge1xuICAgICAgICAgIHNwbGl0cy5wdXNoKHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSxcbiAgICAgICAgICAgIHZhbDogY3VycmVudEZ1bGwgPT09IFwiXCIgPyBcIidcIiA6IGN1cnJlbnRGdWxsLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjdXJyZW50RnVsbCA9IFwiXCI7XG4gICAgICAgIGJyYWNrZXRlZCA9ICFicmFja2V0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXRlZCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEZ1bGwgPSBjO1xuICAgICAgICBjdXJyZW50ID0gYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQgfHwgL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuXG4gIHN0YXRpYyBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKSB7XG4gICAgcmV0dXJuIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHNbdG9rZW5dO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBmb3JtYXRPcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gZm9ybWF0T3B0cztcbiAgICB0aGlzLmxvYyA9IGxvY2FsZTtcbiAgICB0aGlzLnN5c3RlbUxvYyA9IG51bGw7XG4gIH1cblxuICBmb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgb3B0cykge1xuICAgIGlmICh0aGlzLnN5c3RlbUxvYyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zeXN0ZW1Mb2MgPSB0aGlzLmxvYy5yZWRlZmF1bHRUb1N5c3RlbSgpO1xuICAgIH1cbiAgICBjb25zdCBkZiA9IHRoaXMuc3lzdGVtTG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH1cblxuICBkdEZvcm1hdHRlcihkdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLmZvcm1hdCgpO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVQYXJ0cyhkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5mb3JtYXRUb1BhcnRzKCk7XG4gIH1cblxuICBmb3JtYXRJbnRlcnZhbChpbnRlcnZhbCwgb3B0cykge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihpbnRlcnZhbC5zdGFydCwgb3B0cyk7XG4gICAgcmV0dXJuIGRmLmR0Zi5mb3JtYXRSYW5nZShpbnRlcnZhbC5zdGFydC50b0pTRGF0ZSgpLCBpbnRlcnZhbC5lbmQudG9KU0RhdGUoKSk7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cblxuICBudW0obiwgcCA9IDAsIHNpZ25EaXNwbGF5ID0gdW5kZWZpbmVkKSB7XG4gICAgLy8gd2UgZ2V0IHNvbWUgcGVyZiBvdXQgb2YgZG9pbmcgdGhpcyBoZXJlLCBhbm5veWluZ2x5XG4gICAgaWYgKHRoaXMub3B0cy5mb3JjZVNpbXBsZSkge1xuICAgICAgcmV0dXJuIHBhZFN0YXJ0KG4sIHApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuXG4gICAgaWYgKHAgPiAwKSB7XG4gICAgICBvcHRzLnBhZFRvID0gcDtcbiAgICB9XG4gICAgaWYgKHNpZ25EaXNwbGF5KSB7XG4gICAgICBvcHRzLnNpZ25EaXNwbGF5ID0gc2lnbkRpc3BsYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9jLm51bWJlckZvcm1hdHRlcihvcHRzKS5mb3JtYXQobik7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZtdCkge1xuICAgIGNvbnN0IGtub3duRW5nbGlzaCA9IHRoaXMubG9jLmxpc3RpbmdNb2RlKCkgPT09IFwiZW5cIixcbiAgICAgIHVzZURhdGVUaW1lRm9ybWF0dGVyID0gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgJiYgdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgIT09IFwiZ3JlZ29yeVwiLFxuICAgICAgc3RyaW5nID0gKG9wdHMsIGV4dHJhY3QpID0+IHRoaXMubG9jLmV4dHJhY3QoZHQsIG9wdHMsIGV4dHJhY3QpLFxuICAgICAgZm9ybWF0T2Zmc2V0ID0gKG9wdHMpID0+IHtcbiAgICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgICAgcmV0dXJuIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICAgIH0sXG4gICAgICBtZXJpZGllbSA9ICgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tZXJpZGllbUZvckRhdGVUaW1lKGR0KVxuICAgICAgICAgIDogc3RyaW5nKHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9LCBcImRheXBlcmlvZFwiKSxcbiAgICAgIG1vbnRoID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhzdGFuZGFsb25lID8geyBtb250aDogbGVuZ3RoIH0gOiB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKSxcbiAgICAgIHdlZWtkYXkgPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoXG4gICAgICAgICAgICAgIHN0YW5kYWxvbmUgPyB7IHdlZWtkYXk6IGxlbmd0aCB9IDogeyB3ZWVrZGF5OiBsZW5ndGgsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9LFxuICAgICAgICAgICAgICBcIndlZWtkYXlcIlxuICAgICAgICAgICAgKSxcbiAgICAgIG1heWJlTWFjcm8gPSAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKTtcbiAgICAgICAgaWYgKGZvcm1hdE9wdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgZm9ybWF0T3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJhID0gKGxlbmd0aCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoID8gRW5nbGlzaC5lcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSA6IHN0cmluZyh7IGVyYTogbGVuZ3RoIH0sIFwiZXJhXCIpLFxuICAgICAgdG9rZW5Ub1N0cmluZyA9ICh0b2tlbikgPT4ge1xuICAgICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cHM6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL2RhdGUtdGltZS9kYXRlLXRpbWUtc3ltYm9sc1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgLy8gbXNcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kLCAyKTtcbiAgICAgICAgICAvLyBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTApLCAyKTtcbiAgICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwMCkpO1xuICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSk7XG4gICAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuICAgICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIpO1xuICAgICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcIm5hcnJvd1wiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJzaG9ydFwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDYwMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJ0ZWNoaWVcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwic2hvcnRcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwibG9uZ1wiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICAvLyB6b25lXG4gICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAgIC8vIG1lcmlkaWVtc1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgICAvLyBkYXRlc1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwibnVtZXJpY1wiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5KTtcbiAgICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCIyLWRpZ2l0XCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXksIDIpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8geWVhcnNcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIikgOiB0aGlzLm51bShkdC55ZWFyKTtcbiAgICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwiMi1kaWdpdFwiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgICAvLyBlcmFzXG4gICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQURcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcbiAgICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJsb25nXCIpO1xuICAgICAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcbiAgICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla051bWJlcik7XG4gICAgICAgICAgY2FzZSBcIm5uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubG9jYWxXZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiaWlcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwiaWlpaVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla1llYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCk7XG4gICAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwsIDMpO1xuICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyKTtcbiAgICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQudHMgLyAxMDAwKSk7XG4gICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC50cyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1hY3JvKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIHRva2VuVG9TdHJpbmcpO1xuICB9XG5cbiAgZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKGR1ciwgZm10KSB7XG4gICAgY29uc3QgaW52ZXJ0TGFyZ2VzdCA9IHRoaXMub3B0cy5zaWduTW9kZSA9PT0gXCJuZWdhdGl2ZUxhcmdlc3RPbmx5XCIgPyAtMSA6IDE7XG4gICAgY29uc3QgdG9rZW5Ub0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRzXCI7XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInNlY29uZHNcIjtcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWludXRlc1wiO1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJob3Vyc1wiO1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJkYXlzXCI7XG4gICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgIHJldHVybiBcIndlZWtzXCI7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vbnRoc1wiO1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ5ZWFyc1wiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAobGlsZHVyLCBpbmZvKSA9PiAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdG9rZW5Ub0ZpZWxkKHRva2VuKTtcbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgIGNvbnN0IGludmVyc2lvbkZhY3RvciA9XG4gICAgICAgICAgICBpbmZvLmlzTmVnYXRpdmVEdXJhdGlvbiAmJiBtYXBwZWQgIT09IGluZm8ubGFyZ2VzdFVuaXQgPyBpbnZlcnRMYXJnZXN0IDogMTtcbiAgICAgICAgICBsZXQgc2lnbkRpc3BsYXk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0cy5zaWduTW9kZSA9PT0gXCJuZWdhdGl2ZUxhcmdlc3RPbmx5XCIgJiYgbWFwcGVkICE9PSBpbmZvLmxhcmdlc3RVbml0KSB7XG4gICAgICAgICAgICBzaWduRGlzcGxheSA9IFwibmV2ZXJcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5zaWduTW9kZSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgc2lnbkRpc3BsYXkgPSBcImFsd2F5c1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBcImF1dG9cIiBhbmQgXCJuZWdhdGl2ZVwiIGFyZSB0aGUgc2FtZSwgYnV0IFwiYXV0b1wiIGhhcyBiZXR0ZXIgc3VwcG9ydFxuICAgICAgICAgICAgc2lnbkRpc3BsYXkgPSBcImF1dG9cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGxpbGR1ci5nZXQobWFwcGVkKSAqIGludmVyc2lvbkZhY3RvciwgdG9rZW4ubGVuZ3RoLCBzaWduRGlzcGxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5zID0gRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksXG4gICAgICByZWFsVG9rZW5zID0gdG9rZW5zLnJlZHVjZShcbiAgICAgICAgKGZvdW5kLCB7IGxpdGVyYWwsIHZhbCB9KSA9PiAobGl0ZXJhbCA/IGZvdW5kIDogZm91bmQuY29uY2F0KHZhbCkpLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIGNvbGxhcHNlZCA9IGR1ci5zaGlmdFRvKC4uLnJlYWxUb2tlbnMubWFwKHRva2VuVG9GaWVsZCkuZmlsdGVyKCh0KSA9PiB0KSksXG4gICAgICBkdXJhdGlvbkluZm8gPSB7XG4gICAgICAgIGlzTmVnYXRpdmVEdXJhdGlvbjogY29sbGFwc2VkIDwgMCxcbiAgICAgICAgLy8gdGhpcyByZWxpZXMgb24gXCJjb2xsYXBzZWRcIiBiZWluZyBiYXNlZCBvbiBcInNoaWZ0VG9cIiwgd2hpY2ggYnVpbGRzIHVwIHRoZSBvYmplY3RcbiAgICAgICAgLy8gaW4gb3JkZXJcbiAgICAgICAgbGFyZ2VzdFVuaXQ6IE9iamVjdC5rZXlzKGNvbGxhcHNlZC52YWx1ZXMpWzBdLFxuICAgICAgfTtcbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKHRva2VucywgdG9rZW5Ub1N0cmluZyhjb2xsYXBzZWQsIGR1cmF0aW9uSW5mbykpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formatter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/invalid.js":
/*!*************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/invalid.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Invalid)\n/* harmony export */ });\nclass Invalid {\n  constructor(reason, explanation) {\n    this.reason = reason;\n    this.explanation = explanation;\n  }\n\n  toMessage() {\n    if (this.explanation) {\n      return `${this.reason}: ${this.explanation}`;\n    } else {\n      return this.reason;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVksSUFBSSxpQkFBaUI7QUFDakQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9pbnZhbGlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWQge1xuICBjb25zdHJ1Y3RvcihyZWFzb24sIGV4cGxhbmF0aW9uKSB7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5leHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uO1xuICB9XG5cbiAgdG9NZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLmV4cGxhbmF0aW9uKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5yZWFzb259OiAke3RoaXMuZXhwbGFuYXRpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/invalid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/locale.js":
/*!************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/locale.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Locale)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nconst intlDTCache = new Map();\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache.get(key);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache.set(key, dtf);\n  }\n  return dtf;\n}\n\nconst intlNumCache = new Map();\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache.set(key, inf);\n  }\n  return inf;\n}\n\nconst intlRelCache = new Map();\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache.set(key, inf);\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nconst intlResolvedOptionsCache = new Map();\nfunction getCachedIntResolvedOptions(locString) {\n  let opts = intlResolvedOptionsCache.get(locString);\n  if (opts === undefined) {\n    opts = new Intl.DateTimeFormat(locString).resolvedOptions();\n    intlResolvedOptionsCache.set(locString, opts);\n  }\n  return opts;\n}\n\nconst weekInfoCache = new Map();\nfunction getCachedWeekInfo(locString) {\n  let data = weekInfoCache.get(locString);\n  if (!data) {\n    const locale = new Intl.Locale(locString);\n    // browsers currently implement this as a property, but spec says it should be a getter function\n    data = \"getWeekInfo\" in locale ? locale.getWeekInfo() : locale.weekInfo;\n    // minimalDays was removed from WeekInfo: https://github.com/tc39/proposal-intl-locale-info/issues/86\n    if (!(\"minimalDays\" in data)) {\n      data = { ...fallbackWeekSettings, ...data };\n    }\n    weekInfoCache.set(locString, data);\n  }\n  return data;\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const { numberingSystem, calendar } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2009, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, englishFn, intlFn) {\n  const mode = loc.listingMode();\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      getCachedIntResolvedOptions(loc.locale).numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roundTo)(i, 3);\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n\n    let z = undefined;\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n      this.originalZone = dt.zone;\n    }\n\n    const intlOpts = { ...this.opts };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts()\n        .map(({ value }) => value)\n        .join(\"\");\n    }\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n    if (this.originalZone) {\n      return parts.map((part) => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName,\n          });\n          return {\n            ...part,\n            value: offsetName,\n          };\n        } else {\n          return part;\n        }\n      });\n    }\n    return parts;\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasRelative)()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return _english_js__WEBPACK_IMPORTED_MODULE_1__.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\nconst fallbackWeekSettings = {\n  firstDay: 1,\n  minimalDays: 4,\n  weekend: [6, 7],\n};\n\n/**\n * @private\n */\nclass Locale {\n  static fromOpts(opts) {\n    return Locale.create(\n      opts.locale,\n      opts.numberingSystem,\n      opts.outputCalendar,\n      opts.weekSettings,\n      opts.defaultToEN\n    );\n  }\n\n  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {\n    const specifiedLocale = locale || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLocale;\n    // the system locale is useful for human-readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultOutputCalendar;\n    const weekSettingsR = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(weekSettings) || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultWeekSettings;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache.clear();\n    intlNumCache.clear();\n    intlRelCache.clear();\n    intlResolvedOptionsCache.clear();\n    weekInfoCache.clear();\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);\n  }\n\n  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.weekSettings = weekSettings;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(alts.weekSettings) || this.weekSettings,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.months, () => {\n      // Workaround for \"ja\" locale: formatToParts does not label all parts of the month\n      // as \"month\" and for this locale there is no difference between \"format\" and \"non-format\".\n      // As such, just use format() instead of formatToParts() and take the whole string\n      const monthSpecialCase = this.intl === \"ja\" || this.intl.startsWith(\"ja-\");\n      format &= !monthSpecialCase;\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        const mapper = !monthSpecialCase\n          ? (dt) => this.extract(dt, intl, \"month\")\n          : (dt) => this.dtFormatter(dt, intl).format();\n        this.monthsCache[formatStr][length] = mapMonths(mapper);\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems() {\n    return listStuff(\n      this,\n      undefined,\n      () => _english_js__WEBPACK_IMPORTED_MODULE_1__.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 9), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(-40, 1, 1), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      getCachedIntResolvedOptions(this.intl).locale.startsWith(\"en-us\")\n    );\n  }\n\n  getWeekSettings() {\n    if (this.weekSettings) {\n      return this.weekSettings;\n    } else if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasLocaleWeekInfo)()) {\n      return fallbackWeekSettings;\n    } else {\n      return getCachedWeekInfo(this.locale);\n    }\n  }\n\n  getStartOfWeek() {\n    return this.getWeekSettings().firstDay;\n  }\n\n  getMinDaysInFirstWeek() {\n    return this.getWeekSettings().minimalDays;\n  }\n\n  getWeekendDays() {\n    return this.getWeekSettings().weekend;\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n\n  toString() {\n    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRztBQUM1RDtBQUNGO0FBQ0E7QUFDTTs7QUFFNUM7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUMsVUFBVSx3QkFBd0IsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBZTtBQUN6Qzs7QUFFQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFD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bm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2xvY2FsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNMb2NhbGVXZWVrSW5mbywgaGFzUmVsYXRpdmUsIHBhZFN0YXJ0LCByb3VuZFRvLCB2YWxpZGF0ZVdlZWtTZXR0aW5ncyB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vLyB0b2RvIC0gcmVtYXAgY2FjaGluZ1xuXG5sZXQgaW50bExGQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZExGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxMRkNhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuTGlzdEZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxMRkNhY2hlW2tleV0gPSBkdGY7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxuY29uc3QgaW50bERUQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRDYWNoZWREVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bERUQ2FjaGUuZ2V0KGtleSk7XG4gIGlmIChkdGYgPT09IHVuZGVmaW5lZCkge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bERUQ2FjaGUuc2V0KGtleSwgZHRmKTtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5jb25zdCBpbnRsTnVtQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRDYWNoZWRJTkYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgaW5mID0gaW50bE51bUNhY2hlLmdldChrZXkpO1xuICBpZiAoaW5mID09PSB1bmRlZmluZWQpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGUuc2V0KGtleSwgaW5mKTtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5jb25zdCBpbnRsUmVsQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYXNlLCAuLi5jYWNoZUtleU9wdHMgfSA9IG9wdHM7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsUmVsQ2FjaGUuZ2V0KGtleSk7XG4gIGlmIChpbmYgPT09IHVuZGVmaW5lZCkge1xuICAgIGluZiA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxSZWxDYWNoZS5zZXQoa2V5LCBpbmYpO1xuICB9XG4gIHJldHVybiBpbmY7XG59XG5cbmxldCBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG5mdW5jdGlvbiBzeXN0ZW1Mb2NhbGUoKSB7XG4gIGlmIChzeXNMb2NhbGVDYWNoZSkge1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfSBlbHNlIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlO1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfVxufVxuXG5jb25zdCBpbnRsUmVzb2x2ZWRPcHRpb25zQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRDYWNoZWRJbnRSZXNvbHZlZE9wdGlvbnMobG9jU3RyaW5nKSB7XG4gIGxldCBvcHRzID0gaW50bFJlc29sdmVkT3B0aW9uc0NhY2hlLmdldChsb2NTdHJpbmcpO1xuICBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY1N0cmluZykucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgaW50bFJlc29sdmVkT3B0aW9uc0NhY2hlLnNldChsb2NTdHJpbmcsIG9wdHMpO1xuICB9XG4gIHJldHVybiBvcHRzO1xufVxuXG5jb25zdCB3ZWVrSW5mb0NhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkV2Vla0luZm8obG9jU3RyaW5nKSB7XG4gIGxldCBkYXRhID0gd2Vla0luZm9DYWNoZS5nZXQobG9jU3RyaW5nKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgY29uc3QgbG9jYWxlID0gbmV3IEludGwuTG9jYWxlKGxvY1N0cmluZyk7XG4gICAgLy8gYnJvd3NlcnMgY3VycmVudGx5IGltcGxlbWVudCB0aGlzIGFzIGEgcHJvcGVydHksIGJ1dCBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGEgZ2V0dGVyIGZ1bmN0aW9uXG4gICAgZGF0YSA9IFwiZ2V0V2Vla0luZm9cIiBpbiBsb2NhbGUgPyBsb2NhbGUuZ2V0V2Vla0luZm8oKSA6IGxvY2FsZS53ZWVrSW5mbztcbiAgICAvLyBtaW5pbWFsRGF5cyB3YXMgcmVtb3ZlZCBmcm9tIFdlZWtJbmZvOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1pbnRsLWxvY2FsZS1pbmZvL2lzc3Vlcy84NlxuICAgIGlmICghKFwibWluaW1hbERheXNcIiBpbiBkYXRhKSkge1xuICAgICAgZGF0YSA9IHsgLi4uZmFsbGJhY2tXZWVrU2V0dGluZ3MsIC4uLmRhdGEgfTtcbiAgICB9XG4gICAgd2Vla0luZm9DYWNoZS5zZXQobG9jU3RyaW5nLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlU3RyKSB7XG4gIC8vIEkgcmVhbGx5IHdhbnQgdG8gYXZvaWQgd3JpdGluZyBhIEJDUCA0NyBwYXJzZXJcbiAgLy8gc2VlLCBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vYmNwLTQ3XG4gIC8vIEluc3RlYWQsIHdlJ2xsIGRvIHRoaXM6XG5cbiAgLy8gYSkgaWYgdGhlIHN0cmluZyBoYXMgbm8gLXUgZXh0ZW5zaW9ucywganVzdCBsZWF2ZSBpdCBhbG9uZVxuICAvLyBiKSBpZiBpdCBkb2VzLCB1c2UgSW50bCB0byByZXNvbHZlIGV2ZXJ5dGhpbmdcbiAgLy8gYykgaWYgSW50bCBmYWlscywgdHJ5IGFnYWluIHdpdGhvdXQgdGhlIC11XG5cbiAgLy8gcHJpdmF0ZSBzdWJ0YWdzIGFuZCB1bmljb2RlIHN1YnRhZ3MgaGF2ZSBvcmRlcmluZyByZXF1aXJlbWVudHMsXG4gIC8vIGFuZCB3ZSdyZSBub3QgcHJvcGVybHkgcGFyc2luZyB0aGlzLCBzbyBqdXN0IHN0cmlwIG91dCB0aGVcbiAgLy8gcHJpdmF0ZSBvbmVzIGlmIHRoZXkgZXhpc3QuXG4gIGNvbnN0IHhJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXgtXCIpO1xuICBpZiAoeEluZGV4ICE9PSAtMSkge1xuICAgIGxvY2FsZVN0ciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgeEluZGV4KTtcbiAgfVxuXG4gIGNvbnN0IHVJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXUtXCIpO1xuICBpZiAodUluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBbbG9jYWxlU3RyXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgc2VsZWN0ZWRTdHI7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYobG9jYWxlU3RyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gbG9jYWxlU3RyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHVJbmRleCk7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKHNtYWxsZXIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBzbWFsbGVyO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gW3NlbGVjdGVkU3RyLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRsQ29uZmlnU3RyaW5nKGxvY2FsZVN0ciwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikge1xuICBpZiAob3V0cHV0Q2FsZW5kYXIgfHwgbnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgaWYgKCFsb2NhbGVTdHIuaW5jbHVkZXMoXCItdS1cIikpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBcIi11XCI7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1jYS0ke291dHB1dENhbGVuZGFyfWA7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IGAtbnUtJHtudW1iZXJpbmdTeXN0ZW19YDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDA5LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGVuZ2xpc2hGbiwgaW50bEZuKSB7XG4gIGNvbnN0IG1vZGUgPSBsb2MubGlzdGluZ01vZGUoKTtcblxuICBpZiAobW9kZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJlblwiKSB7XG4gICAgcmV0dXJuIGVuZ2xpc2hGbihsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnRsRm4obGVuZ3RoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0Zhc3ROdW1iZXJzKGxvYykge1xuICBpZiAobG9jLm51bWJlcmluZ1N5c3RlbSAmJiBsb2MubnVtYmVyaW5nU3lzdGVtICE9PSBcImxhdG5cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFxuICAgICAgbG9jLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIgfHxcbiAgICAgICFsb2MubG9jYWxlIHx8XG4gICAgICBsb2MubG9jYWxlLnN0YXJ0c1dpdGgoXCJlblwiKSB8fFxuICAgICAgZ2V0Q2FjaGVkSW50UmVzb2x2ZWRPcHRpb25zKGxvYy5sb2NhbGUpLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCJcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5TnVtYmVyRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoaW50bCwgZm9yY2VTaW1wbGUsIG9wdHMpIHtcbiAgICB0aGlzLnBhZFRvID0gb3B0cy5wYWRUbyB8fCAwO1xuICAgIHRoaXMuZmxvb3IgPSBvcHRzLmZsb29yIHx8IGZhbHNlO1xuXG4gICAgY29uc3QgeyBwYWRUbywgZmxvb3IsIC4uLm90aGVyT3B0cyB9ID0gb3B0cztcblxuICAgIGlmICghZm9yY2VTaW1wbGUgfHwgT2JqZWN0LmtleXMob3RoZXJPcHRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpbnRsT3B0cyA9IHsgdXNlR3JvdXBpbmc6IGZhbHNlLCAuLi5vcHRzIH07XG4gICAgICBpZiAob3B0cy5wYWRUbyA+IDApIGludGxPcHRzLm1pbmltdW1JbnRlZ2VyRGlnaXRzID0gb3B0cy5wYWRUbztcbiAgICAgIHRoaXMuaW5mID0gZ2V0Q2FjaGVkSU5GKGludGwsIGludGxPcHRzKTtcbiAgICB9XG4gIH1cblxuICBmb3JtYXQoaSkge1xuICAgIGlmICh0aGlzLmluZikge1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IGk7XG4gICAgICByZXR1cm4gdGhpcy5pbmYuZm9ybWF0KGZpeGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG8gbWF0Y2ggdGhlIGJyb3dzZXIncyBudW1iZXJmb3JtYXR0ZXIgZGVmYXVsdHNcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiByb3VuZFRvKGksIDMpO1xuICAgICAgcmV0dXJuIHBhZFN0YXJ0KGZpeGVkLCB0aGlzLnBhZFRvKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlEYXRlRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoZHQsIGludGwsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMub3JpZ2luYWxab25lID0gdW5kZWZpbmVkO1xuXG4gICAgbGV0IHogPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMub3B0cy50aW1lWm9uZSkge1xuICAgICAgLy8gRG9uJ3QgYXBwbHkgYW55IHdvcmthcm91bmRzIGlmIGEgdGltZVpvbmUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBvcHRzXG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwiZml4ZWRcIikge1xuICAgICAgLy8gVVRDLTggb3IgRXRjL1VUQy04IGFyZSBub3QgcGFydCBvZiB0emRhdGEsIG9ubHkgRXRjL0dNVCs4IGFuZCB0aGUgbGlrZS5cbiAgICAgIC8vIFRoYXQgaXMgd2h5IGZpeGVkLW9mZnNldCBUWiBpcyBzZXQgdG8gdGhhdCB1bmxlc3MgaXQgaXM6XG4gICAgICAvLyAxLiBSZXByZXNlbnRpbmcgb2Zmc2V0IDAgd2hlbiBVVEMgaXMgdXNlZCB0byBtYWludGFpbiBwcmV2aW91cyBiZWhhdmlvciBhbmQgZG9lcyBub3QgYmVjb21lIEdNVC5cbiAgICAgIC8vIDIuIFVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyOlxuICAgICAgLy8gICAgLSBzb21lIGRvIG5vdCBzdXBwb3J0IEV0Yy9cbiAgICAgIC8vICAgIC0gPCBFdGMvR01ULTE0LCA+IEV0Yy9HTVQrMTIsIGFuZCAzMC1taW51dGUgb3IgNDUtbWludXRlIG9mZnNldHMgYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YVxuICAgICAgY29uc3QgZ210T2Zmc2V0ID0gLTEgKiAoZHQub2Zmc2V0IC8gNjApO1xuICAgICAgY29uc3Qgb2Zmc2V0WiA9IGdtdE9mZnNldCA+PSAwID8gYEV0Yy9HTVQrJHtnbXRPZmZzZXR9YCA6IGBFdGMvR01UJHtnbXRPZmZzZXR9YDtcbiAgICAgIGlmIChkdC5vZmZzZXQgIT09IDAgJiYgSUFOQVpvbmUuY3JlYXRlKG9mZnNldFopLnZhbGlkKSB7XG4gICAgICAgIHogPSBvZmZzZXRaO1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYWxsIGZpeGVkLW9mZnNldCB6b25lcyBsaWtlIEV0Yy8rNDozMCBhcmUgcHJlc2VudCBpbiB0emRhdGEgc29cbiAgICAgICAgLy8gd2UgbWFudWFsbHkgYXBwbHkgdGhlIG9mZnNldCBhbmQgc3Vic3RpdHV0ZSB0aGUgem9uZSBhcyBuZWVkZWQuXG4gICAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgICB0aGlzLmR0ID0gZHQub2Zmc2V0ID09PSAwID8gZHQgOiBkdC5zZXRab25lKFwiVVRDXCIpLnBsdXMoeyBtaW51dGVzOiBkdC5vZmZzZXQgfSk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxab25lID0gZHQuem9uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImlhbmFcIikge1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgeiA9IGR0LnpvbmUubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3VzdG9tIHpvbmVzIGNhbiBoYXZlIGFueSBvZmZzZXQgLyBvZmZzZXROYW1lIHNvIHdlIGp1c3QgbWFudWFsbHlcbiAgICAgIC8vIGFwcGx5IHRoZSBvZmZzZXQgYW5kIHN1YnN0aXR1dGUgdGhlIHpvbmUgYXMgbmVlZGVkLlxuICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICB0aGlzLmR0ID0gZHQuc2V0Wm9uZShcIlVUQ1wiKS5wbHVzKHsgbWludXRlczogZHQub2Zmc2V0IH0pO1xuICAgICAgdGhpcy5vcmlnaW5hbFpvbmUgPSBkdC56b25lO1xuICAgIH1cblxuICAgIGNvbnN0IGludGxPcHRzID0geyAuLi50aGlzLm9wdHMgfTtcbiAgICBpbnRsT3B0cy50aW1lWm9uZSA9IGludGxPcHRzLnRpbWVab25lIHx8IHo7XG4gICAgdGhpcy5kdGYgPSBnZXRDYWNoZWREVEYoaW50bCwgaW50bE9wdHMpO1xuICB9XG5cbiAgZm9ybWF0KCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsWm9uZSkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSB0byBzdWJzdGl0dXRlIGluIHRoZSBhY3R1YWwgem9uZSBuYW1lLCB3ZSBoYXZlIHRvIHVzZVxuICAgICAgLy8gZm9ybWF0VG9QYXJ0cyBzbyB0aGF0IHRoZSB0aW1lem9uZSBjYW4gYmUgcmVwbGFjZWQuXG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRUb1BhcnRzKClcbiAgICAgICAgLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSlcbiAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmR0Zi5mb3JtYXQodGhpcy5kdC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoKSB7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLmR0Zi5mb3JtYXRUb1BhcnRzKHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxab25lKSB7XG4gICAgICByZXR1cm4gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGltZVpvbmVOYW1lXCIpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXROYW1lID0gdGhpcy5vcmlnaW5hbFpvbmUub2Zmc2V0TmFtZSh0aGlzLmR0LnRzLCB7XG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuZHQubG9jYWxlLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdHMudGltZVpvbmVOYW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgICAgdmFsdWU6IG9mZnNldE5hbWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbiAgfVxuXG4gIHJlc29sdmVkT3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kdGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBQb2x5UmVsRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoaW50bCwgaXNFbmdsaXNoLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0geyBzdHlsZTogXCJsb25nXCIsIC4uLm9wdHMgfTtcbiAgICBpZiAoIWlzRW5nbGlzaCAmJiBoYXNSZWxhdGl2ZSgpKSB7XG4gICAgICB0aGlzLnJ0ZiA9IGdldENhY2hlZFJURihpbnRsLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICBmb3JtYXQoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRW5nbGlzaC5mb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIHRoaXMub3B0cy5udW1lcmljLCB0aGlzLm9wdHMuc3R5bGUgIT09IFwibG9uZ1wiKTtcbiAgICB9XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZmFsbGJhY2tXZWVrU2V0dGluZ3MgPSB7XG4gIGZpcnN0RGF5OiAxLFxuICBtaW5pbWFsRGF5czogNCxcbiAgd2Vla2VuZDogWzYsIDddLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbGUge1xuICBzdGF0aWMgZnJvbU9wdHMob3B0cykge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKFxuICAgICAgb3B0cy5sb2NhbGUsXG4gICAgICBvcHRzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgIG9wdHMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICBvcHRzLndlZWtTZXR0aW5ncyxcbiAgICAgIG9wdHMuZGVmYXVsdFRvRU5cbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIHdlZWtTZXR0aW5ncywgZGVmYXVsdFRvRU4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHNwZWNpZmllZExvY2FsZSA9IGxvY2FsZSB8fCBTZXR0aW5ncy5kZWZhdWx0TG9jYWxlO1xuICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4tcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgY29uc3QgbG9jYWxlUiA9IHNwZWNpZmllZExvY2FsZSB8fCAoZGVmYXVsdFRvRU4gPyBcImVuLVVTXCIgOiBzeXN0ZW1Mb2NhbGUoKSk7XG4gICAgY29uc3QgbnVtYmVyaW5nU3lzdGVtUiA9IG51bWJlcmluZ1N5c3RlbSB8fCBTZXR0aW5ncy5kZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICAgIGNvbnN0IG91dHB1dENhbGVuZGFyUiA9IG91dHB1dENhbGVuZGFyIHx8IFNldHRpbmdzLmRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICBjb25zdCB3ZWVrU2V0dGluZ3NSID0gdmFsaWRhdGVXZWVrU2V0dGluZ3Mod2Vla1NldHRpbmdzKSB8fCBTZXR0aW5ncy5kZWZhdWx0V2Vla1NldHRpbmdzO1xuICAgIHJldHVybiBuZXcgTG9jYWxlKGxvY2FsZVIsIG51bWJlcmluZ1N5c3RlbVIsIG91dHB1dENhbGVuZGFyUiwgd2Vla1NldHRpbmdzUiwgc3BlY2lmaWVkTG9jYWxlKTtcbiAgfVxuXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIHN5c0xvY2FsZUNhY2hlID0gbnVsbDtcbiAgICBpbnRsRFRDYWNoZS5jbGVhcigpO1xuICAgIGludGxOdW1DYWNoZS5jbGVhcigpO1xuICAgIGludGxSZWxDYWNoZS5jbGVhcigpO1xuICAgIGludGxSZXNvbHZlZE9wdGlvbnNDYWNoZS5jbGVhcigpO1xuICAgIHdlZWtJbmZvQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBudW1iZXJpbmcsIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMud2Vla1NldHRpbmdzID0gd2Vla1NldHRpbmdzO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZSgpIHtcbiAgICBjb25zdCBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpO1xuICAgIGNvbnN0IGhhc05vV2VpcmRuZXNzID1cbiAgICAgICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmXG4gICAgICAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG4gICAgcmV0dXJuIGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcyA/IFwiZW5cIiA6IFwiaW50bFwiO1xuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIHZhbGlkYXRlV2Vla1NldHRpbmdzKGFsdHMud2Vla1NldHRpbmdzKSB8fCB0aGlzLndlZWtTZXR0aW5ncyxcbiAgICAgICAgYWx0cy5kZWZhdWx0VG9FTiB8fCBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZWRlZmF1bHRUb0VOKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHsgLi4uYWx0cywgZGVmYXVsdFRvRU46IHRydWUgfSk7XG4gIH1cblxuICByZWRlZmF1bHRUb1N5c3RlbShhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiBmYWxzZSB9KTtcbiAgfVxuXG4gIG1vbnRocyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2gubW9udGhzLCAoKSA9PiB7XG4gICAgICAvLyBXb3JrYXJvdW5kIGZvciBcImphXCIgbG9jYWxlOiBmb3JtYXRUb1BhcnRzIGRvZXMgbm90IGxhYmVsIGFsbCBwYXJ0cyBvZiB0aGUgbW9udGhcbiAgICAgIC8vIGFzIFwibW9udGhcIiBhbmQgZm9yIHRoaXMgbG9jYWxlIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiBcImZvcm1hdFwiIGFuZCBcIm5vbi1mb3JtYXRcIi5cbiAgICAgIC8vIEFzIHN1Y2gsIGp1c3QgdXNlIGZvcm1hdCgpIGluc3RlYWQgb2YgZm9ybWF0VG9QYXJ0cygpIGFuZCB0YWtlIHRoZSB3aG9sZSBzdHJpbmdcbiAgICAgIGNvbnN0IG1vbnRoU3BlY2lhbENhc2UgPSB0aGlzLmludGwgPT09IFwiamFcIiB8fCB0aGlzLmludGwuc3RhcnRzV2l0aChcImphLVwiKTtcbiAgICAgIGZvcm1hdCAmPSAhbW9udGhTcGVjaWFsQ2FzZTtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXQgPyB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSA6IHsgbW9udGg6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9ICFtb250aFNwZWNpYWxDYXNlXG4gICAgICAgICAgPyAoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJtb250aFwiKVxuICAgICAgICAgIDogKGR0KSA9PiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBpbnRsKS5mb3JtYXQoKTtcbiAgICAgICAgdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBNb250aHMobWFwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIHdlZWtkYXlzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC53ZWVrZGF5cywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdFxuICAgICAgICAgID8geyB3ZWVrZGF5OiBsZW5ndGgsIHllYXI6IFwibnVtZXJpY1wiLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfVxuICAgICAgICAgIDogeyB3ZWVrZGF5OiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBXZWVrZGF5cygoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIndlZWtkYXlcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgbWVyaWRpZW1zKCkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYoXG4gICAgICB0aGlzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgKCkgPT4gRW5nbGlzaC5tZXJpZGllbXMsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIEluIHRoZW9yeSB0aGVyZSBjb3VsZCBiZSBhcmliaXRyYXJ5IGRheSBwZXJpb2RzLiBXZSdyZSBnb25uYSBhc3N1bWUgdGhlcmUgYXJlIGV4YWN0bHkgdHdvXG4gICAgICAgIC8vIGZvciBBTSBhbmQgUE0uIFRoaXMgaXMgcHJvYmFibHkgd3JvbmcsIGJ1dCBpdCdzIG1ha2VzIHBhcnNpbmcgd2F5IGVhc2llci5cbiAgICAgICAgaWYgKCF0aGlzLm1lcmlkaWVtQ2FjaGUpIHtcbiAgICAgICAgICBjb25zdCBpbnRsID0geyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH07XG4gICAgICAgICAgdGhpcy5tZXJpZGllbUNhY2hlID0gW0RhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDkpLCBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCAxOSldLm1hcChcbiAgICAgICAgICAgIChkdCkgPT4gdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImRheXBlcmlvZFwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZXJpZGllbUNhY2hlO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBlcmFzKGxlbmd0aCkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLmVyYXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSB7IGVyYTogbGVuZ3RoIH07XG5cbiAgICAgIC8vIFRoaXMgaXMgcHJvYmxlbWF0aWMuIERpZmZlcmVudCBjYWxlbmRhcnMgYXJlIGdvaW5nIHRvIGRlZmluZSBlcmFzIHRvdGFsbHkgZGlmZmVyZW50bHkuIFdoYXQgSSBuZWVkIGlzIHRoZSBtaW5pbXVtIHNldCBvZiBkYXRlc1xuICAgICAgLy8gdG8gZGVmaW5pdGVseSBlbnVtZXJhdGUgdGhlbS5cbiAgICAgIGlmICghdGhpcy5lcmFDYWNoZVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSA9IFtEYXRlVGltZS51dGMoLTQwLCAxLCAxKSwgRGF0ZVRpbWUudXRjKDIwMTcsIDEsIDEpXS5tYXAoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJlcmFcIilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4dHJhY3QoZHQsIGludGxPcHRzLCBmaWVsZCkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpLFxuICAgICAgcmVzdWx0cyA9IGRmLmZvcm1hdFRvUGFydHMoKSxcbiAgICAgIG1hdGNoaW5nID0gcmVzdWx0cy5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZmllbGQpO1xuICAgIHJldHVybiBtYXRjaGluZyA/IG1hdGNoaW5nLnZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIG51bWJlckZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICAvLyB0aGlzIGZvcmNlc2ltcGxlIG9wdGlvbiBpcyBuZXZlciB1c2VkICh0aGUgb25seSBjYWxsZXIgc2hvcnQtY2lyY3VpdHMgb24gaXQsIGJ1dCBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSlcbiAgICAvLyAoaW4gY29udHJhc3QsIHRoZSByZXN0IG9mIHRoZSBjb25kaXRpb24gaXMgdXNlZCBoZWF2aWx5KVxuICAgIHJldHVybiBuZXcgUG9seU51bWJlckZvcm1hdHRlcih0aGlzLmludGwsIG9wdHMuZm9yY2VTaW1wbGUgfHwgdGhpcy5mYXN0TnVtYmVycywgb3B0cyk7XG4gIH1cblxuICBkdEZvcm1hdHRlcihkdCwgaW50bE9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seURhdGVGb3JtYXR0ZXIoZHQsIHRoaXMuaW50bCwgaW50bE9wdHMpO1xuICB9XG5cbiAgcmVsRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seVJlbEZvcm1hdHRlcih0aGlzLmludGwsIHRoaXMuaXNFbmdsaXNoKCksIG9wdHMpO1xuICB9XG5cbiAgbGlzdEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gZ2V0Q2FjaGVkTEYodGhpcy5pbnRsLCBvcHRzKTtcbiAgfVxuXG4gIGlzRW5nbGlzaCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IFwiZW5cIiB8fFxuICAgICAgdGhpcy5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gXCJlbi11c1wiIHx8XG4gICAgICBnZXRDYWNoZWRJbnRSZXNvbHZlZE9wdGlvbnModGhpcy5pbnRsKS5sb2NhbGUuc3RhcnRzV2l0aChcImVuLXVzXCIpXG4gICAgKTtcbiAgfVxuXG4gIGdldFdlZWtTZXR0aW5ncygpIHtcbiAgICBpZiAodGhpcy53ZWVrU2V0dGluZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLndlZWtTZXR0aW5ncztcbiAgICB9IGVsc2UgaWYgKCFoYXNMb2NhbGVXZWVrSW5mbygpKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2tXZWVrU2V0dGluZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRDYWNoZWRXZWVrSW5mbyh0aGlzLmxvY2FsZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhcnRPZldlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1NldHRpbmdzKCkuZmlyc3REYXk7XG4gIH1cblxuICBnZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1NldHRpbmdzKCkubWluaW1hbERheXM7XG4gIH1cblxuICBnZXRXZWVrZW5kRGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXZWVrU2V0dGluZ3MoKS53ZWVrZW5kO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiZcbiAgICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBvdGhlci5udW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyXG4gICAgKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgTG9jYWxlKCR7dGhpcy5sb2NhbGV9LCAke3RoaXMubnVtYmVyaW5nU3lzdGVtfSwgJHt0aGlzLm91dHB1dENhbGVuZGFyfSlgO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/regexParser.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/regexParser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseHTTPDate: () => (/* binding */ parseHTTPDate),\n/* harmony export */   parseISODate: () => (/* binding */ parseISODate),\n/* harmony export */   parseISODuration: () => (/* binding */ parseISODuration),\n/* harmony export */   parseISOTimeOnly: () => (/* binding */ parseISOTimeOnly),\n/* harmony export */   parseRFC2822Date: () => (/* binding */ parseRFC2822Date),\n/* harmony export */   parseSQL: () => (/* binding */ parseSQL)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */\n\nconst ianaRegex = /[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;\n\nfunction combineRegexes(...regexes) {\n  const full = regexes.reduce((f, r) => f + r.source, \"\");\n  return RegExp(`^${full}$`);\n}\n\nfunction combineExtractors(...extractors) {\n  return (m) =>\n    extractors\n      .reduce(\n        ([mergedVals, mergedZone, cursor], ex) => {\n          const [val, zone, next] = ex(m, cursor);\n          return [{ ...mergedVals, ...val }, zone || mergedZone, next];\n        },\n        [{}, null, 1]\n      )\n      .slice(0, 2);\n}\n\nfunction parse(s, ...patterns) {\n  if (s == null) {\n    return [null, null];\n  }\n\n  for (const [regex, extractor] of patterns) {\n    const m = regex.exec(s);\n    if (m) {\n      return extractor(m);\n    }\n  }\n  return [null, null];\n}\n\nfunction simpleParse(...keys) {\n  return (match, cursor) => {\n    const ret = {};\n    let i;\n\n    for (i = 0; i < keys.length; i++) {\n      ret[keys[i]] = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(match[cursor + i]);\n    }\n    return [ret, null, cursor + i];\n  };\n}\n\n// ISO and SQL parsing\nconst offsetRegex = /(?:([Zz])|([+-]\\d\\d)(?::?(\\d\\d))?)/;\nconst isoExtendedZone = `(?:${offsetRegex.source}?(?:\\\\[(${ianaRegex.source})\\\\])?)?`;\nconst isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/;\nconst isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);\nconst isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);\nconst isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/;\nconst isoWeekRegex = /(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/;\nconst isoOrdinalRegex = /(\\d{4})-?(\\d{3})/;\nconst extractISOWeekData = simpleParse(\"weekYear\", \"weekNumber\", \"weekDay\");\nconst extractISOOrdinalData = simpleParse(\"year\", \"ordinal\");\nconst sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/; // dumbed-down version of the ISO one\nconst sqlTimeRegex = RegExp(\n  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`\n);\nconst sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);\n\nfunction int(match, pos, fallback) {\n  const m = match[pos];\n  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(m) ? fallback : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(m);\n}\n\nfunction extractISOYmd(match, cursor) {\n  const item = {\n    year: int(match, cursor),\n    month: int(match, cursor + 1, 1),\n    day: int(match, cursor + 2, 1),\n  };\n\n  return [item, null, cursor + 3];\n}\n\nfunction extractISOTime(match, cursor) {\n  const item = {\n    hours: int(match, cursor, 0),\n    minutes: int(match, cursor + 1, 0),\n    seconds: int(match, cursor + 2, 0),\n    milliseconds: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(match[cursor + 3]),\n  };\n\n  return [item, null, cursor + 4];\n}\n\nfunction extractISOOffset(match, cursor) {\n  const local = !match[cursor] && !match[cursor + 1],\n    fullOffset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(match[cursor + 1], match[cursor + 2]),\n    zone = local ? null : _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(fullOffset);\n  return [{}, zone, cursor + 3];\n}\n\nfunction extractIANAZone(match, cursor) {\n  const zone = match[cursor] ? _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(match[cursor]) : null;\n  return [{}, zone, cursor + 1];\n}\n\n// ISO time parsing\n\nconst isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);\n\n// ISO duration parsing\n\nconst isoDuration =\n  /^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;\n\nfunction extractISODuration(match) {\n  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =\n    match;\n\n  const hasNegativePrefix = s[0] === \"-\";\n  const negativeSeconds = secondStr && secondStr[0] === \"-\";\n\n  const maybeNegate = (num, force = false) =>\n    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;\n\n  return [\n    {\n      years: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(yearStr)),\n      months: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(monthStr)),\n      weeks: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(weekStr)),\n      days: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(dayStr)),\n      hours: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(hourStr)),\n      minutes: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(minuteStr)),\n      seconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(secondStr), secondStr === \"-0\"),\n      milliseconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(millisecondsStr), negativeSeconds),\n    },\n  ];\n}\n\n// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\nconst obsOffsets = {\n  GMT: 0,\n  EDT: -4 * 60,\n  EST: -5 * 60,\n  CDT: -5 * 60,\n  CST: -6 * 60,\n  MDT: -6 * 60,\n  MST: -7 * 60,\n  PDT: -7 * 60,\n  PST: -8 * 60,\n};\n\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n  const result = {\n    year: yearStr.length === 2 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr)) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr),\n    month: _english_js__WEBPACK_IMPORTED_MODULE_1__.monthsShort.indexOf(monthStr) + 1,\n    day: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(dayStr),\n    hour: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(hourStr),\n    minute: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(minuteStr),\n  };\n\n  if (secondStr) result.second = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(secondStr);\n  if (weekdayStr) {\n    result.weekday =\n      weekdayStr.length > 3\n        ? _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysLong.indexOf(weekdayStr) + 1\n        : _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysShort.indexOf(weekdayStr) + 1;\n  }\n\n  return result;\n}\n\n// RFC 2822/5322\nconst rfc2822 =\n  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\n\nfunction extractRFC2822(match) {\n  const [\n      ,\n      weekdayStr,\n      dayStr,\n      monthStr,\n      yearStr,\n      hourStr,\n      minuteStr,\n      secondStr,\n      obsOffset,\n      milOffset,\n      offHourStr,\n      offMinuteStr,\n    ] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  let offset;\n  if (obsOffset) {\n    offset = obsOffsets[obsOffset];\n  } else if (milOffset) {\n    offset = 0;\n  } else {\n    offset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(offHourStr, offMinuteStr);\n  }\n\n  return [result, new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](offset)];\n}\n\nfunction preprocessRFC2822(s) {\n  // Remove comments and folding whitespace and replace multiple-spaces with a single space\n  return s\n    .replace(/\\([^()]*\\)|[\\n\\t]/g, \" \")\n    .replace(/(\\s\\s+)/g, \" \")\n    .trim();\n}\n\n// http date\n\nconst rfc1123 =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  rfc850 =\n    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  ascii =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\n\nfunction extractRFC1123Or850(match) {\n  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nfunction extractASCII(match) {\n  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nconst isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nconst isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);\nconst isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);\nconst isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\n\nconst extractISOYmdTimeAndOffset = combineExtractors(\n  extractISOYmd,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOWeekTimeAndOffset = combineExtractors(\n  extractISOWeekData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOOrdinalDateAndTime = combineExtractors(\n  extractISOOrdinalData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOTimeAndOffset = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\n/*\n * @private\n */\n\nfunction parseISODate(s) {\n  return parse(\n    s,\n    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],\n    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],\n    [isoTimeCombinedRegex, extractISOTimeAndOffset]\n  );\n}\n\nfunction parseRFC2822Date(s) {\n  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);\n}\n\nfunction parseHTTPDate(s) {\n  return parse(\n    s,\n    [rfc1123, extractRFC1123Or850],\n    [rfc850, extractRFC1123Or850],\n    [ascii, extractASCII]\n  );\n}\n\nfunction parseISODuration(s) {\n  return parse(s, [isoDuration, extractISODuration]);\n}\n\nconst extractISOTimeOnly = combineExtractors(extractISOTime);\n\nfunction parseISOTimeOnly(s) {\n  return parse(s, [isoTimeOnly, extractISOTimeOnly]);\n}\n\nconst sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nconst sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\n\nconst extractISOTimeOffsetAndIANAZone = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\nfunction parseSQL(s) {\n  return parse(\n    s,\n    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvcmVnZXhQYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQU9tQjtBQUNxQjtBQUNrQjtBQUNkOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysd0JBQXdCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLE1BQU0sc0JBQXNCLE1BQU0sb0JBQW9CLE1BQU07O0FBRTNGO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDLFNBQVM7QUFDVCxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQyxxQkFBcUIsc0RBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUIsVUFBVSxpQkFBaUI7QUFDNUUsaUVBQWlFLEtBQUs7QUFDdEUsK0JBQStCLHdCQUF3QixFQUFFLGdCQUFnQjtBQUN6RSwrQ0FBK0Msb0JBQW9CO0FBQ25FLDZCQUE2QixFQUFFLElBQUksRUFBRTtBQUNyQywwQkFBMEIsRUFBRTtBQUM1Qiw2QkFBNkIsRUFBRSxPQUFPLEVBQUU7QUFDeEM7QUFDQTtBQUNBLHlCQUF5QixFQUFFLGtCQUFrQjtBQUM3QztBQUNBLEtBQUsseUJBQXlCLE1BQU0sbUJBQW1CLElBQUksaUJBQWlCO0FBQzVFO0FBQ0EsNENBQTRDLG9CQUFvQjs7QUFFaEU7QUFDQTtBQUNBLFNBQVMscURBQVcsaUJBQWlCLHNEQUFZO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQVc7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFZO0FBQzdCLDBCQUEwQixpRUFBZTtBQUN6QyxZQUFZO0FBQ1o7O0FBRUE7QUFDQSwrQkFBK0IsMERBQVE7QUFDdkMsWUFBWTtBQUNaOztBQUVBOztBQUVBLGlDQUFpQyx3QkFBd0I7O0FBRXpEOztBQUVBO0FBQ0EsbUJBQW1CLEtBQUssUUFBUSxLQUFLLGVBQWUsS0FBSyxRQUFRLEtBQUssZUFBZSxLQUFLLFFBQVEsS0FBSyxlQUFlLEtBQUssUUFBUSxLQUFLLG1CQUFtQixLQUFLLFFBQVEsS0FBSyxlQUFlLEtBQUssUUFBUSxLQUFLLGVBQWUsS0FBSyxjQUFjLEtBQUs7O0FBRXJQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qix1REFBYTtBQUN0QywwQkFBMEIsdURBQWE7QUFDdkMseUJBQXlCLHVEQUFhO0FBQ3RDLHdCQUF3Qix1REFBYTtBQUNyQyx5QkFBeUIsdURBQWE7QUFDdEMsMkJBQTJCLHVEQUFhO0FBQ3hDLDJCQUEyQix1REFBYTtBQUN4QyxnQ0FBZ0MscURBQVc7QUFDM0MsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUFjLENBQUMsc0RBQVksYUFBYSxzREFBWTtBQUNyRixXQUFXLG9EQUFtQjtBQUM5QixTQUFTLHNEQUFZO0FBQ3JCLFVBQVUsc0RBQVk7QUFDdEIsWUFBWSxzREFBWTtBQUN4Qjs7QUFFQSxpQ0FBaUMsc0RBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBb0I7QUFDOUIsVUFBVSxzREFBcUI7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUksMERBQTBELElBQUk7O0FBRS9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixhQUFhLHNEQUFZO0FBQ3pCOztBQUVBLHNCQUFzQixpRUFBZTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtHQUFrRyxFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSCxFQUFFOztBQUU1SDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFlO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvcmVnZXhQYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdW50cnVuY2F0ZVllYXIsXG4gIHNpZ25lZE9mZnNldCxcbiAgcGFyc2VJbnRlZ2VyLFxuICBwYXJzZU1pbGxpcyxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmNvbnN0IGlhbmFSZWdleCA9IC9bQS1aYS16XystXXsxLDI1Nn0oPzo6P1xcL1tBLVphLXowLTlfKy1dezEsMjU2fSg/OlxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnZXhlcyguLi5yZWdleGVzKSB7XG4gIGNvbnN0IGZ1bGwgPSByZWdleGVzLnJlZHVjZSgoZiwgcikgPT4gZiArIHIuc291cmNlLCBcIlwiKTtcbiAgcmV0dXJuIFJlZ0V4cChgXiR7ZnVsbH0kYCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFeHRyYWN0b3JzKC4uLmV4dHJhY3RvcnMpIHtcbiAgcmV0dXJuIChtKSA9PlxuICAgIGV4dHJhY3RvcnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbbWVyZ2VkVmFscywgbWVyZ2VkWm9uZSwgY3Vyc29yXSwgZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBbdmFsLCB6b25lLCBuZXh0XSA9IGV4KG0sIGN1cnNvcik7XG4gICAgICAgICAgcmV0dXJuIFt7IC4uLm1lcmdlZFZhbHMsIC4uLnZhbCB9LCB6b25lIHx8IG1lcmdlZFpvbmUsIG5leHRdO1xuICAgICAgICB9LFxuICAgICAgICBbe30sIG51bGwsIDFdXG4gICAgICApXG4gICAgICAuc2xpY2UoMCwgMik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHMsIC4uLnBhdHRlcm5zKSB7XG4gIGlmIChzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgZm9yIChjb25zdCBbcmVnZXgsIGV4dHJhY3Rvcl0gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtID0gcmVnZXguZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RvcihtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtudWxsLCBudWxsXTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlUGFyc2UoLi4ua2V5cykge1xuICByZXR1cm4gKG1hdGNoLCBjdXJzb3IpID0+IHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRba2V5c1tpXV0gPSBwYXJzZUludGVnZXIobWF0Y2hbY3Vyc29yICsgaV0pO1xuICAgIH1cbiAgICByZXR1cm4gW3JldCwgbnVsbCwgY3Vyc29yICsgaV07XG4gIH07XG59XG5cbi8vIElTTyBhbmQgU1FMIHBhcnNpbmdcbmNvbnN0IG9mZnNldFJlZ2V4ID0gLyg/OihbWnpdKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pLztcbmNvbnN0IGlzb0V4dGVuZGVkWm9uZSA9IGAoPzoke29mZnNldFJlZ2V4LnNvdXJjZX0/KD86XFxcXFsoJHtpYW5hUmVnZXguc291cmNlfSlcXFxcXSk/KT9gO1xuY29uc3QgaXNvVGltZUJhc2VSZWdleCA9IC8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Wy4sXShcXGR7MSwzMH0pKT8pPyk/LztcbmNvbnN0IGlzb1RpbWVSZWdleCA9IFJlZ0V4cChgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0ke2lzb0V4dGVuZGVkWm9uZX1gKTtcbmNvbnN0IGlzb1RpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86W1R0XSR7aXNvVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuY29uc3QgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy87XG5jb25zdCBpc29XZWVrUmVnZXggPSAvKFxcZHs0fSktP1coXFxkXFxkKSg/Oi0/KFxcZCkpPy87XG5jb25zdCBpc29PcmRpbmFsUmVnZXggPSAvKFxcZHs0fSktPyhcXGR7M30pLztcbmNvbnN0IGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0YSA9IHNpbXBsZVBhcnNlKFwieWVhclwiLCBcIm9yZGluYWxcIik7XG5jb25zdCBzcWxZbWRSZWdleCA9IC8oXFxkezR9KS0oXFxkXFxkKS0oXFxkXFxkKS87IC8vIGR1bWJlZC1kb3duIHZlcnNpb24gb2YgdGhlIElTTyBvbmVcbmNvbnN0IHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9ID8oPzoke29mZnNldFJlZ2V4LnNvdXJjZX18KCR7aWFuYVJlZ2V4LnNvdXJjZX0pKT9gXG4pO1xuY29uc3Qgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pWSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pVyk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pRCk/KD86VCg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUgpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsMjB9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICBjb25zdCBbcywgeWVhclN0ciwgbW9udGhTdHIsIHdlZWtTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIG1pbGxpc2Vjb25kc1N0cl0gPVxuICAgIG1hdGNoO1xuXG4gIGNvbnN0IGhhc05lZ2F0aXZlUHJlZml4ID0gc1swXSA9PT0gXCItXCI7XG4gIGNvbnN0IG5lZ2F0aXZlU2Vjb25kcyA9IHNlY29uZFN0ciAmJiBzZWNvbmRTdHJbMF0gPT09IFwiLVwiO1xuXG4gIGNvbnN0IG1heWJlTmVnYXRlID0gKG51bSwgZm9yY2UgPSBmYWxzZSkgPT5cbiAgICBudW0gIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgKG51bSAmJiBoYXNOZWdhdGl2ZVByZWZpeCkpID8gLW51bSA6IG51bTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHllYXJTdHIpKSxcbiAgICAgIG1vbnRoczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtb250aFN0cikpLFxuICAgICAgd2Vla3M6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcod2Vla1N0cikpLFxuICAgICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhkYXlTdHIpKSxcbiAgICAgIGhvdXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGhvdXJTdHIpKSxcbiAgICAgIG1pbnV0ZXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobWludXRlU3RyKSksXG4gICAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHNlY29uZFN0ciksIHNlY29uZFN0ciA9PT0gXCItMFwiKSxcbiAgICAgIG1pbGxpc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VNaWxsaXMobWlsbGlzZWNvbmRzU3RyKSwgbmVnYXRpdmVTZWNvbmRzKSxcbiAgICB9LFxuICBdO1xufVxuXG4vLyBUaGVzZSBhcmUgYSBsaXR0bGUgYnJhaW5kZWFkLiBFRFQgKnNob3VsZCogdGVsbCB1cyB0aGF0IHdlJ3JlIGluLCBzYXksIEFtZXJpY2EvTmV3X1lvcmtcbi8vIGFuZCBub3QganVzdCB0aGF0IHdlJ3JlIGluIC0yNDAgKnJpZ2h0IG5vdyouIEJ1dCBzaW5jZSBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSB1c2VkIHRoYXQgb2Z0ZW5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGlnbm9yZSB0aGF0XG5jb25zdCBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwLFxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHllYXI6IHllYXJTdHIubGVuZ3RoID09PSAyID8gdW50cnVuY2F0ZVllYXIocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSA6IHBhcnNlSW50ZWdlcih5ZWFyU3RyKSxcbiAgICBtb250aDogRW5nbGlzaC5tb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSArIDEsXG4gICAgZGF5OiBwYXJzZUludGVnZXIoZGF5U3RyKSxcbiAgICBob3VyOiBwYXJzZUludGVnZXIoaG91clN0ciksXG4gICAgbWludXRlOiBwYXJzZUludGVnZXIobWludXRlU3RyKSxcbiAgfTtcblxuICBpZiAoc2Vjb25kU3RyKSByZXN1bHQuc2Vjb25kID0gcGFyc2VJbnRlZ2VyKHNlY29uZFN0cik7XG4gIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgcmVzdWx0LndlZWtkYXkgPVxuICAgICAgd2Vla2RheVN0ci5sZW5ndGggPiAzXG4gICAgICAgID8gRW5nbGlzaC53ZWVrZGF5c0xvbmcuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDFcbiAgICAgICAgOiBFbmdsaXNoLndlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSRkMgMjgyMi81MzIyXG5jb25zdCByZmMyODIyID1cbiAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSxcXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KD86KFsrLV1cXGRcXGQpKFxcZFxcZCkpKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMjgyMihtYXRjaCkge1xuICBjb25zdCBbXG4gICAgICAsXG4gICAgICB3ZWVrZGF5U3RyLFxuICAgICAgZGF5U3RyLFxuICAgICAgbW9udGhTdHIsXG4gICAgICB5ZWFyU3RyLFxuICAgICAgaG91clN0cixcbiAgICAgIG1pbnV0ZVN0cixcbiAgICAgIHNlY29uZFN0cixcbiAgICAgIG9ic09mZnNldCxcbiAgICAgIG1pbE9mZnNldCxcbiAgICAgIG9mZkhvdXJTdHIsXG4gICAgICBvZmZNaW51dGVTdHIsXG4gICAgXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcblxuICBsZXQgb2Zmc2V0O1xuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCBcIiBcIilcbiAgICAudHJpbSgpO1xufVxuXG4vLyBodHRwIGRhdGVcblxuY29uc3QgcmZjMTEyMyA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSwgKFxcZFxcZCkgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoXFxkezR9KSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgcmZjODUwID1cbiAgICAvXihNb25kYXl8VHVlc2RheXxXZWRuZXNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIGFzY2lpID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKCBcXGR8XFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSAoXFxkezR9KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMTEyM09yODUwKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIGRheVN0ciwgbW9udGhTdHIsIHllYXJTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBU0NJSShtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgeWVhclN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5jb25zdCBpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvWW1kUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1dlZWtSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvT3JkaW5hbFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29UaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPWW1kLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuLypcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZV0sXG4gICAgW2lzb1RpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZUFuZE9mZnNldF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtyZmMxMTIzLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbYXNjaWksIGV4dHJhY3RBU0NJSV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cblxuY29uc3QgZXh0cmFjdElTT1RpbWVPbmx5ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09UaW1lT25seShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvVGltZU9ubHksIGV4dHJhY3RJU09UaW1lT25seV0pO1xufVxuXG5jb25zdCBzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsWW1kUmVnZXgsIHNxbFRpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/regexParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/tokenParser.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/tokenParser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TokenParser: () => (/* binding */ TokenParser),\n/* harmony export */   expandMacroTokens: () => (/* binding */ expandMacroTokens),\n/* harmony export */   explainFromTokens: () => (/* binding */ explainFromTokens),\n/* harmony export */   formatOptsToTokens: () => (/* binding */ formatOptsToTokens),\n/* harmony export */   parseFromTokens: () => (/* binding */ parseFromTokens)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _digits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./digits.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/digits.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\");\n\n\n\n\n\n\n\n\nconst MISSING_FTP = \"missing Intl.DateTimeFormat.formatToParts support\";\n\nfunction intUnit(regex, post = (i) => i) {\n  return { regex, deser: ([s]) => post((0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.parseDigits)(s)) };\n}\n\nconst NBSP = String.fromCharCode(160);\nconst spaceOrNBSP = `[ ${NBSP}]`;\nconst spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, \"g\");\n\nfunction fixListRegex(s) {\n  // make dots optional and also make them literal\n  // make space and non breakable space characters interchangeable\n  return s.replace(/\\./g, \"\\\\.?\").replace(spaceOrNBSPRegExp, spaceOrNBSP);\n}\n\nfunction stripInsensitivities(s) {\n  return s\n    .replace(/\\./g, \"\") // ignore dots that were made optional\n    .replace(spaceOrNBSPRegExp, \" \") // interchange space and nbsp\n    .toLowerCase();\n}\n\nfunction oneOf(strings, startIndex) {\n  if (strings === null) {\n    return null;\n  } else {\n    return {\n      regex: RegExp(strings.map(fixListRegex).join(\"|\")),\n      deser: ([s]) =>\n        strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,\n    };\n  }\n}\n\nfunction offset(regex, groups) {\n  return { regex, deser: ([, h, m]) => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(h, m), groups };\n}\n\nfunction simple(regex) {\n  return { regex, deser: ([s]) => s };\n}\n\nfunction escapeToken(value) {\n  return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n\n/**\n * @param token\n * @param {Locale} loc\n */\nfunction unitForToken(token, loc) {\n  const one = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc),\n    two = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2}\"),\n    three = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{3}\"),\n    four = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4}\"),\n    six = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{6}\"),\n    oneOrTwo = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,2}\"),\n    oneToThree = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,3}\"),\n    oneToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,6}\"),\n    oneToNine = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,9}\"),\n    twoToFour = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2,4}\"),\n    fourToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4,6}\"),\n    literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),\n    unitate = (t) => {\n      if (token.literal) {\n        return literal(t);\n      }\n      switch (t.val) {\n        // era\n        case \"G\":\n          return oneOf(loc.eras(\"short\"), 0);\n        case \"GG\":\n          return oneOf(loc.eras(\"long\"), 0);\n        // years\n        case \"y\":\n          return intUnit(oneToSix);\n        case \"yy\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        case \"yyyy\":\n          return intUnit(four);\n        case \"yyyyy\":\n          return intUnit(fourToSix);\n        case \"yyyyyy\":\n          return intUnit(six);\n        // months\n        case \"M\":\n          return intUnit(oneOrTwo);\n        case \"MM\":\n          return intUnit(two);\n        case \"MMM\":\n          return oneOf(loc.months(\"short\", true), 1);\n        case \"MMMM\":\n          return oneOf(loc.months(\"long\", true), 1);\n        case \"L\":\n          return intUnit(oneOrTwo);\n        case \"LL\":\n          return intUnit(two);\n        case \"LLL\":\n          return oneOf(loc.months(\"short\", false), 1);\n        case \"LLLL\":\n          return oneOf(loc.months(\"long\", false), 1);\n        // dates\n        case \"d\":\n          return intUnit(oneOrTwo);\n        case \"dd\":\n          return intUnit(two);\n        // ordinals\n        case \"o\":\n          return intUnit(oneToThree);\n        case \"ooo\":\n          return intUnit(three);\n        // time\n        case \"HH\":\n          return intUnit(two);\n        case \"H\":\n          return intUnit(oneOrTwo);\n        case \"hh\":\n          return intUnit(two);\n        case \"h\":\n          return intUnit(oneOrTwo);\n        case \"mm\":\n          return intUnit(two);\n        case \"m\":\n          return intUnit(oneOrTwo);\n        case \"q\":\n          return intUnit(oneOrTwo);\n        case \"qq\":\n          return intUnit(two);\n        case \"s\":\n          return intUnit(oneOrTwo);\n        case \"ss\":\n          return intUnit(two);\n        case \"S\":\n          return intUnit(oneToThree);\n        case \"SSS\":\n          return intUnit(three);\n        case \"u\":\n          return simple(oneToNine);\n        case \"uu\":\n          return simple(oneOrTwo);\n        case \"uuu\":\n          return intUnit(one);\n        // meridiem\n        case \"a\":\n          return oneOf(loc.meridiems(), 0);\n        // weekYear (k)\n        case \"kkkk\":\n          return intUnit(four);\n        case \"kk\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        // weekNumber (W)\n        case \"W\":\n          return intUnit(oneOrTwo);\n        case \"WW\":\n          return intUnit(two);\n        // weekdays\n        case \"E\":\n        case \"c\":\n          return intUnit(one);\n        case \"EEE\":\n          return oneOf(loc.weekdays(\"short\", false), 1);\n        case \"EEEE\":\n          return oneOf(loc.weekdays(\"long\", false), 1);\n        case \"ccc\":\n          return oneOf(loc.weekdays(\"short\", true), 1);\n        case \"cccc\":\n          return oneOf(loc.weekdays(\"long\", true), 1);\n        // offset/zone\n        case \"Z\":\n        case \"ZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);\n        case \"ZZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);\n        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing\n        // because we don't have any way to figure out what they are\n        case \"z\":\n          return simple(/[a-z_+-/]{1,256}?/i);\n        // this special-case \"token\" represents a place where a macro-token expanded into a white-space literal\n        // in this case we accept any non-newline white-space\n        case \" \":\n          return simple(/[^\\S\\n\\r]/);\n        default:\n          return literal(t);\n      }\n    };\n\n  const unit = unitate(token) || {\n    invalidReason: MISSING_FTP,\n  };\n\n  unit.token = token;\n\n  return unit;\n}\n\nconst partTypeStyleToTokenVal = {\n  year: {\n    \"2-digit\": \"yy\",\n    numeric: \"yyyyy\",\n  },\n  month: {\n    numeric: \"M\",\n    \"2-digit\": \"MM\",\n    short: \"MMM\",\n    long: \"MMMM\",\n  },\n  day: {\n    numeric: \"d\",\n    \"2-digit\": \"dd\",\n  },\n  weekday: {\n    short: \"EEE\",\n    long: \"EEEE\",\n  },\n  dayperiod: \"a\",\n  dayPeriod: \"a\",\n  hour12: {\n    numeric: \"h\",\n    \"2-digit\": \"hh\",\n  },\n  hour24: {\n    numeric: \"H\",\n    \"2-digit\": \"HH\",\n  },\n  minute: {\n    numeric: \"m\",\n    \"2-digit\": \"mm\",\n  },\n  second: {\n    numeric: \"s\",\n    \"2-digit\": \"ss\",\n  },\n  timeZoneName: {\n    long: \"ZZZZZ\",\n    short: \"ZZZ\",\n  },\n};\n\nfunction tokenForPart(part, formatOpts, resolvedOpts) {\n  const { type, value } = part;\n\n  if (type === \"literal\") {\n    const isSpace = /^\\s+$/.test(value);\n    return {\n      literal: !isSpace,\n      val: isSpace ? \" \" : value,\n    };\n  }\n\n  const style = formatOpts[type];\n\n  // The user might have explicitly specified hour12 or hourCycle\n  // if so, respect their decision\n  // if not, refer back to the resolvedOpts, which are based on the locale\n  let actualType = type;\n  if (type === \"hour\") {\n    if (formatOpts.hour12 != null) {\n      actualType = formatOpts.hour12 ? \"hour12\" : \"hour24\";\n    } else if (formatOpts.hourCycle != null) {\n      if (formatOpts.hourCycle === \"h11\" || formatOpts.hourCycle === \"h12\") {\n        actualType = \"hour12\";\n      } else {\n        actualType = \"hour24\";\n      }\n    } else {\n      // tokens only differentiate between 24 hours or not,\n      // so we do not need to check hourCycle here, which is less supported anyways\n      actualType = resolvedOpts.hour12 ? \"hour12\" : \"hour24\";\n    }\n  }\n  let val = partTypeStyleToTokenVal[actualType];\n  if (typeof val === \"object\") {\n    val = val[style];\n  }\n\n  if (val) {\n    return {\n      literal: false,\n      val,\n    };\n  }\n\n  return undefined;\n}\n\nfunction buildRegex(units) {\n  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, \"\");\n  return [`^${re}$`, units];\n}\n\nfunction match(input, regex, handlers) {\n  const matches = input.match(regex);\n\n  if (matches) {\n    const all = {};\n    let matchIndex = 1;\n    for (const i in handlers) {\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(handlers, i)) {\n        const h = handlers[i],\n          groups = h.groups ? h.groups + 1 : 1;\n        if (!h.literal && h.token) {\n          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));\n        }\n        matchIndex += groups;\n      }\n    }\n    return [matches, all];\n  } else {\n    return [matches, {}];\n  }\n}\n\nfunction dateTimeFromMatches(matches) {\n  const toField = (token) => {\n    switch (token) {\n      case \"S\":\n        return \"millisecond\";\n      case \"s\":\n        return \"second\";\n      case \"m\":\n        return \"minute\";\n      case \"h\":\n      case \"H\":\n        return \"hour\";\n      case \"d\":\n        return \"day\";\n      case \"o\":\n        return \"ordinal\";\n      case \"L\":\n      case \"M\":\n        return \"month\";\n      case \"y\":\n        return \"year\";\n      case \"E\":\n      case \"c\":\n        return \"weekday\";\n      case \"W\":\n        return \"weekNumber\";\n      case \"k\":\n        return \"weekYear\";\n      case \"q\":\n        return \"quarter\";\n      default:\n        return null;\n    }\n  };\n\n  let zone = null;\n  let specificOffset;\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.z)) {\n    zone = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(matches.z);\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.Z)) {\n    if (!zone) {\n      zone = new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matches.Z);\n    }\n    specificOffset = matches.Z;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.q)) {\n    matches.M = (matches.q - 1) * 3 + 1;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.h)) {\n    if (matches.h < 12 && matches.a === 1) {\n      matches.h += 12;\n    } else if (matches.h === 12 && matches.a === 0) {\n      matches.h = 0;\n    }\n  }\n\n  if (matches.G === 0 && matches.y) {\n    matches.y = -matches.y;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.u)) {\n    matches.S = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(matches.u);\n  }\n\n  const vals = Object.keys(matches).reduce((r, k) => {\n    const f = toField(k);\n    if (f) {\n      r[f] = matches[k];\n    }\n\n    return r;\n  }, {});\n\n  return [vals, zone, specificOffset];\n}\n\nlet dummyDateTimeCache = null;\n\nfunction getDummyDateTime() {\n  if (!dummyDateTimeCache) {\n    dummyDateTimeCache = _datetime_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromMillis(1555555555555);\n  }\n\n  return dummyDateTimeCache;\n}\n\nfunction maybeExpandMacroToken(token, locale) {\n  if (token.literal) {\n    return token;\n  }\n\n  const formatOpts = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].macroTokenToFormatOpts(token.val);\n  const tokens = formatOptsToTokens(formatOpts, locale);\n\n  if (tokens == null || tokens.includes(undefined)) {\n    return token;\n  }\n\n  return tokens;\n}\n\nfunction expandMacroTokens(tokens, locale) {\n  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));\n}\n\n/**\n * @private\n */\n\nclass TokenParser {\n  constructor(locale, format) {\n    this.locale = locale;\n    this.format = format;\n    this.tokens = expandMacroTokens(_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parseFormat(format), locale);\n    this.units = this.tokens.map((t) => unitForToken(t, locale));\n    this.disqualifyingUnit = this.units.find((t) => t.invalidReason);\n\n    if (!this.disqualifyingUnit) {\n      const [regexString, handlers] = buildRegex(this.units);\n      this.regex = RegExp(regexString, \"i\");\n      this.handlers = handlers;\n    }\n  }\n\n  explainFromTokens(input) {\n    if (!this.isValid) {\n      return { input, tokens: this.tokens, invalidReason: this.invalidReason };\n    } else {\n      const [rawMatches, matches] = match(input, this.regex, this.handlers),\n        [result, zone, specificOffset] = matches\n          ? dateTimeFromMatches(matches)\n          : [null, null, undefined];\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"a\") && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"H\")) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\n          \"Can't include meridiem when specifying 24-hour format\"\n        );\n      }\n      return {\n        input,\n        tokens: this.tokens,\n        regex: this.regex,\n        rawMatches,\n        matches,\n        result,\n        zone,\n        specificOffset,\n      };\n    }\n  }\n\n  get isValid() {\n    return !this.disqualifyingUnit;\n  }\n\n  get invalidReason() {\n    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;\n  }\n}\n\nfunction explainFromTokens(locale, input, format) {\n  const parser = new TokenParser(locale, format);\n  return parser.explainFromTokens(input);\n}\n\nfunction parseFromTokens(locale, input, format) {\n  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);\n  return [result, zone, specificOffset, invalidReason];\n}\n\nfunction formatOptsToTokens(formatOpts, locale) {\n  if (!formatOpts) {\n    return null;\n  }\n\n  const formatter = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(locale, formatOpts);\n  const df = formatter.dtFormatter(getDummyDateTime());\n  const parts = df.formatToParts();\n  const resolvedOpts = df.resolvedOptions();\n  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdG9rZW5QYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1HO0FBQzVEO0FBQ21CO0FBQ2Q7QUFDTjtBQUNnQjtBQUNPOztBQUU3RDs7QUFFQTtBQUNBLFdBQVcsNEJBQTRCLHVEQUFXO0FBQ2xEOztBQUVBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw0QkFBNEIsc0RBQVk7QUFDbkQ7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsY0FBYyxzREFBVTtBQUN4QixVQUFVLHNEQUFVLFFBQVEsRUFBRTtBQUM5QixZQUFZLHNEQUFVLFFBQVEsRUFBRTtBQUNoQyxXQUFXLHNEQUFVLFFBQVEsRUFBRTtBQUMvQixVQUFVLHNEQUFVLFFBQVEsRUFBRTtBQUM5QixlQUFlLHNEQUFVLFFBQVEsSUFBSTtBQUNyQyxpQkFBaUIsc0RBQVUsUUFBUSxJQUFJO0FBQ3ZDLGVBQWUsc0RBQVUsUUFBUSxJQUFJO0FBQ3JDLGdCQUFnQixzREFBVSxRQUFRLElBQUk7QUFDdEMsZ0JBQWdCLHNEQUFVLFFBQVEsSUFBSTtBQUN0QyxnQkFBZ0Isc0RBQVUsUUFBUSxJQUFJO0FBQ3RDLHdCQUF3QixxRUFBcUU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvREFBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9EQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCLFFBQVEsV0FBVztBQUM5RTtBQUNBLDJDQUEyQyxnQkFBZ0IsSUFBSSxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELEVBQUUsR0FBRyxTQUFTO0FBQ3pFLGNBQWMsR0FBRztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8scURBQVc7QUFDbEIsV0FBVywwREFBUTtBQUNuQjs7QUFFQSxPQUFPLHFEQUFXO0FBQ2xCO0FBQ0EsaUJBQWlCLGlFQUFlO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLHFEQUFXO0FBQ2xCO0FBQ0E7O0FBRUEsT0FBTyxxREFBVztBQUNsQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxxREFBVztBQUNsQixnQkFBZ0IscURBQVc7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVE7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscURBQVM7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxREFBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQWMsa0JBQWtCLHdEQUFjO0FBQ3hELGtCQUFrQixxRUFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsOENBQThDO0FBQ3hEO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlTWlsbGlzLCBpc1VuZGVmaW5lZCwgdW50cnVuY2F0ZVllYXIsIHNpZ25lZE9mZnNldCwgaGFzT3duUHJvcGVydHkgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgeyBkaWdpdFJlZ2V4LCBwYXJzZURpZ2l0cyB9IGZyb20gXCIuL2RpZ2l0cy5qc1wiO1xuaW1wb3J0IHsgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5cbmNvbnN0IE1JU1NJTkdfRlRQID0gXCJtaXNzaW5nIEludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBzdXBwb3J0XCI7XG5cbmZ1bmN0aW9uIGludFVuaXQocmVnZXgsIHBvc3QgPSAoaSkgPT4gaSkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHBvc3QocGFyc2VEaWdpdHMocykpIH07XG59XG5cbmNvbnN0IE5CU1AgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCk7XG5jb25zdCBzcGFjZU9yTkJTUCA9IGBbICR7TkJTUH1dYDtcbmNvbnN0IHNwYWNlT3JOQlNQUmVnRXhwID0gbmV3IFJlZ0V4cChzcGFjZU9yTkJTUCwgXCJnXCIpO1xuXG5mdW5jdGlvbiBmaXhMaXN0UmVnZXgocykge1xuICAvLyBtYWtlIGRvdHMgb3B0aW9uYWwgYW5kIGFsc28gbWFrZSB0aGVtIGxpdGVyYWxcbiAgLy8gbWFrZSBzcGFjZSBhbmQgbm9uIGJyZWFrYWJsZSBzcGFjZSBjaGFyYWN0ZXJzIGludGVyY2hhbmdlYWJsZVxuICByZXR1cm4gcy5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLj9cIikucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgc3BhY2VPck5CU1ApO1xufVxuXG5mdW5jdGlvbiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSB7XG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcLi9nLCBcIlwiKSAvLyBpZ25vcmUgZG90cyB0aGF0IHdlcmUgbWFkZSBvcHRpb25hbFxuICAgIC5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBcIiBcIikgLy8gaW50ZXJjaGFuZ2Ugc3BhY2UgYW5kIG5ic3BcbiAgICAudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gb25lT2Yoc3RyaW5ncywgc3RhcnRJbmRleCkge1xuICBpZiAoc3RyaW5ncyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZWdleDogUmVnRXhwKHN0cmluZ3MubWFwKGZpeExpc3RSZWdleCkuam9pbihcInxcIikpLFxuICAgICAgZGVzZXI6IChbc10pID0+XG4gICAgICAgIHN0cmluZ3MuZmluZEluZGV4KChpKSA9PiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSA9PT0gc3RyaXBJbnNlbnNpdGl2aXRpZXMoaSkpICsgc3RhcnRJbmRleCxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG9mZnNldChyZWdleCwgZ3JvdXBzKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFssIGgsIG1dKSA9PiBzaWduZWRPZmZzZXQoaCwgbSksIGdyb3VwcyB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGUocmVnZXgpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBzIH07XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVRva2VuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHRva2VuXG4gKiBAcGFyYW0ge0xvY2FsZX0gbG9jXG4gKi9cbmZ1bmN0aW9uIHVuaXRGb3JUb2tlbih0b2tlbiwgbG9jKSB7XG4gIGNvbnN0IG9uZSA9IGRpZ2l0UmVnZXgobG9jKSxcbiAgICB0d28gPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Mn1cIiksXG4gICAgdGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7M31cIiksXG4gICAgZm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcIns0fVwiKSxcbiAgICBzaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Nn1cIiksXG4gICAgb25lT3JUd28gPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwyfVwiKSxcbiAgICBvbmVUb1RocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezEsM31cIiksXG4gICAgb25lVG9TaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSw2fVwiKSxcbiAgICBvbmVUb05pbmUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSw5fVwiKSxcbiAgICB0d29Ub0ZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Miw0fVwiKSxcbiAgICBmb3VyVG9TaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NCw2fVwiKSxcbiAgICBsaXRlcmFsID0gKHQpID0+ICh7IHJlZ2V4OiBSZWdFeHAoZXNjYXBlVG9rZW4odC52YWwpKSwgZGVzZXI6IChbc10pID0+IHMsIGxpdGVyYWw6IHRydWUgfSksXG4gICAgdW5pdGF0ZSA9ICh0KSA9PiB7XG4gICAgICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodC52YWwpIHtcbiAgICAgICAgLy8gZXJhXG4gICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwic2hvcnRcIiksIDApO1xuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJsb25nXCIpLCAwKTtcbiAgICAgICAgLy8geWVhcnNcbiAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1NpeCk7XG4gICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwieXl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoc2l4KTtcbiAgICAgICAgLy8gbW9udGhzXG4gICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIC8vIGRhdGVzXG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyBvcmRpbmFsc1xuICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICAvLyB0aW1lXG4gICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZVRvTmluZSk7XG4gICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgLy8gbWVyaWRpZW1cbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1lcmlkaWVtcygpLCAwKTtcbiAgICAgICAgLy8gd2Vla1llYXIgKGspXG4gICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91cik7XG4gICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgICAvLyB3ZWVrTnVtYmVyIChXKVxuICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIldXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gd2Vla2RheXNcbiAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgdHJ1ZSksIDEpO1xuICAgICAgICAvLyBvZmZzZXQvem9uZVxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSg/OjooJHt0d28uc291cmNlfSkpP2ApLCAyKTtcbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKCR7dHdvLnNvdXJjZX0pP2ApLCAyKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHRoZXkgYXJlXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW2Etel8rLS9dezEsMjU2fT8vaSk7XG4gICAgICAgIC8vIHRoaXMgc3BlY2lhbC1jYXNlIFwidG9rZW5cIiByZXByZXNlbnRzIGEgcGxhY2Ugd2hlcmUgYSBtYWNyby10b2tlbiBleHBhbmRlZCBpbnRvIGEgd2hpdGUtc3BhY2UgbGl0ZXJhbFxuICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgYWNjZXB0IGFueSBub24tbmV3bGluZSB3aGl0ZS1zcGFjZVxuICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1teXFxTXFxuXFxyXS8pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgY29uc3QgdW5pdCA9IHVuaXRhdGUodG9rZW4pIHx8IHtcbiAgICBpbnZhbGlkUmVhc29uOiBNSVNTSU5HX0ZUUCxcbiAgfTtcblxuICB1bml0LnRva2VuID0gdG9rZW47XG5cbiAgcmV0dXJuIHVuaXQ7XG59XG5cbmNvbnN0IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsID0ge1xuICB5ZWFyOiB7XG4gICAgXCIyLWRpZ2l0XCI6IFwieXlcIixcbiAgICBudW1lcmljOiBcInl5eXl5XCIsXG4gIH0sXG4gIG1vbnRoOiB7XG4gICAgbnVtZXJpYzogXCJNXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiTU1cIixcbiAgICBzaG9ydDogXCJNTU1cIixcbiAgICBsb25nOiBcIk1NTU1cIixcbiAgfSxcbiAgZGF5OiB7XG4gICAgbnVtZXJpYzogXCJkXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiZGRcIixcbiAgfSxcbiAgd2Vla2RheToge1xuICAgIHNob3J0OiBcIkVFRVwiLFxuICAgIGxvbmc6IFwiRUVFRVwiLFxuICB9LFxuICBkYXlwZXJpb2Q6IFwiYVwiLFxuICBkYXlQZXJpb2Q6IFwiYVwiLFxuICBob3VyMTI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiLFxuICB9LFxuICBob3VyMjQ6IHtcbiAgICBudW1lcmljOiBcIkhcIixcbiAgICBcIjItZGlnaXRcIjogXCJISFwiLFxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiLFxuICB9LFxuICBzZWNvbmQ6IHtcbiAgICBudW1lcmljOiBcInNcIixcbiAgICBcIjItZGlnaXRcIjogXCJzc1wiLFxuICB9LFxuICB0aW1lWm9uZU5hbWU6IHtcbiAgICBsb25nOiBcIlpaWlpaXCIsXG4gICAgc2hvcnQ6IFwiWlpaXCIsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0b2tlbkZvclBhcnQocGFydCwgZm9ybWF0T3B0cywgcmVzb2x2ZWRPcHRzKSB7XG4gIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IHBhcnQ7XG5cbiAgaWYgKHR5cGUgPT09IFwibGl0ZXJhbFwiKSB7XG4gICAgY29uc3QgaXNTcGFjZSA9IC9eXFxzKyQvLnRlc3QodmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiAhaXNTcGFjZSxcbiAgICAgIHZhbDogaXNTcGFjZSA/IFwiIFwiIDogdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gZm9ybWF0T3B0c1t0eXBlXTtcblxuICAvLyBUaGUgdXNlciBtaWdodCBoYXZlIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGhvdXIxMiBvciBob3VyQ3ljbGVcbiAgLy8gaWYgc28sIHJlc3BlY3QgdGhlaXIgZGVjaXNpb25cbiAgLy8gaWYgbm90LCByZWZlciBiYWNrIHRvIHRoZSByZXNvbHZlZE9wdHMsIHdoaWNoIGFyZSBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gIGxldCBhY3R1YWxUeXBlID0gdHlwZTtcbiAgaWYgKHR5cGUgPT09IFwiaG91clwiKSB7XG4gICAgaWYgKGZvcm1hdE9wdHMuaG91cjEyICE9IG51bGwpIHtcbiAgICAgIGFjdHVhbFR5cGUgPSBmb3JtYXRPcHRzLmhvdXIxMiA/IFwiaG91cjEyXCIgOiBcImhvdXIyNFwiO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0T3B0cy5ob3VyQ3ljbGUgIT0gbnVsbCkge1xuICAgICAgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlID09PSBcImgxMVwiIHx8IGZvcm1hdE9wdHMuaG91ckN5Y2xlID09PSBcImgxMlwiKSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIxMlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsVHlwZSA9IFwiaG91cjI0XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRva2VucyBvbmx5IGRpZmZlcmVudGlhdGUgYmV0d2VlbiAyNCBob3VycyBvciBub3QsXG4gICAgICAvLyBzbyB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBob3VyQ3ljbGUgaGVyZSwgd2hpY2ggaXMgbGVzcyBzdXBwb3J0ZWQgYW55d2F5c1xuICAgICAgYWN0dWFsVHlwZSA9IHJlc29sdmVkT3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9XG4gIH1cbiAgbGV0IHZhbCA9IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsW2FjdHVhbFR5cGVdO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikge1xuICAgIHZhbCA9IHZhbFtzdHlsZV07XG4gIH1cblxuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgdmFsLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBidWlsZFJlZ2V4KHVuaXRzKSB7XG4gIGNvbnN0IHJlID0gdW5pdHMubWFwKCh1KSA9PiB1LnJlZ2V4KS5yZWR1Y2UoKGYsIHIpID0+IGAke2Z9KCR7ci5zb3VyY2V9KWAsIFwiXCIpO1xuICByZXR1cm4gW2BeJHtyZX0kYCwgdW5pdHNdO1xufVxuXG5mdW5jdGlvbiBtYXRjaChpbnB1dCwgcmVnZXgsIGhhbmRsZXJzKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBpbnB1dC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBjb25zdCBhbGwgPSB7fTtcbiAgICBsZXQgbWF0Y2hJbmRleCA9IDE7XG4gICAgZm9yIChjb25zdCBpIGluIGhhbmRsZXJzKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoaGFuZGxlcnMsIGkpKSB7XG4gICAgICAgIGNvbnN0IGggPSBoYW5kbGVyc1tpXSxcbiAgICAgICAgICBncm91cHMgPSBoLmdyb3VwcyA/IGguZ3JvdXBzICsgMSA6IDE7XG4gICAgICAgIGlmICghaC5saXRlcmFsICYmIGgudG9rZW4pIHtcbiAgICAgICAgICBhbGxbaC50b2tlbi52YWxbMF1dID0gaC5kZXNlcihtYXRjaGVzLnNsaWNlKG1hdGNoSW5kZXgsIG1hdGNoSW5kZXggKyBncm91cHMpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaEluZGV4ICs9IGdyb3VwcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFttYXRjaGVzLCBhbGxdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbWF0Y2hlcywge31dO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcykge1xuICBjb25zdCB0b0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XG4gICAgICBjYXNlIFwiaFwiOlxuICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgcmV0dXJuIFwiZGF5XCI7XG4gICAgICBjYXNlIFwib1wiOlxuICAgICAgICByZXR1cm4gXCJvcmRpbmFsXCI7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcbiAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgIGNhc2UgXCJFXCI6XG4gICAgICBjYXNlIFwiY1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrZGF5XCI7XG4gICAgICBjYXNlIFwiV1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrTnVtYmVyXCI7XG4gICAgICBjYXNlIFwia1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrWWVhclwiO1xuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIFwicXVhcnRlclwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGxldCB6b25lID0gbnVsbDtcbiAgbGV0IHNwZWNpZmljT2Zmc2V0O1xuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMueikpIHtcbiAgICB6b25lID0gSUFOQVpvbmUuY3JlYXRlKG1hdGNoZXMueik7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuWikpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHpvbmUgPSBuZXcgRml4ZWRPZmZzZXRab25lKG1hdGNoZXMuWik7XG4gICAgfVxuICAgIHNwZWNpZmljT2Zmc2V0ID0gbWF0Y2hlcy5aO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnEpKSB7XG4gICAgbWF0Y2hlcy5NID0gKG1hdGNoZXMucSAtIDEpICogMyArIDE7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuaCkpIHtcbiAgICBpZiAobWF0Y2hlcy5oIDwgMTIgJiYgbWF0Y2hlcy5hID09PSAxKSB7XG4gICAgICBtYXRjaGVzLmggKz0gMTI7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzLmggPT09IDEyICYmIG1hdGNoZXMuYSA9PT0gMCkge1xuICAgICAgbWF0Y2hlcy5oID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF0Y2hlcy5HID09PSAwICYmIG1hdGNoZXMueSkge1xuICAgIG1hdGNoZXMueSA9IC1tYXRjaGVzLnk7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMudSkpIHtcbiAgICBtYXRjaGVzLlMgPSBwYXJzZU1pbGxpcyhtYXRjaGVzLnUpO1xuICB9XG5cbiAgY29uc3QgdmFscyA9IE9iamVjdC5rZXlzKG1hdGNoZXMpLnJlZHVjZSgociwgaykgPT4ge1xuICAgIGNvbnN0IGYgPSB0b0ZpZWxkKGspO1xuICAgIGlmIChmKSB7XG4gICAgICByW2ZdID0gbWF0Y2hlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfSwge30pO1xuXG4gIHJldHVybiBbdmFscywgem9uZSwgc3BlY2lmaWNPZmZzZXRdO1xufVxuXG5sZXQgZHVtbXlEYXRlVGltZUNhY2hlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0RHVtbXlEYXRlVGltZSgpIHtcbiAgaWYgKCFkdW1teURhdGVUaW1lQ2FjaGUpIHtcbiAgICBkdW1teURhdGVUaW1lQ2FjaGUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKDE1NTU1NTU1NTU1NTUpO1xuICB9XG5cbiAgcmV0dXJuIGR1bW15RGF0ZVRpbWVDYWNoZTtcbn1cblxuZnVuY3Rpb24gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHRva2VuLCBsb2NhbGUpIHtcbiAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4udmFsKTtcbiAgY29uc3QgdG9rZW5zID0gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIGxvY2FsZSk7XG5cbiAgaWYgKHRva2VucyA9PSBudWxsIHx8IHRva2Vucy5pbmNsdWRlcyh1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZE1hY3JvVG9rZW5zKHRva2VucywgbG9jYWxlKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0KC4uLnRva2Vucy5tYXAoKHQpID0+IG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0LCBsb2NhbGUpKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY2xhc3MgVG9rZW5QYXJzZXIge1xuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdCkge1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMudG9rZW5zID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZvcm1hdCksIGxvY2FsZSk7XG4gICAgdGhpcy51bml0cyA9IHRoaXMudG9rZW5zLm1hcCgodCkgPT4gdW5pdEZvclRva2VuKHQsIGxvY2FsZSkpO1xuICAgIHRoaXMuZGlzcXVhbGlmeWluZ1VuaXQgPSB0aGlzLnVuaXRzLmZpbmQoKHQpID0+IHQuaW52YWxpZFJlYXNvbik7XG5cbiAgICBpZiAoIXRoaXMuZGlzcXVhbGlmeWluZ1VuaXQpIHtcbiAgICAgIGNvbnN0IFtyZWdleFN0cmluZywgaGFuZGxlcnNdID0gYnVpbGRSZWdleCh0aGlzLnVuaXRzKTtcbiAgICAgIHRoaXMucmVnZXggPSBSZWdFeHAocmVnZXhTdHJpbmcsIFwiaVwiKTtcbiAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB9XG4gIH1cblxuICBleHBsYWluRnJvbVRva2VucyhpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4geyBpbnB1dCwgdG9rZW5zOiB0aGlzLnRva2VucywgaW52YWxpZFJlYXNvbjogdGhpcy5pbnZhbGlkUmVhc29uIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtyYXdNYXRjaGVzLCBtYXRjaGVzXSA9IG1hdGNoKGlucHV0LCB0aGlzLnJlZ2V4LCB0aGlzLmhhbmRsZXJzKSxcbiAgICAgICAgW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXRdID0gbWF0Y2hlc1xuICAgICAgICAgID8gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKVxuICAgICAgICAgIDogW251bGwsIG51bGwsIHVuZGVmaW5lZF07XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJhXCIpICYmIGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiSFwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgXCJDYW4ndCBpbmNsdWRlIG1lcmlkaWVtIHdoZW4gc3BlY2lmeWluZyAyNC1ob3VyIGZvcm1hdFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dCxcbiAgICAgICAgdG9rZW5zOiB0aGlzLnRva2VucyxcbiAgICAgICAgcmVnZXg6IHRoaXMucmVnZXgsXG4gICAgICAgIHJhd01hdGNoZXMsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgem9uZSxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXQsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhdGhpcy5kaXNxdWFsaWZ5aW5nVW5pdDtcbiAgfVxuXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3F1YWxpZnlpbmdVbml0ID8gdGhpcy5kaXNxdWFsaWZ5aW5nVW5pdC5pbnZhbGlkUmVhc29uIDogbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBUb2tlblBhcnNlcihsb2NhbGUsIGZvcm1hdCk7XG4gIHJldHVybiBwYXJzZXIuZXhwbGFpbkZyb21Ub2tlbnMoaW5wdXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCk7XG4gIHJldHVybiBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKSB7XG4gIGlmICghZm9ybWF0T3B0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBkZiA9IGZvcm1hdHRlci5kdEZvcm1hdHRlcihnZXREdW1teURhdGVUaW1lKCkpO1xuICBjb25zdCBwYXJ0cyA9IGRmLmZvcm1hdFRvUGFydHMoKTtcbiAgY29uc3QgcmVzb2x2ZWRPcHRzID0gZGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHApID0+IHRva2VuRm9yUGFydChwLCBmb3JtYXRPcHRzLCByZXNvbHZlZE9wdHMpKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/tokenParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js":
/*!**********************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asNumber: () => (/* binding */ asNumber),\n/* harmony export */   bestBy: () => (/* binding */ bestBy),\n/* harmony export */   daysInMonth: () => (/* binding */ daysInMonth),\n/* harmony export */   daysInYear: () => (/* binding */ daysInYear),\n/* harmony export */   floorMod: () => (/* binding */ floorMod),\n/* harmony export */   formatOffset: () => (/* binding */ formatOffset),\n/* harmony export */   hasLocaleWeekInfo: () => (/* binding */ hasLocaleWeekInfo),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasRelative: () => (/* binding */ hasRelative),\n/* harmony export */   integerBetween: () => (/* binding */ integerBetween),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isLeapYear: () => (/* binding */ isLeapYear),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   maybeArray: () => (/* binding */ maybeArray),\n/* harmony export */   normalizeObject: () => (/* binding */ normalizeObject),\n/* harmony export */   objToLocalTS: () => (/* binding */ objToLocalTS),\n/* harmony export */   padStart: () => (/* binding */ padStart),\n/* harmony export */   parseFloating: () => (/* binding */ parseFloating),\n/* harmony export */   parseInteger: () => (/* binding */ parseInteger),\n/* harmony export */   parseMillis: () => (/* binding */ parseMillis),\n/* harmony export */   parseZoneInfo: () => (/* binding */ parseZoneInfo),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   roundTo: () => (/* binding */ roundTo),\n/* harmony export */   signedOffset: () => (/* binding */ signedOffset),\n/* harmony export */   timeObject: () => (/* binding */ timeObject),\n/* harmony export */   untruncateYear: () => (/* binding */ untruncateYear),\n/* harmony export */   validateWeekSettings: () => (/* binding */ validateWeekSettings),\n/* harmony export */   weeksInWeekYear: () => (/* binding */ weeksInWeekYear)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _conversions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conversions.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/conversions.js\");\n/*\n  This is just a junk drawer, containing anything used across multiple classes.\n  Because Luxon is small(ish), this should stay small and we won't worry about splitting\n  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.\n*/\n\n\n\n\n\n/**\n * @private\n */\n\n// TYPES\n\nfunction isUndefined(o) {\n  return typeof o === \"undefined\";\n}\n\nfunction isNumber(o) {\n  return typeof o === \"number\";\n}\n\nfunction isInteger(o) {\n  return typeof o === \"number\" && o % 1 === 0;\n}\n\nfunction isString(o) {\n  return typeof o === \"string\";\n}\n\nfunction isDate(o) {\n  return Object.prototype.toString.call(o) === \"[object Date]\";\n}\n\n// CAPABILITIES\n\nfunction hasRelative() {\n  try {\n    return typeof Intl !== \"undefined\" && !!Intl.RelativeTimeFormat;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction hasLocaleWeekInfo() {\n  try {\n    return (\n      typeof Intl !== \"undefined\" &&\n      !!Intl.Locale &&\n      (\"weekInfo\" in Intl.Locale.prototype || \"getWeekInfo\" in Intl.Locale.prototype)\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\n// OBJECTS AND ARRAYS\n\nfunction maybeArray(thing) {\n  return Array.isArray(thing) ? thing : [thing];\n}\n\nfunction bestBy(arr, by, compare) {\n  if (arr.length === 0) {\n    return undefined;\n  }\n  return arr.reduce((best, next) => {\n    const pair = [by(next), next];\n    if (!best) {\n      return pair;\n    } else if (compare(best[0], pair[0]) === best[0]) {\n      return best;\n    } else {\n      return pair;\n    }\n  }, null)[1];\n}\n\nfunction pick(obj, keys) {\n  return keys.reduce((a, k) => {\n    a[k] = obj[k];\n    return a;\n  }, {});\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction validateWeekSettings(settings) {\n  if (settings == null) {\n    return null;\n  } else if (typeof settings !== \"object\") {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Week settings must be an object\");\n  } else {\n    if (\n      !integerBetween(settings.firstDay, 1, 7) ||\n      !integerBetween(settings.minimalDays, 1, 7) ||\n      !Array.isArray(settings.weekend) ||\n      settings.weekend.some((v) => !integerBetween(v, 1, 7))\n    ) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Invalid week settings\");\n    }\n    return {\n      firstDay: settings.firstDay,\n      minimalDays: settings.minimalDays,\n      weekend: Array.from(settings.weekend),\n    };\n  }\n}\n\n// NUMBERS AND STRINGS\n\nfunction integerBetween(thing, bottom, top) {\n  return isInteger(thing) && thing >= bottom && thing <= top;\n}\n\n// x % n but takes the sign of n instead of x\nfunction floorMod(x, n) {\n  return x - n * Math.floor(x / n);\n}\n\nfunction padStart(input, n = 2) {\n  const isNeg = input < 0;\n  let padded;\n  if (isNeg) {\n    padded = \"-\" + (\"\" + -input).padStart(n, \"0\");\n  } else {\n    padded = (\"\" + input).padStart(n, \"0\");\n  }\n  return padded;\n}\n\nfunction parseInteger(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseInt(string, 10);\n  }\n}\n\nfunction parseFloating(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseFloat(string);\n  }\n}\n\nfunction parseMillis(fraction) {\n  // Return undefined (instead of 0) in these cases, where fraction is not set\n  if (isUndefined(fraction) || fraction === null || fraction === \"\") {\n    return undefined;\n  } else {\n    const f = parseFloat(\"0.\" + fraction) * 1000;\n    return Math.floor(f);\n  }\n}\n\nfunction roundTo(number, digits, rounding = \"round\") {\n  const factor = 10 ** digits;\n  switch (rounding) {\n    case \"expand\":\n      return number > 0\n        ? Math.ceil(number * factor) / factor\n        : Math.floor(number * factor) / factor;\n    case \"trunc\":\n      return Math.trunc(number * factor) / factor;\n    case \"round\":\n      return Math.round(number * factor) / factor;\n    case \"floor\":\n      return Math.floor(number * factor) / factor;\n    case \"ceil\":\n      return Math.ceil(number * factor) / factor;\n    default:\n      throw new RangeError(`Value rounding ${rounding} is out of range`);\n  }\n}\n\n// DATE BASICS\n\nfunction isLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\nfunction daysInYear(year) {\n  return isLeapYear(year) ? 366 : 365;\n}\n\nfunction daysInMonth(year, month) {\n  const modMonth = floorMod(month - 1, 12) + 1,\n    modYear = year + (month - modMonth) / 12;\n\n  if (modMonth === 2) {\n    return isLeapYear(modYear) ? 29 : 28;\n  } else {\n    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];\n  }\n}\n\n// convert a calendar object to a local timestamp (epoch, but with the offset baked in)\nfunction objToLocalTS(obj) {\n  let d = Date.UTC(\n    obj.year,\n    obj.month - 1,\n    obj.day,\n    obj.hour,\n    obj.minute,\n    obj.second,\n    obj.millisecond\n  );\n\n  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that\n  if (obj.year < 100 && obj.year >= 0) {\n    d = new Date(d);\n    // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not\n    // so if obj.year is in 99, but obj.day makes it roll over into year 100,\n    // the calculations done by Date.UTC are using year 2000 - which is incorrect\n    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);\n  }\n  return +d;\n}\n\n// adapted from moment.js: https://github.com/moment/moment/blob/000ac1800e620f770f4eb31b5ae908f6167b0ab2/src/lib/units/week-calendar-utils.js\nfunction firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {\n  const fwdlw = (0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.isoWeekdayToLocal)((0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.dayOfWeek)(year, 1, minDaysInFirstWeek), startOfWeek);\n  return -fwdlw + minDaysInFirstWeek - 1;\n}\n\nfunction weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);\n  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);\n  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;\n}\n\nfunction untruncateYear(year) {\n  if (year > 99) {\n    return year;\n  } else return year > _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].twoDigitCutoffYear ? 1900 + year : 2000 + year;\n}\n\n// PARSING\n\nfunction parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {\n  const date = new Date(ts),\n    intlOpts = {\n      hourCycle: \"h23\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    };\n\n  if (timeZone) {\n    intlOpts.timeZone = timeZone;\n  }\n\n  const modified = { timeZoneName: offsetFormat, ...intlOpts };\n\n  const parsed = new Intl.DateTimeFormat(locale, modified)\n    .formatToParts(date)\n    .find((m) => m.type.toLowerCase() === \"timezonename\");\n  return parsed ? parsed.value : null;\n}\n\n// signedOffset('-5', '30') -> -330\nfunction signedOffset(offHourStr, offMinuteStr) {\n  let offHour = parseInt(offHourStr, 10);\n\n  // don't || this because we want to preserve -0\n  if (Number.isNaN(offHour)) {\n    offHour = 0;\n  }\n\n  const offMin = parseInt(offMinuteStr, 10) || 0,\n    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;\n  return offHour * 60 + offMinSigned;\n}\n\n// COERCION\n\nfunction asNumber(value) {\n  const numericValue = Number(value);\n  if (typeof value === \"boolean\" || value === \"\" || !Number.isFinite(numericValue))\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(`Invalid unit value ${value}`);\n  return numericValue;\n}\n\nfunction normalizeObject(obj, normalizer) {\n  const normalized = {};\n  for (const u in obj) {\n    if (hasOwnProperty(obj, u)) {\n      const v = obj[u];\n      if (v === undefined || v === null) continue;\n      normalized[normalizer(u)] = asNumber(v);\n    }\n  }\n  return normalized;\n}\n\n/**\n * Returns the offset's value as a string\n * @param {number} ts - Epoch milliseconds for which to get the offset\n * @param {string} format - What style of offset to return.\n *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n * @return {string}\n */\nfunction formatOffset(offset, format) {\n  const hours = Math.trunc(Math.abs(offset / 60)),\n    minutes = Math.trunc(Math.abs(offset % 60)),\n    sign = offset >= 0 ? \"+\" : \"-\";\n\n  switch (format) {\n    case \"short\":\n      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;\n    case \"narrow\":\n      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : \"\"}`;\n    case \"techie\":\n      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;\n    default:\n      throw new RangeError(`Value format ${format} is out of range for property format`);\n  }\n}\n\nfunction timeObject(obj) {\n  return pick(obj, [\"hour\", \"minute\", \"second\", \"millisecond\"]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDZDtBQUMwQjs7QUFFaEU7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyw0REFBb0I7QUFDbEMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFpQixDQUFDLDBEQUFTO0FBQzNDO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQixvREFBUTtBQUMvQjs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxjQUFjLDREQUFvQix1QkFBdUIsTUFBTTtBQUMvRDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxtQkFBbUIsR0FBRyxxQkFBcUI7QUFDbEU7QUFDQSxnQkFBZ0IsS0FBSyxFQUFFLE1BQU0sRUFBRSxrQkFBa0IsUUFBUSxPQUFPO0FBQ2hFO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxtQkFBbUIsRUFBRSxxQkFBcUI7QUFDakU7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBUaGlzIGlzIGp1c3QgYSBqdW5rIGRyYXdlciwgY29udGFpbmluZyBhbnl0aGluZyB1c2VkIGFjcm9zcyBtdWx0aXBsZSBjbGFzc2VzLlxuICBCZWNhdXNlIEx1eG9uIGlzIHNtYWxsKGlzaCksIHRoaXMgc2hvdWxkIHN0YXkgc21hbGwgYW5kIHdlIHdvbid0IHdvcnJ5IGFib3V0IHNwbGl0dGluZ1xuICBpdCB1cCBpbnRvLCBzYXksIHBhcnNpbmdVdGlsLmpzIGFuZCBiYXNpY1V0aWwuanMgYW5kIHNvIG9uLiBCdXQgdGhleSBhcmUgZGl2aWRlZCB1cCBieSBmZWF0dXJlIGFyZWEuXG4qL1xuXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IGRheU9mV2VlaywgaXNvV2Vla2RheVRvTG9jYWwgfSBmcm9tIFwiLi9jb252ZXJzaW9ucy5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gVFlQRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXG4vLyBDQVBBQklMSVRJRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNMb2NhbGVXZWVrSW5mbygpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICEhSW50bC5Mb2NhbGUgJiZcbiAgICAgIChcIndlZWtJbmZvXCIgaW4gSW50bC5Mb2NhbGUucHJvdG90eXBlIHx8IFwiZ2V0V2Vla0luZm9cIiBpbiBJbnRsLkxvY2FsZS5wcm90b3R5cGUpXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBPQkpFQ1RTIEFORCBBUlJBWVNcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpbmcpID8gdGhpbmcgOiBbdGhpbmddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVzdEJ5KGFyciwgYnksIGNvbXBhcmUpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhcnIucmVkdWNlKChiZXN0LCBuZXh0KSA9PiB7XG4gICAgY29uc3QgcGFpciA9IFtieShuZXh0KSwgbmV4dF07XG4gICAgaWYgKCFiZXN0KSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmUoYmVzdFswXSwgcGFpclswXSkgPT09IGJlc3RbMF0pIHtcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9XG4gIH0sIG51bGwpWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChhLCBrKSA9PiB7XG4gICAgYVtrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlV2Vla1NldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiV2VlayBzZXR0aW5ncyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXG4gICAgICAhaW50ZWdlckJldHdlZW4oc2V0dGluZ3MuZmlyc3REYXksIDEsIDcpIHx8XG4gICAgICAhaW50ZWdlckJldHdlZW4oc2V0dGluZ3MubWluaW1hbERheXMsIDEsIDcpIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheShzZXR0aW5ncy53ZWVrZW5kKSB8fFxuICAgICAgc2V0dGluZ3Mud2Vla2VuZC5zb21lKCh2KSA9PiAhaW50ZWdlckJldHdlZW4odiwgMSwgNykpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJJbnZhbGlkIHdlZWsgc2V0dGluZ3NcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaXJzdERheTogc2V0dGluZ3MuZmlyc3REYXksXG4gICAgICBtaW5pbWFsRGF5czogc2V0dGluZ3MubWluaW1hbERheXMsXG4gICAgICB3ZWVrZW5kOiBBcnJheS5mcm9tKHNldHRpbmdzLndlZWtlbmQpLFxuICAgIH07XG4gIH1cbn1cblxuLy8gTlVNQkVSUyBBTkQgU1RSSU5HU1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlckJldHdlZW4odGhpbmcsIGJvdHRvbSwgdG9wKSB7XG4gIHJldHVybiBpc0ludGVnZXIodGhpbmcpICYmIHRoaW5nID49IGJvdHRvbSAmJiB0aGluZyA8PSB0b3A7XG59XG5cbi8vIHggJSBuIGJ1dCB0YWtlcyB0aGUgc2lnbiBvZiBuIGluc3RlYWQgb2YgeFxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yTW9kKHgsIG4pIHtcbiAgcmV0dXJuIHggLSBuICogTWF0aC5mbG9vcih4IC8gbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWRTdGFydChpbnB1dCwgbiA9IDIpIHtcbiAgY29uc3QgaXNOZWcgPSBpbnB1dCA8IDA7XG4gIGxldCBwYWRkZWQ7XG4gIGlmIChpc05lZykge1xuICAgIHBhZGRlZCA9IFwiLVwiICsgKFwiXCIgKyAtaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkZWQgPSAoXCJcIiArIGlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH1cbiAgcmV0dXJuIHBhZGRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZWdlcihzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsb2F0aW5nKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHJpbmcpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1pbGxpcyhmcmFjdGlvbikge1xuICAvLyBSZXR1cm4gdW5kZWZpbmVkIChpbnN0ZWFkIG9mIDApIGluIHRoZXNlIGNhc2VzLCB3aGVyZSBmcmFjdGlvbiBpcyBub3Qgc2V0XG4gIGlmIChpc1VuZGVmaW5lZChmcmFjdGlvbikgfHwgZnJhY3Rpb24gPT09IG51bGwgfHwgZnJhY3Rpb24gPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGYgPSBwYXJzZUZsb2F0KFwiMC5cIiArIGZyYWN0aW9uKSAqIDEwMDA7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG8obnVtYmVyLCBkaWdpdHMsIHJvdW5kaW5nID0gXCJyb3VuZFwiKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cztcbiAgc3dpdGNoIChyb3VuZGluZykge1xuICAgIGNhc2UgXCJleHBhbmRcIjpcbiAgICAgIHJldHVybiBudW1iZXIgPiAwXG4gICAgICAgID8gTWF0aC5jZWlsKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3JcbiAgICAgICAgOiBNYXRoLmZsb29yKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgY2FzZSBcInRydW5jXCI6XG4gICAgICByZXR1cm4gTWF0aC50cnVuYyhudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBjYXNlIFwiZmxvb3JcIjpcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgY2FzZSBcImNlaWxcIjpcbiAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIHJvdW5kaW5nICR7cm91bmRpbmd9IGlzIG91dCBvZiByYW5nZWApO1xuICB9XG59XG5cbi8vIERBVEUgQkFTSUNTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgY29uc3QgbW9kTW9udGggPSBmbG9vck1vZChtb250aCAtIDEsIDEyKSArIDEsXG4gICAgbW9kWWVhciA9IHllYXIgKyAobW9udGggLSBtb2RNb250aCkgLyAxMjtcblxuICBpZiAobW9kTW9udGggPT09IDIpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcihtb2RZZWFyKSA/IDI5IDogMjg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFszMSwgbnVsbCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdW21vZE1vbnRoIC0gMV07XG4gIH1cbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5leHBvcnQgZnVuY3Rpb24gb2JqVG9Mb2NhbFRTKG9iaikge1xuICBsZXQgZCA9IERhdGUuVVRDKFxuICAgIG9iai55ZWFyLFxuICAgIG9iai5tb250aCAtIDEsXG4gICAgb2JqLmRheSxcbiAgICBvYmouaG91cixcbiAgICBvYmoubWludXRlLFxuICAgIG9iai5zZWNvbmQsXG4gICAgb2JqLm1pbGxpc2Vjb25kXG4gICk7XG5cbiAgLy8gZm9yIGxlZ2FjeSByZWFzb25zLCB5ZWFycyBiZXR3ZWVuIDAgYW5kIDk5IGFyZSBpbnRlcnByZXRlZCBhcyAxOVhYOyByZXZlcnQgdGhhdFxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICAvLyBzZXQgdGhlIG1vbnRoIGFuZCBkYXkgYWdhaW4sIHRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgeWVhciAyMDAwIGlzIGEgbGVhcCB5ZWFyLCBidXQgeWVhciAxMDAgaXMgbm90XG4gICAgLy8gc28gaWYgb2JqLnllYXIgaXMgaW4gOTksIGJ1dCBvYmouZGF5IG1ha2VzIGl0IHJvbGwgb3ZlciBpbnRvIHllYXIgMTAwLFxuICAgIC8vIHRoZSBjYWxjdWxhdGlvbnMgZG9uZSBieSBEYXRlLlVUQyBhcmUgdXNpbmcgeWVhciAyMDAwIC0gd2hpY2ggaXMgaW5jb3JyZWN0XG4gICAgZC5zZXRVVENGdWxsWWVhcihvYmoueWVhciwgb2JqLm1vbnRoIC0gMSwgb2JqLmRheSk7XG4gIH1cbiAgcmV0dXJuICtkO1xufVxuXG4vLyBhZGFwdGVkIGZyb20gbW9tZW50LmpzOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9ibG9iLzAwMGFjMTgwMGU2MjBmNzcwZjRlYjMxYjVhZTkwOGY2MTY3YjBhYjIvc3JjL2xpYi91bml0cy93ZWVrLWNhbGVuZGFyLXV0aWxzLmpzXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2Vlaykge1xuICBjb25zdCBmd2RsdyA9IGlzb1dlZWtkYXlUb0xvY2FsKGRheU9mV2Vlayh5ZWFyLCAxLCBtaW5EYXlzSW5GaXJzdFdlZWspLCBzdGFydE9mV2Vlayk7XG4gIHJldHVybiAtZndkbHcgKyBtaW5EYXlzSW5GaXJzdFdlZWsgLSAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWsgPSA0LCBzdGFydE9mV2VlayA9IDEpIHtcbiAgY29uc3Qgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh3ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2Vlayk7XG4gIGNvbnN0IHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHdlZWtZZWFyICsgMSwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2Vlayk7XG4gIHJldHVybiAoZGF5c0luWWVhcih3ZWVrWWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXIpIHtcbiAgaWYgKHllYXIgPiA5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2UgcmV0dXJuIHllYXIgPiBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xufVxuXG4vLyBQQVJTSU5HXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVpvbmVJbmZvKHRzLCBvZmZzZXRGb3JtYXQsIGxvY2FsZSwgdGltZVpvbmUgPSBudWxsKSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyksXG4gICAgaW50bE9wdHMgPSB7XG4gICAgICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgfTtcblxuICBpZiAodGltZVpvbmUpIHtcbiAgICBpbnRsT3B0cy50aW1lWm9uZSA9IHRpbWVab25lO1xuICB9XG5cbiAgY29uc3QgbW9kaWZpZWQgPSB7IHRpbWVab25lTmFtZTogb2Zmc2V0Rm9ybWF0LCAuLi5pbnRsT3B0cyB9O1xuXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgbW9kaWZpZWQpXG4gICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwidGltZXpvbmVuYW1lXCIpO1xuICByZXR1cm4gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogbnVsbDtcbn1cblxuLy8gc2lnbmVkT2Zmc2V0KCctNScsICczMCcpIC0+IC0zMzBcbmV4cG9ydCBmdW5jdGlvbiBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKSB7XG4gIGxldCBvZmZIb3VyID0gcGFyc2VJbnQob2ZmSG91clN0ciwgMTApO1xuXG4gIC8vIGRvbid0IHx8IHRoaXMgYmVjYXVzZSB3ZSB3YW50IHRvIHByZXNlcnZlIC0wXG4gIGlmIChOdW1iZXIuaXNOYU4ob2ZmSG91cikpIHtcbiAgICBvZmZIb3VyID0gMDtcbiAgfVxuXG4gIGNvbnN0IG9mZk1pbiA9IHBhcnNlSW50KG9mZk1pbnV0ZVN0ciwgMTApIHx8IDAsXG4gICAgb2ZmTWluU2lnbmVkID0gb2ZmSG91ciA8IDAgfHwgT2JqZWN0LmlzKG9mZkhvdXIsIC0wKSA/IC1vZmZNaW4gOiBvZmZNaW47XG4gIHJldHVybiBvZmZIb3VyICogNjAgKyBvZmZNaW5TaWduZWQ7XG59XG5cbi8vIENPRVJDSU9OXG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcih2YWx1ZSkge1xuICBjb25zdCBudW1lcmljVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gXCJcIiB8fCAhTnVtYmVyLmlzRmluaXRlKG51bWVyaWNWYWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBJbnZhbGlkIHVuaXQgdmFsdWUgJHt2YWx1ZX1gKTtcbiAgcmV0dXJuIG51bWVyaWNWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZXIpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBmb3IgKGNvbnN0IHUgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgdSkpIHtcbiAgICAgIGNvbnN0IHYgPSBvYmpbdV07XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVyKHUpXSA9IGFzTnVtYmVyKHYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T2Zmc2V0KG9mZnNldCwgZm9ybWF0KSB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgLyA2MCkpLFxuICAgIG1pbnV0ZXMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAlIDYwKSksXG4gICAgc2lnbiA9IG9mZnNldCA+PSAwID8gXCIrXCIgOiBcIi1cIjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJzfSR7bWludXRlcyA+IDAgPyBgOiR7bWludXRlc31gIDogXCJcIn1gO1xuICAgIGNhc2UgXCJ0ZWNoaWVcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfSR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIGZvcm1hdCAke2Zvcm1hdH0gaXMgb3V0IG9mIHJhbmdlIGZvciBwcm9wZXJ0eSBmb3JtYXRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZU9iamVjdChvYmopIHtcbiAgcmV0dXJuIHBpY2sob2JqLCBbXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/zoneUtil.js":
/*!**************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/impl/zoneUtil.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeZone: () => (/* binding */ normalizeZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/invalidZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../zones/systemZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/systemZone.js\");\n/**\n * @private\n */\n\n\n\n\n\n\n\n\n\nfunction normalizeZone(input, defaultZone) {\n  let offset;\n  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(input) || input === null) {\n    return defaultZone;\n  } else if (input instanceof _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    return input;\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isString)(input)) {\n    const lowered = input.toLowerCase();\n    if (lowered === \"default\") return defaultZone;\n    else if (lowered === \"local\" || lowered === \"system\") return _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance;\n    else if (lowered === \"utc\" || lowered === \"gmt\") return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance;\n    else return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parseSpecifier(lowered) || _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(input);\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(input)) {\n    return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(input);\n  } else if (typeof input === \"object\" && \"offset\" in input && typeof input.offset === \"function\") {\n    // This is dumb, but the instanceof check above doesn't seem to really work\n    // so we're duck checking it\n    return input;\n  } else {\n    return new _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](input);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFOEI7QUFDYztBQUNjO0FBQ1I7O0FBRVU7QUFDWjs7QUFFekM7QUFDUDtBQUNBLE1BQU0scURBQVc7QUFDakI7QUFDQSxJQUFJLDBCQUEwQixnREFBSTtBQUNsQztBQUNBLElBQUksU0FBUyxrREFBUTtBQUNyQjtBQUNBO0FBQ0EsaUVBQWlFLDREQUFVO0FBQzNFLDREQUE0RCxpRUFBZTtBQUMzRSxnQkFBZ0IsaUVBQWUsNEJBQTRCLDBEQUFRO0FBQ25FLElBQUksU0FBUyxrREFBUTtBQUNyQixXQUFXLGlFQUFlO0FBQzFCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZSw2REFBVztBQUMxQjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC96b25lVXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IEludmFsaWRab25lIGZyb20gXCIuLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4uL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIGRlZmF1bHRab25lKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIGNvbnN0IGxvd2VyZWQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcmVkID09PSBcImRlZmF1bHRcIikgcmV0dXJuIGRlZmF1bHRab25lO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwibG9jYWxcIiB8fCBsb3dlcmVkID09PSBcInN5c3RlbVwiKSByZXR1cm4gU3lzdGVtWm9uZS5pbnN0YW5jZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcInV0Y1wiIHx8IGxvd2VyZWQgPT09IFwiZ210XCIpIHJldHVybiBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgZWxzZSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKGxvd2VyZWQpIHx8IElBTkFab25lLmNyZWF0ZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIFwib2Zmc2V0XCIgaW4gaW5wdXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gVGhpcyBpcyBkdW1iLCBidXQgdGhlIGluc3RhbmNlb2YgY2hlY2sgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHJlYWxseSB3b3JrXG4gICAgLy8gc28gd2UncmUgZHVjayBjaGVja2luZyBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/zoneUtil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/info.js":
/*!*****************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/info.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Info)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n\n\n\n\n\n\n\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nclass Info {\n  /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */\n  static hasDST(zone = _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone) {\n    const proto = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].now().setZone(zone).set({ month: 12 });\n\n    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;\n  }\n\n  /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */\n  static isValidIANAZone(zone) {\n    return _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isValidZone(zone);\n  }\n\n  /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone#isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */\n  static normalizeZone(input) {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(input, _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone);\n  }\n\n  /**\n   * Get the weekday on which the week starts according to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday\n   */\n  static getStartOfWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getStartOfWeek();\n  }\n\n  /**\n   * Get the minimum number of days necessary in a week before it is considered part of the next year according\n   * to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number}\n   */\n  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getMinDaysInFirstWeek();\n  }\n\n  /**\n   * Get the weekdays, which are considered the weekend according to the given locale\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday\n   */\n  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {\n    // copy the array, because we cache it internally\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getWeekendDays().slice();\n  }\n\n  /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'\n   * @return {Array}\n   */\n  static months(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length);\n  }\n\n  /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link Info#months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {Array}\n   */\n  static monthsFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length, true);\n  }\n\n  /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''\n   * @return {Array}\n   */\n  static weekdays(length = \"long\", { locale = null, numberingSystem = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length);\n  }\n\n  /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link Info#weekdays}\n   * @param {string} [length='long'] - the length of the month representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @return {Array}\n   */\n  static weekdaysFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length, true);\n  }\n\n  /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]\n   * @return {Array}\n   */\n  static meridiems({ locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale).meridiems();\n  }\n\n  /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\n   * @return {Array}\n   */\n  static eras(length = \"short\", { locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, null, \"gregory\").eras(length);\n  }\n\n  /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `relative`: whether this environment supports relative time formatting\n   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale\n   * @example Info.features() //=> { relative: false, localeWeek: true }\n   * @return {Object}\n   */\n  static features() {\n    return { relative: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasRelative)(), localeWeek: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasLocaleWeekInfo)() };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2luZm8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxQztBQUNBO0FBQ0M7QUFDSztBQUNROztBQUVhOztBQUVoRTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsY0FBYztBQUNkO0FBQ0EsdUJBQXVCLG9EQUFRO0FBQy9CLGtCQUFrQixvREFBUSwyQkFBMkIsV0FBVzs7QUFFaEUsNkRBQTZELFVBQVU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVcsMERBQVE7QUFDbkI7O0FBRUE7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVcsZ0VBQWEsUUFBUSxvREFBUTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsMEJBQTBCLCtCQUErQixJQUFJO0FBQzdELHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQSxxQ0FBcUMsK0JBQStCLElBQUk7QUFDeEUsc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFVBQVU7QUFDekI7QUFDQSw4QkFBOEIsK0JBQStCLElBQUk7QUFDakU7QUFDQSxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RCx1Q0FBdUMsY0FBYztBQUNyRCxvQ0FBb0MsMkJBQTJCO0FBQy9ELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1GQUFtRjtBQUN6RjtBQUNBLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRkFBbUY7QUFDekY7QUFDQSxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RCx1Q0FBdUMsY0FBYztBQUNyRCxjQUFjO0FBQ2Q7QUFDQSxxQ0FBcUMsdURBQXVELElBQUk7QUFDaEcsc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQXVEO0FBQzdEO0FBQ0Esc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsY0FBYztBQUNkO0FBQ0EscUJBQXFCLGdCQUFnQixJQUFJO0FBQ3pDLFdBQVcsdURBQU07QUFDakI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRCxjQUFjO0FBQ2Q7QUFDQSxrQ0FBa0MsZ0JBQWdCLElBQUk7QUFDdEQsV0FBVyx1REFBTTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhLFVBQVUsMERBQVcsZ0JBQWdCLGdFQUFpQjtBQUNuRTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW5mby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuXG5pbXBvcnQgeyBoYXNMb2NhbGVXZWVrSW5mbywgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcblxuLyoqXG4gKiBUaGUgSW5mbyBjbGFzcyBjb250YWlucyBzdGF0aWMgbWV0aG9kcyBmb3IgcmV0cmlldmluZyBnZW5lcmFsIHRpbWUgYW5kIGRhdGUgcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgaXQgaGFzIG1ldGhvZHMgZm9yIGZpbmRpbmcgb3V0IGlmIGEgdGltZSB6b25lIGhhcyBhIERTVCwgZm9yIGxpc3RpbmcgdGhlIG1vbnRocyBpbiBhbnkgc3VwcG9ydGVkIGxvY2FsZSwgYW5kIGZvciBkaXNjb3ZlcmluZyB3aGljaCBvZiBMdXhvbiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmZvIHtcbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBjb250YWlucyBhIERTVC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBab25lIHRvIGNoZWNrLiBEZWZhdWx0cyB0byB0aGUgZW52aXJvbm1lbnQncyBsb2NhbCB6b25lLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGhhc0RTVCh6b25lID0gU2V0dGluZ3MuZGVmYXVsdFpvbmUpIHtcbiAgICBjb25zdCBwcm90byA9IERhdGVUaW1lLm5vdygpLnNldFpvbmUoem9uZSkuc2V0KHsgbW9udGg6IDEyIH0pO1xuXG4gICAgcmV0dXJuICF6b25lLmlzVW5pdmVyc2FsICYmIHByb3RvLm9mZnNldCAhPT0gcHJvdG8uc2V0KHsgbW9udGg6IDYgfSkub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBpcyBhIHZhbGlkIElBTkEgc3BlY2lmaWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFpvbmUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkSUFOQVpvbmUoem9uZSkge1xuICAgIHJldHVybiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lI2lzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtkYXkgb24gd2hpY2ggdGhlIHdlZWsgc3RhcnRzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gbG9jYWxlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBzdGFydCBvZiB0aGUgd2VlaywgMSBmb3IgTW9uZGF5IHRocm91Z2ggNyBmb3IgU3VuZGF5XG4gICAqL1xuICBzdGF0aWMgZ2V0U3RhcnRPZldlZWsoeyBsb2NhbGUgPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlKSkuZ2V0U3RhcnRPZldlZWsoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGRheXMgbmVjZXNzYXJ5IGluIGEgd2VlayBiZWZvcmUgaXQgaXMgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBuZXh0IHllYXIgYWNjb3JkaW5nXG4gICAqIHRvIHRoZSBnaXZlbiBsb2NhbGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRNaW5pbXVtRGF5c0luRmlyc3RXZWVrKHsgbG9jYWxlID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSkpLmdldE1pbkRheXNJbkZpcnN0V2VlaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla2RheXMsIHdoaWNoIGFyZSBjb25zaWRlcmVkIHRoZSB3ZWVrZW5kIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gbG9jYWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybnMge251bWJlcltdfSBhbiBhcnJheSBvZiB3ZWVrZGF5cywgMSBmb3IgTW9uZGF5IHRocm91Z2ggNyBmb3IgU3VuZGF5XG4gICAqL1xuICBzdGF0aWMgZ2V0V2Vla2VuZFdlZWtkYXlzKHsgbG9jYWxlID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICAvLyBjb3B5IHRoZSBhcnJheSwgYmVjYXVzZSB3ZSBjYWNoZSBpdCBpbnRlcm5hbGx5XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUpKS5nZXRXZWVrZW5kRGF5cygpLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygpWzBdIC8vPT4gJ0phbnVhcnknXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcpWzBdIC8vPT4gJ0phbidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnKVswXSAvLz0+ICcxJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9IClbMF0gLy89PiAnamFudi4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2aEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdsb25nJywgeyBvdXRwdXRDYWxlbmRhcjogJ2lzbGFtaWMnIH0pWzBdIC8vPT4gJ1JhYmnKuyBJJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHMoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyNtb250aHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSB3ZWVrIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoKVswXSAvLz0+ICdNb25kYXknXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JylbMF0gLy89PiAnTW9uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0pWzBdIC8vPT4gJ2x1bi4nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2KfZhNin2KvZhtmK2YYnXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzKGxlbmd0aCA9IFwibG9uZ1wiLCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCB3ZWVrIG5hbWVzLlxuICAgKiBGb3JtYXQgd2Vla2RheXMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSB3ZWVrZGF5cyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gbW9yZSBkYXRlIGluZm9ybWF0aW9uLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyN3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPW51bGxdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgbWVyaWRpZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoKSAvLz0+IFsgJ0FNJywgJ1BNJyBdXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKHsgbG9jYWxlOiAnbXknIH0pIC8vPT4gWyAn4YCU4YC24YCU4YCA4YC6JywgJ+GAiuGAlOGAsScgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJpZGllbXMoeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSkubWVyaWRpZW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBlcmFzKGxlbmd0aCA9IFwic2hvcnRcIiwgeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVsbCwgXCJncmVnb3J5XCIpLmVyYXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICogU29tZSBmZWF0dXJlcyBvZiBMdXhvbiBhcmUgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLiBGb3IgZXhhbXBsZSwgb24gb2xkZXIgYnJvd3NlcnMsIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZyBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgKiBLZXlzOlxuICAgKiAqIGByZWxhdGl2ZWA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmdcbiAgICogKiBgbG9jYWxlV2Vla2A6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyBkaWZmZXJlbnQgd2Vla2RheXMgZm9yIHRoZSBzdGFydCBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gICAqIEBleGFtcGxlIEluZm8uZmVhdHVyZXMoKSAvLz0+IHsgcmVsYXRpdmU6IGZhbHNlLCBsb2NhbGVXZWVrOiB0cnVlIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZlYXR1cmVzKCkge1xuICAgIHJldHVybiB7IHJlbGF0aXZlOiBoYXNSZWxhdGl2ZSgpLCBsb2NhbGVXZWVrOiBoYXNMb2NhbGVXZWVrSW5mbygpIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/interval.js":
/*!*********************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/interval.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interval)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/formats.js\");\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Interval\";\n\n// checks if the start is equal to or before the end\nfunction validateStartEnd(start, end) {\n  if (!start || !start.isValid) {\n    return Interval.invalid(\"missing or invalid start\");\n  } else if (!end || !end.isValid) {\n    return Interval.invalid(\"missing or invalid end\");\n  } else if (end < start) {\n    return Interval.invalid(\n      \"end before start\",\n      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`\n    );\n  } else {\n    return null;\n  }\n}\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.\n * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.\n * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}\n * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.\n */\nclass Interval {\n  /**\n   * @private\n   */\n  constructor(config) {\n    /**\n     * @access private\n     */\n    this.s = config.start;\n    /**\n     * @access private\n     */\n    this.e = config.end;\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.isLuxonInterval = true;\n  }\n\n  /**\n   * Create an invalid Interval.\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Interval}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidIntervalError(invalid);\n    } else {\n      return new Interval({ invalid });\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n   * @param {DateTime|Date|Object} start\n   * @param {DateTime|Date|Object} end\n   * @return {Interval}\n   */\n  static fromDateTimes(start, end) {\n    const builtStart = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start),\n      builtEnd = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n\n    const validateError = validateStartEnd(builtStart, builtEnd);\n\n    if (validateError == null) {\n      return new Interval({\n        start: builtStart,\n        end: builtEnd,\n      });\n    } else {\n      return validateError;\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and a Duration to extend to.\n   * @param {DateTime|Date|Object} start\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static after(start, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start);\n    return Interval.fromDateTimes(dt, dt.plus(dur));\n  }\n\n  /**\n   * Create an Interval from an end DateTime and a Duration to extend backwards to.\n   * @param {DateTime|Date|Object} end\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static before(end, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n    return Interval.fromDateTimes(dt.minus(dur), dt);\n  }\n\n  /**\n   * Create an Interval from an ISO 8601 string.\n   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n   * @param {string} text - the ISO string to parse\n   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {Interval}\n   */\n  static fromISO(text, opts) {\n    const [s, e] = (text || \"\").split(\"/\", 2);\n    if (s && e) {\n      let start, startIsValid;\n      try {\n        start = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(s, opts);\n        startIsValid = start.isValid;\n      } catch (e) {\n        startIsValid = false;\n      }\n\n      let end, endIsValid;\n      try {\n        end = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(e, opts);\n        endIsValid = end.isValid;\n      } catch (e) {\n        endIsValid = false;\n      }\n\n      if (startIsValid && endIsValid) {\n        return Interval.fromDateTimes(start, end);\n      }\n\n      if (startIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(e, opts);\n        if (dur.isValid) {\n          return Interval.after(start, dur);\n        }\n      } else if (endIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(s, opts);\n        if (dur.isValid) {\n          return Interval.before(end, dur);\n        }\n      }\n    }\n    return Interval.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n  }\n\n  /**\n   * Check if an object is an Interval. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isInterval(o) {\n    return (o && o.isLuxonInterval) || false;\n  }\n\n  /**\n   * Returns the start of the Interval\n   * @type {DateTime}\n   */\n  get start() {\n    return this.isValid ? this.s : null;\n  }\n\n  /**\n   * Returns the end of the Interval. This is the first instant which is not part of the interval\n   * (Interval is half-open).\n   * @type {DateTime}\n   */\n  get end() {\n    return this.isValid ? this.e : null;\n  }\n\n  /**\n   * Returns the last DateTime included in the interval (since end is not part of the interval)\n   * @type {DateTime}\n   */\n  get lastDateTime() {\n    return this.isValid ? (this.e ? this.e.minus(1) : null) : null;\n  }\n\n  /**\n   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalidReason === null;\n  }\n\n  /**\n   * Returns an error code if this Interval is invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Returns the length of the Interval in the specified unit.\n   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\n   * @return {number}\n   */\n  length(unit = \"milliseconds\") {\n    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;\n  }\n\n  /**\n   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n   * @param {string} [unit='milliseconds'] - the unit of time to count.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime\n   * @return {number}\n   */\n  count(unit = \"milliseconds\", opts) {\n    if (!this.isValid) return NaN;\n    const start = this.start.startOf(unit, opts);\n    let end;\n    if (opts?.useLocaleWeeks) {\n      end = this.end.reconfigure({ locale: start.locale });\n    } else {\n      end = this.end;\n    }\n    end = end.startOf(unit, opts);\n    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());\n  }\n\n  /**\n   * Returns whether this Interval's start and end are both in the same unit of time\n   * @param {string} unit - the unit of time to check sameness on\n   * @return {boolean}\n   */\n  hasSame(unit) {\n    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end DateTimes.\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.s.valueOf() === this.e.valueOf();\n  }\n\n  /**\n   * Return whether this Interval's start is after the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isAfter(dateTime) {\n    if (!this.isValid) return false;\n    return this.s > dateTime;\n  }\n\n  /**\n   * Return whether this Interval's end is before the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isBefore(dateTime) {\n    if (!this.isValid) return false;\n    return this.e <= dateTime;\n  }\n\n  /**\n   * Return whether this Interval contains the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  contains(dateTime) {\n    if (!this.isValid) return false;\n    return this.s <= dateTime && this.e > dateTime;\n  }\n\n  /**\n   * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n   * @param {Object} values - the values to set\n   * @param {DateTime} values.start - the starting DateTime\n   * @param {DateTime} values.end - the ending DateTime\n   * @return {Interval}\n   */\n  set({ start, end } = {}) {\n    if (!this.isValid) return this;\n    return Interval.fromDateTimes(start || this.s, end || this.e);\n  }\n\n  /**\n   * Split this Interval at each of the specified DateTimes\n   * @param {...DateTime} dateTimes - the unit of time to count.\n   * @return {Array}\n   */\n  splitAt(...dateTimes) {\n    if (!this.isValid) return [];\n    const sorted = dateTimes\n        .map(_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)\n        .filter((d) => this.contains(d))\n        .sort((a, b) => a.toMillis() - b.toMillis()),\n      results = [];\n    let { s } = this,\n      i = 0;\n\n    while (s < this.e) {\n      const added = sorted[i] || this.e,\n        next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      i += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into smaller Intervals, each of the specified length.\n   * Left over time is grouped into a smaller interval\n   * @param {Duration|Object|number} duration - The length of each resulting interval.\n   * @return {Array}\n   */\n  splitBy(duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration);\n\n    if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\n      return [];\n    }\n\n    let { s } = this,\n      idx = 1,\n      next;\n\n    const results = [];\n    while (s < this.e) {\n      const added = this.start.plus(dur.mapUnits((x) => x * idx));\n      next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      idx += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into the specified number of smaller intervals.\n   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\n   * @return {Array}\n   */\n  divideEqually(numberOfParts) {\n    if (!this.isValid) return [];\n    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\n  }\n\n  /**\n   * Return whether this Interval overlaps with the specified Interval\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  overlaps(other) {\n    return this.e > other.s && this.s < other.e;\n  }\n\n  /**\n   * Return whether this Interval's end is adjacent to the specified Interval's start.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsStart(other) {\n    if (!this.isValid) return false;\n    return +this.e === +other.s;\n  }\n\n  /**\n   * Return whether this Interval's start is adjacent to the specified Interval's end.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsEnd(other) {\n    if (!this.isValid) return false;\n    return +other.e === +this.s;\n  }\n\n  /**\n   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  engulfs(other) {\n    if (!this.isValid) return false;\n    return this.s <= other.s && this.e >= other.e;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end as the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    return this.s.equals(other.s) && this.e.equals(other.e);\n  }\n\n  /**\n   * Return an Interval representing the intersection of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n   * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  intersection(other) {\n    if (!this.isValid) return this;\n    const s = this.s > other.s ? this.s : other.s,\n      e = this.e < other.e ? this.e : other.e;\n\n    if (s >= e) {\n      return null;\n    } else {\n      return Interval.fromDateTimes(s, e);\n    }\n  }\n\n  /**\n   * Return an Interval representing the union of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  union(other) {\n    if (!this.isValid) return this;\n    const s = this.s < other.s ? this.s : other.s,\n      e = this.e > other.e ? this.e : other.e;\n    return Interval.fromDateTimes(s, e);\n  }\n\n  /**\n   * Merge an array of Intervals into an equivalent minimal set of Intervals.\n   * Combines overlapping and adjacent Intervals.\n   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval\n   * and ending with the latest.\n   *\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static merge(intervals) {\n    const [found, final] = intervals\n      .sort((a, b) => a.s - b.s)\n      .reduce(\n        ([sofar, current], item) => {\n          if (!current) {\n            return [sofar, item];\n          } else if (current.overlaps(item) || current.abutsStart(item)) {\n            return [sofar, current.union(item)];\n          } else {\n            return [sofar.concat([current]), item];\n          }\n        },\n        [[], null]\n      );\n    if (final) {\n      found.push(final);\n    }\n    return found;\n  }\n\n  /**\n   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static xor(intervals) {\n    let start = null,\n      currentCount = 0;\n    const results = [],\n      ends = intervals.map((i) => [\n        { time: i.s, type: \"s\" },\n        { time: i.e, type: \"e\" },\n      ]),\n      flattened = Array.prototype.concat(...ends),\n      arr = flattened.sort((a, b) => a.time - b.time);\n\n    for (const i of arr) {\n      currentCount += i.type === \"s\" ? 1 : -1;\n\n      if (currentCount === 1) {\n        start = i.time;\n      } else {\n        if (start && +start !== +i.time) {\n          results.push(Interval.fromDateTimes(start, i.time));\n        }\n\n        start = null;\n      }\n    }\n\n    return Interval.merge(results);\n  }\n\n  /**\n   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n   * @param {...Interval} intervals\n   * @return {Array}\n   */\n  difference(...intervals) {\n    return Interval.xor([this].concat(intervals))\n      .map((i) => this.intersection(i))\n      .filter((i) => i && !i.isEmpty());\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for debugging.\n   * @return {string}\n   */\n  toString() {\n    if (!this.isValid) return INVALID;\n    return `[${this.s.toISO()}  ${this.e.toISO()})`;\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;\n    } else {\n      return `Interval { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns a localized string representing this Interval. Accepts the same options as the\n   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as\n   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method\n   * is browser-specific, but in general it will return an appropriate representation of the\n   * Interval in the assigned locale. Defaults to the system's locale if no locale has been\n   * specified.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or\n   * Intl.DateTimeFormat constructor options.\n   * @param {Object} opts - Options to override the configuration of the start DateTime.\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create(this.s.loc.clone(opts), formatOpts).formatInterval(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Interval.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISO(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of date of this Interval.\n   * The time components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {string}\n   */\n  toISODate() {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISODate()}/${this.e.toISODate()}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of time of this Interval.\n   * The date components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISOTime(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this Interval formatted according to the specified format\n   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible\n   * formatting tool.\n   * @param {string} dateFormat - The format string. This string formats the start and end time.\n   * See {@link DateTime#toFormat} for details.\n   * @param {Object} opts - Options.\n   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end\n   * representations.\n   * @return {string}\n   */\n  toFormat(dateFormat, { separator = \"  \" } = {}) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;\n  }\n\n  /**\n   * Return a Duration representing the time spanned by this interval.\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n   * @return {Duration}\n   */\n  toDuration(unit, opts) {\n    if (!this.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].invalid(this.invalidReason);\n    }\n    return this.e.diff(this.s, unit, opts);\n  }\n\n  /**\n   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n   * @param {function} mapFn\n   * @return {Interval}\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n   */\n  mapEndpoints(mapFn) {\n    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ludGVydmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTJEO0FBQ3RCO0FBQ0E7QUFDb0M7QUFDakM7QUFDSTtBQUNDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkVBQTJFLGVBQWUsVUFBVSxZQUFZO0FBQ2hIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlGQUF5RixlQUFlO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw2QkFBNkIsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsTUFBTSx1QkFBdUI7QUFDekosd0JBQXdCLHNCQUFzQixLQUFLLG9CQUFvQjtBQUN2RSxxREFBcUQscUJBQXFCLEdBQUcsc0JBQXNCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLE1BQU0sd0JBQXdCO0FBQ2hOLHdFQUF3RSxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyw0QkFBNEIsTUFBTSwwQkFBMEI7QUFDcFQsa0VBQWtFLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHO0FBQzlLLHlFQUF5RSx3QkFBd0IsR0FBRyw4QkFBOEIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsT0FBTywwQkFBMEI7QUFDOVE7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFB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O0FBQzNEO0FBQ0EsUUFBUSwwREFBUztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSw0QkFBNEI7QUFDakQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLDRCQUE0QjtBQUNqRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSx5QkFBeUI7QUFDbkMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBLHlCQUF5QixvQkFBb0IsSUFBSTtBQUNqRDtBQUNBLGNBQWMsNEJBQTRCLEVBQUUsVUFBVSxFQUFFLDRCQUE0QjtBQUNwRjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQiw4RUFBOEU7QUFDOUUsb0ZBQW9GO0FBQ3BGLGtHQUFrRztBQUNsRyw2R0FBNkc7QUFDN0csdUZBQXVGO0FBQ3ZGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9EQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLHdGQUF3RixVQUFVO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2FjaGUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGF0ZVRpbWUsIHsgZnJpZW5kbHlEYXRlVGltZSB9IGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWRJbnRlcnZhbEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgSW50ZXJ2YWxcIjtcblxuLy8gY2hlY2tzIGlmIHRoZSBzdGFydCBpcyBlcXVhbCB0byBvciBiZWZvcmUgdGhlIGVuZFxuZnVuY3Rpb24gdmFsaWRhdGVTdGFydEVuZChzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQgfHwgIXN0YXJ0LmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBzdGFydFwiKTtcbiAgfSBlbHNlIGlmICghZW5kIHx8ICFlbmQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIGVuZFwiKTtcbiAgfSBlbHNlIGlmIChlbmQgPCBzdGFydCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFxuICAgICAgXCJlbmQgYmVmb3JlIHN0YXJ0XCIsXG4gICAgICBgVGhlIGVuZCBvZiBhbiBpbnRlcnZhbCBtdXN0IGJlIGFmdGVyIGl0cyBzdGFydCwgYnV0IHlvdSBoYWQgc3RhcnQ9JHtzdGFydC50b0lTTygpfSBhbmQgZW5kPSR7ZW5kLnRvSVNPKCl9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBJbnRlcnZhbCBvYmplY3QgcmVwcmVzZW50cyBhIGhhbGYtb3BlbiBpbnRlcnZhbCBvZiB0aW1lLCB3aGVyZSBlYWNoIGVuZHBvaW50IGlzIGEge0BsaW5rIERhdGVUaW1lfS4gQ29uY2VwdHVhbGx5LCBpdCdzIGEgY29udGFpbmVyIGZvciB0aG9zZSB0d28gZW5kcG9pbnRzLCBhY2NvbXBhbmllZCBieSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgY29tcGFyaW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBJbnRlcnZhbDpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYW4gSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwuZnJvbURhdGVUaW1lc30sIHtAbGluayBJbnRlcnZhbC5hZnRlcn0sIHtAbGluayBJbnRlcnZhbC5iZWZvcmV9LCBvciB7QGxpbmsgSW50ZXJ2YWwuZnJvbUlTT30uXG4gKiAqICoqQWNjZXNzb3JzKiogVXNlIHtAbGluayBJbnRlcnZhbCNzdGFydH0gYW5kIHtAbGluayBJbnRlcnZhbCNlbmR9IHRvIGdldCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAqICogKipJbnRlcnJvZ2F0aW9uKiogVG8gYW5hbHl6ZSB0aGUgSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjY291bnR9LCB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSwge0BsaW5rIEludGVydmFsI2hhc1NhbWV9LCB7QGxpbmsgSW50ZXJ2YWwjY29udGFpbnN9LCB7QGxpbmsgSW50ZXJ2YWwjaXNBZnRlcn0sIG9yIHtAbGluayBJbnRlcnZhbCNpc0JlZm9yZX0uXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgb3RoZXIgSW50ZXJ2YWxzIG91dCBvZiB0aGlzIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNzZXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRBdH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEJ5fSwge0BsaW5rIEludGVydmFsI2RpdmlkZUVxdWFsbHl9LCB7QGxpbmsgSW50ZXJ2YWwubWVyZ2V9LCB7QGxpbmsgSW50ZXJ2YWwueG9yfSwge0BsaW5rIEludGVydmFsI3VuaW9ufSwge0BsaW5rIEludGVydmFsI2ludGVyc2VjdGlvbn0sIG9yIHtAbGluayBJbnRlcnZhbCNkaWZmZXJlbmNlfS5cbiAqICogKipDb21wYXJpc29uKiogVG8gY29tcGFyZSB0aGlzIEludGVydmFsIHRvIGFub3RoZXIgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI2VxdWFsc30sIHtAbGluayBJbnRlcnZhbCNvdmVybGFwc30sIHtAbGluayBJbnRlcnZhbCNhYnV0c1N0YXJ0fSwge0BsaW5rIEludGVydmFsI2FidXRzRW5kfSwge0BsaW5rIEludGVydmFsI2VuZ3VsZnN9XG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9TdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU099LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09EYXRlfSwge0BsaW5rIEludGVydmFsI3RvSVNPVGltZX0sIHtAbGluayBJbnRlcnZhbCN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgSW50ZXJ2YWwjdG9EdXJhdGlvbn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lID0gY29uZmlnLmVuZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWlsdFN0YXJ0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCksXG4gICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYWZ0ZXIoc3RhcnQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0LCBkdC5wbHVzKGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIGVuZCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgYmFja3dhcmRzIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBiZWZvcmUoZW5kLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQubWludXMoZHVyKSwgZHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIElTTyA4NjAxIHN0cmluZy5cbiAgICogQWNjZXB0cyBgPHN0YXJ0Pi88ZW5kPmAsIGA8c3RhcnQ+LzxkdXJhdGlvbj5gLCBhbmQgYDxkdXJhdGlvbj4vPGVuZD5gIGZvcm1hdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbnMgdG8gcGFzcyB7QGxpbmsgRGF0ZVRpbWUjZnJvbUlTT30gYW5kIG9wdGlvbmFsbHkge0BsaW5rIER1cmF0aW9uI2Zyb21JU099XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3MsIGVdID0gKHRleHQgfHwgXCJcIikuc3BsaXQoXCIvXCIsIDIpO1xuICAgIGlmIChzICYmIGUpIHtcbiAgICAgIGxldCBzdGFydCwgc3RhcnRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBzdGFydElzVmFsaWQgPSBzdGFydC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVuZCwgZW5kSXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IERhdGVUaW1lLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGVuZElzVmFsaWQgPSBlbmQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkICYmIGVuZElzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmFmdGVyKHN0YXJ0LCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmJlZm9yZShlbmQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIEludGVydmFsLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNJbnRlcnZhbChvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkludGVydmFsKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnMgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgSW50ZXJ2YWwuIFRoaXMgaXMgdGhlIGZpcnN0IGluc3RhbnQgd2hpY2ggaXMgbm90IHBhcnQgb2YgdGhlIGludGVydmFsXG4gICAqIChJbnRlcnZhbCBpcyBoYWxmLW9wZW4pLlxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgRGF0ZVRpbWUgaW5jbHVkZWQgaW4gdGhlIGludGVydmFsIChzaW5jZSBlbmQgaXMgbm90IHBhcnQgb2YgdGhlIGludGVydmFsKVxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgbGFzdERhdGVUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyAodGhpcy5lID8gdGhpcy5lLm1pbnVzKDEpIDogbnVsbCkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGF0IGxlYXN0IGl0cyBzdGFydCwgbWVhbmluZyB0aGF0IHRoZSBJbnRlcnZhbCBpc24ndCAnYmFja3dhcmRzJy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkUmVhc29uID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIEludGVydmFsIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBJbnRlcnZhbCBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbCBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIHJldHVybiB0aGUgbGVuZ3RoIGluLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0R1cmF0aW9uKC4uLlt1bml0XSkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzLCBtb250aHMsIG9yIHllYXJzIGluY2x1ZGVkIGluIHRoZSBJbnRlcnZhbCwgZXZlbiBpbiBwYXJ0LlxuICAgKiBVbmxpa2Uge0BsaW5rIEludGVydmFsI2xlbmd0aH0gdGhpcyBjb3VudHMgc2VjdGlvbnMgb2YgdGhlIGNhbGVuZGFyLCBub3QgcGVyaW9kcyBvZiB0aW1lLCBlLmcuIHNwZWNpZnlpbmcgJ2RheSdcbiAgICogYXNrcyAnd2hhdCBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBpbnRlcnZhbD8nLCBub3QgJ2hvdyBtYW55IGRheXMgbG9uZyBpcyB0aGlzIGludGVydmFsPydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1bml0PSdtaWxsaXNlY29uZHMnXSAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2VlazsgdGhpcyBvcGVyYXRpb24gd2lsbCBhbHdheXMgdXNlIHRoZSBsb2NhbGUgb2YgdGhlIHN0YXJ0IERhdGVUaW1lXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvdW50KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0LnN0YXJ0T2YodW5pdCwgb3B0cyk7XG4gICAgbGV0IGVuZDtcbiAgICBpZiAob3B0cz8udXNlTG9jYWxlV2Vla3MpIHtcbiAgICAgIGVuZCA9IHRoaXMuZW5kLnJlY29uZmlndXJlKHsgbG9jYWxlOiBzdGFydC5sb2NhbGUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHRoaXMuZW5kO1xuICAgIH1cbiAgICBlbmQgPSBlbmQuc3RhcnRPZih1bml0LCBvcHRzKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpKSArIChlbmQudmFsdWVPZigpICE9PSB0aGlzLmVuZC52YWx1ZU9mKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgYW5kIGVuZCBhcmUgYm90aCBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5pc0VtcHR5KCkgfHwgdGhpcy5lLm1pbnVzKDEpLmhhc1NhbWUodGhpcy5zLCB1bml0KSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgRGF0ZVRpbWVzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zLnZhbHVlT2YoKSA9PT0gdGhpcy5lLnZhbHVlT2YoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWZ0ZXIoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNCZWZvcmUoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmUgPD0gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBjb250YWlucyB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbnMoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPD0gZGF0ZVRpbWUgJiYgdGhpcy5lID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRzXCIgdGhlIHN0YXJ0IGFuZC9vciBlbmQgZGF0ZXMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIHRoZSB2YWx1ZXMgdG8gc2V0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5zdGFydCAtIHRoZSBzdGFydGluZyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuZW5kIC0gdGhlIGVuZGluZyBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHNldCh7IHN0YXJ0LCBlbmQgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0IHx8IHRoaXMucywgZW5kIHx8IHRoaXMuZSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBhdCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRBdCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNvcnRlZCA9IGRhdGVUaW1lc1xuICAgICAgICAubWFwKGZyaWVuZGx5RGF0ZVRpbWUpXG4gICAgICAgIC5maWx0ZXIoKGQpID0+IHRoaXMuY29udGFpbnMoZCkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnRvTWlsbGlzKCkgLSBiLnRvTWlsbGlzKCkpLFxuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpID0gMDtcblxuICAgIHdoaWxlIChzIDwgdGhpcy5lKSB7XG4gICAgICBjb25zdCBhZGRlZCA9IHNvcnRlZFtpXSB8fCB0aGlzLmUsXG4gICAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gc21hbGxlciBJbnRlcnZhbHMsIGVhY2ggb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAqIExlZnQgb3ZlciB0aW1lIGlzIGdyb3VwZWQgaW50byBhIHNtYWxsZXIgaW50ZXJ2YWxcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBsZW5ndGggb2YgZWFjaCByZXN1bHRpbmcgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRCeShkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIWR1ci5pc1ZhbGlkIHx8IGR1ci5hcyhcIm1pbGxpc2Vjb25kc1wiKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpZHggPSAxLFxuICAgICAgbmV4dDtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSB0aGlzLnN0YXJ0LnBsdXMoZHVyLm1hcFVuaXRzKCh4KSA9PiB4ICogaWR4KSk7XG4gICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc21hbGxlciBpbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZlBhcnRzIC0gVGhlIG51bWJlciBvZiBJbnRlcnZhbHMgdG8gZGl2aWRlIHRoZSBJbnRlcnZhbCBpbnRvLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpdmlkZUVxdWFsbHkobnVtYmVyT2ZQYXJ0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRCeSh0aGlzLmxlbmd0aCgpIC8gbnVtYmVyT2ZQYXJ0cykuc2xpY2UoMCwgbnVtYmVyT2ZQYXJ0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBvdmVybGFwcyB3aXRoIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxcbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG92ZXJsYXBzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZSA+IG90aGVyLnMgJiYgdGhpcy5zIDwgb3RoZXIuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBzdGFydC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzU3RhcnQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArdGhpcy5lID09PSArb3RoZXIucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWRqYWNlbnQgdG8gdGhlIHNwZWNpZmllZCBJbnRlcnZhbCdzIGVuZC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzRW5kKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK290aGVyLmUgPT09ICt0aGlzLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgSW50ZXJ2YWwgZnVsbHkgY29udGFpbnMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbCwgc3BlY2lmaWNhbGx5IGlmIHRoZSBpbnRlcnNlY3QgKG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBvdGhlciBJbnRlcnZhbCkgaXMgZXF1YWwgdG8gdGhlIG90aGVyIEludGVydmFsOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlbmd1bGZzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IG90aGVyLnMgJiYgdGhpcy5lID49IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBhcyB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zLmVxdWFscyhvdGhlci5zKSAmJiB0aGlzLmUuZXF1YWxzKG90aGVyLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSByZXN1bHRpbmcgSW50ZXJ2YWwgaGFzIHRoZSBtYXhpbXVtIHN0YXJ0IHRpbWUgYW5kIHRoZSBtaW5pbXVtIGVuZCB0aW1lIG9mIHRoZSB0d28gSW50ZXJ2YWxzLlxuICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGludGVyc2VjdGlvbiBpcyBlbXB0eSwgbWVhbmluZywgdGhlIGludGVydmFscyBkb24ndCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMgPiBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgIGUgPSB0aGlzLmUgPCBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcblxuICAgIGlmIChzID49IGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgdW5pb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWluaW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWF4aW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bmlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zIDwgb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lID4gb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIGludG8gYW4gZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIFRoZSByZXN1bHRpbmcgYXJyYXkgd2lsbCBjb250YWluIHRoZSBJbnRlcnZhbHMgaW4gYXNjZW5kaW5nIG9yZGVyLCB0aGF0IGlzLCBzdGFydGluZyB3aXRoIHRoZSBlYXJsaWVzdCBJbnRlcnZhbFxuICAgKiBhbmQgZW5kaW5nIHdpdGggdGhlIGxhdGVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmdlKGludGVydmFscykge1xuICAgIGNvbnN0IFtmb3VuZCwgZmluYWxdID0gaW50ZXJ2YWxzXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5zIC0gYi5zKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFtzb2ZhciwgY3VycmVudF0sIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGl0ZW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5vdmVybGFwcyhpdGVtKSB8fCBjdXJyZW50LmFidXRzU3RhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGN1cnJlbnQudW5pb24oaXRlbSldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLmNvbmNhdChbY3VycmVudF0pLCBpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtbXSwgbnVsbF1cbiAgICAgICk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmb3VuZC5wdXNoKGZpbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBJbnRlcnZhbHMgcmVwcmVzZW50aW5nIHRoZSBzcGFucyBvZiB0aW1lIHRoYXQgb25seSBhcHBlYXIgaW4gb25lIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgeG9yKGludGVydmFscykge1xuICAgIGxldCBzdGFydCA9IG51bGwsXG4gICAgICBjdXJyZW50Q291bnQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXSxcbiAgICAgIGVuZHMgPSBpbnRlcnZhbHMubWFwKChpKSA9PiBbXG4gICAgICAgIHsgdGltZTogaS5zLCB0eXBlOiBcInNcIiB9LFxuICAgICAgICB7IHRpbWU6IGkuZSwgdHlwZTogXCJlXCIgfSxcbiAgICAgIF0pLFxuICAgICAgZmxhdHRlbmVkID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5lbmRzKSxcbiAgICAgIGFyciA9IGZsYXR0ZW5lZC5zb3J0KChhLCBiKSA9PiBhLnRpbWUgLSBiLnRpbWUpO1xuXG4gICAgZm9yIChjb25zdCBpIG9mIGFycikge1xuICAgICAgY3VycmVudENvdW50ICs9IGkudHlwZSA9PT0gXCJzXCIgPyAxIDogLTE7XG5cbiAgICAgIGlmIChjdXJyZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSBpLnRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgJiYgK3N0YXJ0ICE9PSAraS50aW1lKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGkudGltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnZhbC5tZXJnZShyZXN1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBzcGFuIG9mIHRpbWUgaW4gdGhpcyBJbnRlcnZhbCB0aGF0IGRvZXNuJ3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHsuLi5JbnRlcnZhbH0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZGlmZmVyZW5jZSguLi5pbnRlcnZhbHMpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwueG9yKFt0aGlzXS5jb25jYXQoaW50ZXJ2YWxzKSlcbiAgICAgIC5tYXAoKGkpID0+IHRoaXMuaW50ZXJzZWN0aW9uKGkpKVxuICAgICAgLmZpbHRlcigoaSkgPT4gaSAmJiAhaS5pc0VtcHR5KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGBbJHt0aGlzLnMudG9JU08oKX0g4oCTICR7dGhpcy5lLnRvSVNPKCl9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGFwcHJvcHJpYXRlIGZvciB0aGUgUkVQTC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGBJbnRlcnZhbCB7IHN0YXJ0OiAke3RoaXMucy50b0lTTygpfSwgZW5kOiAke3RoaXMuZS50b0lTTygpfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBJbnRlcnZhbCB7IEludmFsaWQsIHJlYXNvbjogJHt0aGlzLmludmFsaWRSZWFzb259IH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBJbnRlcnZhbC4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZVxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzXG4gICAqIHtAbGluayBEYXRlVGltZS5EQVRFX0ZVTEx9IG9yIHtAbGluayBEYXRlVGltZS5USU1FX1NJTVBMRX0uIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZFxuICAgKiBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogSW50ZXJ2YWwgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS4gRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW5cbiAgICogc3BlY2lmaWVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZm9ybWF0T3B0cz1EYXRlVGltZS5EQVRFX1NIT1JUXSAtIEVpdGhlciBhIERhdGVUaW1lIHByZXNldCBvclxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgc3RhcnQgRGF0ZVRpbWUuXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAxMS83LzIwMjIg4oCTIDExLzgvMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gTm92ZW1iZXIgNyDigJMgOCwgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmci1GUicgfSk7IC8vPT4gN+KAkzggbm92ZW1icmUgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiA2OjAwIOKAkyA4OjAwIFBNXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gTW9uLCBOb3YgMDcsIDY6MDAg4oCTIDg6MDAgcFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5zLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0SW50ZXJ2YWwodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU08ob3B0cyl9LyR7dGhpcy5lLnRvSVNPKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGRhdGUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIHRpbWUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09EYXRlKCl9LyR7dGhpcy5lLnRvSVNPRGF0ZSgpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIGRhdGUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPVGltZShvcHRzKX0vJHt0aGlzLmUudG9JU09UaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXRcbiAgICogc3RyaW5nLiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlXG4gICAqIGZvcm1hdHRpbmcgdG9vbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVGb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZy4gVGhpcyBzdHJpbmcgZm9ybWF0cyB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lLlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc2VwYXJhdG9yID0gICcg4oCTICddIC0gQSBzZXBhcmF0b3IgdG8gcGxhY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZFxuICAgKiByZXByZXNlbnRhdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGRhdGVGb3JtYXQsIHsgc2VwYXJhdG9yID0gXCIg4oCTIFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvRm9ybWF0KGRhdGVGb3JtYXQpfSR7c2VwYXJhdG9yfSR7dGhpcy5lLnRvRm9ybWF0KGRhdGVGb3JtYXQpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSB0aW1lIHNwYW5uZWQgYnkgdGhpcyBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbigpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogODg0ODkyNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdkYXlzJykudG9PYmplY3QoKSAvLz0+IHsgZGF5czogMS4wMjQxODEyMTUyNzc3Nzc4IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNC44MjA5NSB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNCwgc2Vjb25kczogNDkuMjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IHNlY29uZHM6IDg4NDg5LjI1NyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgdG9EdXJhdGlvbih1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKHRoaXMuaW52YWxpZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmUuZGlmZih0aGlzLnMsIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBtYXBGbiBvbiB0aGUgaW50ZXJ2YWwgc3RhcnQgYW5kIGVuZCwgcmV0dXJuaW5nIGEgbmV3IEludGVydmFsIGZyb20gdGhlIHJlc3VsdGluZyBEYXRlVGltZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRm5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC50b1VUQygpKVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQucGx1cyh7IGhvdXJzOiAyIH0pKVxuICAgKi9cbiAgbWFwRW5kcG9pbnRzKG1hcEZuKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMobWFwRm4odGhpcy5zKSwgbWFwRm4odGhpcy5lKSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/interval.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/luxon.js":
/*!******************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/luxon.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* reexport safe */ _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Duration: () => (/* reexport safe */ _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   FixedOffsetZone: () => (/* reexport safe */ _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   IANAZone: () => (/* reexport safe */ _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   Info: () => (/* reexport safe */ _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   Interval: () => (/* reexport safe */ _interval_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   InvalidZone: () => (/* reexport safe */ _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   Settings: () => (/* reexport safe */ _settings_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   SystemZone: () => (/* reexport safe */ _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Zone: () => (/* reexport safe */ _zone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/info.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zones/invalidZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"3.7.1\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2x1eG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNBO0FBQ0E7QUFDUjtBQUNBO0FBQzRCO0FBQ2Q7QUFDTTtBQUNGO0FBQ1Y7O0FBRXJDOztBQWNFIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvbHV4b24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IEluZm8gZnJvbSBcIi4vaW5mby5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4vem9uZS5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IEludmFsaWRab25lIGZyb20gXCIuL3pvbmVzL2ludmFsaWRab25lLmpzXCI7XG5pbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcblxuY29uc3QgVkVSU0lPTiA9IFwiMy43LjFcIjtcblxuZXhwb3J0IHtcbiAgVkVSU0lPTixcbiAgRGF0ZVRpbWUsXG4gIER1cmF0aW9uLFxuICBJbnRlcnZhbCxcbiAgSW5mbyxcbiAgWm9uZSxcbiAgRml4ZWRPZmZzZXRab25lLFxuICBJQU5BWm9uZSxcbiAgSW52YWxpZFpvbmUsXG4gIFN5c3RlbVpvbmUsXG4gIFNldHRpbmdzLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/luxon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js":
/*!*********************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/settings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Settings)\n/* harmony export */ });\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_digits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/digits.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/digits.js\");\n\n\n\n\n\n\n\n\n\nlet now = () => Date.now(),\n  defaultZone = \"system\",\n  defaultLocale = null,\n  defaultNumberingSystem = null,\n  defaultOutputCalendar = null,\n  twoDigitCutoffYear = 60,\n  throwOnInvalid,\n  defaultWeekSettings = null;\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.\n */\nclass Settings {\n  /**\n   * Get the callback for returning the current timestamp.\n   * @type {function}\n   */\n  static get now() {\n    return now;\n  }\n\n  /**\n   * Set the callback for returning the current timestamp.\n   * The function should return a number, which will be interpreted as an Epoch millisecond count\n   * @type {function}\n   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n   */\n  static set now(n) {\n    now = n;\n  }\n\n  /**\n   * Set the default time zone to create DateTimes in. Does not affect existing instances.\n   * Use the value \"system\" to reset this value to the system's time zone.\n   * @type {string}\n   */\n  static set defaultZone(zone) {\n    defaultZone = zone;\n  }\n\n  /**\n   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.\n   * The default value is the system's time zone (the one set on the machine that runs this code).\n   * @type {Zone}\n   */\n  static get defaultZone() {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(defaultZone, _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance);\n  }\n\n  /**\n   * Get the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultLocale() {\n    return defaultLocale;\n  }\n\n  /**\n   * Set the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultLocale(locale) {\n    defaultLocale = locale;\n  }\n\n  /**\n   * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultNumberingSystem() {\n    return defaultNumberingSystem;\n  }\n\n  /**\n   * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultNumberingSystem(numberingSystem) {\n    defaultNumberingSystem = numberingSystem;\n  }\n\n  /**\n   * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultOutputCalendar() {\n    return defaultOutputCalendar;\n  }\n\n  /**\n   * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultOutputCalendar(outputCalendar) {\n    defaultOutputCalendar = outputCalendar;\n  }\n\n  /**\n   * @typedef {Object} WeekSettings\n   * @property {number} firstDay\n   * @property {number} minimalDays\n   * @property {number[]} weekend\n   */\n\n  /**\n   * @return {WeekSettings|null}\n   */\n  static get defaultWeekSettings() {\n    return defaultWeekSettings;\n  }\n\n  /**\n   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and\n   * how many days are required in the first week of a year.\n   * Does not affect existing instances.\n   *\n   * @param {WeekSettings|null} weekSettings\n   */\n  static set defaultWeekSettings(weekSettings) {\n    defaultWeekSettings = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.validateWeekSettings)(weekSettings);\n  }\n\n  /**\n   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   */\n  static get twoDigitCutoffYear() {\n    return twoDigitCutoffYear;\n  }\n\n  /**\n   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century\n   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century\n   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950\n   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50\n   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50\n   */\n  static set twoDigitCutoffYear(cutoffYear) {\n    twoDigitCutoffYear = cutoffYear % 100;\n  }\n\n  /**\n   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static get throwOnInvalid() {\n    return throwOnInvalid;\n  }\n\n  /**\n   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static set throwOnInvalid(t) {\n    throwOnInvalid = t;\n  }\n\n  /**\n   * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCaches() {\n    _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resetCache();\n    _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resetCache();\n    _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].resetCache();\n    (0,_impl_digits_js__WEBPACK_IMPORTED_MODULE_6__.resetDigitRegexCache)();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3NldHRpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStDO0FBQ0o7QUFDTDtBQUNEOztBQUVjO0FBQ0c7QUFDRTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLGdFQUFhLGNBQWMsNERBQVU7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFVBQVU7QUFDMUI7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQW9CO0FBQzlDOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsSUFBSSx1REFBTTtBQUNWLElBQUksMERBQVE7QUFDWixJQUFJLG9EQUFRO0FBQ1osSUFBSSxxRUFBb0I7QUFDeEI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3NldHRpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5cbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZVdlZWtTZXR0aW5ncyB9IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IHsgcmVzZXREaWdpdFJlZ2V4Q2FjaGUgfSBmcm9tIFwiLi9pbXBsL2RpZ2l0cy5qc1wiO1xuXG5sZXQgbm93ID0gKCkgPT4gRGF0ZS5ub3coKSxcbiAgZGVmYXVsdFpvbmUgPSBcInN5c3RlbVwiLFxuICBkZWZhdWx0TG9jYWxlID0gbnVsbCxcbiAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bGwsXG4gIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG51bGwsXG4gIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDYwLFxuICB0aHJvd09uSW52YWxpZCxcbiAgZGVmYXVsdFdlZWtTZXR0aW5ncyA9IG51bGw7XG5cbi8qKlxuICogU2V0dGluZ3MgY29udGFpbnMgc3RhdGljIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBjb250cm9sIEx1eG9uJ3Mgb3ZlcmFsbCBiZWhhdmlvci4gTHV4b24gaXMgYSBzaW1wbGUgbGlicmFyeSB3aXRoIGZldyBvcHRpb25zLCBidXQgdGhlIG9uZXMgaXQgZG9lcyBoYXZlIGxpdmUgaGVyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3Mge1xuICAvKipcbiAgICogR2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCBub3coKSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlciwgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBFcG9jaCBtaWxsaXNlY29uZCBjb3VudFxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IERhdGUubm93KCkgKyAzMDAwIC8vIHByZXRlbmQgaXQgaXMgMyBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gMCAvLyBhbHdheXMgcHJldGVuZCBpdCdzIEphbiAxLCAxOTcwIGF0IG1pZG5pZ2h0IGluIFVUQyB0aW1lXG4gICAqL1xuICBzdGF0aWMgc2V0IG5vdyhuKSB7XG4gICAgbm93ID0gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFVzZSB0aGUgdmFsdWUgXCJzeXN0ZW1cIiB0byByZXNldCB0aGlzIHZhbHVlIHRvIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRab25lKHpvbmUpIHtcbiAgICBkZWZhdWx0Wm9uZSA9IHpvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSBvYmplY3QgY3VycmVudGx5IHVzZWQgdG8gY3JlYXRlIERhdGVUaW1lcy4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIHN5c3RlbSdzIHRpbWUgem9uZSAodGhlIG9uZSBzZXQgb24gdGhlIG1hY2hpbmUgdGhhdCBydW5zIHRoaXMgY29kZSkuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0Wm9uZSgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplWm9uZShkZWZhdWx0Wm9uZSwgU3lzdGVtWm9uZS5pbnN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRMb2NhbGUobG9jYWxlKSB7XG4gICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBXZWVrU2V0dGluZ3NcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZpcnN0RGF5XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5pbWFsRGF5c1xuICAgKiBAcHJvcGVydHkge251bWJlcltdfSB3ZWVrZW5kXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtXZWVrU2V0dGluZ3N8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFdlZWtTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdlZWtTZXR0aW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3Mgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBsb2NhbGUgd2VlayBzZXR0aW5ncywgaS5lLiB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIHRoZSB3ZWVrZW5kIGFuZFxuICAgKiBob3cgbWFueSBkYXlzIGFyZSByZXF1aXJlZCBpbiB0aGUgZmlyc3Qgd2VlayBvZiBhIHllYXIuXG4gICAqIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2Vla1NldHRpbmdzfG51bGx9IHdlZWtTZXR0aW5nc1xuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0V2Vla1NldHRpbmdzKHdlZWtTZXR0aW5ncykge1xuICAgIGRlZmF1bHRXZWVrU2V0dGluZ3MgPSB2YWxpZGF0ZVdlZWtTZXR0aW5ncyh3ZWVrU2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3V0b2ZmIHllYXIgZm9yIHdoZXRoZXIgYSAyLWRpZ2l0IHllYXIgc3RyaW5nIGlzIGludGVycHJldGVkIGluIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIGNlbnR1cnkuIE51bWJlcnMgaGlnaGVyIHRoYW4gdGhlIGN1dG9mZiB3aWxsIGJlIGNvbnNpZGVyZWQgdG8gbWVhbiAxOXh4IGFuZCBudW1iZXJzIGxvd2VyIG9yIGVxdWFsIHRvIHRoZSBjdXRvZmYgd2lsbCBiZSBjb25zaWRlcmVkIDIweHguXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcigpIHtcbiAgICByZXR1cm4gdHdvRGlnaXRDdXRvZmZZZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3V0b2ZmIHllYXIgZm9yIHdoZXRoZXIgYSAyLWRpZ2l0IHllYXIgc3RyaW5nIGlzIGludGVycHJldGVkIGluIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIGNlbnR1cnkuIE51bWJlcnMgaGlnaGVyIHRoYW4gdGhlIGN1dG9mZiB3aWxsIGJlIGNvbnNpZGVyZWQgdG8gbWVhbiAxOXh4IGFuZCBudW1iZXJzIGxvd2VyIG9yIGVxdWFsIHRvIHRoZSBjdXRvZmYgd2lsbCBiZSBjb25zaWRlcmVkIDIweHguXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDAgLy8gYWxsICd5eScgYXJlIGludGVycHJldGVkIGFzIDIwdGggY2VudHVyeVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSA5OSAvLyBhbGwgJ3l5JyBhcmUgaW50ZXJwcmV0ZWQgYXMgMjFzdCBjZW50dXJ5XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDUwIC8vICc0OScgLT4gMjA0OTsgJzUwJyAtPiAxOTUwXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDE5NTAgLy8gaW50ZXJwcmV0ZWQgYXMgNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMjA1MCAvLyBBTFNPIGludGVycHJldGVkIGFzIDUwXG4gICAqL1xuICBzdGF0aWMgc2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcihjdXRvZmZZZWFyKSB7XG4gICAgdHdvRGlnaXRDdXRvZmZZZWFyID0gY3V0b2ZmWWVhciAlIDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRocm93T25JbnZhbGlkKCkge1xuICAgIHJldHVybiB0aHJvd09uSW52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHRocm93T25JbnZhbGlkKHQpIHtcbiAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgTHV4b24ncyBnbG9iYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gICAgRGF0ZVRpbWUucmVzZXRDYWNoZSgpO1xuICAgIHJlc2V0RGlnaXRSZWdleENhY2hlKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/settings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js":
/*!*****************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/zone.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Zone)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/errors.js\");\n\n\n/**\n * @interface\n */\nclass Zone {\n  /**\n   * The type of zone\n   * @abstract\n   * @type {string}\n   */\n  get type() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The name of this zone.\n   * @abstract\n   * @type {string}\n   */\n  get name() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The IANA name of this zone.\n   * Defaults to `name` if not overwritten by a subclass.\n   * @abstract\n   * @type {string}\n   */\n  get ianaName() {\n    return this.name;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year.\n   * @abstract\n   * @type {boolean}\n   */\n  get isUniversal() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, opts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @abstract\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @abstract\n   * @type {boolean}\n   */\n  get isValid() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQztBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBJQU5BIG5hbWUgb2YgdGhpcyB6b25lLlxuICAgKiBEZWZhdWx0cyB0byBgbmFtZWAgaWYgbm90IG92ZXJ3cml0dGVuIGJ5IGEgc3ViY2xhc3MuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyBjb21tb24gbmFtZSAoc3VjaCBhcyBFU1QpIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gYWZmZWN0IHRoZSBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLiBBY2NlcHRzICdsb25nJyBvciAnc2hvcnQnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5sb2NhbGUgLSBXaGF0IGxvY2FsZSB0byByZXR1cm4gdGhlIG9mZnNldCBuYW1lIGluLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBvZmZzZXROYW1lKHRzLCBvcHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCh0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgdmFsaWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js":
/*!***************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/zones/IANAZone.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ IANAZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js\");\n\n\n\nconst dtfCache = new Map();\nfunction makeDTF(zoneName) {\n  let dtf = dtfCache.get(zoneName);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zoneName,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n    dtfCache.set(zoneName, dtf);\n  }\n  return dtf;\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nconst ianaZoneCache = new Map();\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nclass IANAZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    let zone = ianaZoneCache.get(name);\n    if (zone === undefined) {\n      ianaZoneCache.set(name, (zone = new IANAZone(name)));\n    }\n    return zone;\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache.clear();\n    dtfCache.clear();\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /**\n   * The type of zone. `iana` for all instances of `IANAZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"iana\";\n  }\n\n  /**\n   * The name of this zone (i.e. the IANA zone name).\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.zoneName;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns false for all IANA zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return false;\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale, this.name);\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    if (!this.valid) return NaN;\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.objToLocalTS)({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.valid;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL0lBTkFab25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RjtBQUMzRDs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEMsWUFBWSxjQUFjO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxNQUFNLFVBQVUsMERBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDZSx1QkFBdUIsZ0RBQUk7QUFDMUM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUpBQXFKO0FBQ3JKLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQyxXQUFXLDREQUFhO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVcsMkRBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsMkRBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL0lBTkFab25lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbywgaXNVbmRlZmluZWQsIG9ialRvTG9jYWxUUyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmNvbnN0IGR0ZkNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gbWFrZURURih6b25lTmFtZSkge1xuICBsZXQgZHRmID0gZHRmQ2FjaGUuZ2V0KHpvbmVOYW1lKTtcbiAgaWYgKGR0ZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgdGltZVpvbmU6IHpvbmVOYW1lLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGVyYTogXCJzaG9ydFwiLFxuICAgIH0pO1xuICAgIGR0ZkNhY2hlLnNldCh6b25lTmFtZSwgZHRmKTtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5jb25zdCB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGVyYTogMyxcbiAgaG91cjogNCxcbiAgbWludXRlOiA1LFxuICBzZWNvbmQ6IDYsXG59O1xuXG5mdW5jdGlvbiBoYWNreU9mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9cXHUyMDBFL2csIFwiXCIpLFxuICAgIHBhcnNlZCA9IC8oXFxkKylcXC8oXFxkKylcXC8oXFxkKykgKEFEfEJDKSw/IChcXGQrKTooXFxkKyk6KFxcZCspLy5leGVjKGZvcm1hdHRlZCksXG4gICAgWywgZk1vbnRoLCBmRGF5LCBmWWVhciwgZmFkT3JCYywgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdID0gcGFyc2VkO1xuICByZXR1cm4gW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXTtcbn1cblxuZnVuY3Rpb24gcGFydHNPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXRUb1BhcnRzKGRhdGUpO1xuICBjb25zdCBmaWxsZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBmb3JtYXR0ZWRbaV07XG4gICAgY29uc3QgcG9zID0gdHlwZVRvUG9zW3R5cGVdO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiZXJhXCIpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQocG9zKSkge1xuICAgICAgZmlsbGVkW3Bvc10gPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsbGVkO1xufVxuXG5jb25zdCBpYW5hWm9uZUNhY2hlID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBBIHpvbmUgaWRlbnRpZmllZCBieSBhbiBJQU5BIGlkZW50aWZpZXIsIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElBTkFab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFpvbmUgbmFtZVxuICAgKiBAcmV0dXJuIHtJQU5BWm9uZX1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUobmFtZSkge1xuICAgIGxldCB6b25lID0gaWFuYVpvbmVDYWNoZS5nZXQobmFtZSk7XG4gICAgaWYgKHpvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWFuYVpvbmVDYWNoZS5zZXQobmFtZSwgKHpvbmUgPSBuZXcgSUFOQVpvbmUobmFtZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHpvbmU7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgbG9jYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBpYW5hWm9uZUNhY2hlLmNsZWFyKCk7XG4gICAgZHRmQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIHZhbGlkIHNwZWNpZmllci4gVGhpcyBvbmx5IGNoZWNrcyB0aGUgc3RyaW5nJ3MgZm9ybWF0LCBub3QgdGhhdCB0aGUgc3BlY2lmaWVyIGlkZW50aWZpZXMgYSBrbm93biB6b25lOyBzZWUgaXNWYWxpZFpvbmUgZm9yIHRoYXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIHN0cmluZyB0byBjaGVjayB2YWxpZGl0eSBvblxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEBkZXByZWNhdGVkIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZvcndhcmRzIHRvIGlzVmFsaWRab25lLCBiZXR0ZXIgdXNlIGBpc1ZhbGlkWm9uZSgpYCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTcGVjaWZpZXIocykge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRab25lKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlkZW50aWZpZXMgYSByZWFsIHpvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiBmYWxzZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFpvbmUoem9uZSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IHRpbWVab25lOiB6b25lIH0pLmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gbmFtZTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy52YWxpZCA9IElBTkFab25lLmlzVmFsaWRab25lKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmUuIGBpYW5hYCBmb3IgYWxsIGluc3RhbmNlcyBvZiBgSUFOQVpvbmVgLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImlhbmFcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUgKGkuZS4gdGhlIElBTkEgem9uZSBuYW1lKS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG9mZnNldCBpcyBrbm93biB0byBiZSBmaXhlZCBmb3IgdGhlIHdob2xlIHllYXI6XG4gICAqIEFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBhbGwgSUFOQSB6b25lcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyBjb21tb24gbmFtZSAoc3VjaCBhcyBFU1QpIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gYWZmZWN0IHRoZSBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLiBBY2NlcHRzICdsb25nJyBvciAnc2hvcnQnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5sb2NhbGUgLSBXaGF0IGxvY2FsZSB0byByZXR1cm4gdGhlIG9mZnNldCBuYW1lIGluLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUsIHRoaXMubmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmb3IgdGhpcyB6b25lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBjb21wdXRlIHRoZSBvZmZzZXRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgICBpZiAoaXNOYU4oZGF0ZSkpIHJldHVybiBOYU47XG5cbiAgICBjb25zdCBkdGYgPSBtYWtlRFRGKHRoaXMubmFtZSk7XG4gICAgbGV0IFt5ZWFyLCBtb250aCwgZGF5LCBhZE9yQmMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IGR0Zi5mb3JtYXRUb1BhcnRzXG4gICAgICA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSlcbiAgICAgIDogaGFja3lPZmZzZXQoZHRmLCBkYXRlKTtcblxuICAgIGlmIChhZE9yQmMgPT09IFwiQkNcIikge1xuICAgICAgeWVhciA9IC1NYXRoLmFicyh5ZWFyKSArIDE7XG4gICAgfVxuXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB1c2luZyBob3VyMTIgYW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMjU1NjQmY2FuPTImcT0lMjIyNCUzQTAwJTIyJTIwZGF0ZXRpbWVmb3JtYXRcbiAgICBjb25zdCBhZGp1c3RlZEhvdXIgPSBob3VyID09PSAyNCA/IDAgOiBob3VyO1xuXG4gICAgY29uc3QgYXNVVEMgPSBvYmpUb0xvY2FsVFMoe1xuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5LFxuICAgICAgaG91cjogYWRqdXN0ZWRIb3VyLFxuICAgICAgbWludXRlLFxuICAgICAgc2Vjb25kLFxuICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgfSk7XG5cbiAgICBsZXQgYXNUUyA9ICtkYXRlO1xuICAgIGNvbnN0IG92ZXIgPSBhc1RTICUgMTAwMDtcbiAgICBhc1RTIC09IG92ZXIgPj0gMCA/IG92ZXIgOiAxMDAwICsgb3ZlcjtcbiAgICByZXR1cm4gKGFzVVRDIC0gYXNUUykgLyAoNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgZXF1YWwgdG8gYW5vdGhlciB6b25lXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge1pvbmV9IG90aGVyWm9uZSAtIHRoZSB6b25lIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiaWFuYVwiICYmIG90aGVyWm9uZS5uYW1lID09PSB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/IANAZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js":
/*!**********************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FixedOffsetZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * A zone with a fixed offset (meaning no DST)\n * @implements {Zone}\n */\nclass FixedOffsetZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of UTC\n   * @return {FixedOffsetZone}\n   */\n  static get utcInstance() {\n    if (singleton === null) {\n      singleton = new FixedOffsetZone(0);\n    }\n    return singleton;\n  }\n\n  /**\n   * Get an instance with a specified offset\n   * @param {number} offset - The offset in minutes\n   * @return {FixedOffsetZone}\n   */\n  static instance(offset) {\n    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);\n  }\n\n  /**\n   * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n   * @param {string} s - The offset string to parse\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+6\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+06\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n   * @return {FixedOffsetZone}\n   */\n  static parseSpecifier(s) {\n    if (s) {\n      const r = s.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\n      if (r) {\n        return new FixedOffsetZone((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(r[1], r[2]));\n      }\n    }\n    return null;\n  }\n\n  constructor(offset) {\n    super();\n    /** @private **/\n    this.fixed = offset;\n  }\n\n  /**\n   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"fixed\";\n  }\n\n  /**\n   * The name of this zone.\n   * All fixed zones' names always start with \"UTC\" (plus optional offset)\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.fixed === 0 ? \"UTC\" : `UTC${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, \"narrow\")}`;\n  }\n\n  /**\n   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`\n   *\n   * @override\n   * @type {string}\n   */\n  get ianaName() {\n    if (this.fixed === 0) {\n      return \"Etc/UTC\";\n    } else {\n      return `Etc/GMT${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(-this.fixed, \"narrow\")}`;\n    }\n  }\n\n  /**\n   * Returns the offset's common name at the specified timestamp.\n   *\n   * For fixed offset zones this equals to the zone name.\n   * @override\n   */\n  offsetName() {\n    return this.name;\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, format);\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns true for all fixed offset zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return true;\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   *\n   * For fixed offset zones, this is constant and does not depend on a timestamp.\n   * @override\n   * @return {number}\n   */\n  offset() {\n    return this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"fixed\" && otherZone.fixed === this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is valid:\n   * All fixed offset zones are valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkQ7QUFDL0I7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDZSw4QkFBOEIsZ0RBQUk7QUFDakQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSxTQUFTLEVBQUU7QUFDdkQ7QUFDQSxtQ0FBbUMsMkRBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRDQUE0QywyREFBWSx1QkFBdUI7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLDJEQUFZLHdCQUF3QjtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLDJEQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNhY2hlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdE9mZnNldCwgc2lnbmVkT2Zmc2V0IH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogQSB6b25lIHdpdGggYSBmaXhlZCBvZmZzZXQgKG1lYW5pbmcgbm8gRFNUKVxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkT2Zmc2V0Wm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFVUQ1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHV0Y0luc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBGaXhlZE9mZnNldFpvbmUoMCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UgOiBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIGEgVVRDIG9mZnNldCBzdHJpbmcsIGxpa2UgXCJVVEMrNlwiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIG9mZnNldCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzA2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQy02OjAwXCIpXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBwYXJzZVNwZWNpZmllcihzKSB7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSBzLm1hdGNoKC9edXRjKD86KFsrLV1cXGR7MSwyfSkoPzo6KFxcZHsyfSkpPyk/JC9pKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRPZmZzZXRab25lKHNpZ25lZE9mZnNldChyWzFdLCByWzJdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy5maXhlZCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lLiBgZml4ZWRgIGZvciBhbGwgaW5zdGFuY2VzIG9mIGBGaXhlZE9mZnNldFpvbmVgLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImZpeGVkXCI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyB6b25lLlxuICAgKiBBbGwgZml4ZWQgem9uZXMnIG5hbWVzIGFsd2F5cyBzdGFydCB3aXRoIFwiVVRDXCIgKHBsdXMgb3B0aW9uYWwgb2Zmc2V0KVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkID09PSAwID8gXCJVVENcIiA6IGBVVEMke2Zvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBJQU5BIG5hbWUgb2YgdGhpcyB6b25lLCBpLmUuIGBFdGMvVVRDYCBvciBgRXRjL0dNVCsvLW5uYFxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICBpZiAodGhpcy5maXhlZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiRXRjL1VUQ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEV0Yy9HTVQke2Zvcm1hdE9mZnNldCgtdGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEZvciBmaXhlZCBvZmZzZXQgem9uZXMgdGhpcyBlcXVhbHMgdG8gdGhlIHpvbmUgbmFtZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhcjpcbiAgICogQWx3YXlzIHJldHVybnMgdHJ1ZSBmb3IgYWxsIGZpeGVkIG9mZnNldCB6b25lcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICpcbiAgICogRm9yIGZpeGVkIG9mZnNldCB6b25lcywgdGhpcyBpcyBjb25zdGFudCBhbmQgZG9lcyBub3QgZGVwZW5kIG9uIGEgdGltZXN0YW1wLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmUgKGkuZS4gYWxzbyBmaXhlZCBhbmQgc2FtZSBvZmZzZXQpXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge1pvbmV9IG90aGVyWm9uZSAtIHRoZSB6b25lIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiZml4ZWRcIiAmJiBvdGhlclpvbmUuZml4ZWQgPT09IHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkOlxuICAgKiBBbGwgZml4ZWQgb2Zmc2V0IHpvbmVzIGFyZSB2YWxpZC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/fixedOffsetZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/invalidZone.js":
/*!******************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/zones/invalidZone.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InvalidZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js\");\n\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n * @implements {Zone}\n */\nclass InvalidZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(zoneName) {\n    super();\n    /**  @private */\n    this.zoneName = zoneName;\n  }\n\n  /** @override **/\n  get type() {\n    return \"invalid\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName() {\n    return null;\n  }\n\n  /** @override **/\n  formatOffset() {\n    return \"\";\n  }\n\n  /** @override **/\n  offset() {\n    return NaN;\n  }\n\n  /** @override **/\n  equals() {\n    return false;\n  }\n\n  /** @override **/\n  get isValid() {\n    return false;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThCOztBQUU5QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ2UsMEJBQTBCLGdEQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbi8qKlxuICogQSB6b25lIHRoYXQgZmFpbGVkIHRvIHBhcnNlLiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkWm9uZSBleHRlbmRzIFpvbmUge1xuICBjb25zdHJ1Y3Rvcih6b25lTmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqICBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuem9uZU5hbWUgPSB6b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImludmFsaWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/invalidZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/systemZone.js":
/*!*****************************************************************!*\
  !*** ../fjell-cache/node_modules/luxon/src/zones/systemZone.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SystemZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * Represents the local zone for this JavaScript environment.\n * @implements {Zone}\n */\nclass SystemZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of the local zone\n   * @return {SystemZone}\n   */\n  static get instance() {\n    if (singleton === null) {\n      singleton = new SystemZone();\n    }\n    return singleton;\n  }\n\n  /** @override **/\n  get type() {\n    return \"system\";\n  }\n\n  /** @override **/\n  get name() {\n    return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    return -new Date(ts).getTimezoneOffset();\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"system\";\n  }\n\n  /** @override **/\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThEO0FBQ2hDOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ2UseUJBQXlCLGdEQUFJO0FBQzVDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLFdBQVcsNERBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMkRBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jYWNoZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbG9jYWwgem9uZVxuICAgKiBAcmV0dXJuIHtTeXN0ZW1ab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgU3lzdGVtWm9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-cache/node_modules/luxon/src/zones/systemZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/dist/index.js":
/*!*****************************************!*\
  !*** ../fjell-client-api/dist/index.js ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   AuthorizationError: () => (/* binding */ AuthorizationError),\n/* harmony export */   ClientApiError: () => (/* binding */ ClientApiError),\n/* harmony export */   ConfigurationError: () => (/* binding */ ConfigurationError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   HttpWrapper: () => (/* binding */ HttpWrapper),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   ParseError: () => (/* binding */ ParseError),\n/* harmony export */   PayloadTooLargeError: () => (/* binding */ PayloadTooLargeError),\n/* harmony export */   RateLimitError: () => (/* binding */ RateLimitError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   calculateRetryDelay: () => (/* binding */ calculateRetryDelay),\n/* harmony export */   createCItemApi: () => (/* binding */ createCItemApi),\n/* harmony export */   createHttpError: () => (/* binding */ createHttpError),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createInstanceFactory: () => (/* binding */ createInstanceFactory),\n/* harmony export */   createNetworkError: () => (/* binding */ createNetworkError),\n/* harmony export */   createPItemApi: () => (/* binding */ createPItemApi),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryFactory: () => (/* binding */ createRegistryFactory),\n/* harmony export */   enhanceError: () => (/* binding */ enhanceError),\n/* harmony export */   executeErrorHandler: () => (/* binding */ executeErrorHandler),\n/* harmony export */   executeWithRetry: () => (/* binding */ executeWithRetry),\n/* harmony export */   getRetryConfig: () => (/* binding */ getRetryConfig),\n/* harmony export */   isClientApiError: () => (/* binding */ isClientApiError),\n/* harmony export */   isRetryableError: () => (/* binding */ isRetryableError),\n/* harmony export */   shouldRetryError: () => (/* binding */ shouldRetryError)\n/* harmony export */ });\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/core */ \"(app-pages-browser)/../fjell-client-api/node_modules/@fjell/core/dist/index.js\");\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/../fjell-client-api/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fjell/registry */ \"(app-pages-browser)/../fjell-client-api/node_modules/@fjell/registry/dist/index.js\");\n// src/ops/all.ts\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLogger(\"@fjell/client-api\");\nvar logger_default = LibLogger;\n// src/ops/all.ts\nvar logger = logger_default.get(\"client-api\", \"ops\", \"all\");\nvar getAllOperation = (api, apiOptions, utilities)=>{\n    const all = async function() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const params = (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.queryToParams)(query);\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.allAuthenticated,\n            params\n        });\n        logger.default(\"all\", {\n            query,\n            locations,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)));\n    };\n    return all;\n};\n// src/ops/action.ts\nvar logger2 = logger_default.get(\"client-api\", \"ops\", \"action\");\nvar getActionOperation = (api, apiOptions, utilities)=>{\n    const action = async function(ik, action2) {\n        let body = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const requestOptions = Object.assign({}, apiOptions.postOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger2.default(\"action\", {\n            ik,\n            action: action2,\n            body,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processOne(api.httpPost(\"\".concat(utilities.getPath(ik), \"/\").concat(action2), body, requestOptions)));\n    };\n    return action;\n};\n// src/ops/allAction.ts\nvar logger3 = logger_default.get(\"client-api\", \"ops\", \"allAction\");\nvar getAllActionOperation = (api, apiOptions, utilities)=>{\n    const allAction = async function(action) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        const requestOptions = Object.assign({}, apiOptions.postOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger3.default(\"allAction\", {\n            action,\n            body,\n            locations,\n            requestOptions\n        });\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        return utilities.validatePK(await utilities.processArray(api.httpPost(\"\".concat(utilities.getPath(loc), \"/\").concat(action), body, requestOptions)));\n    };\n    return allAction;\n};\n// src/ops/one.ts\n\nvar logger4 = logger_default.get(\"client-api\", \"ops\", \"one\");\nvar getOneOperation = (api, apiOptions, utilities)=>{\n    const one = async function() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const params = (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.queryToParams)(query);\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.readAuthenticated,\n            params\n        });\n        logger4.default(\"one\", {\n            query,\n            locations,\n            requestOptions\n        });\n        let item = null;\n        const items = utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)));\n        if (items.length > 0) {\n            item = items[0];\n        }\n        return item;\n    };\n    return one;\n};\n// src/ops/errorHandling.ts\nfunction shouldRetryError(error) {\n    var _error_message, _error_message1;\n    if (error.code === \"ECONNREFUSED\" || error.code === \"ENOTFOUND\" || error.code === \"ENETUNREACH\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"network\"))) {\n        return true;\n    }\n    if (error.status >= 500 || error.status === 429) {\n        return true;\n    }\n    if (error.status >= 400 && error.status < 500 && error.status !== 429) {\n        return false;\n    }\n    return true;\n}\nfunction calculateRetryDelay(attempt, config) {\n    const exponentialDelay = (config.initialDelayMs || 1e3) * Math.pow(config.backoffMultiplier || 2, attempt);\n    const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs || 3e4);\n    const jitter = 0.5 + Math.random() * 0.5;\n    return Math.floor(cappedDelay * jitter);\n}\nfunction enhanceError(error, context) {\n    if (!error) return new Error(\"Unknown error occurred\");\n    if (error.context) return error;\n    const enhancedError = new Error(error.message || \"HTTP operation failed\");\n    Object.assign(enhancedError, {\n        code: error.code || error.status || \"UNKNOWN_ERROR\",\n        status: error.status,\n        context,\n        originalError: error\n    });\n    return enhancedError;\n}\nfunction getRetryConfig(apiOptions) {\n    return {\n        maxRetries: 3,\n        initialDelayMs: 1e3,\n        maxDelayMs: 3e4,\n        backoffMultiplier: 2,\n        ...apiOptions.retryConfig\n    };\n}\nfunction executeErrorHandler(errorHandler, error, context, logger21) {\n    if (!errorHandler) return;\n    try {\n        errorHandler(error, context);\n    } catch (handlerError) {\n        logger21.error(\"Custom error handler failed\", {\n            originalError: error.message,\n            handlerError: (handlerError === null || handlerError === void 0 ? void 0 : handlerError.message) || String(handlerError)\n        });\n    }\n}\nasync function executeWithRetry(operation, operationName, operationContext, apiOptions, logger21, specialErrorHandling) {\n    const retryConfig = getRetryConfig(apiOptions);\n    let lastError = null;\n    const startTime = Date.now();\n    for(let attempt = 0; attempt <= retryConfig.maxRetries; attempt++){\n        try {\n            logger21.debug(\"Executing \".concat(operationName, \" (attempt \").concat(attempt + 1, \")\"), operationContext);\n            const result = await operation();\n            if (attempt > 0) {\n                logger21.info(\"\".concat(operationName, \" operation succeeded after \").concat(attempt, \" retries\"), {\n                    ...operationContext,\n                    totalAttempts: attempt + 1,\n                    duration: Date.now() - startTime\n                });\n            }\n            return result;\n        } catch (error) {\n            lastError = error;\n            if (specialErrorHandling) {\n                const specialResult = specialErrorHandling(error);\n                if (specialResult !== void 0) {\n                    return specialResult;\n                }\n            }\n            if (attempt === retryConfig.maxRetries) {\n                break;\n            }\n            const isRetryable = shouldRetryError(error);\n            if (!isRetryable) {\n                logger21.debug(\"Not retrying \".concat(operationName, \" operation due to non-retryable error\"), {\n                    ...operationContext,\n                    errorMessage: error.message,\n                    errorCode: error.code || error.status,\n                    attempt: attempt + 1\n                });\n                break;\n            }\n            const delay = calculateRetryDelay(attempt, retryConfig);\n            logger21.warning(\"Retrying \".concat(operationName, \" operation (attempt \").concat(attempt + 2, \") after \").concat(delay, \"ms\"), {\n                ...operationContext,\n                errorMessage: error.message,\n                errorCode: error.code || error.status,\n                delay,\n                attemptNumber: attempt + 1\n            });\n            await new Promise((resolve)=>setTimeout(resolve, delay));\n        }\n    }\n    const finalError = enhanceError(lastError, operationContext);\n    executeErrorHandler(apiOptions.errorHandler, finalError, operationContext, logger21);\n    logger21.error(\"\".concat(operationName, \" operation failed after \").concat(retryConfig.maxRetries + 1, \" attempts\"), {\n        ...operationContext,\n        errorMessage: finalError.message,\n        errorCode: finalError.code || finalError.status,\n        duration: Date.now() - startTime,\n        totalAttempts: retryConfig.maxRetries + 1\n    });\n    throw finalError;\n}\n// src/ops/create.ts\nvar logger5 = logger_default.get(\"client-api\", \"ops\", \"create\");\nvar getCreateOperation = (api, apiOptions, utilities)=>{\n    const create = async function(item) {\n        let locations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        const requestOptions = Object.assign({}, apiOptions.postOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger5.default(\"create\", {\n            item,\n            locations,\n            requestOptions\n        });\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const operationContext = {\n            operation: \"create\",\n            path: utilities.getPath(loc),\n            itemType: typeof item,\n            hasLocations: locations.length > 0\n        };\n        const retryConfig = {\n            maxRetries: 3,\n            initialDelayMs: 1e3,\n            maxDelayMs: 3e4,\n            backoffMultiplier: 2,\n            ...apiOptions.retryConfig\n        };\n        let lastError = null;\n        const startTime = Date.now();\n        for(let attempt = 0; attempt <= retryConfig.maxRetries; attempt++){\n            try {\n                logger5.debug(\"Creating item (attempt \".concat(attempt + 1, \")\"), operationContext);\n                const result = await utilities.processOne(api.httpPost(utilities.getPath(loc), item, requestOptions));\n                const created = utilities.validatePK(result);\n                if (attempt > 0) {\n                    logger5.info(\"Create operation succeeded after \".concat(attempt, \" retries\"), {\n                        ...operationContext,\n                        totalAttempts: attempt + 1,\n                        duration: Date.now() - startTime\n                    });\n                }\n                return created;\n            } catch (error) {\n                lastError = error;\n                if (attempt === retryConfig.maxRetries) {\n                    break;\n                }\n                const isRetryable = shouldRetryError(error);\n                if (!isRetryable) {\n                    logger5.debug(\"Not retrying create operation due to non-retryable error\", {\n                        ...operationContext,\n                        errorMessage: error.message,\n                        errorCode: error.code || error.status,\n                        attempt: attempt + 1\n                    });\n                    break;\n                }\n                const delay = calculateRetryDelay(attempt, retryConfig);\n                logger5.warning(\"Retrying create operation (attempt \".concat(attempt + 2, \") after \").concat(delay, \"ms\"), {\n                    ...operationContext,\n                    errorMessage: error.message,\n                    errorCode: error.code || error.status,\n                    delay,\n                    attemptNumber: attempt + 1\n                });\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n        }\n        const finalError = enhanceError(lastError, operationContext);\n        if (apiOptions.errorHandler) {\n            try {\n                apiOptions.errorHandler(finalError, operationContext);\n            } catch (handlerError) {\n                logger5.error(\"Custom error handler failed\", {\n                    originalError: finalError.message,\n                    handlerError: (handlerError === null || handlerError === void 0 ? void 0 : handlerError.message) || String(handlerError)\n                });\n            }\n        }\n        logger5.error(\"Create operation failed after \".concat(retryConfig.maxRetries + 1, \" attempts\"), {\n            ...operationContext,\n            errorMessage: finalError.message,\n            errorCode: finalError.code || finalError.status,\n            duration: Date.now() - startTime,\n            totalAttempts: retryConfig.maxRetries + 1\n        });\n        throw finalError;\n    };\n    return create;\n};\n// src/ops/update.ts\nvar logger6 = logger_default.get(\"client-api\", \"ops\", \"update\");\nvar getUpdateOperation = (api, apiOptions, utilities)=>{\n    const update = async (ik, item)=>{\n        const requestOptions = Object.assign({}, apiOptions.putOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger6.default(\"update\", {\n            ik,\n            item,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processOne(api.httpPut(utilities.getPath(ik), item, requestOptions)));\n    };\n    return update;\n};\n// src/ops/get.ts\nvar logger7 = logger_default.get(\"client-api\", \"ops\", \"get\");\nvar getGetOperation = (api, apiOptions, utilities)=>{\n    const get = async (ik)=>{\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.readAuthenticated\n        });\n        logger7.default(\"get\", {\n            ik,\n            requestOptions\n        });\n        const operationContext = {\n            operation: \"get\",\n            path: utilities.getPath(ik),\n            keyType: typeof ik\n        };\n        const retryConfig = {\n            maxRetries: 3,\n            initialDelayMs: 1e3,\n            maxDelayMs: 3e4,\n            backoffMultiplier: 2,\n            ...apiOptions.retryConfig\n        };\n        let lastError = null;\n        const startTime = Date.now();\n        for(let attempt = 0; attempt <= retryConfig.maxRetries; attempt++){\n            try {\n                logger7.debug(\"Getting item (attempt \".concat(attempt + 1, \")\"), operationContext);\n                const result = await utilities.processOne(api.httpGet(utilities.getPath(ik), requestOptions));\n                const item = utilities.validatePK(result);\n                if (attempt > 0) {\n                    logger7.info(\"Get operation succeeded after \".concat(attempt, \" retries\"), {\n                        ...operationContext,\n                        totalAttempts: attempt + 1,\n                        duration: Date.now() - startTime\n                    });\n                }\n                return item;\n            } catch (error) {\n                lastError = error;\n                if (error.status === 404) {\n                    logger7.debug(\"Item not found (404)\", operationContext);\n                    return null;\n                }\n                if (attempt === retryConfig.maxRetries) {\n                    break;\n                }\n                const isRetryable = shouldRetryError(error);\n                if (!isRetryable) {\n                    logger7.debug(\"Not retrying get operation due to non-retryable error\", {\n                        ...operationContext,\n                        errorMessage: error.message,\n                        errorCode: error.code || error.status,\n                        attempt: attempt + 1\n                    });\n                    break;\n                }\n                const delay = calculateRetryDelay(attempt, retryConfig);\n                logger7.warning(\"Retrying get operation (attempt \".concat(attempt + 2, \") after \").concat(delay, \"ms\"), {\n                    ...operationContext,\n                    errorMessage: error.message,\n                    errorCode: error.code || error.status,\n                    delay,\n                    attemptNumber: attempt + 1\n                });\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n        }\n        const finalError = enhanceError(lastError, operationContext);\n        if (apiOptions.errorHandler) {\n            try {\n                apiOptions.errorHandler(finalError, operationContext);\n            } catch (handlerError) {\n                logger7.error(\"Custom error handler failed\", {\n                    originalError: finalError.message,\n                    handlerError: (handlerError === null || handlerError === void 0 ? void 0 : handlerError.message) || String(handlerError)\n                });\n            }\n        }\n        logger7.error(\"Get operation failed after \".concat(retryConfig.maxRetries + 1, \" attempts\"), {\n            ...operationContext,\n            errorMessage: finalError.message,\n            errorCode: finalError.code || finalError.status,\n            duration: Date.now() - startTime,\n            totalAttempts: retryConfig.maxRetries + 1\n        });\n        throw finalError;\n    };\n    return get;\n};\n// src/ops/remove.ts\nvar logger8 = logger_default.get(\"client-api\", \"ops\", \"remove\");\nvar getRemoveOperation = (api, apiOptions, utilities)=>{\n    const remove = async (ik)=>{\n        const requestOptions = Object.assign({}, apiOptions.deleteOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated\n        });\n        logger8.default(\"remove\", {\n            ik,\n            requestOptions\n        });\n        return api.httpDelete(utilities.getPath(ik), requestOptions);\n    };\n    return remove;\n};\n// src/ops/find.ts\nvar logger9 = logger_default.get(\"client-api\", \"ops\", \"find\");\nvar getFindOperation = (api, apiOptions, utilities)=>{\n    const find = async function(finder) {\n        let finderParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const mergedParams = finderToParams(finder, finderParams);\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.allAuthenticated,\n            params: mergedParams\n        });\n        logger9.default(\"find\", {\n            finder,\n            finderParams,\n            locations,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)));\n    };\n    return find;\n};\n// src/ops/findOne.ts\nvar logger10 = logger_default.get(\"client-api\", \"ops\", \"find\");\nvar getFindOneOperation = (api, apiOptions, utilities)=>{\n    const findOne = async function(finder) {\n        let finderParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        const params = finderToParams(finder, finderParams);\n        params.one = true;\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.allAuthenticated,\n            params\n        });\n        logger10.default(\"findOne\", {\n            finder,\n            finderParams,\n            locations,\n            requestOptions\n        });\n        return utilities.validatePK(await utilities.processArray(api.httpGet(utilities.getPath(loc), requestOptions)))[0];\n    };\n    return findOne;\n};\n// src/ops/facet.ts\nvar logger11 = logger_default.get(\"client-api\", \"ops\", \"facet\");\nvar getFacetOperation = (api, apiOptions, utilities)=>{\n    const facet = async function(ik, facet2) {\n        let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated,\n            params\n        });\n        logger11.default(\"facet\", {\n            ik,\n            facet: facet2,\n            requestOptions\n        });\n        return api.httpGet(\"\".concat(utilities.getPath(ik), \"/\").concat(facet2), requestOptions);\n    };\n    return facet;\n};\n// src/ops/allFacet.ts\nvar logger12 = logger_default.get(\"client-api\", \"ops\", \"allFacet\");\nvar getAllFacetOperation = (api, apiOptions, utilities)=>{\n    const allFacet = async function(facet) {\n        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        const requestOptions = Object.assign({}, apiOptions.getOptions, {\n            isAuthenticated: apiOptions.writeAuthenticated,\n            params\n        });\n        logger12.default(\"allFacet\", {\n            facet,\n            locations,\n            requestOptions\n        });\n        utilities.verifyLocations(locations);\n        const loc = locations;\n        return api.httpGet(\"\".concat(utilities.getPath(loc), \"/\").concat(facet), requestOptions);\n    };\n    return allFacet;\n};\n// src/ops/index.ts\nvar getOperations = (api, apiOptions, utilities)=>{\n    return {\n        action: getActionOperation(api, apiOptions, utilities),\n        all: getAllOperation(api, apiOptions, utilities),\n        allAction: getAllActionOperation(api, apiOptions, utilities),\n        allFacet: getAllFacetOperation(api, apiOptions, utilities),\n        create: getCreateOperation(api, apiOptions, utilities),\n        facet: getFacetOperation(api, apiOptions, utilities),\n        findOne: getFindOneOperation(api, apiOptions, utilities),\n        find: getFindOperation(api, apiOptions, utilities),\n        get: getGetOperation(api, apiOptions, utilities),\n        one: getOneOperation(api, apiOptions, utilities),\n        remove: getRemoveOperation(api, apiOptions, utilities),\n        update: getUpdateOperation(api, apiOptions, utilities)\n    };\n};\n// src/Utilities.ts\n\n\nvar logger13 = logger_default.get(\"client-api\", \"Utility\");\nvar createUtilities = (pkType, pathNames)=>{\n    logger13.default(\"createUtilities\", {\n        pkType,\n        pathNames\n    });\n    const verifyLocations = (locations)=>{\n        if (locations && locations.length < pathNames.length - 1) {\n            throw new Error(\"Not enough locations for pathNames: locations:\" + locations.length + \" pathNames:\" + pathNames.length);\n        }\n        return true;\n    };\n    const processOne = async (apiCall)=>{\n        logger13.default(\"processOne\", {\n            apiCall\n        });\n        const response = await apiCall;\n        logger13.default(\"processOne response\", {\n            responseType: typeof response,\n            hasData: !!response\n        });\n        return convertDoc(response);\n    };\n    const processArray = async (api)=>{\n        logger13.default(\"processArray\", {\n            api\n        });\n        const response = await api;\n        logger13.default(\"processArray response\", {\n            responseType: typeof response,\n            isArray: Array.isArray(response),\n            length: Array.isArray(response) ? response.length : 0\n        });\n        if (response && Array.isArray(response)) {\n            return response.map((subjectChat)=>convertDoc(subjectChat));\n        } else {\n            logger13.error(\"Response was not an array\", {\n                response\n            });\n            throw new Error(\"Response was not an array\");\n        }\n    };\n    const convertDoc = (doc)=>{\n        logger13.default(\"convertDoc\", {\n            doc\n        });\n        if (doc && doc.events) {\n            const events = doc.events;\n            for(const key in events){\n                events[key] = deepmerge__WEBPACK_IMPORTED_MODULE_2__(events[key], {\n                    at: events[key].at ? new Date(events[key].at) : null\n                });\n            }\n            return doc;\n        } else {\n            return doc;\n        }\n    };\n    const getPath = (key)=>{\n        const localPathNames = [\n            ...pathNames\n        ];\n        logger13.default(\"getPath\", {\n            key,\n            pathNames: localPathNames\n        });\n        const keys = (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.generateKeyArray)(key);\n        let path = addPath(\"\", keys, localPathNames);\n        if (localPathNames.length === 1) {\n            path = \"\".concat(path, \"/\").concat(localPathNames[0]);\n        }\n        logger13.default(\"getPath created\", {\n            key,\n            path\n        });\n        return path;\n    };\n    const addPath = (base, keys, localPathNames)=>{\n        logger13.default(\"addPath\", {\n            base,\n            keys,\n            pathNames: localPathNames\n        });\n        if (keys.length < localPathNames.length - 1) {\n            logger13.error(\"addPath should never have keys with a length less than the length of pathNames - 1\", {\n                keys,\n                localPathNames\n            });\n            throw new Error(\"addPath should never have keys with a length less than the length of pathNames - 1: \" + keys.length + \" \" + localPathNames.length + \" \" + JSON.stringify(keys, localPathNames));\n        } else if (keys.length > localPathNames.length) {\n            logger13.error(\"addPath should never have keys with a length greater than the length of pathNames\", {\n                keys,\n                pathNames\n            });\n            throw new Error(\"addPath should never have keys with a length greater than the length of pathNames: \" + keys.length + \" \" + localPathNames.length + \" \" + JSON.stringify(keys, localPathNames));\n        }\n        if (keys.length === 0) {\n            logger13.default(\"addPath returning base\", {\n                base\n            });\n            return base;\n        } else {\n            let nextBase;\n            const key = keys.pop();\n            const pathName = localPathNames.pop();\n            if ((0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isPriKey)(key)) {\n                const PriKey2 = key;\n                nextBase = \"\".concat(base, \"/\").concat(pathName, \"/\").concat(PriKey2.pk);\n                logger13.default(\"Adding Path for PK\", {\n                    pathName,\n                    PriKey: PriKey2,\n                    nextBase\n                });\n            } else {\n                const LocKey2 = key;\n                nextBase = \"\".concat(base, \"/\").concat(pathName, \"/\").concat(LocKey2.lk);\n                logger13.default(\"Retrieving Collection for LK\", {\n                    pathName,\n                    LocKey: LocKey2\n                });\n            }\n            logger13.default(\"calling addPath recursively\", {\n                nextBase,\n                keys,\n                localPathNames\n            });\n            return addPath(nextBase, keys, localPathNames);\n        }\n    };\n    const validatePK = (item)=>{\n        return (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType);\n    };\n    return {\n        verifyLocations,\n        processOne,\n        convertDoc,\n        processArray,\n        getPath,\n        validatePK\n    };\n};\n// src/AItemAPI.ts\nvar logger14 = logger_default.get(\"AItemAPI\");\nvar finderToParams = (finder, finderParams)=>{\n    return {\n        finder,\n        finderParams: JSON.stringify(finderParams)\n    };\n};\nvar createAItemAPI = (api, pkType, pathNames, options)=>{\n    logger14.default(\"createAItemAPI\", {\n        pkType,\n        pathNames,\n        options\n    });\n    let mergedOptions;\n    const defaultOptions = {\n        readAuthenticated: true,\n        allAuthenticated: true,\n        writeAuthenticated: true,\n        getOptions: {},\n        postOptions: {},\n        putOptions: {},\n        deleteOptions: {}\n    };\n    if (options) {\n        mergedOptions = Object.assign({}, defaultOptions, options);\n    } else {\n        mergedOptions = defaultOptions;\n    }\n    const utilities = createUtilities(pkType, pathNames);\n    const operations = getOperations(api, mergedOptions, utilities);\n    return {\n        action: operations.action,\n        all: operations.all,\n        allAction: operations.allAction,\n        allFacet: operations.allFacet,\n        create: operations.create,\n        facet: operations.facet,\n        find: operations.find,\n        findOne: operations.findOne,\n        get: operations.get,\n        one: operations.one,\n        remove: operations.remove,\n        update: operations.update\n    };\n};\n// src/CItemAPI.ts\nvar logger15 = logger_default.get(\"CItemAPI\");\nvar createCItemApi = (api, type, pathNames, options)=>{\n    logger15.default(\"createCItemApi\", {\n        api,\n        type,\n        pathNames,\n        options\n    });\n    const aItemAPI = createAItemAPI(api, type, pathNames, options);\n    return {\n        action: aItemAPI.action,\n        all: aItemAPI.all,\n        allAction: aItemAPI.allAction,\n        allFacet: aItemAPI.allFacet,\n        one: aItemAPI.one,\n        get: aItemAPI.get,\n        create: aItemAPI.create,\n        remove: aItemAPI.remove,\n        update: aItemAPI.update,\n        facet: aItemAPI.facet,\n        find: aItemAPI.find,\n        findOne: aItemAPI.findOne\n    };\n};\n// src/PItemAPI.ts\nvar logger16 = logger_default.get(\"PItemAPI\");\nvar createPItemApi = (api, type, pathName, options)=>{\n    logger16.default(\"createPItemApi\", {\n        type,\n        pathName,\n        options\n    });\n    const aItemAPI = createAItemAPI(api, type, [\n        pathName\n    ], options);\n    const action = async function(ik, action2) {\n        let body = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return await aItemAPI.action(ik, action2, body);\n    };\n    const all = async function() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        return await aItemAPI.all(query, []);\n    };\n    const allAction = async function(action2) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return await aItemAPI.allAction(action2, body, []);\n    };\n    const allFacet = async function(facet2) {\n        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return await aItemAPI.allFacet(facet2, params);\n    };\n    const one = async function() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        return await aItemAPI.one(query, []);\n    };\n    const get = async (ik)=>await aItemAPI.get(ik);\n    const create = async (item)=>await aItemAPI.create(item, []);\n    const remove = async (ik)=>await aItemAPI.remove(ik);\n    const update = async (ik, item)=>await aItemAPI.update(ik, item);\n    const facet = async function(ik, facet2) {\n        let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return await aItemAPI.facet(ik, facet2, params);\n    };\n    const find = async function(finder) {\n        let finderParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return await aItemAPI.find(finder, finderParams);\n    };\n    const findOne = async function(finder) {\n        let finderParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return await aItemAPI.findOne(finder, finderParams);\n    };\n    return {\n        ...aItemAPI,\n        action,\n        all,\n        allAction,\n        allFacet,\n        one,\n        get,\n        create,\n        remove,\n        update,\n        facet,\n        find,\n        findOne\n    };\n};\n// src/Instance.ts\n\nvar logger17 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate, clientApi)=>{\n    logger17.debug(\"createInstance\", {\n        coordinate,\n        clientApi,\n        registry\n    });\n    const baseInstance = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_3__.createInstance)(registry, coordinate);\n    return {\n        ...baseInstance,\n        clientApi\n    };\n};\n// src/InstanceFactory.ts\nvar logger18 = logger_default.get(\"InstanceFactory\");\nvar createInstanceFactory = (clientApi)=>{\n    return (coordinate, context)=>{\n        logger18.debug(\"Creating client-api instance\", {\n            coordinate,\n            registry: context.registry,\n            clientApi\n        });\n        return createInstance(context.registry, coordinate, clientApi);\n    };\n};\n// src/Registry.ts\n\nvar logger19 = logger_default.get(\"Registry\");\nvar createRegistryFactory = ()=>{\n    return (type, registryHub)=>{\n        if (type !== \"client-api\") {\n            throw new Error(\"Client API registry factory can only create 'client-api' type registries, got: \".concat(type));\n        }\n        logger19.debug(\"Creating client-api registry\", {\n            type,\n            registryHub\n        });\n        const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_3__.createRegistry)(type, registryHub);\n        return baseRegistry;\n    };\n};\nvar createRegistry = (registryHub)=>{\n    const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_3__.createRegistry)(\"client-api\", registryHub);\n    return {\n        ...baseRegistry\n    };\n};\n// src/errors/index.ts\nvar ClientApiError = class extends Error {\n    toJSON() {\n        return {\n            name: this.name,\n            code: this.code,\n            message: this.message,\n            isRetryable: this.isRetryable,\n            timestamp: this.timestamp,\n            context: this.context,\n            stack: this.stack\n        };\n    }\n    constructor(message, context){\n        super(message);\n        this.name = this.constructor.name;\n        this.timestamp = /* @__PURE__ */ new Date();\n        this.context = context;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n};\nvar NetworkError = class extends ClientApiError {\n    constructor(message, context){\n        super(\"Network error: \".concat(message), context), this.code = \"NETWORK_ERROR\", this.isRetryable = true;\n    }\n};\nvar TimeoutError = class extends ClientApiError {\n    constructor(timeout, context){\n        super(\"Request timed out after \".concat(timeout, \"ms\"), context), this.code = \"TIMEOUT_ERROR\", this.isRetryable = true;\n    }\n};\nvar AuthenticationError = class extends ClientApiError {\n    constructor(message, context){\n        super(message || \"Authentication failed - invalid or expired credentials\", context), this.code = \"AUTHENTICATION_ERROR\", this.isRetryable = false;\n    }\n};\nvar AuthorizationError = class extends ClientApiError {\n    constructor(message, context){\n        super(message || \"Access forbidden - insufficient permissions\", context), this.code = \"AUTHORIZATION_ERROR\", this.isRetryable = false;\n    }\n};\nvar NotFoundError = class extends ClientApiError {\n    constructor(resource, identifier, context){\n        const message = identifier ? \"\".concat(resource, \" with identifier '\").concat(identifier, \"' not found\") : \"\".concat(resource, \" not found\");\n        super(message, context), this.code = \"NOT_FOUND_ERROR\", this.isRetryable = false;\n    }\n};\nvar ValidationError = class extends ClientApiError {\n    constructor(message, validationErrors, context){\n        super(\"Validation error: \".concat(message), context), this.code = \"VALIDATION_ERROR\", this.isRetryable = false;\n        this.validationErrors = validationErrors;\n    }\n};\nvar ConflictError = class extends ClientApiError {\n    constructor(message, context){\n        super(\"Conflict: \".concat(message), context), this.code = \"CONFLICT_ERROR\", this.isRetryable = false;\n    }\n};\nvar RateLimitError = class extends ClientApiError {\n    constructor(retryAfter, context){\n        const message = retryAfter ? \"Rate limit exceeded - retry after \".concat(retryAfter, \" seconds\") : \"Rate limit exceeded\";\n        super(message, context), this.code = \"RATE_LIMIT_ERROR\", this.isRetryable = true;\n        this.retryAfter = retryAfter;\n    }\n};\nvar ServerError = class extends ClientApiError {\n    constructor(statusCode, message, context){\n        super(message || \"Server error (\".concat(statusCode, \")\"), context), this.code = \"SERVER_ERROR\", this.isRetryable = true;\n        this.statusCode = statusCode;\n    }\n};\nvar PayloadTooLargeError = class extends ClientApiError {\n    constructor(maxSize, context){\n        const message = maxSize ? \"Request payload too large - maximum size is \".concat(maxSize) : \"Request payload too large\";\n        super(message, context), this.code = \"PAYLOAD_TOO_LARGE_ERROR\", this.isRetryable = false;\n    }\n};\nvar HttpError = class extends ClientApiError {\n    constructor(statusCode, statusText, message, context){\n        super(message || \"HTTP error \".concat(statusCode, \": \").concat(statusText), context), this.code = \"HTTP_ERROR\";\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n        this.isRetryable = statusCode >= 500;\n    }\n};\nvar ConfigurationError = class extends ClientApiError {\n    constructor(message, context){\n        super(\"Configuration error: \".concat(message), context), this.code = \"CONFIGURATION_ERROR\", this.isRetryable = false;\n    }\n};\nvar ParseError = class extends ClientApiError {\n    constructor(message, context){\n        super(\"Parse error: \".concat(message), context), this.code = \"PARSE_ERROR\", this.isRetryable = false;\n    }\n};\nfunction createHttpError(statusCode, statusText, responseBody, context) {\n    const errorContext = {\n        statusCode,\n        statusText,\n        responseBody,\n        ...context\n    };\n    switch(statusCode){\n        case 400:\n            if (responseBody === null || responseBody === void 0 ? void 0 : responseBody.validationErrors) {\n                return new ValidationError(responseBody.message || \"Request validation failed\", responseBody.validationErrors, errorContext);\n            }\n            return new ValidationError((responseBody === null || responseBody === void 0 ? void 0 : responseBody.message) || statusText, [], errorContext);\n        case 401:\n            return new AuthenticationError(responseBody === null || responseBody === void 0 ? void 0 : responseBody.message, errorContext);\n        case 403:\n            return new AuthorizationError(responseBody === null || responseBody === void 0 ? void 0 : responseBody.message, errorContext);\n        case 404:\n            return new NotFoundError((responseBody === null || responseBody === void 0 ? void 0 : responseBody.resource) || \"Resource\", responseBody === null || responseBody === void 0 ? void 0 : responseBody.identifier, errorContext);\n        case 409:\n            return new ConflictError((responseBody === null || responseBody === void 0 ? void 0 : responseBody.message) || statusText, errorContext);\n        case 413:\n            return new PayloadTooLargeError(responseBody === null || responseBody === void 0 ? void 0 : responseBody.maxSize, errorContext);\n        case 429:\n            {\n                var _context_headers;\n                let retryAfter;\n                if (responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter) {\n                    retryAfter = responseBody.retryAfter;\n                } else if (context === null || context === void 0 ? void 0 : (_context_headers = context.headers) === null || _context_headers === void 0 ? void 0 : _context_headers[\"retry-after\"]) {\n                    retryAfter = parseInt(context.headers[\"retry-after\"]);\n                }\n                return new RateLimitError(retryAfter, errorContext);\n            }\n        default:\n            if (statusCode >= 500) {\n                return new ServerError(statusCode, (responseBody === null || responseBody === void 0 ? void 0 : responseBody.message) || statusText, errorContext);\n            }\n            return new HttpError(statusCode, statusText, responseBody === null || responseBody === void 0 ? void 0 : responseBody.message, errorContext);\n    }\n}\nfunction createNetworkError(error, context) {\n    var _error_message, _error_message1;\n    const errorContext = {\n        originalError: error,\n        ...context\n    };\n    if (error.code === \"ECONNABORTED\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\"))) {\n        return new TimeoutError(error.timeout || 5e3, errorContext);\n    }\n    if (error.code === \"ECONNREFUSED\" || error.code === \"ENOTFOUND\" || error.code === \"ENETUNREACH\" || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"network\"))) {\n        return new NetworkError(error.message || \"Network connection failed\", errorContext);\n    }\n    return new NetworkError(error.message || \"Unknown network error\", errorContext);\n}\nfunction isRetryableError(error) {\n    return error instanceof ClientApiError && error.isRetryable;\n}\nfunction isClientApiError(error) {\n    return error instanceof ClientApiError;\n}\n// src/http/HttpWrapper.ts\nvar logger20 = {\n    debug: (message, context)=>console.debug(message, context),\n    info: (message, context)=>console.info(message, context),\n    warning: (message, context)=>console.warn(message, context),\n    error: (message, context)=>console.error(message, context)\n};\nvar DEFAULT_RETRY_CONFIG = {\n    maxRetries: 3,\n    initialDelayMs: 1e3,\n    maxDelayMs: 3e4,\n    backoffMultiplier: 2,\n    enableJitter: true,\n    shouldRetry: (error, attemptNumber)=>{\n        if (attemptNumber >= 3) return false;\n        if (error.isRetryable) return true;\n        return false;\n    },\n    onRetry: (error, attemptNumber, delay)=>{\n        logger20.warning(\"Retrying HTTP request (attempt \".concat(attemptNumber + 1, \") after \").concat(delay, \"ms\"), {\n            errorCode: error.code,\n            errorMessage: error.message,\n            delay,\n            attemptNumber\n        });\n    }\n};\nvar sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\nfunction calculateDelay(attemptNumber, config) {\n    const exponentialDelay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attemptNumber);\n    const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\n    if (!config.enableJitter) {\n        return cappedDelay;\n    }\n    const jitter = 0.5 + Math.random() * 0.5;\n    return Math.floor(cappedDelay * jitter);\n}\nvar HttpWrapper = class {\n    /**\n   * Execute HTTP operation with retry logic and error handling\n   */ async executeWithRetry(operation, operationName, context) {\n        let lastError = null;\n        const startTime = Date.now();\n        for(let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++){\n            try {\n                logger20.debug(\"Executing \".concat(operationName), {\n                    attempt: attempt + 1,\n                    maxRetries: this.retryConfig.maxRetries + 1,\n                    ...context\n                });\n                const result = await operation();\n                if (attempt > 0) {\n                    logger20.info(\"\".concat(operationName, \" succeeded after \").concat(attempt, \" retries\"), {\n                        totalAttempts: attempt + 1,\n                        duration: Date.now() - startTime,\n                        ...context\n                    });\n                }\n                return result;\n            } catch (error) {\n                lastError = this.convertToClientApiError(error, operationName, context);\n                if (attempt === this.retryConfig.maxRetries) {\n                    break;\n                }\n                if (!this.retryConfig.shouldRetry(lastError, attempt)) {\n                    logger20.debug(\"Not retrying \".concat(operationName, \" due to non-retryable error\"), {\n                        errorCode: lastError.code,\n                        errorMessage: lastError.message,\n                        attempt: attempt + 1,\n                        ...context\n                    });\n                    break;\n                }\n                let delay = calculateDelay(attempt, this.retryConfig);\n                if (lastError instanceof RateLimitError && lastError.retryAfter) {\n                    delay = Math.max(delay, lastError.retryAfter * 1e3);\n                }\n                this.retryConfig.onRetry(lastError, attempt, delay);\n                await sleep(delay);\n            }\n        }\n        logger20.error(\"\".concat(operationName, \" failed after \").concat(this.retryConfig.maxRetries + 1, \" attempts\"), {\n            errorCode: lastError === null || lastError === void 0 ? void 0 : lastError.code,\n            errorMessage: lastError === null || lastError === void 0 ? void 0 : lastError.message,\n            duration: Date.now() - startTime,\n            ...context\n        });\n        throw lastError;\n    }\n    /**\n   * Convert any error to a ClientApiError\n   */ convertToClientApiError(error, operationName, context) {\n        const errorContext = {\n            operation: operationName,\n            ...context\n        };\n        if (error instanceof ClientApiError) {\n            return error;\n        }\n        if (error.response) {\n            var _error_config;\n            const { status, statusText, data, headers } = error.response;\n            return createHttpError(status, statusText, data, {\n                ...errorContext,\n                headers,\n                url: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url\n            });\n        }\n        if (error.request) {\n            var _error_config1, _error_config2;\n            return createNetworkError(error, {\n                ...errorContext,\n                url: (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.url,\n                method: (_error_config2 = error.config) === null || _error_config2 === void 0 ? void 0 : _error_config2.method\n            });\n        }\n        return createNetworkError(error, errorContext);\n    }\n    /**\n   * Wrapper for HTTP GET operations\n   */ async get(url, options, context) {\n        return this.executeWithRetry(()=>this.api.httpGet(url, options), \"GET\", {\n            url,\n            ...context\n        });\n    }\n    /**\n   * Wrapper for HTTP POST operations\n   */ async post(url, data, options, context) {\n        return this.executeWithRetry(()=>this.api.httpPost(url, data, options), \"POST\", {\n            url,\n            hasData: !!data,\n            ...context\n        });\n    }\n    /**\n   * Wrapper for HTTP PUT operations\n   */ async put(url, data, options, context) {\n        return this.executeWithRetry(()=>this.api.httpPut(url, data, options), \"PUT\", {\n            url,\n            hasData: !!data,\n            ...context\n        });\n    }\n    /**\n   * Wrapper for HTTP DELETE operations\n   */ async delete(url, options, context) {\n        return this.executeWithRetry(()=>this.api.httpDelete(url, options), \"DELETE\", {\n            url,\n            ...context\n        });\n    }\n    /**\n   * Update retry configuration\n   */ updateRetryConfig(newConfig) {\n        Object.assign(this.retryConfig, newConfig);\n    }\n    /**\n   * Get current retry configuration\n   */ getRetryConfig() {\n        return {\n            ...this.retryConfig\n        };\n    }\n    constructor(api, retryConfig = {}){\n        this.api = api;\n        this.retryConfig = {\n            ...DEFAULT_RETRY_CONFIG,\n            ...retryConfig\n        };\n    }\n};\n //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS087O0FDTGE7QUFFcEIsSUFBTSxZQUFZLGdFQUFRLENBQVUsbUJBQW1CO0FBRXZELElBQU8saUJBQVE7O0FEUWYsSUFBTSxTQUFTLGVBQVUsSUFBSSxjQUFjLE9BQU8sS0FBSztBQUVoRCxJQUFNLGtCQUFrQixDQVEzQixLQUNBLFlBQ0E7SUFJRixNQUFNLE1BQU07WUFDVix5RUFBbUIsQ0FBQyxHQUNwQiw2RUFBa0QsQ0FBQztRQUVuRCxVQUFVLGdCQUFnQixTQUFTO1FBQ25DLE1BQU0sTUFBNEM7UUFFbEQsTUFBTSxTQUFzQiwwREFBYSxDQUFDLEtBQUs7UUFDL0MsTUFBTSxpQkFBaUIsT0FBTyxPQUFPLENBQUMsR0FBRyxXQUFXLFlBQVk7WUFBRSxpQkFBaUIsV0FBVztZQUFrQjtRQUFPLENBQUM7UUFFeEgsT0FBTyxRQUFRLE9BQU87WUFBRTtZQUFPO1lBQVc7UUFBZSxDQUFDO1FBRTFELE9BQU8sVUFBVSxXQUFXLE1BQU0sVUFBVSxhQUMxQyxJQUFJLFFBQ0YsVUFBVSxRQUFRLEdBQUcsR0FDckI7SUFFTjtJQUVBLE9BQU87QUFDVDs7QUVyQ0EsSUFBTUEsVUFBUyxlQUFVLElBQUksY0FBYyxPQUFPLFFBQVE7QUFFbkQsSUFBTSxxQkFBcUIsQ0FROUIsS0FDQSxZQUNBO0lBSUYsTUFBTSxTQUFTLGVBQ2IsSUFDQUM7WUFDQSx3RUFBWSxDQUFDO1FBRWIsTUFBTSxpQkFBaUIsT0FBTyxPQUFPLENBQUMsR0FBRyxXQUFXLGFBQWE7WUFBRSxpQkFBaUIsV0FBVztRQUFtQixDQUFDO1FBQ25IRCxRQUFPLFFBQVEsVUFBVTtZQUFFO1lBQUksUUFBQUM7WUFBUTtZQUFNO1FBQWUsQ0FBQztRQUU3RCxPQUFPLFVBQVUsV0FDZixNQUFNLFVBQVUsV0FDZCxJQUFJLFNBQ0Ys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SUFDSixLQUNBLE1BQ0EsU0FDQSxTQUNZO1FBQ1osT0FBTyxLQUFLLGlCQUNWLElBQU0sS0FBSyxJQUFJLFFBQVEsS0FBSyxNQUFNLE9BQU8sR0FDekMsT0FDQTtZQUFFO1lBQUssU0FBUyxDQUFDLENBQUM7WUFBTSxHQUFHO1FBQVE7SUFFdkM7SUFBQTs7R0FBQSxHQUtBLE1BQU0sT0FDSixLQUNBLFNBQ0EsU0FDWTtRQUNaLE9BQU8sS0FBSyxpQkFDVixJQUFNLEtBQUssSUFBSSxXQUFXLEtBQUssT0FBTyxHQUN0QyxVQUNBO1lBQUU7WUFBSyxHQUFHO1FBQVE7SUFFdEI7SUFBQTs7R0FBQSxHQUtBLGtCQUFrQixXQUF1QztRQUN2RCxPQUFPLE9BQU8sS0FBSyxhQUFhLFNBQVM7SUFDM0M7SUFBQTs7R0FBQSxHQUtBLGlCQUF3QztRQUN0QyxPQUFPO1lBQUUsR0FBRyxLQUFLO1FBQVk7SUFDL0I7SUEvTEEsWUFBWSxLQUFjLGNBQTJCLENBQUMsRUFBRztRQUN2RCxLQUFLLE1BQU07UUFDWCxLQUFLLGNBQWM7WUFBRSxHQUFHO1lBQXNCLEdBQUc7UUFBWTtJQUMvRDtBQTZMRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2FsbC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9hY3Rpb24udHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvYWxsQWN0aW9uLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL29uZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9lcnJvckhhbmRsaW5nLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2NyZWF0ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy91cGRhdGUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvZ2V0LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL3JlbW92ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL29wcy9maW5kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvb3BzL2ZpbmRPbmUudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvZmFjZXQudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvYWxsRmFjZXQudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9vcHMvaW5kZXgudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9VdGlsaXRpZXMudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9BSXRlbUFQSS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0NJdGVtQVBJLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvUEl0ZW1BUEkudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9JbnN0YW5jZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0luc3RhbmNlRmFjdG9yeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL1JlZ2lzdHJ5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXJyb3JzL2luZGV4LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvaHR0cC9IdHRwV3JhcHBlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIExvY0tleUFycmF5LFxuICBxdWVyeVRvUGFyYW1zLFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGksIFF1ZXJ5UGFyYW1zIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdhbGwnKTtcblxuZXhwb3J0IGNvbnN0IGdldEFsbE9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IGFsbCA9IGFzeW5jIChcbiAgICBxdWVyeTogSXRlbVF1ZXJ5ID0ge30gYXMgSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICB1dGlsaXRpZXMudmVyaWZ5TG9jYXRpb25zKGxvY2F0aW9ucyk7XG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBwYXJhbXM6IFF1ZXJ5UGFyYW1zID0gcXVlcnlUb1BhcmFtcyhxdWVyeSk7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLmFsbEF1dGhlbnRpY2F0ZWQsIHBhcmFtcyB9KTtcblxuICAgIGxvZ2dlci5kZWZhdWx0KCdhbGwnLCB7IHF1ZXJ5LCBsb2NhdGlvbnMsIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIHV0aWxpdGllcy52YWxpZGF0ZVBLKGF3YWl0IHV0aWxpdGllcy5wcm9jZXNzQXJyYXkoXG4gICAgICBhcGkuaHR0cEdldDxWW10+KFxuICAgICAgICB1dGlsaXRpZXMuZ2V0UGF0aChsb2MpLFxuICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICkpKSBhcyBWW107XG4gIH1cblxuICByZXR1cm4gYWxsO1xufVxuXG4iLCJpbXBvcnQgTG9nZ2luZyBmcm9tICdAZmplbGwvbG9nZ2luZyc7XG5cbmNvbnN0IExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKCdAZmplbGwvY2xpZW50LWFwaScpO1xuXG5leHBvcnQgZGVmYXVsdCBMaWJMb2dnZXI7XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdhY3Rpb24nKTtcblxuZXhwb3J0IGNvbnN0IGdldEFjdGlvbk9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IGFjdGlvbiA9IGFzeW5jIChcbiAgICBpazogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keTogYW55ID0ge30sXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5wb3N0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdhY3Rpb24nLCB7IGlrLCBhY3Rpb24sIGJvZHksIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIHV0aWxpdGllcy52YWxpZGF0ZVBLKFxuICAgICAgYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NPbmUoXG4gICAgICAgIGFwaS5odHRwUG9zdDxWPihcbiAgICAgICAgICBgJHt1dGlsaXRpZXMuZ2V0UGF0aChpayl9LyR7YWN0aW9ufWAsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgKVxuICAgICAgKSkgYXMgVjtcblxuICB9O1xuXG4gIHJldHVybiBhY3Rpb247XG59XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2FsbEFjdGlvbicpO1xuXG5leHBvcnQgY29uc3QgZ2V0QWxsQWN0aW9uT3BlcmF0aW9uID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICBhcGk6IEh0dHBBcGksXG4gICAgYXBpT3B0aW9uczogQ2xpZW50QXBpT3B0aW9ucyxcbiAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG5cbiAgKSA9PiB7XG5cbiAgY29uc3QgYWxsQWN0aW9uID0gYXN5bmMgKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFwaU9wdGlvbnMucG9zdE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLndyaXRlQXV0aGVudGljYXRlZCB9KTtcbiAgICBsb2dnZXIuZGVmYXVsdCgnYWxsQWN0aW9uJywgeyBhY3Rpb24sIGJvZHksIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZXNwb25kIHRvIGVpdGhlciBhIHNpbmdsZSBvYmplY3QsIG9yIG11bHRpcGxlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gICAgcmV0dXJuIHV0aWxpdGllcy52YWxpZGF0ZVBLKFxuICAgICAgYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NBcnJheShcbiAgICAgICAgYXBpLmh0dHBQb3N0PFZbXT4oXG4gICAgICAgICAgYCR7dXRpbGl0aWVzLmdldFBhdGgobG9jKX0vJHthY3Rpb259YCxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgICApXG4gICAgICApKSBhcyBWW107XG4gIH07XG5cbiAgcmV0dXJuIGFsbEFjdGlvbjtcbn1cbiIsImltcG9ydCB7XG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgTG9jS2V5QXJyYXksXG4gIFF1ZXJ5UGFyYW1zLFxuICBxdWVyeVRvUGFyYW1zXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcblxuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuLi9DbGllbnRBcGlPcHRpb25zXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7IFV0aWxpdGllcyB9IGZyb20gXCIuLi9VdGlsaXRpZXNcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnY2xpZW50LWFwaScsICdvcHMnLCAnb25lJyk7XG5cbmV4cG9ydCBjb25zdCBnZXRPbmVPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG5cbiAgY29uc3Qgb25lID0gYXN5bmMgKFxuICAgIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSBhcyBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBwYXJhbXM6IFF1ZXJ5UGFyYW1zID0gcXVlcnlUb1BhcmFtcyhxdWVyeSk7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLnJlYWRBdXRoZW50aWNhdGVkLCBwYXJhbXMgfSk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ29uZScsIHsgcXVlcnksIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG5cbiAgICBsZXQgaXRlbTogViB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uc3QgaXRlbXMgPSB1dGlsaXRpZXMudmFsaWRhdGVQSyhhd2FpdCB1dGlsaXRpZXMucHJvY2Vzc0FycmF5KFxuICAgICAgYXBpLmh0dHBHZXQ8VltdPihcbiAgICAgICAgdXRpbGl0aWVzLmdldFBhdGgobG9jKSxcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMsXG4gICAgICApKSkgYXMgVltdO1xuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbSBhcyBWO1xuICB9XG5cbiAgcmV0dXJuIG9uZTtcbn1cbiIsIi8qKlxuICogU2hhcmVkIGVycm9yIGhhbmRsaW5nIHV0aWxpdGllcyBmb3IgYWxsIEhUVFAgb3BlcmF0aW9uc1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBlcnJvciBzaG91bGQgYmUgcmV0cmllZCBiYXNlZCBvbiBlcnJvciB0eXBlIGFuZCBzdGF0dXMgY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkUmV0cnlFcnJvcihlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gIC8vIFJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzIGFuZCB0aW1lb3V0c1xuICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVGVVNFRCcgfHxcbiAgICBlcnJvci5jb2RlID09PSAnRU5PVEZPVU5EJyB8fFxuICAgIGVycm9yLmNvZGUgPT09ICdFTkVUVU5SRUFDSCcgfHxcbiAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndGltZW91dCcpIHx8XG4gICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gUmV0cnkgb24gSFRUUCA1eHggZXJyb3JzIGFuZCA0MjkgKHJhdGUgbGltaXRpbmcpXG4gIGlmIChlcnJvci5zdGF0dXMgPj0gNTAwIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBEb24ndCByZXRyeSBvbiA0eHggY2xpZW50IGVycm9ycyAoZXhjZXB0IDQyOSlcbiAgaWYgKGVycm9yLnN0YXR1cyA+PSA0MDAgJiYgZXJyb3Iuc3RhdHVzIDwgNTAwICYmIGVycm9yLnN0YXR1cyAhPT0gNDI5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byByZXRyeWluZyB1bmtub3duIGVycm9yc1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHJldHJ5IGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZiBhbmQgaml0dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQ6IG51bWJlciwgY29uZmlnOiBhbnkpOiBudW1iZXIge1xuICBjb25zdCBleHBvbmVudGlhbERlbGF5ID0gKGNvbmZpZy5pbml0aWFsRGVsYXlNcyB8fCAxMDAwKSAqIE1hdGgucG93KGNvbmZpZy5iYWNrb2ZmTXVsdGlwbGllciB8fCAyLCBhdHRlbXB0KTtcbiAgY29uc3QgY2FwcGVkRGVsYXkgPSBNYXRoLm1pbihleHBvbmVudGlhbERlbGF5LCBjb25maWcubWF4RGVsYXlNcyB8fCAzMDAwMCk7XG5cbiAgLy8gQWRkIGppdHRlcjogcmFuZG9tIHZhbHVlIGJldHdlZW4gNTAlIGFuZCAxMDAlIG9mIGNhbGN1bGF0ZWQgZGVsYXlcbiAgY29uc3Qgaml0dGVyID0gMC41ICsgKE1hdGgucmFuZG9tKCkgKiAwLjUpO1xuICByZXR1cm4gTWF0aC5mbG9vcihjYXBwZWREZWxheSAqIGppdHRlcik7XG59XG5cbi8qKlxuICogRW5oYW5jZXMgZXJyb3Igd2l0aCBhZGRpdGlvbmFsIGNvbnRleHQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvcjogYW55LCBjb250ZXh0OiBhbnkpOiBhbnkge1xuICBpZiAoIWVycm9yKSByZXR1cm4gbmV3IEVycm9yKCdVbmtub3duIGVycm9yIG9jY3VycmVkJyk7XG5cbiAgLy8gSWYgaXQncyBhbHJlYWR5IGVuaGFuY2VkLCByZXR1cm4gYXMtaXNcbiAgaWYgKGVycm9yLmNvbnRleHQpIHJldHVybiBlcnJvcjtcblxuICAvLyBBZGQgY29udGV4dCB0byB0aGUgZXJyb3JcbiAgY29uc3QgZW5oYW5jZWRFcnJvciA9IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdIVFRQIG9wZXJhdGlvbiBmYWlsZWQnKTtcbiAgT2JqZWN0LmFzc2lnbihlbmhhbmNlZEVycm9yLCB7XG4gICAgY29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMgfHwgJ1VOS05PV05fRVJST1InLFxuICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgIGNvbnRleHQsXG4gICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgfSk7XG5cbiAgcmV0dXJuIGVuaGFuY2VkRXJyb3I7XG59XG5cbi8qKlxuICogR2V0cyBkZWZhdWx0IHJldHJ5IGNvbmZpZ3VyYXRpb24gbWVyZ2VkIHdpdGggcHJvdmlkZWQgb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcoYXBpT3B0aW9uczogYW55KTogYW55IHtcbiAgcmV0dXJuIHtcbiAgICBtYXhSZXRyaWVzOiAzLFxuICAgIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICAgIG1heERlbGF5TXM6IDMwMDAwLFxuICAgIGJhY2tvZmZNdWx0aXBsaWVyOiAyLFxuICAgIC4uLmFwaU9wdGlvbnMucmV0cnlDb25maWdcbiAgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGN1c3RvbSBlcnJvciBoYW5kbGVyIGV4ZWN1dGlvbiB3aXRoIGVycm9yIHByb3RlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVFcnJvckhhbmRsZXIoXG4gIGVycm9ySGFuZGxlcjogKChlcnJvcjogYW55LCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gdm9pZCkgfCB1bmRlZmluZWQsXG4gIGVycm9yOiBhbnksXG4gIGNvbnRleHQ6IGFueSxcbiAgbG9nZ2VyOiBhbnlcbik6IHZvaWQge1xuICBpZiAoIWVycm9ySGFuZGxlcikgcmV0dXJuO1xuXG4gIHRyeSB7XG4gICAgZXJyb3JIYW5kbGVyKGVycm9yLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoaGFuZGxlckVycm9yOiBhbnkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0N1c3RvbSBlcnJvciBoYW5kbGVyIGZhaWxlZCcsIHtcbiAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBoYW5kbGVyRXJyb3I6IGhhbmRsZXJFcnJvcj8ubWVzc2FnZSB8fCBTdHJpbmcoaGFuZGxlckVycm9yKVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ29tbW9uIHJldHJ5IGxvb3AgbG9naWMgZm9yIEhUVFAgb3BlcmF0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVdpdGhSZXRyeTxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBvcGVyYXRpb25OYW1lOiBzdHJpbmcsXG4gIG9wZXJhdGlvbkNvbnRleHQ6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGFwaU9wdGlvbnM6IGFueSxcbiAgbG9nZ2VyOiBhbnksXG4gIHNwZWNpYWxFcnJvckhhbmRsaW5nPzogKGVycm9yOiBhbnkpID0+IFQgfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhhcGlPcHRpb25zKTtcbiAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8PSByZXRyeUNvbmZpZy5tYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBFeGVjdXRpbmcgJHtvcGVyYXRpb25OYW1lfSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfSlgLCBvcGVyYXRpb25Db250ZXh0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKCk7XG5cbiAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICBsb2dnZXIuaW5mbyhgJHtvcGVyYXRpb25OYW1lfSBvcGVyYXRpb24gc3VjY2VlZGVkIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllc2AsIHtcbiAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgIHRvdGFsQXR0ZW1wdHM6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuXG4gICAgICAvLyBIYW5kbGUgc3BlY2lhbCBlcnJvciBjYXNlcyAobGlrZSA0MDQgcmV0dXJuaW5nIG51bGwpXG4gICAgICBpZiAoc3BlY2lhbEVycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lhbFJlc3VsdCA9IHNwZWNpYWxFcnJvckhhbmRsaW5nKGVycm9yKTtcbiAgICAgICAgaWYgKHNwZWNpYWxSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzcGVjaWFsUmVzdWx0IGFzIFQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gdGhlIGxhc3QgYXR0ZW1wdFxuICAgICAgaWYgKGF0dGVtcHQgPT09IHJldHJ5Q29uZmlnLm1heFJldHJpZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCByZXRyeSB0aGlzIGVycm9yXG4gICAgICBjb25zdCBpc1JldHJ5YWJsZSA9IHNob3VsZFJldHJ5RXJyb3IoZXJyb3IpO1xuICAgICAgaWYgKCFpc1JldHJ5YWJsZSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYE5vdCByZXRyeWluZyAke29wZXJhdGlvbk5hbWV9IG9wZXJhdGlvbiBkdWUgdG8gbm9uLXJldHJ5YWJsZSBlcnJvcmAsIHtcbiAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBlcnJvckNvZGU6IGVycm9yLmNvZGUgfHwgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQgKyAxXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIHJldHJ5Q29uZmlnKTtcblxuICAgICAgbG9nZ2VyLndhcm5pbmcoYFJldHJ5aW5nICR7b3BlcmF0aW9uTmFtZX0gb3BlcmF0aW9uIChhdHRlbXB0ICR7YXR0ZW1wdCArIDJ9KSBhZnRlciAke2RlbGF5fW1zYCwge1xuICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgIGRlbGF5LFxuICAgICAgICBhdHRlbXB0TnVtYmVyOiBhdHRlbXB0ICsgMVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgZmluYWwgZXJyb3JcbiAgY29uc3QgZmluYWxFcnJvciA9IGVuaGFuY2VFcnJvcihsYXN0RXJyb3IsIG9wZXJhdGlvbkNvbnRleHQpO1xuXG4gIC8vIEV4ZWN1dGUgY3VzdG9tIGVycm9yIGhhbmRsZXIgaWYgcHJvdmlkZWRcbiAgZXhlY3V0ZUVycm9ySGFuZGxlcihhcGlPcHRpb25zLmVycm9ySGFuZGxlciwgZmluYWxFcnJvciwgb3BlcmF0aW9uQ29udGV4dCwgbG9nZ2VyKTtcblxuICBsb2dnZXIuZXJyb3IoYCR7b3BlcmF0aW9uTmFtZX0gb3BlcmF0aW9uIGZhaWxlZCBhZnRlciAke3JldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxfSBhdHRlbXB0c2AsIHtcbiAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgIGVycm9yTWVzc2FnZTogZmluYWxFcnJvci5tZXNzYWdlLFxuICAgIGVycm9yQ29kZTogZmluYWxFcnJvci5jb2RlIHx8IGZpbmFsRXJyb3Iuc3RhdHVzLFxuICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgIHRvdGFsQXR0ZW1wdHM6IHJldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxXG4gIH0pO1xuXG4gIHRocm93IGZpbmFsRXJyb3I7XG59XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVSZXRyeURlbGF5LCBlbmhhbmNlRXJyb3IsIHNob3VsZFJldHJ5RXJyb3IgfSBmcm9tIFwiLi9lcnJvckhhbmRsaW5nXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2NyZWF0ZScpO1xuXG5leHBvcnQgY29uc3QgZ2V0Q3JlYXRlT3BlcmF0aW9uID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICBhcGk6IEh0dHBBcGksXG4gICAgYXBpT3B0aW9uczogQ2xpZW50QXBpT3B0aW9ucyxcbiAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG5cbiAgKSA9PiB7XG5cbiAgY29uc3QgY3JlYXRlID0gYXN5bmMgKFxuICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PixcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5wb3N0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdjcmVhdGUnLCB7IGl0ZW0sIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG4gICAgY29uc3Qgb3BlcmF0aW9uQ29udGV4dCA9IHtcbiAgICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScsXG4gICAgICBwYXRoOiB1dGlsaXRpZXMuZ2V0UGF0aChsb2MpLFxuICAgICAgaXRlbVR5cGU6IHR5cGVvZiBpdGVtLFxuICAgICAgaGFzTG9jYXRpb25zOiBsb2NhdGlvbnMubGVuZ3RoID4gMFxuICAgIH07XG5cbiAgICAvLyBSZXRyeSBjb25maWd1cmF0aW9uIGZyb20gb3B0aW9ucyBvciBkZWZhdWx0c1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0ge1xuICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICAgICAgbWF4RGVsYXlNczogMzAwMDAsXG4gICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcbiAgICAgIC4uLmFwaU9wdGlvbnMucmV0cnlDb25maWdcbiAgICB9O1xuXG4gICAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gcmV0cnlDb25maWcubWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYENyZWF0aW5nIGl0ZW0gKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0pYCwgb3BlcmF0aW9uQ29udGV4dCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NPbmUoYXBpLmh0dHBQb3N0PFY+KFxuICAgICAgICAgIHV0aWxpdGllcy5nZXRQYXRoKGxvYyksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgKSk7XG5cbiAgICAgICAgY29uc3QgY3JlYXRlZDogViA9IHV0aWxpdGllcy52YWxpZGF0ZVBLKHJlc3VsdCkgYXMgVjtcblxuICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgQ3JlYXRlIG9wZXJhdGlvbiBzdWNjZWVkZWQgYWZ0ZXIgJHthdHRlbXB0fSByZXRyaWVzYCwge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIHRvdGFsQXR0ZW1wdHM6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcblxuICAgICAgICAvLyBEb24ndCByZXRyeSBvbiB0aGUgbGFzdCBhdHRlbXB0XG4gICAgICAgIGlmIChhdHRlbXB0ID09PSByZXRyeUNvbmZpZy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgZXJyb3IgaXMgcmV0cnlhYmxlXG4gICAgICAgIGNvbnN0IGlzUmV0cnlhYmxlID0gc2hvdWxkUmV0cnlFcnJvcihlcnJvcik7XG4gICAgICAgIGlmICghaXNSZXRyeWFibGUpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vdCByZXRyeWluZyBjcmVhdGUgb3BlcmF0aW9uIGR1ZSB0byBub24tcmV0cnlhYmxlIGVycm9yJywge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0ICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICBjb25zdCBkZWxheSA9IGNhbGN1bGF0ZVJldHJ5RGVsYXkoYXR0ZW1wdCwgcmV0cnlDb25maWcpO1xuXG4gICAgICAgIGxvZ2dlci53YXJuaW5nKGBSZXRyeWluZyBjcmVhdGUgb3BlcmF0aW9uIChhdHRlbXB0ICR7YXR0ZW1wdCArIDJ9KSBhZnRlciAke2RlbGF5fW1zYCwge1xuICAgICAgICAgIC4uLm9wZXJhdGlvbkNvbnRleHQsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgYXR0ZW1wdE51bWJlcjogYXR0ZW1wdCArIDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGZpbmFsIGVycm9yXG4gICAgY29uc3QgZmluYWxFcnJvciA9IGVuaGFuY2VFcnJvcihsYXN0RXJyb3IsIG9wZXJhdGlvbkNvbnRleHQpO1xuXG4gICAgLy8gQ2FsbCBjdXN0b20gZXJyb3IgaGFuZGxlciBpZiBwcm92aWRlZFxuICAgIGlmIChhcGlPcHRpb25zLmVycm9ySGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXBpT3B0aW9ucy5lcnJvckhhbmRsZXIoZmluYWxFcnJvciwgb3BlcmF0aW9uQ29udGV4dCk7XG4gICAgICB9IGNhdGNoIChoYW5kbGVyRXJyb3I6IGFueSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0N1c3RvbSBlcnJvciBoYW5kbGVyIGZhaWxlZCcsIHtcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBmaW5hbEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgaGFuZGxlckVycm9yOiBoYW5kbGVyRXJyb3I/Lm1lc3NhZ2UgfHwgU3RyaW5nKGhhbmRsZXJFcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmVycm9yKGBDcmVhdGUgb3BlcmF0aW9uIGZhaWxlZCBhZnRlciAke3JldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxfSBhdHRlbXB0c2AsIHtcbiAgICAgIC4uLm9wZXJhdGlvbkNvbnRleHQsXG4gICAgICBlcnJvck1lc3NhZ2U6IGZpbmFsRXJyb3IubWVzc2FnZSxcbiAgICAgIGVycm9yQ29kZTogZmluYWxFcnJvci5jb2RlIHx8IGZpbmFsRXJyb3Iuc3RhdHVzLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICB0b3RhbEF0dGVtcHRzOiByZXRyeUNvbmZpZy5tYXhSZXRyaWVzICsgMVxuICAgIH0pO1xuXG4gICAgdGhyb3cgZmluYWxFcnJvcjtcbiAgfTtcblxuICByZXR1cm4gY3JlYXRlO1xufVxuIiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBJdGVtLFxuICBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICd1cGRhdGUnKTtcblxuZXhwb3J0IGNvbnN0IGdldFVwZGF0ZU9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IHVwZGF0ZSA9IGFzeW5jIChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFwaU9wdGlvbnMucHV0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCd1cGRhdGUnLCB7IGlrLCBpdGVtLCByZXF1ZXN0T3B0aW9ucyB9KTtcblxuICAgIHJldHVybiB1dGlsaXRpZXMudmFsaWRhdGVQSyhhd2FpdCB1dGlsaXRpZXMucHJvY2Vzc09uZShcbiAgICAgIGFwaS5odHRwUHV0PFY+KFxuICAgICAgICB1dGlsaXRpZXMuZ2V0UGF0aChpayksXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgKSkpIGFzIFY7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlO1xufVxuIiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICBJdGVtLFxuICBQcmlLZXksXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcblxuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuLi9DbGllbnRBcGlPcHRpb25zXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7IFV0aWxpdGllcyB9IGZyb20gXCIuLi9VdGlsaXRpZXNcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZVJldHJ5RGVsYXksIGVuaGFuY2VFcnJvciwgc2hvdWxkUmV0cnlFcnJvciB9IGZyb20gXCIuL2Vycm9ySGFuZGxpbmdcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnY2xpZW50LWFwaScsICdvcHMnLCAnZ2V0Jyk7XG5cbmV4cG9ydCBjb25zdCBnZXRHZXRPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApID0+IHtcblxuICBjb25zdCBnZXQgPSBhc3luYyAoXG4gICAgaWs6IFByaUtleTxTPiB8IENvbUtleTxTLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LFxuICApOiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLnJlYWRBdXRoZW50aWNhdGVkIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdnZXQnLCB7IGlrLCByZXF1ZXN0T3B0aW9ucyB9KTtcblxuICAgIGNvbnN0IG9wZXJhdGlvbkNvbnRleHQgPSB7XG4gICAgICBvcGVyYXRpb246ICdnZXQnLFxuICAgICAgcGF0aDogdXRpbGl0aWVzLmdldFBhdGgoaWspLFxuICAgICAga2V5VHlwZTogdHlwZW9mIGlrXG4gICAgfTtcblxuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0ge1xuICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICAgICAgbWF4RGVsYXlNczogMzAwMDAsXG4gICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcbiAgICAgIC4uLmFwaU9wdGlvbnMucmV0cnlDb25maWdcbiAgICB9O1xuXG4gICAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gcmV0cnlDb25maWcubWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYEdldHRpbmcgaXRlbSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfSlgLCBvcGVyYXRpb25Db250ZXh0KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1dGlsaXRpZXMucHJvY2Vzc09uZShcbiAgICAgICAgICBhcGkuaHR0cEdldDxWPihcbiAgICAgICAgICAgIHV0aWxpdGllcy5nZXRQYXRoKGlrKSxcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBpdGVtID0gdXRpbGl0aWVzLnZhbGlkYXRlUEsocmVzdWx0KSBhcyBWO1xuXG4gICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBHZXQgb3BlcmF0aW9uIHN1Y2NlZWRlZCBhZnRlciAke2F0dGVtcHR9IHJldHJpZXNgLCB7XG4gICAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgICAgdG90YWxBdHRlbXB0czogYXR0ZW1wdCArIDEsXG4gICAgICAgICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuXG4gICAgICAgIC8vIEhhbmRsZSA0MDQgZXJyb3JzIHNwZWNpYWxseSAtIHJldHVybiBudWxsIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdJdGVtIG5vdCBmb3VuZCAoNDA0KScsIG9wZXJhdGlvbkNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dGVtcHQgPT09IHJldHJ5Q29uZmlnLm1heFJldHJpZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzUmV0cnlhYmxlID0gc2hvdWxkUmV0cnlFcnJvcihlcnJvcik7XG4gICAgICAgIGlmICghaXNSZXRyeWFibGUpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vdCByZXRyeWluZyBnZXQgb3BlcmF0aW9uIGR1ZSB0byBub24tcmV0cnlhYmxlIGVycm9yJywge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0ICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIHJldHJ5Q29uZmlnKTtcblxuICAgICAgICBsb2dnZXIud2FybmluZyhgUmV0cnlpbmcgZ2V0IG9wZXJhdGlvbiAoYXR0ZW1wdCAke2F0dGVtcHQgKyAyfSkgYWZ0ZXIgJHtkZWxheX1tc2AsIHtcbiAgICAgICAgICAuLi5vcGVyYXRpb25Db250ZXh0LFxuICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBlcnJvckNvZGU6IGVycm9yLmNvZGUgfHwgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgIGF0dGVtcHROdW1iZXI6IGF0dGVtcHQgKyAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbmFsRXJyb3IgPSBlbmhhbmNlRXJyb3IobGFzdEVycm9yLCBvcGVyYXRpb25Db250ZXh0KTtcblxuICAgIGlmIChhcGlPcHRpb25zLmVycm9ySGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXBpT3B0aW9ucy5lcnJvckhhbmRsZXIoZmluYWxFcnJvciwgb3BlcmF0aW9uQ29udGV4dCk7XG4gICAgICB9IGNhdGNoIChoYW5kbGVyRXJyb3I6IGFueSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0N1c3RvbSBlcnJvciBoYW5kbGVyIGZhaWxlZCcsIHtcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBmaW5hbEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgaGFuZGxlckVycm9yOiBoYW5kbGVyRXJyb3I/Lm1lc3NhZ2UgfHwgU3RyaW5nKGhhbmRsZXJFcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmVycm9yKGBHZXQgb3BlcmF0aW9uIGZhaWxlZCBhZnRlciAke3JldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxfSBhdHRlbXB0c2AsIHtcbiAgICAgIC4uLm9wZXJhdGlvbkNvbnRleHQsXG4gICAgICBlcnJvck1lc3NhZ2U6IGZpbmFsRXJyb3IubWVzc2FnZSxcbiAgICAgIGVycm9yQ29kZTogZmluYWxFcnJvci5jb2RlIHx8IGZpbmFsRXJyb3Iuc3RhdHVzLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICB0b3RhbEF0dGVtcHRzOiByZXRyeUNvbmZpZy5tYXhSZXRyaWVzICsgMVxuICAgIH0pO1xuXG4gICAgdGhyb3cgZmluYWxFcnJvcjtcbiAgfVxuXG4gIHJldHVybiBnZXQ7XG59XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdyZW1vdmUnKTtcblxuZXhwb3J0IGNvbnN0IGdldFJlbW92ZU9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IHJlbW92ZSA9IGFzeW5jIChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5kZWxldGVPcHRpb25zLCB7IGlzQXV0aGVudGljYXRlZDogYXBpT3B0aW9ucy53cml0ZUF1dGhlbnRpY2F0ZWQgfSk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3JlbW92ZScsIHsgaWssIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIGFwaS5odHRwRGVsZXRlPGJvb2xlYW4+KHV0aWxpdGllcy5nZXRQYXRoKGlrKSwgcmVxdWVzdE9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlbW92ZTtcbn1cbiIsImltcG9ydCB7XG4gIEl0ZW0sXG4gIExvY0tleUFycmF5LFxuICBRdWVyeVBhcmFtc1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IGZpbmRlclRvUGFyYW1zIH0gZnJvbSBcIi4uL0FJdGVtQVBJXCI7XG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdmaW5kJyk7XG5cbmV4cG9ydCBjb25zdCBnZXRGaW5kT3BlcmF0aW9uID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICBhcGk6IEh0dHBBcGksXG4gICAgYXBpT3B0aW9uczogQ2xpZW50QXBpT3B0aW9ucyxcbiAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG5cbiAgKSA9PiB7XG5cbiAgY29uc3QgZmluZCA9IGFzeW5jIChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICAgIGxvY2F0aW9uczogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdID0gW11cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICB1dGlsaXRpZXMudmVyaWZ5TG9jYXRpb25zKGxvY2F0aW9ucyk7XG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBtZXJnZWRQYXJhbXM6IFF1ZXJ5UGFyYW1zID0gZmluZGVyVG9QYXJhbXMoZmluZGVyLCBmaW5kZXJQYXJhbXMpO1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXBpT3B0aW9ucy5nZXRPcHRpb25zLCB7IGlzQXV0aGVudGljYXRlZDogYXBpT3B0aW9ucy5hbGxBdXRoZW50aWNhdGVkLCBwYXJhbXM6IG1lcmdlZFBhcmFtcyB9KTtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZmluZCcsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG5cbiAgICByZXR1cm4gdXRpbGl0aWVzLnZhbGlkYXRlUEsoYXdhaXQgdXRpbGl0aWVzLnByb2Nlc3NBcnJheShcbiAgICAgIGFwaS5odHRwR2V0PFZbXT4oXG4gICAgICAgIHV0aWxpdGllcy5nZXRQYXRoKGxvYyksXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgKSkpIGFzIFZbXTtcbiAgfVxuXG4gIHJldHVybiBmaW5kO1xufVxuIiwiaW1wb3J0IHtcbiAgSXRlbSxcbiAgTG9jS2V5QXJyYXksXG4gIFF1ZXJ5UGFyYW1zXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcblxuaW1wb3J0IHsgZmluZGVyVG9QYXJhbXMgfSBmcm9tIFwiLi4vQUl0ZW1BUElcIjtcbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2ZpbmQnKTtcblxuZXhwb3J0IGNvbnN0IGdldEZpbmRPbmVPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApID0+IHtcblxuICBjb25zdCBmaW5kT25lID0gYXN5bmMgKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICB1dGlsaXRpZXMudmVyaWZ5TG9jYXRpb25zKGxvY2F0aW9ucyk7XG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICBjb25zdCBwYXJhbXM6IFF1ZXJ5UGFyYW1zID0gZmluZGVyVG9QYXJhbXMoZmluZGVyLCBmaW5kZXJQYXJhbXMpO1xuICAgIHBhcmFtcy5vbmUgPSB0cnVlO1xuXG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLmFsbEF1dGhlbnRpY2F0ZWQsIHBhcmFtcyB9KTtcbiAgICBsb2dnZXIuZGVmYXVsdCgnZmluZE9uZScsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG5cbiAgICByZXR1cm4gKHV0aWxpdGllcy52YWxpZGF0ZVBLKGF3YWl0IHV0aWxpdGllcy5wcm9jZXNzQXJyYXkoXG4gICAgICBhcGkuaHR0cEdldDxWW10+KFxuICAgICAgICB1dGlsaXRpZXMuZ2V0UGF0aChsb2MpLFxuICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICkpKSBhcyBWW10pWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRPbmU7XG59XG4iLCJpbXBvcnQge1xuICBDb21LZXksXG4gIEl0ZW0sXG4gIFByaUtleSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ29wcycsICdmYWNldCcpO1xuXG5leHBvcnQgY29uc3QgZ2V0RmFjZXRPcGVyYXRpb24gPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KFxuICAgIGFwaTogSHR0cEFwaSxcbiAgICBhcGlPcHRpb25zOiBDbGllbnRBcGlPcHRpb25zLFxuICAgIHV0aWxpdGllczogVXRpbGl0aWVzPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cblxuICApID0+IHtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBmYWNldCBvcGVyYXRpb24gb24gYW4gaXRlbS5cbiAgICpcbiAgICogQSBmYWNldCBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgaXMgcmVsYXRlZCB0byBhbiBpdGVtIC0gaXQgcmVwcmVzZW50c1xuICAgKiBhIHNwZWNpZmljIGFzcGVjdCBvciBjaGFyYWN0ZXJpc3RpYyBvZiB0aGUgaXRlbS4gVW5saWtlIGFjdGlvbnMgd2hpY2ggbWF5XG4gICAqIHJldHVybiBpdGVtcyBvciBwZXJmb3JtIG9wZXJhdGlvbnMsIGZhY2V0cyBhcmUgaW5mb3JtYXRpb25hbCBxdWVyaWVzIHRoYXRcbiAgICogcmV0dXJuIGRhdGEgYWJvdXQgYSBwYXJ0aWN1bGFyIGZhY2V0IG9mIGFuIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBpayAtIFRoZSBpdGVtIGtleSAoY29tcG9zaXRlIG9yIHByaW1hcnkga2V5KSBpZGVudGlmeWluZyB0aGUgaXRlbVxuICAgKiBAcGFyYW0gZmFjZXQgLSBUaGUgbmFtZSBvZiB0aGUgZmFjZXQgdG8gcXVlcnlcbiAgICogQHBhcmFtIGJvZHkgLSBPcHRpb25hbCByZXF1ZXN0IGJvZHkgZm9yIHRoZSBmYWNldCBvcGVyYXRpb25cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBIVFRQIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZmFjZXQgZGF0YVxuICAgKi9cbiAgY29uc3QgZmFjZXQgPSBhc3luYyAoXG4gICAgaWs6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFwaU9wdGlvbnMuZ2V0T3B0aW9ucywgeyBpc0F1dGhlbnRpY2F0ZWQ6IGFwaU9wdGlvbnMud3JpdGVBdXRoZW50aWNhdGVkLCBwYXJhbXMgfSk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2ZhY2V0JywgeyBpaywgZmFjZXQsIHJlcXVlc3RPcHRpb25zIH0pO1xuXG4gICAgcmV0dXJuIGFwaS5odHRwR2V0PGFueT4oXG4gICAgICBgJHt1dGlsaXRpZXMuZ2V0UGF0aChpayl9LyR7ZmFjZXR9YCxcbiAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICk7XG5cbiAgfTtcblxuICByZXR1cm4gZmFjZXQ7XG59XG4iLCJpbXBvcnQge1xuICBJdGVtLFxuICBMb2NLZXlBcnJheVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi4vQ2xpZW50QXBpT3B0aW9uc1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBVdGlsaXRpZXMgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ2NsaWVudC1hcGknLCAnb3BzJywgJ2FsbEZhY2V0Jyk7XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxGYWNldE9wZXJhdGlvbiA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oXG4gICAgYXBpOiBIdHRwQXBpLFxuICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgdXRpbGl0aWVzOiBVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuXG4gICkgPT4ge1xuXG4gIGNvbnN0IGFsbEZhY2V0ID0gYXN5bmMgKFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgICBsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSA9IFtdXG4gICk6IFByb21pc2U8VltdPiA9PiB7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcGlPcHRpb25zLmdldE9wdGlvbnMsIHsgaXNBdXRoZW50aWNhdGVkOiBhcGlPcHRpb25zLndyaXRlQXV0aGVudGljYXRlZCwgcGFyYW1zIH0pO1xuICAgIGxvZ2dlci5kZWZhdWx0KCdhbGxGYWNldCcsIHsgZmFjZXQsIGxvY2F0aW9ucywgcmVxdWVzdE9wdGlvbnMgfSk7XG4gICAgdXRpbGl0aWVzLnZlcmlmeUxvY2F0aW9ucyhsb2NhdGlvbnMpO1xuXG4gICAgY29uc3QgbG9jOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBsb2NhdGlvbnM7XG5cbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZXNwb25kIHRvIGVpdGhlciBhIHNpbmdsZSBvYmplY3QsIG9yIG11bHRpcGxlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gICAgcmV0dXJuIGFwaS5odHRwR2V0PFZbXT4oXG4gICAgICBgJHt1dGlsaXRpZXMuZ2V0UGF0aChsb2MpfS8ke2ZhY2V0fWAsXG4gICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICApXG4gIH07XG5cbiAgcmV0dXJuIGFsbEZhY2V0O1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCJcbmltcG9ydCB7IGdldEFsbE9wZXJhdGlvbiB9IGZyb20gXCIuL2FsbFwiXG5pbXBvcnQgeyBnZXRBY3Rpb25PcGVyYXRpb24gfSBmcm9tIFwiLi9hY3Rpb25cIlxuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiXG5pbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiXG5pbXBvcnQgeyBnZXRBbGxBY3Rpb25PcGVyYXRpb24gfSBmcm9tIFwiLi9hbGxBY3Rpb25cIlxuaW1wb3J0IHsgZ2V0T25lT3BlcmF0aW9uIH0gZnJvbSBcIi4vb25lXCJcbmltcG9ydCB7IGdldENyZWF0ZU9wZXJhdGlvbiB9IGZyb20gXCIuL2NyZWF0ZVwiXG5pbXBvcnQgeyBnZXRVcGRhdGVPcGVyYXRpb24gfSBmcm9tIFwiLi91cGRhdGVcIlxuaW1wb3J0IHsgZ2V0R2V0T3BlcmF0aW9uIH0gZnJvbSBcIi4vZ2V0XCJcbmltcG9ydCB7IGdldFJlbW92ZU9wZXJhdGlvbiB9IGZyb20gXCIuL3JlbW92ZVwiXG5pbXBvcnQgeyBnZXRGaW5kT3BlcmF0aW9uIH0gZnJvbSBcIi4vZmluZFwiXG5pbXBvcnQgeyBDbGllbnRBcGlPcHRpb25zIH0gZnJvbSBcIi4uL0NsaWVudEFwaU9wdGlvbnNcIlxuaW1wb3J0IHsgQ2xpZW50QXBpIH0gZnJvbSBcIi4uL0NsaWVudEFwaVwiXG5pbXBvcnQgeyBnZXRGaW5kT25lT3BlcmF0aW9uIH0gZnJvbSBcIi4vZmluZE9uZVwiXG5pbXBvcnQgeyBnZXRGYWNldE9wZXJhdGlvbiB9IGZyb20gXCIuL2ZhY2V0XCJcbmltcG9ydCB7IGdldEFsbEZhY2V0T3BlcmF0aW9uIH0gZnJvbSBcIi4vYWxsRmFjZXRcIlxuXG5leHBvcnQgY29uc3QgZ2V0T3BlcmF0aW9ucyA9XG4gIDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICAgIGFwaTogSHR0cEFwaSxcbiAgICAgIGFwaU9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMsXG4gICAgICB1dGlsaXRpZXM6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuXG4gICAgKTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IGdldEFjdGlvbk9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBhbGw6IGdldEFsbE9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBhbGxBY3Rpb246IGdldEFsbEFjdGlvbk9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBhbGxGYWNldDogZ2V0QWxsRmFjZXRPcGVyYXRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAgYXBpLFxuICAgICAgICBhcGlPcHRpb25zLFxuICAgICAgICB1dGlsaXRpZXMsXG4gICAgICApLFxuICAgICAgY3JlYXRlOiBnZXRDcmVhdGVPcGVyYXRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAgYXBpLFxuICAgICAgICBhcGlPcHRpb25zLFxuICAgICAgICB1dGlsaXRpZXMsXG4gICAgICApLFxuICAgICAgZmFjZXQ6IGdldEZhY2V0T3BlcmF0aW9uPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oXG4gICAgICAgIGFwaSxcbiAgICAgICAgYXBpT3B0aW9ucyxcbiAgICAgICAgdXRpbGl0aWVzLFxuICAgICAgKSxcbiAgICAgIGZpbmRPbmU6IGdldEZpbmRPbmVPcGVyYXRpb248ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihcbiAgICAgICAgYXBpLFxuICAgICAgICBhcGlPcHRpb25zLFxuICAgICAgICB1dGlsaXRpZXMsXG4gICAgICApLFxuICAgICAgZmluZDogZ2V0RmluZE9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBnZXQ6IGdldEdldE9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICBvbmU6IGdldE9uZU9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICByZW1vdmU6IGdldFJlbW92ZU9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgICB1cGRhdGU6IGdldFVwZGF0ZU9wZXJhdGlvbjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KFxuICAgICAgICBhcGksXG4gICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgIHV0aWxpdGllcyxcbiAgICAgICksXG4gICAgfVxuICB9IiwiaW1wb3J0IHtcbiAgQ29tS2V5LFxuICB2YWxpZGF0ZVBLIGFzIGNvcmVWYWxpZGF0ZVBLLFxuICBnZW5lcmF0ZUtleUFycmF5LFxuICBpc1ByaUtleSxcbiAgSXRlbSxcbiAgTG9jS2V5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5LFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSBcImRlZXBtZXJnZVwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdjbGllbnQtYXBpJywgJ1V0aWxpdHknKTtcblxuZXhwb3J0IGludGVyZmFjZSBVdGlsaXRpZXM8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4ge1xuICB2ZXJpZnlMb2NhdGlvbnM6IChsb2NhdGlvbnM6IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXSB8IG5ldmVyKSA9PiBib29sZWFuO1xuICBwcm9jZXNzT25lOiAoYXBpQ2FsbDogUHJvbWlzZTxWPikgPT4gUHJvbWlzZTxWPjtcbiAgcHJvY2Vzc0FycmF5OiAoYXBpOiBQcm9taXNlPFZbXT4pID0+IFByb21pc2U8VltdPjtcbiAgY29udmVydERvYzogKGRvYzogVikgPT4gVjtcbiAgZ2V0UGF0aDogKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4gfCBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10pID0+IHN0cmluZztcbiAgdmFsaWRhdGVQSzogKGl0ZW06IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PltdKSA9PlxuICAgIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PltdO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlVXRpbGl0aWVzID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KHBrVHlwZTogUywgcGF0aE5hbWVzOiBzdHJpbmdbXSk6IFV0aWxpdGllczxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcblxuICBsb2dnZXIuZGVmYXVsdCgnY3JlYXRlVXRpbGl0aWVzJywgeyBwa1R5cGUsIHBhdGhOYW1lcyB9KTtcblxuICBjb25zdCB2ZXJpZnlMb2NhdGlvbnMgPSAoXG4gICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gfCBuZXZlcixcbiAgKTogYm9vbGVhbiA9PiB7XG5cbiAgICBpZiAobG9jYXRpb25zICYmIGxvY2F0aW9ucy5sZW5ndGggPCBwYXRoTmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGxvY2F0aW9ucyBmb3IgcGF0aE5hbWVzOiBsb2NhdGlvbnM6J1xuICAgICAgICArIGxvY2F0aW9ucy5sZW5ndGggKyAnIHBhdGhOYW1lczonICsgcGF0aE5hbWVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgcHJvY2Vzc09uZSA9IGFzeW5jIChcbiAgICBhcGlDYWxsOiBQcm9taXNlPFY+LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdCgncHJvY2Vzc09uZScsIHsgYXBpQ2FsbCB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGw7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ3Byb2Nlc3NPbmUgcmVzcG9uc2UnLCB7XG4gICAgICByZXNwb25zZVR5cGU6IHR5cGVvZiByZXNwb25zZSxcbiAgICAgIGhhc0RhdGE6ICEhcmVzcG9uc2VcbiAgICB9KTtcbiAgICByZXR1cm4gY29udmVydERvYyhyZXNwb25zZSk7XG4gIH07XG5cbiAgY29uc3QgcHJvY2Vzc0FycmF5ID0gYXN5bmMgKFxuICAgIGFwaTogUHJvbWlzZTxWW10+LFxuICApOiBQcm9taXNlPFZbXT4gPT4ge1xuICAgIGxvZ2dlci5kZWZhdWx0KCdwcm9jZXNzQXJyYXknLCB7IGFwaSB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaTtcbiAgICBsb2dnZXIuZGVmYXVsdCgncHJvY2Vzc0FycmF5IHJlc3BvbnNlJywge1xuICAgICAgcmVzcG9uc2VUeXBlOiB0eXBlb2YgcmVzcG9uc2UsXG4gICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSxcbiAgICAgIGxlbmd0aDogQXJyYXkuaXNBcnJheShyZXNwb25zZSkgPyByZXNwb25zZS5sZW5ndGggOiAwXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlICYmIEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UubWFwKChzdWJqZWN0Q2hhdDogVikgPT5cbiAgICAgICAgY29udmVydERvYyhzdWJqZWN0Q2hhdCksXG4gICAgICApIGFzIHVua25vd24gYXMgVltdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ1Jlc3BvbnNlIHdhcyBub3QgYW4gYXJyYXknLCB7IHJlc3BvbnNlIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSB3YXMgbm90IGFuIGFycmF5Jyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNvbnZlcnREb2MgPSAoZG9jOiBWKTogViA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2NvbnZlcnREb2MnLCB7IGRvYyB9KTtcbiAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShkb2MsIG51bGwsIDIpKTtcbiAgICBpZiAoZG9jICYmIGRvYy5ldmVudHMpIHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGRvYy5ldmVudHM7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgZXZlbnRzW2tleV0gPSBkZWVwbWVyZ2UoZXZlbnRzW2tleV0sIHsgYXQ6IGV2ZW50c1trZXldLmF0ID8gbmV3IERhdGUoZXZlbnRzW2tleV0uYXQpIDogbnVsbCB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvYyBhcyB1bmtub3duIGFzIFY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldFBhdGggPVxuICAgIChcbiAgICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4gfCBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10sXG4gICAgKTpcbiAgICAgIHN0cmluZyA9PiB7XG5cbiAgICAgIGNvbnN0IGxvY2FsUGF0aE5hbWVzID0gWy4uLnBhdGhOYW1lc107XG4gICAgICBsb2dnZXIuZGVmYXVsdCgnZ2V0UGF0aCcsIHsga2V5LCBwYXRoTmFtZXM6IGxvY2FsUGF0aE5hbWVzIH0pO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnZ2V0UGF0aCBrZXk6ICcgKyBKU09OLnN0cmluZ2lmeShrZXkpKTtcblxuICAgICAgY29uc3Qga2V5cyA9IGdlbmVyYXRlS2V5QXJyYXkoa2V5KTtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ2dldFBhdGgga2V5czogJyArIEpTT04uc3RyaW5naWZ5KGtleXMpKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdnZXRQYXRoIHBhdGhOYW1lczogJyArIEpTT04uc3RyaW5naWZ5KHBhdGhOYW1lcykpO1xuXG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gYWRkUGF0aCgnJywga2V5cywgbG9jYWxQYXRoTmFtZXMpO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBjb2xsZWN0aW9uIGxlZnQgaW4gdGhlIGNvbGxlY3Rpb25zIGFycmF5LCB0aGlzIG1lYW5zIHRoYXRcbiAgICAgIC8vIHdlIHJlY2VpdmVkIExvY0tleXMgYW5kIHdlIG5lZWQgdG8gYWRkIHRoZSBsYXN0IGNvbGxlY3Rpb24gdG8gdGhlIHJlZmVyZW5jZVxuICAgICAgaWYgKGxvY2FsUGF0aE5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwYXRoID0gYCR7cGF0aH0vJHtsb2NhbFBhdGhOYW1lc1swXX1gO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIuZGVmYXVsdCgnZ2V0UGF0aCBjcmVhdGVkJywgeyBrZXksIHBhdGggfSk7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgY29uc3QgYWRkUGF0aCA9IChcbiAgICBiYXNlOiBzdHJpbmcsXG4gICAga2V5czogQXJyYXk8UHJpS2V5PFM+IHwgTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+PixcbiAgICBsb2NhbFBhdGhOYW1lczogc3RyaW5nW10sXG4gICk6IHN0cmluZyA9PiB7XG4gICAgbG9nZ2VyLmRlZmF1bHQoJ2FkZFBhdGgnLCB7IGJhc2UsIGtleXMsIHBhdGhOYW1lczogbG9jYWxQYXRoTmFtZXMgfSk7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgbG9jYWxQYXRoTmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdhZGRQYXRoIHNob3VsZCBuZXZlciBoYXZlIGtleXMgd2l0aCBhIGxlbmd0aCBsZXNzIHRoYW4gdGhlIGxlbmd0aCBvZiBwYXRoTmFtZXMgLSAxJyxcbiAgICAgICAgeyBrZXlzLCBsb2NhbFBhdGhOYW1lcyB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWRkUGF0aCBzaG91bGQgbmV2ZXIgaGF2ZSBrZXlzIHdpdGggYSBsZW5ndGggbGVzcyB0aGFuIHRoZSBsZW5ndGggb2YgcGF0aE5hbWVzIC0gMTogJ1xuICAgICAgICArIGtleXMubGVuZ3RoICsgJyAnICsgbG9jYWxQYXRoTmFtZXMubGVuZ3RoICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoa2V5cywgbG9jYWxQYXRoTmFtZXMpKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID4gbG9jYWxQYXRoTmFtZXMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ2FkZFBhdGggc2hvdWxkIG5ldmVyIGhhdmUga2V5cyB3aXRoIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHBhdGhOYW1lcycsXG4gICAgICAgIHsga2V5cywgcGF0aE5hbWVzIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRQYXRoIHNob3VsZCBuZXZlciBoYXZlIGtleXMgd2l0aCBhIGxlbmd0aCBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiBwYXRoTmFtZXM6ICdcbiAgICAgICAgKyBrZXlzLmxlbmd0aCArICcgJyArIGxvY2FsUGF0aE5hbWVzLmxlbmd0aCArICcgJyArIEpTT04uc3RyaW5naWZ5KGtleXMsIGxvY2FsUGF0aE5hbWVzKSk7XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgeW91J3ZlIHJlY3Vyc2l2ZWx5IGNvbnN1bWVkIGFsbCBvZiB0aGUga2V5cywgcmV0dXJuIHRoZSBiYXNlLlxuICAgICAgbG9nZ2VyLmRlZmF1bHQoJ2FkZFBhdGggcmV0dXJuaW5nIGJhc2UnLCB7IGJhc2UgfSk7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0cmlldmUgdGhlIG5leHQga2V5IGFuZCBjb2xsZWN0aW9uLCBhbmQgY3JlYXRlIHRoZSBuZXh0IGJhc2VcbiAgICAgIGxldCBuZXh0QmFzZTogc3RyaW5nO1xuICAgICAgY29uc3Qga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgIGNvbnN0IHBhdGhOYW1lID0gbG9jYWxQYXRoTmFtZXMucG9wKCk7XG4gICAgICBpZiAoaXNQcmlLZXkoa2V5KSkge1xuICAgICAgICBjb25zdCBQcmlLZXkgPSBrZXkgYXMgUHJpS2V5PFM+O1xuICAgICAgICBuZXh0QmFzZSA9IGAke2Jhc2V9LyR7cGF0aE5hbWV9LyR7UHJpS2V5LnBrfWA7XG4gICAgICAgIGxvZ2dlci5kZWZhdWx0KCdBZGRpbmcgUGF0aCBmb3IgUEsnLCB7IHBhdGhOYW1lLCBQcmlLZXksIG5leHRCYXNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgTG9jS2V5ID0ga2V5IGFzIExvY0tleTxMMSB8IEwyIHwgTDMgfCBMNCB8IEw1PjtcbiAgICAgICAgbmV4dEJhc2UgPSBgJHtiYXNlfS8ke3BhdGhOYW1lfS8ke0xvY0tleS5sa31gO1xuICAgICAgICBsb2dnZXIuZGVmYXVsdCgnUmV0cmlldmluZyBDb2xsZWN0aW9uIGZvciBMSycsIHsgcGF0aE5hbWUsIExvY0tleSB9KTtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmRlZmF1bHQoJ2NhbGxpbmcgYWRkUGF0aCByZWN1cnNpdmVseScsIHsgbmV4dEJhc2UsIGtleXMsIGxvY2FsUGF0aE5hbWVzIH0pO1xuICAgICAgcmV0dXJuIGFkZFBhdGgobmV4dEJhc2UsIGtleXMsIGxvY2FsUGF0aE5hbWVzKTtcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlUEsgPSAoXG4gICAgaXRlbTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+W10pOlxuICAgIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PltdID0+IHtcbiAgICByZXR1cm4gY29yZVZhbGlkYXRlUEs8UywgTDEsIEwyLCBMMywgTDQsIEw1PihpdGVtLCBwa1R5cGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJpZnlMb2NhdGlvbnMsXG4gICAgcHJvY2Vzc09uZSxcbiAgICBjb252ZXJ0RG9jLFxuICAgIHByb2Nlc3NBcnJheSxcbiAgICBnZXRQYXRoLFxuICAgIHZhbGlkYXRlUEssXG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuaW1wb3J0IHsgSXRlbSwgUXVlcnlQYXJhbXMgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBBcGkgfSBmcm9tIFwiQGZqZWxsL2h0dHAtYXBpXCI7XG5cbmltcG9ydCB7IENsaWVudEFwaU9wdGlvbnMgfSBmcm9tIFwiLi9DbGllbnRBcGlPcHRpb25zXCI7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25zIH0gZnJvbSBcIi4vb3BzXCI7XG5pbXBvcnQgeyBjcmVhdGVVdGlsaXRpZXMgfSBmcm9tIFwiLi9VdGlsaXRpZXNcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCIuL0NsaWVudEFwaVwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdBSXRlbUFQSScpO1xuXG5leHBvcnQgdHlwZSBQYXRoTmFtZXNBcnJheTxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9XG4gIChbTDVdIGV4dGVuZHMgW25ldmVyXSA/XG4gICAgKFtMNF0gZXh0ZW5kcyBbbmV2ZXJdID9cbiAgICAgIChbTDNdIGV4dGVuZHMgW25ldmVyXSA/XG4gICAgICAgIChbTDJdIGV4dGVuZHMgW25ldmVyXSA/XG4gICAgICAgICAgKFtMMV0gZXh0ZW5kcyBbbmV2ZXJdID9cbiAgICAgICAgICAgIFtzdHJpbmddIDpcbiAgICAgICAgICAgIFtzdHJpbmcsIHN0cmluZ10pIDpcbiAgICAgICAgICBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pIDpcbiAgICAgICAgW3N0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pIDpcbiAgICAgIFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pIDpcbiAgICBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10pO1xuXG5leHBvcnQgY29uc3QgZmluZGVyVG9QYXJhbXMgPSAoXG4gIGZpbmRlcjogc3RyaW5nLFxuICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PlxuKTogUXVlcnlQYXJhbXMgPT4ge1xuICByZXR1cm4ge1xuICAgIGZpbmRlcixcbiAgICBmaW5kZXJQYXJhbXM6IEpTT04uc3RyaW5naWZ5KGZpbmRlclBhcmFtcyksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQUl0ZW1BUEkgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGFwaTogSHR0cEFwaSxcbiAgcGtUeXBlOiBTLFxuICBwYXRoTmFtZXM6IFBhdGhOYW1lc0FycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIG9wdGlvbnM/OiBDbGllbnRBcGlPcHRpb25zLFxuKTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuXG4gIGxvZ2dlci5kZWZhdWx0KCdjcmVhdGVBSXRlbUFQSScsIHsgcGtUeXBlLCBwYXRoTmFtZXMsIG9wdGlvbnMgfSk7XG5cbiAgbGV0IG1lcmdlZE9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnM7XG5cbiAgY29uc3QgZGVmYXVsdE9wdGlvbnM6IENsaWVudEFwaU9wdGlvbnMgPSB7XG4gICAgcmVhZEF1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgYWxsQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICB3cml0ZUF1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgZ2V0T3B0aW9uczoge30sXG4gICAgcG9zdE9wdGlvbnM6IHt9LFxuICAgIHB1dE9wdGlvbnM6IHt9LFxuICAgIGRlbGV0ZU9wdGlvbnM6IHt9LFxuICB9O1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBtZXJnZWRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIH1cblxuICBjb25zdCB1dGlsaXRpZXMgPSBjcmVhdGVVdGlsaXRpZXM8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pihwa1R5cGUsIHBhdGhOYW1lcyk7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBnZXRPcGVyYXRpb25zPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oYXBpLCBtZXJnZWRPcHRpb25zLCB1dGlsaXRpZXMpO1xuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uOiBvcGVyYXRpb25zLmFjdGlvbixcbiAgICBhbGw6IG9wZXJhdGlvbnMuYWxsLFxuICAgIGFsbEFjdGlvbjogb3BlcmF0aW9ucy5hbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQ6IG9wZXJhdGlvbnMuYWxsRmFjZXQsXG4gICAgY3JlYXRlOiBvcGVyYXRpb25zLmNyZWF0ZSxcbiAgICBmYWNldDogb3BlcmF0aW9ucy5mYWNldCxcbiAgICBmaW5kOiBvcGVyYXRpb25zLmZpbmQsXG4gICAgZmluZE9uZTogb3BlcmF0aW9ucy5maW5kT25lLFxuICAgIGdldDogb3BlcmF0aW9ucy5nZXQsXG4gICAgb25lOiBvcGVyYXRpb25zLm9uZSxcbiAgICByZW1vdmU6IG9wZXJhdGlvbnMucmVtb3ZlLFxuICAgIHVwZGF0ZTogb3BlcmF0aW9ucy51cGRhdGUsXG4gIH1cbn0iLCJcbmltcG9ydCB7XG4gIENvbUtleSxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LFxuICBMb2NLZXlBcnJheSxcbiAgUHJpS2V5LFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7XG4gIEh0dHBBcGlcbn0gZnJvbSBcIkBmamVsbC9odHRwLWFwaVwiO1xuaW1wb3J0IHsgY3JlYXRlQUl0ZW1BUEksIFBhdGhOYW1lc0FycmF5IH0gZnJvbSBcIi4vQUl0ZW1BUElcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCIuL0NsaWVudEFwaVwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuL0NsaWVudEFwaU9wdGlvbnNcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnQ0l0ZW1BUEknKTtcblxuZXhwb3J0IGludGVyZmFjZSBDSXRlbUFwaTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gIGFjdGlvbjogKFxuICAgIGlrOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5OiBhbnksXG4gICkgPT4gUHJvbWlzZTxWPjtcbiAgYWxsOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFZbXT47XG4gIGFsbEFjdGlvbjogKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk/OiBhbnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICkgPT4gUHJvbWlzZTxWW10+O1xuICBhbGxGYWNldDogKFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8YW55PjtcbiAgZ2V0OiAoXG4gICAgaWs6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApID0+IFByb21pc2U8ViB8IG51bGw+O1xuICBjcmVhdGU6IChcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdXG4gICkgPT4gUHJvbWlzZTxWPjtcbiAgcmVtb3ZlOiAoXG4gICAgaWs6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIHVwZGF0ZTogKFxuICAgIGlrOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICkgPT4gUHJvbWlzZTxWPjtcbiAgZmFjZXQ6IChcbiAgICBpazogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxhbnk+O1xuICBmaW5kOiAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBbXVxuICApID0+IFByb21pc2U8VltdPjtcbiAgZmluZE9uZTogKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW11cbiAgKSA9PiBQcm9taXNlPFY+O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNJdGVtQXBpID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihhcGk6IEh0dHBBcGksIHR5cGU6IFMsIHBhdGhOYW1lczogUGF0aE5hbWVzQXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1Piwgb3B0aW9ucz86IENsaWVudEFwaU9wdGlvbnMpOiBDSXRlbUFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcblxuICBsb2dnZXIuZGVmYXVsdCgnY3JlYXRlQ0l0ZW1BcGknLCB7IGFwaSwgdHlwZSwgcGF0aE5hbWVzLCBvcHRpb25zIH0pO1xuXG4gIGNvbnN0IGFJdGVtQVBJID0gY3JlYXRlQUl0ZW1BUEkoYXBpLCB0eXBlLCBwYXRoTmFtZXMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uOiBhSXRlbUFQSS5hY3Rpb24sXG4gICAgYWxsOiBhSXRlbUFQSS5hbGwsXG4gICAgYWxsQWN0aW9uOiBhSXRlbUFQSS5hbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQ6IGFJdGVtQVBJLmFsbEZhY2V0LFxuICAgIG9uZTogYUl0ZW1BUEkub25lLFxuICAgIGdldDogYUl0ZW1BUEkuZ2V0LFxuICAgIGNyZWF0ZTogYUl0ZW1BUEkuY3JlYXRlLFxuICAgIHJlbW92ZTogYUl0ZW1BUEkucmVtb3ZlLFxuICAgIHVwZGF0ZTogYUl0ZW1BUEkudXBkYXRlLFxuICAgIGZhY2V0OiBhSXRlbUFQSS5mYWNldCxcbiAgICBmaW5kOiBhSXRlbUFQSS5maW5kLFxuICAgIGZpbmRPbmU6IGFJdGVtQVBJLmZpbmRPbmUsXG4gIH0gYXMgdW5rbm93biBhcyBDSXRlbUFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xufVxuIiwiaW1wb3J0IHsgQ29tS2V5LCBJdGVtLCBJdGVtUXVlcnksIFByaUtleSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSHR0cEFwaSB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcbmltcG9ydCB7IGNyZWF0ZUFJdGVtQVBJIH0gZnJvbSBcIi4vQUl0ZW1BUElcIjtcbmltcG9ydCB7IENsaWVudEFwaSB9IGZyb20gXCIuL0NsaWVudEFwaVwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuL2xvZ2dlclwiO1xuaW1wb3J0IHsgQ2xpZW50QXBpT3B0aW9ucyB9IGZyb20gXCIuL0NsaWVudEFwaU9wdGlvbnNcIjtcbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ1BJdGVtQVBJJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUEl0ZW1BcGk8XG4gIFYgZXh0ZW5kcyBJdGVtPFM+LFxuICBTIGV4dGVuZHMgc3RyaW5nXG4+IGV4dGVuZHMgQ2xpZW50QXBpPFYsIFM+IHtcblxuICBhY3Rpb246IChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keTogYW55LFxuICApID0+IFByb21pc2U8Vj47XG5cbiAgYWxsOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgKSA9PiBQcm9taXNlPFZbXT47XG5cbiAgYWxsQWN0aW9uOiAoXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueSxcbiAgKSA9PiBQcm9taXNlPFZbXT47XG5cbiAgYWxsRmFjZXQ6IChcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgKSA9PiBQcm9taXNlPGFueT47XG5cbiAgb25lOiAoXG4gICAgcXVlcnk6IEl0ZW1RdWVyeSxcbiAgKSA9PiBQcm9taXNlPFYgfCBudWxsPjtcblxuICBnZXQ6IChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbiAgY3JlYXRlOiAoXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFM+PixcbiAgKSA9PiBQcm9taXNlPFY+O1xuXG4gIHJlbW92ZTogKFxuICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gIHVwZGF0ZTogKFxuICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08Uz4+LFxuICApID0+IFByb21pc2U8Vj47XG5cbiAgZmFjZXQ6IChcbiAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxhbnk+O1xuXG4gIGZpbmQ6IChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxWW10+O1xuXG4gIGZpbmRPbmU6IChcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4gUHJvbWlzZTxWPjtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBJdGVtQXBpID0gPFYgZXh0ZW5kcyBJdGVtPFM+LCBTIGV4dGVuZHMgc3RyaW5nPihcbiAgYXBpOiBIdHRwQXBpLFxuICB0eXBlOiBTLFxuICBwYXRoTmFtZTogc3RyaW5nLFxuICBvcHRpb25zPzogQ2xpZW50QXBpT3B0aW9uc1xuKTogUEl0ZW1BcGk8ViwgUz4gPT4ge1xuXG4gIGxvZ2dlci5kZWZhdWx0KCdjcmVhdGVQSXRlbUFwaScsIHsgdHlwZSwgcGF0aE5hbWUsIG9wdGlvbnMgfSk7XG5cbiAgY29uc3QgYUl0ZW1BUEkgPSBjcmVhdGVBSXRlbUFQSTxWLCBTPihhcGksIHR5cGUsIFtwYXRoTmFtZV0sIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGFjdGlvbiA9XG4gICAgYXN5bmMgKFxuICAgICAgaWs6IFByaUtleTxTPiB8IENvbUtleTxTLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LFxuICAgICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgICBib2R5OiBhbnkgPSB7fSxcbiAgICApOiBQcm9taXNlPFY+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5hY3Rpb24oaWssIGFjdGlvbiwgYm9keSkgYXMgVjtcblxuICBjb25zdCBhbGwgPVxuICAgIGFzeW5jIChcbiAgICAgIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSBhcyBJdGVtUXVlcnksXG4gICAgKTogUHJvbWlzZTxWW10+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5hbGwocXVlcnksIFtdKSBhcyBWW107XG5cbiAgY29uc3QgYWxsQWN0aW9uID1cbiAgICBhc3luYyAoXG4gICAgICBhY3Rpb246IHN0cmluZyxcbiAgICAgIGJvZHk6IGFueSA9IHt9LFxuICAgICk6IFByb21pc2U8VltdPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuYWxsQWN0aW9uKGFjdGlvbiwgYm9keSwgW10pIGFzIFZbXTtcblxuICBjb25zdCBhbGxGYWNldCA9XG4gICAgYXN5bmMgKFxuICAgICAgZmFjZXQ6IHN0cmluZyxcbiAgICAgIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5hbGxGYWNldChmYWNldCwgcGFyYW1zKSBhcyBhbnk7XG5cbiAgY29uc3Qgb25lID1cbiAgICBhc3luYyAoXG4gICAgICBxdWVyeTogSXRlbVF1ZXJ5ID0ge30gYXMgSXRlbVF1ZXJ5LFxuICAgICk6IFByb21pc2U8ViB8IG51bGw+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5vbmUocXVlcnksIFtdKSBhcyBWIHwgbnVsbDtcblxuICBjb25zdCBnZXQgPVxuICAgIGFzeW5jIChcbiAgICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgICApOiBQcm9taXNlPFYgfCBudWxsPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuZ2V0KGlrKSBhcyBWIHwgbnVsbDtcblxuICBjb25zdCBjcmVhdGUgPVxuICAgIGFzeW5jIChcbiAgICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTPj4sXG4gICAgKTogUHJvbWlzZTxWPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuY3JlYXRlKGl0ZW0sIFtdKSBhcyBWO1xuXG4gIGNvbnN0IHJlbW92ZSA9XG4gICAgYXN5bmMgKFxuICAgICAgaWs6IFByaUtleTxTPiB8IENvbUtleTxTLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4gPT5cbiAgICAgIGF3YWl0IGFJdGVtQVBJLnJlbW92ZShpaykgYXMgYm9vbGVhbjtcblxuICBjb25zdCB1cGRhdGUgPVxuICAgIGFzeW5jIChcbiAgICAgIGlrOiBQcmlLZXk8Uz4gfCBDb21LZXk8UywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPixcbiAgICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTPj4sXG4gICAgKTogUHJvbWlzZTxWPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkudXBkYXRlKGlrLCBpdGVtKSBhcyBWO1xuXG4gIGNvbnN0IGZhY2V0ID1cbiAgICBhc3luYyAoXG4gICAgICBpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sXG4gICAgICBmYWNldDogc3RyaW5nLFxuICAgICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgICApOiBQcm9taXNlPGFueT4gPT5cbiAgICAgIGF3YWl0IGFJdGVtQVBJLmZhY2V0KGlrLCBmYWNldCwgcGFyYW1zKSBhcyBhbnk7XG5cbiAgY29uc3QgZmluZCA9XG4gICAgYXN5bmMgKFxuICAgICAgZmluZGVyOiBzdHJpbmcsXG4gICAgICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9LFxuICAgICk6IFByb21pc2U8VltdPiA9PlxuICAgICAgYXdhaXQgYUl0ZW1BUEkuZmluZChmaW5kZXIsIGZpbmRlclBhcmFtcykgYXMgVltdO1xuXG4gIGNvbnN0IGZpbmRPbmUgPVxuICAgIGFzeW5jIChcbiAgICAgIGZpbmRlcjogc3RyaW5nLFxuICAgICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgICApOiBQcm9taXNlPFY+ID0+XG4gICAgICBhd2FpdCBhSXRlbUFQSS5maW5kT25lKGZpbmRlciwgZmluZGVyUGFyYW1zKSBhcyBWO1xuXG4gIHJldHVybiB7XG4gICAgLi4uYUl0ZW1BUEksXG4gICAgYWN0aW9uLFxuICAgIGFsbCxcbiAgICBhbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQsXG4gICAgb25lLFxuICAgIGdldCxcbiAgICBjcmVhdGUsXG4gICAgcmVtb3ZlLFxuICAgIHVwZGF0ZSxcbiAgICBmYWNldCxcbiAgICBmaW5kLFxuICAgIGZpbmRPbmUsXG4gIH07XG5cbn07XG4iLCJcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBJbnN0YW5jZSBhcyBCYXNlSW5zdGFuY2UsIENvb3JkaW5hdGUsIGNyZWF0ZUluc3RhbmNlIGFzIGNyZWF0ZUJhc2VJbnN0YW5jZSwgUmVnaXN0cnkgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiLi9DbGllbnRBcGlcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIkluc3RhbmNlXCIpO1xuXG4vKipcbiAqIFRoZSBDbGllbnQgQVBJIEluc3RhbmNlIGludGVyZmFjZSByZXByZXNlbnRzIGEgY2xpZW50IEFQSSBtb2RlbCBpbnN0YW5jZSB0aGF0IGV4dGVuZHMgdGhlIGJhc2UgSW5zdGFuY2VcbiAqIGZyb20gQGZqZWxsL3JlZ2lzdHJ5IGFuZCBhZGRzIGNsaWVudCBBUEkgb3BlcmF0aW9ucyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCByZW1vdGUgZGF0YS5cbiAqXG4gKiBUaGUgaW50ZXJmYWNlIGV4dGVuZHMgdGhlIGJhc2UgSW5zdGFuY2UgKHdoaWNoIHByb3ZpZGVzIGNvb3JkaW5hdGUgYW5kIHJlZ2lzdHJ5KSB3aXRoOlxuICogLSBjbGllbnRBcGk6IFByb3ZpZGVzIG1ldGhvZHMgZm9yIGludGVyYWN0aW5nIHdpdGggcmVtb3RlIGRhdGEgdGhyb3VnaCBIVFRQIEFQSXMgKGdldCwgY3JlYXRlLCB1cGRhdGUsIGV0Yy4pXG4gKlxuICogQHRlbXBsYXRlIFYgLSBUaGUgdHlwZSBvZiB0aGUgZGF0YSBtb2RlbCBpdGVtLCBleHRlbmRpbmcgSXRlbVxuICogQHRlbXBsYXRlIFMgLSBUaGUgc3RyaW5nIGxpdGVyYWwgdHlwZSByZXByZXNlbnRpbmcgdGhlIG1vZGVsJ3Mga2V5IHR5cGVcbiAqIEB0ZW1wbGF0ZSBMMS1MNSAtIE9wdGlvbmFsIHN0cmluZyBsaXRlcmFsIHR5cGVzIGZvciBsb2NhdGlvbiBoaWVyYXJjaHkgbGV2ZWxzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFuY2U8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gZXh0ZW5kcyBCYXNlSW5zdGFuY2U8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB7XG4gIC8qKiBUaGUgY2xpZW50IEFQSSBvYmplY3QgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBpbnRlcmFjdGluZyB3aXRoIHJlbW90ZSBkYXRhICovXG4gIGNsaWVudEFwaTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnN0YW5jZSA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICByZWdpc3RyeTogUmVnaXN0cnksXG4gICAgY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIGNsaWVudEFwaTogQ2xpZW50QXBpPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICk6IEluc3RhbmNlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBsb2dnZXIuZGVidWcoXCJjcmVhdGVJbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIGNsaWVudEFwaSwgcmVnaXN0cnkgfSk7XG4gIGNvbnN0IGJhc2VJbnN0YW5jZSA9IGNyZWF0ZUJhc2VJbnN0YW5jZShyZWdpc3RyeSwgY29vcmRpbmF0ZSk7XG4gIHJldHVybiB7IC4uLmJhc2VJbnN0YW5jZSwgY2xpZW50QXBpIH07XG59XG4iLCJpbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBDbGllbnRBcGkgfSBmcm9tIFwiLi9DbGllbnRBcGlcIjtcbmltcG9ydCB7IEluc3RhbmNlRmFjdG9yeSBhcyBCYXNlSW5zdGFuY2VGYWN0b3J5LCBSZWdpc3RyeSwgUmVnaXN0cnlIdWIgfSBmcm9tIFwiQGZqZWxsL3JlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBjcmVhdGVJbnN0YW5jZSwgSW5zdGFuY2UgfSBmcm9tIFwiLi9JbnN0YW5jZVwiO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCJAZmplbGwvcmVnaXN0cnlcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJJbnN0YW5jZUZhY3RvcnlcIik7XG5cbmV4cG9ydCB0eXBlIEluc3RhbmNlRmFjdG9yeTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9IChcbiAgY2xpZW50QXBpOiBDbGllbnRBcGk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PlxuKSA9PiBCYXNlSW5zdGFuY2VGYWN0b3J5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50LWFwaSBpbnN0YW5jZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUluc3RhbmNlRmFjdG9yeSA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBjbGllbnRBcGk6IENsaWVudEFwaTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IEJhc2VJbnN0YW5jZUZhY3Rvcnk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG4gIHJldHVybiAoY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBjb250ZXh0OiB7IHJlZ2lzdHJ5OiBSZWdpc3RyeSwgcmVnaXN0cnlIdWI/OiBSZWdpc3RyeUh1YiB9KSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiQ3JlYXRpbmcgY2xpZW50LWFwaSBpbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5OiBjb250ZXh0LnJlZ2lzdHJ5LCBjbGllbnRBcGkgfSk7XG5cbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UoY29udGV4dC5yZWdpc3RyeSwgY29vcmRpbmF0ZSwgY2xpZW50QXBpKSBhcyBJbnN0YW5jZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICB9O1xufTtcbiIsImltcG9ydCBMaWJMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHtcbiAgUmVnaXN0cnkgYXMgQmFzZVJlZ2lzdHJ5LFxuICBjcmVhdGVSZWdpc3RyeSBhcyBjcmVhdGVCYXNlUmVnaXN0cnksXG4gIFJlZ2lzdHJ5RmFjdG9yeSxcbiAgUmVnaXN0cnlIdWJcbn0gZnJvbSAnQGZqZWxsL3JlZ2lzdHJ5JztcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIlJlZ2lzdHJ5XCIpO1xuXG4vKipcbiAqIEV4dGVuZGVkIFJlZ2lzdHJ5IGludGVyZmFjZSBmb3IgY2xpZW50LWFwaS1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cnkgZXh0ZW5kcyBCYXNlUmVnaXN0cnkge1xuICB0eXBlOiAnY2xpZW50LWFwaSc7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50LWFwaSByZWdpc3RyaWVzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWdpc3RyeUZhY3RvcnkgPSAoKTogUmVnaXN0cnlGYWN0b3J5ID0+IHtcbiAgcmV0dXJuICh0eXBlOiBzdHJpbmcsIHJlZ2lzdHJ5SHViPzogUmVnaXN0cnlIdWIpOiBCYXNlUmVnaXN0cnkgPT4ge1xuICAgIGlmICh0eXBlICE9PSAnY2xpZW50LWFwaScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IEFQSSByZWdpc3RyeSBmYWN0b3J5IGNhbiBvbmx5IGNyZWF0ZSAnY2xpZW50LWFwaScgdHlwZSByZWdpc3RyaWVzLCBnb3Q6ICR7dHlwZX1gKTtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoXCJDcmVhdGluZyBjbGllbnQtYXBpIHJlZ2lzdHJ5XCIsIHsgdHlwZSwgcmVnaXN0cnlIdWIgfSk7XG5cbiAgICBjb25zdCBiYXNlUmVnaXN0cnkgPSBjcmVhdGVCYXNlUmVnaXN0cnkodHlwZSwgcmVnaXN0cnlIdWIpO1xuXG4gICAgLy8gQ2FzdCB0byBSZWdpc3RyeSBmb3IgdHlwZSBzYWZldHlcbiAgICByZXR1cm4gYmFzZVJlZ2lzdHJ5IGFzIFJlZ2lzdHJ5O1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNsaWVudC1hcGkgcmVnaXN0cnkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5SHViPzogUmVnaXN0cnlIdWIpOiBSZWdpc3RyeSA9PiB7XG4gIGNvbnN0IGJhc2VSZWdpc3RyeSA9IGNyZWF0ZUJhc2VSZWdpc3RyeSgnY2xpZW50LWFwaScsIHJlZ2lzdHJ5SHViKTtcblxuICByZXR1cm4ge1xuICAgIC4uLmJhc2VSZWdpc3RyeSxcbiAgfSBhcyBSZWdpc3RyeTtcbn07XG4iLCIvKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBDbGllbnQgQVBJIGVycm9yc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xpZW50QXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGFic3RyYWN0IHJlYWRvbmx5IGNvZGU6IHN0cmluZztcbiAgYWJzdHJhY3QgcmVhZG9ubHkgaXNSZXRyeWFibGU6IGJvb2xlYW47XG4gIHJlYWRvbmx5IHRpbWVzdGFtcDogRGF0ZTtcbiAgcmVhZG9ubHkgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT47XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgIC8vIEVuc3VyZSBwcm9wZXIgcHJvdG90eXBlIGNoYWluIGZvciBpbnN0YW5jZW9mIGNoZWNrc1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGlzUmV0cnlhYmxlOiB0aGlzLmlzUmV0cnlhYmxlLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIE5ldHdvcmstcmVsYXRlZCBlcnJvcnMgKGNvbm5lY3Rpb24gaXNzdWVzLCB0aW1lb3V0cylcbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIENsaWVudEFwaUVycm9yIHtcbiAgcmVhZG9ubHkgY29kZSA9ICdORVRXT1JLX0VSUk9SJztcbiAgcmVhZG9ubHkgaXNSZXRyeWFibGUgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihgTmV0d29yayBlcnJvcjogJHttZXNzYWdlfWAsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogSFRUUCB0aW1lb3V0IGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ1RJTUVPVVRfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IodGltZW91dDogbnVtYmVyLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKGBSZXF1ZXN0IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXNgLCBjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEF1dGhlbnRpY2F0aW9uIGVycm9ycyAoNDAxIFVuYXV0aG9yaXplZClcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnQVVUSEVOVElDQVRJT05fRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCAnQXV0aGVudGljYXRpb24gZmFpbGVkIC0gaW52YWxpZCBvciBleHBpcmVkIGNyZWRlbnRpYWxzJywgY29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdXRob3JpemF0aW9uIGVycm9ycyAoNDAzIEZvcmJpZGRlbilcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhvcml6YXRpb25FcnJvciBleHRlbmRzIENsaWVudEFwaUVycm9yIHtcbiAgcmVhZG9ubHkgY29kZSA9ICdBVVRIT1JJWkFUSU9OX0VSUk9SJztcbiAgcmVhZG9ubHkgaXNSZXRyeWFibGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ0FjY2VzcyBmb3JiaWRkZW4gLSBpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnLCBjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc291cmNlIG5vdCBmb3VuZCBlcnJvcnMgKDQwNCBOb3QgRm91bmQpXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ05PVF9GT1VORF9FUlJPUic7XG4gIHJlYWRvbmx5IGlzUmV0cnlhYmxlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocmVzb3VyY2U6IHN0cmluZywgaWRlbnRpZmllcj86IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaWRlbnRpZmllclxuICAgICAgPyBgJHtyZXNvdXJjZX0gd2l0aCBpZGVudGlmaWVyICcke2lkZW50aWZpZXJ9JyBub3QgZm91bmRgXG4gICAgICA6IGAke3Jlc291cmNlfSBub3QgZm91bmRgO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogUmVxdWVzdCB2YWxpZGF0aW9uIGVycm9ycyAoNDAwIEJhZCBSZXF1ZXN0KVxuICovXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ1ZBTElEQVRJT05fRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuICByZWFkb25seSB2YWxpZGF0aW9uRXJyb3JzPzogQXJyYXk8eyBmaWVsZDogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfT47XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCB2YWxpZGF0aW9uRXJyb3JzPzogQXJyYXk8eyBmaWVsZDogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfT4sIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoYFZhbGlkYXRpb24gZXJyb3I6ICR7bWVzc2FnZX1gLCBjb250ZXh0KTtcbiAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmxpY3QgZXJyb3JzICg0MDkgQ29uZmxpY3QpXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ0NPTkZMSUNUX0VSUk9SJztcbiAgcmVhZG9ubHkgaXNSZXRyeWFibGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoYENvbmZsaWN0OiAke21lc3NhZ2V9YCwgY29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSYXRlIGxpbWl0aW5nIGVycm9ycyAoNDI5IFRvbyBNYW55IFJlcXVlc3RzKVxuICovXG5leHBvcnQgY2xhc3MgUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnUkFURV9MSU1JVF9FUlJPUic7XG4gIHJlYWRvbmx5IGlzUmV0cnlhYmxlID0gdHJ1ZTtcbiAgcmVhZG9ubHkgcmV0cnlBZnRlcj86IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihyZXRyeUFmdGVyPzogbnVtYmVyLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSByZXRyeUFmdGVyXG4gICAgICA/IGBSYXRlIGxpbWl0IGV4Y2VlZGVkIC0gcmV0cnkgYWZ0ZXIgJHtyZXRyeUFmdGVyfSBzZWNvbmRzYFxuICAgICAgOiAnUmF0ZSBsaW1pdCBleGNlZWRlZCc7XG4gICAgc3VwZXIobWVzc2FnZSwgY29udGV4dCk7XG4gICAgdGhpcy5yZXRyeUFmdGVyID0gcmV0cnlBZnRlcjtcbiAgfVxufVxuXG4vKipcbiAqIFNlcnZlciBlcnJvcnMgKDV4eCBzdGF0dXMgY29kZXMpXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIENsaWVudEFwaUVycm9yIHtcbiAgcmVhZG9ubHkgY29kZSA9ICdTRVJWRVJfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IHRydWU7XG4gIHJlYWRvbmx5IHN0YXR1c0NvZGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlOiBudW1iZXIsIG1lc3NhZ2U/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCBgU2VydmVyIGVycm9yICgke3N0YXR1c0NvZGV9KWAsIGNvbnRleHQpO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXF1ZXN0IHBheWxvYWQgdG9vIGxhcmdlIGVycm9ycyAoNDEzKVxuICovXG5leHBvcnQgY2xhc3MgUGF5bG9hZFRvb0xhcmdlRXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnUEFZTE9BRF9UT09fTEFSR0VfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1heFNpemU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1heFNpemVcbiAgICAgID8gYFJlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UgLSBtYXhpbXVtIHNpemUgaXMgJHttYXhTaXplfWBcbiAgICAgIDogJ1JlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UnO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJpYyBIVFRQIGVycm9ycyBmb3IgdW5oYW5kbGVkIHN0YXR1cyBjb2Rlc1xuICovXG5leHBvcnQgY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ0hUVFBfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZTogYm9vbGVhbjtcbiAgcmVhZG9ubHkgc3RhdHVzQ29kZTogbnVtYmVyO1xuICByZWFkb25seSBzdGF0dXNUZXh0OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZTogbnVtYmVyLCBzdGF0dXNUZXh0OiBzdHJpbmcsIG1lc3NhZ2U/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCBgSFRUUCBlcnJvciAke3N0YXR1c0NvZGV9OiAke3N0YXR1c1RleHR9YCwgY29udGV4dCk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuXG4gICAgLy8gNXh4IGVycm9ycyBhcmUgZ2VuZXJhbGx5IHJldHJ5YWJsZSwgNHh4IGFyZSBub3RcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gc3RhdHVzQ29kZSA+PSA1MDA7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgQ2xpZW50QXBpRXJyb3Ige1xuICByZWFkb25seSBjb2RlID0gJ0NPTkZJR1VSQVRJT05fRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihgQ29uZmlndXJhdGlvbiBlcnJvcjogJHttZXNzYWdlfWAsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2Uvc2VyaWFsaXphdGlvbiBlcnJvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBDbGllbnRBcGlFcnJvciB7XG4gIHJlYWRvbmx5IGNvZGUgPSAnUEFSU0VfRVJST1InO1xuICByZWFkb25seSBpc1JldHJ5YWJsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihgUGFyc2UgZXJyb3I6ICR7bWVzc2FnZX1gLCBjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhcHByb3ByaWF0ZSBlcnJvciBmcm9tIEhUVFAgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUh0dHBFcnJvcihcbiAgc3RhdHVzQ29kZTogbnVtYmVyLFxuICBzdGF0dXNUZXh0OiBzdHJpbmcsXG4gIHJlc3BvbnNlQm9keT86IGFueSxcbiAgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT5cbik6IENsaWVudEFwaUVycm9yIHtcbiAgY29uc3QgZXJyb3JDb250ZXh0ID0geyBzdGF0dXNDb2RlLCBzdGF0dXNUZXh0LCByZXNwb25zZUJvZHksIC4uLmNvbnRleHQgfTtcblxuICBzd2l0Y2ggKHN0YXR1c0NvZGUpIHtcbiAgICBjYXNlIDQwMDpcbiAgICAgIGlmIChyZXNwb25zZUJvZHk/LnZhbGlkYXRpb25FcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgcmVzcG9uc2VCb2R5Lm1lc3NhZ2UgfHwgJ1JlcXVlc3QgdmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgIHJlc3BvbnNlQm9keS52YWxpZGF0aW9uRXJyb3JzLFxuICAgICAgICAgIGVycm9yQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IocmVzcG9uc2VCb2R5Py5tZXNzYWdlIHx8IHN0YXR1c1RleHQsIFtdLCBlcnJvckNvbnRleHQpO1xuXG4gICAgY2FzZSA0MDE6XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IocmVzcG9uc2VCb2R5Py5tZXNzYWdlLCBlcnJvckNvbnRleHQpO1xuXG4gICAgY2FzZSA0MDM6XG4gICAgICByZXR1cm4gbmV3IEF1dGhvcml6YXRpb25FcnJvcihyZXNwb25zZUJvZHk/Lm1lc3NhZ2UsIGVycm9yQ29udGV4dCk7XG5cbiAgICBjYXNlIDQwNDpcbiAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihcbiAgICAgICAgcmVzcG9uc2VCb2R5Py5yZXNvdXJjZSB8fCAnUmVzb3VyY2UnLFxuICAgICAgICByZXNwb25zZUJvZHk/LmlkZW50aWZpZXIsXG4gICAgICAgIGVycm9yQ29udGV4dFxuICAgICAgKTtcblxuICAgIGNhc2UgNDA5OlxuICAgICAgcmV0dXJuIG5ldyBDb25mbGljdEVycm9yKHJlc3BvbnNlQm9keT8ubWVzc2FnZSB8fCBzdGF0dXNUZXh0LCBlcnJvckNvbnRleHQpO1xuXG4gICAgY2FzZSA0MTM6XG4gICAgICByZXR1cm4gbmV3IFBheWxvYWRUb29MYXJnZUVycm9yKHJlc3BvbnNlQm9keT8ubWF4U2l6ZSwgZXJyb3JDb250ZXh0KTtcblxuICAgIGNhc2UgNDI5OiB7XG4gICAgICBsZXQgcmV0cnlBZnRlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKHJlc3BvbnNlQm9keT8ucmV0cnlBZnRlcikge1xuICAgICAgICByZXRyeUFmdGVyID0gcmVzcG9uc2VCb2R5LnJldHJ5QWZ0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQ/LmhlYWRlcnM/LlsncmV0cnktYWZ0ZXInXSkge1xuICAgICAgICByZXRyeUFmdGVyID0gcGFyc2VJbnQoY29udGV4dC5oZWFkZXJzWydyZXRyeS1hZnRlciddKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0RXJyb3IocmV0cnlBZnRlciwgZXJyb3JDb250ZXh0KTtcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gNTAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyRXJyb3Ioc3RhdHVzQ29kZSwgcmVzcG9uc2VCb2R5Py5tZXNzYWdlIHx8IHN0YXR1c1RleHQsIGVycm9yQ29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgSHR0cEVycm9yKHN0YXR1c0NvZGUsIHN0YXR1c1RleHQsIHJlc3BvbnNlQm9keT8ubWVzc2FnZSwgZXJyb3JDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhcHByb3ByaWF0ZSBlcnJvciBmcm9tIG5ldHdvcmsvY29ubmVjdGlvbiBpc3N1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5ldHdvcmtFcnJvcihlcnJvcjogYW55LCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pik6IENsaWVudEFwaUVycm9yIHtcbiAgY29uc3QgZXJyb3JDb250ZXh0ID0geyBvcmlnaW5hbEVycm9yOiBlcnJvciwgLi4uY29udGV4dCB9O1xuXG4gIGlmIChlcnJvci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndGltZW91dCcpKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lb3V0RXJyb3IoZXJyb3IudGltZW91dCB8fCA1MDAwLCBlcnJvckNvbnRleHQpO1xuICB9XG5cbiAgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnIHx8XG4gICAgZXJyb3IuY29kZSA9PT0gJ0VOT1RGT1VORCcgfHxcbiAgICBlcnJvci5jb2RlID09PSAnRU5FVFVOUkVBQ0gnIHx8XG4gICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgIHJldHVybiBuZXcgTmV0d29ya0Vycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQnLCBlcnJvckNvbnRleHQpO1xuICB9XG5cbiAgLy8gRm9yIHVua25vd24gZXJyb3JzLCB0cmVhdCBhcyBuZXR3b3JrIGlzc3VlcyB0aGF0IG1pZ2h0IGJlIHJldHJ5YWJsZVxuICByZXR1cm4gbmV3IE5ldHdvcmtFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIG5ldHdvcmsgZXJyb3InLCBlcnJvckNvbnRleHQpO1xufVxuXG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgZXJyb3IgaXMgcmV0cnlhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JldHJ5YWJsZUVycm9yKGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgQ2xpZW50QXBpRXJyb3IgJiYgZXJyb3IuaXNSZXRyeWFibGU7XG59XG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBlcnJvciBpcyBhIENsaWVudCBBUEkgZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xpZW50QXBpRXJyb3IoZXJyb3I6IGFueSk6IGVycm9yIGlzIENsaWVudEFwaUVycm9yIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgQ2xpZW50QXBpRXJyb3I7XG59XG4iLCJpbXBvcnQgeyBIdHRwQXBpIH0gZnJvbSAnQGZqZWxsL2h0dHAtYXBpJztcbmltcG9ydCB7XG4gIENsaWVudEFwaUVycm9yLFxuICBjcmVhdGVIdHRwRXJyb3IsXG4gIGNyZWF0ZU5ldHdvcmtFcnJvcixcbiAgUmF0ZUxpbWl0RXJyb3Jcbn0gZnJvbSAnLi4vZXJyb3JzL2luZGV4JztcblxuLy8gU2ltcGxlIGxvZ2dlciBpbnRlcmZhY2UgZm9yIG5vd1xuY29uc3QgbG9nZ2VyID0ge1xuICBkZWJ1ZzogKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IGFueSkgPT4gY29uc29sZS5kZWJ1ZyhtZXNzYWdlLCBjb250ZXh0KSxcbiAgaW5mbzogKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IGFueSkgPT4gY29uc29sZS5pbmZvKG1lc3NhZ2UsIGNvbnRleHQpLFxuICB3YXJuaW5nOiAobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogYW55KSA9PiBjb25zb2xlLndhcm4obWVzc2FnZSwgY29udGV4dCksXG4gIGVycm9yOiAobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0PzogYW55KSA9PiBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGNvbnRleHQpXG59O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIHJldHJ5IGJlaGF2aW9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlDb25maWcge1xuICAvKiogTWF4aW11bSBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgKGRlZmF1bHQ6IDMpICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIC8qKiBJbml0aWFsIGRlbGF5IGJldHdlZW4gcmV0cmllcyBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDEwMDApICovXG4gIGluaXRpYWxEZWxheU1zPzogbnVtYmVyO1xuICAvKiogTWF4aW11bSBkZWxheSBiZXR3ZWVuIHJldHJpZXMgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiAzMDAwMCkgKi9cbiAgbWF4RGVsYXlNcz86IG51bWJlcjtcbiAgLyoqIEJhY2tvZmYgbXVsdGlwbGllciBmb3IgZXhwb25lbnRpYWwgYmFja29mZiAoZGVmYXVsdDogMikgKi9cbiAgYmFja29mZk11bHRpcGxpZXI/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIGFkZCBqaXR0ZXIgdG8gcmV0cnkgZGVsYXlzIChkZWZhdWx0OiB0cnVlKSAqL1xuICBlbmFibGVKaXR0ZXI/OiBib29sZWFuO1xuICAvKiogQ3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBzaG91bGQgYmUgcmV0cmllZCAqL1xuICBzaG91bGRSZXRyeT86IChlcnJvcjogQ2xpZW50QXBpRXJyb3IsIGF0dGVtcHROdW1iZXI6IG51bWJlcikgPT4gYm9vbGVhbjtcbiAgLyoqIENhbGxlZCBiZWZvcmUgZWFjaCByZXRyeSBhdHRlbXB0ICovXG4gIG9uUmV0cnk/OiAoZXJyb3I6IENsaWVudEFwaUVycm9yLCBhdHRlbXB0TnVtYmVyOiBudW1iZXIsIGRlbGF5OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogRGVmYXVsdCByZXRyeSBjb25maWd1cmF0aW9uXG4gKi9cbmNvbnN0IERFRkFVTFRfUkVUUllfQ09ORklHOiBSZXF1aXJlZDxSZXRyeUNvbmZpZz4gPSB7XG4gIG1heFJldHJpZXM6IDMsXG4gIGluaXRpYWxEZWxheU1zOiAxMDAwLFxuICBtYXhEZWxheU1zOiAzMDAwMCxcbiAgYmFja29mZk11bHRpcGxpZXI6IDIsXG4gIGVuYWJsZUppdHRlcjogdHJ1ZSxcbiAgc2hvdWxkUmV0cnk6IChlcnJvcjogQ2xpZW50QXBpRXJyb3IsIGF0dGVtcHROdW1iZXI6IG51bWJlcikgPT4ge1xuICAgIC8vIERvbid0IHJldHJ5IGFmdGVyIG1heCBhdHRlbXB0c1xuICAgIGlmIChhdHRlbXB0TnVtYmVyID49IDMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEFsd2F5cyByZXRyeSByZXRyeWFibGUgZXJyb3JzXG4gICAgaWYgKGVycm9yLmlzUmV0cnlhYmxlKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIERvbid0IHJldHJ5IG5vbi1yZXRyeWFibGUgZXJyb3JzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBvblJldHJ5OiAoZXJyb3I6IENsaWVudEFwaUVycm9yLCBhdHRlbXB0TnVtYmVyOiBudW1iZXIsIGRlbGF5OiBudW1iZXIpID0+IHtcbiAgICBsb2dnZXIud2FybmluZyhgUmV0cnlpbmcgSFRUUCByZXF1ZXN0IChhdHRlbXB0ICR7YXR0ZW1wdE51bWJlciArIDF9KSBhZnRlciAke2RlbGF5fW1zYCwge1xuICAgICAgZXJyb3JDb2RlOiBlcnJvci5jb2RlLFxuICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgZGVsYXksXG4gICAgICBhdHRlbXB0TnVtYmVyXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2xlZXAgdXRpbGl0eSBmb3IgcmV0cnkgZGVsYXlzXG4gKi9cbmNvbnN0IHNsZWVwID0gKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkZWxheSBmb3IgZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIG9wdGlvbmFsIGppdHRlclxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVEZWxheShcbiAgYXR0ZW1wdE51bWJlcjogbnVtYmVyLFxuICBjb25maWc6IFJlcXVpcmVkPFJldHJ5Q29uZmlnPlxuKTogbnVtYmVyIHtcbiAgY29uc3QgZXhwb25lbnRpYWxEZWxheSA9IGNvbmZpZy5pbml0aWFsRGVsYXlNcyAqIE1hdGgucG93KGNvbmZpZy5iYWNrb2ZmTXVsdGlwbGllciwgYXR0ZW1wdE51bWJlcik7XG4gIGNvbnN0IGNhcHBlZERlbGF5ID0gTWF0aC5taW4oZXhwb25lbnRpYWxEZWxheSwgY29uZmlnLm1heERlbGF5TXMpO1xuXG4gIGlmICghY29uZmlnLmVuYWJsZUppdHRlcikge1xuICAgIHJldHVybiBjYXBwZWREZWxheTtcbiAgfVxuXG4gIC8vIEFkZCBqaXR0ZXI6IHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIDUwJSBhbmQgMTAwJSBvZiBjYWxjdWxhdGVkIGRlbGF5XG4gIGNvbnN0IGppdHRlciA9IDAuNSArIChNYXRoLnJhbmRvbSgpICogMC41KTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoY2FwcGVkRGVsYXkgKiBqaXR0ZXIpO1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIEhUVFAgd3JhcHBlciB3aXRoIHJldHJ5IGxvZ2ljIGFuZCBjb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwV3JhcHBlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXBpOiBIdHRwQXBpO1xuICBwcml2YXRlIHJlYWRvbmx5IHJldHJ5Q29uZmlnOiBSZXF1aXJlZDxSZXRyeUNvbmZpZz47XG5cbiAgY29uc3RydWN0b3IoYXBpOiBIdHRwQXBpLCByZXRyeUNvbmZpZzogUmV0cnlDb25maWcgPSB7fSkge1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMucmV0cnlDb25maWcgPSB7IC4uLkRFRkFVTFRfUkVUUllfQ09ORklHLCAuLi5yZXRyeUNvbmZpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgSFRUUCBvcGVyYXRpb24gd2l0aCByZXRyeSBsb2dpYyBhbmQgZXJyb3IgaGFuZGxpbmdcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVXaXRoUmV0cnk8VD4oXG4gICAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PlxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgbGFzdEVycm9yOiBDbGllbnRBcGlFcnJvciB8IG51bGwgPSBudWxsO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8PSB0aGlzLnJldHJ5Q29uZmlnLm1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBFeGVjdXRpbmcgJHtvcGVyYXRpb25OYW1lfWAsIHtcbiAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0ICsgMSxcbiAgICAgICAgICBtYXhSZXRyaWVzOiB0aGlzLnJldHJ5Q29uZmlnLm1heFJldHJpZXMgKyAxLFxuICAgICAgICAgIC4uLmNvbnRleHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYCR7b3BlcmF0aW9uTmFtZX0gc3VjY2VlZGVkIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllc2AsIHtcbiAgICAgICAgICAgIHRvdGFsQXR0ZW1wdHM6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICAuLi5jb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gdGhpcy5jb252ZXJ0VG9DbGllbnRBcGlFcnJvcihlcnJvciwgb3BlcmF0aW9uTmFtZSwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gdGhlIGxhc3QgYXR0ZW1wdFxuICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gdGhpcy5yZXRyeUNvbmZpZy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgcmV0cnkgdGhpcyBlcnJvclxuICAgICAgICBpZiAoIXRoaXMucmV0cnlDb25maWcuc2hvdWxkUmV0cnkobGFzdEVycm9yLCBhdHRlbXB0KSkge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm90IHJldHJ5aW5nICR7b3BlcmF0aW9uTmFtZX0gZHVlIHRvIG5vbi1yZXRyeWFibGUgZXJyb3JgLCB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IGxhc3RFcnJvci5jb2RlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBsYXN0RXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGF0dGVtcHQ6IGF0dGVtcHQgKyAxLFxuICAgICAgICAgICAgLi4uY29udGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgd2l0aCBjdXN0b20gZGVsYXlcbiAgICAgICAgbGV0IGRlbGF5ID0gY2FsY3VsYXRlRGVsYXkoYXR0ZW1wdCwgdGhpcy5yZXRyeUNvbmZpZyk7XG4gICAgICAgIGlmIChsYXN0RXJyb3IgaW5zdGFuY2VvZiBSYXRlTGltaXRFcnJvciAmJiBsYXN0RXJyb3IucmV0cnlBZnRlcikge1xuICAgICAgICAgIGRlbGF5ID0gTWF0aC5tYXgoZGVsYXksIGxhc3RFcnJvci5yZXRyeUFmdGVyICogMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIHJldHJ5IGNhbGxiYWNrXG4gICAgICAgIHRoaXMucmV0cnlDb25maWcub25SZXRyeShsYXN0RXJyb3IsIGF0dGVtcHQsIGRlbGF5KTtcblxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeWluZ1xuICAgICAgICBhd2FpdCBzbGVlcChkZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9nIGZpbmFsIGZhaWx1cmVcbiAgICBsb2dnZXIuZXJyb3IoYCR7b3BlcmF0aW9uTmFtZX0gZmFpbGVkIGFmdGVyICR7dGhpcy5yZXRyeUNvbmZpZy5tYXhSZXRyaWVzICsgMX0gYXR0ZW1wdHNgLCB7XG4gICAgICBlcnJvckNvZGU6IGxhc3RFcnJvcj8uY29kZSxcbiAgICAgIGVycm9yTWVzc2FnZTogbGFzdEVycm9yPy5tZXNzYWdlLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAuLi5jb250ZXh0XG4gICAgfSk7XG5cbiAgICB0aHJvdyBsYXN0RXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbnkgZXJyb3IgdG8gYSBDbGllbnRBcGlFcnJvclxuICAgKi9cbiAgcHJpdmF0ZSBjb252ZXJ0VG9DbGllbnRBcGlFcnJvcihcbiAgICBlcnJvcjogYW55LFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PlxuICApOiBDbGllbnRBcGlFcnJvciB7XG4gICAgY29uc3QgZXJyb3JDb250ZXh0ID0geyBvcGVyYXRpb246IG9wZXJhdGlvbk5hbWUsIC4uLmNvbnRleHQgfTtcblxuICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhIENsaWVudEFwaUVycm9yLCByZXR1cm4gYXMtaXNcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDbGllbnRBcGlFcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBIVFRQIHJlc3BvbnNlIGVycm9yc1xuICAgIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgICAgY29uc3QgeyBzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEsIGhlYWRlcnMgfSA9IGVycm9yLnJlc3BvbnNlO1xuICAgICAgcmV0dXJuIGNyZWF0ZUh0dHBFcnJvcihzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEsIHtcbiAgICAgICAgLi4uZXJyb3JDb250ZXh0LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICB1cmw6IGVycm9yLmNvbmZpZz8udXJsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVxdWVzdCBlcnJvcnMgKG5ldHdvcmsgaXNzdWVzLCB0aW1lb3V0cywgZXRjLilcbiAgICBpZiAoZXJyb3IucmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5ldHdvcmtFcnJvcihlcnJvciwge1xuICAgICAgICAuLi5lcnJvckNvbnRleHQsXG4gICAgICAgIHVybDogZXJyb3IuY29uZmlnPy51cmwsXG4gICAgICAgIG1ldGhvZDogZXJyb3IuY29uZmlnPy5tZXRob2RcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb25maWd1cmF0aW9uIG9yIG90aGVyIGVycm9yc1xuICAgIHJldHVybiBjcmVhdGVOZXR3b3JrRXJyb3IoZXJyb3IsIGVycm9yQ29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgSFRUUCBHRVQgb3BlcmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0PFQ+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBhbnksXG4gICAgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVdpdGhSZXRyeShcbiAgICAgICgpID0+IHRoaXMuYXBpLmh0dHBHZXQodXJsLCBvcHRpb25zKSxcbiAgICAgICdHRVQnLFxuICAgICAgeyB1cmwsIC4uLmNvbnRleHQgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgSFRUUCBQT1NUIG9wZXJhdGlvbnNcbiAgICovXG4gIGFzeW5jIHBvc3Q8VD4oXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgZGF0YT86IGFueSxcbiAgICBvcHRpb25zPzogYW55LFxuICAgIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVXaXRoUmV0cnkoXG4gICAgICAoKSA9PiB0aGlzLmFwaS5odHRwUG9zdCh1cmwsIGRhdGEsIG9wdGlvbnMpLFxuICAgICAgJ1BPU1QnLFxuICAgICAgeyB1cmwsIGhhc0RhdGE6ICEhZGF0YSwgLi4uY29udGV4dCB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIGZvciBIVFRQIFBVVCBvcGVyYXRpb25zXG4gICAqL1xuICBhc3luYyBwdXQ8VD4oXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgZGF0YT86IGFueSxcbiAgICBvcHRpb25zPzogYW55LFxuICAgIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVXaXRoUmV0cnkoXG4gICAgICAoKSA9PiB0aGlzLmFwaS5odHRwUHV0KHVybCwgZGF0YSwgb3B0aW9ucyksXG4gICAgICAnUFVUJyxcbiAgICAgIHsgdXJsLCBoYXNEYXRhOiAhIWRhdGEsIC4uLmNvbnRleHQgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgSFRUUCBERUxFVEUgb3BlcmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgZGVsZXRlPFQ+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBhbnksXG4gICAgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVdpdGhSZXRyeShcbiAgICAgICgpID0+IHRoaXMuYXBpLmh0dHBEZWxldGUodXJsLCBvcHRpb25zKSxcbiAgICAgICdERUxFVEUnLFxuICAgICAgeyB1cmwsIC4uLmNvbnRleHQgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHJldHJ5IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHVwZGF0ZVJldHJ5Q29uZmlnKG5ld0NvbmZpZzogUGFydGlhbDxSZXRyeUNvbmZpZz4pOiB2b2lkIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMucmV0cnlDb25maWcsIG5ld0NvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcmV0cnkgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0UmV0cnlDb25maWcoKTogUmVxdWlyZWQ8UmV0cnlDb25maWc+IHtcbiAgICByZXR1cm4geyAuLi50aGlzLnJldHJ5Q29uZmlnIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJsb2dnZXIiLCJhY3Rpb24iLCJxdWVyeVRvUGFyYW1zIiwiZmFjZXQiLCJQcmlLZXkiLCJMb2NLZXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/@fjell/core/dist/index.js":
/*!******************************************************************!*\
  !*** ../fjell-client-api/node_modules/@fjell/core/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItemService: () => (/* binding */ AItemService),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   IFactory: () => (/* binding */ IFactory),\n/* harmony export */   IQFactory: () => (/* binding */ IQFactory),\n/* harmony export */   abbrevAgg: () => (/* binding */ abbrevAgg),\n/* harmony export */   abbrevCompoundCondition: () => (/* binding */ abbrevCompoundCondition),\n/* harmony export */   abbrevCondition: () => (/* binding */ abbrevCondition),\n/* harmony export */   abbrevIK: () => (/* binding */ abbrevIK),\n/* harmony export */   abbrevLKA: () => (/* binding */ abbrevLKA),\n/* harmony export */   abbrevQuery: () => (/* binding */ abbrevQuery),\n/* harmony export */   abbrevRef: () => (/* binding */ abbrevRef),\n/* harmony export */   cPK: () => (/* binding */ cPK),\n/* harmony export */   constructPriKey: () => (/* binding */ constructPriKey),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   generateKeyArray: () => (/* binding */ generateKeyArray),\n/* harmony export */   ikToLKA: () => (/* binding */ ikToLKA),\n/* harmony export */   isComItem: () => (/* binding */ isComItem),\n/* harmony export */   isComKey: () => (/* binding */ isComKey),\n/* harmony export */   isComKeyEqual: () => (/* binding */ isComKeyEqual),\n/* harmony export */   isComKeyEqualNormalized: () => (/* binding */ isComKeyEqualNormalized),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isItemKey: () => (/* binding */ isItemKey),\n/* harmony export */   isItemKeyEqual: () => (/* binding */ isItemKeyEqual),\n/* harmony export */   isItemKeyEqualNormalized: () => (/* binding */ isItemKeyEqualNormalized),\n/* harmony export */   isLocKey: () => (/* binding */ isLocKey),\n/* harmony export */   isLocKeyEqual: () => (/* binding */ isLocKeyEqual),\n/* harmony export */   isLocKeyEqualNormalized: () => (/* binding */ isLocKeyEqualNormalized),\n/* harmony export */   isPriItem: () => (/* binding */ isPriItem),\n/* harmony export */   isPriKey: () => (/* binding */ isPriKey),\n/* harmony export */   isPriKeyEqual: () => (/* binding */ isPriKeyEqual),\n/* harmony export */   isPriKeyEqualNormalized: () => (/* binding */ isPriKeyEqualNormalized),\n/* harmony export */   isQueryMatch: () => (/* binding */ isQueryMatch),\n/* harmony export */   isValidComKey: () => (/* binding */ isValidComKey),\n/* harmony export */   isValidItemKey: () => (/* binding */ isValidItemKey),\n/* harmony export */   isValidLocKey: () => (/* binding */ isValidLocKey),\n/* harmony export */   isValidLocKeyArray: () => (/* binding */ isValidLocKeyArray),\n/* harmony export */   isValidPriKey: () => (/* binding */ isValidPriKey),\n/* harmony export */   itemKeyToLocKeyArray: () => (/* binding */ itemKeyToLocKeyArray),\n/* harmony export */   lkaToIK: () => (/* binding */ lkaToIK),\n/* harmony export */   locKeyArrayToItemKey: () => (/* binding */ locKeyArrayToItemKey),\n/* harmony export */   paramsToQuery: () => (/* binding */ paramsToQuery),\n/* harmony export */   primaryType: () => (/* binding */ primaryType),\n/* harmony export */   queryToParams: () => (/* binding */ queryToParams),\n/* harmony export */   toKeyTypeArray: () => (/* binding */ toKeyTypeArray),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys),\n/* harmony export */   validatePK: () => (/* binding */ validatePK)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/../fjell-client-api/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! luxon */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/luxon.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/core\");\nvar logger_default = LibLogger;\n\n// src/dictionary.ts\nvar logger = logger_default.get(\"Dictionary\");\nvar Dictionary = class _Dictionary {\n  map = {};\n  hashFunction = (key) => JSON.stringify(key);\n  constructor(map, hashFunction) {\n    if (hashFunction) {\n      this.hashFunction = hashFunction;\n    }\n    if (map) {\n      Object.entries(map).forEach(([hashedKey, value]) => {\n        try {\n          const originalKey = JSON.parse(hashedKey);\n          this.map[hashedKey] = { originalKey, value };\n        } catch {\n          logger.warning(\"Cannot recover original key from legacy map entry\", { hashedKey });\n        }\n      });\n    }\n  }\n  set(key, item) {\n    logger.trace(\"set\", { key, item });\n    const hashedKey = this.hashFunction(key);\n    this.map[hashedKey] = { originalKey: key, value: item };\n  }\n  get(key) {\n    logger.trace(\"get\", { key });\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry && this.keysEqual(entry.originalKey, key) ? entry.value : null;\n  }\n  keysEqual(key1, key2) {\n    return key1 === key2;\n  }\n  delete(key) {\n    logger.trace(\"delete\", { key });\n    const hashedKey = this.hashFunction(key);\n    delete this.map[hashedKey];\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  includesKey(key) {\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry ? this.keysEqual(entry.originalKey, key) : false;\n  }\n  clone() {\n    const clonedMap = {};\n    Object.entries(this.map).forEach(([hashedKey, entry]) => {\n      clonedMap[hashedKey] = entry.value;\n    });\n    const clone = new _Dictionary(clonedMap, this.hashFunction);\n    clone.map = Object.assign({}, this.map);\n    return clone;\n  }\n};\n\n// src/item/IFactory.ts\n\n\n// src/key/KUtils.ts\nvar logger2 = logger_default.get(\"KUtils\");\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && (normalizedKey.pk !== void 0 && normalizedKey.pk !== null)) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && (normalizedKey.lk !== void 0 && normalizedKey.lk !== null)) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && (locItem.lk !== void 0 && locItem.lk !== null)) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return JSON.stringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isPriKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isPriKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.pk) === normalizeKeyValue(b.pk) && a.kt === b.kt;\n};\nvar isLocKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isLocKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.lk) === normalizeKeyValue(b.lk) && a.kt === b.kt;\n};\nvar isComKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isComKeyEqualNormalized\", { a, b });\n  if (a && b && isPriKeyEqualNormalized({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqualNormalized(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isItemKeyEqualNormalized\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqualNormalized(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqualNormalized(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqual = (a, b) => {\n  logger2.trace(\"isKeyEqual\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqual(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqual(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isPriKeyEqual = (a, b) => {\n  logger2.trace(\"isPriKeyEqual\", { a, b });\n  return a && b && a.pk === b.pk && a.kt === b.kt;\n};\nvar isLocKeyEqual = (a, b) => {\n  logger2.trace(\"isLocKeyEqual\", { a, b });\n  return a && b && a.lk === b.lk && a.kt === b.kt;\n};\nvar isComKeyEqual = (a, b) => {\n  logger2.trace(\"isComKeyEqual\", { a, b });\n  if (a && b && isPriKeyEqual({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqual(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKey = (key) => {\n  logger2.trace(\"isItemKey\", { key });\n  return key !== void 0 && (isComKey(key) || isPriKey(key));\n};\nvar isComKey = (key) => {\n  logger2.trace(\"isComKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc !== void 0 && key.loc.length > 0);\n};\nvar isPriKey = (key) => {\n  logger2.trace(\"isPriKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc === void 0 || key.loc.length === 0);\n};\nvar isLocKey = (key) => {\n  logger2.trace(\"isLocKey\", { key });\n  return key !== void 0 && (key.lk !== void 0 && key.kt !== void 0);\n};\nvar generateKeyArray = (key) => {\n  logger2.trace(\"generateKeyArray\", { key });\n  const keys = [];\n  if (isComKey(key) || isPriKey(key)) {\n    if (isComKey(key)) {\n      const comKey = key;\n      keys.push({ pk: comKey.pk, kt: comKey.kt });\n      for (let i = 0; i < comKey.loc.length; i++) {\n        keys.push(comKey.loc[i]);\n      }\n    } else {\n      keys.push(key);\n    }\n  } else {\n    const locKeys = key;\n    for (let i = 0; i < locKeys.length; i++) {\n      keys.push(locKeys[i]);\n    }\n  }\n  return keys;\n};\nvar constructPriKey = (pk, kt) => {\n  logger2.trace(\"constructPriKey\", { pk, kt });\n  let pri;\n  if (typeof pk === \"string\" || typeof pk === \"number\") {\n    pri = { kt, pk };\n  } else {\n    pri = pk;\n  }\n  return pri;\n};\nvar cPK = constructPriKey;\nvar toKeyTypeArray = (ik) => {\n  logger2.trace(\"toKeyTypeArray\", { ik });\n  if (isComKey(ik)) {\n    const ck = ik;\n    return [ck.kt, ...ck.loc.map((l) => l.kt)];\n  } else {\n    return [ik.kt];\n  }\n};\nvar abbrevIK = (ik) => {\n  logger2.trace(\"abbrevIK\", { ik });\n  if (ik) {\n    if (isComKey(ik)) {\n      const ck = ik;\n      return `${ck.kt}:${ck.pk}:${ck.loc.map((l) => `${l.kt}:${l.lk}`).join(\",\")}`;\n    } else {\n      return `${ik.kt}:${ik.pk}`;\n    }\n  } else {\n    return \"null IK\";\n  }\n};\nvar abbrevLKA = (keyArray) => {\n  logger2.trace(\"abbrevLKA\", { keyArray });\n  if (keyArray === void 0 || keyArray === null) {\n    return \"null LKA\";\n  } else {\n    return keyArray.map((key) => {\n      if (key) {\n        return `${key.kt}:${key.lk}`;\n      } else {\n        return key;\n      }\n    }).join(\",\");\n  }\n};\nvar primaryType = (ik) => {\n  logger2.trace(\"primaryType\", { ik });\n  if (isComKey(ik)) {\n    return ik.kt;\n  } else {\n    return ik.kt;\n  }\n};\nvar itemKeyToLocKeyArray = (ik) => {\n  logger2.trace(\"itemKeyToLocKeyArray\", { ik: abbrevIK(ik) });\n  let lka = [];\n  if (isComKey(ik)) {\n    const ck = ik;\n    lka = [{ kt: ck.kt, lk: ck.pk }, ...ck.loc];\n  } else {\n    const pk = ik;\n    lka = [{ kt: pk.kt, lk: pk.pk }];\n  }\n  logger2.trace(\"itemKeyToLocKeyArray Results\", { ik: abbrevIK(ik), lka: abbrevLKA(lka) });\n  return lka;\n};\nvar ikToLKA = itemKeyToLocKeyArray;\nvar locKeyArrayToItemKey = (lka) => {\n  logger2.trace(\"locKeyArrayToItemKey\", { lka: abbrevLKA(lka) });\n  if (lka && lka.length === 1) {\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    return priKey;\n  } else if (lka && lka.length > 1 && lka[0] !== void 0) {\n    const locs = lka.slice(1);\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    const comKey = { kt: priKey.kt, pk: priKey.pk, loc: locs };\n    return comKey;\n  } else {\n    throw new Error(\"locKeyArrayToItemKey: lka is undefined or empty\");\n  }\n};\nvar isValidPriKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.pk !== void 0 && key.pk !== null && key.pk !== \"\" && key.pk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.lk !== void 0 && key.lk !== null && key.lk !== \"\" && key.lk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKeyArray = (keyArray) => {\n  return keyArray !== void 0 && keyArray !== null && keyArray.every(isValidLocKey);\n};\nvar isValidComKey = (key) => {\n  return key !== void 0 && key !== null && isValidPriKey(key) && isValidLocKeyArray(key.loc);\n};\nvar isValidItemKey = (key) => {\n  return isComKey(key) && isValidComKey(key) || isPriKey(key) && isValidPriKey(key);\n};\nvar lkaToIK = locKeyArrayToItemKey;\n\n// src/item/IFactory.ts\nvar IFactory = class _IFactory {\n  item = {};\n  constructor(props = {}) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n  }\n  addRef(i, name) {\n    const ik = i.key;\n    const refName = name || primaryType(ik);\n    if (!this.item.refs) {\n      this.item.refs = {};\n    }\n    this.item.refs[refName] = ik;\n    return this;\n  }\n  static addRef(i, name) {\n    return new _IFactory().addRef(i, name);\n  }\n  addDefaultEvents() {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    const now = /* @__PURE__ */ new Date();\n    if (!this.item.events.created) {\n      this.item.events.created = { at: now };\n    }\n    if (!this.item.events.updated) {\n      this.item.events.updated = { at: now };\n    }\n    if (!this.item.events.deleted) {\n      this.item.events.deleted = { at: null };\n    }\n    return this;\n  }\n  addEvent(name, at, by) {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    this.item.events[name] = { at, by };\n    return this;\n  }\n  static addEvent(name, at, by) {\n    return new _IFactory().addEvent(name, at, by);\n  }\n  addProp(name, value) {\n    this.item[name] = value;\n    return this;\n  }\n  static addProp(name, value) {\n    return new _IFactory().addProp(name, value);\n  }\n  addProps(props) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n    return this;\n  }\n  static addProps(props) {\n    return new _IFactory().addProps(props);\n  }\n  toItem() {\n    return this.item;\n  }\n};\n\n// src/AItemService.ts\nvar AItemService = class {\n  pkType;\n  parentService = null;\n  constructor(pkType, parentService) {\n    this.pkType = pkType;\n    if (parentService) {\n      this.parentService = parentService;\n    }\n  }\n  getPkType = () => {\n    return this.pkType;\n  };\n  getKeyTypes = () => {\n    let keyTypes = [this.getPkType()];\n    if (this.parentService) {\n      keyTypes = keyTypes.concat(this.parentService.getKeyTypes());\n    }\n    return keyTypes;\n  };\n};\n\n// src/item/ItemQuery.ts\nvar isCondition = (condition) => {\n  return (typeof condition.column === \"string\" && (Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"string\")) || Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"number\") || typeof condition.value === \"string\" || typeof condition.value === \"number\" || typeof condition.value === \"boolean\" || condition.value instanceof Date) && (condition.operator ? typeof condition.operator === \"string\" : true);\n};\n\n// src/item/IQFactory.ts\nvar IQFactory = class _IQFactory {\n  query = {};\n  constructor(query = {}) {\n    this.query = query;\n  }\n  orderBy(field, direction = \"asc\") {\n    if (!this.query.orderBy) {\n      this.query.orderBy = [];\n    }\n    this.query.orderBy.push({ field, direction });\n    return this;\n  }\n  agg(name, query) {\n    if (!this.query.aggs) {\n      this.query.aggs = {};\n    }\n    this.query.aggs[name] = query;\n    return this;\n  }\n  event(name, query) {\n    if (!this.query.events) {\n      this.query.events = {};\n    }\n    this.query.events[name] = query;\n    return this;\n  }\n  conditions(conditions, compoundType = \"AND\") {\n    for (const condition of conditions) {\n      if (!isCondition(condition)) {\n        throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n      }\n    }\n    if (!this.query.compoundCondition) {\n      this.query.compoundCondition = {\n        compoundType,\n        conditions\n      };\n    } else {\n      const compoundCondition = {\n        compoundType,\n        conditions\n      };\n      this.query.compoundCondition.conditions.push(compoundCondition);\n    }\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  // TODO: right now, we're only supporting PK refs for queries.  Should add support for CKs\n  pk(kt, pk, name) {\n    if (!this.query.refs) {\n      this.query.refs = {};\n    }\n    const refName = name || kt;\n    this.query.refs[refName] = cPK(pk, kt);\n    return this;\n  }\n  condition(column, value, operator = \"==\") {\n    const condition = { column, value, operator };\n    if (isCondition(condition)) {\n      if (!this.query.compoundCondition) {\n        this.query.compoundCondition = {\n          compoundType: \"AND\",\n          conditions: []\n        };\n      }\n      this.query.compoundCondition.conditions.push(condition);\n      return this;\n    } else {\n      throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n    }\n  }\n  static all() {\n    const iqFactory = new _IQFactory();\n    return iqFactory;\n  }\n  static orderBy(field, direction = \"asc\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.orderBy(field, direction);\n  }\n  static agg(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.agg(name, query);\n  }\n  static event(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.event(name, query);\n  }\n  static limit(limit) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.limit(limit);\n  }\n  static offset(offset) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.offset(offset);\n  }\n  static pk(kt, pk, name) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.pk(kt, pk, name);\n  }\n  static condition(column, value, operator = \"==\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.condition(column, value, operator);\n  }\n  static conditions(conditions, compoundType = \"AND\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.conditions(conditions, compoundType);\n  }\n  toQuery() {\n    return this.query;\n  }\n};\n\n// src/item/IQUtils.ts\n\nvar logger3 = logger_default.get(\"IQUtils\");\nvar queryToParams = (query) => {\n  const params = {};\n  if (query.compoundCondition) {\n    params.compoundCondition = JSON.stringify(query.compoundCondition);\n  }\n  if (query.refs) {\n    params.refs = JSON.stringify(query.refs);\n  }\n  if (query.limit) {\n    params.limit = query.limit;\n  }\n  if (query.offset) {\n    params.offset = query.offset;\n  }\n  if (query.aggs) {\n    params.aggs = JSON.stringify(query.aggs);\n  }\n  if (query.events) {\n    params.events = JSON.stringify(query.events);\n  }\n  return params;\n};\nvar dateTimeReviver = function(key, value) {\n  if (typeof value === \"string\") {\n    const parsedDate = luxon__WEBPACK_IMPORTED_MODULE_2__.DateTime.fromISO(value);\n    if (parsedDate.isValid) {\n      return parsedDate.toJSDate();\n      ;\n    }\n  }\n  return value;\n};\nvar paramsToQuery = (params) => {\n  const query = {};\n  if (params.compoundCondition) {\n    query.compoundCondition = JSON.parse(params.compoundCondition);\n  }\n  if (params.refs) {\n    query.refs = JSON.parse(params.refs);\n  }\n  if (params.limit) {\n    query.limit = Number(params.limit);\n  }\n  if (params.offset) {\n    query.offset = Number(params.offset);\n  }\n  if (params.aggs) {\n    query.aggs = JSON.parse(params.aggs);\n  }\n  if (params.events) {\n    query.events = JSON.parse(params.events, dateTimeReviver);\n  }\n  return query;\n};\nvar isRefQueryMatch = (refKey, queryRef, references) => {\n  logger3.trace(\"doesRefMatch\", { queryRef, references });\n  logger3.debug(\"Comparing Ref\", { refKey, itemRef: references[refKey], queryRef });\n  return isItemKeyEqual(queryRef, references[refKey]);\n};\nvar isCompoundConditionQueryMatch = (queryCondition, item) => {\n  if (queryCondition.compoundType === \"AND\") {\n    return queryCondition.conditions.every(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  } else {\n    return queryCondition.conditions.some(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  }\n};\nvar isConditionQueryMatch = (queryCondition, item) => {\n  const propKey = queryCondition.column;\n  logger3.trace(\"doesConditionMatch\", { propKey, queryCondition, item });\n  if (item[propKey] === void 0) {\n    logger3.debug(\"Item does not contain prop under key\", { propKey, item });\n    return false;\n  }\n  logger3.debug(\"Comparing Condition\", { propKey, itemProp: item[propKey], queryCondition });\n  let result = false;\n  switch (queryCondition.operator) {\n    case \"==\":\n      result = item[propKey] === queryCondition.value;\n      break;\n    case \"!=\":\n      result = item[propKey] !== queryCondition.value;\n      break;\n    case \">\":\n      result = item[propKey] > queryCondition.value;\n      break;\n    case \">=\":\n      result = item[propKey] >= queryCondition.value;\n      break;\n    case \"<\":\n      result = item[propKey] < queryCondition.value;\n      break;\n    case \"<=\":\n      result = item[propKey] <= queryCondition.value;\n      break;\n    case \"in\":\n      result = queryCondition.value.includes(item[propKey]);\n      break;\n    case \"not-in\":\n      result = !queryCondition.value.includes(item[propKey]);\n      break;\n    case \"array-contains\":\n      result = item[propKey].includes(queryCondition.value);\n      break;\n    case \"array-contains-any\":\n      result = queryCondition.value.some((value) => item[propKey].includes(value));\n      break;\n  }\n  return result;\n};\nvar isAggQueryMatch = (aggKey, aggQuery, agg) => {\n  const aggItem = agg.item;\n  logger3.debug(\"Comparing Agg\", { aggKey, aggItem, aggQuery });\n  return isQueryMatch(aggItem, aggQuery);\n};\nvar isEventQueryMatch = (eventKey, eventQuery, item) => {\n  if (!item.events[eventKey]) {\n    logger3.debug(\"Item does not contain event under key\", { eventKey, events: item.events });\n    return false;\n  } else {\n    const itemEvent = item.events[eventKey];\n    if (itemEvent.at !== null) {\n      if (eventQuery.start && !(eventQuery.start.getTime() <= itemEvent.at.getTime())) {\n        logger3.debug(\"Item date before event start query\", { eventQuery, itemEvent });\n        return false;\n      }\n      if (eventQuery.end && !(eventQuery.end.getTime() > itemEvent.at.getTime())) {\n        logger3.debug(\"Item date after event end query\", { eventQuery, itemEvent });\n        return false;\n      }\n    } else {\n      logger3.debug(\"Item event does contains a null at\", { itemEvent });\n      return false;\n    }\n    return true;\n  }\n};\nvar isQueryMatch = (item, query) => {\n  logger3.trace(\"isMatch\", { item, query });\n  if (query.refs && item.refs) {\n    for (const key in query.refs) {\n      const queryRef = query.refs[key];\n      if (!isRefQueryMatch(key, queryRef, item.refs)) return false;\n    }\n  } else if (query.refs && !item.refs) {\n    logger3.debug(\"Query contains refs but item does not have refs\", { query, item });\n    return false;\n  }\n  if (query.compoundCondition && item) {\n    if (!isCompoundConditionQueryMatch(query.compoundCondition, item)) return false;\n  }\n  if (query.events && item.events) {\n    for (const key in query.events) {\n      const queryEvent = query.events[key];\n      if (!isEventQueryMatch(key, queryEvent, item)) return false;\n    }\n    return true;\n  }\n  if (query.aggs && item.aggs) {\n    for (const key in query.aggs) {\n      const aggQuery = query.aggs[key];\n      if (item.aggs[key] && !isAggQueryMatch(key, aggQuery, item.aggs[key])) return false;\n    }\n  }\n  if (query.aggs && !item.aggs) {\n    logger3.debug(\"Query contains aggs but item does not have aggs\", { query, item });\n    return false;\n  }\n  return true;\n};\nvar abbrevQuery = (query) => {\n  const abbrev = [\"IQ\"];\n  if (query) {\n    if (query.refs) {\n      for (const key in query.refs) {\n        const ref = abbrevRef(key, query.refs[key]);\n        abbrev.push(ref);\n      }\n    }\n    if (query.compoundCondition) {\n      const props = abbrevCompoundCondition(query.compoundCondition);\n      abbrev.push(props);\n    }\n    if (query.aggs) {\n      for (const key in query.aggs) {\n        const agg = abbrevAgg(key, query.aggs[key]);\n        abbrev.push(agg);\n      }\n    }\n    if (query.events) {\n      const events = `(E${Object.keys(query.events).join(\",\")})`;\n      abbrev.push(events);\n    }\n    if (query.limit) {\n      abbrev.push(`L${query.limit}`);\n    }\n    if (query.offset) {\n      abbrev.push(`O${query.offset}`);\n    }\n  } else {\n    abbrev.push(\"(empty)\");\n  }\n  return abbrev.join(\" \");\n};\nvar abbrevRef = (key, ref) => {\n  if (isPriKey(ref)) {\n    const priKey = ref;\n    return `R(${key},${priKey.kt},${priKey.pk})`;\n  } else {\n    const comKey = ref;\n    return `R(${key},${JSON.stringify(comKey)})`;\n  }\n};\nvar abbrevAgg = (key, agg) => {\n  return `A(${key},${abbrevQuery(agg)})`;\n};\nvar abbrevCompoundCondition = (compoundCondition) => {\n  return `CC(${compoundCondition.compoundType},${compoundCondition.conditions ? compoundCondition.conditions.map(abbrevCondition).join(\",\") : \"No Conditions\"})`;\n};\nvar abbrevCondition = (condition) => {\n  if (isCondition(condition)) {\n    return `(${condition.column},${condition.value},${condition.operator})`;\n  } else {\n    return abbrevCompoundCondition(condition);\n  }\n};\n\n// src/item/IUtils.ts\nvar logger4 = logger_default.get(\"IUtils\");\nvar validatePKForItem = (item, pkType) => {\n  if (!item) {\n    logger4.error(\"Validating PK, Item is undefined\", { item });\n    throw new Error(\"Validating PK, Item is undefined\");\n  }\n  if (!item.key) {\n    logger4.error(\"Validating PK, Item does not have a key\", { item });\n    throw new Error(\"Validating PK, Item does not have a key\");\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray[0] !== pkType) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, pkType });\n    throw new Error(`Item does not have the correct primary key type. Expected ${pkType}, got ${keyTypeArray[0]}`);\n  }\n  return item;\n};\nvar validatePK = (input, pkType) => {\n  logger4.trace(\"Checking Return Type\", { input });\n  if (Array.isArray(input)) {\n    return input.map((item) => validatePKForItem(item, pkType));\n  }\n  return validatePKForItem(input, pkType);\n};\nvar validateKeys = (item, keyTypes) => {\n  logger4.trace(\"Checking Return Type\", { item });\n  if (!item) {\n    throw new Error(\"validating keys, item is undefined\");\n  }\n  if (!item.key) {\n    throw new Error(\"validating keys, item does not have a key: \" + JSON.stringify(item));\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray.length !== keyTypes.length) {\n    throw new Error(`Item does not have the correct number of keys. Expected ${keyTypes.length}, but got ${keyTypeArray.length}`);\n  }\n  const match = JSON.stringify(keyTypeArray) === JSON.stringify(keyTypes);\n  if (!match) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, thisKeyTypes: keyTypes });\n    throw new Error(`Item does not have the correct key types. Expected [${keyTypes.join(\", \")}], but got [${keyTypeArray.join(\", \")}]`);\n  }\n  return item;\n};\nvar isPriItem = (item) => {\n  return !!(item && item.key && isPriKey(item.key));\n};\nvar isComItem = (item) => {\n  return !!(item && item.key && isComKey(item.key));\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9AZmplbGwvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNxQztBQUNyQyxnQkFBZ0IsZ0VBQWlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFVBQVU7QUFDVixnRkFBZ0YsV0FBVztBQUMzRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQsMENBQTBDLG9CQUFvQixJQUFJLG9CQUFvQjtBQUN0RjtBQUNBLHNCQUFzQixr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QUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQy9IO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzQ0FBc0M7QUFDckYsMkVBQTJFLG9CQUFvQixjQUFjLHdCQUF3QjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnREU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9AZmplbGwvY29yZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9sb2dnZXIudHNcbmltcG9ydCBMb2dnaW5nIGZyb20gXCJAZmplbGwvbG9nZ2luZ1wiO1xudmFyIExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKFwiQGZqZWxsL2NvcmVcIik7XG52YXIgbG9nZ2VyX2RlZmF1bHQgPSBMaWJMb2dnZXI7XG5cbi8vIHNyYy9kaWN0aW9uYXJ5LnRzXG52YXIgbG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiRGljdGlvbmFyeVwiKTtcbnZhciBEaWN0aW9uYXJ5ID0gY2xhc3MgX0RpY3Rpb25hcnkge1xuICBtYXAgPSB7fTtcbiAgaGFzaEZ1bmN0aW9uID0gKGtleSkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgY29uc3RydWN0b3IobWFwLCBoYXNoRnVuY3Rpb24pIHtcbiAgICBpZiAoaGFzaEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLmhhc2hGdW5jdGlvbiA9IGhhc2hGdW5jdGlvbjtcbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgT2JqZWN0LmVudHJpZXMobWFwKS5mb3JFYWNoKChbaGFzaGVkS2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbEtleSA9IEpTT04ucGFyc2UoaGFzaGVkS2V5KTtcbiAgICAgICAgICB0aGlzLm1hcFtoYXNoZWRLZXldID0geyBvcmlnaW5hbEtleSwgdmFsdWUgfTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgbG9nZ2VyLndhcm5pbmcoXCJDYW5ub3QgcmVjb3ZlciBvcmlnaW5hbCBrZXkgZnJvbSBsZWdhY3kgbWFwIGVudHJ5XCIsIHsgaGFzaGVkS2V5IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2V0KGtleSwgaXRlbSkge1xuICAgIGxvZ2dlci50cmFjZShcInNldFwiLCB7IGtleSwgaXRlbSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7IG9yaWdpbmFsS2V5OiBrZXksIHZhbHVlOiBpdGVtIH07XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGxvZ2dlci50cmFjZShcImdldFwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICByZXR1cm4gZW50cnkgJiYgdGhpcy5rZXlzRXF1YWwoZW50cnkub3JpZ2luYWxLZXksIGtleSkgPyBlbnRyeS52YWx1ZSA6IG51bGw7XG4gIH1cbiAga2V5c0VxdWFsKGtleTEsIGtleTIpIHtcbiAgICByZXR1cm4ga2V5MSA9PT0ga2V5MjtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiZGVsZXRlXCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgZGVsZXRlIHRoaXMubWFwW2hhc2hlZEtleV07XG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkubWFwKChlbnRyeSkgPT4gZW50cnkub3JpZ2luYWxLZXkpO1xuICB9XG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkubWFwKChlbnRyeSkgPT4gZW50cnkudmFsdWUpO1xuICB9XG4gIGluY2x1ZGVzS2V5KGtleSkge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiBlbnRyeSA/IHRoaXMua2V5c0VxdWFsKGVudHJ5Lm9yaWdpbmFsS2V5LCBrZXkpIDogZmFsc2U7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmVkTWFwID0ge307XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5tYXApLmZvckVhY2goKFtoYXNoZWRLZXksIGVudHJ5XSkgPT4ge1xuICAgICAgY2xvbmVkTWFwW2hhc2hlZEtleV0gPSBlbnRyeS52YWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBfRGljdGlvbmFyeShjbG9uZWRNYXAsIHRoaXMuaGFzaEZ1bmN0aW9uKTtcbiAgICBjbG9uZS5tYXAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1hcCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59O1xuXG4vLyBzcmMvaXRlbS9JRmFjdG9yeS50c1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tIFwiZGVlcG1lcmdlXCI7XG5cbi8vIHNyYy9rZXkvS1V0aWxzLnRzXG52YXIgbG9nZ2VyMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIktVdGlsc1wiKTtcbnZhciBub3JtYWxpemVLZXlWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn07XG52YXIgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIChrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGtleSkpO1xuICAgICAgaWYgKFwicGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIChub3JtYWxpemVkS2V5LnBrICE9PSB2b2lkIDAgJiYgbm9ybWFsaXplZEtleS5wayAhPT0gbnVsbCkpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5wayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWRLZXkucGspO1xuICAgICAgfVxuICAgICAgaWYgKFwibGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIChub3JtYWxpemVkS2V5LmxrICE9PSB2b2lkIDAgJiYgbm9ybWFsaXplZEtleS5sayAhPT0gbnVsbCkpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5sayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWRLZXkubGspO1xuICAgICAgfVxuICAgICAgaWYgKFwibG9jXCIgaW4gbm9ybWFsaXplZEtleSAmJiBBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRLZXkubG9jKSkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxvYyA9IG5vcm1hbGl6ZWRLZXkubG9jLm1hcCgobG9jSXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChsb2NJdGVtICYmIFwibGtcIiBpbiBsb2NJdGVtICYmIChsb2NJdGVtLmxrICE9PSB2b2lkIDAgJiYgbG9jSXRlbS5sayAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmxvY0l0ZW0sIGxrOiBub3JtYWxpemVLZXlWYWx1ZShsb2NJdGVtLmxrKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9jSXRlbTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZEtleSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICB9O1xufTtcbnZhciBpc1ByaUtleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc1ByaUtleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgbm9ybWFsaXplS2V5VmFsdWUoYS5waykgPT09IG5vcm1hbGl6ZUtleVZhbHVlKGIucGspICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzTG9jS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzTG9jS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBub3JtYWxpemVLZXlWYWx1ZShhLmxrKSA9PT0gbm9ybWFsaXplS2V5VmFsdWUoYi5saykgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICBpZiAoYSAmJiBiICYmIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkKHsga3Q6IGEua3QsIHBrOiBhLnBrIH0sIHsga3Q6IGIua3QsIHBrOiBiLnBrIH0pKSB7XG4gICAgaWYgKGEubG9jLmxlbmd0aCA9PT0gYi5sb2MubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQoYS5sb2NbaV0sIGIubG9jW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzSXRlbUtleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICBpZiAoaXNDb21LZXkoYSkgJiYgaXNDb21LZXkoYikpIHtcbiAgICByZXR1cm4gaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWQoYSwgYik7XG4gIH0gZWxzZSBpZiAoaXNQcmlLZXkoYSkgJiYgaXNQcmlLZXkoYikpIHtcbiAgICBpZiAoaXNDb21LZXkoYSkgfHwgaXNDb21LZXkoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkKGEsIGIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNJdGVtS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNLZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIGlmIChpc0NvbUtleShhKSAmJiBpc0NvbUtleShiKSkge1xuICAgIHJldHVybiBpc0NvbUtleUVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKGlzUHJpS2V5KGEpICYmIGlzUHJpS2V5KGIpKSB7XG4gICAgaWYgKGlzQ29tS2V5KGEpIHx8IGlzQ29tS2V5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc1ByaUtleUVxdWFsKGEsIGIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNQcmlLZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc1ByaUtleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJiBhLnBrID09PSBiLnBrICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzTG9jS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNMb2NLZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgYS5sayA9PT0gYi5sayAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0NvbUtleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzQ29tS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICBpZiAoYSAmJiBiICYmIGlzUHJpS2V5RXF1YWwoeyBrdDogYS5rdCwgcGs6IGEucGsgfSwgeyBrdDogYi5rdCwgcGs6IGIucGsgfSkpIHtcbiAgICBpZiAoYS5sb2MubGVuZ3RoID09PSBiLmxvYy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0xvY0tleUVxdWFsKGEubG9jW2ldLCBiLmxvY1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0l0ZW1LZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0l0ZW1LZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoaXNDb21LZXkoa2V5KSB8fCBpc1ByaUtleShrZXkpKTtcbn07XG52YXIgaXNDb21LZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0NvbUtleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChrZXkucGsgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IHZvaWQgMCkgJiYgKGtleS5sb2MgIT09IHZvaWQgMCAmJiBrZXkubG9jLmxlbmd0aCA+IDApO1xufTtcbnZhciBpc1ByaUtleSA9IChrZXkpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzUHJpS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGtleS5wayAhPT0gdm9pZCAwICYmIGtleS5rdCAhPT0gdm9pZCAwKSAmJiAoa2V5LmxvYyA9PT0gdm9pZCAwIHx8IGtleS5sb2MubGVuZ3RoID09PSAwKTtcbn07XG52YXIgaXNMb2NLZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0xvY0tleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChrZXkubGsgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IHZvaWQgMCk7XG59O1xudmFyIGdlbmVyYXRlS2V5QXJyYXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJnZW5lcmF0ZUtleUFycmF5XCIsIHsga2V5IH0pO1xuICBjb25zdCBrZXlzID0gW107XG4gIGlmIChpc0NvbUtleShrZXkpIHx8IGlzUHJpS2V5KGtleSkpIHtcbiAgICBpZiAoaXNDb21LZXkoa2V5KSkge1xuICAgICAgY29uc3QgY29tS2V5ID0ga2V5O1xuICAgICAga2V5cy5wdXNoKHsgcGs6IGNvbUtleS5waywga3Q6IGNvbUtleS5rdCB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tS2V5LmxvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXlzLnB1c2goY29tS2V5LmxvY1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsb2NLZXlzID0ga2V5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKGxvY0tleXNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG52YXIgY29uc3RydWN0UHJpS2V5ID0gKHBrLCBrdCkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiY29uc3RydWN0UHJpS2V5XCIsIHsgcGssIGt0IH0pO1xuICBsZXQgcHJpO1xuICBpZiAodHlwZW9mIHBrID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwayA9PT0gXCJudW1iZXJcIikge1xuICAgIHByaSA9IHsga3QsIHBrIH07XG4gIH0gZWxzZSB7XG4gICAgcHJpID0gcGs7XG4gIH1cbiAgcmV0dXJuIHByaTtcbn07XG52YXIgY1BLID0gY29uc3RydWN0UHJpS2V5O1xudmFyIHRvS2V5VHlwZUFycmF5ID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJ0b0tleVR5cGVBcnJheVwiLCB7IGlrIH0pO1xuICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgY29uc3QgY2sgPSBpaztcbiAgICByZXR1cm4gW2NrLmt0LCAuLi5jay5sb2MubWFwKChsKSA9PiBsLmt0KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtpay5rdF07XG4gIH1cbn07XG52YXIgYWJicmV2SUsgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImFiYnJldklLXCIsIHsgaWsgfSk7XG4gIGlmIChpaykge1xuICAgIGlmIChpc0NvbUtleShpaykpIHtcbiAgICAgIGNvbnN0IGNrID0gaWs7XG4gICAgICByZXR1cm4gYCR7Y2sua3R9OiR7Y2sucGt9OiR7Y2subG9jLm1hcCgobCkgPT4gYCR7bC5rdH06JHtsLmxrfWApLmpvaW4oXCIsXCIpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtpay5rdH06JHtpay5wa31gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJudWxsIElLXCI7XG4gIH1cbn07XG52YXIgYWJicmV2TEtBID0gKGtleUFycmF5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJhYmJyZXZMS0FcIiwgeyBrZXlBcnJheSB9KTtcbiAgaWYgKGtleUFycmF5ID09PSB2b2lkIDAgfHwga2V5QXJyYXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsIExLQVwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlBcnJheS5tYXAoKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICByZXR1cm4gYCR7a2V5Lmt0fToke2tleS5sa31gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9KS5qb2luKFwiLFwiKTtcbiAgfVxufTtcbnZhciBwcmltYXJ5VHlwZSA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwicHJpbWFyeVR5cGVcIiwgeyBpayB9KTtcbiAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgIHJldHVybiBpay5rdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaWsua3Q7XG4gIH1cbn07XG52YXIgaXRlbUtleVRvTG9jS2V5QXJyYXkgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcIml0ZW1LZXlUb0xvY0tleUFycmF5XCIsIHsgaWs6IGFiYnJldklLKGlrKSB9KTtcbiAgbGV0IGxrYSA9IFtdO1xuICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgY29uc3QgY2sgPSBpaztcbiAgICBsa2EgPSBbeyBrdDogY2sua3QsIGxrOiBjay5wayB9LCAuLi5jay5sb2NdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBrID0gaWs7XG4gICAgbGthID0gW3sga3Q6IHBrLmt0LCBsazogcGsucGsgfV07XG4gIH1cbiAgbG9nZ2VyMi50cmFjZShcIml0ZW1LZXlUb0xvY0tleUFycmF5IFJlc3VsdHNcIiwgeyBpazogYWJicmV2SUsoaWspLCBsa2E6IGFiYnJldkxLQShsa2EpIH0pO1xuICByZXR1cm4gbGthO1xufTtcbnZhciBpa1RvTEtBID0gaXRlbUtleVRvTG9jS2V5QXJyYXk7XG52YXIgbG9jS2V5QXJyYXlUb0l0ZW1LZXkgPSAobGthKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJsb2NLZXlBcnJheVRvSXRlbUtleVwiLCB7IGxrYTogYWJicmV2TEtBKGxrYSkgfSk7XG4gIGlmIChsa2EgJiYgbGthLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHByaUtleSA9IGNQSyhsa2FbMF0ubGssIGxrYVswXS5rdCk7XG4gICAgcmV0dXJuIHByaUtleTtcbiAgfSBlbHNlIGlmIChsa2EgJiYgbGthLmxlbmd0aCA+IDEgJiYgbGthWzBdICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBsb2NzID0gbGthLnNsaWNlKDEpO1xuICAgIGNvbnN0IHByaUtleSA9IGNQSyhsa2FbMF0ubGssIGxrYVswXS5rdCk7XG4gICAgY29uc3QgY29tS2V5ID0geyBrdDogcHJpS2V5Lmt0LCBwazogcHJpS2V5LnBrLCBsb2M6IGxvY3MgfTtcbiAgICByZXR1cm4gY29tS2V5O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvY0tleUFycmF5VG9JdGVtS2V5OiBsa2EgaXMgdW5kZWZpbmVkIG9yIGVtcHR5XCIpO1xuICB9XG59O1xudmFyIGlzVmFsaWRQcmlLZXkgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IHZhbGlkID0ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSBudWxsICYmIChrZXkucGsgIT09IHZvaWQgMCAmJiBrZXkucGsgIT09IG51bGwgJiYga2V5LnBrICE9PSBcIlwiICYmIGtleS5wayAhPT0gXCJudWxsXCIpICYmIChrZXkua3QgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IG51bGwgJiYga2V5Lmt0ICE9PSBcIlwiICYmIGtleS5rdCAhPT0gXCJudWxsXCIpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xudmFyIGlzVmFsaWRMb2NLZXkgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IHZhbGlkID0ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSBudWxsICYmIChrZXkubGsgIT09IHZvaWQgMCAmJiBrZXkubGsgIT09IG51bGwgJiYga2V5LmxrICE9PSBcIlwiICYmIGtleS5sayAhPT0gXCJudWxsXCIpICYmIChrZXkua3QgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IG51bGwgJiYga2V5Lmt0ICE9PSBcIlwiICYmIGtleS5rdCAhPT0gXCJudWxsXCIpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xudmFyIGlzVmFsaWRMb2NLZXlBcnJheSA9IChrZXlBcnJheSkgPT4ge1xuICByZXR1cm4ga2V5QXJyYXkgIT09IHZvaWQgMCAmJiBrZXlBcnJheSAhPT0gbnVsbCAmJiBrZXlBcnJheS5ldmVyeShpc1ZhbGlkTG9jS2V5KTtcbn07XG52YXIgaXNWYWxpZENvbUtleSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gbnVsbCAmJiBpc1ZhbGlkUHJpS2V5KGtleSkgJiYgaXNWYWxpZExvY0tleUFycmF5KGtleS5sb2MpO1xufTtcbnZhciBpc1ZhbGlkSXRlbUtleSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIGlzQ29tS2V5KGtleSkgJiYgaXNWYWxpZENvbUtleShrZXkpIHx8IGlzUHJpS2V5KGtleSkgJiYgaXNWYWxpZFByaUtleShrZXkpO1xufTtcbnZhciBsa2FUb0lLID0gbG9jS2V5QXJyYXlUb0l0ZW1LZXk7XG5cbi8vIHNyYy9pdGVtL0lGYWN0b3J5LnRzXG52YXIgSUZhY3RvcnkgPSBjbGFzcyBfSUZhY3Rvcnkge1xuICBpdGVtID0ge307XG4gIGNvbnN0cnVjdG9yKHByb3BzID0ge30pIHtcbiAgICB0aGlzLml0ZW0gPSBkZWVwbWVyZ2UodGhpcy5pdGVtLCBwcm9wcyk7XG4gIH1cbiAgYWRkUmVmKGksIG5hbWUpIHtcbiAgICBjb25zdCBpayA9IGkua2V5O1xuICAgIGNvbnN0IHJlZk5hbWUgPSBuYW1lIHx8IHByaW1hcnlUeXBlKGlrKTtcbiAgICBpZiAoIXRoaXMuaXRlbS5yZWZzKSB7XG4gICAgICB0aGlzLml0ZW0ucmVmcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLml0ZW0ucmVmc1tyZWZOYW1lXSA9IGlrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRSZWYoaSwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkUmVmKGksIG5hbWUpO1xuICB9XG4gIGFkZERlZmF1bHRFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzID0ge307XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cy5jcmVhdGVkKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzLmNyZWF0ZWQgPSB7IGF0OiBub3cgfTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzLnVwZGF0ZWQpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMudXBkYXRlZCA9IHsgYXQ6IG5vdyB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMuZGVsZXRlZCkge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cy5kZWxldGVkID0geyBhdDogbnVsbCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRFdmVudChuYW1lLCBhdCwgYnkpIHtcbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLmV2ZW50c1tuYW1lXSA9IHsgYXQsIGJ5IH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZEV2ZW50KG5hbWUsIGF0LCBieSkge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkRXZlbnQobmFtZSwgYXQsIGJ5KTtcbiAgfVxuICBhZGRQcm9wKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5pdGVtW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFkZFByb3AobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZFByb3AobmFtZSwgdmFsdWUpO1xuICB9XG4gIGFkZFByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5pdGVtID0gZGVlcG1lcmdlKHRoaXMuaXRlbSwgcHJvcHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBuZXcgX0lGYWN0b3J5KCkuYWRkUHJvcHMocHJvcHMpO1xuICB9XG4gIHRvSXRlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtO1xuICB9XG59O1xuXG4vLyBzcmMvQUl0ZW1TZXJ2aWNlLnRzXG52YXIgQUl0ZW1TZXJ2aWNlID0gY2xhc3Mge1xuICBwa1R5cGU7XG4gIHBhcmVudFNlcnZpY2UgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihwa1R5cGUsIHBhcmVudFNlcnZpY2UpIHtcbiAgICB0aGlzLnBrVHlwZSA9IHBrVHlwZTtcbiAgICBpZiAocGFyZW50U2VydmljZSkge1xuICAgICAgdGhpcy5wYXJlbnRTZXJ2aWNlID0gcGFyZW50U2VydmljZTtcbiAgICB9XG4gIH1cbiAgZ2V0UGtUeXBlID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnBrVHlwZTtcbiAgfTtcbiAgZ2V0S2V5VHlwZXMgPSAoKSA9PiB7XG4gICAgbGV0IGtleVR5cGVzID0gW3RoaXMuZ2V0UGtUeXBlKCldO1xuICAgIGlmICh0aGlzLnBhcmVudFNlcnZpY2UpIHtcbiAgICAgIGtleVR5cGVzID0ga2V5VHlwZXMuY29uY2F0KHRoaXMucGFyZW50U2VydmljZS5nZXRLZXlUeXBlcygpKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVR5cGVzO1xuICB9O1xufTtcblxuLy8gc3JjL2l0ZW0vSXRlbVF1ZXJ5LnRzXG52YXIgaXNDb25kaXRpb24gPSAoY29uZGl0aW9uKSA9PiB7XG4gIHJldHVybiAodHlwZW9mIGNvbmRpdGlvbi5jb2x1bW4gPT09IFwic3RyaW5nXCIgJiYgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uLnZhbHVlKSAmJiBjb25kaXRpb24udmFsdWUuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSkgfHwgQXJyYXkuaXNBcnJheShjb25kaXRpb24udmFsdWUpICYmIGNvbmRpdGlvbi52YWx1ZS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwibnVtYmVyXCIpIHx8IHR5cGVvZiBjb25kaXRpb24udmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNvbmRpdGlvbi52YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29uZGl0aW9uLnZhbHVlID09PSBcImJvb2xlYW5cIiB8fCBjb25kaXRpb24udmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAoY29uZGl0aW9uLm9wZXJhdG9yID8gdHlwZW9mIGNvbmRpdGlvbi5vcGVyYXRvciA9PT0gXCJzdHJpbmdcIiA6IHRydWUpO1xufTtcblxuLy8gc3JjL2l0ZW0vSVFGYWN0b3J5LnRzXG52YXIgSVFGYWN0b3J5ID0gY2xhc3MgX0lRRmFjdG9yeSB7XG4gIHF1ZXJ5ID0ge307XG4gIGNvbnN0cnVjdG9yKHF1ZXJ5ID0ge30pIHtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gIH1cbiAgb3JkZXJCeShmaWVsZCwgZGlyZWN0aW9uID0gXCJhc2NcIikge1xuICAgIGlmICghdGhpcy5xdWVyeS5vcmRlckJ5KSB7XG4gICAgICB0aGlzLnF1ZXJ5Lm9yZGVyQnkgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeS5vcmRlckJ5LnB1c2goeyBmaWVsZCwgZGlyZWN0aW9uIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFnZyhuYW1lLCBxdWVyeSkge1xuICAgIGlmICghdGhpcy5xdWVyeS5hZ2dzKSB7XG4gICAgICB0aGlzLnF1ZXJ5LmFnZ3MgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeS5hZ2dzW25hbWVdID0gcXVlcnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZXZlbnQobmFtZSwgcXVlcnkpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkuZXZlbnRzKSB7XG4gICAgICB0aGlzLnF1ZXJ5LmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5LmV2ZW50c1tuYW1lXSA9IHF1ZXJ5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbmRpdGlvbnMoY29uZGl0aW9ucywgY29tcG91bmRUeXBlID0gXCJBTkRcIikge1xuICAgIGZvciAoY29uc3QgY29uZGl0aW9uIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgIGlmICghaXNDb25kaXRpb24oY29uZGl0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29uZGl0aW9uOiAke0pTT04uc3RyaW5naWZ5KGNvbmRpdGlvbil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbikge1xuICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbiA9IHtcbiAgICAgICAgY29tcG91bmRUeXBlLFxuICAgICAgICBjb25kaXRpb25zXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21wb3VuZENvbmRpdGlvbiA9IHtcbiAgICAgICAgY29tcG91bmRUeXBlLFxuICAgICAgICBjb25kaXRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zLnB1c2goY29tcG91bmRDb25kaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaW1pdChsaW1pdCkge1xuICAgIHRoaXMucXVlcnkubGltaXQgPSBsaW1pdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvZmZzZXQob2Zmc2V0KSB7XG4gICAgdGhpcy5xdWVyeS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gVE9ETzogcmlnaHQgbm93LCB3ZSdyZSBvbmx5IHN1cHBvcnRpbmcgUEsgcmVmcyBmb3IgcXVlcmllcy4gIFNob3VsZCBhZGQgc3VwcG9ydCBmb3IgQ0tzXG4gIHBrKGt0LCBwaywgbmFtZSkge1xuICAgIGlmICghdGhpcy5xdWVyeS5yZWZzKSB7XG4gICAgICB0aGlzLnF1ZXJ5LnJlZnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcmVmTmFtZSA9IG5hbWUgfHwga3Q7XG4gICAgdGhpcy5xdWVyeS5yZWZzW3JlZk5hbWVdID0gY1BLKHBrLCBrdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29uZGl0aW9uKGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yID0gXCI9PVwiKSB7XG4gICAgY29uc3QgY29uZGl0aW9uID0geyBjb2x1bW4sIHZhbHVlLCBvcGVyYXRvciB9O1xuICAgIGlmIChpc0NvbmRpdGlvbihjb25kaXRpb24pKSB7XG4gICAgICBpZiAoIXRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbiA9IHtcbiAgICAgICAgICBjb21wb3VuZFR5cGU6IFwiQU5EXCIsXG4gICAgICAgICAgY29uZGl0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbmRpdGlvbjogJHtKU09OLnN0cmluZ2lmeShjb25kaXRpb24pfWApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYWxsKCkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeTtcbiAgfVxuICBzdGF0aWMgb3JkZXJCeShmaWVsZCwgZGlyZWN0aW9uID0gXCJhc2NcIikge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5vcmRlckJ5KGZpZWxkLCBkaXJlY3Rpb24pO1xuICB9XG4gIHN0YXRpYyBhZ2cobmFtZSwgcXVlcnkpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuYWdnKG5hbWUsIHF1ZXJ5KTtcbiAgfVxuICBzdGF0aWMgZXZlbnQobmFtZSwgcXVlcnkpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuZXZlbnQobmFtZSwgcXVlcnkpO1xuICB9XG4gIHN0YXRpYyBsaW1pdChsaW1pdCkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5saW1pdChsaW1pdCk7XG4gIH1cbiAgc3RhdGljIG9mZnNldChvZmZzZXQpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3Rvcnkub2Zmc2V0KG9mZnNldCk7XG4gIH1cbiAgc3RhdGljIHBrKGt0LCBwaywgbmFtZSkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5wayhrdCwgcGssIG5hbWUpO1xuICB9XG4gIHN0YXRpYyBjb25kaXRpb24oY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IgPSBcIj09XCIpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuY29uZGl0aW9uKGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgfVxuICBzdGF0aWMgY29uZGl0aW9ucyhjb25kaXRpb25zLCBjb21wb3VuZFR5cGUgPSBcIkFORFwiKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmNvbmRpdGlvbnMoY29uZGl0aW9ucywgY29tcG91bmRUeXBlKTtcbiAgfVxuICB0b1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5O1xuICB9XG59O1xuXG4vLyBzcmMvaXRlbS9JUVV0aWxzLnRzXG5pbXBvcnQgKiBhcyBsdXhvbiBmcm9tIFwibHV4b25cIjtcbnZhciBsb2dnZXIzID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSVFVdGlsc1wiKTtcbnZhciBxdWVyeVRvUGFyYW1zID0gKHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHt9O1xuICBpZiAocXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICBwYXJhbXMuY29tcG91bmRDb25kaXRpb24gPSBKU09OLnN0cmluZ2lmeShxdWVyeS5jb21wb3VuZENvbmRpdGlvbik7XG4gIH1cbiAgaWYgKHF1ZXJ5LnJlZnMpIHtcbiAgICBwYXJhbXMucmVmcyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LnJlZnMpO1xuICB9XG4gIGlmIChxdWVyeS5saW1pdCkge1xuICAgIHBhcmFtcy5saW1pdCA9IHF1ZXJ5LmxpbWl0O1xuICB9XG4gIGlmIChxdWVyeS5vZmZzZXQpIHtcbiAgICBwYXJhbXMub2Zmc2V0ID0gcXVlcnkub2Zmc2V0O1xuICB9XG4gIGlmIChxdWVyeS5hZ2dzKSB7XG4gICAgcGFyYW1zLmFnZ3MgPSBKU09OLnN0cmluZ2lmeShxdWVyeS5hZ2dzKTtcbiAgfVxuICBpZiAocXVlcnkuZXZlbnRzKSB7XG4gICAgcGFyYW1zLmV2ZW50cyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LmV2ZW50cyk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn07XG52YXIgZGF0ZVRpbWVSZXZpdmVyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0ZSA9IGx1eG9uLkRhdGVUaW1lLmZyb21JU08odmFsdWUpO1xuICAgIGlmIChwYXJzZWREYXRlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWREYXRlLnRvSlNEYXRlKCk7XG4gICAgICA7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgcGFyYW1zVG9RdWVyeSA9IChwYXJhbXMpID0+IHtcbiAgY29uc3QgcXVlcnkgPSB7fTtcbiAgaWYgKHBhcmFtcy5jb21wb3VuZENvbmRpdGlvbikge1xuICAgIHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uID0gSlNPTi5wYXJzZShwYXJhbXMuY29tcG91bmRDb25kaXRpb24pO1xuICB9XG4gIGlmIChwYXJhbXMucmVmcykge1xuICAgIHF1ZXJ5LnJlZnMgPSBKU09OLnBhcnNlKHBhcmFtcy5yZWZzKTtcbiAgfVxuICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgcXVlcnkubGltaXQgPSBOdW1iZXIocGFyYW1zLmxpbWl0KTtcbiAgfVxuICBpZiAocGFyYW1zLm9mZnNldCkge1xuICAgIHF1ZXJ5Lm9mZnNldCA9IE51bWJlcihwYXJhbXMub2Zmc2V0KTtcbiAgfVxuICBpZiAocGFyYW1zLmFnZ3MpIHtcbiAgICBxdWVyeS5hZ2dzID0gSlNPTi5wYXJzZShwYXJhbXMuYWdncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5ldmVudHMpIHtcbiAgICBxdWVyeS5ldmVudHMgPSBKU09OLnBhcnNlKHBhcmFtcy5ldmVudHMsIGRhdGVUaW1lUmV2aXZlcik7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcbnZhciBpc1JlZlF1ZXJ5TWF0Y2ggPSAocmVmS2V5LCBxdWVyeVJlZiwgcmVmZXJlbmNlcykgPT4ge1xuICBsb2dnZXIzLnRyYWNlKFwiZG9lc1JlZk1hdGNoXCIsIHsgcXVlcnlSZWYsIHJlZmVyZW5jZXMgfSk7XG4gIGxvZ2dlcjMuZGVidWcoXCJDb21wYXJpbmcgUmVmXCIsIHsgcmVmS2V5LCBpdGVtUmVmOiByZWZlcmVuY2VzW3JlZktleV0sIHF1ZXJ5UmVmIH0pO1xuICByZXR1cm4gaXNJdGVtS2V5RXF1YWwocXVlcnlSZWYsIHJlZmVyZW5jZXNbcmVmS2V5XSk7XG59O1xudmFyIGlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoID0gKHF1ZXJ5Q29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gIGlmIChxdWVyeUNvbmRpdGlvbi5jb21wb3VuZFR5cGUgPT09IFwiQU5EXCIpIHtcbiAgICByZXR1cm4gcXVlcnlDb25kaXRpb24uY29uZGl0aW9ucy5ldmVyeShcbiAgICAgIChjb25kaXRpb24pID0+IGlzQ29uZGl0aW9uKGNvbmRpdGlvbikgPyBpc0NvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKSA6IGlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBxdWVyeUNvbmRpdGlvbi5jb25kaXRpb25zLnNvbWUoXG4gICAgICAoY29uZGl0aW9uKSA9PiBpc0NvbmRpdGlvbihjb25kaXRpb24pID8gaXNDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSkgOiBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pXG4gICAgKTtcbiAgfVxufTtcbnZhciBpc0NvbmRpdGlvblF1ZXJ5TWF0Y2ggPSAocXVlcnlDb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgY29uc3QgcHJvcEtleSA9IHF1ZXJ5Q29uZGl0aW9uLmNvbHVtbjtcbiAgbG9nZ2VyMy50cmFjZShcImRvZXNDb25kaXRpb25NYXRjaFwiLCB7IHByb3BLZXksIHF1ZXJ5Q29uZGl0aW9uLCBpdGVtIH0pO1xuICBpZiAoaXRlbVtwcm9wS2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZG9lcyBub3QgY29udGFpbiBwcm9wIHVuZGVyIGtleVwiLCB7IHByb3BLZXksIGl0ZW0gfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxvZ2dlcjMuZGVidWcoXCJDb21wYXJpbmcgQ29uZGl0aW9uXCIsIHsgcHJvcEtleSwgaXRlbVByb3A6IGl0ZW1bcHJvcEtleV0sIHF1ZXJ5Q29uZGl0aW9uIH0pO1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIHN3aXRjaCAocXVlcnlDb25kaXRpb24ub3BlcmF0b3IpIHtcbiAgICBjYXNlIFwiPT1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPT09IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiE9XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldICE9PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI+XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldID4gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPj1cIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPj0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPFwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA8IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIjw9XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldIDw9IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImluXCI6XG4gICAgICByZXN1bHQgPSBxdWVyeUNvbmRpdGlvbi52YWx1ZS5pbmNsdWRlcyhpdGVtW3Byb3BLZXldKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub3QtaW5cIjpcbiAgICAgIHJlc3VsdCA9ICFxdWVyeUNvbmRpdGlvbi52YWx1ZS5pbmNsdWRlcyhpdGVtW3Byb3BLZXldKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhcnJheS1jb250YWluc1wiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XS5pbmNsdWRlcyhxdWVyeUNvbmRpdGlvbi52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCI6XG4gICAgICByZXN1bHQgPSBxdWVyeUNvbmRpdGlvbi52YWx1ZS5zb21lKCh2YWx1ZSkgPT4gaXRlbVtwcm9wS2V5XS5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgaXNBZ2dRdWVyeU1hdGNoID0gKGFnZ0tleSwgYWdnUXVlcnksIGFnZykgPT4ge1xuICBjb25zdCBhZ2dJdGVtID0gYWdnLml0ZW07XG4gIGxvZ2dlcjMuZGVidWcoXCJDb21wYXJpbmcgQWdnXCIsIHsgYWdnS2V5LCBhZ2dJdGVtLCBhZ2dRdWVyeSB9KTtcbiAgcmV0dXJuIGlzUXVlcnlNYXRjaChhZ2dJdGVtLCBhZ2dRdWVyeSk7XG59O1xudmFyIGlzRXZlbnRRdWVyeU1hdGNoID0gKGV2ZW50S2V5LCBldmVudFF1ZXJ5LCBpdGVtKSA9PiB7XG4gIGlmICghaXRlbS5ldmVudHNbZXZlbnRLZXldKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZG9lcyBub3QgY29udGFpbiBldmVudCB1bmRlciBrZXlcIiwgeyBldmVudEtleSwgZXZlbnRzOiBpdGVtLmV2ZW50cyB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaXRlbUV2ZW50ID0gaXRlbS5ldmVudHNbZXZlbnRLZXldO1xuICAgIGlmIChpdGVtRXZlbnQuYXQgIT09IG51bGwpIHtcbiAgICAgIGlmIChldmVudFF1ZXJ5LnN0YXJ0ICYmICEoZXZlbnRRdWVyeS5zdGFydC5nZXRUaW1lKCkgPD0gaXRlbUV2ZW50LmF0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgbG9nZ2VyMy5kZWJ1ZyhcIkl0ZW0gZGF0ZSBiZWZvcmUgZXZlbnQgc3RhcnQgcXVlcnlcIiwgeyBldmVudFF1ZXJ5LCBpdGVtRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudFF1ZXJ5LmVuZCAmJiAhKGV2ZW50UXVlcnkuZW5kLmdldFRpbWUoKSA+IGl0ZW1FdmVudC5hdC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRhdGUgYWZ0ZXIgZXZlbnQgZW5kIHF1ZXJ5XCIsIHsgZXZlbnRRdWVyeSwgaXRlbUV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGV2ZW50IGRvZXMgY29udGFpbnMgYSBudWxsIGF0XCIsIHsgaXRlbUV2ZW50IH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBpc1F1ZXJ5TWF0Y2ggPSAoaXRlbSwgcXVlcnkpID0+IHtcbiAgbG9nZ2VyMy50cmFjZShcImlzTWF0Y2hcIiwgeyBpdGVtLCBxdWVyeSB9KTtcbiAgaWYgKHF1ZXJ5LnJlZnMgJiYgaXRlbS5yZWZzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkucmVmcykge1xuICAgICAgY29uc3QgcXVlcnlSZWYgPSBxdWVyeS5yZWZzW2tleV07XG4gICAgICBpZiAoIWlzUmVmUXVlcnlNYXRjaChrZXksIHF1ZXJ5UmVmLCBpdGVtLnJlZnMpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKHF1ZXJ5LnJlZnMgJiYgIWl0ZW0ucmVmcykge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJRdWVyeSBjb250YWlucyByZWZzIGJ1dCBpdGVtIGRvZXMgbm90IGhhdmUgcmVmc1wiLCB7IHF1ZXJ5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocXVlcnkuY29tcG91bmRDb25kaXRpb24gJiYgaXRlbSkge1xuICAgIGlmICghaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2gocXVlcnkuY29tcG91bmRDb25kaXRpb24sIGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHF1ZXJ5LmV2ZW50cyAmJiBpdGVtLmV2ZW50cykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LmV2ZW50cykge1xuICAgICAgY29uc3QgcXVlcnlFdmVudCA9IHF1ZXJ5LmV2ZW50c1trZXldO1xuICAgICAgaWYgKCFpc0V2ZW50UXVlcnlNYXRjaChrZXksIHF1ZXJ5RXZlbnQsIGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChxdWVyeS5hZ2dzICYmIGl0ZW0uYWdncykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LmFnZ3MpIHtcbiAgICAgIGNvbnN0IGFnZ1F1ZXJ5ID0gcXVlcnkuYWdnc1trZXldO1xuICAgICAgaWYgKGl0ZW0uYWdnc1trZXldICYmICFpc0FnZ1F1ZXJ5TWF0Y2goa2V5LCBhZ2dRdWVyeSwgaXRlbS5hZ2dzW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChxdWVyeS5hZ2dzICYmICFpdGVtLmFnZ3MpIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiUXVlcnkgY29udGFpbnMgYWdncyBidXQgaXRlbSBkb2VzIG5vdCBoYXZlIGFnZ3NcIiwgeyBxdWVyeSwgaXRlbSB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGFiYnJldlF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IGFiYnJldiA9IFtcIklRXCJdO1xuICBpZiAocXVlcnkpIHtcbiAgICBpZiAocXVlcnkucmVmcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkucmVmcykge1xuICAgICAgICBjb25zdCByZWYgPSBhYmJyZXZSZWYoa2V5LCBxdWVyeS5yZWZzW2tleV0pO1xuICAgICAgICBhYmJyZXYucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IHByb3BzID0gYWJicmV2Q29tcG91bmRDb25kaXRpb24ocXVlcnkuY29tcG91bmRDb25kaXRpb24pO1xuICAgICAgYWJicmV2LnB1c2gocHJvcHMpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuYWdncykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkuYWdncykge1xuICAgICAgICBjb25zdCBhZ2cgPSBhYmJyZXZBZ2coa2V5LCBxdWVyeS5hZ2dzW2tleV0pO1xuICAgICAgICBhYmJyZXYucHVzaChhZ2cpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkuZXZlbnRzKSB7XG4gICAgICBjb25zdCBldmVudHMgPSBgKEUke09iamVjdC5rZXlzKHF1ZXJ5LmV2ZW50cykuam9pbihcIixcIil9KWA7XG4gICAgICBhYmJyZXYucHVzaChldmVudHMpO1xuICAgIH1cbiAgICBpZiAocXVlcnkubGltaXQpIHtcbiAgICAgIGFiYnJldi5wdXNoKGBMJHtxdWVyeS5saW1pdH1gKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5Lm9mZnNldCkge1xuICAgICAgYWJicmV2LnB1c2goYE8ke3F1ZXJ5Lm9mZnNldH1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWJicmV2LnB1c2goXCIoZW1wdHkpXCIpO1xuICB9XG4gIHJldHVybiBhYmJyZXYuam9pbihcIiBcIik7XG59O1xudmFyIGFiYnJldlJlZiA9IChrZXksIHJlZikgPT4ge1xuICBpZiAoaXNQcmlLZXkocmVmKSkge1xuICAgIGNvbnN0IHByaUtleSA9IHJlZjtcbiAgICByZXR1cm4gYFIoJHtrZXl9LCR7cHJpS2V5Lmt0fSwke3ByaUtleS5wa30pYDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb21LZXkgPSByZWY7XG4gICAgcmV0dXJuIGBSKCR7a2V5fSwke0pTT04uc3RyaW5naWZ5KGNvbUtleSl9KWA7XG4gIH1cbn07XG52YXIgYWJicmV2QWdnID0gKGtleSwgYWdnKSA9PiB7XG4gIHJldHVybiBgQSgke2tleX0sJHthYmJyZXZRdWVyeShhZ2cpfSlgO1xufTtcbnZhciBhYmJyZXZDb21wb3VuZENvbmRpdGlvbiA9IChjb21wb3VuZENvbmRpdGlvbikgPT4ge1xuICByZXR1cm4gYENDKCR7Y29tcG91bmRDb25kaXRpb24uY29tcG91bmRUeXBlfSwke2NvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMgPyBjb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zLm1hcChhYmJyZXZDb25kaXRpb24pLmpvaW4oXCIsXCIpIDogXCJObyBDb25kaXRpb25zXCJ9KWA7XG59O1xudmFyIGFiYnJldkNvbmRpdGlvbiA9IChjb25kaXRpb24pID0+IHtcbiAgaWYgKGlzQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICByZXR1cm4gYCgke2NvbmRpdGlvbi5jb2x1bW59LCR7Y29uZGl0aW9uLnZhbHVlfSwke2NvbmRpdGlvbi5vcGVyYXRvcn0pYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWJicmV2Q29tcG91bmRDb25kaXRpb24oY29uZGl0aW9uKTtcbiAgfVxufTtcblxuLy8gc3JjL2l0ZW0vSVV0aWxzLnRzXG52YXIgbG9nZ2VyNCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIklVdGlsc1wiKTtcbnZhciB2YWxpZGF0ZVBLRm9ySXRlbSA9IChpdGVtLCBwa1R5cGUpID0+IHtcbiAgaWYgKCFpdGVtKSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gaXMgdW5kZWZpbmVkXCIsIHsgaXRlbSB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoIWl0ZW0ua2V5KSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gZG9lcyBub3QgaGF2ZSBhIGtleVwiLCB7IGl0ZW0gfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5XCIpO1xuICB9XG4gIGNvbnN0IGtleVR5cGVBcnJheSA9IHRvS2V5VHlwZUFycmF5KGl0ZW0ua2V5KTtcbiAgaWYgKGtleVR5cGVBcnJheVswXSAhPT0gcGtUeXBlKSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIktleSBUeXBlIEFycmF5IE1pc21hdGNoXCIsIHsga2V5VHlwZUFycmF5LCBwa1R5cGUgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgcHJpbWFyeSBrZXkgdHlwZS4gRXhwZWN0ZWQgJHtwa1R5cGV9LCBnb3QgJHtrZXlUeXBlQXJyYXlbMF19YCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xudmFyIHZhbGlkYXRlUEsgPSAoaW5wdXQsIHBrVHlwZSkgPT4ge1xuICBsb2dnZXI0LnRyYWNlKFwiQ2hlY2tpbmcgUmV0dXJuIFR5cGVcIiwgeyBpbnB1dCB9KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gdmFsaWRhdGVQS0Zvckl0ZW0oaXRlbSwgcGtUeXBlKSk7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlUEtGb3JJdGVtKGlucHV0LCBwa1R5cGUpO1xufTtcbnZhciB2YWxpZGF0ZUtleXMgPSAoaXRlbSwga2V5VHlwZXMpID0+IHtcbiAgbG9nZ2VyNC50cmFjZShcIkNoZWNraW5nIFJldHVybiBUeXBlXCIsIHsgaXRlbSB9KTtcbiAgaWYgKCFpdGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidmFsaWRhdGluZyBrZXlzLCBpdGVtIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoIWl0ZW0ua2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidmFsaWRhdGluZyBrZXlzLCBpdGVtIGRvZXMgbm90IGhhdmUgYSBrZXk6IFwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICB9XG4gIGNvbnN0IGtleVR5cGVBcnJheSA9IHRvS2V5VHlwZUFycmF5KGl0ZW0ua2V5KTtcbiAgaWYgKGtleVR5cGVBcnJheS5sZW5ndGggIT09IGtleVR5cGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBrZXlzLiBFeHBlY3RlZCAke2tleVR5cGVzLmxlbmd0aH0sIGJ1dCBnb3QgJHtrZXlUeXBlQXJyYXkubGVuZ3RofWApO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gSlNPTi5zdHJpbmdpZnkoa2V5VHlwZUFycmF5KSA9PT0gSlNPTi5zdHJpbmdpZnkoa2V5VHlwZXMpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgbG9nZ2VyNC5lcnJvcihcIktleSBUeXBlIEFycmF5IE1pc21hdGNoXCIsIHsga2V5VHlwZUFycmF5LCB0aGlzS2V5VHlwZXM6IGtleVR5cGVzIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IGtleSB0eXBlcy4gRXhwZWN0ZWQgWyR7a2V5VHlwZXMuam9pbihcIiwgXCIpfV0sIGJ1dCBnb3QgWyR7a2V5VHlwZUFycmF5LmpvaW4oXCIsIFwiKX1dYCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xudmFyIGlzUHJpSXRlbSA9IChpdGVtKSA9PiB7XG4gIHJldHVybiAhIShpdGVtICYmIGl0ZW0ua2V5ICYmIGlzUHJpS2V5KGl0ZW0ua2V5KSk7XG59O1xudmFyIGlzQ29tSXRlbSA9IChpdGVtKSA9PiB7XG4gIHJldHVybiAhIShpdGVtICYmIGl0ZW0ua2V5ICYmIGlzQ29tS2V5KGl0ZW0ua2V5KSk7XG59O1xuZXhwb3J0IHtcbiAgQUl0ZW1TZXJ2aWNlLFxuICBEaWN0aW9uYXJ5LFxuICBJRmFjdG9yeSxcbiAgSVFGYWN0b3J5LFxuICBhYmJyZXZBZ2csXG4gIGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uLFxuICBhYmJyZXZDb25kaXRpb24sXG4gIGFiYnJldklLLFxuICBhYmJyZXZMS0EsXG4gIGFiYnJldlF1ZXJ5LFxuICBhYmJyZXZSZWYsXG4gIGNQSyxcbiAgY29uc3RydWN0UHJpS2V5LFxuICBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uLFxuICBnZW5lcmF0ZUtleUFycmF5LFxuICBpa1RvTEtBLFxuICBpc0NvbUl0ZW0sXG4gIGlzQ29tS2V5LFxuICBpc0NvbUtleUVxdWFsLFxuICBpc0NvbUtleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNDb25kaXRpb24sXG4gIGlzSXRlbUtleSxcbiAgaXNJdGVtS2V5RXF1YWwsXG4gIGlzSXRlbUtleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNMb2NLZXksXG4gIGlzTG9jS2V5RXF1YWwsXG4gIGlzTG9jS2V5RXF1YWxOb3JtYWxpemVkLFxuICBpc1ByaUl0ZW0sXG4gIGlzUHJpS2V5LFxuICBpc1ByaUtleUVxdWFsLFxuICBpc1ByaUtleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNRdWVyeU1hdGNoLFxuICBpc1ZhbGlkQ29tS2V5LFxuICBpc1ZhbGlkSXRlbUtleSxcbiAgaXNWYWxpZExvY0tleSxcbiAgaXNWYWxpZExvY0tleUFycmF5LFxuICBpc1ZhbGlkUHJpS2V5LFxuICBpdGVtS2V5VG9Mb2NLZXlBcnJheSxcbiAgbGthVG9JSyxcbiAgbG9jS2V5QXJyYXlUb0l0ZW1LZXksXG4gIHBhcmFtc1RvUXVlcnksXG4gIHByaW1hcnlUeXBlLFxuICBxdWVyeVRvUGFyYW1zLFxuICB0b0tleVR5cGVBcnJheSxcbiAgdmFsaWRhdGVLZXlzLFxuICB2YWxpZGF0ZVBLXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/@fjell/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js":
/*!*********************************************************************!*\
  !*** ../fjell-client-api/node_modules/@fjell/logging/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9AZmplbGwvbG9nZ2luZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEtBQUs7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkIsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQU1wQjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL0BmamVsbC9sb2dnaW5nL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL0xvZ0Zvcm1hdC50c1xudmFyIExvZ0Zvcm1hdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dGb3JtYXRfZXhwb3J0cywge1xuICBMb2dGb3JtYXRzOiAoKSA9PiBMb2dGb3JtYXRzLFxuICBTVFJVQ1RVUkVEOiAoKSA9PiBTVFJVQ1RVUkVELFxuICBURVhUOiAoKSA9PiBURVhULFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZ1xufSk7XG52YXIgVEVYVCA9IHtcbiAgbmFtZTogXCJURVhUXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlRleHQgZm9ybWF0XCJcbn07XG52YXIgU1RSVUNUVVJFRCA9IHtcbiAgbmFtZTogXCJTVFJVQ1RVUkVEXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZWQgZm9ybWF0XCJcbn07XG52YXIgTG9nRm9ybWF0cyA9IFtcbiAgVEVYVCxcbiAgU1RSVUNUVVJFRFxuXTtcbnZhciBnZXRDb25maWcgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dGb3JtYXRzLmZpbmQoKGNvbmZpZzIpID0+IGNvbmZpZzIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBGb3JtYXQgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvTG9nTGV2ZWwudHNcbnZhciBMb2dMZXZlbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dMZXZlbF9leHBvcnRzLCB7XG4gIEFMRVJUOiAoKSA9PiBBTEVSVCxcbiAgQ1JJVElDQUw6ICgpID0+IENSSVRJQ0FMLFxuICBERUJVRzogKCkgPT4gREVCVUcsXG4gIERFRkFVTFQ6ICgpID0+IERFRkFVTFQsXG4gIEVNRVJHRU5DWTogKCkgPT4gRU1FUkdFTkNZLFxuICBFUlJPUjogKCkgPT4gRVJST1IsXG4gIElORk86ICgpID0+IElORk8sXG4gIExvZ0xldmVsczogKCkgPT4gTG9nTGV2ZWxzLFxuICBOT1RJQ0U6ICgpID0+IE5PVElDRSxcbiAgVFJBQ0U6ICgpID0+IFRSQUNFLFxuICBXQVJOSU5HOiAoKSA9PiBXQVJOSU5HLFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZzJcbn0pO1xudmFyIEVNRVJHRU5DWSA9IHtcbiAgbmFtZTogXCJFTUVSR0VOQ1lcIixcbiAgdmFsdWU6IDBcbn07XG52YXIgQUxFUlQgPSB7XG4gIG5hbWU6IFwiQUxFUlRcIixcbiAgdmFsdWU6IDFcbn07XG52YXIgQ1JJVElDQUwgPSB7XG4gIG5hbWU6IFwiQ1JJVElDQUxcIixcbiAgdmFsdWU6IDJcbn07XG52YXIgRVJST1IgPSB7XG4gIG5hbWU6IFwiRVJST1JcIixcbiAgdmFsdWU6IDNcbn07XG52YXIgV0FSTklORyA9IHtcbiAgbmFtZTogXCJXQVJOSU5HXCIsXG4gIHZhbHVlOiA0XG59O1xudmFyIE5PVElDRSA9IHtcbiAgbmFtZTogXCJOT1RJQ0VcIixcbiAgdmFsdWU6IDVcbn07XG52YXIgSU5GTyA9IHtcbiAgbmFtZTogXCJJTkZPXCIsXG4gIHZhbHVlOiA2XG59O1xudmFyIERFQlVHID0ge1xuICBuYW1lOiBcIkRFQlVHXCIsXG4gIHZhbHVlOiA3XG59O1xudmFyIFRSQUNFID0ge1xuICBuYW1lOiBcIlRSQUNFXCIsXG4gIHZhbHVlOiA4XG59O1xudmFyIERFRkFVTFQgPSB7XG4gIG5hbWU6IFwiREVGQVVMVFwiLFxuICB2YWx1ZTogOVxufTtcbnZhciBMb2dMZXZlbHMgPSBbXG4gIEVNRVJHRU5DWSxcbiAgQUxFUlQsXG4gIENSSVRJQ0FMLFxuICBFUlJPUixcbiAgV0FSTklORyxcbiAgTk9USUNFLFxuICBJTkZPLFxuICBERUJVRyxcbiAgVFJBQ0UsXG4gIERFRkFVTFRcbl07XG52YXIgZ2V0Q29uZmlnMiA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0xldmVscy5maW5kKChjb25maWcyKSA9PiBjb25maWcyLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMb2cgTGV2ZWwgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgZGVmYXVsdExvZ0xldmVsID0gSU5GTztcbnZhciBkZWZhdWx0TG9nRm9ybWF0ID0gVEVYVDtcbnZhciBkZWZhdWx0TG9nZ2luZ0NvbmZpZyA9IHtcbiAgbG9nTGV2ZWw6IGRlZmF1bHRMb2dMZXZlbCxcbiAgbG9nRm9ybWF0OiBkZWZhdWx0TG9nRm9ybWF0LFxuICBvdmVycmlkZXM6IHt9LFxuICBmbG9vZENvbnRyb2w6IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICAgIHRpbWVmcmFtZTogMWUzXG4gICAgLy8gMSBzZWNvbmRcbiAgfVxufTtcbnZhciBjb252ZXJ0T3ZlcnJpZGVzID0gKG92ZXJyaWRlcykgPT4ge1xuICBjb25zdCBjb252ZXJ0ZWRPdmVycmlkZXMgPSB7fTtcbiAgaWYgKG92ZXJyaWRlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKG92ZXJyaWRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjb252ZXJ0ZWRPdmVycmlkZXNba2V5XSA9IHsgbG9nTGV2ZWw6IHZhbHVlLmxvZ0xldmVsID8gZ2V0Q29uZmlnMih2YWx1ZS5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3ZlcnJpZGVzO1xufTtcbnZhciBjb252ZXJ0Q29uZmlnID0gKGNvbmZpZykgPT4ge1xuICByZXR1cm4ge1xuICAgIGxvZ0xldmVsOiBjb25maWcubG9nTGV2ZWwgPyBnZXRDb25maWcyKGNvbmZpZy5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwsXG4gICAgbG9nRm9ybWF0OiBjb25maWcubG9nRm9ybWF0ID8gZ2V0Q29uZmlnKGNvbmZpZy5sb2dGb3JtYXQpIDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgICBvdmVycmlkZXM6IGNvbnZlcnRPdmVycmlkZXMoY29uZmlnLm92ZXJyaWRlcyksXG4gICAgZmxvb2RDb250cm9sOiB7XG4gICAgICAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZy5mbG9vZENvbnRyb2wsXG4gICAgICAuLi5jb25maWcuZmxvb2RDb250cm9sIHx8IHt9XG4gICAgfVxuICB9O1xufTtcbnZhciBjb25maWd1cmVMb2dnaW5nID0gKCkgPT4ge1xuICBsZXQgY29uZmlnID0ge307XG4gIGNvbnN0IGxvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgZXhwb0xvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5FWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgbmV4dExvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgbGV0IGxvZ0xldmVsRW52ID0gcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuICBsZXQgbG9nRm9ybWF0RW52ID0gcHJvY2Vzcy5lbnYuTE9HX0ZPUk1BVDtcbiAgaWYgKGxvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShsb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBMT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cG9Mb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoZXhwb0xvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIEVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV4dExvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShuZXh0TG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gTkVYVF9QVUJMSUNfTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfVxuICBjb25zdCBjb252ZXJ0ZWRDb25maWcgPSBjb252ZXJ0Q29uZmlnKGNvbmZpZyk7XG4gIGlmIChsb2dMZXZlbEVudikge1xuICAgIGxvZ0xldmVsRW52ID0gbG9nTGV2ZWxFbnY/LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nTGV2ZWxDb25maWcgPSBnZXRDb25maWcyKGxvZ0xldmVsRW52KTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nTGV2ZWwgPSBsb2dMZXZlbENvbmZpZztcbiAgfVxuICBpZiAobG9nRm9ybWF0RW52KSB7XG4gICAgbG9nRm9ybWF0RW52ID0gbG9nRm9ybWF0RW52LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nRm9ybWF0Q29uZmlnID0gZ2V0Q29uZmlnKGxvZ0Zvcm1hdEVudik7XG4gICAgY29udmVydGVkQ29uZmlnLmxvZ0Zvcm1hdCA9IGxvZ0Zvcm1hdENvbmZpZztcbiAgfVxuICBjb25zdCBmaW5hbENvbmZpZyA9IHsgLi4uZGVmYXVsdExvZ2dpbmdDb25maWcsIC4uLmNvbnZlcnRlZENvbmZpZyB9O1xuICByZXR1cm4gZmluYWxDb25maWc7XG59O1xuXG4vLyBzcmMvV3JpdGVyLnRzXG52YXIgY3JlYXRlV3JpdGVyID0gKGZvcm1hdHRlciwgbG9nTWV0aG9kLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlc3BlY3RJbmplY3RlZE1ldGhvZCA9IGZhbHNlLFxuICAgIGVycm9yTWV0aG9kID0gY29uc29sZS5lcnJvcixcbiAgICB3YXJuaW5nTWV0aG9kID0gY29uc29sZS53YXJuLFxuICAgIGluZm9NZXRob2QgPSBjb25zb2xlLmxvZ1xuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICB3cml0ZTogKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgICAgbGV0IGZpbmFsTG9nTWV0aG9kID0gbG9nTWV0aG9kO1xuICAgICAgaWYgKCFyZXNwZWN0SW5qZWN0ZWRNZXRob2QpIHtcbiAgICAgICAgaWYgKGxldmVsLm5hbWUgPT09IEVSUk9SLm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gQ1JJVElDQUwubmFtZSB8fCBsZXZlbC5uYW1lID09PSBBTEVSVC5uYW1lIHx8IGxldmVsLm5hbWUgPT09IEVNRVJHRU5DWS5uYW1lKSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBlcnJvck1ldGhvZDtcbiAgICAgICAgfSBlbHNlIGlmIChsZXZlbC5uYW1lID09PSBXQVJOSU5HLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IHdhcm5pbmdNZXRob2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBpbmZvTWV0aG9kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5hbExvZ01ldGhvZChmb3JtYXR0ZXIuZm9ybWF0TG9nKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9mb3JtYXR0ZXIudHNcbmltcG9ydCB1dGlsIGZyb20gXCJ1dGlsXCI7XG52YXIgc2FmZUluc3BlY3QgPSAob2JqKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChvYmopO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYFtPYmplY3Q6ICR7dHlwZW9mIG9ian1dYDtcbiAgfVxufTtcbnZhciBzYWZlRm9ybWF0ID0gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdXRpbC5mb3JtYXQobWVzc2FnZSwgLi4uYXJncyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgJHttZXNzYWdlfSAke3NhZmVJbnNwZWN0KGFyZ3MpfWA7XG4gIH1cbn07XG52YXIgY3JlYXRlRm9ybWF0dGVyID0gKGxvZ0Zvcm1hdCkgPT4ge1xuICBpZiAobG9nRm9ybWF0Lm5hbWUgPT09IFwiVEVYVFwiKSB7XG4gICAgcmV0dXJuIGdldFRleHRGb3JtYXR0ZXIoKTtcbiAgfSBlbHNlIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJTVFJVQ1RVUkVEXCIpIHtcbiAgICByZXR1cm4gZ2V0U3RydWN0dXJlZEZvcm1hdHRlcigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsb2cgZm9ybWF0OiAke2xvZ0Zvcm1hdC5uYW1lfWApO1xufTtcbnZhciBnZXRUZXh0Rm9ybWF0dGVyID0gKCkgPT4ge1xuICBjb25zdCBmb3JtYXRMb2cgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuICAgIGxldCBsb2dNZXNzYWdlO1xuICAgIGlmIChwYXlsb2FkLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dNZXNzYWdlID0gcGF5bG9hZC5tZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAoaGFzU3BlY2lmaWVycykge1xuICAgICAgbG9nTWVzc2FnZSA9IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dNZXNzYWdlID0gYCR7cGF5bG9hZC5tZXNzYWdlfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke2xvZ01lc3NhZ2V9YDtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHJhbmRvbUludCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlMiA9IGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke3NhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9ICR7cmFuZG9tSW50fWA7XG4gICAgcmV0dXJuIHRpbWVyTWVzc2FnZTI7XG4gIH07XG4gIHJldHVybiB7IGZvcm1hdExvZywgdGltZXJNZXNzYWdlLCBnZXRMb2dGb3JtYXQ6ICgpID0+IFRFWFQgfTtcbn07XG52YXIgZ2V0U3RydWN0dXJlZEZvcm1hdHRlciA9ICgpID0+IHtcbiAgY29uc3QgZm9ybWF0TG9nID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogaGFzU3BlY2lmaWVycyA/IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpIDogcGF5bG9hZC5tZXNzYWdlLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgLi4uIWhhc1NwZWNpZmllcnMgJiYgcGF5bG9hZC5kYXRhLmxlbmd0aCA+IDAgJiYgeyBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzZXZlcml0eSxcbiAgICAgIG1lc3NhZ2U6IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgZGF0YTogc2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9zcGFuSWRcIjogU3RyaW5nKHJhbmRvbUludClcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gU1RSVUNUVVJFRCB9O1xufTtcblxuLy8gc3JjL0Zsb29kQ29udHJvbC50c1xuaW1wb3J0IHV0aWwyIGZyb20gXCJ1dGlsXCI7XG52YXIgaGFzaCA9IChtZXNzYWdlLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGRhdGFTdHJpbmcgPSBkYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdXRpbDIuaW5zcGVjdChpdGVtKTtcbiAgICB9XG4gIH0pLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHttZXNzYWdlfSR7ZGF0YVN0cmluZ31gO1xufTtcbnZhciBGbG9vZENvbnRyb2wgPSBjbGFzcyB7XG4gIGNvbmZpZztcbiAgaGlzdG9yeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN1cHByZXNzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjbGVhbnVwVGltZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmNsZWFudXAoKSwgdGhpcy5jb25maWcudGltZWZyYW1lICogMik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2hhc2gyLCB0aW1lc3RhbXBzXSBvZiB0aGlzLmhpc3RvcnkuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByZWNlbnRUaW1lc3RhbXBzID0gdGltZXN0YW1wcy5maWx0ZXIoXG4gICAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChyZWNlbnRUaW1lc3RhbXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LnNldChoYXNoMiwgcmVjZW50VGltZXN0YW1wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpc3RvcnkuZGVsZXRlKGhhc2gyKTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShoYXNoMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBcImxvZ1wiO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gKHRoaXMuaGlzdG9yeS5nZXQobWVzc2FnZUhhc2gpIHx8IFtdKS5maWx0ZXIoXG4gICAgICAodGltZXN0YW1wKSA9PiBub3cgLSB0aW1lc3RhbXAgPCB0aGlzLmNvbmZpZy50aW1lZnJhbWVcbiAgICApO1xuICAgIHRpbWVzdGFtcHMucHVzaChub3cpO1xuICAgIHRoaXMuaGlzdG9yeS5zZXQobWVzc2FnZUhhc2gsIHRpbWVzdGFtcHMpO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA+IHRoaXMuY29uZmlnLnRocmVzaG9sZCkge1xuICAgICAgY29uc3Qgc3VwcHJlc3NlZEluZm8gPSB0aGlzLnN1cHByZXNzZWQuZ2V0KG1lc3NhZ2VIYXNoKTtcbiAgICAgIGlmIChzdXBwcmVzc2VkSW5mbykge1xuICAgICAgICBzdXBwcmVzc2VkSW5mby5jb3VudCsrO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLnNldChtZXNzYWdlSGFzaCwgeyBjb3VudDogMSwgZmlyc3RUaW1lc3RhbXA6IHRpbWVzdGFtcHNbMF0sIHN1bW1hcnlMb2dnZWQ6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zdXBwcmVzc2VkLmhhcyhtZXNzYWdlSGFzaCkpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShtZXNzYWdlSGFzaCk7XG4gICAgICAgIHJldHVybiBcInJlc3VtZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJsb2dcIjtcbiAgfVxuICBnZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkge1xuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk/LmNvdW50IHx8IDA7XG4gIH1cbn07XG5cbi8vIHNyYy9Mb2dnZXIudHNcbnZhciBjcmVhdGVMb2dnZXIgPSAobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIobG9nRm9ybWF0KTtcbiAgY29uc3QgZmxvb2RDb250cm9sID0gZmxvb2RDb250cm9sQ29uZmlnLmVuYWJsZWQgPyBuZXcgRmxvb2RDb250cm9sKGZsb29kQ29udHJvbENvbmZpZykgOiBudWxsO1xuICBjb25zdCBsb2dGdW5jdGlvbiA9IGNvbnNvbGUubG9nO1xuICBjb25zdCB3cml0ZXIgPSBjcmVhdGVXcml0ZXIoZm9ybWF0dGVyLCBsb2dGdW5jdGlvbiwgd3JpdGVyT3B0aW9ucyk7XG4gIGNvbnN0IHdyaXRlID0gKGxldmVsLCBtZXNzYWdlLCBkYXRhKSA9PiB7XG4gICAgaWYgKGxvZ0xldmVsLnZhbHVlIDwgbGV2ZWwudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hlY2sgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuY2hlY2sobWVzc2FnZSwgZGF0YSkgOiBcImxvZ1wiO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7IG1lc3NhZ2UsIGRhdGEgfTtcbiAgICBzd2l0Y2ggKGNoZWNrKSB7XG4gICAgICBjYXNlIFwibG9nXCI6XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdXBwcmVzc1wiOlxuICAgICAgICBpZiAoZmxvb2RDb250cm9sICYmIGZsb29kQ29udHJvbC5nZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgY29uc3QgbmV3UGF5bG9hZCA9IHsgbWVzc2FnZTogYFN0YXJ0ZWQgc3VwcHJlc3NpbmcgcmVwZWF0ZWQgbG9nIG1lc3NhZ2VgLCBkYXRhOiBbXSB9O1xuICAgICAgICAgIHdyaXRlci53cml0ZShvcmlnaW5hbExldmVsLCBjb29yZGluYXRlcywgbmV3UGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVzdW1lXCI6IHtcbiAgICAgICAgY29uc3QgY291bnQgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIDogMDtcbiAgICAgICAgY29uc3QgcmVzdW1lUGF5bG9hZCA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBgU3RvcHBlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZS4gU3VwcHJlc3NlZCAke2NvdW50fSB0aW1lcy5gLFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHJlc3VtZVBheWxvYWQpO1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGFydFRpbWVMb2dnZXIgPSAobG9nTGV2ZWwyLCBjb29yZGluYXRlczIsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UgPSBmb3JtYXR0ZXIudGltZXJNZXNzYWdlKGxvZ0xldmVsMiwgY29vcmRpbmF0ZXMyLCBwYXlsb2FkKTtcbiAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lKHRpbWVyTWVzc2FnZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuZDogKCkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lRW5kKHRpbWVyTWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgbG9nOiAoLi4uZGF0YSkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lTG9nKHRpbWVyTWVzc2FnZSwgLi4uZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBlbWVyZ2VuY3k6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShFTUVSR0VOQ1ksIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgYWxlcnQ6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShBTEVSVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBjcml0aWNhbDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKENSSVRJQ0FMLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGVycm9yOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoRVJST1IsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgd2FybmluZzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKFdBUk5JTkcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgbm90aWNlOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoTk9USUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGluZm86IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShJTkZPLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVCVUcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgdHJhY2U6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShUUkFDRSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBkZWZhdWx0OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVGQVVMVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0aW1lOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHsgbWVzc2FnZSwgZGF0YSB9O1xuICAgICAgcmV0dXJuIHN0YXJ0VGltZUxvZ2dlcihsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgIH0sXG4gICAgZ2V0OiAoLi4uYWRkaXRpb25hbENvbXBvbmVudHMpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IFsuLi5jb29yZGluYXRlcy5jb21wb25lbnRzLCAuLi5hZGRpdGlvbmFsQ29tcG9uZW50c11cbiAgICAgIH0sIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucyk7XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBpZiAoZmxvb2RDb250cm9sKSB7XG4gICAgICAgIGZsb29kQ29udHJvbC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2xvZ2dpbmcudHNcbnZhciBnZXRMb2dnZXIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBjb25maWd1cmVMb2dnaW5nKCk7XG4gIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUJhc2VMb2dnZXIobmFtZSwgY29uZmlnKTtcbiAgcmV0dXJuIGxvZ2dlcjtcbn07XG52YXIgY3JlYXRlQmFzZUxvZ2dlciA9IChuYW1lLCBjb25maWcpID0+IHtcbiAgbGV0IHsgbG9nTGV2ZWwgfSA9IGNvbmZpZztcbiAgY29uc3QgeyBsb2dGb3JtYXQsIGZsb29kQ29udHJvbCB9ID0gY29uZmlnO1xuICBjb25zdCBvdmVycmlkZXMgPSBjb25maWcub3ZlcnJpZGVzO1xuICBpZiAob3ZlcnJpZGVzICYmIG92ZXJyaWRlc1tuYW1lXSkge1xuICAgIGxvZ0xldmVsID0gb3ZlcnJpZGVzW25hbWVdLmxvZ0xldmVsO1xuICB9XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0geyBjYXRlZ29yeTogbmFtZSwgY29tcG9uZW50czogW10gfTtcbiAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihsb2dGb3JtYXQsIGxvZ0xldmVsLCBjb29yZGluYXRlcywgZmxvb2RDb250cm9sKTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSB7IGdldExvZ2dlciB9O1xuZXhwb3J0IHtcbiAgTG9nRm9ybWF0X2V4cG9ydHMgYXMgTG9nRm9ybWF0LFxuICBMb2dMZXZlbF9leHBvcnRzIGFzIExvZ0xldmVsLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGdldExvZ2dlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/@fjell/registry/dist/index.js":
/*!**********************************************************************!*\
  !*** ../fjell-client-api/node_modules/@fjell/registry/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-client-api/node_modules/@fjell/logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = (kta, scopes = []) => {\n  const ktArray = Array.isArray(kta) ? kta : [kta];\n  const toString = () => {\n    logger.debug(\"toString\", { kta, scopes });\n    return `${ktArray.join(\", \")} - ${scopes.join(\", \")}`;\n  };\n  logger.debug(\"createCoordinate\", { kta: ktArray, scopes, toString });\n  return { kta: ktArray, scopes, toString };\n};\n\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate) => {\n  logger2.debug(\"createInstance\", { coordinate, registry });\n  return { coordinate, registry };\n};\nvar isInstance = (instance) => {\n  return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n\n// src/RegistryStats.ts\nvar RegistryStats = class {\n  totalCalls = 0;\n  // Map structure: ktaKey -> scopeKey -> clientKey -> count\n  coordinateCalls = /* @__PURE__ */ new Map();\n  /**\n   * Records a get() call for the specified coordinate and client\n   */\n  recordGetCall(kta, scopes, client) {\n    this.totalCalls++;\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    if (!this.coordinateCalls.has(ktaKey)) {\n      this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n    }\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap.has(scopeKey)) {\n      scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n    }\n    const clientMap = scopeMap.get(scopeKey);\n    const currentCount = clientMap.get(clientKey) || 0;\n    clientMap.set(clientKey, currentCount + 1);\n  }\n  /**\n   * Gets the current statistics snapshot\n   */\n  getStatistics() {\n    const coordinateCallRecords = [];\n    let serviceCalls = 0;\n    let applicationCalls = 0;\n    let unidentifiedCalls = 0;\n    for (const [ktaKey, scopeMap] of this.coordinateCalls) {\n      for (const [scopeKey, clientMap] of scopeMap) {\n        const clientCalls = [];\n        let totalCount = 0;\n        for (const [clientKey, count] of clientMap) {\n          const client = this.parseClientKey(clientKey);\n          if (client !== null) {\n            clientCalls.push({ client, count });\n          }\n          totalCount += count;\n          if (clientKey === \"__no_client__\") {\n            unidentifiedCalls += count;\n          } else if (typeof client === \"string\") {\n            applicationCalls += count;\n          } else if (client !== null) {\n            serviceCalls += count;\n          }\n        }\n        coordinateCallRecords.push({\n          kta: ktaKey.split(\".\"),\n          scopes: this.parseScopeKey(scopeKey),\n          count: totalCount,\n          clientCalls: [...clientCalls]\n          // Return a copy\n        });\n      }\n    }\n    return {\n      totalGetCalls: this.totalCalls,\n      coordinateCallRecords: [...coordinateCallRecords],\n      // Return a copy\n      clientSummary: {\n        serviceCalls,\n        applicationCalls,\n        unidentifiedCalls\n      }\n    };\n  }\n  /**\n   * Gets call count for a specific coordinate combination\n   */\n  getCallCount(kta, scopes) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    let total = 0;\n    for (const count of clientMap.values()) {\n      total += count;\n    }\n    return total;\n  }\n  /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */\n  getCallCountByClient(kta, scopes, client) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    return clientMap.get(clientKey) || 0;\n  }\n  /**\n   * Gets total calls for a specific kta (across all scopes)\n   */\n  getTotalCallsForKta(kta) {\n    const ktaKey = kta.join(\".\");\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    let total = 0;\n    for (const clientMap of scopeMap.values()) {\n      for (const count of clientMap.values()) {\n        total += count;\n      }\n    }\n    return total;\n  }\n  /**\n   * Gets all unique kta paths that have been called\n   */\n  getCalledKtaPaths() {\n    const ktaPaths = [];\n    for (const ktaKey of this.coordinateCalls.keys()) {\n      ktaPaths.push(ktaKey.split(\".\"));\n    }\n    return ktaPaths;\n  }\n  /**\n   * Creates a normalized scope key from scopes array\n   */\n  createScopeKey(scopes) {\n    if (scopes.length === 0) return \"__no_scopes__\";\n    return [...scopes].sort().join(\",\");\n  }\n  /**\n   * Parses a scope key back to scopes array\n   */\n  parseScopeKey(scopeKey) {\n    if (scopeKey === \"__no_scopes__\") return [];\n    return scopeKey.split(\",\");\n  }\n  /**\n   * Creates a normalized client key from client identifier\n   */\n  createClientKey(client) {\n    if (!client) return \"__no_client__\";\n    if (typeof client === \"string\") {\n      return `app:${client}`;\n    }\n    const coordKey = `${client.coordinate.kta.join(\".\")};${this.createScopeKey(client.coordinate.scopes)}`;\n    return `service:${client.registryType}:${coordKey}`;\n  }\n  /**\n   * Parses a client key back to client identifier\n   */\n  parseClientKey(clientKey) {\n    if (clientKey === \"__no_client__\") return null;\n    if (clientKey.startsWith(\"app:\")) {\n      return clientKey.substring(4);\n    }\n    if (clientKey.startsWith(\"service:\")) {\n      const parts = clientKey.substring(8).split(\":\");\n      if (parts.length !== 2) return null;\n      const registryType = parts[0];\n      const coordParts = parts[1].split(\";\");\n      if (coordParts.length !== 2) return null;\n      const kta = coordParts[0].split(\".\");\n      const scopes = this.parseScopeKey(coordParts[1]);\n      return {\n        registryType,\n        coordinate: { kta, scopes }\n      };\n    }\n    return null;\n  }\n};\n\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes) => {\n  if (!requestedScopes || requestedScopes.length === 0) {\n    const firstInstance = scopedInstances[0]?.instance;\n    if (!firstInstance) {\n      throw new Error(\"No instances available\");\n    }\n    return firstInstance;\n  }\n  const matchingInstance = scopedInstances.find((scopedInstance) => {\n    if (!scopedInstance.scopes) return false;\n    return requestedScopes.every(\n      (scope) => scopedInstance.scopes && scopedInstance.scopes.includes(scope)\n    );\n  });\n  if (!matchingInstance) {\n    throw new Error(`No instance found matching scopes: ${requestedScopes.join(\", \")}`);\n  }\n  return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub) => {\n  const instanceTree = {};\n  const registryStats = new RegistryStats();\n  const createProxiedRegistry = (callingCoordinate) => {\n    const serviceClient = {\n      registryType: type,\n      coordinate: {\n        kta: callingCoordinate.kta,\n        scopes: callingCoordinate.scopes\n      }\n    };\n    return {\n      ...registry,\n      get: (kta, options) => {\n        const clientToUse = options?.client || serviceClient;\n        return registry.get(kta, { ...options, client: clientToUse });\n      }\n    };\n  };\n  const createInstance2 = (kta, scopes, factory) => {\n    logger3.debug(`Creating and registering instance for key path and scopes`, kta, scopes, `in registry type: ${type}`);\n    const coordinate = createCoordinate(kta, scopes);\n    const proxiedRegistry = createProxiedRegistry(coordinate);\n    const instance = factory(coordinate, {\n      registry: proxiedRegistry,\n      registryHub\n    });\n    if (!isInstance(instance)) {\n      throw new Error(`Factory did not return a valid instance for: ${kta.join(\".\")}`);\n    }\n    registerInternal(kta, instance, { scopes });\n    return instance;\n  };\n  const registerInternal = (kta, instance, options) => {\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    logger3.debug(`Registering instance for key path and scopes`, keyPath, options?.scopes, `in registry type: ${type}`);\n    if (!isInstance(instance)) {\n      throw new Error(`Attempting to register a non-instance: ${kta.join(\".\")}`);\n    }\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        currentLevel[keyType] = {\n          instances: [],\n          children: isLeaf ? null : {}\n        };\n      }\n      if (isLeaf) {\n        currentLevel[keyType].instances.push({\n          scopes: options?.scopes,\n          instance\n        });\n      } else {\n        if (!currentLevel[keyType].children) {\n          currentLevel[keyType].children = {};\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n  };\n  const register = (kta, instance, options) => {\n    logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n    registerInternal(kta, instance, options);\n  };\n  const get = (kta, options) => {\n    registryStats.recordGetCall(kta, options?.scopes, options?.client);\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        throw new Error(`Instance not found for key path: ${kta.join(\".\")}, Missing key: ${keyType}`);\n      }\n      if (isLeaf) {\n        const scopedInstances = currentLevel[keyType].instances;\n        if (scopedInstances.length === 0) {\n          throw new Error(`No instances registered for key path: ${kta.join(\".\")}`);\n        }\n        return findScopedInstance(scopedInstances, options?.scopes);\n      } else {\n        if (!currentLevel[keyType].children) {\n          throw new Error(`Instance not found for key path: ${kta.join(\".\")}, No children for: ${keyType}`);\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n    return null;\n  };\n  const getCoordinates = () => {\n    const coordinates = [];\n    const traverseTree = (node) => {\n      for (const keyType in node) {\n        const treeNode = node[keyType];\n        for (const scopedInstance of treeNode.instances) {\n          coordinates.push(scopedInstance.instance.coordinate);\n        }\n        if (treeNode.children) {\n          traverseTree(treeNode.children);\n        }\n      }\n    };\n    traverseTree(instanceTree);\n    return coordinates;\n  };\n  const getStatistics = () => {\n    return registryStats.getStatistics();\n  };\n  const registry = {\n    type,\n    registryHub,\n    createInstance: createInstance2,\n    register,\n    get,\n    getCoordinates,\n    getStatistics,\n    instanceTree\n  };\n  return registry;\n};\n\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n  registryType;\n  context;\n  constructor(message, registryType, context) {\n    super(message);\n    this.name = this.constructor.name;\n    this.registryType = registryType;\n    this.context = context;\n    const ErrorConstructor = Error;\n    if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n      ErrorConstructor.captureStackTrace(this, this.constructor);\n    }\n  }\n  getDetails() {\n    const details = [this.message];\n    if (this.registryType) {\n      details.push(`Registry Type: ${this.registryType}`);\n    }\n    if (this.context) {\n      details.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n    }\n    return details.join(\"\\n\");\n  }\n};\nvar RegistryCreationError = class extends RegistryError {\n  constructor(type, reason, context) {\n    super(`Failed to create registry of type '${type}': ${reason}`, type, context);\n  }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n  keyPath;\n  factoryResult;\n  constructor(keyPath, factoryResult, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Factory did not return a valid instance for: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof factoryResult}`,\n      registryType,\n      { keyPath, factoryResult: typeof factoryResult }\n    );\n    this.keyPath = keyPath;\n    this.factoryResult = factoryResult;\n  }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n  keyPath;\n  attemptedRegistration;\n  constructor(keyPath, attemptedRegistration, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Attempting to register a non-instance: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof attemptedRegistration}`,\n      registryType,\n      { keyPath, attemptedRegistration: typeof attemptedRegistration }\n    );\n    this.keyPath = keyPath;\n    this.attemptedRegistration = attemptedRegistration;\n  }\n};\n\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n  hubType;\n  constructor(message, hubType, context) {\n    const enrichedContext = hubType ? { ...context, hubType } : context;\n    super(message, \"\", enrichedContext);\n    this.hubType = hubType;\n  }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n  duplicateType;\n  constructor(type, context) {\n    super(\n      `Registry already registered under type: ${type}. Each registry type must be unique within a registry hub.`,\n      \"\",\n      { ...context, duplicateType: type }\n    );\n    this.duplicateType = type;\n  }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n  requestedType;\n  availableTypes;\n  constructor(requestedType, availableTypes = [], context) {\n    let message = `No registry registered under type: ${requestedType}`;\n    if (availableTypes.length > 0) {\n      message += `. Available types: [${availableTypes.join(\", \")}]`;\n    }\n    super(message, \"\", { ...context, requestedType, availableTypes });\n    this.requestedType = requestedType;\n    this.availableTypes = availableTypes;\n  }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n  factoryError;\n  attemptedType;\n  constructor(type, factoryError, context) {\n    super(\n      `Registry factory failed to create registry of type '${type}': ${factoryError.message}`,\n      \"\",\n      { ...context, attemptedType: type, originalError: factoryError.message }\n    );\n    this.factoryError = factoryError;\n    this.attemptedType = type;\n  }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n  factoryResult;\n  attemptedType;\n  constructor(type, factoryResult, context) {\n    super(\n      `Registry factory returned invalid registry for type '${type}'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: ${typeof factoryResult}`,\n      \"\",\n      { ...context, attemptedType: type, factoryResult: typeof factoryResult }\n    );\n    this.factoryResult = factoryResult;\n    this.attemptedType = type;\n  }\n};\n\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = () => {\n  const registries = {};\n  const createRegistry2 = (type, factory) => {\n    logger4.debug(`Creating new registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    const registry = factory(type, hub);\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    registries[type] = registry;\n    logger4.debug(`Successfully created and registered new registry with type: ${type}`);\n    return registry;\n  };\n  const registerRegistry = (registry) => {\n    const type = registry.type;\n    logger4.debug(`Registering registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    registries[type] = registry;\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    logger4.debug(`Successfully registered registry with type: ${type}`);\n  };\n  const get = (type, kta, options) => {\n    logger4.debug(`Looking up instance for type: ${type}, kta: ${kta.join(\".\")}, scopes: ${options?.scopes?.join(\",\") || \"none\"}`);\n    const registry = registries[type];\n    if (!registry) {\n      const availableTypes = Object.keys(registries);\n      throw new RegistryTypeNotFoundError(type, availableTypes);\n    }\n    return registry.get(kta, options);\n  };\n  const getRegistry = (type) => {\n    return registries[type] || null;\n  };\n  const getRegisteredTypes = () => {\n    return Object.keys(registries);\n  };\n  const unregisterRegistry = (type) => {\n    if (registries[type]) {\n      delete registries[type];\n      logger4.debug(`Unregistered registry under type: ${type}`);\n      return true;\n    }\n    return false;\n  };\n  const getAllCoordinates = () => {\n    const allCoordinates = [];\n    for (const registryType in registries) {\n      const registry = registries[registryType];\n      const coordinates = registry.getCoordinates();\n      coordinates.forEach((coordinate) => {\n        allCoordinates.push({\n          coordinate,\n          registryType\n        });\n      });\n    }\n    logger4.debug(`Retrieved ${allCoordinates.length} total coordinates from ${Object.keys(registries).length} registries`);\n    return allCoordinates;\n  };\n  const hub = {\n    createRegistry: createRegistry2,\n    registerRegistry,\n    get,\n    getRegistry,\n    getRegisteredTypes,\n    getAllCoordinates,\n    unregisterRegistry\n  };\n  return hub;\n};\n\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n  keyPath;\n  constructor(message, keyPath, registryType, context) {\n    super(message, registryType, { ...context, keyPath });\n    this.keyPath = keyPath;\n  }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n  missingKey;\n  constructor(keyPath, missingKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    let message = `Instance not found for key path: ${keyPathStr}`;\n    if (missingKey) {\n      message += `, Missing key: ${missingKey}`;\n    }\n    super(message, keyPath, registryType, { ...context, missingKey });\n    this.missingKey = missingKey;\n  }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances registered for key path: ${keyPathStr}. The key path exists in the registry tree but contains no instances.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances available for key path: ${keyPathStr}. This typically indicates an internal registry state issue.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n  requestedScopes;\n  availableScopes;\n  constructor(keyPath, requestedScopes, availableScopes = [], registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    const scopesStr = requestedScopes.join(\", \");\n    const availableScopesStr = availableScopes.map((scopes) => `[${scopes.join(\", \")}]`).join(\", \");\n    let message = `No instance found matching scopes: ${scopesStr} for key path: ${keyPathStr}`;\n    if (availableScopes.length > 0) {\n      message += `. Available scopes: ${availableScopesStr}`;\n    }\n    super(message, keyPath, registryType, { requestedScopes, availableScopes });\n    this.requestedScopes = requestedScopes;\n    this.availableScopes = availableScopes;\n  }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n  parentKey;\n  constructor(keyPath, parentKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Instance not found for key path: ${keyPathStr}, No children for: ${parentKey}. The path cannot be traversed further as '${parentKey}' has no child nodes.`,\n      keyPath,\n      registryType,\n      { ...context, parentKey }\n    );\n    this.parentKey = parentKey;\n  }\n};\n\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n  kta;\n  scopes;\n  constructor(message, kta, scopes, context) {\n    super(message, \"\", { ...context, kta, scopes });\n    this.kta = kta;\n    this.scopes = scopes;\n  }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n  constructor(kta, scopes, reason, context) {\n    super(\n      `Invalid coordinate parameters: ${reason}. KTA: ${JSON.stringify(kta)}, Scopes: [${scopes.join(\", \")}]`,\n      kta,\n      scopes,\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidKTAError = class extends CoordinateError {\n  constructor(kta, reason, context) {\n    super(\n      `Invalid KTA (Key Type Array): ${reason}. Expected string or array of strings, got: ${JSON.stringify(kta)}`,\n      kta,\n      [],\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidScopesError = class extends CoordinateError {\n  invalidScopes;\n  constructor(scopes, invalidScopes, reason, context) {\n    super(\n      `Invalid scopes: ${reason}. Invalid scope values: ${JSON.stringify(invalidScopes)}`,\n      null,\n      scopes.filter((s) => typeof s === \"string\"),\n      { ...context, reason, invalidScopes }\n    );\n    this.invalidScopes = invalidScopes;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9AZmplbGwvcmVnaXN0cnkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDO0FBQ3JDLGdCQUFnQixnRUFBaUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDLGNBQWMsb0JBQW9CLElBQUksa0JBQWtCO0FBQ3hEO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUEyQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9AZmplbGwvcmVnaXN0cnkvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbG9nZ2VyLnRzXG5pbXBvcnQgTG9nZ2luZyBmcm9tIFwiQGZqZWxsL2xvZ2dpbmdcIjtcbnZhciBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcihcIkBmamVsbC9yZWdpc3RyeVwiKTtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExpYkxvZ2dlcjtcblxuLy8gc3JjL0Nvb3JkaW5hdGUudHNcbnZhciBsb2dnZXIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJDb29yZGluYXRlXCIpO1xudmFyIGNyZWF0ZUNvb3JkaW5hdGUgPSAoa3RhLCBzY29wZXMgPSBbXSkgPT4ge1xuICBjb25zdCBrdEFycmF5ID0gQXJyYXkuaXNBcnJheShrdGEpID8ga3RhIDogW2t0YV07XG4gIGNvbnN0IHRvU3RyaW5nID0gKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhcInRvU3RyaW5nXCIsIHsga3RhLCBzY29wZXMgfSk7XG4gICAgcmV0dXJuIGAke2t0QXJyYXkuam9pbihcIiwgXCIpfSAtICR7c2NvcGVzLmpvaW4oXCIsIFwiKX1gO1xuICB9O1xuICBsb2dnZXIuZGVidWcoXCJjcmVhdGVDb29yZGluYXRlXCIsIHsga3RhOiBrdEFycmF5LCBzY29wZXMsIHRvU3RyaW5nIH0pO1xuICByZXR1cm4geyBrdGE6IGt0QXJyYXksIHNjb3BlcywgdG9TdHJpbmcgfTtcbn07XG5cbi8vIHNyYy9JbnN0YW5jZS50c1xudmFyIGxvZ2dlcjIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJbnN0YW5jZVwiKTtcbnZhciBjcmVhdGVJbnN0YW5jZSA9IChyZWdpc3RyeSwgY29vcmRpbmF0ZSkgPT4ge1xuICBsb2dnZXIyLmRlYnVnKFwiY3JlYXRlSW5zdGFuY2VcIiwgeyBjb29yZGluYXRlLCByZWdpc3RyeSB9KTtcbiAgcmV0dXJuIHsgY29vcmRpbmF0ZSwgcmVnaXN0cnkgfTtcbn07XG52YXIgaXNJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICByZXR1cm4gaW5zdGFuY2UgIT09IG51bGwgJiYgaW5zdGFuY2UgIT09IHZvaWQgMCAmJiBpbnN0YW5jZS5jb29yZGluYXRlICE9PSB2b2lkIDAgJiYgaW5zdGFuY2UucmVnaXN0cnkgIT09IHZvaWQgMDtcbn07XG5cbi8vIHNyYy9SZWdpc3RyeVN0YXRzLnRzXG52YXIgUmVnaXN0cnlTdGF0cyA9IGNsYXNzIHtcbiAgdG90YWxDYWxscyA9IDA7XG4gIC8vIE1hcCBzdHJ1Y3R1cmU6IGt0YUtleSAtPiBzY29wZUtleSAtPiBjbGllbnRLZXkgLT4gY291bnRcbiAgY29vcmRpbmF0ZUNhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFJlY29yZHMgYSBnZXQoKSBjYWxsIGZvciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUgYW5kIGNsaWVudFxuICAgKi9cbiAgcmVjb3JkR2V0Q2FsbChrdGEsIHNjb3BlcywgY2xpZW50KSB7XG4gICAgdGhpcy50b3RhbENhbGxzKys7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IGNsaWVudEtleSA9IHRoaXMuY3JlYXRlQ2xpZW50S2V5KGNsaWVudCk7XG4gICAgaWYgKCF0aGlzLmNvb3JkaW5hdGVDYWxscy5oYXMoa3RhS2V5KSkge1xuICAgICAgdGhpcy5jb29yZGluYXRlQ2FsbHMuc2V0KGt0YUtleSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcC5oYXMoc2NvcGVLZXkpKSB7XG4gICAgICBzY29wZU1hcC5zZXQoc2NvcGVLZXksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnRNYXAgPSBzY29wZU1hcC5nZXQoc2NvcGVLZXkpO1xuICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IGNsaWVudE1hcC5nZXQoY2xpZW50S2V5KSB8fCAwO1xuICAgIGNsaWVudE1hcC5zZXQoY2xpZW50S2V5LCBjdXJyZW50Q291bnQgKyAxKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0aXN0aWNzIHNuYXBzaG90XG4gICAqL1xuICBnZXRTdGF0aXN0aWNzKCkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVDYWxsUmVjb3JkcyA9IFtdO1xuICAgIGxldCBzZXJ2aWNlQ2FsbHMgPSAwO1xuICAgIGxldCBhcHBsaWNhdGlvbkNhbGxzID0gMDtcbiAgICBsZXQgdW5pZGVudGlmaWVkQ2FsbHMgPSAwO1xuICAgIGZvciAoY29uc3QgW2t0YUtleSwgc2NvcGVNYXBdIG9mIHRoaXMuY29vcmRpbmF0ZUNhbGxzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtzY29wZUtleSwgY2xpZW50TWFwXSBvZiBzY29wZU1hcCkge1xuICAgICAgICBjb25zdCBjbGllbnRDYWxscyA9IFtdO1xuICAgICAgICBsZXQgdG90YWxDb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgW2NsaWVudEtleSwgY291bnRdIG9mIGNsaWVudE1hcCkge1xuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMucGFyc2VDbGllbnRLZXkoY2xpZW50S2V5KTtcbiAgICAgICAgICBpZiAoY2xpZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGllbnRDYWxscy5wdXNoKHsgY2xpZW50LCBjb3VudCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxDb3VudCArPSBjb3VudDtcbiAgICAgICAgICBpZiAoY2xpZW50S2V5ID09PSBcIl9fbm9fY2xpZW50X19cIikge1xuICAgICAgICAgICAgdW5pZGVudGlmaWVkQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2xpZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvbkNhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXJ2aWNlQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvb3JkaW5hdGVDYWxsUmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICBrdGE6IGt0YUtleS5zcGxpdChcIi5cIiksXG4gICAgICAgICAgc2NvcGVzOiB0aGlzLnBhcnNlU2NvcGVLZXkoc2NvcGVLZXkpLFxuICAgICAgICAgIGNvdW50OiB0b3RhbENvdW50LFxuICAgICAgICAgIGNsaWVudENhbGxzOiBbLi4uY2xpZW50Q2FsbHNdXG4gICAgICAgICAgLy8gUmV0dXJuIGEgY29weVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsR2V0Q2FsbHM6IHRoaXMudG90YWxDYWxscyxcbiAgICAgIGNvb3JkaW5hdGVDYWxsUmVjb3JkczogWy4uLmNvb3JkaW5hdGVDYWxsUmVjb3Jkc10sXG4gICAgICAvLyBSZXR1cm4gYSBjb3B5XG4gICAgICBjbGllbnRTdW1tYXJ5OiB7XG4gICAgICAgIHNlcnZpY2VDYWxscyxcbiAgICAgICAgYXBwbGljYXRpb25DYWxscyxcbiAgICAgICAgdW5pZGVudGlmaWVkQ2FsbHNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGNhbGwgY291bnQgZm9yIGEgc3BlY2lmaWMgY29vcmRpbmF0ZSBjb21iaW5hdGlvblxuICAgKi9cbiAgZ2V0Q2FsbENvdW50KGt0YSwgc2NvcGVzKSB7XG4gICAgY29uc3Qga3RhS2V5ID0ga3RhLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcCkgcmV0dXJuIDA7XG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBpZiAoIWNsaWVudE1hcCkgcmV0dXJuIDA7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IGNvdW50IG9mIGNsaWVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgdG90YWwgKz0gY291bnQ7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBjYWxsIGNvdW50IGZvciBhIHNwZWNpZmljIGNvb3JkaW5hdGUgY29tYmluYXRpb24gZnJvbSBhIHNwZWNpZmljIGNsaWVudFxuICAgKi9cbiAgZ2V0Q2FsbENvdW50QnlDbGllbnQoa3RhLCBzY29wZXMsIGNsaWVudCkge1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZUtleSA9IHRoaXMuY3JlYXRlU2NvcGVLZXkoc2NvcGVzIHx8IFtdKTtcbiAgICBjb25zdCBjbGllbnRLZXkgPSB0aGlzLmNyZWF0ZUNsaWVudEtleShjbGllbnQpO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcCkgcmV0dXJuIDA7XG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBpZiAoIWNsaWVudE1hcCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGNsaWVudE1hcC5nZXQoY2xpZW50S2V5KSB8fCAwO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRvdGFsIGNhbGxzIGZvciBhIHNwZWNpZmljIGt0YSAoYWNyb3NzIGFsbCBzY29wZXMpXG4gICAqL1xuICBnZXRUb3RhbENhbGxzRm9yS3RhKGt0YSkge1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChjb25zdCBjbGllbnRNYXAgb2Ygc2NvcGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY291bnQgb2YgY2xpZW50TWFwLnZhbHVlcygpKSB7XG4gICAgICAgIHRvdGFsICs9IGNvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYWxsIHVuaXF1ZSBrdGEgcGF0aHMgdGhhdCBoYXZlIGJlZW4gY2FsbGVkXG4gICAqL1xuICBnZXRDYWxsZWRLdGFQYXRocygpIHtcbiAgICBjb25zdCBrdGFQYXRocyA9IFtdO1xuICAgIGZvciAoY29uc3Qga3RhS2V5IG9mIHRoaXMuY29vcmRpbmF0ZUNhbGxzLmtleXMoKSkge1xuICAgICAga3RhUGF0aHMucHVzaChrdGFLZXkuc3BsaXQoXCIuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGt0YVBhdGhzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9ybWFsaXplZCBzY29wZSBrZXkgZnJvbSBzY29wZXMgYXJyYXlcbiAgICovXG4gIGNyZWF0ZVNjb3BlS2V5KHNjb3Blcykge1xuICAgIGlmIChzY29wZXMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJfX25vX3Njb3Blc19fXCI7XG4gICAgcmV0dXJuIFsuLi5zY29wZXNdLnNvcnQoKS5qb2luKFwiLFwiKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgc2NvcGUga2V5IGJhY2sgdG8gc2NvcGVzIGFycmF5XG4gICAqL1xuICBwYXJzZVNjb3BlS2V5KHNjb3BlS2V5KSB7XG4gICAgaWYgKHNjb3BlS2V5ID09PSBcIl9fbm9fc2NvcGVzX19cIikgcmV0dXJuIFtdO1xuICAgIHJldHVybiBzY29wZUtleS5zcGxpdChcIixcIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBub3JtYWxpemVkIGNsaWVudCBrZXkgZnJvbSBjbGllbnQgaWRlbnRpZmllclxuICAgKi9cbiAgY3JlYXRlQ2xpZW50S2V5KGNsaWVudCkge1xuICAgIGlmICghY2xpZW50KSByZXR1cm4gXCJfX25vX2NsaWVudF9fXCI7XG4gICAgaWYgKHR5cGVvZiBjbGllbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBgYXBwOiR7Y2xpZW50fWA7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkS2V5ID0gYCR7Y2xpZW50LmNvb3JkaW5hdGUua3RhLmpvaW4oXCIuXCIpfTske3RoaXMuY3JlYXRlU2NvcGVLZXkoY2xpZW50LmNvb3JkaW5hdGUuc2NvcGVzKX1gO1xuICAgIHJldHVybiBgc2VydmljZToke2NsaWVudC5yZWdpc3RyeVR5cGV9OiR7Y29vcmRLZXl9YDtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgY2xpZW50IGtleSBiYWNrIHRvIGNsaWVudCBpZGVudGlmaWVyXG4gICAqL1xuICBwYXJzZUNsaWVudEtleShjbGllbnRLZXkpIHtcbiAgICBpZiAoY2xpZW50S2V5ID09PSBcIl9fbm9fY2xpZW50X19cIikgcmV0dXJuIG51bGw7XG4gICAgaWYgKGNsaWVudEtleS5zdGFydHNXaXRoKFwiYXBwOlwiKSkge1xuICAgICAgcmV0dXJuIGNsaWVudEtleS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIGlmIChjbGllbnRLZXkuc3RhcnRzV2l0aChcInNlcnZpY2U6XCIpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGNsaWVudEtleS5zdWJzdHJpbmcoOCkuc3BsaXQoXCI6XCIpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCByZWdpc3RyeVR5cGUgPSBwYXJ0c1swXTtcbiAgICAgIGNvbnN0IGNvb3JkUGFydHMgPSBwYXJ0c1sxXS5zcGxpdChcIjtcIik7XG4gICAgICBpZiAoY29vcmRQYXJ0cy5sZW5ndGggIT09IDIpIHJldHVybiBudWxsO1xuICAgICAgY29uc3Qga3RhID0gY29vcmRQYXJ0c1swXS5zcGxpdChcIi5cIik7XG4gICAgICBjb25zdCBzY29wZXMgPSB0aGlzLnBhcnNlU2NvcGVLZXkoY29vcmRQYXJ0c1sxXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWdpc3RyeVR5cGUsXG4gICAgICAgIGNvb3JkaW5hdGU6IHsga3RhLCBzY29wZXMgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIHNyYy9SZWdpc3RyeS50c1xudmFyIGxvZ2dlcjMgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJSZWdpc3RyeVwiKTtcbnZhciBmaW5kU2NvcGVkSW5zdGFuY2UgPSAoc2NvcGVkSW5zdGFuY2VzLCByZXF1ZXN0ZWRTY29wZXMpID0+IHtcbiAgaWYgKCFyZXF1ZXN0ZWRTY29wZXMgfHwgcmVxdWVzdGVkU2NvcGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IGZpcnN0SW5zdGFuY2UgPSBzY29wZWRJbnN0YW5jZXNbMF0/Lmluc3RhbmNlO1xuICAgIGlmICghZmlyc3RJbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gaW5zdGFuY2VzIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0SW5zdGFuY2U7XG4gIH1cbiAgY29uc3QgbWF0Y2hpbmdJbnN0YW5jZSA9IHNjb3BlZEluc3RhbmNlcy5maW5kKChzY29wZWRJbnN0YW5jZSkgPT4ge1xuICAgIGlmICghc2NvcGVkSW5zdGFuY2Uuc2NvcGVzKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJlcXVlc3RlZFNjb3Blcy5ldmVyeShcbiAgICAgIChzY29wZSkgPT4gc2NvcGVkSW5zdGFuY2Uuc2NvcGVzICYmIHNjb3BlZEluc3RhbmNlLnNjb3Blcy5pbmNsdWRlcyhzY29wZSlcbiAgICApO1xuICB9KTtcbiAgaWYgKCFtYXRjaGluZ0luc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnN0YW5jZSBmb3VuZCBtYXRjaGluZyBzY29wZXM6ICR7cmVxdWVzdGVkU2NvcGVzLmpvaW4oXCIsIFwiKX1gKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hpbmdJbnN0YW5jZS5pbnN0YW5jZTtcbn07XG52YXIgY3JlYXRlUmVnaXN0cnkgPSAodHlwZSwgcmVnaXN0cnlIdWIpID0+IHtcbiAgY29uc3QgaW5zdGFuY2VUcmVlID0ge307XG4gIGNvbnN0IHJlZ2lzdHJ5U3RhdHMgPSBuZXcgUmVnaXN0cnlTdGF0cygpO1xuICBjb25zdCBjcmVhdGVQcm94aWVkUmVnaXN0cnkgPSAoY2FsbGluZ0Nvb3JkaW5hdGUpID0+IHtcbiAgICBjb25zdCBzZXJ2aWNlQ2xpZW50ID0ge1xuICAgICAgcmVnaXN0cnlUeXBlOiB0eXBlLFxuICAgICAgY29vcmRpbmF0ZToge1xuICAgICAgICBrdGE6IGNhbGxpbmdDb29yZGluYXRlLmt0YSxcbiAgICAgICAgc2NvcGVzOiBjYWxsaW5nQ29vcmRpbmF0ZS5zY29wZXNcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZWdpc3RyeSxcbiAgICAgIGdldDogKGt0YSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBjbGllbnRUb1VzZSA9IG9wdGlvbnM/LmNsaWVudCB8fCBzZXJ2aWNlQ2xpZW50O1xuICAgICAgICByZXR1cm4gcmVnaXN0cnkuZ2V0KGt0YSwgeyAuLi5vcHRpb25zLCBjbGllbnQ6IGNsaWVudFRvVXNlIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IGNyZWF0ZUluc3RhbmNlMiA9IChrdGEsIHNjb3BlcywgZmFjdG9yeSkgPT4ge1xuICAgIGxvZ2dlcjMuZGVidWcoYENyZWF0aW5nIGFuZCByZWdpc3RlcmluZyBpbnN0YW5jZSBmb3Iga2V5IHBhdGggYW5kIHNjb3Blc2AsIGt0YSwgc2NvcGVzLCBgaW4gcmVnaXN0cnkgdHlwZTogJHt0eXBlfWApO1xuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSBjcmVhdGVDb29yZGluYXRlKGt0YSwgc2NvcGVzKTtcbiAgICBjb25zdCBwcm94aWVkUmVnaXN0cnkgPSBjcmVhdGVQcm94aWVkUmVnaXN0cnkoY29vcmRpbmF0ZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBmYWN0b3J5KGNvb3JkaW5hdGUsIHtcbiAgICAgIHJlZ2lzdHJ5OiBwcm94aWVkUmVnaXN0cnksXG4gICAgICByZWdpc3RyeUh1YlxuICAgIH0pO1xuICAgIGlmICghaXNJbnN0YW5jZShpbnN0YW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFjdG9yeSBkaWQgbm90IHJldHVybiBhIHZhbGlkIGluc3RhbmNlIGZvcjogJHtrdGEuam9pbihcIi5cIil9YCk7XG4gICAgfVxuICAgIHJlZ2lzdGVySW50ZXJuYWwoa3RhLCBpbnN0YW5jZSwgeyBzY29wZXMgfSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuICBjb25zdCByZWdpc3RlckludGVybmFsID0gKGt0YSwgaW5zdGFuY2UsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBrZXlQYXRoID0gWy4uLmt0YV0ucmV2ZXJzZSgpO1xuICAgIGxldCBjdXJyZW50TGV2ZWwgPSBpbnN0YW5jZVRyZWU7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhgUmVnaXN0ZXJpbmcgaW5zdGFuY2UgZm9yIGtleSBwYXRoIGFuZCBzY29wZXNgLCBrZXlQYXRoLCBvcHRpb25zPy5zY29wZXMsIGBpbiByZWdpc3RyeSB0eXBlOiAke3R5cGV9YCk7XG4gICAgaWYgKCFpc0luc3RhbmNlKGluc3RhbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgbm9uLWluc3RhbmNlOiAke2t0YS5qb2luKFwiLlwiKX1gKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlUeXBlID0ga2V5UGF0aFtpXTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGkgPT09IGtleVBhdGgubGVuZ3RoIC0gMTtcbiAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXSA9IHtcbiAgICAgICAgICBpbnN0YW5jZXM6IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBpc0xlYWYgPyBudWxsIDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgY3VycmVudExldmVsW2tleVR5cGVdLmluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZXM6IG9wdGlvbnM/LnNjb3BlcyxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuKSB7XG4gICAgICAgICAgY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXIgPSAoa3RhLCBpbnN0YW5jZSwgb3B0aW9ucykgPT4ge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJVc2luZyBkZXByZWNhdGVkIHJlZ2lzdGVyIG1ldGhvZC4gQ29uc2lkZXIgdXNpbmcgY3JlYXRlSW5zdGFuY2UgaW5zdGVhZC5cIik7XG4gICAgcmVnaXN0ZXJJbnRlcm5hbChrdGEsIGluc3RhbmNlLCBvcHRpb25zKTtcbiAgfTtcbiAgY29uc3QgZ2V0ID0gKGt0YSwgb3B0aW9ucykgPT4ge1xuICAgIHJlZ2lzdHJ5U3RhdHMucmVjb3JkR2V0Q2FsbChrdGEsIG9wdGlvbnM/LnNjb3Blcywgb3B0aW9ucz8uY2xpZW50KTtcbiAgICBjb25zdCBrZXlQYXRoID0gWy4uLmt0YV0ucmV2ZXJzZSgpO1xuICAgIGxldCBjdXJyZW50TGV2ZWwgPSBpbnN0YW5jZVRyZWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlUeXBlID0ga2V5UGF0aFtpXTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGkgPT09IGtleVBhdGgubGVuZ3RoIC0gMTtcbiAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbihcIi5cIil9LCBNaXNzaW5nIGtleTogJHtrZXlUeXBlfWApO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICBjb25zdCBzY29wZWRJbnN0YW5jZXMgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uaW5zdGFuY2VzO1xuICAgICAgICBpZiAoc2NvcGVkSW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5zdGFuY2VzIHJlZ2lzdGVyZWQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKFwiLlwiKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZFNjb3BlZEluc3RhbmNlKHNjb3BlZEluc3RhbmNlcywgb3B0aW9ucz8uc2NvcGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKFwiLlwiKX0sIE5vIGNoaWxkcmVuIGZvcjogJHtrZXlUeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0IGdldENvb3JkaW5hdGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gICAgY29uc3QgdHJhdmVyc2VUcmVlID0gKG5vZGUpID0+IHtcbiAgICAgIGZvciAoY29uc3Qga2V5VHlwZSBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IHRyZWVOb2RlID0gbm9kZVtrZXlUeXBlXTtcbiAgICAgICAgZm9yIChjb25zdCBzY29wZWRJbnN0YW5jZSBvZiB0cmVlTm9kZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKHNjb3BlZEluc3RhbmNlLmluc3RhbmNlLmNvb3JkaW5hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlTm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIHRyYXZlcnNlVHJlZSh0cmVlTm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRyYXZlcnNlVHJlZShpbnN0YW5jZVRyZWUpO1xuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGlzdGljcyA9ICgpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0cnlTdGF0cy5nZXRTdGF0aXN0aWNzKCk7XG4gIH07XG4gIGNvbnN0IHJlZ2lzdHJ5ID0ge1xuICAgIHR5cGUsXG4gICAgcmVnaXN0cnlIdWIsXG4gICAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlMixcbiAgICByZWdpc3RlcixcbiAgICBnZXQsXG4gICAgZ2V0Q29vcmRpbmF0ZXMsXG4gICAgZ2V0U3RhdGlzdGljcyxcbiAgICBpbnN0YW5jZVRyZWVcbiAgfTtcbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufTtcblxuLy8gc3JjL2Vycm9ycy9SZWdpc3RyeUVycm9yLnRzXG52YXIgUmVnaXN0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICByZWdpc3RyeVR5cGU7XG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJlZ2lzdHJ5VHlwZSA9IHJlZ2lzdHJ5VHlwZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IEVycm9yQ29uc3RydWN0b3IgPSBFcnJvcjtcbiAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgRXJyb3JDb25zdHJ1Y3Rvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGV0YWlscygpIHtcbiAgICBjb25zdCBkZXRhaWxzID0gW3RoaXMubWVzc2FnZV07XG4gICAgaWYgKHRoaXMucmVnaXN0cnlUeXBlKSB7XG4gICAgICBkZXRhaWxzLnB1c2goYFJlZ2lzdHJ5IFR5cGU6ICR7dGhpcy5yZWdpc3RyeVR5cGV9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgIGRldGFpbHMucHVzaChgQ29udGV4dDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNvbnRleHQsIG51bGwsIDIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZGV0YWlscy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIFJlZ2lzdHJ5Q3JlYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKGBGYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJ5IG9mIHR5cGUgJyR7dHlwZX0nOiAke3JlYXNvbn1gLCB0eXBlLCBjb250ZXh0KTtcbiAgfVxufTtcbnZhciBJbnZhbGlkRmFjdG9yeVJlc3VsdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga2V5UGF0aDtcbiAgZmFjdG9yeVJlc3VsdDtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgZmFjdG9yeVJlc3VsdCwgcmVnaXN0cnlUeXBlKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgRmFjdG9yeSBkaWQgbm90IHJldHVybiBhIHZhbGlkIGluc3RhbmNlIGZvcjogJHtrZXlQYXRoU3RyfS4gRXhwZWN0ZWQgaW5zdGFuY2Ugd2l0aCAnY29vcmRpbmF0ZScgYW5kICdyZWdpc3RyeScgcHJvcGVydGllcywgZ290OiAke3R5cGVvZiBmYWN0b3J5UmVzdWx0fWAsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IGtleVBhdGgsIGZhY3RvcnlSZXN1bHQ6IHR5cGVvZiBmYWN0b3J5UmVzdWx0IH1cbiAgICApO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdGhpcy5mYWN0b3J5UmVzdWx0ID0gZmFjdG9yeVJlc3VsdDtcbiAgfVxufTtcbnZhciBJbnZhbGlkSW5zdGFuY2VSZWdpc3RyYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGtleVBhdGg7XG4gIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uLCByZWdpc3RyeVR5cGUpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBBdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgbm9uLWluc3RhbmNlOiAke2tleVBhdGhTdHJ9LiBFeHBlY3RlZCBpbnN0YW5jZSB3aXRoICdjb29yZGluYXRlJyBhbmQgJ3JlZ2lzdHJ5JyBwcm9wZXJ0aWVzLCBnb3Q6ICR7dHlwZW9mIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbn1gLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyBrZXlQYXRoLCBhdHRlbXB0ZWRSZWdpc3RyYXRpb246IHR5cGVvZiBhdHRlbXB0ZWRSZWdpc3RyYXRpb24gfVxuICAgICk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lzdHJhdGlvbiA9IGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9SZWdpc3RyeUh1YkVycm9yLnRzXG52YXIgUmVnaXN0cnlIdWJFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGh1YlR5cGU7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGh1YlR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBlbnJpY2hlZENvbnRleHQgPSBodWJUeXBlID8geyAuLi5jb250ZXh0LCBodWJUeXBlIH0gOiBjb250ZXh0O1xuICAgIHN1cGVyKG1lc3NhZ2UsIFwiXCIsIGVucmljaGVkQ29udGV4dCk7XG4gICAgdGhpcy5odWJUeXBlID0gaHViVHlwZTtcbiAgfVxufTtcbnZhciBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIGR1cGxpY2F0ZVR5cGU7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBhbHJlYWR5IHJlZ2lzdGVyZWQgdW5kZXIgdHlwZTogJHt0eXBlfS4gRWFjaCByZWdpc3RyeSB0eXBlIG11c3QgYmUgdW5pcXVlIHdpdGhpbiBhIHJlZ2lzdHJ5IGh1Yi5gLFxuICAgICAgXCJcIixcbiAgICAgIHsgLi4uY29udGV4dCwgZHVwbGljYXRlVHlwZTogdHlwZSB9XG4gICAgKTtcbiAgICB0aGlzLmR1cGxpY2F0ZVR5cGUgPSB0eXBlO1xuICB9XG59O1xudmFyIFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICByZXF1ZXN0ZWRUeXBlO1xuICBhdmFpbGFibGVUeXBlcztcbiAgY29uc3RydWN0b3IocmVxdWVzdGVkVHlwZSwgYXZhaWxhYmxlVHlwZXMgPSBbXSwgY29udGV4dCkge1xuICAgIGxldCBtZXNzYWdlID0gYE5vIHJlZ2lzdHJ5IHJlZ2lzdGVyZWQgdW5kZXIgdHlwZTogJHtyZXF1ZXN0ZWRUeXBlfWA7XG4gICAgaWYgKGF2YWlsYWJsZVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2UgKz0gYC4gQXZhaWxhYmxlIHR5cGVzOiBbJHthdmFpbGFibGVUeXBlcy5qb2luKFwiLCBcIil9XWA7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIFwiXCIsIHsgLi4uY29udGV4dCwgcmVxdWVzdGVkVHlwZSwgYXZhaWxhYmxlVHlwZXMgfSk7XG4gICAgdGhpcy5yZXF1ZXN0ZWRUeXBlID0gcmVxdWVzdGVkVHlwZTtcbiAgICB0aGlzLmF2YWlsYWJsZVR5cGVzID0gYXZhaWxhYmxlVHlwZXM7XG4gIH1cbn07XG52YXIgUmVnaXN0cnlGYWN0b3J5RXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBmYWN0b3J5RXJyb3I7XG4gIGF0dGVtcHRlZFR5cGU7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGZhY3RvcnlFcnJvciwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGZhY3RvcnkgZmFpbGVkIHRvIGNyZWF0ZSByZWdpc3RyeSBvZiB0eXBlICcke3R5cGV9JzogJHtmYWN0b3J5RXJyb3IubWVzc2FnZX1gLFxuICAgICAgXCJcIixcbiAgICAgIHsgLi4uY29udGV4dCwgYXR0ZW1wdGVkVHlwZTogdHlwZSwgb3JpZ2luYWxFcnJvcjogZmFjdG9yeUVycm9yLm1lc3NhZ2UgfVxuICAgICk7XG4gICAgdGhpcy5mYWN0b3J5RXJyb3IgPSBmYWN0b3J5RXJyb3I7XG4gICAgdGhpcy5hdHRlbXB0ZWRUeXBlID0gdHlwZTtcbiAgfVxufTtcbnZhciBJbnZhbGlkUmVnaXN0cnlGYWN0b3J5UmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBmYWN0b3J5UmVzdWx0O1xuICBhdHRlbXB0ZWRUeXBlO1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBmYWN0b3J5UmVzdWx0LCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVnaXN0cnkgZmFjdG9yeSByZXR1cm5lZCBpbnZhbGlkIHJlZ2lzdHJ5IGZvciB0eXBlICcke3R5cGV9Jy4gRXhwZWN0ZWQgcmVnaXN0cnkgd2l0aCAndHlwZScsICdnZXQnLCAncmVnaXN0ZXInLCBhbmQgJ2NyZWF0ZUluc3RhbmNlJyBwcm9wZXJ0aWVzLCBnb3Q6ICR7dHlwZW9mIGZhY3RvcnlSZXN1bHR9YCxcbiAgICAgIFwiXCIsXG4gICAgICB7IC4uLmNvbnRleHQsIGF0dGVtcHRlZFR5cGU6IHR5cGUsIGZhY3RvcnlSZXN1bHQ6IHR5cGVvZiBmYWN0b3J5UmVzdWx0IH1cbiAgICApO1xuICAgIHRoaXMuZmFjdG9yeVJlc3VsdCA9IGZhY3RvcnlSZXN1bHQ7XG4gICAgdGhpcy5hdHRlbXB0ZWRUeXBlID0gdHlwZTtcbiAgfVxufTtcblxuLy8gc3JjL1JlZ2lzdHJ5SHViLnRzXG52YXIgbG9nZ2VyNCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIlJlZ2lzdHJ5SHViXCIpO1xudmFyIGNyZWF0ZVJlZ2lzdHJ5SHViID0gKCkgPT4ge1xuICBjb25zdCByZWdpc3RyaWVzID0ge307XG4gIGNvbnN0IGNyZWF0ZVJlZ2lzdHJ5MiA9ICh0eXBlLCBmYWN0b3J5KSA9PiB7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgQ3JlYXRpbmcgbmV3IHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gZmFjdG9yeSh0eXBlLCBodWIpO1xuICAgIGlmICghKFwicmVnaXN0cnlIdWJcIiBpbiByZWdpc3RyeSkgfHwgcmVnaXN0cnkucmVnaXN0cnlIdWIgIT09IGh1Yikge1xuICAgICAgcmVnaXN0cnkucmVnaXN0cnlIdWIgPSBodWI7XG4gICAgfVxuICAgIHJlZ2lzdHJpZXNbdHlwZV0gPSByZWdpc3RyeTtcbiAgICBsb2dnZXI0LmRlYnVnKGBTdWNjZXNzZnVsbHkgY3JlYXRlZCBhbmQgcmVnaXN0ZXJlZCBuZXcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICB9O1xuICBjb25zdCByZWdpc3RlclJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHJlZ2lzdHJ5LnR5cGU7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgUmVnaXN0ZXJpbmcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG4gICAgaWYgKHJlZ2lzdHJpZXNbdHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG4gICAgcmVnaXN0cmllc1t0eXBlXSA9IHJlZ2lzdHJ5O1xuICAgIGlmICghKFwicmVnaXN0cnlIdWJcIiBpbiByZWdpc3RyeSkgfHwgcmVnaXN0cnkucmVnaXN0cnlIdWIgIT09IGh1Yikge1xuICAgICAgcmVnaXN0cnkucmVnaXN0cnlIdWIgPSBodWI7XG4gICAgfVxuICAgIGxvZ2dlcjQuZGVidWcoYFN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkIHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICB9O1xuICBjb25zdCBnZXQgPSAodHlwZSwga3RhLCBvcHRpb25zKSA9PiB7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgTG9va2luZyB1cCBpbnN0YW5jZSBmb3IgdHlwZTogJHt0eXBlfSwga3RhOiAke2t0YS5qb2luKFwiLlwiKX0sIHNjb3BlczogJHtvcHRpb25zPy5zY29wZXM/LmpvaW4oXCIsXCIpIHx8IFwibm9uZVwifWApO1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gcmVnaXN0cmllc1t0eXBlXTtcbiAgICBpZiAoIXJlZ2lzdHJ5KSB7XG4gICAgICBjb25zdCBhdmFpbGFibGVUeXBlcyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJpZXMpO1xuICAgICAgdGhyb3cgbmV3IFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IodHlwZSwgYXZhaWxhYmxlVHlwZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0cnkuZ2V0KGt0YSwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IGdldFJlZ2lzdHJ5ID0gKHR5cGUpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0cmllc1t0eXBlXSB8fCBudWxsO1xuICB9O1xuICBjb25zdCBnZXRSZWdpc3RlcmVkVHlwZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdHJpZXMpO1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyUmVnaXN0cnkgPSAodHlwZSkgPT4ge1xuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICBkZWxldGUgcmVnaXN0cmllc1t0eXBlXTtcbiAgICAgIGxvZ2dlcjQuZGVidWcoYFVucmVnaXN0ZXJlZCByZWdpc3RyeSB1bmRlciB0eXBlOiAke3R5cGV9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBjb25zdCBnZXRBbGxDb29yZGluYXRlcyA9ICgpID0+IHtcbiAgICBjb25zdCBhbGxDb29yZGluYXRlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVnaXN0cnlUeXBlIGluIHJlZ2lzdHJpZXMpIHtcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gcmVnaXN0cmllc1tyZWdpc3RyeVR5cGVdO1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSByZWdpc3RyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaCgoY29vcmRpbmF0ZSkgPT4ge1xuICAgICAgICBhbGxDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICBjb29yZGluYXRlLFxuICAgICAgICAgIHJlZ2lzdHJ5VHlwZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsb2dnZXI0LmRlYnVnKGBSZXRyaWV2ZWQgJHthbGxDb29yZGluYXRlcy5sZW5ndGh9IHRvdGFsIGNvb3JkaW5hdGVzIGZyb20gJHtPYmplY3Qua2V5cyhyZWdpc3RyaWVzKS5sZW5ndGh9IHJlZ2lzdHJpZXNgKTtcbiAgICByZXR1cm4gYWxsQ29vcmRpbmF0ZXM7XG4gIH07XG4gIGNvbnN0IGh1YiA9IHtcbiAgICBjcmVhdGVSZWdpc3RyeTogY3JlYXRlUmVnaXN0cnkyLFxuICAgIHJlZ2lzdGVyUmVnaXN0cnksXG4gICAgZ2V0LFxuICAgIGdldFJlZ2lzdHJ5LFxuICAgIGdldFJlZ2lzdGVyZWRUeXBlcyxcbiAgICBnZXRBbGxDb29yZGluYXRlcyxcbiAgICB1bnJlZ2lzdGVyUmVnaXN0cnlcbiAgfTtcbiAgcmV0dXJuIGh1Yjtcbn07XG5cbi8vIHNyYy9lcnJvcnMvSW5zdGFuY2VFcnJvci50c1xudmFyIEluc3RhbmNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrZXlQYXRoO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBrZXlQYXRoLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCByZWdpc3RyeVR5cGUsIHsgLi4uY29udGV4dCwga2V5UGF0aCB9KTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICB9XG59O1xudmFyIEluc3RhbmNlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIG1pc3NpbmdLZXk7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIG1pc3NpbmdLZXksIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIGxldCBtZXNzYWdlID0gYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn1gO1xuICAgIGlmIChtaXNzaW5nS2V5KSB7XG4gICAgICBtZXNzYWdlICs9IGAsIE1pc3Npbmcga2V5OiAke21pc3NpbmdLZXl9YDtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSwga2V5UGF0aCwgcmVnaXN0cnlUeXBlLCB7IC4uLmNvbnRleHQsIG1pc3NpbmdLZXkgfSk7XG4gICAgdGhpcy5taXNzaW5nS2V5ID0gbWlzc2luZ0tleTtcbiAgfVxufTtcbnZhciBOb0luc3RhbmNlc1JlZ2lzdGVyZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYE5vIGluc3RhbmNlcyByZWdpc3RlcmVkIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfS4gVGhlIGtleSBwYXRoIGV4aXN0cyBpbiB0aGUgcmVnaXN0cnkgdHJlZSBidXQgY29udGFpbnMgbm8gaW5zdGFuY2VzLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbn07XG52YXIgTm9JbnN0YW5jZXNBdmFpbGFibGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYE5vIGluc3RhbmNlcyBhdmFpbGFibGUgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9LiBUaGlzIHR5cGljYWxseSBpbmRpY2F0ZXMgYW4gaW50ZXJuYWwgcmVnaXN0cnkgc3RhdGUgaXNzdWUuYCxcbiAgICAgIGtleVBhdGgsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxufTtcbnZhciBTY29wZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICByZXF1ZXN0ZWRTY29wZXM7XG4gIGF2YWlsYWJsZVNjb3BlcztcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcmVxdWVzdGVkU2NvcGVzLCBhdmFpbGFibGVTY29wZXMgPSBbXSwgcmVnaXN0cnlUeXBlKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVzU3RyID0gcmVxdWVzdGVkU2NvcGVzLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBhdmFpbGFibGVTY29wZXNTdHIgPSBhdmFpbGFibGVTY29wZXMubWFwKChzY29wZXMpID0+IGBbJHtzY29wZXMuam9pbihcIiwgXCIpfV1gKS5qb2luKFwiLCBcIik7XG4gICAgbGV0IG1lc3NhZ2UgPSBgTm8gaW5zdGFuY2UgZm91bmQgbWF0Y2hpbmcgc2NvcGVzOiAke3Njb3Blc1N0cn0gZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9YDtcbiAgICBpZiAoYXZhaWxhYmxlU2NvcGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2UgKz0gYC4gQXZhaWxhYmxlIHNjb3BlczogJHthdmFpbGFibGVTY29wZXNTdHJ9YDtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSwga2V5UGF0aCwgcmVnaXN0cnlUeXBlLCB7IHJlcXVlc3RlZFNjb3BlcywgYXZhaWxhYmxlU2NvcGVzIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkU2NvcGVzID0gcmVxdWVzdGVkU2NvcGVzO1xuICAgIHRoaXMuYXZhaWxhYmxlU2NvcGVzID0gYXZhaWxhYmxlU2NvcGVzO1xuICB9XG59O1xudmFyIE5vQ2hpbGRyZW5BdmFpbGFibGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIHBhcmVudEtleTtcbiAgY29uc3RydWN0b3Ioa2V5UGF0aCwgcGFyZW50S2V5LCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9LCBObyBjaGlsZHJlbiBmb3I6ICR7cGFyZW50S2V5fS4gVGhlIHBhdGggY2Fubm90IGJlIHRyYXZlcnNlZCBmdXJ0aGVyIGFzICcke3BhcmVudEtleX0nIGhhcyBubyBjaGlsZCBub2Rlcy5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsgLi4uY29udGV4dCwgcGFyZW50S2V5IH1cbiAgICApO1xuICAgIHRoaXMucGFyZW50S2V5ID0gcGFyZW50S2V5O1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzL0Nvb3JkaW5hdGVFcnJvci50c1xudmFyIENvb3JkaW5hdGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGt0YTtcbiAgc2NvcGVzO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBrdGEsIHNjb3BlcywgY29udGV4dCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIFwiXCIsIHsgLi4uY29udGV4dCwga3RhLCBzY29wZXMgfSk7XG4gICAgdGhpcy5rdGEgPSBrdGE7XG4gICAgdGhpcy5zY29wZXMgPSBzY29wZXM7XG4gIH1cbn07XG52YXIgSW52YWxpZENvb3JkaW5hdGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa3RhLCBzY29wZXMsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgY29vcmRpbmF0ZSBwYXJhbWV0ZXJzOiAke3JlYXNvbn0uIEtUQTogJHtKU09OLnN0cmluZ2lmeShrdGEpfSwgU2NvcGVzOiBbJHtzY29wZXMuam9pbihcIiwgXCIpfV1gLFxuICAgICAga3RhLFxuICAgICAgc2NvcGVzLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24gfVxuICAgICk7XG4gIH1cbn07XG52YXIgSW52YWxpZEtUQUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrdGEsIHJlYXNvbiwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYEludmFsaWQgS1RBIChLZXkgVHlwZSBBcnJheSk6ICR7cmVhc29ufS4gRXhwZWN0ZWQgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGdvdDogJHtKU09OLnN0cmluZ2lmeShrdGEpfWAsXG4gICAgICBrdGEsXG4gICAgICBbXSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uIH1cbiAgICApO1xuICB9XG59O1xudmFyIEludmFsaWRTY29wZXNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgaW52YWxpZFNjb3BlcztcbiAgY29uc3RydWN0b3Ioc2NvcGVzLCBpbnZhbGlkU2NvcGVzLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhbGlkIHNjb3BlczogJHtyZWFzb259LiBJbnZhbGlkIHNjb3BlIHZhbHVlczogJHtKU09OLnN0cmluZ2lmeShpbnZhbGlkU2NvcGVzKX1gLFxuICAgICAgbnVsbCxcbiAgICAgIHNjb3Blcy5maWx0ZXIoKHMpID0+IHR5cGVvZiBzID09PSBcInN0cmluZ1wiKSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uLCBpbnZhbGlkU2NvcGVzIH1cbiAgICApO1xuICAgIHRoaXMuaW52YWxpZFNjb3BlcyA9IGludmFsaWRTY29wZXM7XG4gIH1cbn07XG5leHBvcnQge1xuICBDb29yZGluYXRlRXJyb3IsXG4gIER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yLFxuICBJbnN0YW5jZUVycm9yLFxuICBJbnN0YW5jZU5vdEZvdW5kRXJyb3IsXG4gIEludmFsaWRDb29yZGluYXRlRXJyb3IsXG4gIEludmFsaWRGYWN0b3J5UmVzdWx0RXJyb3IsXG4gIEludmFsaWRJbnN0YW5jZVJlZ2lzdHJhdGlvbkVycm9yLFxuICBJbnZhbGlkS1RBRXJyb3IsXG4gIEludmFsaWRSZWdpc3RyeUZhY3RvcnlSZXN1bHRFcnJvcixcbiAgSW52YWxpZFNjb3Blc0Vycm9yLFxuICBOb0NoaWxkcmVuQXZhaWxhYmxlRXJyb3IsXG4gIE5vSW5zdGFuY2VzQXZhaWxhYmxlRXJyb3IsXG4gIE5vSW5zdGFuY2VzUmVnaXN0ZXJlZEVycm9yLFxuICBSZWdpc3RyeUNyZWF0aW9uRXJyb3IsXG4gIFJlZ2lzdHJ5RXJyb3IsXG4gIFJlZ2lzdHJ5RmFjdG9yeUVycm9yLFxuICBSZWdpc3RyeUh1YkVycm9yLFxuICBSZWdpc3RyeVN0YXRzLFxuICBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yLFxuICBTY29wZU5vdEZvdW5kRXJyb3IsXG4gIGNyZWF0ZUNvb3JkaW5hdGUsXG4gIGNyZWF0ZUluc3RhbmNlLFxuICBjcmVhdGVSZWdpc3RyeSxcbiAgY3JlYXRlUmVnaXN0cnlIdWIsXG4gIGlzSW5zdGFuY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/@fjell/registry/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/deepmerge/dist/cjs.js":
/*!**************************************************************!*\
  !*** ../fjell-client-api/node_modules/deepmerge/dist/cjs.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwgc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/deepmerge/dist/cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js":
/*!**************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/datetime.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DateTime),\n/* harmony export */   friendlyDateTime: () => (/* binding */ friendlyDateTime)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/info.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_diff_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./impl/diff.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/diff.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./impl/tokenParser.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/tokenParser.js\");\n/* harmony import */ var _impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./impl/conversions.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/conversions.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/invalid.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid DateTime\";\nconst MAX_DATE = 8.64e15;\n\nfunction unsupportedZone(zone) {\n  return new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unsupported zone\", `the zone \"${zone.name}\" is not supported`);\n}\n\n// we cache week data on the DT object and this intermediates the cache\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedWeekData(dt) {\n  if (dt.weekData === null) {\n    dt.weekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(dt.c);\n  }\n  return dt.weekData;\n}\n\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedLocalWeekData(dt) {\n  if (dt.localWeekData === null) {\n    dt.localWeekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(\n      dt.c,\n      dt.loc.getMinDaysInFirstWeek(),\n      dt.loc.getStartOfWeek()\n    );\n  }\n  return dt.localWeekData;\n}\n\n// clone really means, \"make a new object with these modifications\". all \"setters\" really use this\n// to create a new object while only changing some of the properties\nfunction clone(inst, alts) {\n  const current = {\n    ts: inst.ts,\n    zone: inst.zone,\n    c: inst.c,\n    o: inst.o,\n    loc: inst.loc,\n    invalid: inst.invalid,\n  };\n  return new DateTime({ ...current, ...alts, old: current });\n}\n\n// find the right offset a given local time. The o input is our guess, which determines which\n// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)\nfunction fixOffset(localTS, o, tz) {\n  // Our UTC time is just a guess because our offset is just a guess\n  let utcGuess = localTS - o * 60 * 1000;\n\n  // Test whether the zone matches the offset for this ts\n  const o2 = tz.offset(utcGuess);\n\n  // If so, offset didn't change and we're done\n  if (o === o2) {\n    return [utcGuess, o];\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= (o2 - o) * 60 * 1000;\n\n  // If that gives us the local time we want, we're done\n  const o3 = tz.offset(utcGuess);\n  if (o2 === o3) {\n    return [utcGuess, o2];\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];\n}\n\n// convert an epoch timestamp into a calendar object with the given offset\nfunction tsToObj(ts, offset) {\n  ts += offset * 60 * 1000;\n\n  const d = new Date(ts);\n\n  return {\n    year: d.getUTCFullYear(),\n    month: d.getUTCMonth() + 1,\n    day: d.getUTCDate(),\n    hour: d.getUTCHours(),\n    minute: d.getUTCMinutes(),\n    second: d.getUTCSeconds(),\n    millisecond: d.getUTCMilliseconds(),\n  };\n}\n\n// convert a calendar object to a epoch timestamp\nfunction objToTS(obj, offset, zone) {\n  return fixOffset((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(obj), offset, zone);\n}\n\n// create a new DT instance by adding a duration, adjusting for DSTs\nfunction adjustTime(inst, dur) {\n  const oPre = inst.o,\n    year = inst.c.year + Math.trunc(dur.years),\n    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,\n    c = {\n      ...inst.c,\n      year,\n      month,\n      day:\n        Math.min(inst.c.day, (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(year, month)) +\n        Math.trunc(dur.days) +\n        Math.trunc(dur.weeks) * 7,\n    },\n    millisToAdd = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject({\n      years: dur.years - Math.trunc(dur.years),\n      quarters: dur.quarters - Math.trunc(dur.quarters),\n      months: dur.months - Math.trunc(dur.months),\n      weeks: dur.weeks - Math.trunc(dur.weeks),\n      days: dur.days - Math.trunc(dur.days),\n      hours: dur.hours,\n      minutes: dur.minutes,\n      seconds: dur.seconds,\n      milliseconds: dur.milliseconds,\n    }).as(\"milliseconds\"),\n    localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(c);\n\n  let [ts, o] = fixOffset(localTS, oPre, inst.zone);\n\n  if (millisToAdd !== 0) {\n    ts += millisToAdd;\n    // that could have changed the offset by going over a DST, but we want to keep the ts the same\n    o = inst.zone.offset(ts);\n  }\n\n  return { ts, o };\n}\n\n// helper useful in turning the results of parsing into real dates\n// by handling the zone options\nfunction parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {\n  const { setZone, zone } = opts;\n  if ((parsed && Object.keys(parsed).length !== 0) || parsedZone) {\n    const interpretationZone = parsedZone || zone,\n      inst = DateTime.fromObject(parsed, {\n        ...opts,\n        zone: interpretationZone,\n        specificOffset,\n      });\n    return setZone ? inst : inst.setZone(zone);\n  } else {\n    return DateTime.invalid(\n      new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unparsable\", `the input \"${text}\" can't be parsed as ${format}`)\n    );\n  }\n}\n\n// if you want to output a technical format (e.g. RFC 2822), this helper\n// helps handle the details\nfunction toTechFormat(dt, format, allowZ = true) {\n  return dt.isValid\n    ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(_impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create(\"en-US\"), {\n        allowZ,\n        forceSimple: true,\n      }).formatDateTimeFromString(dt, format)\n    : null;\n}\n\nfunction toISODate(o, extended, precision) {\n  const longFormat = o.c.year > 9999 || o.c.year < 0;\n  let c = \"\";\n  if (longFormat && o.c.year >= 0) c += \"+\";\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.year, longFormat ? 6 : 4);\n  if (precision === \"year\") return c;\n  if (extended) {\n    c += \"-\";\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n    c += \"-\";\n  } else {\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n  }\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.day);\n  return c;\n}\n\nfunction toISOTime(\n  o,\n  extended,\n  suppressSeconds,\n  suppressMilliseconds,\n  includeOffset,\n  extendedZone,\n  precision\n) {\n  let showSeconds = !suppressSeconds || o.c.millisecond !== 0 || o.c.second !== 0,\n    c = \"\";\n  switch (precision) {\n    case \"day\":\n    case \"month\":\n    case \"year\":\n      break;\n    default:\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.hour);\n      if (precision === \"hour\") break;\n      if (extended) {\n        c += \":\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += \":\";\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      } else {\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      }\n      if (precision === \"second\") break;\n      if (showSeconds && (!suppressMilliseconds || o.c.millisecond !== 0)) {\n        c += \".\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.millisecond, 3);\n      }\n  }\n\n  if (includeOffset) {\n    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {\n      c += \"Z\";\n    } else if (o.o < 0) {\n      c += \"-\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o % 60));\n    } else {\n      c += \"+\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o % 60));\n    }\n  }\n\n  if (extendedZone) {\n    c += \"[\" + o.zone.ianaName + \"]\";\n  }\n  return c;\n}\n\n// defaults for unspecified units in the supported calendars\nconst defaultUnitValues = {\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultWeekUnitValues = {\n    weekNumber: 1,\n    weekday: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultOrdinalUnitValues = {\n    ordinal: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  };\n\n// Units in the supported calendars, sorted by bigness\nconst orderedUnits = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"],\n  orderedWeekUnits = [\n    \"weekYear\",\n    \"weekNumber\",\n    \"weekday\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\",\n  ],\n  orderedOrdinalUnits = [\"year\", \"ordinal\", \"hour\", \"minute\", \"second\", \"millisecond\"];\n\n// standardize case and plurality in units\nfunction normalizeUnit(unit) {\n  const normalized = {\n    year: \"year\",\n    years: \"year\",\n    month: \"month\",\n    months: \"month\",\n    day: \"day\",\n    days: \"day\",\n    hour: \"hour\",\n    hours: \"hour\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    second: \"second\",\n    seconds: \"second\",\n    millisecond: \"millisecond\",\n    milliseconds: \"millisecond\",\n    weekday: \"weekday\",\n    weekdays: \"weekday\",\n    weeknumber: \"weekNumber\",\n    weeksnumber: \"weekNumber\",\n    weeknumbers: \"weekNumber\",\n    weekyear: \"weekYear\",\n    weekyears: \"weekYear\",\n    ordinal: \"ordinal\",\n  }[unit.toLowerCase()];\n\n  if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidUnitError(unit);\n\n  return normalized;\n}\n\nfunction normalizeUnitWithLocalWeeks(unit) {\n  switch (unit.toLowerCase()) {\n    case \"localweekday\":\n    case \"localweekdays\":\n      return \"localWeekday\";\n    case \"localweeknumber\":\n    case \"localweeknumbers\":\n      return \"localWeekNumber\";\n    case \"localweekyear\":\n    case \"localweekyears\":\n      return \"localWeekYear\";\n    default:\n      return normalizeUnit(unit);\n  }\n}\n\n// cache offsets for zones based on the current timestamp when this function is\n// first called. When we are handling a datetime from components like (year,\n// month, day, hour) in a time zone, we need a guess about what the timezone\n// offset is so that we can convert into a UTC timestamp. One way is to find the\n// offset of now in the zone. The actual date may have a different offset (for\n// example, if we handle a date in June while we're in December in a zone that\n// observes DST), but we can check and adjust that.\n//\n// When handling many dates, calculating the offset for now every time is\n// expensive. It's just a guess, so we can cache the offset to use even if we\n// are right on a time change boundary (we'll just correct in the other\n// direction). Using a timestamp from first read is a slight optimization for\n// handling dates close to the current date, since those dates will usually be\n// in the same offset (we could set the timestamp statically, instead). We use a\n// single timestamp for all zones to make things a bit more predictable.\n//\n// This is safe for quickDT (used by local() and utc()) because we don't fill in\n// higher-order units from tsNow (as we do in fromObject, this requires that\n// offset is calculated from tsNow).\n/**\n * @param {Zone} zone\n * @return {number}\n */\nfunction guessOffsetForZone(zone) {\n  if (zoneOffsetTs === undefined) {\n    zoneOffsetTs = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  // Do not cache anything but IANA zones, because it is not safe to do so.\n  // Guessing an offset which is not present in the zone can cause wrong results from fixOffset\n  if (zone.type !== \"iana\") {\n    return zone.offset(zoneOffsetTs);\n  }\n  const zoneName = zone.name;\n  let offsetGuess = zoneOffsetGuessCache.get(zoneName);\n  if (offsetGuess === undefined) {\n    offsetGuess = zone.offset(zoneOffsetTs);\n    zoneOffsetGuessCache.set(zoneName, offsetGuess);\n  }\n  return offsetGuess;\n}\n\n// this is a dumbed down version of fromObject() that runs about 60% faster\n// but doesn't do any validation, makes a bunch of assumptions about what units\n// are present, and so on.\nfunction quickDT(obj, opts) {\n  const zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  if (!zone.isValid) {\n    return DateTime.invalid(unsupportedZone(zone));\n  }\n\n  const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n\n  let ts, o;\n\n  // assume we have the higher-order units\n  if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj.year)) {\n    for (const u of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj[u])) {\n        obj[u] = defaultUnitValues[u];\n      }\n    }\n\n    const invalid = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(obj) || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(obj);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    const offsetProvis = guessOffsetForZone(zone);\n    [ts, o] = objToTS(obj, offsetProvis, zone);\n  } else {\n    ts = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  return new DateTime({ ts, zone, loc, o });\n}\n\nfunction diffRelative(start, end, opts) {\n  const round = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.round) ? true : opts.round,\n    rounding = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.rounding) ? \"trunc\" : opts.rounding,\n    format = (c, unit) => {\n      c = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.roundTo)(c, round || opts.calendary ? 0 : 2, opts.calendary ? \"round\" : rounding);\n      const formatter = end.loc.clone(opts).relFormatter(opts);\n      return formatter.format(c, unit);\n    },\n    differ = (unit) => {\n      if (opts.calendary) {\n        if (!end.hasSame(start, unit)) {\n          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);\n        } else return 0;\n      } else {\n        return end.diff(start, unit).get(unit);\n      }\n    };\n\n  if (opts.unit) {\n    return format(differ(opts.unit), opts.unit);\n  }\n\n  for (const unit of opts.units) {\n    const count = differ(unit);\n    if (Math.abs(count) >= 1) {\n      return format(count, unit);\n    }\n  }\n  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);\n}\n\nfunction lastOpts(argList) {\n  let opts = {},\n    args;\n  if (argList.length > 0 && typeof argList[argList.length - 1] === \"object\") {\n    opts = argList[argList.length - 1];\n    args = Array.from(argList).slice(0, argList.length - 1);\n  } else {\n    args = Array.from(argList);\n  }\n  return [opts, args];\n}\n\n/**\n * Timestamp to use for cached zone offset guesses (exposed for test)\n */\nlet zoneOffsetTs;\n/**\n * Cache for zone offset guesses (exposed for test).\n *\n * This optimizes quickDT via guessOffsetForZone to avoid repeated calls of\n * zone.offset().\n */\nconst zoneOffsetGuessCache = new Map();\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},\n * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.\n * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nclass DateTime {\n  /**\n   * @access private\n   */\n  constructor(config) {\n    const zone = config.zone || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone;\n\n    let invalid =\n      config.invalid ||\n      (Number.isNaN(config.ts) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null) ||\n      (!zone.isValid ? unsupportedZone(zone) : null);\n    /**\n     * @access private\n     */\n    this.ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(config.ts) ? _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now() : config.ts;\n\n    let c = null,\n      o = null;\n    if (!invalid) {\n      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);\n\n      if (unchanged) {\n        [c, o] = [config.old.c, config.old.o];\n      } else {\n        // If an offset has been passed and we have not been called from\n        // clone(), we can trust it and avoid the offset calculation.\n        const ot = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(config.o) && !config.old ? config.o : zone.offset(this.ts);\n        c = tsToObj(this.ts, ot);\n        invalid = Number.isNaN(c.year) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null;\n        c = invalid ? null : c;\n        o = invalid ? null : ot;\n      }\n    }\n\n    /**\n     * @access private\n     */\n    this._zone = zone;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.invalid = invalid;\n    /**\n     * @access private\n     */\n    this.weekData = null;\n    /**\n     * @access private\n     */\n    this.localWeekData = null;\n    /**\n     * @access private\n     */\n    this.c = c;\n    /**\n     * @access private\n     */\n    this.o = o;\n    /**\n     * @access private\n     */\n    this.isLuxonDateTime = true;\n  }\n\n  // CONSTRUCT\n\n  /**\n   * Create a DateTime for the current instant, in the system's time zone.\n   *\n   * Use Settings to override these default values if needed.\n   * @example DateTime.now().toISO() //~> now in the ISO format\n   * @return {DateTime}\n   */\n  static now() {\n    return new DateTime({});\n  }\n\n  /**\n   * Create a local DateTime\n   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month, 1-indexed\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @example DateTime.local()                                  //~> now\n   * @example DateTime.local({ zone: \"America/New_York\" })      //~> now, in US east coast time\n   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00\n   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00\n   * @example DateTime.local(2017, 3, 12, { locale: \"fr\" })     //~> 2017-03-12T00:00:00, with a French locale\n   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00\n   * @example DateTime.local(2017, 3, 12, 5, { zone: \"utc\" })   //~> 2017-03-12T05:00:00, in UTC\n   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765\n   * @return {DateTime}\n   */\n  static local() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime in UTC\n   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.utc()                                              //~> now\n   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z\n   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: \"fr\" })          //~> 2017-03-12T05:45:00Z with a French locale\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: \"fr\" }) //~> 2017-03-12T05:45:10.765Z with a French locale\n   * @return {DateTime}\n   */\n  static utc() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n\n    opts.zone = _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].utcInstance;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime from a JavaScript Date object. Uses the default zone.\n   * @param {Date} date - a JavaScript Date object\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @return {DateTime}\n   */\n  static fromJSDate(date, options = {}) {\n    const ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isDate)(date) ? date.valueOf() : NaN;\n    if (Number.isNaN(ts)) {\n      return DateTime.invalid(\"invalid input\");\n    }\n\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    return new DateTime({\n      ts: ts,\n      zone: zoneToUse,\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n    });\n  }\n\n  /**\n   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} milliseconds - a number of milliseconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromMillis(milliseconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(milliseconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`\n      );\n    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {\n      // this isn't perfect because we can still end up out of range because of additional shifting, but it's a start\n      return DateTime.invalid(\"Timestamp out of range\");\n    } else {\n      return new DateTime({\n        ts: milliseconds,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} seconds - a number of seconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromSeconds(seconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(seconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromSeconds requires a numerical input\");\n    } else {\n      return new DateTime({\n        ts: seconds * 1000,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.year - a year, such as 1987\n   * @param {number} obj.month - a month, 1-12\n   * @param {number} obj.day - a day of the month, 1-31, depending on the month\n   * @param {number} obj.ordinal - day of the year, 1-365 or 366\n   * @param {number} obj.weekYear - an ISO week year\n   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n   * @param {number} obj.localWeekYear - a week year, according to the locale\n   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale\n   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale\n   * @param {number} obj.hour - hour of the day, 0-23\n   * @param {number} obj.minute - minute of the hour, 0-59\n   * @param {number} obj.second - second of the minute, 0-59\n   * @param {number} obj.millisecond - millisecond of the second, 0-999\n   * @param {Object} opts - options for creating this DateTime\n   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()\n   * @param {string} [opts.locale='system\\'s locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })\n   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: \"en-US\" }).toISODate() //=> '2021-12-26'\n   * @return {DateTime}\n   */\n  static fromObject(obj, opts = {}) {\n    obj = obj || {};\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(obj, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, loc);\n\n    const tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now(),\n      offsetProvis = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.specificOffset)\n        ? opts.specificOffset\n        : zoneToUse.offset(tsNow),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    // cases:\n    // just a weekday -> this week's instance of that weekday, no worries\n    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error\n    // (gregorian month or day) + ordinal -> error\n    // otherwise just use weeks or ordinals or gregorian, depending on what's specified\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);\n\n    // configure ourselves to deal with gregorian dates or week stuff\n    let units,\n      defaultValues,\n      objNow = tsToObj(tsNow, offsetProvis);\n    if (useWeekData) {\n      units = orderedWeekUnits;\n      defaultValues = defaultWeekUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(objNow, minDaysInFirstWeek, startOfWeek);\n    } else if (containsOrdinal) {\n      units = orderedOrdinalUnits;\n      defaultValues = defaultOrdinalUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(objNow);\n    } else {\n      units = orderedUnits;\n      defaultValues = defaultUnitValues;\n    }\n\n    // set default values for missing stuff\n    let foundFirst = false;\n    for (const u of units) {\n      const v = normalized[u];\n      if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(v)) {\n        foundFirst = true;\n      } else if (foundFirst) {\n        normalized[u] = defaultValues[u];\n      } else {\n        normalized[u] = objNow[u];\n      }\n    }\n\n    // make sure the values we have are in range\n    const higherOrderInvalid = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidWeekData)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidOrdinalData)(normalized)\n        : (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(normalized),\n      invalid = higherOrderInvalid || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(normalized);\n\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    // compute the actual time\n    const gregorian = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)(normalized)\n        : normalized,\n      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),\n      inst = new DateTime({\n        ts: tsFinal,\n        zone: zoneToUse,\n        o: offsetFinal,\n        loc,\n      });\n\n    // gregorian data + weekday serves only to validate\n    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {\n      return DateTime.invalid(\n        \"mismatched weekday\",\n        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`\n      );\n    }\n\n    if (!inst.isValid) {\n      return DateTime.invalid(inst.invalid);\n    }\n\n    return inst;\n  }\n\n  /**\n   * Create a DateTime from an ISO 8601 string\n   * @param {string} text - the ISO string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n   * @example DateTime.fromISO('2016-W05-4')\n   * @return {DateTime}\n   */\n  static fromISO(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseISODate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"ISO 8601\", text);\n  }\n\n  /**\n   * Create a DateTime from an RFC 2822 string\n   * @param {string} text - the RFC 2822 string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n   * @return {DateTime}\n   */\n  static fromRFC2822(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseRFC2822Date)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"RFC 2822\", text);\n  }\n\n  /**\n   * Create a DateTime from an HTTP header date\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @param {string} text - the HTTP header date\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n   * @return {DateTime}\n   */\n  static fromHTTP(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseHTTPDate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"HTTP\", opts);\n  }\n\n  /**\n   * Create a DateTime from an input string and format string.\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromFormat(text, fmt, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(fmt)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromFormat requires an input string and a format\");\n    }\n\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      }),\n      [vals, parsedZone, specificOffset, invalid] = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.parseFromTokens)(localeToUse, text, fmt);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    } else {\n      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);\n    }\n  }\n\n  /**\n   * @deprecated use fromFormat instead\n   */\n  static fromString(text, fmt, opts = {}) {\n    return DateTime.fromFormat(text, fmt, opts);\n  }\n\n  /**\n   * Create a DateTime from a SQL date, time, or datetime\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale\n   * @param {string} text - the string to parse\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @example DateTime.fromSQL('2017-05-15')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n   * @example DateTime.fromSQL('09:12:34.342')\n   * @return {DateTime}\n   */\n  static fromSQL(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseSQL)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"SQL\", text);\n  }\n\n  /**\n   * Create an invalid DateTime.\n   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {DateTime}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"need to specify a reason the DateTime is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidDateTimeError(invalid);\n    } else {\n      return new DateTime({ invalid });\n    }\n  }\n\n  /**\n   * Check if an object is an instance of DateTime. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDateTime(o) {\n    return (o && o.isLuxonDateTime) || false;\n  }\n\n  /**\n   * Produce the format string for a set of options\n   * @param formatOpts\n   * @param localeOpts\n   * @returns {string}\n   */\n  static parseFormatForOpts(formatOpts, localeOpts = {}) {\n    const tokenList = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.formatOptsToTokens)(formatOpts, _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join(\"\");\n  }\n\n  /**\n   * Produce the the fully expanded format token for the locale\n   * Does NOT quote characters, so quoted tokens will not round trip correctly\n   * @param fmt\n   * @param localeOpts\n   * @returns {string}\n   */\n  static expandFormat(fmt, localeOpts = {}) {\n    const expanded = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.expandMacroTokens)(_impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseFormat(fmt), _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return expanded.map((t) => t.val).join(\"\");\n  }\n\n  static resetCache() {\n    zoneOffsetTs = undefined;\n    zoneOffsetGuessCache.clear();\n  }\n\n  // INFO\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7\n   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4\n   * @return {number}\n   */\n  get(unit) {\n    return this[unit];\n  }\n\n  /**\n   * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n   * * The DateTime was created by an operation on another invalid date\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get outputCalendar() {\n    return this.isValid ? this.loc.outputCalendar : null;\n  }\n\n  /**\n   * Get the time zone associated with this DateTime.\n   * @type {Zone}\n   */\n  get zone() {\n    return this._zone;\n  }\n\n  /**\n   * Get the name of the time zone.\n   * @type {string}\n   */\n  get zoneName() {\n    return this.isValid ? this.zone.name : null;\n  }\n\n  /**\n   * Get the year\n   * @example DateTime.local(2017, 5, 25).year //=> 2017\n   * @type {number}\n   */\n  get year() {\n    return this.isValid ? this.c.year : NaN;\n  }\n\n  /**\n   * Get the quarter\n   * @example DateTime.local(2017, 5, 25).quarter //=> 2\n   * @type {number}\n   */\n  get quarter() {\n    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\n  }\n\n  /**\n   * Get the month (1-12).\n   * @example DateTime.local(2017, 5, 25).month //=> 5\n   * @type {number}\n   */\n  get month() {\n    return this.isValid ? this.c.month : NaN;\n  }\n\n  /**\n   * Get the day of the month (1-30ish).\n   * @example DateTime.local(2017, 5, 25).day //=> 25\n   * @type {number}\n   */\n  get day() {\n    return this.isValid ? this.c.day : NaN;\n  }\n\n  /**\n   * Get the hour of the day (0-23).\n   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n   * @type {number}\n   */\n  get hour() {\n    return this.isValid ? this.c.hour : NaN;\n  }\n\n  /**\n   * Get the minute of the hour (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n   * @type {number}\n   */\n  get minute() {\n    return this.isValid ? this.c.minute : NaN;\n  }\n\n  /**\n   * Get the second of the minute (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n   * @type {number}\n   */\n  get second() {\n    return this.isValid ? this.c.second : NaN;\n  }\n\n  /**\n   * Get the millisecond of the second (0-999).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n   * @type {number}\n   */\n  get millisecond() {\n    return this.isValid ? this.c.millisecond : NaN;\n  }\n\n  /**\n   * Get the week year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015\n   * @type {number}\n   */\n  get weekYear() {\n    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the week number of the week year (1-52ish).\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21\n   * @type {number}\n   */\n  get weekNumber() {\n    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the day of the week.\n   * 1 is Monday and 7 is Sunday\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 11, 31).weekday //=> 4\n   * @type {number}\n   */\n  get weekday() {\n    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Returns true if this date is on a weekend according to the locale, false otherwise\n   * @returns {boolean}\n   */\n  get isWeekend() {\n    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);\n  }\n\n  /**\n   * Get the day of the week according to the locale.\n   * 1 is the first day of the week and 7 is the last day of the week.\n   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,\n   * @returns {number}\n   */\n  get localWeekday() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,\n   * because the week can start on different days of the week (see localWeekday) and because a different number of days\n   * is required for a week to count as the first week of a year.\n   * @returns {number}\n   */\n  get localWeekNumber() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)\n   * differently, see localWeekNumber.\n   * @returns {number}\n   */\n  get localWeekYear() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the ordinal (meaning the day of the year)\n   * @example DateTime.local(2017, 5, 25).ordinal //=> 145\n   * @type {number|DateTime}\n   */\n  get ordinal() {\n    return this.isValid ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c).ordinal : NaN;\n  }\n\n  /**\n   * Get the human readable short month name, such as 'Oct'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct\n   * @type {string}\n   */\n  get monthShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"short\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable long month name, such as 'October'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthLong //=> October\n   * @type {string}\n   */\n  get monthLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"long\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable short weekday, such as 'Mon'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n   * @type {string}\n   */\n  get weekdayShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"short\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the human readable long weekday, such as 'Monday'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n   * @type {string}\n   */\n  get weekdayLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"long\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the UTC offset of this DateTime in minutes\n   * @example DateTime.now().offset //=> -240\n   * @example DateTime.utc().offset //=> 0\n   * @type {number}\n   */\n  get offset() {\n    return this.isValid ? +this.o : NaN;\n  }\n\n  /**\n   * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameShort() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"short\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameLong() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"long\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get whether this zone's offset ever changes, as in a DST.\n   * @type {boolean}\n   */\n  get isOffsetFixed() {\n    return this.isValid ? this.zone.isUniversal : null;\n  }\n\n  /**\n   * Get whether the DateTime is in a DST.\n   * @type {boolean}\n   */\n  get isInDST() {\n    if (this.isOffsetFixed) {\n      return false;\n    } else {\n      return (\n        this.offset > this.set({ month: 1, day: 1 }).offset ||\n        this.offset > this.set({ month: 5 }).offset\n      );\n    }\n  }\n\n  /**\n   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC\n   * in this DateTime's zone. During DST changes local time can be ambiguous, for example\n   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.\n   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.\n   * @returns {DateTime[]}\n   */\n  getPossibleOffsets() {\n    if (!this.isValid || this.isOffsetFixed) {\n      return [this];\n    }\n    const dayMs = 86400000;\n    const minuteMs = 60000;\n    const localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(this.c);\n    const oEarlier = this.zone.offset(localTS - dayMs);\n    const oLater = this.zone.offset(localTS + dayMs);\n\n    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);\n    const o2 = this.zone.offset(localTS - oLater * minuteMs);\n    if (o1 === o2) {\n      return [this];\n    }\n    const ts1 = localTS - o1 * minuteMs;\n    const ts2 = localTS - o2 * minuteMs;\n    const c1 = tsToObj(ts1, o1);\n    const c2 = tsToObj(ts2, o2);\n    if (\n      c1.hour === c2.hour &&\n      c1.minute === c2.minute &&\n      c1.second === c2.second &&\n      c1.millisecond === c2.millisecond\n    ) {\n      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];\n    }\n    return [this];\n  }\n\n  /**\n   * Returns true if this DateTime is in a leap year, false otherwise\n   * @example DateTime.local(2016).isInLeapYear //=> true\n   * @example DateTime.local(2013).isInLeapYear //=> false\n   * @type {boolean}\n   */\n  get isInLeapYear() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isLeapYear)(this.year);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's month\n   * @example DateTime.local(2016, 2).daysInMonth //=> 29\n   * @example DateTime.local(2016, 3).daysInMonth //=> 31\n   * @type {number}\n   */\n  get daysInMonth() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(this.year, this.month);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's year\n   * @example DateTime.local(2016).daysInYear //=> 366\n   * @example DateTime.local(2013).daysInYear //=> 365\n   * @type {number}\n   */\n  get daysInYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInYear)(this.year) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2004).weeksInWeekYear //=> 53\n   * @example DateTime.local(2013).weeksInWeekYear //=> 52\n   * @type {number}\n   */\n  get weeksInWeekYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(this.weekYear) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's local week year\n   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52\n   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53\n   * @type {number}\n   */\n  get weeksInLocalWeekYear() {\n    return this.isValid\n      ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(\n          this.localWeekYear,\n          this.loc.getMinDaysInFirstWeek(),\n          this.loc.getStartOfWeek()\n        )\n      : NaN;\n  }\n\n  /**\n   * Returns the resolved Intl options for this DateTime.\n   * This is useful in understanding the behavior of formatting methods\n   * @param {Object} opts - the same options as toLocaleString\n   * @return {Object}\n   */\n  resolvedLocaleOptions(opts = {}) {\n    const { locale, numberingSystem, calendar } = _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(\n      this.loc.clone(opts),\n      opts\n    ).resolvedOptions(this);\n    return { locale, numberingSystem, outputCalendar: calendar };\n  }\n\n  // TRANSFORM\n\n  /**\n   * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to {@link DateTime#setZone}('utc')\n   * @param {number} [offset=0] - optionally, an offset from UTC in minutes\n   * @param {Object} [opts={}] - options to pass to `setZone()`\n   * @return {DateTime}\n   */\n  toUTC(offset = 0, opts = {}) {\n    return this.setZone(_zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance(offset), opts);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to `setZone('local')`\n   * @return {DateTime}\n   */\n  toLocal() {\n    return this.setZone(_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n   *\n   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.\n   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.\n   * @return {DateTime}\n   */\n  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {\n    zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (zone.equals(this.zone)) {\n      return this;\n    } else if (!zone.isValid) {\n      return DateTime.invalid(unsupportedZone(zone));\n    } else {\n      let newTS = this.ts;\n      if (keepLocalTime || keepCalendarTime) {\n        const offsetGuess = zone.offset(this.ts);\n        const asObj = this.toObject();\n        [newTS] = objToTS(asObj, offsetGuess, zone);\n      }\n      return clone(this, { ts: newTS, zone });\n    }\n  }\n\n  /**\n   * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\n   * @param {Object} properties - the properties to set\n   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\n   * @return {DateTime}\n   */\n  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });\n    return clone(this, { loc });\n  }\n\n  /**\n   * \"Set\" the locale. Returns a newly-constructed DateTime.\n   * Just a convenient alias for reconfigure({ locale })\n   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')\n   * @return {DateTime}\n   */\n  setLocale(locale) {\n    return this.reconfigure({ locale });\n  }\n\n  /**\n   * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n   * You can only set units with this method; for \"setting\" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.\n   *\n   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.\n   * They cannot be mixed with ISO-week units like `weekday`.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dt.set({ year: 2017 })\n   * @example dt.set({ hour: 8, minute: 30 })\n   * @example dt.set({ weekday: 5 })\n   * @example dt.set({ year: 2005, ordinal: 234 })\n   * @return {DateTime}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(values, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, this.loc);\n\n    const settingWeekStuff =\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekYear) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekNumber) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekday),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    let mixed;\n    if (settingWeekStuff) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(\n        { ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },\n        minDaysInFirstWeek,\n        startOfWeek\n      );\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal)) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)({ ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c), ...normalized });\n    } else {\n      mixed = { ...this.toObject(), ...normalized };\n\n      // if we didn't set the day but we ended up on an overflow date,\n      // use the last day of the right month\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day)) {\n        mixed.day = Math.min((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(mixed.year, mixed.month), mixed.day);\n      }\n    }\n\n    const [ts, o] = objToTS(mixed, this.o, this.zone);\n    return clone(this, { ts, o });\n  }\n\n  /**\n   * Add a period of time to this DateTime and return the resulting DateTime\n   *\n   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @example DateTime.now().plus(123) //~> in 123 milliseconds\n   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday\n   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n   * @return {DateTime}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration);\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * Subtract a period of time to this DateTime and return the resulting DateTime\n   * See {@link DateTime#plus}\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   @return {DateTime}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration).negate();\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * \"Set\" this DateTime to the beginning of a unit of time.\n   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n   * @return {DateTime}\n   */\n  startOf(unit, { useLocaleWeeks = false } = {}) {\n    if (!this.isValid) return this;\n\n    const o = {},\n      normalizedUnit = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit(unit);\n    switch (normalizedUnit) {\n      case \"years\":\n        o.month = 1;\n      // falls through\n      case \"quarters\":\n      case \"months\":\n        o.day = 1;\n      // falls through\n      case \"weeks\":\n      case \"days\":\n        o.hour = 0;\n      // falls through\n      case \"hours\":\n        o.minute = 0;\n      // falls through\n      case \"minutes\":\n        o.second = 0;\n      // falls through\n      case \"seconds\":\n        o.millisecond = 0;\n        break;\n      case \"milliseconds\":\n        break;\n      // no default, invalid units throw in normalizeUnit()\n    }\n\n    if (normalizedUnit === \"weeks\") {\n      if (useLocaleWeeks) {\n        const startOfWeek = this.loc.getStartOfWeek();\n        const { weekday } = this;\n        if (weekday < startOfWeek) {\n          o.weekNumber = this.weekNumber - 1;\n        }\n        o.weekday = startOfWeek;\n      } else {\n        o.weekday = 1;\n      }\n    }\n\n    if (normalizedUnit === \"quarters\") {\n      const q = Math.ceil(this.month / 3);\n      o.month = (q - 1) * 3 + 1;\n    }\n\n    return this.set(o);\n  }\n\n  /**\n   * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n   * @return {DateTime}\n   */\n  endOf(unit, opts) {\n    return this.isValid\n      ? this.plus({ [unit]: 1 })\n          .startOf(unit, opts)\n          .minus(1)\n      : this;\n  }\n\n  // OUTPUT\n\n  /**\n   * Returns a string representation of this DateTime formatted according to the specified format string.\n   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.\n   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation\n   * of the DateTime in the assigned locale.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toLocaleString(); //=> 4/20/2017\n   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'\n   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), formatOpts).formatDateTime(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an array of format \"parts\", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\n   * @example DateTime.now().toLocaleParts(); //=> [\n   *                                   //=>   { type: 'day', value: '25' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'month', value: '05' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'year', value: '1982' }\n   *                                   //=> ]\n   */\n  toLocaleParts(opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), opts).formatDateTimeParts(this)\n      : [];\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n   * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'\n   * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'\n   * @return {string|null}\n   */\n  toISO({\n    format = \"extended\",\n    suppressSeconds = false,\n    suppressMilliseconds = false,\n    includeOffset = true,\n    extendedZone = false,\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    const ext = format === \"extended\";\n\n    let c = toISODate(this, ext, precision);\n    if (orderedUnits.indexOf(precision) >= 3) c += \"T\";\n    c += toISOTime(\n      this,\n      ext,\n      suppressSeconds,\n      suppressMilliseconds,\n      includeOffset,\n      extendedZone,\n      precision\n    );\n    return c;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's date component\n   * @param {Object} opts - options\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.\n   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'\n   * @return {string|null}\n   */\n  toISODate({ format = \"extended\", precision = \"day\" } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, format === \"extended\", normalizeUnit(precision));\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's week date\n   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n   * @return {string}\n   */\n  toISOWeekDate() {\n    return toTechFormat(this, \"kkkk-'W'WW-c\");\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's time component\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'\n   * @return {string}\n   */\n  toISOTime({\n    suppressMilliseconds = false,\n    suppressSeconds = false,\n    includeOffset = true,\n    includePrefix = false,\n    extendedZone = false,\n    format = \"extended\",\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    let c = includePrefix && orderedUnits.indexOf(precision) >= 3 ? \"T\" : \"\";\n    return (\n      c +\n      toISOTime(\n        this,\n        format === \"extended\",\n        suppressSeconds,\n        suppressMilliseconds,\n        includeOffset,\n        extendedZone,\n        precision\n      )\n    );\n  }\n\n  /**\n   * Returns an RFC 2822-compatible string representation of this DateTime\n   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n   * @return {string}\n   */\n  toRFC2822() {\n    return toTechFormat(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\", false);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.\n   * Specifically, the string conforms to RFC 1123.\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n   * @return {string}\n   */\n  toHTTP() {\n    return toTechFormat(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\");\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Date\n   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n   * @return {string|null}\n   */\n  toSQLDate() {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Time\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc().toSQL() //=> '05:15:16.345'\n   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n   * @return {string}\n   */\n  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {\n    let fmt = \"HH:mm:ss.SSS\";\n\n    if (includeZone || includeOffset) {\n      if (includeOffsetSpace) {\n        fmt += \" \";\n      }\n      if (includeZone) {\n        fmt += \"z\";\n      } else if (includeOffset) {\n        fmt += \"ZZ\";\n      }\n    }\n\n    return toTechFormat(this, fmt, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n   * @return {string}\n   */\n  toSQL(opts = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for debugging\n   * @return {string}\n   */\n  toString() {\n    return this.isValid ? this.toISO() : INVALID;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;\n    } else {\n      return `DateTime { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime.\n   * @return {number}\n   */\n  toMillis() {\n    return this.isValid ? this.ts : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.\n   * @return {number}\n   */\n  toSeconds() {\n    return this.isValid ? this.ts / 1000 : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (as a whole number) of this DateTime.\n   * @return {number}\n   */\n  toUnixInteger() {\n    return this.isValid ? Math.floor(this.ts / 1000) : NaN;\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a BSON serializable equivalent to this DateTime.\n   * @return {Date}\n   */\n  toBSON() {\n    return this.toJSDate();\n  }\n\n  /**\n   * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n   * @param opts - options for generating the object\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\n   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n   * @return {Object}\n   */\n  toObject(opts = {}) {\n    if (!this.isValid) return {};\n\n    const base = { ...this.c };\n\n    if (opts.includeConfig) {\n      base.outputCalendar = this.outputCalendar;\n      base.numberingSystem = this.loc.numberingSystem;\n      base.locale = this.loc.locale;\n    }\n    return base;\n  }\n\n  /**\n   * Returns a JavaScript Date equivalent to this DateTime.\n   * @return {Date}\n   */\n  toJSDate() {\n    return new Date(this.isValid ? this.ts : NaN);\n  }\n\n  // COMPARE\n\n  /**\n   * Return the difference between two DateTimes as a Duration.\n   * @param {DateTime} otherDateTime - the DateTime to compare this one to\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example\n   * var i1 = DateTime.fromISO('1982-05-25T09:45'),\n   *     i2 = DateTime.fromISO('1983-10-14T10:30');\n   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n   * @return {Duration}\n   */\n  diff(otherDateTime, unit = \"milliseconds\", opts = {}) {\n    if (!this.isValid || !otherDateTime.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].invalid(\"created by diffing an invalid DateTime\");\n    }\n\n    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };\n\n    const units = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.maybeArray)(unit).map(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit),\n      otherIsLater = otherDateTime.valueOf() > this.valueOf(),\n      earlier = otherIsLater ? this : otherDateTime,\n      later = otherIsLater ? otherDateTime : this,\n      diffed = (0,_impl_diff_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(earlier, later, units, durOpts);\n\n    return otherIsLater ? diffed.negate() : diffed;\n  }\n\n  /**\n   * Return the difference between this DateTime and right now.\n   * See {@link DateTime#diff}\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  diffNow(unit = \"milliseconds\", opts = {}) {\n    return this.diff(DateTime.now(), unit, opts);\n  }\n\n  /**\n   * Return an Interval spanning between this DateTime and another DateTime\n   * @param {DateTime} otherDateTime - the other end point of the Interval\n   * @return {Interval|DateTime}\n   */\n  until(otherDateTime) {\n    return this.isValid ? _interval_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDateTimes(this, otherDateTime) : this;\n  }\n\n  /**\n   * Return whether this DateTime is in the same unit of time as another DateTime.\n   * Higher-order units must also be identical for this function to return `true`.\n   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.\n   * @param {DateTime} otherDateTime - the other DateTime\n   * @param {string} unit - the unit of time to check sameness on\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used\n   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n   * @return {boolean}\n   */\n  hasSame(otherDateTime, unit, opts) {\n    if (!this.isValid) return false;\n\n    const inputMs = otherDateTime.valueOf();\n    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });\n    return (\n      adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts)\n    );\n  }\n\n  /**\n   * Equality check\n   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.\n   * To compare just the millisecond values, use `+dt1 === +dt2`.\n   * @param {DateTime} other - the other DateTime\n   * @return {boolean}\n   */\n  equals(other) {\n    return (\n      this.isValid &&\n      other.isValid &&\n      this.valueOf() === other.valueOf() &&\n      this.zone.equals(other.zone) &&\n      this.loc.equals(other.loc)\n    );\n  }\n\n  /**\n   * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\n   * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} [options.style=\"long\"] - the style of units, must be \"long\", \"short\", or \"narrow\"\n   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of \"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", or \"seconds\"\n   * @param {boolean} [options.round=true] - whether to round the numbers in the output.\n   * @param {string} [options.rounding=\"trunc\"] - rounding method to use when rounding the numbers in the output. Can be \"trunc\" (toward zero), \"expand\" (away from zero), \"round\", \"floor\", or \"ceil\".\n   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n   * @example DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"\n   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n   */\n  toRelative(options = {}) {\n    if (!this.isValid) return null;\n    const base = options.base || DateTime.fromObject({}, { zone: this.zone }),\n      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;\n    let units = [\"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\"];\n    let unit = options.unit;\n    if (Array.isArray(options.unit)) {\n      units = options.unit;\n      unit = undefined;\n    }\n    return diffRelative(base, this.plus(padding), {\n      ...options,\n      numeric: \"always\",\n      units,\n      unit,\n    });\n  }\n\n  /**\n   * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"years\", \"quarters\", \"months\", \"weeks\", or \"days\"\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n   * @example DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"maana\"\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n   */\n  toRelativeCalendar(options = {}) {\n    if (!this.isValid) return null;\n\n    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {\n      ...options,\n      numeric: \"auto\",\n      units: [\"years\", \"months\", \"days\"],\n      calendary: true,\n    });\n  }\n\n  /**\n   * Return the min of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum\n   * @return {DateTime} the min DateTime, or undefined if called with no argument\n   */\n  static min(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"min requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.min);\n  }\n\n  /**\n   * Return the max of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum\n   * @return {DateTime} the max DateTime, or undefined if called with no argument\n   */\n  static max(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"max requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.max);\n  }\n\n  // MISC\n\n  /**\n   * Explain how a string would be parsed by fromFormat()\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see description)\n   * @param {Object} options - options taken by fromFormat()\n   * @return {Object}\n   */\n  static fromFormatExplain(text, fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.explainFromTokens)(localeToUse, text, fmt);\n  }\n\n  /**\n   * @deprecated use fromFormatExplain instead\n   */\n  static fromStringExplain(text, fmt, options = {}) {\n    return DateTime.fromFormatExplain(text, fmt, options);\n  }\n\n  /**\n   * Build a parser for `fmt` using the given locale. This parser can be passed\n   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This\n   * can be used to optimize cases where many dates need to be parsed in a\n   * specific format.\n   *\n   * @param {String} fmt - the format the string is expected to be in (see\n   * description)\n   * @param {Object} options - options used to set locale and numberingSystem\n   * for parser\n   * @returns {TokenParser} - opaque object to be used\n   */\n  static buildFormatParser(fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return new _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.TokenParser(localeToUse, fmt);\n  }\n\n  /**\n   * Create a DateTime from an input string and format parser.\n   *\n   * The format parser must have been created with the same locale as this call.\n   *\n   * @param {String} text - the string to parse\n   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}\n   * @param {Object} opts - options taken by fromFormat()\n   * @returns {DateTime}\n   */\n  static fromFormatParser(text, formatParser, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(formatParser)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        \"fromFormatParser requires an input string and a format parser\"\n      );\n    }\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n\n    if (!localeToUse.equals(formatParser.locale)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromFormatParser called with a locale of ${localeToUse}, ` +\n          `but the format parser was created for ${formatParser.locale}`\n      );\n    }\n\n    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);\n\n    if (invalidReason) {\n      return DateTime.invalid(invalidReason);\n    } else {\n      return parseDataToDateTime(\n        result,\n        zone,\n        opts,\n        `format ${formatParser.format}`,\n        text,\n        specificOffset\n      );\n    }\n  }\n\n  // FORMAT PRESETS\n\n  /**\n   * {@link DateTime#toLocaleString} format like 10/14/1983\n   * @type {Object}\n   */\n  static get DATE_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE_WITH_SECONDS;\n  }\n}\n\n/**\n * @private\n */\nfunction friendlyDateTime(dateTimeish) {\n  if (DateTime.isDateTime(dateTimeish)) {\n    return dateTimeish;\n  } else if (dateTimeish && dateTimeish.valueOf && (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(dateTimeish.valueOf())) {\n    return DateTime.fromJSDate(dateTimeish);\n  } else if (dateTimeish && typeof dateTimeish === \"object\") {\n    return DateTime.fromObject(dateTimeish);\n  } else {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`\n    );\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0E7QUFDQTtBQUNSO0FBQ2U7QUFDYTtBQUNuQjtBQWVkO0FBQzJCO0FBQ2pCO0FBQzhEO0FBT2pFO0FBWUE7QUFDYztBQU14QjtBQUNtQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBLGFBQWEseURBQU8sa0NBQWtDLFVBQVU7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0VBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzRUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwyREFBWTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwREFBVztBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixvREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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QTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSwrQ0FBK0MsdURBQVE7QUFDM0Q7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osY0FBYyw2REFBb0I7QUFDbEMsb0NBQW9DLFlBQVksWUFBWSxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kYXRldGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNVbmRlZmluZWQsXG4gIG1heWJlQXJyYXksXG4gIGlzRGF0ZSxcbiAgaXNOdW1iZXIsXG4gIGJlc3RCeSxcbiAgZGF5c0luTW9udGgsXG4gIGRheXNJblllYXIsXG4gIGlzTGVhcFllYXIsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxuICBvYmpUb0xvY2FsVFMsXG4gIHBhZFN0YXJ0LFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgZGlmZiBmcm9tIFwiLi9pbXBsL2RpZmYuanNcIjtcbmltcG9ydCB7IHBhcnNlUkZDMjgyMkRhdGUsIHBhcnNlSVNPRGF0ZSwgcGFyc2VIVFRQRGF0ZSwgcGFyc2VTUUwgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBwYXJzZUZyb21Ub2tlbnMsXG4gIGV4cGxhaW5Gcm9tVG9rZW5zLFxuICBmb3JtYXRPcHRzVG9Ub2tlbnMsXG4gIGV4cGFuZE1hY3JvVG9rZW5zLFxuICBUb2tlblBhcnNlcixcbn0gZnJvbSBcIi4vaW1wbC90b2tlblBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgZ3JlZ29yaWFuVG9XZWVrLFxuICB3ZWVrVG9HcmVnb3JpYW4sXG4gIGdyZWdvcmlhblRvT3JkaW5hbCxcbiAgb3JkaW5hbFRvR3JlZ29yaWFuLFxuICBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YSxcbiAgaGFzSW52YWxpZFdlZWtEYXRhLFxuICBoYXNJbnZhbGlkT3JkaW5hbERhdGEsXG4gIGhhc0ludmFsaWRUaW1lRGF0YSxcbiAgdXNlc0xvY2FsV2Vla1ZhbHVlcyxcbiAgaXNvV2Vla2RheVRvTG9jYWwsXG59IGZyb20gXCIuL2ltcGwvY29udmVyc2lvbnMuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5pbXBvcnQge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IsXG4gIEludmFsaWRVbml0RXJyb3IsXG4gIEludmFsaWREYXRlVGltZUVycm9yLFxufSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIERhdGVUaW1lXCI7XG5jb25zdCBNQVhfREFURSA9IDguNjRlMTU7XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkWm9uZSh6b25lKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcInVuc3VwcG9ydGVkIHpvbmVcIiwgYHRoZSB6b25lIFwiJHt6b25lLm5hbWV9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xufVxuXG4vLyB3ZSBjYWNoZSB3ZWVrIGRhdGEgb24gdGhlIERUIG9iamVjdCBhbmQgdGhpcyBpbnRlcm1lZGlhdGVzIHRoZSBjYWNoZVxuLyoqXG4gKiBAcGFyYW0ge0RhdGVUaW1lfSBkdFxuICovXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG4gIHJldHVybiBkdC53ZWVrRGF0YTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RhdGVUaW1lfSBkdFxuICovXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEoZHQpIHtcbiAgaWYgKGR0LmxvY2FsV2Vla0RhdGEgPT09IG51bGwpIHtcbiAgICBkdC5sb2NhbFdlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKFxuICAgICAgZHQuYyxcbiAgICAgIGR0LmxvYy5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSxcbiAgICAgIGR0LmxvYy5nZXRTdGFydE9mV2VlaygpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZHQubG9jYWxXZWVrRGF0YTtcbn1cblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zLCBcIm1ha2UgYSBuZXcgb2JqZWN0IHdpdGggdGhlc2UgbW9kaWZpY2F0aW9uc1wiLiBhbGwgXCJzZXR0ZXJzXCIgcmVhbGx5IHVzZSB0aGlzXG4vLyB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHdoaWxlIG9ubHkgY2hhbmdpbmcgc29tZSBvZiB0aGUgcHJvcGVydGllc1xuZnVuY3Rpb24gY2xvbmUoaW5zdCwgYWx0cykge1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkLFxuICB9O1xuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgLi4uY3VycmVudCwgLi4uYWx0cywgb2xkOiBjdXJyZW50IH0pO1xufVxuXG4vLyBmaW5kIHRoZSByaWdodCBvZmZzZXQgYSBnaXZlbiBsb2NhbCB0aW1lLiBUaGUgbyBpbnB1dCBpcyBvdXIgZ3Vlc3MsIHdoaWNoIGRldGVybWluZXMgd2hpY2hcbi8vIG9mZnNldCB3ZSdsbCBwaWNrIGluIGFtYmlndW91cyBjYXNlcyAoZS5nLiB0aGVyZSBhcmUgdHdvIDMgQU1zIGIvYyBGYWxsYmFjayBEU1QpXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIGxldCB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwO1xuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGUgem9uZSBtYXRjaGVzIHRoZSBvZmZzZXQgZm9yIHRoaXMgdHNcbiAgY29uc3QgbzIgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIC8vIElmIHNvLCBvZmZzZXQgZGlkbid0IGNoYW5nZSBhbmQgd2UncmUgZG9uZVxuICBpZiAobyA9PT0gbzIpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvXTtcbiAgfVxuXG4gIC8vIElmIG5vdCwgY2hhbmdlIHRoZSB0cyBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgb2Zmc2V0XG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwO1xuXG4gIC8vIElmIHRoYXQgZ2l2ZXMgdXMgdGhlIGxvY2FsIHRpbWUgd2Ugd2FudCwgd2UncmUgZG9uZVxuICBjb25zdCBvMyA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH1cblxuICAvLyBJZiBpdCdzIGRpZmZlcmVudCwgd2UncmUgaW4gYSBob2xlIHRpbWUuIFRoZSBvZmZzZXQgaGFzIGNoYW5nZWQsIGJ1dCB0aGUgd2UgZG9uJ3QgYWRqdXN0IHRoZSB0aW1lXG4gIHJldHVybiBbbG9jYWxUUyAtIE1hdGgubWluKG8yLCBvMykgKiA2MCAqIDEwMDAsIE1hdGgubWF4KG8yLCBvMyldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGVwb2NoIHRpbWVzdGFtcCBpbnRvIGEgY2FsZW5kYXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG9mZnNldFxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcblxuICBjb25zdCBkID0gbmV3IERhdGUodHMpO1xuXG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgfTtcbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGVwb2NoIHRpbWVzdGFtcFxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuZnVuY3Rpb24gYWRqdXN0VGltZShpbnN0LCBkdXIpIHtcbiAgY29uc3Qgb1ByZSA9IGluc3QubyxcbiAgICB5ZWFyID0gaW5zdC5jLnllYXIgKyBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICBjID0ge1xuICAgICAgLi4uaW5zdC5jLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5OlxuICAgICAgICBNYXRoLm1pbihpbnN0LmMuZGF5LCBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIuZGF5cykgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci53ZWVrcykgKiA3LFxuICAgIH0sXG4gICAgbWlsbGlzVG9BZGQgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtcbiAgICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgICBxdWFydGVyczogZHVyLnF1YXJ0ZXJzIC0gTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpLFxuICAgICAgbW9udGhzOiBkdXIubW9udGhzIC0gTWF0aC50cnVuYyhkdXIubW9udGhzKSxcbiAgICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgICBkYXlzOiBkdXIuZGF5cyAtIE1hdGgudHJ1bmMoZHVyLmRheXMpLFxuICAgICAgaG91cnM6IGR1ci5ob3VycyxcbiAgICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgICAgc2Vjb25kczogZHVyLnNlY29uZHMsXG4gICAgICBtaWxsaXNlY29uZHM6IGR1ci5taWxsaXNlY29uZHMsXG4gICAgfSkuYXMoXCJtaWxsaXNlY29uZHNcIiksXG4gICAgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyhjKTtcblxuICBsZXQgW3RzLCBvXSA9IGZpeE9mZnNldChsb2NhbFRTLCBvUHJlLCBpbnN0LnpvbmUpO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkO1xuICAgIC8vIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBvZmZzZXQgYnkgZ29pbmcgb3ZlciBhIERTVCwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgdHMgdGhlIHNhbWVcbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4geyB0cywgbyB9O1xufVxuXG4vLyBoZWxwZXIgdXNlZnVsIGluIHR1cm5pbmcgdGhlIHJlc3VsdHMgb2YgcGFyc2luZyBpbnRvIHJlYWwgZGF0ZXNcbi8vIGJ5IGhhbmRsaW5nIHRoZSB6b25lIG9wdGlvbnNcbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQsIHNwZWNpZmljT2Zmc2V0KSB7XG4gIGNvbnN0IHsgc2V0Wm9uZSwgem9uZSB9ID0gb3B0cztcbiAgaWYgKChwYXJzZWQgJiYgT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggIT09IDApIHx8IHBhcnNlZFpvbmUpIHtcbiAgICBjb25zdCBpbnRlcnByZXRhdGlvblpvbmUgPSBwYXJzZWRab25lIHx8IHpvbmUsXG4gICAgICBpbnN0ID0gRGF0ZVRpbWUuZnJvbU9iamVjdChwYXJzZWQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgICBzcGVjaWZpY09mZnNldCxcbiAgICAgIH0pO1xuICAgIHJldHVybiBzZXRab25lID8gaW5zdCA6IGluc3Quc2V0Wm9uZSh6b25lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgIG5ldyBJbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyAke2Zvcm1hdH1gKVxuICAgICk7XG4gIH1cbn1cblxuLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcbmZ1bmN0aW9uIHRvVGVjaEZvcm1hdChkdCwgZm9ybWF0LCBhbGxvd1ogPSB0cnVlKSB7XG4gIHJldHVybiBkdC5pc1ZhbGlkXG4gICAgPyBGb3JtYXR0ZXIuY3JlYXRlKExvY2FsZS5jcmVhdGUoXCJlbi1VU1wiKSwge1xuICAgICAgICBhbGxvd1osXG4gICAgICAgIGZvcmNlU2ltcGxlOiB0cnVlLFxuICAgICAgfSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmb3JtYXQpXG4gICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0lTT0RhdGUobywgZXh0ZW5kZWQsIHByZWNpc2lvbikge1xuICBjb25zdCBsb25nRm9ybWF0ID0gby5jLnllYXIgPiA5OTk5IHx8IG8uYy55ZWFyIDwgMDtcbiAgbGV0IGMgPSBcIlwiO1xuICBpZiAobG9uZ0Zvcm1hdCAmJiBvLmMueWVhciA+PSAwKSBjICs9IFwiK1wiO1xuICBjICs9IHBhZFN0YXJ0KG8uYy55ZWFyLCBsb25nRm9ybWF0ID8gNiA6IDQpO1xuICBpZiAocHJlY2lzaW9uID09PSBcInllYXJcIikgcmV0dXJuIGM7XG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGlmIChwcmVjaXNpb24gPT09IFwibW9udGhcIikgcmV0dXJuIGM7XG4gICAgYyArPSBcIi1cIjtcbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgaWYgKHByZWNpc2lvbiA9PT0gXCJtb250aFwiKSByZXR1cm4gYztcbiAgfVxuICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gdG9JU09UaW1lKFxuICBvLFxuICBleHRlbmRlZCxcbiAgc3VwcHJlc3NTZWNvbmRzLFxuICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgaW5jbHVkZU9mZnNldCxcbiAgZXh0ZW5kZWRab25lLFxuICBwcmVjaXNpb25cbikge1xuICBsZXQgc2hvd1NlY29uZHMgPSAhc3VwcHJlc3NTZWNvbmRzIHx8IG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCBvLmMuc2Vjb25kICE9PSAwLFxuICAgIGMgPSBcIlwiO1xuICBzd2l0Y2ggKHByZWNpc2lvbikge1xuICAgIGNhc2UgXCJkYXlcIjpcbiAgICBjYXNlIFwibW9udGhcIjpcbiAgICBjYXNlIFwieWVhclwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGMgKz0gcGFkU3RhcnQoby5jLmhvdXIpO1xuICAgICAgaWYgKHByZWNpc2lvbiA9PT0gXCJob3VyXCIpIGJyZWFrO1xuICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgIGMgKz0gXCI6XCI7XG4gICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IFwibWludXRlXCIpIGJyZWFrO1xuICAgICAgICBpZiAoc2hvd1NlY29uZHMpIHtcbiAgICAgICAgICBjICs9IFwiOlwiO1xuICAgICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLnNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IFwibWludXRlXCIpIGJyZWFrO1xuICAgICAgICBpZiAoc2hvd1NlY29uZHMpIHtcbiAgICAgICAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJlY2lzaW9uID09PSBcInNlY29uZFwiKSBicmVhaztcbiAgICAgIGlmIChzaG93U2Vjb25kcyAmJiAoIXN1cHByZXNzTWlsbGlzZWNvbmRzIHx8IG8uYy5taWxsaXNlY29uZCAhPT0gMCkpIHtcbiAgICAgICAgYyArPSBcIi5cIjtcbiAgICAgICAgYyArPSBwYWRTdGFydChvLmMubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwICYmICFleHRlbmRlZFpvbmUpIHtcbiAgICAgIGMgKz0gXCJaXCI7XG4gICAgfSBlbHNlIGlmIChvLm8gPCAwKSB7XG4gICAgICBjICs9IFwiLVwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vICUgNjApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyArPSBcIitcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gJSA2MCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHRlbmRlZFpvbmUpIHtcbiAgICBjICs9IFwiW1wiICsgby56b25lLmlhbmFOYW1lICsgXCJdXCI7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRXaXRoTG9jYWxXZWVrcyh1bml0KSB7XG4gIHN3aXRjaCAodW5pdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImxvY2Fsd2Vla2RheVwiOlxuICAgIGNhc2UgXCJsb2NhbHdlZWtkYXlzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtkYXlcIjtcbiAgICBjYXNlIFwibG9jYWx3ZWVrbnVtYmVyXCI6XG4gICAgY2FzZSBcImxvY2Fsd2Vla251bWJlcnNcIjpcbiAgICAgIHJldHVybiBcImxvY2FsV2Vla051bWJlclwiO1xuICAgIGNhc2UgXCJsb2NhbHdlZWt5ZWFyXCI6XG4gICAgY2FzZSBcImxvY2Fsd2Vla3llYXJzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtZZWFyXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub3JtYWxpemVVbml0KHVuaXQpO1xuICB9XG59XG5cbi8vIGNhY2hlIG9mZnNldHMgZm9yIHpvbmVzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRpbWVzdGFtcCB3aGVuIHRoaXMgZnVuY3Rpb24gaXNcbi8vIGZpcnN0IGNhbGxlZC4gV2hlbiB3ZSBhcmUgaGFuZGxpbmcgYSBkYXRldGltZSBmcm9tIGNvbXBvbmVudHMgbGlrZSAoeWVhcixcbi8vIG1vbnRoLCBkYXksIGhvdXIpIGluIGEgdGltZSB6b25lLCB3ZSBuZWVkIGEgZ3Vlc3MgYWJvdXQgd2hhdCB0aGUgdGltZXpvbmVcbi8vIG9mZnNldCBpcyBzbyB0aGF0IHdlIGNhbiBjb252ZXJ0IGludG8gYSBVVEMgdGltZXN0YW1wLiBPbmUgd2F5IGlzIHRvIGZpbmQgdGhlXG4vLyBvZmZzZXQgb2Ygbm93IGluIHRoZSB6b25lLiBUaGUgYWN0dWFsIGRhdGUgbWF5IGhhdmUgYSBkaWZmZXJlbnQgb2Zmc2V0IChmb3Jcbi8vIGV4YW1wbGUsIGlmIHdlIGhhbmRsZSBhIGRhdGUgaW4gSnVuZSB3aGlsZSB3ZSdyZSBpbiBEZWNlbWJlciBpbiBhIHpvbmUgdGhhdFxuLy8gb2JzZXJ2ZXMgRFNUKSwgYnV0IHdlIGNhbiBjaGVjayBhbmQgYWRqdXN0IHRoYXQuXG4vL1xuLy8gV2hlbiBoYW5kbGluZyBtYW55IGRhdGVzLCBjYWxjdWxhdGluZyB0aGUgb2Zmc2V0IGZvciBub3cgZXZlcnkgdGltZSBpc1xuLy8gZXhwZW5zaXZlLiBJdCdzIGp1c3QgYSBndWVzcywgc28gd2UgY2FuIGNhY2hlIHRoZSBvZmZzZXQgdG8gdXNlIGV2ZW4gaWYgd2Vcbi8vIGFyZSByaWdodCBvbiBhIHRpbWUgY2hhbmdlIGJvdW5kYXJ5ICh3ZSdsbCBqdXN0IGNvcnJlY3QgaW4gdGhlIG90aGVyXG4vLyBkaXJlY3Rpb24pLiBVc2luZyBhIHRpbWVzdGFtcCBmcm9tIGZpcnN0IHJlYWQgaXMgYSBzbGlnaHQgb3B0aW1pemF0aW9uIGZvclxuLy8gaGFuZGxpbmcgZGF0ZXMgY2xvc2UgdG8gdGhlIGN1cnJlbnQgZGF0ZSwgc2luY2UgdGhvc2UgZGF0ZXMgd2lsbCB1c3VhbGx5IGJlXG4vLyBpbiB0aGUgc2FtZSBvZmZzZXQgKHdlIGNvdWxkIHNldCB0aGUgdGltZXN0YW1wIHN0YXRpY2FsbHksIGluc3RlYWQpLiBXZSB1c2UgYVxuLy8gc2luZ2xlIHRpbWVzdGFtcCBmb3IgYWxsIHpvbmVzIHRvIG1ha2UgdGhpbmdzIGEgYml0IG1vcmUgcHJlZGljdGFibGUuXG4vL1xuLy8gVGhpcyBpcyBzYWZlIGZvciBxdWlja0RUICh1c2VkIGJ5IGxvY2FsKCkgYW5kIHV0YygpKSBiZWNhdXNlIHdlIGRvbid0IGZpbGwgaW5cbi8vIGhpZ2hlci1vcmRlciB1bml0cyBmcm9tIHRzTm93IChhcyB3ZSBkbyBpbiBmcm9tT2JqZWN0LCB0aGlzIHJlcXVpcmVzIHRoYXRcbi8vIG9mZnNldCBpcyBjYWxjdWxhdGVkIGZyb20gdHNOb3cpLlxuLyoqXG4gKiBAcGFyYW0ge1pvbmV9IHpvbmVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ3Vlc3NPZmZzZXRGb3Jab25lKHpvbmUpIHtcbiAgaWYgKHpvbmVPZmZzZXRUcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgem9uZU9mZnNldFRzID0gU2V0dGluZ3Mubm93KCk7XG4gIH1cblxuICAvLyBEbyBub3QgY2FjaGUgYW55dGhpbmcgYnV0IElBTkEgem9uZXMsIGJlY2F1c2UgaXQgaXMgbm90IHNhZmUgdG8gZG8gc28uXG4gIC8vIEd1ZXNzaW5nIGFuIG9mZnNldCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiB0aGUgem9uZSBjYW4gY2F1c2Ugd3JvbmcgcmVzdWx0cyBmcm9tIGZpeE9mZnNldFxuICBpZiAoem9uZS50eXBlICE9PSBcImlhbmFcIikge1xuICAgIHJldHVybiB6b25lLm9mZnNldCh6b25lT2Zmc2V0VHMpO1xuICB9XG4gIGNvbnN0IHpvbmVOYW1lID0gem9uZS5uYW1lO1xuICBsZXQgb2Zmc2V0R3Vlc3MgPSB6b25lT2Zmc2V0R3Vlc3NDYWNoZS5nZXQoem9uZU5hbWUpO1xuICBpZiAob2Zmc2V0R3Vlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQoem9uZU9mZnNldFRzKTtcbiAgICB6b25lT2Zmc2V0R3Vlc3NDYWNoZS5zZXQoem9uZU5hbWUsIG9mZnNldEd1ZXNzKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0R3Vlc3M7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCBvcHRzKSB7XG4gIGNvbnN0IHpvbmUgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICBpZiAoIXpvbmUuaXNWYWxpZCkge1xuICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gIH1cblxuICBjb25zdCBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKTtcblxuICBsZXQgdHMsIG87XG5cbiAgLy8gYXNzdW1lIHdlIGhhdmUgdGhlIGhpZ2hlci1vcmRlciB1bml0c1xuICBpZiAoIWlzVW5kZWZpbmVkKG9iai55ZWFyKSkge1xuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICAgIG9ialt1XSA9IGRlZmF1bHRVbml0VmFsdWVzW3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHx8IGhhc0ludmFsaWRUaW1lRGF0YShvYmopO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXRQcm92aXMgPSBndWVzc09mZnNldEZvclpvbmUoem9uZSk7XG4gICAgW3RzLCBvXSA9IG9ialRvVFMob2JqLCBvZmZzZXRQcm92aXMsIHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRzID0gU2V0dGluZ3Mubm93KCk7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgdHMsIHpvbmUsIGxvYywgbyB9KTtcbn1cblxuZnVuY3Rpb24gZGlmZlJlbGF0aXZlKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgY29uc3Qgcm91bmQgPSBpc1VuZGVmaW5lZChvcHRzLnJvdW5kKSA/IHRydWUgOiBvcHRzLnJvdW5kLFxuICAgIHJvdW5kaW5nID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZGluZykgPyBcInRydW5jXCIgOiBvcHRzLnJvdW5kaW5nLFxuICAgIGZvcm1hdCA9IChjLCB1bml0KSA9PiB7XG4gICAgICBjID0gcm91bmRUbyhjLCByb3VuZCB8fCBvcHRzLmNhbGVuZGFyeSA/IDAgOiAyLCBvcHRzLmNhbGVuZGFyeSA/IFwicm91bmRcIiA6IHJvdW5kaW5nKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGVuZC5sb2MuY2xvbmUob3B0cykucmVsRm9ybWF0dGVyKG9wdHMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoYywgdW5pdCk7XG4gICAgfSxcbiAgICBkaWZmZXIgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKG9wdHMuY2FsZW5kYXJ5KSB7XG4gICAgICAgIGlmICghZW5kLmhhc1NhbWUoc3RhcnQsIHVuaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZC5zdGFydE9mKHVuaXQpLmRpZmYoc3RhcnQuc3RhcnRPZih1bml0KSwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGlmIChvcHRzLnVuaXQpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRpZmZlcihvcHRzLnVuaXQpLCBvcHRzLnVuaXQpO1xuICB9XG5cbiAgZm9yIChjb25zdCB1bml0IG9mIG9wdHMudW5pdHMpIHtcbiAgICBjb25zdCBjb3VudCA9IGRpZmZlcih1bml0KTtcbiAgICBpZiAoTWF0aC5hYnMoY291bnQpID49IDEpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHN0YXJ0ID4gZW5kID8gLTAgOiAwLCBvcHRzLnVuaXRzW29wdHMudW5pdHMubGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBsYXN0T3B0cyhhcmdMaXN0KSB7XG4gIGxldCBvcHRzID0ge30sXG4gICAgYXJncztcbiAgaWYgKGFyZ0xpc3QubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0cyA9IGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXTtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KS5zbGljZSgwLCBhcmdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpO1xuICB9XG4gIHJldHVybiBbb3B0cywgYXJnc107XG59XG5cbi8qKlxuICogVGltZXN0YW1wIHRvIHVzZSBmb3IgY2FjaGVkIHpvbmUgb2Zmc2V0IGd1ZXNzZXMgKGV4cG9zZWQgZm9yIHRlc3QpXG4gKi9cbmxldCB6b25lT2Zmc2V0VHM7XG4vKipcbiAqIENhY2hlIGZvciB6b25lIG9mZnNldCBndWVzc2VzIChleHBvc2VkIGZvciB0ZXN0KS5cbiAqXG4gKiBUaGlzIG9wdGltaXplcyBxdWlja0RUIHZpYSBndWVzc09mZnNldEZvclpvbmUgdG8gYXZvaWQgcmVwZWF0ZWQgY2FsbHMgb2ZcbiAqIHpvbmUub2Zmc2V0KCkuXG4gKi9cbmNvbnN0IHpvbmVPZmZzZXRHdWVzc0NhY2hlID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEEgRGF0ZVRpbWUgaXMgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGRhdGUgYW5kIHRpbWUgYW5kIGFjY29tcGFueWluZyBtZXRob2RzLiBJdCBjb250YWlucyBjbGFzcyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBBIERhdGVUaW1lIGNvbXByaXNlcyBvZjpcbiAqICogQSB0aW1lc3RhbXAuIEVhY2ggRGF0ZVRpbWUgaW5zdGFuY2UgcmVmZXJzIHRvIGEgc3BlY2lmaWMgbWlsbGlzZWNvbmQgb2YgdGhlIFVuaXggZXBvY2guXG4gKiAqIEEgdGltZSB6b25lLiBFYWNoIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpYyB6b25lIChieSBkZWZhdWx0IHRoZSBsb2NhbCBzeXN0ZW0ncyB6b25lKS5cbiAqICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgZWZmZWN0IGhvdyBvdXRwdXQgc3RyaW5ncyBhcmUgZm9ybWF0dGVkLCBzdWNoIGFzIGBsb2NhbGVgLCBgbnVtYmVyaW5nU3lzdGVtYCwgYW5kIGBvdXRwdXRDYWxlbmRhcmAuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgZnVuY3Rpb25hbGl0eSBpdCBwcm92aWRlczpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKjogVG8gY3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBpdHMgY29tcG9uZW50cywgdXNlIG9uZSBvZiBpdHMgZmFjdG9yeSBjbGFzcyBtZXRob2RzOiB7QGxpbmsgRGF0ZVRpbWUubG9jYWx9LCB7QGxpbmsgRGF0ZVRpbWUudXRjfSwgYW5kIChtb3N0IGZsZXhpYmx5KSB7QGxpbmsgRGF0ZVRpbWUuZnJvbU9iamVjdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIHN0YW5kYXJkIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUlTT30sIHtAbGluayBEYXRlVGltZS5mcm9tSFRUUH0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUuZnJvbVJGQzI4MjJ9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBjdXN0b20gc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgbmF0aXZlIEpTIGRhdGUsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUpTRGF0ZX0uXG4gKiAqICoqR3JlZ29yaWFuIGNhbGVuZGFyIGFuZCB0aW1lKio6IFRvIGV4YW1pbmUgdGhlIEdyZWdvcmlhbiBwcm9wZXJ0aWVzIG9mIGEgRGF0ZVRpbWUgaW5kaXZpZHVhbGx5IChpLmUgYXMgb3Bwb3NlZCB0byBjb2xsZWN0aXZlbHkgdGhyb3VnaCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9KSwgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjeWVhcn0sIHtAbGluayBEYXRlVGltZSNtb250aH0sXG4gKiB7QGxpbmsgRGF0ZVRpbWUjZGF5fSwge0BsaW5rIERhdGVUaW1lI2hvdXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXRlfSwge0BsaW5rIERhdGVUaW1lI3NlY29uZH0sIHtAbGluayBEYXRlVGltZSNtaWxsaXNlY29uZH0gYWNjZXNzb3JzLlxuICogKiAqKldlZWsgY2FsZW5kYXIqKjogRm9yIElTTyB3ZWVrIGNhbGVuZGFyIGF0dHJpYnV0ZXMsIHNlZSB0aGUge0BsaW5rIERhdGVUaW1lI3dlZWtZZWFyfSwge0BsaW5rIERhdGVUaW1lI3dlZWtOdW1iZXJ9LCBhbmQge0BsaW5rIERhdGVUaW1lI3dlZWtkYXl9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjbG9jYWxlfSBhbmQge0BsaW5rIERhdGVUaW1lI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKio6IFRvIHRyYW5zZm9ybSB0aGUgRGF0ZVRpbWUgaW50byBvdGhlciBEYXRlVGltZXMsIHVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0fSwge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSwge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0TG9jYWxlfSwge0BsaW5rIERhdGVUaW1lLnBsdXN9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXN9LCB7QGxpbmsgRGF0ZVRpbWUjZW5kT2Z9LCB7QGxpbmsgRGF0ZVRpbWUjc3RhcnRPZn0sIHtAbGluayBEYXRlVGltZSN0b1VUQ30sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0uXG4gKiAqICoqT3V0cHV0Kio6IFRvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZX0sIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlQ2FsZW5kYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9KU09OfSwge0BsaW5rIERhdGVUaW1lI3RvSVNPfSwge0BsaW5rIERhdGVUaW1lI3RvSFRUUH0sIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0sIHtAbGluayBEYXRlVGltZSN0b1JGQzI4MjJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9TdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9LCB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9KU0RhdGV9LlxuICpcbiAqIFRoZXJlJ3MgcGxlbnR5IG90aGVycyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiwgdGltZSB6b25lcywgYWx0ZXJuYXRpdmUgY2FsZW5kYXJzLCB2YWxpZGl0eSwgYW5kIHNvIG9uLCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVUaW1lIHtcbiAgLyoqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3Qgem9uZSA9IGNvbmZpZy56b25lIHx8IFNldHRpbmdzLmRlZmF1bHRab25lO1xuXG4gICAgbGV0IGludmFsaWQgPVxuICAgICAgY29uZmlnLmludmFsaWQgfHxcbiAgICAgIChOdW1iZXIuaXNOYU4oY29uZmlnLnRzKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGwpIHx8XG4gICAgICAoIXpvbmUuaXNWYWxpZCA/IHVuc3VwcG9ydGVkWm9uZSh6b25lKSA6IG51bGwpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHMgPSBpc1VuZGVmaW5lZChjb25maWcudHMpID8gU2V0dGluZ3Mubm93KCkgOiBjb25maWcudHM7XG5cbiAgICBsZXQgYyA9IG51bGwsXG4gICAgICBvID0gbnVsbDtcbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGNvbmZpZy5vbGQgJiYgY29uZmlnLm9sZC50cyA9PT0gdGhpcy50cyAmJiBjb25maWcub2xkLnpvbmUuZXF1YWxzKHpvbmUpO1xuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIFtjLCBvXSA9IFtjb25maWcub2xkLmMsIGNvbmZpZy5vbGQub107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBhbiBvZmZzZXQgaGFzIGJlZW4gcGFzc2VkIGFuZCB3ZSBoYXZlIG5vdCBiZWVuIGNhbGxlZCBmcm9tXG4gICAgICAgIC8vIGNsb25lKCksIHdlIGNhbiB0cnVzdCBpdCBhbmQgYXZvaWQgdGhlIG9mZnNldCBjYWxjdWxhdGlvbi5cbiAgICAgICAgY29uc3Qgb3QgPSBpc051bWJlcihjb25maWcubykgJiYgIWNvbmZpZy5vbGQgPyBjb25maWcubyA6IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjID0gdHNUb09iaih0aGlzLnRzLCBvdCk7XG4gICAgICAgIGludmFsaWQgPSBOdW1iZXIuaXNOYU4oYy55ZWFyKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGw7XG4gICAgICAgIGMgPSBpbnZhbGlkID8gbnVsbCA6IGM7XG4gICAgICAgIG8gPSBpbnZhbGlkID8gbnVsbCA6IG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3pvbmUgPSB6b25lO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsV2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCh7IHpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pICAgICAgLy9+PiBub3csIGluIFVTIGVhc3QgY29hc3QgdGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwLCB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgeyB6b25lOiBcInV0Y1wiIH0pICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwLCBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGxvY2FsKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud2Vla1NldHRpbmdzXSAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCB7IGxvY2FsZTogXCJmclwiIH0pICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1LCB7IGxvY2FsZTogXCJmclwiIH0pIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIHV0YygpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuXG4gICAgb3B0cy56b25lID0gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0LiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAtIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNEYXRlKGRhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRzID0gaXNEYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiBOYU47XG4gICAgaWYgKE51bWJlci5pc05hTih0cykpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgIHRzOiB0cyxcbiAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihtaWxsaXNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBmcm9tTWlsbGlzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0LCBidXQgcmVjZWl2ZWQgYSAke3R5cGVvZiBtaWxsaXNlY29uZHN9IHdpdGggdmFsdWUgJHttaWxsaXNlY29uZHN9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kcyA8IC1NQVhfREFURSB8fCBtaWxsaXNlY29uZHMgPiBNQVhfREFURSkge1xuICAgICAgLy8gdGhpcyBpc24ndCBwZXJmZWN0IGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyAtIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbVNlY29uZHMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogc2Vjb25kcyAqIDEwMDAsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFyJyBhbmQgJ2hvdXInIHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhciAtIGEgeWVhciwgc3VjaCBhcyAxOTg3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGggLSBhIG1vbnRoLCAxLTEyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5IC0gYSBkYXkgb2YgdGhlIG1vbnRoLCAxLTMxLCBkZXBlbmRpbmcgb24gdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoub3JkaW5hbCAtIGRheSBvZiB0aGUgeWVhciwgMS0zNjUgb3IgMzY2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla1llYXIgLSBhbiBJU08gd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla051bWJlciAtIGFuIElTTyB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla2RheSAtIGFuIElTTyB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmxvY2FsV2Vla1llYXIgLSBhIHdlZWsgeWVhciwgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5sb2NhbFdlZWtOdW1iZXIgLSBhIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXIsIGFjY29yZGluZyB0byB0aGUgbG9jYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubG9jYWxXZWVrZGF5IC0gYSB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgdGhlIGZpcnN0IGFuZCA3IGlzIHRoZSBsYXN0IGRheSBvZiB0aGUgd2VlaywgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3VyIC0gaG91ciBvZiB0aGUgZGF5LCAwLTIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlIC0gbWludXRlIG9mIHRoZSBob3VyLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kIC0gc2Vjb25kIG9mIHRoZSBtaW51dGUsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIDAtOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gaW50ZXJwcmV0IHRoZSBudW1iZXJzIGluIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciB6b25lLiBDYW4gdGFrZSBhbnkgdmFsdWUgdGFrZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHNldFpvbmUoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW1cXCdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAndXRjJyB9KSxcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgbG9jYWxXZWVrWWVhcjogMjAyMiwgbG9jYWxXZWVrTnVtYmVyOiAxLCBsb2NhbFdlZWtkYXk6IDEgfSwgeyBsb2NhbGU6IFwiZW4tVVNcIiB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDIxLTEyLTI2J1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgb2JqID0gb2JqIHx8IHt9O1xuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3MpO1xuICAgIGNvbnN0IHsgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayB9ID0gdXNlc0xvY2FsV2Vla1ZhbHVlcyhub3JtYWxpemVkLCBsb2MpO1xuXG4gICAgY29uc3QgdHNOb3cgPSBTZXR0aW5ncy5ub3coKSxcbiAgICAgIG9mZnNldFByb3ZpcyA9ICFpc1VuZGVmaW5lZChvcHRzLnNwZWNpZmljT2Zmc2V0KVxuICAgICAgICA/IG9wdHMuc3BlY2lmaWNPZmZzZXRcbiAgICAgICAgOiB6b25lVG9Vc2Uub2Zmc2V0KHRzTm93KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXI7XG5cbiAgICAvLyBjYXNlczpcbiAgICAvLyBqdXN0IGEgd2Vla2RheSAtPiB0aGlzIHdlZWsncyBpbnN0YW5jZSBvZiB0aGF0IHdlZWtkYXksIG5vIHdvcnJpZXNcbiAgICAvLyAoZ3JlZ29yaWFuIGRhdGEgb3Igb3JkaW5hbCkgKyAod2Vla1llYXIgb3Igd2Vla051bWJlcikgLT4gZXJyb3JcbiAgICAvLyAoZ3JlZ29yaWFuIG1vbnRoIG9yIGRheSkgKyBvcmRpbmFsIC0+IGVycm9yXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXNlIHdlZWtzIG9yIG9yZGluYWxzIG9yIGdyZWdvcmlhbiwgZGVwZW5kaW5nIG9uIHdoYXQncyBzcGVjaWZpZWRcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VXZWVrRGF0YSA9IGRlZmluaXRlV2Vla0RlZiB8fCAobm9ybWFsaXplZC53ZWVrZGF5ICYmICFjb250YWluc0dyZWdvcik7XG5cbiAgICAvLyBjb25maWd1cmUgb3Vyc2VsdmVzIHRvIGRlYWwgd2l0aCBncmVnb3JpYW4gZGF0ZXMgb3Igd2VlayBzdHVmZlxuICAgIGxldCB1bml0cyxcbiAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICBvYmpOb3cgPSB0c1RvT2JqKHRzTm93LCBvZmZzZXRQcm92aXMpO1xuICAgIGlmICh1c2VXZWVrRGF0YSkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkV2Vla1VuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRXZWVrVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvV2VlayhvYmpOb3csIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRPcmRpbmFsVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9PcmRpbmFsKG9iak5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyBzdHVmZlxuICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB1IG9mIHVuaXRzKSB7XG4gICAgICBjb25zdCB2ID0gbm9ybWFsaXplZFt1XTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRmlyc3QpIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IGRlZmF1bHRWYWx1ZXNbdV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gb2JqTm93W3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdmFsdWVzIHdlIGhhdmUgYXJlIGluIHJhbmdlXG4gICAgY29uc3QgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZCwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgIGludmFsaWQgPSBoaWdoZXJPcmRlckludmFsaWQgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGFjdHVhbCB0aW1lXG4gICAgY29uc3QgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZCwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvYyxcbiAgICAgIH0pO1xuXG4gICAgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG4gICAgaWYgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiBjb250YWluc0dyZWdvciAmJiBvYmoud2Vla2RheSAhPT0gaW5zdC53ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgICAgXCJtaXNtYXRjaGVkIHdlZWtkYXlcIixcbiAgICAgICAgYHlvdSBjYW4ndCBzcGVjaWZ5IGJvdGggYSB3ZWVrZGF5IG9mICR7bm9ybWFsaXplZC53ZWVrZGF5fSBhbmQgYSBkYXRlIG9mICR7aW5zdC50b0lTTygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnN0LmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGluc3QuaW52YWxpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy53ZWVrU2V0dGluZ3NdIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJywge3NldFpvbmU6IHRydWV9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycsIHt6b25lOiAndXRjJ30pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtVzA1LTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSVNPRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIklTTyA4NjAxXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIHRoZSBvZmZzZXQgaXMgYWx3YXlzIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzOjEyIEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCdGcmksIDI1IE5vdiAyMDE2IDEzOjIzOjEyICswNjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzIFonKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tUkZDMjgyMih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVJGQzI4MjJEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiUkZDIDI4MjJcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSBIVFRQIGRhdGVzIGFyZSBhbHdheXMgaW4gVVRDLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCB0aGUgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcuIEZvciBIVFRQIGRhdGVzLCB0aGlzIGlzIGFsd2F5cyBVVEMsIHNvIHRoaXMgb3B0aW9uIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYHpvbmVgIG9wdGlvbiB0byAndXRjJywgYnV0IHRoaXMgb3B0aW9uIGlzIGluY2x1ZGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHNpbWlsYXIgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biwgMDYgTm92IDE5OTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1bmRheSwgMDYtTm92LTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4gTm92ICA2IDA4OjQ5OjM3IDE5OTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSFRUUCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUhUVFBEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSFRUUFwiLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIGlucHV0IHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZy5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9wYXJzaW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgdGhlIGxpbmsgYmVsb3cgZm9yIHRoZSBmb3JtYXRzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRleHQpIHx8IGlzVW5kZWZpbmVkKGZtdCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21Gb3JtYXQgcmVxdWlyZXMgYW4gaW5wdXQgc3RyaW5nIGFuZCBhIGZvcm1hdFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdHMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICAgW3ZhbHMsIHBhcnNlZFpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkXSA9IHBhcnNlRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIGBmb3JtYXQgJHtmbXR9YCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIFNRTCBkYXRlLCB0aW1lLCBvciBkYXRldGltZVxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJywgeyBzZXRab25lOiB0cnVlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJywgeyB6b25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMDk6MTI6MzQuMzQyJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNRTCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVNRTCh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlNRTFwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRGF0ZVRpbWUgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGVUaW1lRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZVRpbWUuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0RhdGVUaW1lKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRGF0ZVRpbWUpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIGZvcm1hdCBzdHJpbmcgZm9yIGEgc2V0IG9mIG9wdGlvbnNcbiAgICogQHBhcmFtIGZvcm1hdE9wdHNcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBwYXJzZUZvcm1hdEZvck9wdHMoZm9ybWF0T3B0cywgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdG9rZW5MaXN0ID0gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gIXRva2VuTGlzdCA/IG51bGwgOiB0b2tlbkxpc3QubWFwKCh0KSA9PiAodCA/IHQudmFsIDogbnVsbCkpLmpvaW4oXCJcIik7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgdGhlIGZ1bGx5IGV4cGFuZGVkIGZvcm1hdCB0b2tlbiBmb3IgdGhlIGxvY2FsZVxuICAgKiBEb2VzIE5PVCBxdW90ZSBjaGFyYWN0ZXJzLCBzbyBxdW90ZWQgdG9rZW5zIHdpbGwgbm90IHJvdW5kIHRyaXAgY29ycmVjdGx5XG4gICAqIEBwYXJhbSBmbXRcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBleHBhbmRGb3JtYXQoZm10LCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuIGV4cGFuZGVkLm1hcCgodCkgPT4gdC52YWwpLmpvaW4oXCJcIik7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICB6b25lT2Zmc2V0VHMgPSB1bmRlZmluZWQ7XG4gICAgem9uZU9mZnNldEd1ZXNzQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8vIElORk9cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnbW9udGgnKTsgLy89PiA3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnZGF5Jyk7IC8vPT4gNFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgdmFsaWQuIEludmFsaWQgRGF0ZVRpbWVzIG9jY3VyIHdoZW46XG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGZyb20gaW52YWxpZCBjYWxlbmRhciBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgMTN0aCBtb250aCBvciBGZWJydWFyeSAzMFxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBieSBhbiBvcGVyYXRpb24gb24gYW5vdGhlciBpbnZhbGlkIGRhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEYXRlVGltZSwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG91dHB1dCBjYWxlbmRhciBvZiBhIERhdGVUaW1lLCBzdWNoICdpc2xhbWljJy4gVGhlIG91dHB1dCBjYWxlbmRhciBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIGdldCB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHpvbmVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUubmFtZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS55ZWFyIC8vPT4gMjAxN1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy55ZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucXVhcnRlciAvLz0+IDJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCAoMS0xMikuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1vbnRoIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5kYXkgLy89PiAyNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmRheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXIgb2YgdGhlIGRheSAoMC0yMykuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5KS5ob3VyIC8vPT4gOVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlIG9mIHRoZSBob3VyICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbnV0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1Mikuc2Vjb25kIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5zZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kICgwLTk5OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIsIDY1NCkubWlsbGlzZWNvbmQgLy89PiA2NTRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMiwgMzEpLndlZWtZZWFyIC8vPT4gMjAxNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtZZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciAoMS01MmlzaCkuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrTnVtYmVyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZGF0ZSBpcyBvbiBhIHdlZWtlbmQgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1dlZWtlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCAmJiB0aGlzLmxvYy5nZXRXZWVrZW5kRGF5cygpLmluY2x1ZGVzKHRoaXMud2Vla2RheSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUuXG4gICAqIDEgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBhbmQgNyBpcyB0aGUgbGFzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIElmIHRoZSBsb2NhbGUgYXNzaWducyBTdW5kYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgdGhlbiBhIGRhdGUgd2hpY2ggaXMgYSBTdW5kYXkgd2lsbCByZXR1cm4gMSxcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbFdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZS4gRGlmZmVyZW50IGxvY2FsZXMgYXNzaWduIHdlZWsgbnVtYmVycyBkaWZmZXJlbnRseSxcbiAgICogYmVjYXVzZSB0aGUgd2VlayBjYW4gc3RhcnQgb24gZGlmZmVyZW50IGRheXMgb2YgdGhlIHdlZWsgKHNlZSBsb2NhbFdlZWtkYXkpIGFuZCBiZWNhdXNlIGEgZGlmZmVyZW50IG51bWJlciBvZiBkYXlzXG4gICAqIGlzIHJlcXVpcmVkIGZvciBhIHdlZWsgdG8gY291bnQgYXMgdGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvY2FsV2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXIgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUuIERpZmZlcmVudCBsb2NhbGVzIGFzc2lnbiB3ZWVrIG51bWJlcnMgKGFuZCB0aGVyZWZvciB3ZWVrIHllYXJzKVxuICAgKiBkaWZmZXJlbnRseSwgc2VlIGxvY2FsV2Vla051bWJlci5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbFdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5vcmRpbmFsIC8vPT4gMTQ1XG4gICAqIEB0eXBlIHtudW1iZXJ8RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgb3JkaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYykub3JkaW5hbCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdCcuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aFNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyBtb250aCBuYW1lLCBzdWNoIGFzICdPY3RvYmVyJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhMb25nIC8vPT4gT2N0b2JlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoTG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheVNob3J0IC8vPT4gTW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgd2Vla2RheSwgc3VjaCBhcyAnTW9uZGF5Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5TG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFVUQyBvZmZzZXQgb2YgdGhpcyBEYXRlVGltZSBpbiBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm9mZnNldCAvLz0+IC0yNDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkub2Zmc2V0IC8vPT4gMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gK3RoaXMubyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRVNUXCIgb3IgXCJFRFRcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZVNob3J0KCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvbmcgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcIiBvciBcIkVhc3Rlcm4gRGF5bGlnaHQgVGltZVwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lTG9uZygpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwibG9uZ1wiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGlzIHpvbmUncyBvZmZzZXQgZXZlciBjaGFuZ2VzLCBhcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNPZmZzZXRGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLmlzVW5pdmVyc2FsIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5EU1QoKSB7XG4gICAgaWYgKHRoaXMuaXNPZmZzZXRGaXhlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDEsIGRheTogMSB9KS5vZmZzZXQgfHxcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiA1IH0pLm9mZnNldFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRob3NlIERhdGVUaW1lcyB3aGljaCBoYXZlIHRoZSBzYW1lIGxvY2FsIHRpbWUgYXMgdGhpcyBEYXRlVGltZSwgYnV0IGEgZGlmZmVyZW50IG9mZnNldCBmcm9tIFVUQ1xuICAgKiBpbiB0aGlzIERhdGVUaW1lJ3Mgem9uZS4gRHVyaW5nIERTVCBjaGFuZ2VzIGxvY2FsIHRpbWUgY2FuIGJlIGFtYmlndW91cywgZm9yIGV4YW1wbGVcbiAgICogYDIwMjMtMTAtMjlUMDI6MzA6MDBgIGluIGBFdXJvcGUvQmVybGluYCBjYW4gaGF2ZSBvZmZzZXQgYCswMTowMGAgb3IgYCswMjowMGAuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGJvdGggcG9zc2libGUgRGF0ZVRpbWVzIGlmIHRoaXMgRGF0ZVRpbWUncyBsb2NhbCB0aW1lIGlzIGFtYmlndW91cy5cbiAgICogQHJldHVybnMge0RhdGVUaW1lW119XG4gICAqL1xuICBnZXRQb3NzaWJsZU9mZnNldHMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgdGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCBkYXlNcyA9IDg2NDAwMDAwO1xuICAgIGNvbnN0IG1pbnV0ZU1zID0gNjAwMDA7XG4gICAgY29uc3QgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyh0aGlzLmMpO1xuICAgIGNvbnN0IG9FYXJsaWVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gZGF5TXMpO1xuICAgIGNvbnN0IG9MYXRlciA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyArIGRheU1zKTtcblxuICAgIGNvbnN0IG8xID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gb0VhcmxpZXIgKiBtaW51dGVNcyk7XG4gICAgY29uc3QgbzIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvTGF0ZXIgKiBtaW51dGVNcyk7XG4gICAgaWYgKG8xID09PSBvMikge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgY29uc3QgdHMxID0gbG9jYWxUUyAtIG8xICogbWludXRlTXM7XG4gICAgY29uc3QgdHMyID0gbG9jYWxUUyAtIG8yICogbWludXRlTXM7XG4gICAgY29uc3QgYzEgPSB0c1RvT2JqKHRzMSwgbzEpO1xuICAgIGNvbnN0IGMyID0gdHNUb09iaih0czIsIG8yKTtcbiAgICBpZiAoXG4gICAgICBjMS5ob3VyID09PSBjMi5ob3VyICYmXG4gICAgICBjMS5taW51dGUgPT09IGMyLm1pbnV0ZSAmJlxuICAgICAgYzEuc2Vjb25kID09PSBjMi5zZWNvbmQgJiZcbiAgICAgIGMxLm1pbGxpc2Vjb25kID09PSBjMi5taWxsaXNlY29uZFxuICAgICkge1xuICAgICAgcmV0dXJuIFtjbG9uZSh0aGlzLCB7IHRzOiB0czEgfSksIGNsb25lKHRoaXMsIHsgdHM6IHRzMiB9KV07XG4gICAgfVxuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW4gYSBsZWFwIHllYXIsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5pc0luTGVhcFllYXIgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmlzSW5MZWFwWWVhciAvLz0+IGZhbHNlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5MZWFwWWVhcigpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyBtb250aFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAyKS5kYXlzSW5Nb250aCAvLz0+IDI5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDMpLmRheXNJbk1vbnRoIC8vPT4gMzFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5kYXlzSW5ZZWFyIC8vPT4gMzY2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmRheXNJblllYXIgLy89PiAzNjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBkYXlzSW5ZZWFyKHRoaXMueWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDA0KS53ZWVrc0luV2Vla1llYXIgLy89PiA1M1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS53ZWVrc0luV2Vla1llYXIgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gd2Vla3NJbldlZWtZZWFyKHRoaXMud2Vla1llYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGlzIERhdGVUaW1lJ3MgbG9jYWwgd2VlayB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMjAsIDYsIHtsb2NhbGU6ICdlbi1VUyd9KS53ZWVrc0luTG9jYWxXZWVrWWVhciAvLz0+IDUyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMjAsIDYsIHtsb2NhbGU6ICdkZS1ERSd9KS53ZWVrc0luTG9jYWxXZWVrWWVhciAvLz0+IDUzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbkxvY2FsV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB3ZWVrc0luV2Vla1llYXIoXG4gICAgICAgICAgdGhpcy5sb2NhbFdlZWtZZWFyLFxuICAgICAgICAgIHRoaXMubG9jLmdldE1pbkRheXNJbkZpcnN0V2VlaygpLFxuICAgICAgICAgIHRoaXMubG9jLmdldFN0YXJ0T2ZXZWVrKClcbiAgICAgICAgKVxuICAgICAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWxzbyBzdXBwb3J0cyBzZXR0aW5nIGxvY2FsZS1iYXNlZCB3ZWVrIHVuaXRzLCBpLmUuIGBsb2NhbFdlZWtkYXlgLCBgbG9jYWxXZWVrTnVtYmVyYCBhbmQgYGxvY2FsV2Vla1llYXJgLlxuICAgKiBUaGV5IGNhbm5vdCBiZSBtaXhlZCB3aXRoIElTTy13ZWVrIHVuaXRzIGxpa2UgYHdlZWtkYXlgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyBob3VyOiA4LCBtaW51dGU6IDMwIH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHdlZWtkYXk6IDUgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAwNSwgb3JkaW5hbDogMjM0IH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3QodmFsdWVzLCBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3MpO1xuICAgIGNvbnN0IHsgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayB9ID0gdXNlc0xvY2FsV2Vla1ZhbHVlcyhub3JtYWxpemVkLCB0aGlzLmxvYyk7XG5cbiAgICBjb25zdCBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKFxuICAgICAgICB7IC4uLmdyZWdvcmlhblRvV2Vlayh0aGlzLmMsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspLCAuLi5ub3JtYWxpemVkIH0sXG4gICAgICAgIG1pbkRheXNJbkZpcnN0V2VlayxcbiAgICAgICAgc3RhcnRPZldlZWtcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vla1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3dlZWsnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMycsIHdlZWtzIGFsd2F5cyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhcnRPZih1bml0LCB7IHVzZUxvY2FsZVdlZWtzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIGlmICh1c2VMb2NhbGVXZWVrcykge1xuICAgICAgICBjb25zdCBzdGFydE9mV2VlayA9IHRoaXMubG9jLmdldFN0YXJ0T2ZXZWVrKCk7XG4gICAgICAgIGNvbnN0IHsgd2Vla2RheSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHdlZWtkYXkgPCBzdGFydE9mV2Vlaykge1xuICAgICAgICAgIG8ud2Vla051bWJlciA9IHRoaXMud2Vla051bWJlciAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgby53ZWVrZGF5ID0gc3RhcnRPZldlZWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLndlZWtkYXkgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJxdWFydGVyc1wiKSB7XG4gICAgICBjb25zdCBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgZW5kIChtZWFuaW5nIHRoZSBsYXN0IG1pbGxpc2Vjb25kKSBvZiBhIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBlbmQgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vla1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignbW9udGgnKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3llYXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTEyLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3dlZWsnKS50b0lTTygpOyAvLyA9PiAnMjAxNC0wMy0wOVQyMzo1OTo1OS45OTktMDU6MDAnLCB3ZWVrcyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignZGF5JykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignaG91cicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMDU6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIGVuZE9mKHVuaXQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IHRoaXMucGx1cyh7IFt1bml0XTogMSB9KVxuICAgICAgICAgIC5zdGFydE9mKHVuaXQsIG9wdHMpXG4gICAgICAgICAgLm1pbnVzKDEpXG4gICAgICA6IHRoaXM7XG4gIH1cblxuICAvLyBPVVRQVVRcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLlxuICAgKiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlIGZvcm1hdHRpbmcgdG9vbC4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvZm9ybWF0dGluZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgQXByIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2ZyJykudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnLCB7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoXCJISCAnaG91cnMgYW5kJyBtbSAnbWludXRlcydcIikgLy89PiAnMjAgaG91cnMgYW5kIDU1IG1pbnV0ZXMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLnJlZGVmYXVsdFRvRU4ob3B0cykpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgZGF0ZS4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzIGBEYXRlVGltZS5EQVRFX0ZVTExgIG9yIGBEYXRlVGltZS5USU1FX1NJTVBMRWAuXG4gICAqIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvblxuICAgKiBvZiB0aGUgRGF0ZVRpbWUgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdE9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gNC8yMC8yMDE3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZW4tZ2InKS50b0xvY2FsZVN0cmluZygpOyAvLz0+ICcyMC8wNC8yMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+ICdBcHJpbCAyMCwgMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyJyB9KTsgLy89PiAnMjggYW/Du3QgMjAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+ICcxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfU0hPUlQpOyAvLz0+ICc0LzIwLzIwMTcsIDExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdsb25nJywgbW9udGg6ICdsb25nJywgZGF5OiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodXJzZGF5LCBBcHJpbCAyMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodSwgQXByIDIwLCAxMToyNyBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnLCBob3VyQ3ljbGU6ICdoMjMnIH0pOyAvLz0+ICcxMTozMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXREYXRlVGltZSh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZm9ybWF0IFwicGFydHNcIiwgbWVhbmluZyBpbmRpdmlkdWFsIHRva2VucyBhbG9uZyB3aXRoIG1ldGFkYXRhLiBUaGlzIGlzIGFsbG93cyBjYWxsZXJzIHRvIHBvc3QtcHJvY2VzcyBpbmRpdmlkdWFsIHNlY3Rpb25zIG9mIHRoZSBmb3JtYXR0ZWQgb3V0cHV0LlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdC9mb3JtYXRUb1BhcnRzXG4gICAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLCBzYW1lIGFzIGB0b0xvY2FsZVN0cmluZ2AuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlUGFydHMoKTsgLy89PiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnZGF5JywgdmFsdWU6ICcyNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ21vbnRoJywgdmFsdWU6ICcwNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ3llYXInLCB2YWx1ZTogJzE5ODInIH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gXVxuICAgKi9cbiAgdG9Mb2NhbGVQYXJ0cyhvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIG9wdHMpLmZvcm1hdERhdGVUaW1lUGFydHModGhpcylcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPWZhbHNlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wcmVjaXNpb249J21pbGxpc2Vjb25kcyddIC0gdHJ1bmNhdGUgb3V0cHV0IHRvIGRlc2lyZWQgcHJlc2ljaW9uOiAneWVhcnMnLCAnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJyBvciAnbWlsbGlzZWNvbmRzJy4gV2hlbiBwcmVjaXNpb24gYW5kIHN1cHByZXNzU2Vjb25kcyBvciBzdXBwcmVzc01pbGxpc2Vjb25kcyBhcmUgdXNlZCB0b2dldGhlciwgcHJlY2lzaW9uIHNldHMgdGhlIG1heGltdW0gdW5pdCBzaG93biBpbiB0aGUgb3V0cHV0LCBob3dldmVyIHNlY29uZHMgb3IgbWlsbGlzZWNvbmRzIHdpbGwgc3RpbGwgYmUgc3VwcHJlc3NlZCBpZiB0aGV5IGFyZSAwLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MywgNSwgMjUpLnRvSVNPKCkgLy89PiAnMTk4Mi0wNS0yNVQwMDowMDowMC4wMDBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1LTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcyMDE3MDQyMlQyMDQ3MDUuMzM1LTA0MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgcHJlY2lzaW9uOiAnZGF5JyB9KSAvLz0+ICcyMDE3LTA0LTIyWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBwcmVjaXNpb246ICdtaW51dGUnIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDdaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICovXG4gIHRvSVNPKHtcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgICBwcmVjaXNpb24gPSBcIm1pbGxpc2Vjb25kc1wiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJlY2lzaW9uID0gbm9ybWFsaXplVW5pdChwcmVjaXNpb24pO1xuICAgIGNvbnN0IGV4dCA9IGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiO1xuXG4gICAgbGV0IGMgPSB0b0lTT0RhdGUodGhpcywgZXh0LCBwcmVjaXNpb24pO1xuICAgIGlmIChvcmRlcmVkVW5pdHMuaW5kZXhPZihwcmVjaXNpb24pID49IDMpIGMgKz0gXCJUXCI7XG4gICAgYyArPSB0b0lTT1RpbWUoXG4gICAgICB0aGlzLFxuICAgICAgZXh0LFxuICAgICAgc3VwcHJlc3NTZWNvbmRzLFxuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgZXh0ZW5kZWRab25lLFxuICAgICAgcHJlY2lzaW9uXG4gICAgKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByZWNpc2lvbj0nZGF5J10gLSB0cnVuY2F0ZSBvdXRwdXQgdG8gZGVzaXJlZCBwcmVjaXNpb246ICd5ZWFycycsICdtb250aHMnLCBvciAnZGF5cycuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTk4MjA1MjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgcHJlY2lzaW9uOiAnbW9udGgnIH0pIC8vPT4gJzE5ODItMDUnXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiLCBwcmVjaXNpb24gPSBcImRheVwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIiwgbm9ybWFsaXplVW5pdChwcmVjaXNpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9dHJ1ZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJlY2lzaW9uPSdtaWxsaXNlY29uZHMnXSAtIHRydW5jYXRlIG91dHB1dCB0byBkZXNpcmVkIHByZXNpY2lvbjogJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycgb3IgJ21pbGxpc2Vjb25kcycuIFdoZW4gcHJlY2lzaW9uIGFuZCBzdXBwcmVzc1NlY29uZHMgb3Igc3VwcHJlc3NNaWxsaXNlY29uZHMgYXJlIHVzZWQgdG9nZXRoZXIsIHByZWNpc2lvbiBzZXRzIHRoZSBtYXhpbXVtIHVuaXQgc2hvd24gaW4gdGhlIG91dHB1dCwgaG93ZXZlciBzZWNvbmRzIG9yIG1pbGxpc2Vjb25kcyB3aWxsIHN0aWxsIGJlIHN1cHByZXNzZWQgaWYgdGhleSBhcmUgMC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoKSAvLz0+ICcwNzozNDoxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0LCBzZWNvbmRzOiAwLCBtaWxsaXNlY29uZHM6IDAgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzA3OjM0WidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMDczNDE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kOiA1NiB9KS50b0lTT1RpbWUoeyBwcmVjaXNpb246ICdtaW51dGUnIH0pIC8vPT4gJzA3OjM0WidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKHtcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGluY2x1ZGVQcmVmaXggPSBmYWxzZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgcHJlY2lzaW9uID0gXCJtaWxsaXNlY29uZHNcIixcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByZWNpc2lvbiA9IG5vcm1hbGl6ZVVuaXQocHJlY2lzaW9uKTtcbiAgICBsZXQgYyA9IGluY2x1ZGVQcmVmaXggJiYgb3JkZXJlZFVuaXRzLmluZGV4T2YocHJlY2lzaW9uKSA+PSAzID8gXCJUXCIgOiBcIlwiO1xuICAgIHJldHVybiAoXG4gICAgICBjICtcbiAgICAgIHRvSVNPVGltZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIsXG4gICAgICAgIHN1cHByZXNzU2Vjb25kcyxcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICAgIGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIGV4dGVuZGVkWm9uZSxcbiAgICAgICAgcHJlY2lzaW9uXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFJGQyAyODIyLWNvbXBhdGlibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwICswMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCAtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9SRkMyODIyKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzIFpaWlwiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJzLiBUaGUgb3V0cHV0IGlzIGFsd2F5cyBleHByZXNzZWQgaW4gR01ULlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSBzdHJpbmcgY29uZm9ybXMgdG8gUkZDIDExMjMuXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCBHTVQnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMywgMTkpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMTk6MDA6MDAgR01UJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0hUVFAoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLnRvVVRDKCksIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyAnR01UJ1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMRGF0ZSgpIC8vPT4gJzIwMTQtMDctMTMnXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlWm9uZTogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1IEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMVGltZSh7IGluY2x1ZGVPZmZzZXQgPSB0cnVlLCBpbmNsdWRlWm9uZSA9IGZhbHNlLCBpbmNsdWRlT2Zmc2V0U3BhY2UgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBmbXQgPSBcIkhIOm1tOnNzLlNTU1wiO1xuXG4gICAgaWYgKGluY2x1ZGVab25lIHx8IGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgIGlmIChpbmNsdWRlT2Zmc2V0U3BhY2UpIHtcbiAgICAgICAgZm10ICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgICAgIGZtdCArPSBcInpcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgICAgICBmbXQgKz0gXCJaWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgZm10LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgRGF0ZVRpbWUgeyB0czogJHt0aGlzLnRvSVNPKCl9LCB6b25lOiAke3RoaXMuem9uZS5uYW1lfSwgbG9jYWxlOiAke3RoaXMubG9jYWxlfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBEYXRlVGltZSB7IEludmFsaWQsIHJlYXNvbjogJHt0aGlzLmludmFsaWRSZWFzb259IH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS4gQWxpYXMgb2Yge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgKGluY2x1ZGluZyBtaWxsaXNlY29uZHMgaW4gdGhlIGZyYWN0aW9uYWwgcGFydCkgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIC8gMTAwMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIChhcyBhIHdob2xlIG51bWJlcikgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9Vbml4SW50ZWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5mbG9vcih0aGlzLnRzIC8gMTAwMCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEJTT04gc2VyaWFsaXphYmxlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTRGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRGF0ZVRpbWUncyB5ZWFyLCBtb250aCwgZGF5LCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvT2JqZWN0KCkgLy89PiB7IHllYXI6IDIwMTcsIG1vbnRoOiA0LCBkYXk6IDIyLCBob3VyOiAyMCwgbWludXRlOiA0OSwgc2Vjb25kOiA0MiwgbWlsbGlzZWNvbmQ6IDI2OCB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBiYXNlID0geyAuLi50aGlzLmMgfTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVDb25maWcpIHtcbiAgICAgIGJhc2Uub3V0cHV0Q2FsZW5kYXIgPSB0aGlzLm91dHB1dENhbGVuZGFyO1xuICAgICAgYmFzZS5udW1iZXJpbmdTeXN0ZW0gPSB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICBiYXNlLmxvY2FsZSA9IHRoaXMubG9jLmxvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgRGF0ZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0pTRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTik7XG4gIH1cblxuICAvLyBDT01QQVJFXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBEYXRlVGltZXMgYXMgYSBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBEYXRlVGltZSB0byBjb21wYXJlIHRoaXMgb25lIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIGFycmF5IG9mIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpMSA9IERhdGVUaW1lLmZyb21JU08oJzE5ODItMDUtMjVUMDk6NDUnKSxcbiAgICogICAgIGkyID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4My0xMC0xNFQxMDozMCcpO1xuICAgKiBpMi5kaWZmKGkxKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDQzODA3NTAwMDAwIH1cbiAgICogaTIuZGlmZihpMSwgJ2hvdXJzJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDEyMTY4Ljc1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOS4wMzEyNSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTksIGhvdXJzOiAwLjc1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmKG90aGVyRGF0ZVRpbWUsIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXJEYXRlVGltZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcImNyZWF0ZWQgYnkgZGlmZmluZyBhbiBpbnZhbGlkIERhdGVUaW1lXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGR1ck9wdHMgPSB7IGxvY2FsZTogdGhpcy5sb2NhbGUsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sIC4uLm9wdHMgfTtcblxuICAgIGNvbnN0IHVuaXRzID0gbWF5YmVBcnJheSh1bml0KS5tYXAoRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBvdGhlcklzTGF0ZXIgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKSA+IHRoaXMudmFsdWVPZigpLFxuICAgICAgZWFybGllciA9IG90aGVySXNMYXRlciA/IHRoaXMgOiBvdGhlckRhdGVUaW1lLFxuICAgICAgbGF0ZXIgPSBvdGhlcklzTGF0ZXIgPyBvdGhlckRhdGVUaW1lIDogdGhpcyxcbiAgICAgIGRpZmZlZCA9IGRpZmYoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBkdXJPcHRzKTtcblxuICAgIHJldHVybiBvdGhlcklzTGF0ZXIgPyBkaWZmZWQubmVnYXRlKCkgOiBkaWZmZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgcmlnaHQgbm93LlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI2RpZmZ9XG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmTm93KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmKERhdGVUaW1lLm5vdygpLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgc3Bhbm5pbmcgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCBhbm90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbHxEYXRlVGltZX1cbiAgICovXG4gIHVudGlsKG90aGVyRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyh0aGlzLCBvdGhlckRhdGVUaW1lKSA6IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBEYXRlVGltZSBpcyBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWUgYXMgYW5vdGhlciBEYXRlVGltZS5cbiAgICogSGlnaGVyLW9yZGVyIHVuaXRzIG11c3QgYWxzbyBiZSBpZGVudGljYWwgZm9yIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGB0cnVlYC5cbiAgICogTm90ZSB0aGF0IHRpbWUgem9uZXMgYXJlICoqaWdub3JlZCoqIGluIHRoaXMgY29tcGFyaXNvbiwgd2hpY2ggY29tcGFyZXMgdGhlICoqbG9jYWwqKiBjYWxlbmRhciB0aW1lLiBVc2Uge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9IHRvIGNvbnZlcnQgb25lIG9mIHRoZSBkYXRlcyBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vlazsgb25seSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWUgaXMgdXNlZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5oYXNTYW1lKG90aGVyRFQsICdkYXknKTsgLy9+PiB0cnVlIGlmIG90aGVyRFQgaXMgaW4gdGhlIHNhbWUgY3VycmVudCBjYWxlbmRhciBkYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUob3RoZXJEYXRlVGltZSwgdW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgY29uc3QgYWRqdXN0ZWRUb1pvbmUgPSB0aGlzLnNldFpvbmUob3RoZXJEYXRlVGltZS56b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgIGFkanVzdGVkVG9ab25lLnN0YXJ0T2YodW5pdCwgb3B0cykgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IGFkanVzdGVkVG9ab25lLmVuZE9mKHVuaXQsIG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRGF0ZVRpbWVzIGFyZSBlcXVhbCBpZiBhbmQgb25seSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIHRvd2FyZHMgemVybyBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3R5bGU9XCJsb25nXCJdIC0gdGhlIHN0eWxlIG9mIHVuaXRzLCBtdXN0IGJlIFwibG9uZ1wiLCBcInNob3J0XCIsIG9yIFwibmFycm93XCJcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHM7IGlmIG9taXR0ZWQsIG9yIGFuIGFycmF5LCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgYmVzdCB1bml0LiBVc2UgYW4gYXJyYXkgb3Igb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBvciBcInNlY29uZHNcIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJvdW5kPXRydWVdIC0gd2hldGhlciB0byByb3VuZCB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm91bmRpbmc9XCJ0cnVuY1wiXSAtIHJvdW5kaW5nIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZyB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LiBDYW4gYmUgXCJ0cnVuY1wiICh0b3dhcmQgemVybyksIFwiZXhwYW5kXCIgKGF3YXkgZnJvbSB6ZXJvKSwgXCJyb3VuZFwiLCBcImZsb29yXCIsIG9yIFwiY2VpbFwiLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGFkZGluZz0wXSAtIHBhZGRpbmcgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIGFsbG93cyB5b3UgdG8gcm91bmQgdXAgdGhlIHJlc3VsdCBpZiBpdCBmaXRzIGluc2lkZSB0aGUgdGhyZXNob2xkLiBEb24ndCB1c2UgaW4gY29tYmluYXRpb24gd2l0aCB7cm91bmQ6IGZhbHNlfSBiZWNhdXNlIHRoZSBkZWNpbWFsIG91dHB1dCB3aWxsIGluY2x1ZGUgdGhlIHBhZGRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiaW4gMSBkYXlcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS50b1JlbGF0aXZlKHsgZGF5czogMSB9KSAvLz0+IFwiZGVudHJvIGRlIDEgZMOtYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGFucyAyMyBoZXVyZXNcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoeyB1bml0OiBcImhvdXJzXCIgfSkgLy89PiBcIjQ4IGhvdXJzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgaG91cnM6IDM2IH0pLnRvUmVsYXRpdmUoeyByb3VuZDogZmFsc2UgfSkgLy89PiBcIjEuNSBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBiYXNlID0gb3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyA/ICh0aGlzIDwgYmFzZSA/IC1vcHRpb25zLnBhZGRpbmcgOiBvcHRpb25zLnBhZGRpbmcpIDogMDtcbiAgICBsZXQgdW5pdHMgPSBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdO1xuICAgIGxldCB1bml0ID0gb3B0aW9ucy51bml0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudW5pdCkpIHtcbiAgICAgIHVuaXRzID0gb3B0aW9ucy51bml0O1xuICAgICAgdW5pdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShiYXNlLCB0aGlzLnBsdXMocGFkZGluZyksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImFsd2F5c1wiLFxuICAgICAgdW5pdHMsXG4gICAgICB1bml0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlIHJlbGF0aXZlIHRvIHRvZGF5LCBzdWNoIGFzIFwieWVzdGVyZGF5XCIgb3IgXCJuZXh0IG1vbnRoXCIuXG4gICAqIE9ubHkgaW50ZXJuYXRpb25hbGl6ZXMgb24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdDsgaWYgb21pdHRlZCwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIHVuaXQuIFVzZSBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgb3IgXCJkYXlzXCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwidG9tb3Jyb3dcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcIlwibWHDsWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcih7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkZW1haW5cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLCB0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluIG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtaW5pbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWluIERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtaW4oLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5tYXgpO1xuICB9XG5cbiAgLy8gTUlTQ1xuXG4gIC8qKlxuICAgKiBFeHBsYWluIGhvdyBhIHN0cmluZyB3b3VsZCBiZSBwYXJzZWQgYnkgZnJvbUZvcm1hdCgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgcGFyc2VyIGZvciBgZm10YCB1c2luZyB0aGUgZ2l2ZW4gbG9jYWxlLiBUaGlzIHBhcnNlciBjYW4gYmUgcGFzc2VkXG4gICAqIHRvIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0UGFyc2VyfSB0byBhIHBhcnNlIGEgZGF0ZSBpbiB0aGlzIGZvcm1hdC4gVGhpc1xuICAgKiBjYW4gYmUgdXNlZCB0byBvcHRpbWl6ZSBjYXNlcyB3aGVyZSBtYW55IGRhdGVzIG5lZWQgdG8gYmUgcGFyc2VkIGluIGFcbiAgICogc3BlY2lmaWMgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWVcbiAgICogZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB1c2VkIHRvIHNldCBsb2NhbGUgYW5kIG51bWJlcmluZ1N5c3RlbVxuICAgKiBmb3IgcGFyc2VyXG4gICAqIEByZXR1cm5zIHtUb2tlblBhcnNlcn0gLSBvcGFxdWUgb2JqZWN0IHRvIGJlIHVzZWRcbiAgICovXG4gIHN0YXRpYyBidWlsZEZvcm1hdFBhcnNlcihmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0aW9ucyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUb2tlblBhcnNlcihsb2NhbGVUb1VzZSwgZm10KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIGlucHV0IHN0cmluZyBhbmQgZm9ybWF0IHBhcnNlci5cbiAgICpcbiAgICogVGhlIGZvcm1hdCBwYXJzZXIgbXVzdCBoYXZlIGJlZW4gY3JlYXRlZCB3aXRoIHRoZSBzYW1lIGxvY2FsZSBhcyB0aGlzIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge1Rva2VuUGFyc2VyfSBmb3JtYXRQYXJzZXIgLSBwYXJzZXIgZnJvbSB7QGxpbmsgRGF0ZVRpbWUuYnVpbGRGb3JtYXRQYXJzZXJ9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybnMge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRQYXJzZXIodGV4dCwgZm9ybWF0UGFyc2VyLCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGV4dCkgfHwgaXNVbmRlZmluZWQoZm9ybWF0UGFyc2VyKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBcImZyb21Gb3JtYXRQYXJzZXIgcmVxdWlyZXMgYW4gaW5wdXQgc3RyaW5nIGFuZCBhIGZvcm1hdCBwYXJzZXJcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcblxuICAgIGlmICghbG9jYWxlVG9Vc2UuZXF1YWxzKGZvcm1hdFBhcnNlci5sb2NhbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBmcm9tRm9ybWF0UGFyc2VyIGNhbGxlZCB3aXRoIGEgbG9jYWxlIG9mICR7bG9jYWxlVG9Vc2V9LCBgICtcbiAgICAgICAgICBgYnV0IHRoZSBmb3JtYXQgcGFyc2VyIHdhcyBjcmVhdGVkIGZvciAke2Zvcm1hdFBhcnNlci5sb2NhbGV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGZvcm1hdFBhcnNlci5leHBsYWluRnJvbVRva2Vucyh0ZXh0KTtcblxuICAgIGlmIChpbnZhbGlkUmVhc29uKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkUmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUoXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgem9uZSxcbiAgICAgICAgb3B0cyxcbiAgICAgICAgYGZvcm1hdCAke2Zvcm1hdFBhcnNlci5mb3JtYXR9YCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/duration.js":
/*!**************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/duration.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accurateMatrix: () => (/* binding */ accurateMatrix),\n/* harmony export */   casualMatrix: () => (/* binding */ casualMatrix),\n/* harmony export */   daysInMonthAccurate: () => (/* binding */ daysInMonthAccurate),\n/* harmony export */   daysInYearAccurate: () => (/* binding */ daysInYearAccurate),\n/* harmony export */   \"default\": () => (/* binding */ Duration),\n/* harmony export */   lowOrderMatrix: () => (/* binding */ lowOrderMatrix)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\");\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Duration\";\n\n// unit conversion constants\nconst lowOrderMatrix = {\n    weeks: {\n      days: 7,\n      hours: 7 * 24,\n      minutes: 7 * 24 * 60,\n      seconds: 7 * 24 * 60 * 60,\n      milliseconds: 7 * 24 * 60 * 60 * 1000,\n    },\n    days: {\n      hours: 24,\n      minutes: 24 * 60,\n      seconds: 24 * 60 * 60,\n      milliseconds: 24 * 60 * 60 * 1000,\n    },\n    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },\n    minutes: { seconds: 60, milliseconds: 60 * 1000 },\n    seconds: { milliseconds: 1000 },\n  },\n  casualMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: 52,\n      days: 365,\n      hours: 365 * 24,\n      minutes: 365 * 24 * 60,\n      seconds: 365 * 24 * 60 * 60,\n      milliseconds: 365 * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: 13,\n      days: 91,\n      hours: 91 * 24,\n      minutes: 91 * 24 * 60,\n      seconds: 91 * 24 * 60 * 60,\n      milliseconds: 91 * 24 * 60 * 60 * 1000,\n    },\n    months: {\n      weeks: 4,\n      days: 30,\n      hours: 30 * 24,\n      minutes: 30 * 24 * 60,\n      seconds: 30 * 24 * 60 * 60,\n      milliseconds: 30 * 24 * 60 * 60 * 1000,\n    },\n\n    ...lowOrderMatrix,\n  },\n  daysInYearAccurate = 146097.0 / 400,\n  daysInMonthAccurate = 146097.0 / 4800,\n  accurateMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: daysInYearAccurate / 7,\n      days: daysInYearAccurate,\n      hours: daysInYearAccurate * 24,\n      minutes: daysInYearAccurate * 24 * 60,\n      seconds: daysInYearAccurate * 24 * 60 * 60,\n      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: daysInYearAccurate / 28,\n      days: daysInYearAccurate / 4,\n      hours: (daysInYearAccurate * 24) / 4,\n      minutes: (daysInYearAccurate * 24 * 60) / 4,\n      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,\n      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,\n    },\n    months: {\n      weeks: daysInMonthAccurate / 7,\n      days: daysInMonthAccurate,\n      hours: daysInMonthAccurate * 24,\n      minutes: daysInMonthAccurate * 24 * 60,\n      seconds: daysInMonthAccurate * 24 * 60 * 60,\n      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,\n    },\n    ...lowOrderMatrix,\n  };\n\n// units ordered by size\nconst orderedUnits = [\n  \"years\",\n  \"quarters\",\n  \"months\",\n  \"weeks\",\n  \"days\",\n  \"hours\",\n  \"minutes\",\n  \"seconds\",\n  \"milliseconds\",\n];\n\nconst reverseUnits = orderedUnits.slice(0).reverse();\n\n// clone really means \"create another instance just like this one, but with these changes\"\nfunction clone(dur, alts, clear = false) {\n  // deep merge for vals\n  const conf = {\n    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },\n    loc: dur.loc.clone(alts.loc),\n    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,\n    matrix: alts.matrix || dur.matrix,\n  };\n  return new Duration(conf);\n}\n\nfunction durationToMillis(matrix, vals) {\n  let sum = vals.milliseconds ?? 0;\n  for (const unit of reverseUnits.slice(1)) {\n    if (vals[unit]) {\n      sum += vals[unit] * matrix[unit][\"milliseconds\"];\n    }\n  }\n  return sum;\n}\n\n// NB: mutates parameters\nfunction normalizeValues(matrix, vals) {\n  // the logic below assumes the overall value of the duration is positive\n  // if this is not the case, factor is used to make it so\n  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;\n\n  orderedUnits.reduceRight((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const previousVal = vals[previous] * factor;\n        const conv = matrix[current][previous];\n\n        // if (previousVal < 0):\n        // lower order unit is negative (e.g. { years: 2, days: -2 })\n        // normalize this by reducing the higher order unit by the appropriate amount\n        // and increasing the lower order unit\n        // this can never make the higher order unit negative, because this function only operates\n        // on positive durations, so the amount of time represented by the lower order unit cannot\n        // be larger than the higher order unit\n        // else:\n        // lower order unit is positive (e.g. { years: 2, days: 450 } or { years: -2, days: 450 })\n        // in this case we attempt to convert as much as possible from the lower order unit into\n        // the higher order one\n        //\n        // Math.floor takes care of both of these cases, rounding away from 0\n        // if previousVal < 0 it makes the absolute value larger\n        // if previousVal >= it makes the absolute value smaller\n        const rollUp = Math.floor(previousVal / conv);\n        vals[current] += rollUp * factor;\n        vals[previous] -= rollUp * conv * factor;\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n\n  // try to convert any decimals into smaller units if possible\n  // for example for { years: 2.5, days: 0, seconds: 0 } we want to get { years: 2, days: 182, hours: 12 }\n  orderedUnits.reduce((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const fraction = vals[previous] % 1;\n        vals[previous] -= fraction;\n        vals[current] += fraction * matrix[previous][current];\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n}\n\n// Remove all properties with a value of 0 from an object\nfunction removeZeroes(vals) {\n  const newVals = {};\n  for (const [key, value] of Object.entries(vals)) {\n    if (value !== 0) {\n      newVals[key] = value;\n    }\n  }\n  return newVals;\n}\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nclass Duration {\n  /**\n   * @private\n   */\n  constructor(config) {\n    const accurate = config.conversionAccuracy === \"longterm\" || false;\n    let matrix = accurate ? accurateMatrix : casualMatrix;\n\n    if (config.matrix) {\n      matrix = config.matrix;\n    }\n\n    /**\n     * @access private\n     */\n    this.values = config.values;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.matrix = matrix;\n    /**\n     * @access private\n     */\n    this.isLuxonDuration = true;\n  }\n\n  /**\n   * Create Duration from a number of milliseconds.\n   * @param {number} count of milliseconds\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  static fromMillis(count, opts) {\n    return Duration.fromObject({ milliseconds: count }, opts);\n  }\n\n  /**\n   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n   * If this object is empty then a zero milliseconds duration is returned.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.years\n   * @param {number} obj.quarters\n   * @param {number} obj.months\n   * @param {number} obj.weeks\n   * @param {number} obj.days\n   * @param {number} obj.hours\n   * @param {number} obj.minutes\n   * @param {number} obj.seconds\n   * @param {number} obj.milliseconds\n   * @param {Object} [opts=[]] - options for creating this Duration\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the custom conversion system to use\n   * @return {Duration}\n   */\n  static fromObject(obj, opts = {}) {\n    if (obj == null || typeof obj !== \"object\") {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Duration.fromObject: argument expected to be an object, got ${\n          obj === null ? \"null\" : typeof obj\n        }`\n      );\n    }\n\n    return new Duration({\n      values: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(obj, Duration.normalizeUnit),\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromObject(opts),\n      conversionAccuracy: opts.conversionAccuracy,\n      matrix: opts.matrix,\n    });\n  }\n\n  /**\n   * Create a Duration from DurationLike.\n   *\n   * @param {Object | number | Duration} durationLike\n   * One of:\n   * - object with keys like 'years' and 'hours'.\n   * - number representing milliseconds\n   * - Duration instance\n   * @return {Duration}\n   */\n  static fromDurationLike(durationLike) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(durationLike)) {\n      return Duration.fromMillis(durationLike);\n    } else if (Duration.isDuration(durationLike)) {\n      return durationLike;\n    } else if (typeof durationLike === \"object\") {\n      return Duration.fromObject(durationLike);\n    } else {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`\n      );\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 duration string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the preset conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n   * @return {Duration}\n   */\n  static fromISO(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISODuration)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 time string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @return {Duration}\n   */\n  static fromISOTime(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISOTimeOnly)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create an invalid Duration.\n   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Duration}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidDurationError(invalid);\n    } else {\n      return new Duration({ invalid });\n    }\n  }\n\n  /**\n   * @private\n   */\n  static normalizeUnit(unit) {\n    const normalized = {\n      year: \"years\",\n      years: \"years\",\n      quarter: \"quarters\",\n      quarters: \"quarters\",\n      month: \"months\",\n      months: \"months\",\n      week: \"weeks\",\n      weeks: \"weeks\",\n      day: \"days\",\n      days: \"days\",\n      hour: \"hours\",\n      hours: \"hours\",\n      minute: \"minutes\",\n      minutes: \"minutes\",\n      second: \"seconds\",\n      seconds: \"seconds\",\n      millisecond: \"milliseconds\",\n      milliseconds: \"milliseconds\",\n    }[unit ? unit.toLowerCase() : unit];\n\n    if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUnitError(unit);\n\n    return normalized;\n  }\n\n  /**\n   * Check if an object is a Duration. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDuration(o) {\n    return (o && o.isLuxonDuration) || false;\n  }\n\n  /**\n   * Get  the locale of a Duration, such 'en-GB'\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n   * * `S` for milliseconds\n   * * `s` for seconds\n   * * `m` for minutes\n   * * `h` for hours\n   * * `d` for days\n   * * `w` for weeks\n   * * `M` for months\n   * * `y` for years\n   * Notes:\n   * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n   * * Tokens can be escaped by wrapping with single quotes.\n   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - options\n   * @param {boolean} [opts.floor=true] - floor numerical values\n   * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n   * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"+6 +2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"-6 -2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"negativeLargestOnly\" }) //=> \"-6 2\"\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    // reverse-compat since 1.2; we always round down now, never up, and we do it by default\n    const fmtOpts = {\n      ...opts,\n      floor: opts.round !== false && opts.floor !== false,\n    };\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(this.loc, fmtOpts).formatDurationFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a string representation of a Duration with all units included.\n   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options\n   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.\n   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.\n   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero\n   * @example\n   * ```js\n   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })\n   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'\n   * dur.toHuman({ listStyle: \"long\" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'\n   * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 mth, 0 wks, 5 hr, 6 min'\n   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'\n   * ```\n   */\n  toHuman(opts = {}) {\n    if (!this.isValid) return INVALID;\n\n    const showZeros = opts.showZeros !== false;\n\n    const l = orderedUnits\n      .map((unit) => {\n        const val = this.values[unit];\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(val) || (val === 0 && !showZeros)) {\n          return null;\n        }\n        return this.loc\n          .numberFormatter({ style: \"unit\", unitDisplay: \"long\", ...opts, unit: unit.slice(0, -1) })\n          .format(val);\n      })\n      .filter((n) => n);\n\n    return this.loc\n      .listFormatter({ type: \"conjunction\", style: opts.listStyle || \"narrow\", ...opts })\n      .format(l);\n  }\n\n  /**\n   * Returns a JavaScript object with this Duration's values.\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n   * @return {Object}\n   */\n  toObject() {\n    if (!this.isValid) return {};\n    return { ...this.values };\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n   * @return {string}\n   */\n  toISO() {\n    // we could use the formatter, but this is an easier way to get the minimum string\n    if (!this.isValid) return null;\n\n    let s = \"P\";\n    if (this.years !== 0) s += this.years + \"Y\";\n    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\n    if (this.weeks !== 0) s += this.weeks + \"W\";\n    if (this.days !== 0) s += this.days + \"D\";\n    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)\n      s += \"T\";\n    if (this.hours !== 0) s += this.hours + \"H\";\n    if (this.minutes !== 0) s += this.minutes + \"M\";\n    if (this.seconds !== 0 || this.milliseconds !== 0)\n      // this will handle \"floating point madness\" by removing extra decimal places\n      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken\n      s += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.roundTo)(this.seconds + this.milliseconds / 1000, 3) + \"S\";\n    if (s === \"P\") s += \"T0S\";\n    return s;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n   * @return {string}\n   */\n  toISOTime(opts = {}) {\n    if (!this.isValid) return null;\n\n    const millis = this.toMillis();\n    if (millis < 0 || millis >= 86400000) return null;\n\n    opts = {\n      suppressMilliseconds: false,\n      suppressSeconds: false,\n      includePrefix: false,\n      format: \"extended\",\n      ...opts,\n      includeOffset: false,\n    };\n\n    const dateTime = _datetime_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromMillis(millis, { zone: \"UTC\" });\n    return dateTime.toISOTime(opts);\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n   * @return {string}\n   */\n  toString() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a string representation of this Duration appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Duration { values: ${JSON.stringify(this.values)} }`;\n    } else {\n      return `Duration { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration.\n   * @return {number}\n   */\n  toMillis() {\n    if (!this.isValid) return NaN;\n\n    return durationToMillis(this.matrix, this.values);\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration),\n      result = {};\n\n    for (const k of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(dur.values, k) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(this.values, k)) {\n        result[k] = dur.get(k) + this.get(k);\n      }\n    }\n\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration);\n    return this.plus(dur.negate());\n  }\n\n  /**\n   * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === \"hours\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n   * @return {Duration}\n   */\n  mapUnits(fn) {\n    if (!this.isValid) return this;\n    const result = {};\n    for (const k of Object.keys(this.values)) {\n      result[k] = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.asNumber)(fn(this.values[k], k));\n    }\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n   * @return {number}\n   */\n  get(unit) {\n    return this[Duration.normalizeUnit(unit)];\n  }\n\n  /**\n   * \"Set\" the values of specified units. Return a newly-constructed Duration.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dur.set({ years: 2017 })\n   * @example dur.set({ hours: 8, minutes: 30 })\n   * @return {Duration}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const mixed = { ...this.values, ...(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(values, Duration.normalizeUnit) };\n    return clone(this, { values: mixed });\n  }\n\n  /**\n   * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n   * @example dur.reconfigure({ locale: 'en-GB' })\n   * @return {Duration}\n   */\n  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem });\n    const opts = { loc, matrix, conversionAccuracy };\n    return clone(this, opts);\n  }\n\n  /**\n   * Return the length of the duration in the specified unit.\n   * @param {string} unit - a unit such as 'minutes' or 'days'\n   * @example Duration.fromObject({years: 1}).as('days') //=> 365\n   * @example Duration.fromObject({years: 1}).as('months') //=> 12\n   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\n   * @return {number}\n   */\n  as(unit) {\n    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\n  }\n\n  /**\n   * Reduce this Duration to its canonical representation in its current units.\n   * Assuming the overall value of the Duration is positive, this means:\n   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)\n   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise\n   *   the overall value would be negative, see third example)\n   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)\n   *\n   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.\n   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }\n   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }\n   * @return {Duration}\n   */\n  normalize() {\n    if (!this.isValid) return this;\n    const vals = this.toObject();\n    normalizeValues(this.matrix, vals);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Rescale units to its largest representation\n   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }\n   * @return {Duration}\n   */\n  rescale() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.normalize().shiftToAll().toObject());\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Convert this Duration into its representation in a different set of units.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n   * @return {Duration}\n   */\n  shiftTo(...units) {\n    if (!this.isValid) return this;\n\n    if (units.length === 0) {\n      return this;\n    }\n\n    units = units.map((u) => Duration.normalizeUnit(u));\n\n    const built = {},\n      accumulated = {},\n      vals = this.toObject();\n    let lastUnit;\n\n    for (const k of orderedUnits) {\n      if (units.indexOf(k) >= 0) {\n        lastUnit = k;\n\n        let own = 0;\n\n        // anything we haven't boiled down yet should get boiled to this unit\n        for (const ak in accumulated) {\n          own += this.matrix[ak][k] * accumulated[ak];\n          accumulated[ak] = 0;\n        }\n\n        // plus anything that's already in this unit\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n          own += vals[k];\n        }\n\n        // only keep the integer part for now in the hopes of putting any decimal part\n        // into a smaller unit later\n        const i = Math.trunc(own);\n        built[k] = i;\n        accumulated[k] = (own * 1000 - i * 1000) / 1000;\n\n        // otherwise, keep it in the wings to boil it later\n      } else if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n        accumulated[k] = vals[k];\n      }\n    }\n\n    // anything leftover becomes the decimal for the last unit\n    // lastUnit must be defined since units is not empty\n    for (const key in accumulated) {\n      if (accumulated[key] !== 0) {\n        built[lastUnit] +=\n          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\n      }\n    }\n\n    normalizeValues(this.matrix, built);\n    return clone(this, { values: built }, true);\n  }\n\n  /**\n   * Shift this Duration to all available units.\n   * Same as shiftTo(\"years\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"milliseconds\")\n   * @return {Duration}\n   */\n  shiftToAll() {\n    if (!this.isValid) return this;\n    return this.shiftTo(\n      \"years\",\n      \"months\",\n      \"weeks\",\n      \"days\",\n      \"hours\",\n      \"minutes\",\n      \"seconds\",\n      \"milliseconds\"\n    );\n  }\n\n  /**\n   * Return the negative of this Duration.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n   * @return {Duration}\n   */\n  negate() {\n    if (!this.isValid) return this;\n    const negated = {};\n    for (const k of Object.keys(this.values)) {\n      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];\n    }\n    return clone(this, { values: negated }, true);\n  }\n\n  /**\n   * Removes all units with values equal to 0 from this Duration.\n   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }\n   * @return {Duration}\n   */\n  removeZeros() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.values);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Get the years.\n   * @type {number}\n   */\n  get years() {\n    return this.isValid ? this.values.years || 0 : NaN;\n  }\n\n  /**\n   * Get the quarters.\n   * @type {number}\n   */\n  get quarters() {\n    return this.isValid ? this.values.quarters || 0 : NaN;\n  }\n\n  /**\n   * Get the months.\n   * @type {number}\n   */\n  get months() {\n    return this.isValid ? this.values.months || 0 : NaN;\n  }\n\n  /**\n   * Get the weeks\n   * @type {number}\n   */\n  get weeks() {\n    return this.isValid ? this.values.weeks || 0 : NaN;\n  }\n\n  /**\n   * Get the days.\n   * @type {number}\n   */\n  get days() {\n    return this.isValid ? this.values.days || 0 : NaN;\n  }\n\n  /**\n   * Get the hours.\n   * @type {number}\n   */\n  get hours() {\n    return this.isValid ? this.values.hours || 0 : NaN;\n  }\n\n  /**\n   * Get the minutes.\n   * @type {number}\n   */\n  get minutes() {\n    return this.isValid ? this.values.minutes || 0 : NaN;\n  }\n\n  /**\n   * Get the seconds.\n   * @return {number}\n   */\n  get seconds() {\n    return this.isValid ? this.values.seconds || 0 : NaN;\n  }\n\n  /**\n   * Get the milliseconds.\n   * @return {number}\n   */\n  get milliseconds() {\n    return this.isValid ? this.values.milliseconds || 0 : NaN;\n  }\n\n  /**\n   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n   * on invalid DateTimes or Intervals.\n   * @return {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this Duration became invalid, or null if the Duration is valid\n   * @return {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Equality check\n   * Two Durations are equal iff they have the same units and the same values for each unit.\n   * @param {Duration} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    if (!this.loc.equals(other.loc)) {\n      return false;\n    }\n\n    function eq(v1, v2) {\n      // Consider 0 and undefined as equal\n      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;\n      return v1 === v2;\n    }\n\n    for (const u of orderedUnits) {\n      if (!eq(this.values[u], other.values[u])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7QUFDL0M7QUFDSjtBQUNGO0FBQ3FDO0FBUW5EO0FBQ2E7QUFDQTs7QUFFckM7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWEsNkRBQTZEO0FBQzFFLGVBQWUsc0NBQXNDO0FBQ3JELGVBQWUsb0JBQW9CO0FBQ25DLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQ0FBb0MsR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxT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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZER1cmF0aW9uRXJyb3IsIEludmFsaWRVbml0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VJU09EdXJhdGlvbiwgcGFyc2VJU09UaW1lT25seSB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGFzTnVtYmVyLFxuICBoYXNPd25Qcm9wZXJ0eSxcbiAgaXNOdW1iZXIsXG4gIGlzVW5kZWZpbmVkLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBEdXJhdGlvblwiO1xuXG4vLyB1bml0IGNvbnZlcnNpb24gY29uc3RhbnRzXG5leHBvcnQgY29uc3QgbG93T3JkZXJNYXRyaXggPSB7XG4gICAgd2Vla3M6IHtcbiAgICAgIGRheXM6IDcsXG4gICAgICBob3VyczogNyAqIDI0LFxuICAgICAgbWludXRlczogNyAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiA3ICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGRheXM6IHtcbiAgICAgIGhvdXJzOiAyNCxcbiAgICAgIG1pbnV0ZXM6IDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBob3VyczogeyBtaW51dGVzOiA2MCwgc2Vjb25kczogNjAgKiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDYwICogMTAwMCB9LFxuICAgIG1pbnV0ZXM6IHsgc2Vjb25kczogNjAsIG1pbGxpc2Vjb25kczogNjAgKiAxMDAwIH0sXG4gICAgc2Vjb25kczogeyBtaWxsaXNlY29uZHM6IDEwMDAgfSxcbiAgfSxcbiAgY2FzdWFsTWF0cml4ID0ge1xuICAgIHllYXJzOiB7XG4gICAgICBxdWFydGVyczogNCxcbiAgICAgIG1vbnRoczogMTIsXG4gICAgICB3ZWVrczogNTIsXG4gICAgICBkYXlzOiAzNjUsXG4gICAgICBob3VyczogMzY1ICogMjQsXG4gICAgICBtaW51dGVzOiAzNjUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiAxMyxcbiAgICAgIGRheXM6IDkxLFxuICAgICAgaG91cnM6IDkxICogMjQsXG4gICAgICBtaW51dGVzOiA5MSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogNCxcbiAgICAgIGRheXM6IDMwLFxuICAgICAgaG91cnM6IDMwICogMjQsXG4gICAgICBtaW51dGVzOiAzMCAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG5cbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfSxcbiAgZGF5c0luWWVhckFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0MDAsXG4gIGRheXNJbk1vbnRoQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQ4MDAsXG4gIGFjY3VyYXRlTWF0cml4ID0ge1xuICAgIHllYXJzOiB7XG4gICAgICBxdWFydGVyczogNCxcbiAgICAgIG1vbnRoczogMTIsXG4gICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gNyxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSxcbiAgICAgIGhvdXJzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBxdWFydGVyczoge1xuICAgICAgbW9udGhzOiAzLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDI4LFxuICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlIC8gNCxcbiAgICAgIGhvdXJzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQpIC8gNCxcbiAgICAgIG1pbnV0ZXM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwKSAvIDQsXG4gICAgICBzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwKSAvIDQsXG4gICAgICBtaWxsaXNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwKSAvIDQsXG4gICAgfSxcbiAgICBtb250aHM6IHtcbiAgICAgIHdlZWtzOiBkYXlzSW5Nb250aEFjY3VyYXRlIC8gNyxcbiAgICAgIGRheXM6IGRheXNJbk1vbnRoQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0LFxuICAgICAgbWludXRlczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIC4uLmxvd09yZGVyTWF0cml4LFxuICB9O1xuXG4vLyB1bml0cyBvcmRlcmVkIGJ5IHNpemVcbmNvbnN0IG9yZGVyZWRVbml0cyA9IFtcbiAgXCJ5ZWFyc1wiLFxuICBcInF1YXJ0ZXJzXCIsXG4gIFwibW9udGhzXCIsXG4gIFwid2Vla3NcIixcbiAgXCJkYXlzXCIsXG4gIFwiaG91cnNcIixcbiAgXCJtaW51dGVzXCIsXG4gIFwic2Vjb25kc1wiLFxuICBcIm1pbGxpc2Vjb25kc1wiLFxuXTtcblxuY29uc3QgcmV2ZXJzZVVuaXRzID0gb3JkZXJlZFVuaXRzLnNsaWNlKDApLnJldmVyc2UoKTtcblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zIFwiY3JlYXRlIGFub3RoZXIgaW5zdGFuY2UganVzdCBsaWtlIHRoaXMgb25lLCBidXQgd2l0aCB0aGVzZSBjaGFuZ2VzXCJcbmZ1bmN0aW9uIGNsb25lKGR1ciwgYWx0cywgY2xlYXIgPSBmYWxzZSkge1xuICAvLyBkZWVwIG1lcmdlIGZvciB2YWxzXG4gIGNvbnN0IGNvbmYgPSB7XG4gICAgdmFsdWVzOiBjbGVhciA/IGFsdHMudmFsdWVzIDogeyAuLi5kdXIudmFsdWVzLCAuLi4oYWx0cy52YWx1ZXMgfHwge30pIH0sXG4gICAgbG9jOiBkdXIubG9jLmNsb25lKGFsdHMubG9jKSxcbiAgICBjb252ZXJzaW9uQWNjdXJhY3k6IGFsdHMuY29udmVyc2lvbkFjY3VyYWN5IHx8IGR1ci5jb252ZXJzaW9uQWNjdXJhY3ksXG4gICAgbWF0cml4OiBhbHRzLm1hdHJpeCB8fCBkdXIubWF0cml4LFxuICB9O1xuICByZXR1cm4gbmV3IER1cmF0aW9uKGNvbmYpO1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvblRvTWlsbGlzKG1hdHJpeCwgdmFscykge1xuICBsZXQgc3VtID0gdmFscy5taWxsaXNlY29uZHMgPz8gMDtcbiAgZm9yIChjb25zdCB1bml0IG9mIHJldmVyc2VVbml0cy5zbGljZSgxKSkge1xuICAgIGlmICh2YWxzW3VuaXRdKSB7XG4gICAgICBzdW0gKz0gdmFsc1t1bml0XSAqIG1hdHJpeFt1bml0XVtcIm1pbGxpc2Vjb25kc1wiXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuLy8gTkI6IG11dGF0ZXMgcGFyYW1ldGVyc1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWVzKG1hdHJpeCwgdmFscykge1xuICAvLyB0aGUgbG9naWMgYmVsb3cgYXNzdW1lcyB0aGUgb3ZlcmFsbCB2YWx1ZSBvZiB0aGUgZHVyYXRpb24gaXMgcG9zaXRpdmVcbiAgLy8gaWYgdGhpcyBpcyBub3QgdGhlIGNhc2UsIGZhY3RvciBpcyB1c2VkIHRvIG1ha2UgaXQgc29cbiAgY29uc3QgZmFjdG9yID0gZHVyYXRpb25Ub01pbGxpcyhtYXRyaXgsIHZhbHMpIDwgMCA/IC0xIDogMTtcblxuICBvcmRlcmVkVW5pdHMucmVkdWNlUmlnaHQoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsID0gdmFsc1twcmV2aW91c10gKiBmYWN0b3I7XG4gICAgICAgIGNvbnN0IGNvbnYgPSBtYXRyaXhbY3VycmVudF1bcHJldmlvdXNdO1xuXG4gICAgICAgIC8vIGlmIChwcmV2aW91c1ZhbCA8IDApOlxuICAgICAgICAvLyBsb3dlciBvcmRlciB1bml0IGlzIG5lZ2F0aXZlIChlLmcuIHsgeWVhcnM6IDIsIGRheXM6IC0yIH0pXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0aGlzIGJ5IHJlZHVjaW5nIHRoZSBoaWdoZXIgb3JkZXIgdW5pdCBieSB0aGUgYXBwcm9wcmlhdGUgYW1vdW50XG4gICAgICAgIC8vIGFuZCBpbmNyZWFzaW5nIHRoZSBsb3dlciBvcmRlciB1bml0XG4gICAgICAgIC8vIHRoaXMgY2FuIG5ldmVyIG1ha2UgdGhlIGhpZ2hlciBvcmRlciB1bml0IG5lZ2F0aXZlLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gb25seSBvcGVyYXRlc1xuICAgICAgICAvLyBvbiBwb3NpdGl2ZSBkdXJhdGlvbnMsIHNvIHRoZSBhbW91bnQgb2YgdGltZSByZXByZXNlbnRlZCBieSB0aGUgbG93ZXIgb3JkZXIgdW5pdCBjYW5ub3RcbiAgICAgICAgLy8gYmUgbGFyZ2VyIHRoYW4gdGhlIGhpZ2hlciBvcmRlciB1bml0XG4gICAgICAgIC8vIGVsc2U6XG4gICAgICAgIC8vIGxvd2VyIG9yZGVyIHVuaXQgaXMgcG9zaXRpdmUgKGUuZy4geyB5ZWFyczogMiwgZGF5czogNDUwIH0gb3IgeyB5ZWFyczogLTIsIGRheXM6IDQ1MCB9KVxuICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgYXR0ZW1wdCB0byBjb252ZXJ0IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgbG93ZXIgb3JkZXIgdW5pdCBpbnRvXG4gICAgICAgIC8vIHRoZSBoaWdoZXIgb3JkZXIgb25lXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGguZmxvb3IgdGFrZXMgY2FyZSBvZiBib3RoIG9mIHRoZXNlIGNhc2VzLCByb3VuZGluZyBhd2F5IGZyb20gMFxuICAgICAgICAvLyBpZiBwcmV2aW91c1ZhbCA8IDAgaXQgbWFrZXMgdGhlIGFic29sdXRlIHZhbHVlIGxhcmdlclxuICAgICAgICAvLyBpZiBwcmV2aW91c1ZhbCA+PSBpdCBtYWtlcyB0aGUgYWJzb2x1dGUgdmFsdWUgc21hbGxlclxuICAgICAgICBjb25zdCByb2xsVXAgPSBNYXRoLmZsb29yKHByZXZpb3VzVmFsIC8gY29udik7XG4gICAgICAgIHZhbHNbY3VycmVudF0gKz0gcm9sbFVwICogZmFjdG9yO1xuICAgICAgICB2YWxzW3ByZXZpb3VzXSAtPSByb2xsVXAgKiBjb252ICogZmFjdG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gIH0sIG51bGwpO1xuXG4gIC8vIHRyeSB0byBjb252ZXJ0IGFueSBkZWNpbWFscyBpbnRvIHNtYWxsZXIgdW5pdHMgaWYgcG9zc2libGVcbiAgLy8gZm9yIGV4YW1wbGUgZm9yIHsgeWVhcnM6IDIuNSwgZGF5czogMCwgc2Vjb25kczogMCB9IHdlIHdhbnQgdG8gZ2V0IHsgeWVhcnM6IDIsIGRheXM6IDE4MiwgaG91cnM6IDEyIH1cbiAgb3JkZXJlZFVuaXRzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSB2YWxzW3ByZXZpb3VzXSAlIDE7XG4gICAgICAgIHZhbHNbcHJldmlvdXNdIC09IGZyYWN0aW9uO1xuICAgICAgICB2YWxzW2N1cnJlbnRdICs9IGZyYWN0aW9uICogbWF0cml4W3ByZXZpb3VzXVtjdXJyZW50XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcbn1cblxuLy8gUmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIHdpdGggYSB2YWx1ZSBvZiAwIGZyb20gYW4gb2JqZWN0XG5mdW5jdGlvbiByZW1vdmVaZXJvZXModmFscykge1xuICBjb25zdCBuZXdWYWxzID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICBuZXdWYWxzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHM7XG59XG5cbi8qKlxuICogQSBEdXJhdGlvbiBvYmplY3QgcmVwcmVzZW50cyBhIHBlcmlvZCBvZiB0aW1lLCBsaWtlIFwiMiBtb250aHNcIiBvciBcIjEgZGF5LCAxIGhvdXJcIi4gQ29uY2VwdHVhbGx5LCBpdCdzIGp1c3QgYSBtYXAgb2YgdW5pdHMgdG8gdGhlaXIgcXVhbnRpdGllcywgYWNjb21wYW5pZWQgYnkgc29tZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gYW5kIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uIFRoZXkgY2FuIGJlIHVzZWQgb24gdGhlaXIgb3duIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgTHV4b24gdHlwZXM7IGZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c30gdG8gYWRkIGEgRHVyYXRpb24gb2JqZWN0IHRvIGEgRGF0ZVRpbWUsIHByb2R1Y2luZyBhbm90aGVyIERhdGVUaW1lLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gRHVyYXRpb246XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGEgRHVyYXRpb24sIHVzZSB7QGxpbmsgRHVyYXRpb24uZnJvbU1pbGxpc30sIHtAbGluayBEdXJhdGlvbi5mcm9tT2JqZWN0fSwgb3Ige0BsaW5rIER1cmF0aW9uLmZyb21JU099LlxuICogKiAqKlVuaXQgdmFsdWVzKiogU2VlIHRoZSB7QGxpbmsgRHVyYXRpb24jeWVhcnN9LCB7QGxpbmsgRHVyYXRpb24jbW9udGhzfSwge0BsaW5rIER1cmF0aW9uI3dlZWtzfSwge0BsaW5rIER1cmF0aW9uI2RheXN9LCB7QGxpbmsgRHVyYXRpb24jaG91cnN9LCB7QGxpbmsgRHVyYXRpb24jbWludXRlc30sIHtAbGluayBEdXJhdGlvbiNzZWNvbmRzfSwge0BsaW5rIER1cmF0aW9uI21pbGxpc2Vjb25kc30gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgIHtAbGluayBEdXJhdGlvbiNsb2NhbGV9IGFuZCB7QGxpbmsgRHVyYXRpb24jbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgbmV3IER1cmF0aW9ucyBvdXQgb2Ygb2xkIG9uZXMgdXNlIHtAbGluayBEdXJhdGlvbiNwbHVzfSwge0BsaW5rIER1cmF0aW9uI21pbnVzfSwge0BsaW5rIER1cmF0aW9uI25vcm1hbGl6ZX0sIHtAbGluayBEdXJhdGlvbiNzZXR9LCB7QGxpbmsgRHVyYXRpb24jcmVjb25maWd1cmV9LCB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30sIGFuZCB7QGxpbmsgRHVyYXRpb24jbmVnYXRlfS5cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBEdXJhdGlvbiBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBEdXJhdGlvbiNhc30sIHtAbGluayBEdXJhdGlvbiN0b0lTT30sIHtAbGluayBEdXJhdGlvbiN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgRHVyYXRpb24jdG9KU09OfVxuICpcbiAqIFRoZXJlJ3MgYXJlIG1vcmUgbWV0aG9kcyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgdmFsaWRpdHksIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVyYXRpb24ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY3VyYXRlID0gY29uZmlnLmNvbnZlcnNpb25BY2N1cmFjeSA9PT0gXCJsb25ndGVybVwiIHx8IGZhbHNlO1xuICAgIGxldCBtYXRyaXggPSBhY2N1cmF0ZSA/IGFjY3VyYXRlTWF0cml4IDogY2FzdWFsTWF0cml4O1xuXG4gICAgaWYgKGNvbmZpZy5tYXRyaXgpIHtcbiAgICAgIG1hdHJpeCA9IGNvbmZpZy5tYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBjb25maWcudmFsdWVzO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb252ZXJzaW9uQWNjdXJhY3kgPSBhY2N1cmF0ZSA/IFwibG9uZ3Rlcm1cIiA6IFwiY2FzdWFsXCI7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EdXJhdGlvbiA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIER1cmF0aW9uIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgb2YgbWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tTWlsbGlzKGNvdW50LCBvcHRzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IGNvdW50IH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiBJZiB0aGlzIG9iamVjdCBpcyBlbXB0eSB0aGVuIGEgemVybyBtaWxsaXNlY29uZHMgZHVyYXRpb24gaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoucXVhcnRlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3Vyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz1bXV0gLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY3VzdG9tIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYER1cmF0aW9uLmZyb21PYmplY3Q6IGFyZ3VtZW50IGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgZ290ICR7XG4gICAgICAgICAgb2JqID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygb2JqXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRHVyYXRpb24oe1xuICAgICAgdmFsdWVzOiBub3JtYWxpemVPYmplY3Qob2JqLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0cyksXG4gICAgICBjb252ZXJzaW9uQWNjdXJhY3k6IG9wdHMuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgICAgbWF0cml4OiBvcHRzLm1hdHJpeCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIER1cmF0aW9uTGlrZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBEdXJhdGlvbn0gZHVyYXRpb25MaWtlXG4gICAqIE9uZSBvZjpcbiAgICogLSBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogLSBudW1iZXIgcmVwcmVzZW50aW5nIG1pbGxpc2Vjb25kc1xuICAgKiAtIER1cmF0aW9uIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb25MaWtlKSB7XG4gICAgaWYgKGlzTnVtYmVyKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIGlmIChEdXJhdGlvbi5pc0R1cmF0aW9uKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBkdXJhdGlvbkxpa2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25MaWtlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBVbmtub3duIGR1cmF0aW9uIGFyZ3VtZW50ICR7ZHVyYXRpb25MaWtlfSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uTGlrZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDNZNk0xVzREVDEySDMwTTVTJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDMsIG1vbnRoczogNiwgd2Vla3M6IDEsIGRheXM6IDQsIGhvdXJzOiAxMiwgbWludXRlczogMzAsIHNlY29uZHM6IDUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQVDIzSCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyMyB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1A1WTNNJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDUsIG1vbnRoczogMyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09EdXJhdGlvbih0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSB0aW1lIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMToyMjozMy40NDQnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDIyLCBzZWNvbmRzOiAzMywgbWlsbGlzZWNvbmRzOiA0NDQgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnVDExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExMDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnVDExMDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPVGltZSh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT1RpbWVPbmx5KHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgZGF0ZXRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRHVyYXRpb25FcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICAgIHllYXI6IFwieWVhcnNcIixcbiAgICAgIHllYXJzOiBcInllYXJzXCIsXG4gICAgICBxdWFydGVyOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBxdWFydGVyczogXCJxdWFydGVyc1wiLFxuICAgICAgbW9udGg6IFwibW9udGhzXCIsXG4gICAgICBtb250aHM6IFwibW9udGhzXCIsXG4gICAgICB3ZWVrOiBcIndlZWtzXCIsXG4gICAgICB3ZWVrczogXCJ3ZWVrc1wiLFxuICAgICAgZGF5OiBcImRheXNcIixcbiAgICAgIGRheXM6IFwiZGF5c1wiLFxuICAgICAgaG91cjogXCJob3Vyc1wiLFxuICAgICAgaG91cnM6IFwiaG91cnNcIixcbiAgICAgIG1pbnV0ZTogXCJtaW51dGVzXCIsXG4gICAgICBtaW51dGVzOiBcIm1pbnV0ZXNcIixcbiAgICAgIHNlY29uZDogXCJzZWNvbmRzXCIsXG4gICAgICBzZWNvbmRzOiBcInNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgIH1bdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6IHVuaXRdO1xuXG4gICAgaWYgKCFub3JtYWxpemVkKSB0aHJvdyBuZXcgSW52YWxpZFVuaXRFcnJvcih1bml0KTtcblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhIER1cmF0aW9uLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEdXJhdGlvbihvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkR1cmF0aW9uKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgIHRoZSBsb2NhbGUgb2YgYSBEdXJhdGlvbiwgc3VjaCAnZW4tR0InXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIER1cmF0aW9uLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIER1cmF0aW9uXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy4gWW91IG1heSB1c2UgdGhlc2UgdG9rZW5zOlxuICAgKiAqIGBTYCBmb3IgbWlsbGlzZWNvbmRzXG4gICAqICogYHNgIGZvciBzZWNvbmRzXG4gICAqICogYG1gIGZvciBtaW51dGVzXG4gICAqICogYGhgIGZvciBob3Vyc1xuICAgKiAqIGBkYCBmb3IgZGF5c1xuICAgKiAqIGB3YCBmb3Igd2Vla3NcbiAgICogKiBgTWAgZm9yIG1vbnRoc1xuICAgKiAqIGB5YCBmb3IgeWVhcnNcbiAgICogTm90ZXM6XG4gICAqICogQWRkIHBhZGRpbmcgYnkgcmVwZWF0aW5nIHRoZSB0b2tlbiwgZS5nLiBcInl5XCIgcGFkcyB0aGUgeWVhcnMgdG8gdHdvIGRpZ2l0cywgXCJoaGhoXCIgcGFkcyB0aGUgaG91cnMgb3V0IHRvIGZvdXIgZGlnaXRzXG4gICAqICogVG9rZW5zIGNhbiBiZSBlc2NhcGVkIGJ5IHdyYXBwaW5nIHdpdGggc2luZ2xlIHF1b3Rlcy5cbiAgICogKiBUaGUgZHVyYXRpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdGhlIHNldCBvZiB1bml0cyBpbiB0aGUgZm9ybWF0IHN0cmluZyB1c2luZyB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30gYW5kIHRoZSBEdXJhdGlvbnMncyBjb252ZXJzaW9uIGFjY3VyYWN5IHNldHRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5mbG9vcj10cnVlXSAtIGZsb29yIG51bWVyaWNhbCB2YWx1ZXNcbiAgICogQHBhcmFtIHsnbmVnYXRpdmUnfCdhbGwnfCduZWdhdGl2ZUxhcmdlc3RPbmx5J30gW29wdHMuc2lnbk1vZGU9bmVnYXRpdmVdIC0gSG93IHRvIGhhbmRsZSBzaWduc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJkIHNcIiwgeyBzaWduTW9kZTogXCJhbGxcIiB9KSAvLz0+IFwiKzYgKzJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogLTYsIHNlY29uZHM6IC0yIH0pLnRvRm9ybWF0KFwiZCBzXCIsIHsgc2lnbk1vZGU6IFwiYWxsXCIgfSkgLy89PiBcIi02IC0yXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IC02LCBzZWNvbmRzOiAtMiB9KS50b0Zvcm1hdChcImQgc1wiLCB7IHNpZ25Nb2RlOiBcIm5lZ2F0aXZlTGFyZ2VzdE9ubHlcIiB9KSAvLz0+IFwiLTYgMlwiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgLy8gcmV2ZXJzZS1jb21wYXQgc2luY2UgMS4yOyB3ZSBhbHdheXMgcm91bmQgZG93biBub3csIG5ldmVyIHVwLCBhbmQgd2UgZG8gaXQgYnkgZGVmYXVsdFxuICAgIGNvbnN0IGZtdE9wdHMgPSB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgZmxvb3I6IG9wdHMucm91bmQgIT09IGZhbHNlICYmIG9wdHMuZmxvb3IgIT09IGZhbHNlLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLCBmbXRPcHRzKS5mb3JtYXREdXJhdGlvbkZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBEdXJhdGlvbiB3aXRoIGFsbCB1bml0cyBpbmNsdWRlZC5cbiAgICogVG8gbW9kaWZ5IGl0cyBiZWhhdmlvciwgdXNlIGBsaXN0U3R5bGVgIGFuZCBhbnkgSW50bC5OdW1iZXJGb3JtYXQgb3B0aW9uLCB0aG91Z2ggYHVuaXREaXNwbGF5YCBpcyBlc3BlY2lhbGx5IHJlbGV2YW50LlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvTnVtYmVyRm9ybWF0L051bWJlckZvcm1hdCNvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gRm9ybWF0dGluZyBvcHRpb25zLiBBY2NlcHRzIHRoZSBzYW1lIGtleXMgYXMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIHRoZSBuYXRpdmUgYEludGwuTnVtYmVyRm9ybWF0YCBjb25zdHJ1Y3RvciwgYXMgd2VsbCBhcyBgbGlzdFN0eWxlYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxpc3RTdHlsZT0nbmFycm93J10gLSBIb3cgdG8gZm9ybWF0IHRoZSBtZXJnZWQgbGlzdC4gQ29ycmVzcG9uZHMgdG8gdGhlIGBzdHlsZWAgcHJvcGVydHkgb2YgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIHRoZSBuYXRpdmUgYEludGwuTGlzdEZvcm1hdGAgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2hvd1plcm9zPXRydWVdIC0gU2hvdyBhbGwgdW5pdHMgcHJldmlvdXNseSB1c2VkIGJ5IHRoZSBkdXJhdGlvbiBldmVuIGlmIHRoZXkgYXJlIHplcm9cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEsIHdlZWtzOiAwLCBob3VyczogNSwgbWludXRlczogNiB9KVxuICAgKiBkdXIudG9IdW1hbigpIC8vPT4gJzEgbW9udGgsIDAgd2Vla3MsIDUgaG91cnMsIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyBsaXN0U3R5bGU6IFwibG9uZ1wiIH0pIC8vPT4gJzEgbW9udGgsIDAgd2Vla3MsIDUgaG91cnMsIGFuZCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgdW5pdERpc3BsYXk6IFwic2hvcnRcIiB9KSAvLz0+ICcxIG10aCwgMCB3a3MsIDUgaHIsIDYgbWluJ1xuICAgKiBkdXIudG9IdW1hbih7IHNob3daZXJvczogZmFsc2UgfSkgLy89PiAnMSBtb250aCwgNSBob3VycywgNiBtaW51dGVzJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvSHVtYW4ob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuXG4gICAgY29uc3Qgc2hvd1plcm9zID0gb3B0cy5zaG93WmVyb3MgIT09IGZhbHNlO1xuXG4gICAgY29uc3QgbCA9IG9yZGVyZWRVbml0c1xuICAgICAgLm1hcCgodW5pdCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlc1t1bml0XTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbCkgfHwgKHZhbCA9PT0gMCAmJiAhc2hvd1plcm9zKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgICAgIC5udW1iZXJGb3JtYXR0ZXIoeyBzdHlsZTogXCJ1bml0XCIsIHVuaXREaXNwbGF5OiBcImxvbmdcIiwgLi4ub3B0cywgdW5pdDogdW5pdC5zbGljZSgwLCAtMSkgfSlcbiAgICAgICAgICAuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigobikgPT4gbik7XG5cbiAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgIC5saXN0Rm9ybWF0dGVyKHsgdHlwZTogXCJjb25qdW5jdGlvblwiLCBzdHlsZTogb3B0cy5saXN0U3R5bGUgfHwgXCJuYXJyb3dcIiwgLi4ub3B0cyB9KVxuICAgICAgLmZvcm1hdChsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIER1cmF0aW9uJ3MgdmFsdWVzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7IC4uLnRoaXMudmFsdWVzIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMywgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQM1lUNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA0LCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1A0TVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDUgfSkudG9JU08oKSAvLz0+ICdQNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiA1IH0pLnRvSVNPKCkgLy89PiAnUFQ1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogNiB9KS50b0lTTygpIC8vPT4gJ1BUMC4wMDZTJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTygpIHtcbiAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGZvcm1hdHRlciwgYnV0IHRoaXMgaXMgYW4gZWFzaWVyIHdheSB0byBnZXQgdGhlIG1pbmltdW0gc3RyaW5nXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgbGV0IHMgPSBcIlBcIjtcbiAgICBpZiAodGhpcy55ZWFycyAhPT0gMCkgcyArPSB0aGlzLnllYXJzICsgXCJZXCI7XG4gICAgaWYgKHRoaXMubW9udGhzICE9PSAwIHx8IHRoaXMucXVhcnRlcnMgIT09IDApIHMgKz0gdGhpcy5tb250aHMgKyB0aGlzLnF1YXJ0ZXJzICogMyArIFwiTVwiO1xuICAgIGlmICh0aGlzLndlZWtzICE9PSAwKSBzICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICBpZiAodGhpcy5kYXlzICE9PSAwKSBzICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwIHx8IHRoaXMubWludXRlcyAhPT0gMCB8fCB0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICBzICs9IFwiVFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwKSBzICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICBpZiAodGhpcy5taW51dGVzICE9PSAwKSBzICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgIGlmICh0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICAvLyB0aGlzIHdpbGwgaGFuZGxlIFwiZmxvYXRpbmcgcG9pbnQgbWFkbmVzc1wiIGJ5IHJlbW92aW5nIGV4dHJhIGRlY2ltYWwgcGxhY2VzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODgwMDQvaXMtZmxvYXRpbmctcG9pbnQtbWF0aC1icm9rZW5cbiAgICAgIHMgKz0gcm91bmRUbyh0aGlzLnNlY29uZHMgKyB0aGlzLm1pbGxpc2Vjb25kcyAvIDEwMDAsIDMpICsgXCJTXCI7XG4gICAgaWYgKHMgPT09IFwiUFwiKSBzICs9IFwiVDBTXCI7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24sIGZvcm1hdHRlZCBhcyBhIHRpbWUgb2YgZGF5LlxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBkdXJhdGlvbiBpcyBpbnZhbGlkLCBuZWdhdGl2ZSwgb3IgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDI0IGhvdXJzLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKCkgLy89PiAnMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzTWlsbGlzZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzExMDAwMC4wMDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBtaWxsaXMgPSB0aGlzLnRvTWlsbGlzKCk7XG4gICAgaWYgKG1pbGxpcyA8IDAgfHwgbWlsbGlzID49IDg2NDAwMDAwKSByZXR1cm4gbnVsbDtcblxuICAgIG9wdHMgPSB7XG4gICAgICBzdXBwcmVzc01pbGxpc2Vjb25kczogZmFsc2UsXG4gICAgICBzdXBwcmVzc1NlY29uZHM6IGZhbHNlLFxuICAgICAgaW5jbHVkZVByZWZpeDogZmFsc2UsXG4gICAgICBmb3JtYXQ6IFwiZXh0ZW5kZWRcIixcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0OiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3QgZGF0ZVRpbWUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKG1pbGxpcywgeyB6b25lOiBcIlVUQ1wiIH0pO1xuICAgIHJldHVybiBkYXRlVGltZS50b0lTT1RpbWUob3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgRHVyYXRpb24geyB2YWx1ZXM6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBEdXJhdGlvbiB7IEludmFsaWQsIHJlYXNvbjogJHt0aGlzLmludmFsaWRSZWFzb259IH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcblxuICAgIHJldHVybiBkdXJhdGlvblRvTWlsbGlzKHRoaXMubWF0cml4LCB0aGlzLnZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIGxvbmdlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShkdXIudmFsdWVzLCBrKSB8fCBoYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlcywgaykpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZHVyLmdldChrKSArIHRoaXMuZ2V0KGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhpcyBEdXJhdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdW5pdC4gQXJpdHkgaXMgMSBvciAyOiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgYW5kLCBvcHRpb25hbGx5LCB0aGUgdW5pdCBuYW1lLiBNdXN0IHJldHVybiBhIG51bWJlci5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cyh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cygoeCwgdSkgPT4gdSA9PT0gXCJob3Vyc1wiID8geCAqIDIgOiB4KSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtYXBVbml0cyhmbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICByZXN1bHRba10gPSBhc051bWJlcihmbih0aGlzLnZhbHVlc1trXSwgaykpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ3llYXJzJykgLy89PiAyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdtb250aHMnKSAvLz0+IDBcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ2RheXMnKSAvLz0+IDNcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1tEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyB5ZWFyczogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgaG91cnM6IDgsIG1pbnV0ZXM6IDMwIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG1peGVkID0geyAuLi50aGlzLnZhbHVlcywgLi4ubm9ybWFsaXplT2JqZWN0KHZhbHVlcywgRHVyYXRpb24ubm9ybWFsaXplVW5pdCkgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG1peGVkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSBhbmQvb3IgbnVtYmVyaW5nU3lzdGVtLiAgUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBkdXIucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjb252ZXJzaW9uQWNjdXJhY3ksIG1hdHJpeCB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtIH0pO1xuICAgIGNvbnN0IG9wdHMgPSB7IGxvYywgbWF0cml4LCBjb252ZXJzaW9uQWNjdXJhY3kgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGR1cmF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlcycgb3IgJ2RheXMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ2RheXMnKSAvLz0+IDM2NVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdtb250aHMnKSAvLz0+IDEyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe2hvdXJzOiA2MH0pLmFzKCdkYXlzJykgLy89PiAyLjVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYXModW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnNoaWZ0VG8odW5pdCkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEFzc3VtaW5nIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBEdXJhdGlvbiBpcyBwb3NpdGl2ZSwgdGhpcyBtZWFuczpcbiAgICogLSBleGNlc3NpdmUgdmFsdWVzIGZvciBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmaXJzdCBhbmQgc2Vjb25kIGV4YW1wbGUpXG4gICAqIC0gbmVnYXRpdmUgbG93ZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBoaWdoZXIgb3JkZXIgdW5pdHMgKHRoZXJlIG11c3QgYmUgc3VjaCBhIGhpZ2hlciBvcmRlciB1bml0LCBvdGhlcndpc2VcbiAgICogICB0aGUgb3ZlcmFsbCB2YWx1ZSB3b3VsZCBiZSBuZWdhdGl2ZSwgc2VlIHRoaXJkIGV4YW1wbGUpXG4gICAqIC0gZnJhY3Rpb25hbCB2YWx1ZXMgZm9yIGhpZ2hlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGxvd2VyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZvdXJ0aCBleGFtcGxlKVxuICAgKlxuICAgKiBJZiB0aGUgb3ZlcmFsbCB2YWx1ZSBpcyBuZWdhdGl2ZSwgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGB0aGlzLm5lZ2F0ZSgpLm5vcm1hbGl6ZSgpLm5lZ2F0ZSgpYC5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxNSwgZGF5czogMjU1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDUwMDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgZGF5czogNTAwMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLjUsIGRheXM6IDAsIGhvdXJzOiAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbm9ybWFsaXplKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIG5vcm1hbGl6ZVZhbHVlcyh0aGlzLm1hdHJpeCwgdmFscyk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2NhbGUgdW5pdHMgdG8gaXRzIGxhcmdlc3QgcmVwcmVzZW50YXRpb25cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogOTAwMDAgfSkucmVzY2FsZSgpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDEsIHNlY29uZHM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZXNjYWxlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gcmVtb3ZlWmVyb2VzKHRoaXMubm9ybWFsaXplKCkuc2hpZnRUb0FsbCgpLnRvT2JqZWN0KCkpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoaXMgRHVyYXRpb24gaW50byBpdHMgcmVwcmVzZW50YXRpb24gaW4gYSBkaWZmZXJlbnQgc2V0IG9mIHVuaXRzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLnNoaWZ0VG8oJ21pbnV0ZXMnLCAnbWlsbGlzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogNjAsIG1pbGxpc2Vjb25kczogMzAwMDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG8oLi4udW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcCgodSkgPT4gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1KSk7XG5cbiAgICBjb25zdCBidWlsdCA9IHt9LFxuICAgICAgYWNjdW11bGF0ZWQgPSB7fSxcbiAgICAgIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbGV0IGxhc3RVbml0O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKHVuaXRzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICBsYXN0VW5pdCA9IGs7XG5cbiAgICAgICAgbGV0IG93biA9IDA7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgd2UgaGF2ZW4ndCBib2lsZWQgZG93biB5ZXQgc2hvdWxkIGdldCBib2lsZWQgdG8gdGhpcyB1bml0XG4gICAgICAgIGZvciAoY29uc3QgYWsgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgICAgICBvd24gKz0gdGhpcy5tYXRyaXhbYWtdW2tdICogYWNjdW11bGF0ZWRbYWtdO1xuICAgICAgICAgIGFjY3VtdWxhdGVkW2FrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwbHVzIGFueXRoaW5nIHRoYXQncyBhbHJlYWR5IGluIHRoaXMgdW5pdFxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgICBvd24gKz0gdmFsc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkga2VlcCB0aGUgaW50ZWdlciBwYXJ0IGZvciBub3cgaW4gdGhlIGhvcGVzIG9mIHB1dHRpbmcgYW55IGRlY2ltYWwgcGFydFxuICAgICAgICAvLyBpbnRvIGEgc21hbGxlciB1bml0IGxhdGVyXG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLnRydW5jKG93bik7XG4gICAgICAgIGJ1aWx0W2tdID0gaTtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSAob3duICogMTAwMCAtIGkgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBrZWVwIGl0IGluIHRoZSB3aW5ncyB0byBib2lsIGl0IGxhdGVyXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBsZWZ0b3ZlciBiZWNvbWVzIHRoZSBkZWNpbWFsIGZvciB0aGUgbGFzdCB1bml0XG4gICAgLy8gbGFzdFVuaXQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIHVuaXRzIGlzIG5vdCBlbXB0eVxuICAgIGZvciAoY29uc3Qga2V5IGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICBpZiAoYWNjdW11bGF0ZWRba2V5XSAhPT0gMCkge1xuICAgICAgICBidWlsdFtsYXN0VW5pdF0gKz1cbiAgICAgICAgICBrZXkgPT09IGxhc3RVbml0ID8gYWNjdW11bGF0ZWRba2V5XSA6IGFjY3VtdWxhdGVkW2tleV0gLyB0aGlzLm1hdHJpeFtsYXN0VW5pdF1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIGJ1aWx0KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IGJ1aWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaWZ0IHRoaXMgRHVyYXRpb24gdG8gYWxsIGF2YWlsYWJsZSB1bml0cy5cbiAgICogU2FtZSBhcyBzaGlmdFRvKFwieWVhcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUb0FsbCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnRUbyhcbiAgICAgIFwieWVhcnNcIixcbiAgICAgIFwibW9udGhzXCIsXG4gICAgICBcIndlZWtzXCIsXG4gICAgICBcImRheXNcIixcbiAgICAgIFwiaG91cnNcIixcbiAgICAgIFwibWludXRlc1wiLFxuICAgICAgXCJzZWNvbmRzXCIsXG4gICAgICBcIm1pbGxpc2Vjb25kc1wiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkubmVnYXRlKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IC0xLCBzZWNvbmRzOiAtMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmVnYXRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIG5lZ2F0ZWRba10gPSB0aGlzLnZhbHVlc1trXSA9PT0gMCA/IDAgOiAtdGhpcy52YWx1ZXNba107XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbmVnYXRlZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB1bml0cyB3aXRoIHZhbHVlcyBlcXVhbCB0byAwIGZyb20gdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiAwLCBob3VyczogMCwgbWludXRlczogMCB9KS5yZW1vdmVaZXJvcygpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAyIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZW1vdmVaZXJvcygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHJlbW92ZVplcm9lcyh0aGlzLnZhbHVlcyk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnllYXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMucXVhcnRlcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRocy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1vbnRocyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMud2Vla3MgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuZGF5cyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91cnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmhvdXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGVzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbnV0ZXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5zZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbGxpc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRHVyYXRpb24gaXMgaW52YWxpZC4gSW52YWxpZCBkdXJhdGlvbnMgYXJlIHJldHVybmVkIGJ5IGRpZmYgb3BlcmF0aW9uc1xuICAgKiBvbiBpbnZhbGlkIERhdGVUaW1lcyBvciBJbnRlcnZhbHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIER1cmF0aW9ucyBhcmUgZXF1YWwgaWZmIHRoZXkgaGF2ZSB0aGUgc2FtZSB1bml0cyBhbmQgdGhlIHNhbWUgdmFsdWVzIGZvciBlYWNoIHVuaXQuXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcSh2MSwgdjIpIHtcbiAgICAgIC8vIENvbnNpZGVyIDAgYW5kIHVuZGVmaW5lZCBhcyBlcXVhbFxuICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgfHwgdjEgPT09IDApIHJldHVybiB2MiA9PT0gdW5kZWZpbmVkIHx8IHYyID09PSAwO1xuICAgICAgcmV0dXJuIHYxID09PSB2MjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoIWVxKHRoaXMudmFsdWVzW3VdLCBvdGhlci52YWx1ZXNbdV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/duration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js":
/*!************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/errors.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingSpecificationError: () => (/* binding */ ConflictingSpecificationError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDateTimeError: () => (/* binding */ InvalidDateTimeError),\n/* harmony export */   InvalidDurationError: () => (/* binding */ InvalidDurationError),\n/* harmony export */   InvalidIntervalError: () => (/* binding */ InvalidIntervalError),\n/* harmony export */   InvalidUnitError: () => (/* binding */ InvalidUnitError),\n/* harmony export */   ZoneIsAbstractError: () => (/* binding */ ZoneIsAbstractError)\n/* harmony export */ });\n// these aren't really private, but nor are they really useful to document\n\n/**\n * @private\n */\nclass LuxonError extends Error {}\n\n/**\n * @private\n */\nclass InvalidDateTimeError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid DateTime: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidIntervalError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Interval: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidDurationError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Duration: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass ConflictingSpecificationError extends LuxonError {}\n\n/**\n * @private\n */\nclass InvalidUnitError extends LuxonError {\n  constructor(unit) {\n    super(`Invalid unit ${unit}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidArgumentError extends LuxonError {}\n\n/**\n * @private\n */\nclass ZoneIsAbstractError extends LuxonError {\n  constructor() {\n    super(\"Zone is an abstract class\");\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhlc2UgYXJlbid0IHJlYWxseSBwcml2YXRlLCBidXQgbm9yIGFyZSB0aGV5IHJlYWxseSB1c2VmdWwgdG8gZG9jdW1lbnRcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBMdXhvbkVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGVUaW1lRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRGF0ZVRpbWU6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnRlcnZhbEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIEludGVydmFsOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRHVyYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEdXJhdGlvbjogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRVbml0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IodW5pdCkge1xuICAgIHN1cGVyKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBab25lSXNBYnN0cmFjdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiWm9uZSBpcyBhbiBhYnN0cmFjdCBjbGFzc1wiKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/conversions.js":
/*!**********************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/conversions.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dayOfWeek: () => (/* binding */ dayOfWeek),\n/* harmony export */   gregorianToOrdinal: () => (/* binding */ gregorianToOrdinal),\n/* harmony export */   gregorianToWeek: () => (/* binding */ gregorianToWeek),\n/* harmony export */   hasInvalidGregorianData: () => (/* binding */ hasInvalidGregorianData),\n/* harmony export */   hasInvalidOrdinalData: () => (/* binding */ hasInvalidOrdinalData),\n/* harmony export */   hasInvalidTimeData: () => (/* binding */ hasInvalidTimeData),\n/* harmony export */   hasInvalidWeekData: () => (/* binding */ hasInvalidWeekData),\n/* harmony export */   isoWeekdayToLocal: () => (/* binding */ isoWeekdayToLocal),\n/* harmony export */   ordinalToGregorian: () => (/* binding */ ordinalToGregorian),\n/* harmony export */   usesLocalWeekValues: () => (/* binding */ usesLocalWeekValues),\n/* harmony export */   weekToGregorian: () => (/* binding */ weekToGregorian)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _invalid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invalid.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\");\n\n\n\n\nconst nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n\nfunction unitOutOfRange(unit, value) {\n  return new _invalid_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n    \"unit out of range\",\n    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`\n  );\n}\n\nfunction dayOfWeek(year, month, day) {\n  const d = new Date(Date.UTC(year, month - 1, day));\n\n  if (year < 100 && year >= 0) {\n    d.setUTCFullYear(d.getUTCFullYear() - 1900);\n  }\n\n  const js = d.getUTCDay();\n\n  return js === 0 ? 7 : js;\n}\n\nfunction computeOrdinal(year, month, day) {\n  return day + ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder)[month - 1];\n}\n\nfunction uncomputeOrdinal(year, ordinal) {\n  const table = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder,\n    month0 = table.findIndex((i) => i < ordinal),\n    day = ordinal - table[month0];\n  return { month: month0 + 1, day };\n}\n\nfunction isoWeekdayToLocal(isoWeekday, startOfWeek) {\n  return ((isoWeekday - startOfWeek + 7) % 7) + 1;\n}\n\n/**\n * @private\n */\n\nfunction gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { year, month, day } = gregObj,\n    ordinal = computeOrdinal(year, month, day),\n    weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);\n\n  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7),\n    weekYear;\n\n  if (weekNumber < 1) {\n    weekYear = year - 1;\n    weekNumber = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(weekYear, minDaysInFirstWeek, startOfWeek);\n  } else if (weekNumber > (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(year, minDaysInFirstWeek, startOfWeek)) {\n    weekYear = year + 1;\n    weekNumber = 1;\n  } else {\n    weekYear = year;\n  }\n\n  return { weekYear, weekNumber, weekday, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregObj) };\n}\n\nfunction weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { weekYear, weekNumber, weekday } = weekData,\n    weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek),\n    yearInDays = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n\n  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek,\n    year;\n\n  if (ordinal < 1) {\n    year = weekYear - 1;\n    ordinal += (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(year);\n  } else if (ordinal > yearInDays) {\n    year = weekYear + 1;\n    ordinal -= (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n  } else {\n    year = weekYear;\n  }\n\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(weekData) };\n}\n\nfunction gregorianToOrdinal(gregData) {\n  const { year, month, day } = gregData;\n  const ordinal = computeOrdinal(year, month, day);\n  return { year, ordinal, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregData) };\n}\n\nfunction ordinalToGregorian(ordinalData) {\n  const { year, ordinal } = ordinalData;\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(ordinalData) };\n}\n\n/**\n * Check if local week units like localWeekday are used in obj.\n * If so, validates that they are not mixed with ISO week units and then copies them to the normal week unit properties.\n * Modifies obj in-place!\n * @param obj the object values\n */\nfunction usesLocalWeekValues(obj, loc) {\n  const hasLocaleWeekData =\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear);\n  if (hasLocaleWeekData) {\n    const hasIsoWeekData =\n      !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekday) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekNumber) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekYear);\n\n    if (hasIsoWeekData) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingSpecificationError(\n        \"Cannot mix locale-based week fields with ISO-based week fields\"\n      );\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday)) obj.weekday = obj.localWeekday;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;\n    delete obj.localWeekday;\n    delete obj.localWeekNumber;\n    delete obj.localWeekYear;\n    return {\n      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),\n      startOfWeek: loc.getStartOfWeek(),\n    };\n  } else {\n    return { minDaysInFirstWeek: 4, startOfWeek: 1 };\n  }\n}\n\nfunction hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.weekYear),\n    validWeek = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(\n      obj.weekNumber,\n      1,\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(obj.weekYear, minDaysInFirstWeek, startOfWeek)\n    ),\n    validWeekday = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.weekday, 1, 7);\n\n  if (!validYear) {\n    return unitOutOfRange(\"weekYear\", obj.weekYear);\n  } else if (!validWeek) {\n    return unitOutOfRange(\"week\", obj.weekNumber);\n  } else if (!validWeekday) {\n    return unitOutOfRange(\"weekday\", obj.weekday);\n  } else return false;\n}\n\nfunction hasInvalidOrdinalData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validOrdinal = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.ordinal, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(obj.year));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validOrdinal) {\n    return unitOutOfRange(\"ordinal\", obj.ordinal);\n  } else return false;\n}\n\nfunction hasInvalidGregorianData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validMonth = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.month, 1, 12),\n    validDay = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.day, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInMonth)(obj.year, obj.month));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validMonth) {\n    return unitOutOfRange(\"month\", obj.month);\n  } else if (!validDay) {\n    return unitOutOfRange(\"day\", obj.day);\n  } else return false;\n}\n\nfunction hasInvalidTimeData(obj) {\n  const { hour, minute, second, millisecond } = obj;\n  const validHour =\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(hour, 0, 23) ||\n      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),\n    validMinute = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(minute, 0, 59),\n    validSecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(second, 0, 59),\n    validMillisecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(millisecond, 0, 999);\n\n  if (!validHour) {\n    return unitOutOfRange(\"hour\", hour);\n  } else if (!validMinute) {\n    return unitOutOfRange(\"minute\", minute);\n  } else if (!validSecond) {\n    return unitOutOfRange(\"second\", second);\n  } else if (!validMillisecond) {\n    return unitOutOfRange(\"millisecond\", millisecond);\n  } else return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9jb252ZXJzaW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQVNtQjtBQUNnQjtBQUMwQjs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbURBQU87QUFDcEI7QUFDQSxxQkFBcUIsT0FBTyxXQUFXLGFBQWEsU0FBUyxLQUFLO0FBQ2xFO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixvREFBVTtBQUMxQjs7QUFFQTtBQUNBLGdCQUFnQixvREFBVTtBQUMxQjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix5REFBZTtBQUNoQyxJQUFJLHNCQUFzQix5REFBZTtBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsV0FBVyxrQ0FBa0Msb0RBQVU7QUFDdkQ7O0FBRU87QUFDUCxVQUFVLGdDQUFnQztBQUMxQztBQUNBLGlCQUFpQixvREFBVTs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvREFBVTtBQUN6QixJQUFJO0FBQ0o7QUFDQSxlQUFlLG9EQUFVO0FBQ3pCLElBQUk7QUFDSjtBQUNBOztBQUVBLFVBQVUsYUFBYTtBQUN2QixXQUFXLHFCQUFxQixvREFBVTtBQUMxQzs7QUFFTztBQUNQLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0EsV0FBVyxrQkFBa0Isb0RBQVU7QUFDdkM7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQixVQUFVLGFBQWE7QUFDdkIsV0FBVyxxQkFBcUIsb0RBQVU7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLEtBQUsscURBQVc7QUFDaEIsS0FBSyxxREFBVztBQUNoQixLQUFLLHFEQUFXO0FBQ2hCO0FBQ0E7QUFDQSxPQUFPLHFEQUFXLGtCQUFrQixxREFBVyxxQkFBcUIscURBQVc7O0FBRS9FO0FBQ0EsZ0JBQWdCLHFFQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFXO0FBQ3BCLFNBQVMscURBQVc7QUFDcEIsU0FBUyxxREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFTztBQUNQLG9CQUFvQixtREFBUztBQUM3QixnQkFBZ0Isd0RBQWM7QUFDOUI7QUFDQTtBQUNBLE1BQU0seURBQWU7QUFDckI7QUFDQSxtQkFBbUIsd0RBQWM7O0FBRWpDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRU87QUFDUCxvQkFBb0IsbURBQVM7QUFDN0IsbUJBQW1CLHdEQUFjLGlCQUFpQixvREFBVTs7QUFFNUQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFTztBQUNQLG9CQUFvQixtREFBUztBQUM3QixpQkFBaUIsd0RBQWM7QUFDL0IsZUFBZSx3REFBYyxhQUFhLHFEQUFXOztBQUVyRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVPO0FBQ1AsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQSxNQUFNLHdEQUFjO0FBQ3BCO0FBQ0Esa0JBQWtCLHdEQUFjO0FBQ2hDLGtCQUFrQix3REFBYztBQUNoQyx1QkFBdUIsd0RBQWM7O0FBRXJDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaW50ZWdlckJldHdlZW4sXG4gIGlzTGVhcFllYXIsXG4gIHRpbWVPYmplY3QsXG4gIGRheXNJblllYXIsXG4gIGRheXNJbk1vbnRoLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIGlzSW50ZWdlcixcbiAgaXNVbmRlZmluZWQsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ludmFsaWQuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgbGVhcExhZGRlciA9IFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNV07XG5cbmZ1bmN0aW9uIHVuaXRPdXRPZlJhbmdlKHVuaXQsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcbiAgICBcInVuaXQgb3V0IG9mIHJhbmdlXCIsXG4gICAgYHlvdSBzcGVjaWZpZWQgJHt2YWx1ZX0gKG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9KSBhcyBhICR7dW5pdH0sIHdoaWNoIGlzIGludmFsaWRgXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICBjb25zdCBkID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXkpKTtcblxuICBpZiAoeWVhciA8IDEwMCAmJiB5ZWFyID49IDApIHtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG5cbiAgY29uc3QganMgPSBkLmdldFVUQ0RheSgpO1xuXG4gIHJldHVybiBqcyA9PT0gMCA/IDcgOiBqcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSkge1xuICByZXR1cm4gZGF5ICsgKGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcilbbW9udGggLSAxXTtcbn1cblxuZnVuY3Rpb24gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKSB7XG4gIGNvbnN0IHRhYmxlID0gaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyLFxuICAgIG1vbnRoMCA9IHRhYmxlLmZpbmRJbmRleCgoaSkgPT4gaSA8IG9yZGluYWwpLFxuICAgIGRheSA9IG9yZGluYWwgLSB0YWJsZVttb250aDBdO1xuICByZXR1cm4geyBtb250aDogbW9udGgwICsgMSwgZGF5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc29XZWVrZGF5VG9Mb2NhbChpc29XZWVrZGF5LCBzdGFydE9mV2Vlaykge1xuICByZXR1cm4gKChpc29XZWVrZGF5IC0gc3RhcnRPZldlZWsgKyA3KSAlIDcpICsgMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub1dlZWsoZ3JlZ09iaiwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ09iaixcbiAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgd2Vla2RheSA9IGlzb1dlZWtkYXlUb0xvY2FsKGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSwgc3RhcnRPZldlZWspO1xuXG4gIGxldCB3ZWVrTnVtYmVyID0gTWF0aC5mbG9vcigob3JkaW5hbCAtIHdlZWtkYXkgKyAxNCAtIG1pbkRheXNJbkZpcnN0V2VlaykgLyA3KSxcbiAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaykpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5LCAuLi50aW1lT2JqZWN0KGdyZWdPYmopIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrVG9HcmVnb3JpYW4od2Vla0RhdGEsIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5IH0gPSB3ZWVrRGF0YSxcbiAgICB3ZWVrZGF5T2ZKYW40ID0gaXNvV2Vla2RheVRvTG9jYWwoZGF5T2ZXZWVrKHdlZWtZZWFyLCAxLCBtaW5EYXlzSW5GaXJzdFdlZWspLCBzdGFydE9mV2VlayksXG4gICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuXG4gIGxldCBvcmRpbmFsID0gd2Vla051bWJlciAqIDcgKyB3ZWVrZGF5IC0gd2Vla2RheU9mSmFuNCAtIDcgKyBtaW5EYXlzSW5GaXJzdFdlZWssXG4gICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qod2Vla0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub09yZGluYWwoZ3JlZ0RhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnRGF0YTtcbiAgY29uc3Qgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpO1xuICByZXR1cm4geyB5ZWFyLCBvcmRpbmFsLCAuLi50aW1lT2JqZWN0KGdyZWdEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgb3JkaW5hbCB9ID0gb3JkaW5hbERhdGE7XG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdChvcmRpbmFsRGF0YSkgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsb2NhbCB3ZWVrIHVuaXRzIGxpa2UgbG9jYWxXZWVrZGF5IGFyZSB1c2VkIGluIG9iai5cbiAqIElmIHNvLCB2YWxpZGF0ZXMgdGhhdCB0aGV5IGFyZSBub3QgbWl4ZWQgd2l0aCBJU08gd2VlayB1bml0cyBhbmQgdGhlbiBjb3BpZXMgdGhlbSB0byB0aGUgbm9ybWFsIHdlZWsgdW5pdCBwcm9wZXJ0aWVzLlxuICogTW9kaWZpZXMgb2JqIGluLXBsYWNlIVxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlc0xvY2FsV2Vla1ZhbHVlcyhvYmosIGxvYykge1xuICBjb25zdCBoYXNMb2NhbGVXZWVrRGF0YSA9XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtkYXkpIHx8XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtOdW1iZXIpIHx8XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtZZWFyKTtcbiAgaWYgKGhhc0xvY2FsZVdlZWtEYXRhKSB7XG4gICAgY29uc3QgaGFzSXNvV2Vla0RhdGEgPVxuICAgICAgIWlzVW5kZWZpbmVkKG9iai53ZWVrZGF5KSB8fCAhaXNVbmRlZmluZWQob2JqLndlZWtOdW1iZXIpIHx8ICFpc1VuZGVmaW5lZChvYmoud2Vla1llYXIpO1xuXG4gICAgaWYgKGhhc0lzb1dlZWtEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IG1peCBsb2NhbGUtYmFzZWQgd2VlayBmaWVsZHMgd2l0aCBJU08tYmFzZWQgd2VlayBmaWVsZHNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrZGF5KSkgb2JqLndlZWtkYXkgPSBvYmoubG9jYWxXZWVrZGF5O1xuICAgIGlmICghaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla051bWJlcikpIG9iai53ZWVrTnVtYmVyID0gb2JqLmxvY2FsV2Vla051bWJlcjtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtZZWFyKSkgb2JqLndlZWtZZWFyID0gb2JqLmxvY2FsV2Vla1llYXI7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtkYXk7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtOdW1iZXI7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtZZWFyO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5EYXlzSW5GaXJzdFdlZWs6IGxvYy5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSxcbiAgICAgIHN0YXJ0T2ZXZWVrOiBsb2MuZ2V0U3RhcnRPZldlZWsoKSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IG1pbkRheXNJbkZpcnN0V2VlazogNCwgc3RhcnRPZldlZWs6IDEgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaiwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKFxuICAgICAgb2JqLndlZWtOdW1iZXIsXG4gICAgICAxLFxuICAgICAgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICApLFxuICAgIHZhbGlkV2Vla2RheSA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrZGF5LCAxLCA3KTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtZZWFyXCIsIG9iai53ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vlaykge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtcIiwgb2JqLndlZWtOdW1iZXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWtkYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrZGF5XCIsIG9iai53ZWVrZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRPcmRpbmFsRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE9yZGluYWwgPSBpbnRlZ2VyQmV0d2VlbihvYmoub3JkaW5hbCwgMSwgZGF5c0luWWVhcihvYmoueWVhcikpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkT3JkaW5hbCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm9yZGluYWxcIiwgb2JqLm9yZGluYWwpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRNb250aCA9IGludGVnZXJCZXR3ZWVuKG9iai5tb250aCwgMSwgMTIpLFxuICAgIHZhbGlkRGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLmRheSwgMSwgZGF5c0luTW9udGgob2JqLnllYXIsIG9iai5tb250aCkpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTW9udGgpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtb250aFwiLCBvYmoubW9udGgpO1xuICB9IGVsc2UgaWYgKCF2YWxpZERheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImRheVwiLCBvYmouZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRUaW1lRGF0YShvYmopIHtcbiAgY29uc3QgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSA9IG9iajtcbiAgY29uc3QgdmFsaWRIb3VyID1cbiAgICAgIGludGVnZXJCZXR3ZWVuKGhvdXIsIDAsIDIzKSB8fFxuICAgICAgKGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDApLFxuICAgIHZhbGlkTWludXRlID0gaW50ZWdlckJldHdlZW4obWludXRlLCAwLCA1OSksXG4gICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICB2YWxpZE1pbGxpc2Vjb25kID0gaW50ZWdlckJldHdlZW4obWlsbGlzZWNvbmQsIDAsIDk5OSk7XG5cbiAgaWYgKCF2YWxpZEhvdXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJob3VyXCIsIGhvdXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbnV0ZSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbnV0ZVwiLCBtaW51dGUpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInNlY29uZFwiLCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbGxpc2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWlsbGlzZWNvbmRcIiwgbWlsbGlzZWNvbmQpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/conversions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/diff.js":
/*!***************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/diff.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../duration.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/duration.js\");\n\n\nfunction dayDiff(earlier, later) {\n  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf(\"day\").valueOf(),\n    ms = utcDayStart(later) - utcDayStart(earlier);\n  return Math.floor(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(ms).as(\"days\"));\n}\n\nfunction highOrderDiffs(cursor, later, units) {\n  const differs = [\n    [\"years\", (a, b) => b.year - a.year],\n    [\"quarters\", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],\n    [\"months\", (a, b) => b.month - a.month + (b.year - a.year) * 12],\n    [\n      \"weeks\",\n      (a, b) => {\n        const days = dayDiff(a, b);\n        return (days - (days % 7)) / 7;\n      },\n    ],\n    [\"days\", dayDiff],\n  ];\n\n  const results = {};\n  const earlier = cursor;\n  let lowestOrder, highWater;\n\n  /* This loop tries to diff using larger units first.\n     If we overshoot, we backtrack and try the next smaller unit.\n     \"cursor\" starts out at the earlier timestamp and moves closer and closer to \"later\"\n     as we use smaller and smaller units.\n     highWater keeps track of where we would be if we added one more of the smallest unit,\n     this is used later to potentially convert any difference smaller than the smallest higher order unit\n     into a fraction of that smallest higher order unit\n  */\n  for (const [unit, differ] of differs) {\n    if (units.indexOf(unit) >= 0) {\n      lowestOrder = unit;\n\n      results[unit] = differ(cursor, later);\n      highWater = earlier.plus(results);\n\n      if (highWater > later) {\n        // we overshot the end point, backtrack cursor by 1\n        results[unit]--;\n        cursor = earlier.plus(results);\n\n        // if we are still overshooting now, we need to backtrack again\n        // this happens in certain situations when diffing times in different zones,\n        // because this calculation ignores time zones\n        if (cursor > later) {\n          // keep the \"overshot by 1\" around as highWater\n          highWater = cursor;\n          // backtrack cursor by 1\n          results[unit]--;\n          cursor = earlier.plus(results);\n        }\n      } else {\n        cursor = highWater;\n      }\n    }\n  }\n\n  return [cursor, results, highWater, lowestOrder];\n}\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(earlier, later, units, opts) {\n  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);\n\n  const remainingMillis = later - cursor;\n\n  const lowerOrderUnits = units.filter(\n    (u) => [\"hours\", \"minutes\", \"seconds\", \"milliseconds\"].indexOf(u) >= 0\n  );\n\n  if (lowerOrderUnits.length === 0) {\n    if (highWater < later) {\n      highWater = cursor.plus({ [lowestOrder]: 1 });\n    }\n\n    if (highWater !== cursor) {\n      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);\n    }\n  }\n\n  const duration = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject(results, opts);\n\n  if (lowerOrderUnits.length > 0) {\n    return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(remainingMillis, opts)\n      .shiftTo(...lowerOrderUnits)\n      .plus(duration);\n  } else {\n    return duration;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDOztBQUV0QztBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQSxvQkFBb0Isb0RBQVE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBVTtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9EQUFROztBQUUzQjtBQUNBLFdBQVcsb0RBQVE7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4uL2R1cmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIGRheURpZmYoZWFybGllciwgbGF0ZXIpIHtcbiAgY29uc3QgdXRjRGF5U3RhcnQgPSAoZHQpID0+IGR0LnRvVVRDKDAsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KS5zdGFydE9mKFwiZGF5XCIpLnZhbHVlT2YoKSxcbiAgICBtcyA9IHV0Y0RheVN0YXJ0KGxhdGVyKSAtIHV0Y0RheVN0YXJ0KGVhcmxpZXIpO1xuICByZXR1cm4gTWF0aC5mbG9vcihEdXJhdGlvbi5mcm9tTWlsbGlzKG1zKS5hcyhcImRheXNcIikpO1xufVxuXG5mdW5jdGlvbiBoaWdoT3JkZXJEaWZmcyhjdXJzb3IsIGxhdGVyLCB1bml0cykge1xuICBjb25zdCBkaWZmZXJzID0gW1xuICAgIFtcInllYXJzXCIsIChhLCBiKSA9PiBiLnllYXIgLSBhLnllYXJdLFxuICAgIFtcInF1YXJ0ZXJzXCIsIChhLCBiKSA9PiBiLnF1YXJ0ZXIgLSBhLnF1YXJ0ZXIgKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDRdLFxuICAgIFtcIm1vbnRoc1wiLCAoYSwgYikgPT4gYi5tb250aCAtIGEubW9udGggKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDEyXSxcbiAgICBbXG4gICAgICBcIndlZWtzXCIsXG4gICAgICAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkYXlzID0gZGF5RGlmZihhLCBiKTtcbiAgICAgICAgcmV0dXJuIChkYXlzIC0gKGRheXMgJSA3KSkgLyA3O1xuICAgICAgfSxcbiAgICBdLFxuICAgIFtcImRheXNcIiwgZGF5RGlmZl0sXG4gIF07XG5cbiAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICBjb25zdCBlYXJsaWVyID0gY3Vyc29yO1xuICBsZXQgbG93ZXN0T3JkZXIsIGhpZ2hXYXRlcjtcblxuICAvKiBUaGlzIGxvb3AgdHJpZXMgdG8gZGlmZiB1c2luZyBsYXJnZXIgdW5pdHMgZmlyc3QuXG4gICAgIElmIHdlIG92ZXJzaG9vdCwgd2UgYmFja3RyYWNrIGFuZCB0cnkgdGhlIG5leHQgc21hbGxlciB1bml0LlxuICAgICBcImN1cnNvclwiIHN0YXJ0cyBvdXQgYXQgdGhlIGVhcmxpZXIgdGltZXN0YW1wIGFuZCBtb3ZlcyBjbG9zZXIgYW5kIGNsb3NlciB0byBcImxhdGVyXCJcbiAgICAgYXMgd2UgdXNlIHNtYWxsZXIgYW5kIHNtYWxsZXIgdW5pdHMuXG4gICAgIGhpZ2hXYXRlciBrZWVwcyB0cmFjayBvZiB3aGVyZSB3ZSB3b3VsZCBiZSBpZiB3ZSBhZGRlZCBvbmUgbW9yZSBvZiB0aGUgc21hbGxlc3QgdW5pdCxcbiAgICAgdGhpcyBpcyB1c2VkIGxhdGVyIHRvIHBvdGVudGlhbGx5IGNvbnZlcnQgYW55IGRpZmZlcmVuY2Ugc21hbGxlciB0aGFuIHRoZSBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICBpbnRvIGEgZnJhY3Rpb24gb2YgdGhhdCBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAqL1xuICBmb3IgKGNvbnN0IFt1bml0LCBkaWZmZXJdIG9mIGRpZmZlcnMpIHtcbiAgICBpZiAodW5pdHMuaW5kZXhPZih1bml0KSA+PSAwKSB7XG4gICAgICBsb3dlc3RPcmRlciA9IHVuaXQ7XG5cbiAgICAgIHJlc3VsdHNbdW5pdF0gPSBkaWZmZXIoY3Vyc29yLCBsYXRlcik7XG4gICAgICBoaWdoV2F0ZXIgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICAvLyB3ZSBvdmVyc2hvdCB0aGUgZW5kIHBvaW50LCBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIG92ZXJzaG9vdGluZyBub3csIHdlIG5lZWQgdG8gYmFja3RyYWNrIGFnYWluXG4gICAgICAgIC8vIHRoaXMgaGFwcGVucyBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgd2hlbiBkaWZmaW5nIHRpbWVzIGluIGRpZmZlcmVudCB6b25lcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGNhbGN1bGF0aW9uIGlnbm9yZXMgdGltZSB6b25lc1xuICAgICAgICBpZiAoY3Vyc29yID4gbGF0ZXIpIHtcbiAgICAgICAgICAvLyBrZWVwIHRoZSBcIm92ZXJzaG90IGJ5IDFcIiBhcm91bmQgYXMgaGlnaFdhdGVyXG4gICAgICAgICAgaGlnaFdhdGVyID0gY3Vyc29yO1xuICAgICAgICAgIC8vIGJhY2t0cmFjayBjdXJzb3IgYnkgMVxuICAgICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvciA9IGhpZ2hXYXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlYXJsaWVyLCBsYXRlciwgdW5pdHMsIG9wdHMpIHtcbiAgbGV0IFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdID0gaGlnaE9yZGVyRGlmZnMoZWFybGllciwgbGF0ZXIsIHVuaXRzKTtcblxuICBjb25zdCByZW1haW5pbmdNaWxsaXMgPSBsYXRlciAtIGN1cnNvcjtcblxuICBjb25zdCBsb3dlck9yZGVyVW5pdHMgPSB1bml0cy5maWx0ZXIoXG4gICAgKHUpID0+IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIl0uaW5kZXhPZih1KSA+PSAwXG4gICk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaGlnaFdhdGVyIDwgbGF0ZXIpIHtcbiAgICAgIGhpZ2hXYXRlciA9IGN1cnNvci5wbHVzKHsgW2xvd2VzdE9yZGVyXTogMSB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGlnaFdhdGVyICE9PSBjdXJzb3IpIHtcbiAgICAgIHJlc3VsdHNbbG93ZXN0T3JkZXJdID0gKHJlc3VsdHNbbG93ZXN0T3JkZXJdIHx8IDApICsgcmVtYWluaW5nTWlsbGlzIC8gKGhpZ2hXYXRlciAtIGN1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHJlc3VsdHMsIG9wdHMpO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKHJlbWFpbmluZ01pbGxpcywgb3B0cylcbiAgICAgIC5zaGlmdFRvKC4uLmxvd2VyT3JkZXJVbml0cylcbiAgICAgIC5wbHVzKGR1cmF0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/diff.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/digits.js":
/*!*****************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/digits.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   digitRegex: () => (/* binding */ digitRegex),\n/* harmony export */   parseDigits: () => (/* binding */ parseDigits),\n/* harmony export */   resetDigitRegexCache: () => (/* binding */ resetDigitRegexCache)\n/* harmony export */ });\nconst numberingSystems = {\n  arab: \"[\\u0660-\\u0669]\",\n  arabext: \"[\\u06F0-\\u06F9]\",\n  bali: \"[\\u1B50-\\u1B59]\",\n  beng: \"[\\u09E6-\\u09EF]\",\n  deva: \"[\\u0966-\\u096F]\",\n  fullwide: \"[\\uFF10-\\uFF19]\",\n  gujr: \"[\\u0AE6-\\u0AEF]\",\n  hanidec: \"[|||||||||]\",\n  khmr: \"[\\u17E0-\\u17E9]\",\n  knda: \"[\\u0CE6-\\u0CEF]\",\n  laoo: \"[\\u0ED0-\\u0ED9]\",\n  limb: \"[\\u1946-\\u194F]\",\n  mlym: \"[\\u0D66-\\u0D6F]\",\n  mong: \"[\\u1810-\\u1819]\",\n  mymr: \"[\\u1040-\\u1049]\",\n  orya: \"[\\u0B66-\\u0B6F]\",\n  tamldec: \"[\\u0BE6-\\u0BEF]\",\n  telu: \"[\\u0C66-\\u0C6F]\",\n  thai: \"[\\u0E50-\\u0E59]\",\n  tibt: \"[\\u0F20-\\u0F29]\",\n  latn: \"\\\\d\",\n};\n\nconst numberingSystemsUTF16 = {\n  arab: [1632, 1641],\n  arabext: [1776, 1785],\n  bali: [6992, 7001],\n  beng: [2534, 2543],\n  deva: [2406, 2415],\n  fullwide: [65296, 65303],\n  gujr: [2790, 2799],\n  khmr: [6112, 6121],\n  knda: [3302, 3311],\n  laoo: [3792, 3801],\n  limb: [6470, 6479],\n  mlym: [3430, 3439],\n  mong: [6160, 6169],\n  mymr: [4160, 4169],\n  orya: [2918, 2927],\n  tamldec: [3046, 3055],\n  telu: [3174, 3183],\n  thai: [3664, 3673],\n  tibt: [3872, 3881],\n};\n\nconst hanidecChars = numberingSystems.hanidec.replace(/[\\[|\\]]/g, \"\").split(\"\");\n\nfunction parseDigits(str) {\n  let value = parseInt(str, 10);\n  if (isNaN(value)) {\n    value = \"\";\n    for (let i = 0; i < str.length; i++) {\n      const code = str.charCodeAt(i);\n\n      if (str[i].search(numberingSystems.hanidec) !== -1) {\n        value += hanidecChars.indexOf(str[i]);\n      } else {\n        for (const key in numberingSystemsUTF16) {\n          const [min, max] = numberingSystemsUTF16[key];\n          if (code >= min && code <= max) {\n            value += code - min;\n          }\n        }\n      }\n    }\n    return parseInt(value, 10);\n  } else {\n    return value;\n  }\n}\n\n// cache of {numberingSystem: {append: regex}}\nconst digitRegexCache = new Map();\nfunction resetDigitRegexCache() {\n  digitRegexCache.clear();\n}\n\nfunction digitRegex({ numberingSystem }, append = \"\") {\n  const ns = numberingSystem || \"latn\";\n\n  let appendCache = digitRegexCache.get(ns);\n  if (appendCache === undefined) {\n    appendCache = new Map();\n    digitRegexCache.set(ns, appendCache);\n  }\n  let regex = appendCache.get(append);\n  if (regex === undefined) {\n    regex = new RegExp(`${numberingSystems[ns]}${append}`);\n    appendCache.set(append, regex);\n  }\n\n  return regex;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWdpdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPO0FBQ1A7QUFDQTs7QUFFTyxzQkFBc0IsaUJBQWlCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQixFQUFFLE9BQU87QUFDeEQ7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBudW1iZXJpbmdTeXN0ZW1zID0ge1xuICBhcmFiOiBcIltcXHUwNjYwLVxcdTA2NjldXCIsXG4gIGFyYWJleHQ6IFwiW1xcdTA2RjAtXFx1MDZGOV1cIixcbiAgYmFsaTogXCJbXFx1MUI1MC1cXHUxQjU5XVwiLFxuICBiZW5nOiBcIltcXHUwOUU2LVxcdTA5RUZdXCIsXG4gIGRldmE6IFwiW1xcdTA5NjYtXFx1MDk2Rl1cIixcbiAgZnVsbHdpZGU6IFwiW1xcdUZGMTAtXFx1RkYxOV1cIixcbiAgZ3VqcjogXCJbXFx1MEFFNi1cXHUwQUVGXVwiLFxuICBoYW5pZGVjOiBcIlvjgId85LiAfOS6jHzkuIl85ZubfOS6lHzlha185LiDfOWFq3zkuZ1dXCIsXG4gIGtobXI6IFwiW1xcdTE3RTAtXFx1MTdFOV1cIixcbiAga25kYTogXCJbXFx1MENFNi1cXHUwQ0VGXVwiLFxuICBsYW9vOiBcIltcXHUwRUQwLVxcdTBFRDldXCIsXG4gIGxpbWI6IFwiW1xcdTE5NDYtXFx1MTk0Rl1cIixcbiAgbWx5bTogXCJbXFx1MEQ2Ni1cXHUwRDZGXVwiLFxuICBtb25nOiBcIltcXHUxODEwLVxcdTE4MTldXCIsXG4gIG15bXI6IFwiW1xcdTEwNDAtXFx1MTA0OV1cIixcbiAgb3J5YTogXCJbXFx1MEI2Ni1cXHUwQjZGXVwiLFxuICB0YW1sZGVjOiBcIltcXHUwQkU2LVxcdTBCRUZdXCIsXG4gIHRlbHU6IFwiW1xcdTBDNjYtXFx1MEM2Rl1cIixcbiAgdGhhaTogXCJbXFx1MEU1MC1cXHUwRTU5XVwiLFxuICB0aWJ0OiBcIltcXHUwRjIwLVxcdTBGMjldXCIsXG4gIGxhdG46IFwiXFxcXGRcIixcbn07XG5cbmNvbnN0IG51bWJlcmluZ1N5c3RlbXNVVEYxNiA9IHtcbiAgYXJhYjogWzE2MzIsIDE2NDFdLFxuICBhcmFiZXh0OiBbMTc3NiwgMTc4NV0sXG4gIGJhbGk6IFs2OTkyLCA3MDAxXSxcbiAgYmVuZzogWzI1MzQsIDI1NDNdLFxuICBkZXZhOiBbMjQwNiwgMjQxNV0sXG4gIGZ1bGx3aWRlOiBbNjUyOTYsIDY1MzAzXSxcbiAgZ3VqcjogWzI3OTAsIDI3OTldLFxuICBraG1yOiBbNjExMiwgNjEyMV0sXG4gIGtuZGE6IFszMzAyLCAzMzExXSxcbiAgbGFvbzogWzM3OTIsIDM4MDFdLFxuICBsaW1iOiBbNjQ3MCwgNjQ3OV0sXG4gIG1seW06IFszNDMwLCAzNDM5XSxcbiAgbW9uZzogWzYxNjAsIDYxNjldLFxuICBteW1yOiBbNDE2MCwgNDE2OV0sXG4gIG9yeWE6IFsyOTE4LCAyOTI3XSxcbiAgdGFtbGRlYzogWzMwNDYsIDMwNTVdLFxuICB0ZWx1OiBbMzE3NCwgMzE4M10sXG4gIHRoYWk6IFszNjY0LCAzNjczXSxcbiAgdGlidDogWzM4NzIsIDM4ODFdLFxufTtcblxuY29uc3QgaGFuaWRlY0NoYXJzID0gbnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjLnJlcGxhY2UoL1tcXFt8XFxdXS9nLCBcIlwiKS5zcGxpdChcIlwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGlnaXRzKHN0cikge1xuICBsZXQgdmFsdWUgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHZhbHVlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoc3RyW2ldLnNlYXJjaChudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMpICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSArPSBoYW5pZGVjQ2hhcnMuaW5kZXhPZihzdHJbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbnVtYmVyaW5nU3lzdGVtc1VURjE2KSB7XG4gICAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IG51bWJlcmluZ1N5c3RlbXNVVEYxNltrZXldO1xuICAgICAgICAgIGlmIChjb2RlID49IG1pbiAmJiBjb2RlIDw9IG1heCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gY29kZSAtIG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8vIGNhY2hlIG9mIHtudW1iZXJpbmdTeXN0ZW06IHthcHBlbmQ6IHJlZ2V4fX1cbmNvbnN0IGRpZ2l0UmVnZXhDYWNoZSA9IG5ldyBNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiByZXNldERpZ2l0UmVnZXhDYWNoZSgpIHtcbiAgZGlnaXRSZWdleENhY2hlLmNsZWFyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWdpdFJlZ2V4KHsgbnVtYmVyaW5nU3lzdGVtIH0sIGFwcGVuZCA9IFwiXCIpIHtcbiAgY29uc3QgbnMgPSBudW1iZXJpbmdTeXN0ZW0gfHwgXCJsYXRuXCI7XG5cbiAgbGV0IGFwcGVuZENhY2hlID0gZGlnaXRSZWdleENhY2hlLmdldChucyk7XG4gIGlmIChhcHBlbmRDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXBwZW5kQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgZGlnaXRSZWdleENhY2hlLnNldChucywgYXBwZW5kQ2FjaGUpO1xuICB9XG4gIGxldCByZWdleCA9IGFwcGVuZENhY2hlLmdldChhcHBlbmQpO1xuICBpZiAocmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgJHtudW1iZXJpbmdTeXN0ZW1zW25zXX0ke2FwcGVuZH1gKTtcbiAgICBhcHBlbmRDYWNoZS5zZXQoYXBwZW5kLCByZWdleCk7XG4gIH1cblxuICByZXR1cm4gcmVnZXg7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/digits.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/english.js":
/*!******************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/english.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eraForDateTime: () => (/* binding */ eraForDateTime),\n/* harmony export */   eras: () => (/* binding */ eras),\n/* harmony export */   erasLong: () => (/* binding */ erasLong),\n/* harmony export */   erasNarrow: () => (/* binding */ erasNarrow),\n/* harmony export */   erasShort: () => (/* binding */ erasShort),\n/* harmony export */   formatRelativeTime: () => (/* binding */ formatRelativeTime),\n/* harmony export */   formatString: () => (/* binding */ formatString),\n/* harmony export */   meridiemForDateTime: () => (/* binding */ meridiemForDateTime),\n/* harmony export */   meridiems: () => (/* binding */ meridiems),\n/* harmony export */   monthForDateTime: () => (/* binding */ monthForDateTime),\n/* harmony export */   months: () => (/* binding */ months),\n/* harmony export */   monthsLong: () => (/* binding */ monthsLong),\n/* harmony export */   monthsNarrow: () => (/* binding */ monthsNarrow),\n/* harmony export */   monthsShort: () => (/* binding */ monthsShort),\n/* harmony export */   weekdayForDateTime: () => (/* binding */ weekdayForDateTime),\n/* harmony export */   weekdays: () => (/* binding */ weekdays),\n/* harmony export */   weekdaysLong: () => (/* binding */ weekdaysLong),\n/* harmony export */   weekdaysNarrow: () => (/* binding */ weekdaysNarrow),\n/* harmony export */   weekdaysShort: () => (/* binding */ weekdaysShort)\n/* harmony export */ });\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n\n\n\nfunction stringify(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\n\n/**\n * @private\n */\n\nconst monthsLong = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n];\n\nconst monthsShort = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\nconst monthsNarrow = [\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"];\n\nfunction months(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...monthsNarrow];\n    case \"short\":\n      return [...monthsShort];\n    case \"long\":\n      return [...monthsLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"];\n    case \"2-digit\":\n      return [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\n    default:\n      return null;\n  }\n}\n\nconst weekdaysLong = [\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\",\n];\n\nconst weekdaysShort = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n\nconst weekdaysNarrow = [\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\"];\n\nfunction weekdays(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...weekdaysNarrow];\n    case \"short\":\n      return [...weekdaysShort];\n    case \"long\":\n      return [...weekdaysLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n    default:\n      return null;\n  }\n}\n\nconst meridiems = [\"AM\", \"PM\"];\n\nconst erasLong = [\"Before Christ\", \"Anno Domini\"];\n\nconst erasShort = [\"BC\", \"AD\"];\n\nconst erasNarrow = [\"B\", \"A\"];\n\nfunction eras(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...erasNarrow];\n    case \"short\":\n      return [...erasShort];\n    case \"long\":\n      return [...erasLong];\n    default:\n      return null;\n  }\n}\n\nfunction meridiemForDateTime(dt) {\n  return meridiems[dt.hour < 12 ? 0 : 1];\n}\n\nfunction weekdayForDateTime(dt, length) {\n  return weekdays(length)[dt.weekday - 1];\n}\n\nfunction monthForDateTime(dt, length) {\n  return months(length)[dt.month - 1];\n}\n\nfunction eraForDateTime(dt, length) {\n  return eras(length)[dt.year < 0 ? 0 : 1];\n}\n\nfunction formatRelativeTime(unit, count, numeric = \"always\", narrow = false) {\n  const units = {\n    years: [\"year\", \"yr.\"],\n    quarters: [\"quarter\", \"qtr.\"],\n    months: [\"month\", \"mo.\"],\n    weeks: [\"week\", \"wk.\"],\n    days: [\"day\", \"day\", \"days\"],\n    hours: [\"hour\", \"hr.\"],\n    minutes: [\"minute\", \"min.\"],\n    seconds: [\"second\", \"sec.\"],\n  };\n\n  const lastable = [\"hours\", \"minutes\", \"seconds\"].indexOf(unit) === -1;\n\n  if (numeric === \"auto\" && lastable) {\n    const isDay = unit === \"days\";\n    switch (count) {\n      case 1:\n        return isDay ? \"tomorrow\" : `next ${units[unit][0]}`;\n      case -1:\n        return isDay ? \"yesterday\" : `last ${units[unit][0]}`;\n      case 0:\n        return isDay ? \"today\" : `this ${units[unit][0]}`;\n      default: // fall through\n    }\n  }\n\n  const isInPast = Object.is(count, -0) || count < 0,\n    fmtValue = Math.abs(count),\n    singular = fmtValue === 1,\n    lilUnits = units[unit],\n    fmtUnit = narrow\n      ? singular\n        ? lilUnits[1]\n        : lilUnits[2] || lilUnits[1]\n      : singular\n      ? units[unit][0]\n      : unit;\n  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;\n}\n\nfunction formatString(knownFormat) {\n  // these all have the offsets removed because we don't have access to them\n  // without all the intl stuff this is backfilling\n  const filtered = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.pick)(knownFormat, [\n      \"weekday\",\n      \"era\",\n      \"year\",\n      \"month\",\n      \"day\",\n      \"hour\",\n      \"minute\",\n      \"second\",\n      \"timeZoneName\",\n      \"hourCycle\",\n    ]),\n    key = stringify(filtered),\n    dateTimeHuge = \"EEEE, LLLL d, yyyy, h:mm a\";\n  switch (key) {\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_SHORT):\n      return \"M/d/yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED):\n      return \"LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED_WITH_WEEKDAY):\n      return \"EEE, LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_FULL):\n      return \"LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_HUGE):\n      return \"EEEE, LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_SIMPLE):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SECONDS):\n      return \"h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SHORT_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_LONG_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_SIMPLE):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SECONDS):\n      return \"HH:mm:ss\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SHORT_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_LONG_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT):\n      return \"M/d/yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED):\n      return \"LLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL):\n      return \"LLLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE):\n      return dateTimeHuge;\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT_WITH_SECONDS):\n      return \"M/d/yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_SECONDS):\n      return \"LLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_WEEKDAY):\n      return \"EEE, d LLL yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL_WITH_SECONDS):\n      return \"LLLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE_WITH_SECONDS):\n      return \"EEEE, LLLL d, yyyy, h:mm:ss a\";\n    default:\n      return dateTimeHuge;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9lbmdsaXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNQOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVSxFQUFFLFNBQVMsYUFBYSxVQUFVLEVBQUUsUUFBUTtBQUM3RTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsOENBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBa0I7QUFDckM7QUFDQSxtQkFBbUIsaURBQWdCO0FBQ25DO0FBQ0EsbUJBQW1CLDhEQUE2QjtBQUNoRDtBQUNBLG1CQUFtQixrREFBaUI7QUFDcEM7QUFDQSxtQkFBbUIsa0RBQWlCO0FBQ3BDO0FBQ0EsbUJBQW1CLG9EQUFtQjtBQUN0QztBQUNBLG1CQUFtQiwwREFBeUI7QUFDNUM7QUFDQSxtQkFBbUIsK0RBQThCO0FBQ2pEO0FBQ0EsbUJBQW1CLDhEQUE2QjtBQUNoRDtBQUNBLG1CQUFtQix1REFBc0I7QUFDekM7QUFDQSxtQkFBbUIsNkRBQTRCO0FBQy9DO0FBQ0EsbUJBQW1CLGtFQUFpQztBQUNwRDtBQUNBLG1CQUFtQixpRUFBZ0M7QUFDbkQ7QUFDQSxtQkFBbUIsdURBQXNCO0FBQ3pDO0FBQ0EsbUJBQW1CLHFEQUFvQjtBQUN2QztBQUNBLG1CQUFtQixzREFBcUI7QUFDeEM7QUFDQSxtQkFBbUIsc0RBQXFCO0FBQ3hDO0FBQ0EsbUJBQW1CLG9FQUFtQztBQUN0RDtBQUNBLG1CQUFtQixrRUFBaUM7QUFDcEQ7QUFDQSxtQkFBbUIsa0VBQWlDO0FBQ3BEO0FBQ0EsbUJBQW1CLG1FQUFrQztBQUNyRDtBQUNBLG1CQUFtQixtRUFBa0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9lbmdsaXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgbW9udGhzTG9uZyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc1Nob3J0ID0gW1xuICBcIkphblwiLFxuICBcIkZlYlwiLFxuICBcIk1hclwiLFxuICBcIkFwclwiLFxuICBcIk1heVwiLFxuICBcIkp1blwiLFxuICBcIkp1bFwiLFxuICBcIkF1Z1wiLFxuICBcIlNlcFwiLFxuICBcIk9jdFwiLFxuICBcIk5vdlwiLFxuICBcIkRlY1wiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBjYXNlIFwiMi1kaWdpdFwiOlxuICAgICAgcmV0dXJuIFtcIjAxXCIsIFwiMDJcIiwgXCIwM1wiLCBcIjA0XCIsIFwiMDVcIiwgXCIwNlwiLCBcIjA3XCIsIFwiMDhcIiwgXCIwOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTG9uZyA9IFtcbiAgXCJNb25kYXlcIixcbiAgXCJUdWVzZGF5XCIsXG4gIFwiV2VkbmVzZGF5XCIsXG4gIFwiVGh1cnNkYXlcIixcbiAgXCJGcmlkYXlcIixcbiAgXCJTYXR1cmRheVwiLFxuICBcIlN1bmRheVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSBbXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc0xvbmcgPSBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzU2hvcnQgPSBbXCJCQ1wiLCBcIkFEXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNMb25nXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMgPSBcImFsd2F5c1wiLCBuYXJyb3cgPSBmYWxzZSkge1xuICBjb25zdCB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXSxcbiAgfTtcblxuICBjb25zdCBsYXN0YWJsZSA9IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl0uaW5kZXhPZih1bml0KSA9PT0gLTE7XG5cbiAgaWYgKG51bWVyaWMgPT09IFwiYXV0b1wiICYmIGxhc3RhYmxlKSB7XG4gICAgY29uc3QgaXNEYXkgPSB1bml0ID09PSBcImRheXNcIjtcbiAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9tb3Jyb3dcIiA6IGBuZXh0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwieWVzdGVyZGF5XCIgOiBgbGFzdCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IGB0aGlzICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGRlZmF1bHQ6IC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgIGZtdFZhbHVlID0gTWF0aC5hYnMoY291bnQpLFxuICAgIHNpbmd1bGFyID0gZm10VmFsdWUgPT09IDEsXG4gICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICBmbXRVbml0ID0gbmFycm93XG4gICAgICA/IHNpbmd1bGFyXG4gICAgICAgID8gbGlsVW5pdHNbMV1cbiAgICAgICAgOiBsaWxVbml0c1syXSB8fCBsaWxVbml0c1sxXVxuICAgICAgOiBzaW5ndWxhclxuICAgICAgPyB1bml0c1t1bml0XVswXVxuICAgICAgOiB1bml0O1xuICByZXR1cm4gaXNJblBhc3QgPyBgJHtmbXRWYWx1ZX0gJHtmbXRVbml0fSBhZ29gIDogYGluICR7Zm10VmFsdWV9ICR7Zm10VW5pdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGtub3duRm9ybWF0KSB7XG4gIC8vIHRoZXNlIGFsbCBoYXZlIHRoZSBvZmZzZXRzIHJlbW92ZWQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIC8vIHdpdGhvdXQgYWxsIHRoZSBpbnRsIHN0dWZmIHRoaXMgaXMgYmFja2ZpbGxpbmdcbiAgY29uc3QgZmlsdGVyZWQgPSBwaWNrKGtub3duRm9ybWF0LCBbXG4gICAgICBcIndlZWtkYXlcIixcbiAgICAgIFwiZXJhXCIsXG4gICAgICBcInllYXJcIixcbiAgICAgIFwibW9udGhcIixcbiAgICAgIFwiZGF5XCIsXG4gICAgICBcImhvdXJcIixcbiAgICAgIFwibWludXRlXCIsXG4gICAgICBcInNlY29uZFwiLFxuICAgICAgXCJ0aW1lWm9uZU5hbWVcIixcbiAgICAgIFwiaG91ckN5Y2xlXCIsXG4gICAgXSksXG4gICAga2V5ID0gc3RyaW5naWZ5KGZpbHRlcmVkKSxcbiAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/english.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formats.js":
/*!******************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/formats.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DATETIME_FULL: () => (/* binding */ DATETIME_FULL),\n/* harmony export */   DATETIME_FULL_WITH_SECONDS: () => (/* binding */ DATETIME_FULL_WITH_SECONDS),\n/* harmony export */   DATETIME_HUGE: () => (/* binding */ DATETIME_HUGE),\n/* harmony export */   DATETIME_HUGE_WITH_SECONDS: () => (/* binding */ DATETIME_HUGE_WITH_SECONDS),\n/* harmony export */   DATETIME_MED: () => (/* binding */ DATETIME_MED),\n/* harmony export */   DATETIME_MED_WITH_SECONDS: () => (/* binding */ DATETIME_MED_WITH_SECONDS),\n/* harmony export */   DATETIME_MED_WITH_WEEKDAY: () => (/* binding */ DATETIME_MED_WITH_WEEKDAY),\n/* harmony export */   DATETIME_SHORT: () => (/* binding */ DATETIME_SHORT),\n/* harmony export */   DATETIME_SHORT_WITH_SECONDS: () => (/* binding */ DATETIME_SHORT_WITH_SECONDS),\n/* harmony export */   DATE_FULL: () => (/* binding */ DATE_FULL),\n/* harmony export */   DATE_HUGE: () => (/* binding */ DATE_HUGE),\n/* harmony export */   DATE_MED: () => (/* binding */ DATE_MED),\n/* harmony export */   DATE_MED_WITH_WEEKDAY: () => (/* binding */ DATE_MED_WITH_WEEKDAY),\n/* harmony export */   DATE_SHORT: () => (/* binding */ DATE_SHORT),\n/* harmony export */   TIME_24_SIMPLE: () => (/* binding */ TIME_24_SIMPLE),\n/* harmony export */   TIME_24_WITH_LONG_OFFSET: () => (/* binding */ TIME_24_WITH_LONG_OFFSET),\n/* harmony export */   TIME_24_WITH_SECONDS: () => (/* binding */ TIME_24_WITH_SECONDS),\n/* harmony export */   TIME_24_WITH_SHORT_OFFSET: () => (/* binding */ TIME_24_WITH_SHORT_OFFSET),\n/* harmony export */   TIME_SIMPLE: () => (/* binding */ TIME_SIMPLE),\n/* harmony export */   TIME_WITH_LONG_OFFSET: () => (/* binding */ TIME_WITH_LONG_OFFSET),\n/* harmony export */   TIME_WITH_SECONDS: () => (/* binding */ TIME_WITH_SECONDS),\n/* harmony export */   TIME_WITH_SHORT_OFFSET: () => (/* binding */ TIME_WITH_SHORT_OFFSET)\n/* harmony export */ });\n/**\n * @private\n */\n\nconst n = \"numeric\",\n  s = \"short\",\n  l = \"long\";\n\nconst DATE_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n};\n\nconst DATE_MED = {\n  year: n,\n  month: s,\n  day: n,\n};\n\nconst DATE_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n};\n\nconst DATE_FULL = {\n  year: n,\n  month: l,\n  day: n,\n};\n\nconst DATE_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n};\n\nconst TIME_SIMPLE = {\n  hour: n,\n  minute: n,\n};\n\nconst TIME_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst TIME_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst TIME_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n\nconst TIME_24_SIMPLE = {\n  hour: n,\n  minute: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: s,\n};\n\nconst TIME_24_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: l,\n};\n\nconst DATETIME_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_SHORT_WITH_SECONDS = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_MED_WITH_SECONDS = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_FULL = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_FULL_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  timeZoneName: l,\n};\n\nconst DATETIME_HUGE_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBuID0gXCJudW1lcmljXCIsXG4gIHMgPSBcInNob3J0XCIsXG4gIGwgPSBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formats.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formatter.js":
/*!********************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/formatter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Formatter)\n/* harmony export */ });\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n\n\n\n\nfunction stringifyTokens(splits, tokenToString) {\n  let s = \"\";\n  for (const token of splits) {\n    if (token.literal) {\n      s += token.val;\n    } else {\n      s += tokenToString(token.val);\n    }\n  }\n  return s;\n}\n\nconst macroTokenToFormatOpts = {\n  D: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_SHORT,\n  DD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_MED,\n  DDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_FULL,\n  DDDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_HUGE,\n  t: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_SIMPLE,\n  tt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SECONDS,\n  ttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SHORT_OFFSET,\n  tttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_LONG_OFFSET,\n  T: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_SIMPLE,\n  TT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SECONDS,\n  TTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SHORT_OFFSET,\n  TTTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_LONG_OFFSET,\n  f: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT,\n  ff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED,\n  fff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL,\n  ffff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE,\n  F: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT_WITH_SECONDS,\n  FF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED_WITH_SECONDS,\n  FFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL_WITH_SECONDS,\n  FFFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE_WITH_SECONDS,\n};\n\n/**\n * @private\n */\n\nclass Formatter {\n  static create(locale, opts = {}) {\n    return new Formatter(locale, opts);\n  }\n\n  static parseFormat(fmt) {\n    // white-space is always considered a literal in user-provided formats\n    // the \" \" token has a special meaning (see unitForToken)\n\n    let current = null,\n      currentFull = \"\",\n      bracketed = false;\n    const splits = [];\n    for (let i = 0; i < fmt.length; i++) {\n      const c = fmt.charAt(i);\n      if (c === \"'\") {\n        // turn '' into a literal signal quote instead of just skipping the empty literal\n        if (currentFull.length > 0 || bracketed) {\n          splits.push({\n            literal: bracketed || /^\\s+$/.test(currentFull),\n            val: currentFull === \"\" ? \"'\" : currentFull,\n          });\n        }\n        current = null;\n        currentFull = \"\";\n        bracketed = !bracketed;\n      } else if (bracketed) {\n        currentFull += c;\n      } else if (c === current) {\n        currentFull += c;\n      } else {\n        if (currentFull.length > 0) {\n          splits.push({ literal: /^\\s+$/.test(currentFull), val: currentFull });\n        }\n        currentFull = c;\n        current = c;\n      }\n    }\n\n    if (currentFull.length > 0) {\n      splits.push({ literal: bracketed || /^\\s+$/.test(currentFull), val: currentFull });\n    }\n\n    return splits;\n  }\n\n  static macroTokenToFormatOpts(token) {\n    return macroTokenToFormatOpts[token];\n  }\n\n  constructor(locale, formatOpts) {\n    this.opts = formatOpts;\n    this.loc = locale;\n    this.systemLoc = null;\n  }\n\n  formatWithSystemDefault(dt, opts) {\n    if (this.systemLoc === null) {\n      this.systemLoc = this.loc.redefaultToSystem();\n    }\n    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });\n    return df.format();\n  }\n\n  dtFormatter(dt, opts = {}) {\n    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });\n  }\n\n  formatDateTime(dt, opts) {\n    return this.dtFormatter(dt, opts).format();\n  }\n\n  formatDateTimeParts(dt, opts) {\n    return this.dtFormatter(dt, opts).formatToParts();\n  }\n\n  formatInterval(interval, opts) {\n    const df = this.dtFormatter(interval.start, opts);\n    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());\n  }\n\n  resolvedOptions(dt, opts) {\n    return this.dtFormatter(dt, opts).resolvedOptions();\n  }\n\n  num(n, p = 0, signDisplay = undefined) {\n    // we get some perf out of doing this here, annoyingly\n    if (this.opts.forceSimple) {\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.padStart)(n, p);\n    }\n\n    const opts = { ...this.opts };\n\n    if (p > 0) {\n      opts.padTo = p;\n    }\n    if (signDisplay) {\n      opts.signDisplay = signDisplay;\n    }\n\n    return this.loc.numberFormatter(opts).format(n);\n  }\n\n  formatDateTimeFromString(dt, fmt) {\n    const knownEnglish = this.loc.listingMode() === \"en\",\n      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== \"gregory\",\n      string = (opts, extract) => this.loc.extract(dt, opts, extract),\n      formatOffset = (opts) => {\n        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {\n          return \"Z\";\n        }\n\n        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : \"\";\n      },\n      meridiem = () =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.meridiemForDateTime(dt)\n          : string({ hour: \"numeric\", hourCycle: \"h12\" }, \"dayperiod\"),\n      month = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.monthForDateTime(dt, length)\n          : string(standalone ? { month: length } : { month: length, day: \"numeric\" }, \"month\"),\n      weekday = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.weekdayForDateTime(dt, length)\n          : string(\n              standalone ? { weekday: length } : { weekday: length, month: \"long\", day: \"numeric\" },\n              \"weekday\"\n            ),\n      maybeMacro = (token) => {\n        const formatOpts = Formatter.macroTokenToFormatOpts(token);\n        if (formatOpts) {\n          return this.formatWithSystemDefault(dt, formatOpts);\n        } else {\n          return token;\n        }\n      },\n      era = (length) =>\n        knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_0__.eraForDateTime(dt, length) : string({ era: length }, \"era\"),\n      tokenToString = (token) => {\n        // Where possible: https://cldr.unicode.org/translation/date-time/date-time-symbols\n        switch (token) {\n          // ms\n          case \"S\":\n            return this.num(dt.millisecond);\n          case \"u\":\n          // falls through\n          case \"SSS\":\n            return this.num(dt.millisecond, 3);\n          // seconds\n          case \"s\":\n            return this.num(dt.second);\n          case \"ss\":\n            return this.num(dt.second, 2);\n          // fractional seconds\n          case \"uu\":\n            return this.num(Math.floor(dt.millisecond / 10), 2);\n          case \"uuu\":\n            return this.num(Math.floor(dt.millisecond / 100));\n          // minutes\n          case \"m\":\n            return this.num(dt.minute);\n          case \"mm\":\n            return this.num(dt.minute, 2);\n          // hours\n          case \"h\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);\n          case \"hh\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);\n          case \"H\":\n            return this.num(dt.hour);\n          case \"HH\":\n            return this.num(dt.hour, 2);\n          // offset\n          case \"Z\":\n            // like +6\n            return formatOffset({ format: \"narrow\", allowZ: this.opts.allowZ });\n          case \"ZZ\":\n            // like +06:00\n            return formatOffset({ format: \"short\", allowZ: this.opts.allowZ });\n          case \"ZZZ\":\n            // like +0600\n            return formatOffset({ format: \"techie\", allowZ: this.opts.allowZ });\n          case \"ZZZZ\":\n            // like EST\n            return dt.zone.offsetName(dt.ts, { format: \"short\", locale: this.loc.locale });\n          case \"ZZZZZ\":\n            // like Eastern Standard Time\n            return dt.zone.offsetName(dt.ts, { format: \"long\", locale: this.loc.locale });\n          // zone\n          case \"z\":\n            // like America/New_York\n            return dt.zoneName;\n          // meridiems\n          case \"a\":\n            return meridiem();\n          // dates\n          case \"d\":\n            return useDateTimeFormatter ? string({ day: \"numeric\" }, \"day\") : this.num(dt.day);\n          case \"dd\":\n            return useDateTimeFormatter ? string({ day: \"2-digit\" }, \"day\") : this.num(dt.day, 2);\n          // weekdays - standalone\n          case \"c\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"ccc\":\n            // like 'Tues'\n            return weekday(\"short\", true);\n          case \"cccc\":\n            // like 'Tuesday'\n            return weekday(\"long\", true);\n          case \"ccccc\":\n            // like 'T'\n            return weekday(\"narrow\", true);\n          // weekdays - format\n          case \"E\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"EEE\":\n            // like 'Tues'\n            return weekday(\"short\", false);\n          case \"EEEE\":\n            // like 'Tuesday'\n            return weekday(\"long\", false);\n          case \"EEEEE\":\n            // like 'T'\n            return weekday(\"narrow\", false);\n          // months - standalone\n          case \"L\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"LL\":\n            // like 01, doesn't seem to work\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"LLL\":\n            // like Jan\n            return month(\"short\", true);\n          case \"LLLL\":\n            // like January\n            return month(\"long\", true);\n          case \"LLLLL\":\n            // like J\n            return month(\"narrow\", true);\n          // months - format\n          case \"M\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"MM\":\n            // like 01\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"MMM\":\n            // like Jan\n            return month(\"short\", false);\n          case \"MMMM\":\n            // like January\n            return month(\"long\", false);\n          case \"MMMMM\":\n            // like J\n            return month(\"narrow\", false);\n          // years\n          case \"y\":\n            // like 2014\n            return useDateTimeFormatter ? string({ year: \"numeric\" }, \"year\") : this.num(dt.year);\n          case \"yy\":\n            // like 14\n            return useDateTimeFormatter\n              ? string({ year: \"2-digit\" }, \"year\")\n              : this.num(dt.year.toString().slice(-2), 2);\n          case \"yyyy\":\n            // like 0012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 4);\n          case \"yyyyyy\":\n            // like 000012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 6);\n          // eras\n          case \"G\":\n            // like AD\n            return era(\"short\");\n          case \"GG\":\n            // like Anno Domini\n            return era(\"long\");\n          case \"GGGGG\":\n            return era(\"narrow\");\n          case \"kk\":\n            return this.num(dt.weekYear.toString().slice(-2), 2);\n          case \"kkkk\":\n            return this.num(dt.weekYear, 4);\n          case \"W\":\n            return this.num(dt.weekNumber);\n          case \"WW\":\n            return this.num(dt.weekNumber, 2);\n          case \"n\":\n            return this.num(dt.localWeekNumber);\n          case \"nn\":\n            return this.num(dt.localWeekNumber, 2);\n          case \"ii\":\n            return this.num(dt.localWeekYear.toString().slice(-2), 2);\n          case \"iiii\":\n            return this.num(dt.localWeekYear, 4);\n          case \"o\":\n            return this.num(dt.ordinal);\n          case \"ooo\":\n            return this.num(dt.ordinal, 3);\n          case \"q\":\n            // like 1\n            return this.num(dt.quarter);\n          case \"qq\":\n            // like 01\n            return this.num(dt.quarter, 2);\n          case \"X\":\n            return this.num(Math.floor(dt.ts / 1000));\n          case \"x\":\n            return this.num(dt.ts);\n          default:\n            return maybeMacro(token);\n        }\n      };\n\n    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);\n  }\n\n  formatDurationFromString(dur, fmt) {\n    const invertLargest = this.opts.signMode === \"negativeLargestOnly\" ? -1 : 1;\n    const tokenToField = (token) => {\n        switch (token[0]) {\n          case \"S\":\n            return \"milliseconds\";\n          case \"s\":\n            return \"seconds\";\n          case \"m\":\n            return \"minutes\";\n          case \"h\":\n            return \"hours\";\n          case \"d\":\n            return \"days\";\n          case \"w\":\n            return \"weeks\";\n          case \"M\":\n            return \"months\";\n          case \"y\":\n            return \"years\";\n          default:\n            return null;\n        }\n      },\n      tokenToString = (lildur, info) => (token) => {\n        const mapped = tokenToField(token);\n        if (mapped) {\n          const inversionFactor =\n            info.isNegativeDuration && mapped !== info.largestUnit ? invertLargest : 1;\n          let signDisplay;\n          if (this.opts.signMode === \"negativeLargestOnly\" && mapped !== info.largestUnit) {\n            signDisplay = \"never\";\n          } else if (this.opts.signMode === \"all\") {\n            signDisplay = \"always\";\n          } else {\n            // \"auto\" and \"negative\" are the same, but \"auto\" has better support\n            signDisplay = \"auto\";\n          }\n          return this.num(lildur.get(mapped) * inversionFactor, token.length, signDisplay);\n        } else {\n          return token;\n        }\n      },\n      tokens = Formatter.parseFormat(fmt),\n      realTokens = tokens.reduce(\n        (found, { literal, val }) => (literal ? found : found.concat(val)),\n        []\n      ),\n      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t)),\n      durationInfo = {\n        isNegativeDuration: collapsed < 0,\n        // this relies on \"collapsed\" being based on \"shiftTo\", which builds up the object\n        // in order\n        largestUnit: Object.keys(collapsed.values)[0],\n      };\n    return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNBO0FBQ0g7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssbURBQWtCO0FBQ3ZCLE1BQU0saURBQWdCO0FBQ3RCLE9BQU8sa0RBQWlCO0FBQ3hCLFFBQVEsa0RBQWlCO0FBQ3pCLEtBQUssb0RBQW1CO0FBQ3hCLE1BQU0sMERBQXlCO0FBQy9CLE9BQU8sK0RBQThCO0FBQ3JDLFFBQVEsOERBQTZCO0FBQ3JDLEtBQUssdURBQXNCO0FBQzNCLE1BQU0sNkRBQTRCO0FBQ2xDLE9BQU8sa0VBQWlDO0FBQ3hDLFFBQVEsaUVBQWdDO0FBQ3hDLEtBQUssdURBQXNCO0FBQzNCLE1BQU0scURBQW9CO0FBQzFCLE9BQU8sc0RBQXFCO0FBQzVCLFFBQVEsc0RBQXFCO0FBQzdCLEtBQUssb0VBQW1DO0FBQ3hDLE1BQU0sa0VBQWlDO0FBQ3ZDLE9BQU8sbUVBQWtDO0FBQ3pDLFFBQVEsbUVBQWtDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0Isc0RBQXNEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUVBQW1FO0FBQ3ZGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHNwbGl0cykge1xuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0ge1xuICBEOiBGb3JtYXRzLkRBVEVfU0hPUlQsXG4gIEREOiBGb3JtYXRzLkRBVEVfTUVELFxuICBEREQ6IEZvcm1hdHMuREFURV9GVUxMLFxuICBEREREOiBGb3JtYXRzLkRBVEVfSFVHRSxcbiAgdDogRm9ybWF0cy5USU1FX1NJTVBMRSxcbiAgdHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMsXG4gIHR0dDogRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VULFxuICB0dHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogRm9ybWF0cy5USU1FXzI0X1NJTVBMRSxcbiAgVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMsXG4gIFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCxcbiAgZjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVCxcbiAgZmY6IEZvcm1hdHMuREFURVRJTUVfTUVELFxuICBmZmY6IEZvcm1hdHMuREFURVRJTUVfRlVMTCxcbiAgZmZmZjogRm9ybWF0cy5EQVRFVElNRV9IVUdFLFxuICBGOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyxcbiAgRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTLFxuICBGRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1hdHRlciB7XG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIC8vIHdoaXRlLXNwYWNlIGlzIGFsd2F5cyBjb25zaWRlcmVkIGEgbGl0ZXJhbCBpbiB1c2VyLXByb3ZpZGVkIGZvcm1hdHNcbiAgICAvLyB0aGUgXCIgXCIgdG9rZW4gaGFzIGEgc3BlY2lhbCBtZWFuaW5nIChzZWUgdW5pdEZvclRva2VuKVxuXG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIC8vIHR1cm4gJycgaW50byBhIGxpdGVyYWwgc2lnbmFsIHF1b3RlIGluc3RlYWQgb2YganVzdCBza2lwcGluZyB0aGUgZW1wdHkgbGl0ZXJhbFxuICAgICAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCB8fCBicmFja2V0ZWQpIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBicmFja2V0ZWQgfHwgL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksXG4gICAgICAgICAgICB2YWw6IGN1cnJlbnRGdWxsID09PSBcIlwiID8gXCInXCIgOiBjdXJyZW50RnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkIHx8IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cblxuICBzdGF0aWMgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzW3Rva2VuXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG4gICAgY29uc3QgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZShkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lUGFydHMoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgZm9ybWF0SW50ZXJ2YWwoaW50ZXJ2YWwsIG9wdHMpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoaW50ZXJ2YWwuc3RhcnQsIG9wdHMpO1xuICAgIHJldHVybiBkZi5kdGYuZm9ybWF0UmFuZ2UoaW50ZXJ2YWwuc3RhcnQudG9KU0RhdGUoKSwgaW50ZXJ2YWwuZW5kLnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG5cbiAgbnVtKG4sIHAgPSAwLCBzaWduRGlzcGxheSA9IHVuZGVmaW5lZCkge1xuICAgIC8vIHdlIGdldCBzb21lIHBlcmYgb3V0IG9mIGRvaW5nIHRoaXMgaGVyZSwgYW5ub3lpbmdseVxuICAgIGlmICh0aGlzLm9wdHMuZm9yY2VTaW1wbGUpIHtcbiAgICAgIHJldHVybiBwYWRTdGFydChuLCBwKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfTtcblxuICAgIGlmIChwID4gMCkge1xuICAgICAgb3B0cy5wYWRUbyA9IHA7XG4gICAgfVxuICAgIGlmIChzaWduRGlzcGxheSkge1xuICAgICAgb3B0cy5zaWduRGlzcGxheSA9IHNpZ25EaXNwbGF5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYy5udW1iZXJGb3JtYXR0ZXIob3B0cykuZm9ybWF0KG4pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICBjb25zdCBrbm93bkVuZ2xpc2ggPSB0aGlzLmxvYy5saXN0aW5nTW9kZSgpID09PSBcImVuXCIsXG4gICAgICB1c2VEYXRlVGltZUZvcm1hdHRlciA9IHRoaXMubG9jLm91dHB1dENhbGVuZGFyICYmIHRoaXMubG9jLm91dHB1dENhbGVuZGFyICE9PSBcImdyZWdvcnlcIixcbiAgICAgIHN0cmluZyA9IChvcHRzLCBleHRyYWN0KSA9PiB0aGlzLmxvYy5leHRyYWN0KGR0LCBvcHRzLCBleHRyYWN0KSxcbiAgICAgIGZvcm1hdE9mZnNldCA9IChvcHRzKSA9PiB7XG4gICAgICAgIGlmIChkdC5pc09mZnNldEZpeGVkICYmIGR0Lm9mZnNldCA9PT0gMCAmJiBvcHRzLmFsbG93Wikge1xuICAgICAgICAgIHJldHVybiBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkdC5pc1ZhbGlkID8gZHQuem9uZS5mb3JtYXRPZmZzZXQoZHQudHMsIG9wdHMuZm9ybWF0KSA6IFwiXCI7XG4gICAgICB9LFxuICAgICAgbWVyaWRpZW0gPSAoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZShkdClcbiAgICAgICAgICA6IHN0cmluZyh7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfSwgXCJkYXlwZXJpb2RcIiksXG4gICAgICBtb250aCA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoc3RhbmRhbG9uZSA/IHsgbW9udGg6IGxlbmd0aCB9IDogeyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIiksXG4gICAgICB3ZWVrZGF5ID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKFxuICAgICAgICAgICAgICBzdGFuZGFsb25lID8geyB3ZWVrZGF5OiBsZW5ndGggfSA6IHsgd2Vla2RheTogbGVuZ3RoLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfSxcbiAgICAgICAgICAgICAgXCJ3ZWVrZGF5XCJcbiAgICAgICAgICAgICksXG4gICAgICBtYXliZU1hY3JvID0gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG4gICAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIGZvcm1hdE9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVyYSA9IChsZW5ndGgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaCA/IEVuZ2xpc2guZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkgOiBzdHJpbmcoeyBlcmE6IGxlbmd0aCB9LCBcImVyYVwiKSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAodG9rZW4pID0+IHtcbiAgICAgICAgLy8gV2hlcmUgcG9zc2libGU6IGh0dHBzOi8vY2xkci51bmljb2RlLm9yZy90cmFuc2xhdGlvbi9kYXRlLXRpbWUvZGF0ZS10aW1lLXN5bWJvbHNcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgIC8vIG1zXG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kLCAzKTtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCwgMik7XG4gICAgICAgICAgLy8gZnJhY3Rpb25hbCBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwKSwgMik7XG4gICAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMDApKTtcbiAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUpO1xuICAgICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSwgMik7XG4gICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyKTtcbiAgICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMiwgMik7XG4gICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyKTtcbiAgICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyLCAyKTtcbiAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArNlxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJuYXJyb3dcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDY6MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwic2hvcnRcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwidGVjaGllXCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFU1RcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcInNob3J0XCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcImxvbmdcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgLy8gem9uZVxuICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lTmFtZTtcbiAgICAgICAgICAvLyBtZXJpZGllbXNcbiAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgcmV0dXJuIG1lcmlkaWVtKCk7XG4gICAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIm51bWVyaWNcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSk7XG4gICAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwiMi1kaWdpdFwiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5LCAyKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMSwgZG9lc24ndCBzZWVtIHRvIHdvcmtcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIHllYXJzXG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMjAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpIDogdGhpcy5udW0oZHQueWVhcik7XG4gICAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIjItZGlnaXRcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwieXl5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNik7XG4gICAgICAgICAgLy8gZXJhc1xuICAgICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFEXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwic2hvcnRcIik7XG4gICAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFubm8gRG9taW5pXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibG9uZ1wiKTtcbiAgICAgICAgICBjYXNlIFwiR0dHR0dcIjpcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJuYXJyb3dcIik7XG4gICAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlcik7XG4gICAgICAgICAgY2FzZSBcIldXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlciwgMik7XG4gICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJublwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla051bWJlciwgMik7XG4gICAgICAgICAgY2FzZSBcImlpXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubG9jYWxXZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImlpaWlcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IGludmVydExhcmdlc3QgPSB0aGlzLm9wdHMuc2lnbk1vZGUgPT09IFwibmVnYXRpdmVMYXJnZXN0T25seVwiID8gLTEgOiAxO1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kc1wiO1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzZWNvbmRzXCI7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbnV0ZXNcIjtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG91cnNcIjtcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZGF5c1wiO1xuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ3ZWVrc1wiO1xuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtb250aHNcIjtcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwieWVhcnNcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gKGxpbGR1ciwgaW5mbykgPT4gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICBjb25zdCBpbnZlcnNpb25GYWN0b3IgPVxuICAgICAgICAgICAgaW5mby5pc05lZ2F0aXZlRHVyYXRpb24gJiYgbWFwcGVkICE9PSBpbmZvLmxhcmdlc3RVbml0ID8gaW52ZXJ0TGFyZ2VzdCA6IDE7XG4gICAgICAgICAgbGV0IHNpZ25EaXNwbGF5O1xuICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2lnbk1vZGUgPT09IFwibmVnYXRpdmVMYXJnZXN0T25seVwiICYmIG1hcHBlZCAhPT0gaW5mby5sYXJnZXN0VW5pdCkge1xuICAgICAgICAgICAgc2lnbkRpc3BsYXkgPSBcIm5ldmVyXCI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuc2lnbk1vZGUgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIHNpZ25EaXNwbGF5ID0gXCJhbHdheXNcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gXCJhdXRvXCIgYW5kIFwibmVnYXRpdmVcIiBhcmUgdGhlIHNhbWUsIGJ1dCBcImF1dG9cIiBoYXMgYmV0dGVyIHN1cHBvcnRcbiAgICAgICAgICAgIHNpZ25EaXNwbGF5ID0gXCJhdXRvXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm51bShsaWxkdXIuZ2V0KG1hcHBlZCkgKiBpbnZlcnNpb25GYWN0b3IsIHRva2VuLmxlbmd0aCwgc2lnbkRpc3BsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgcmVhbFRva2VucyA9IHRva2Vucy5yZWR1Y2UoXG4gICAgICAgIChmb3VuZCwgeyBsaXRlcmFsLCB2YWwgfSkgPT4gKGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpKSxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUbyguLi5yZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcigodCkgPT4gdCkpLFxuICAgICAgZHVyYXRpb25JbmZvID0ge1xuICAgICAgICBpc05lZ2F0aXZlRHVyYXRpb246IGNvbGxhcHNlZCA8IDAsXG4gICAgICAgIC8vIHRoaXMgcmVsaWVzIG9uIFwiY29sbGFwc2VkXCIgYmVpbmcgYmFzZWQgb24gXCJzaGlmdFRvXCIsIHdoaWNoIGJ1aWxkcyB1cCB0aGUgb2JqZWN0XG4gICAgICAgIC8vIGluIG9yZGVyXG4gICAgICAgIGxhcmdlc3RVbml0OiBPYmplY3Qua2V5cyhjb2xsYXBzZWQudmFsdWVzKVswXSxcbiAgICAgIH07XG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2Vucyh0b2tlbnMsIHRva2VuVG9TdHJpbmcoY29sbGFwc2VkLCBkdXJhdGlvbkluZm8pKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formatter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/invalid.js":
/*!******************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/invalid.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Invalid)\n/* harmony export */ });\nclass Invalid {\n  constructor(reason, explanation) {\n    this.reason = reason;\n    this.explanation = explanation;\n  }\n\n  toMessage() {\n    if (this.explanation) {\n      return `${this.reason}: ${this.explanation}`;\n    } else {\n      return this.reason;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9pbnZhbGlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxJQUFJLGlCQUFpQjtBQUNqRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkIHtcbiAgY29uc3RydWN0b3IocmVhc29uLCBleHBsYW5hdGlvbikge1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgfVxuXG4gIHRvTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5leHBsYW5hdGlvbikge1xuICAgICAgcmV0dXJuIGAke3RoaXMucmVhc29ufTogJHt0aGlzLmV4cGxhbmF0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/invalid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/locale.js":
/*!*****************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/locale.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Locale)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nconst intlDTCache = new Map();\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache.get(key);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache.set(key, dtf);\n  }\n  return dtf;\n}\n\nconst intlNumCache = new Map();\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache.set(key, inf);\n  }\n  return inf;\n}\n\nconst intlRelCache = new Map();\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache.set(key, inf);\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nconst intlResolvedOptionsCache = new Map();\nfunction getCachedIntResolvedOptions(locString) {\n  let opts = intlResolvedOptionsCache.get(locString);\n  if (opts === undefined) {\n    opts = new Intl.DateTimeFormat(locString).resolvedOptions();\n    intlResolvedOptionsCache.set(locString, opts);\n  }\n  return opts;\n}\n\nconst weekInfoCache = new Map();\nfunction getCachedWeekInfo(locString) {\n  let data = weekInfoCache.get(locString);\n  if (!data) {\n    const locale = new Intl.Locale(locString);\n    // browsers currently implement this as a property, but spec says it should be a getter function\n    data = \"getWeekInfo\" in locale ? locale.getWeekInfo() : locale.weekInfo;\n    // minimalDays was removed from WeekInfo: https://github.com/tc39/proposal-intl-locale-info/issues/86\n    if (!(\"minimalDays\" in data)) {\n      data = { ...fallbackWeekSettings, ...data };\n    }\n    weekInfoCache.set(locString, data);\n  }\n  return data;\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const { numberingSystem, calendar } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2009, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, englishFn, intlFn) {\n  const mode = loc.listingMode();\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      getCachedIntResolvedOptions(loc.locale).numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roundTo)(i, 3);\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n\n    let z = undefined;\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n      this.originalZone = dt.zone;\n    }\n\n    const intlOpts = { ...this.opts };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts()\n        .map(({ value }) => value)\n        .join(\"\");\n    }\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n    if (this.originalZone) {\n      return parts.map((part) => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName,\n          });\n          return {\n            ...part,\n            value: offsetName,\n          };\n        } else {\n          return part;\n        }\n      });\n    }\n    return parts;\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasRelative)()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return _english_js__WEBPACK_IMPORTED_MODULE_1__.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\nconst fallbackWeekSettings = {\n  firstDay: 1,\n  minimalDays: 4,\n  weekend: [6, 7],\n};\n\n/**\n * @private\n */\nclass Locale {\n  static fromOpts(opts) {\n    return Locale.create(\n      opts.locale,\n      opts.numberingSystem,\n      opts.outputCalendar,\n      opts.weekSettings,\n      opts.defaultToEN\n    );\n  }\n\n  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {\n    const specifiedLocale = locale || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLocale;\n    // the system locale is useful for human-readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultOutputCalendar;\n    const weekSettingsR = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(weekSettings) || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultWeekSettings;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache.clear();\n    intlNumCache.clear();\n    intlRelCache.clear();\n    intlResolvedOptionsCache.clear();\n    weekInfoCache.clear();\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);\n  }\n\n  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.weekSettings = weekSettings;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(alts.weekSettings) || this.weekSettings,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.months, () => {\n      // Workaround for \"ja\" locale: formatToParts does not label all parts of the month\n      // as \"month\" and for this locale there is no difference between \"format\" and \"non-format\".\n      // As such, just use format() instead of formatToParts() and take the whole string\n      const monthSpecialCase = this.intl === \"ja\" || this.intl.startsWith(\"ja-\");\n      format &= !monthSpecialCase;\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        const mapper = !monthSpecialCase\n          ? (dt) => this.extract(dt, intl, \"month\")\n          : (dt) => this.dtFormatter(dt, intl).format();\n        this.monthsCache[formatStr][length] = mapMonths(mapper);\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems() {\n    return listStuff(\n      this,\n      undefined,\n      () => _english_js__WEBPACK_IMPORTED_MODULE_1__.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 9), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(-40, 1, 1), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      getCachedIntResolvedOptions(this.intl).locale.startsWith(\"en-us\")\n    );\n  }\n\n  getWeekSettings() {\n    if (this.weekSettings) {\n      return this.weekSettings;\n    } else if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasLocaleWeekInfo)()) {\n      return fallbackWeekSettings;\n    } else {\n      return getCachedWeekInfo(this.locale);\n    }\n  }\n\n  getStartOfWeek() {\n    return this.getWeekSettings().firstDay;\n  }\n\n  getMinDaysInFirstWeek() {\n    return this.getWeekSettings().minimalDays;\n  }\n\n  getWeekendDays() {\n    return this.getWeekSettings().weekend;\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n\n  toString() {\n    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9HO0FBQzVEO0FBQ0Y7QUFDQTtBQUNNOztBQUU1Qzs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxVQUFVLHdCQUF3QixRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDOztBQUVBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFF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bGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzTG9jYWxlV2Vla0luZm8sIGhhc1JlbGF0aXZlLCBwYWRTdGFydCwgcm91bmRUbywgdmFsaWRhdGVXZWVrU2V0dGluZ3MgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLy8gdG9kbyAtIHJlbWFwIGNhY2hpbmdcblxubGV0IGludGxMRkNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRMRihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsTEZDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTEZDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmNvbnN0IGludGxEVENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlLmdldChrZXkpO1xuICBpZiAoZHRmID09PSB1bmRlZmluZWQpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxEVENhY2hlLnNldChrZXksIGR0Zik7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxuY29uc3QgaW50bE51bUNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkSU5GKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGluZiA9IGludGxOdW1DYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGluZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5mID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bE51bUNhY2hlLnNldChrZXksIGluZik7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxuY29uc3QgaW50bFJlbENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkUlRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFzZSwgLi4uY2FjaGVLZXlPcHRzIH0gPSBvcHRzOyAvLyBleGNsdWRlIGBiYXNlYCBmcm9tIHRoZSBvcHRpb25zXG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIGNhY2hlS2V5T3B0c10pO1xuICBsZXQgaW5mID0gaW50bFJlbENhY2hlLmdldChrZXkpO1xuICBpZiAoaW5mID09PSB1bmRlZmluZWQpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGUuc2V0KGtleSwgaW5mKTtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH1cbn1cblxuY29uc3QgaW50bFJlc29sdmVkT3B0aW9uc0NhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkSW50UmVzb2x2ZWRPcHRpb25zKGxvY1N0cmluZykge1xuICBsZXQgb3B0cyA9IGludGxSZXNvbHZlZE9wdGlvbnNDYWNoZS5nZXQobG9jU3RyaW5nKTtcbiAgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NTdHJpbmcpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIGludGxSZXNvbHZlZE9wdGlvbnNDYWNoZS5zZXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgfVxuICByZXR1cm4gb3B0cztcbn1cblxuY29uc3Qgd2Vla0luZm9DYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlZFdlZWtJbmZvKGxvY1N0cmluZykge1xuICBsZXQgZGF0YSA9IHdlZWtJbmZvQ2FjaGUuZ2V0KGxvY1N0cmluZyk7XG4gIGlmICghZGF0YSkge1xuICAgIGNvbnN0IGxvY2FsZSA9IG5ldyBJbnRsLkxvY2FsZShsb2NTdHJpbmcpO1xuICAgIC8vIGJyb3dzZXJzIGN1cnJlbnRseSBpbXBsZW1lbnQgdGhpcyBhcyBhIHByb3BlcnR5LCBidXQgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhIGdldHRlciBmdW5jdGlvblxuICAgIGRhdGEgPSBcImdldFdlZWtJbmZvXCIgaW4gbG9jYWxlID8gbG9jYWxlLmdldFdlZWtJbmZvKCkgOiBsb2NhbGUud2Vla0luZm87XG4gICAgLy8gbWluaW1hbERheXMgd2FzIHJlbW92ZWQgZnJvbSBXZWVrSW5mbzogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtaW50bC1sb2NhbGUtaW5mby9pc3N1ZXMvODZcbiAgICBpZiAoIShcIm1pbmltYWxEYXlzXCIgaW4gZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7IC4uLmZhbGxiYWNrV2Vla1NldHRpbmdzLCAuLi5kYXRhIH07XG4gICAgfVxuICAgIHdlZWtJbmZvQ2FjaGUuc2V0KGxvY1N0cmluZywgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZVN0cikge1xuICAvLyBJIHJlYWxseSB3YW50IHRvIGF2b2lkIHdyaXRpbmcgYSBCQ1AgNDcgcGFyc2VyXG4gIC8vIHNlZSwgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL2JjcC00N1xuICAvLyBJbnN0ZWFkLCB3ZSdsbCBkbyB0aGlzOlxuXG4gIC8vIGEpIGlmIHRoZSBzdHJpbmcgaGFzIG5vIC11IGV4dGVuc2lvbnMsIGp1c3QgbGVhdmUgaXQgYWxvbmVcbiAgLy8gYikgaWYgaXQgZG9lcywgdXNlIEludGwgdG8gcmVzb2x2ZSBldmVyeXRoaW5nXG4gIC8vIGMpIGlmIEludGwgZmFpbHMsIHRyeSBhZ2FpbiB3aXRob3V0IHRoZSAtdVxuXG4gIC8vIHByaXZhdGUgc3VidGFncyBhbmQgdW5pY29kZSBzdWJ0YWdzIGhhdmUgb3JkZXJpbmcgcmVxdWlyZW1lbnRzLFxuICAvLyBhbmQgd2UncmUgbm90IHByb3Blcmx5IHBhcnNpbmcgdGhpcywgc28ganVzdCBzdHJpcCBvdXQgdGhlXG4gIC8vIHByaXZhdGUgb25lcyBpZiB0aGV5IGV4aXN0LlxuICBjb25zdCB4SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi14LVwiKTtcbiAgaWYgKHhJbmRleCAhPT0gLTEpIHtcbiAgICBsb2NhbGVTdHIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHhJbmRleCk7XG4gIH1cblxuICBjb25zdCB1SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi11LVwiKTtcbiAgaWYgKHVJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gW2xvY2FsZVN0cl07XG4gIH0gZWxzZSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IHNlbGVjdGVkU3RyO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKGxvY2FsZVN0cikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IGxvY2FsZVN0cjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBzbWFsbGVyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB1SW5kZXgpO1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihzbWFsbGVyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gc21hbGxlcjtcbiAgICB9XG5cbiAgICBjb25zdCB7IG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIFtzZWxlY3RlZFN0ciwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50bENvbmZpZ1N0cmluZyhsb2NhbGVTdHIsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpIHtcbiAgaWYgKG91dHB1dENhbGVuZGFyIHx8IG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGlmICghbG9jYWxlU3RyLmluY2x1ZGVzKFwiLXUtXCIpKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRDYWxlbmRhcikge1xuICAgICAgbG9jYWxlU3RyICs9IGAtY2EtJHtvdXRwdXRDYWxlbmRhcn1gO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLW51LSR7bnVtYmVyaW5nU3lzdGVtfWA7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBNb250aHMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSAxMjsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAwOSwgaSwgMSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBtYXBXZWVrZGF5cyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDc7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMyArIGkpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbGlzdFN0dWZmKGxvYywgbGVuZ3RoLCBlbmdsaXNoRm4sIGludGxGbikge1xuICBjb25zdCBtb2RlID0gbG9jLmxpc3RpbmdNb2RlKCk7XG5cbiAgaWYgKG1vZGUgPT09IFwiZXJyb3JcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiZW5cIikge1xuICAgIHJldHVybiBlbmdsaXNoRm4obGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW50bEZuKGxlbmd0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNGYXN0TnVtYmVycyhsb2MpIHtcbiAgaWYgKGxvYy5udW1iZXJpbmdTeXN0ZW0gJiYgbG9jLm51bWJlcmluZ1N5c3RlbSAhPT0gXCJsYXRuXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvYy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiIHx8XG4gICAgICAhbG9jLmxvY2FsZSB8fFxuICAgICAgbG9jLmxvY2FsZS5zdGFydHNXaXRoKFwiZW5cIikgfHxcbiAgICAgIGdldENhY2hlZEludFJlc29sdmVkT3B0aW9ucyhsb2MubG9jYWxlKS5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seU51bWJlckZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGZvcmNlU2ltcGxlLCBvcHRzKSB7XG4gICAgdGhpcy5wYWRUbyA9IG9wdHMucGFkVG8gfHwgMDtcbiAgICB0aGlzLmZsb29yID0gb3B0cy5mbG9vciB8fCBmYWxzZTtcblxuICAgIGNvbnN0IHsgcGFkVG8sIGZsb29yLCAuLi5vdGhlck9wdHMgfSA9IG9wdHM7XG5cbiAgICBpZiAoIWZvcmNlU2ltcGxlIHx8IE9iamVjdC5rZXlzKG90aGVyT3B0cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaW50bE9wdHMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSwgLi4ub3B0cyB9O1xuICAgICAgaWYgKG9wdHMucGFkVG8gPiAwKSBpbnRsT3B0cy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IG9wdHMucGFkVG87XG4gICAgICB0aGlzLmluZiA9IGdldENhY2hlZElORihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGkpIHtcbiAgICBpZiAodGhpcy5pbmYpIHtcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiBpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mLmZvcm1hdChmaXhlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgbnVtYmVyZm9ybWF0dGVyIGRlZmF1bHRzXG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogcm91bmRUbyhpLCAzKTtcbiAgICAgIHJldHVybiBwYWRTdGFydChmaXhlZCwgdGhpcy5wYWRUbyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5RGF0ZUZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGR0LCBpbnRsLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IHVuZGVmaW5lZDtcblxuICAgIGxldCB6ID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdHMudGltZVpvbmUpIHtcbiAgICAgIC8vIERvbid0IGFwcGx5IGFueSB3b3JrYXJvdW5kcyBpZiBhIHRpbWVab25lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gb3B0c1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImZpeGVkXCIpIHtcbiAgICAgIC8vIFVUQy04IG9yIEV0Yy9VVEMtOCBhcmUgbm90IHBhcnQgb2YgdHpkYXRhLCBvbmx5IEV0Yy9HTVQrOCBhbmQgdGhlIGxpa2UuXG4gICAgICAvLyBUaGF0IGlzIHdoeSBmaXhlZC1vZmZzZXQgVFogaXMgc2V0IHRvIHRoYXQgdW5sZXNzIGl0IGlzOlxuICAgICAgLy8gMS4gUmVwcmVzZW50aW5nIG9mZnNldCAwIHdoZW4gVVRDIGlzIHVzZWQgdG8gbWFpbnRhaW4gcHJldmlvdXMgYmVoYXZpb3IgYW5kIGRvZXMgbm90IGJlY29tZSBHTVQuXG4gICAgICAvLyAyLiBVbnN1cHBvcnRlZCBieSB0aGUgYnJvd3NlcjpcbiAgICAgIC8vICAgIC0gc29tZSBkbyBub3Qgc3VwcG9ydCBFdGMvXG4gICAgICAvLyAgICAtIDwgRXRjL0dNVC0xNCwgPiBFdGMvR01UKzEyLCBhbmQgMzAtbWludXRlIG9yIDQ1LW1pbnV0ZSBvZmZzZXRzIGFyZSBub3QgcGFydCBvZiB0emRhdGFcbiAgICAgIGNvbnN0IGdtdE9mZnNldCA9IC0xICogKGR0Lm9mZnNldCAvIDYwKTtcbiAgICAgIGNvbnN0IG9mZnNldFogPSBnbXRPZmZzZXQgPj0gMCA/IGBFdGMvR01UKyR7Z210T2Zmc2V0fWAgOiBgRXRjL0dNVCR7Z210T2Zmc2V0fWA7XG4gICAgICBpZiAoZHQub2Zmc2V0ICE9PSAwICYmIElBTkFab25lLmNyZWF0ZShvZmZzZXRaKS52YWxpZCkge1xuICAgICAgICB6ID0gb2Zmc2V0WjtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFsbCBmaXhlZC1vZmZzZXQgem9uZXMgbGlrZSBFdGMvKzQ6MzAgYXJlIHByZXNlbnQgaW4gdHpkYXRhIHNvXG4gICAgICAgIC8vIHdlIG1hbnVhbGx5IGFwcGx5IHRoZSBvZmZzZXQgYW5kIHN1YnN0aXR1dGUgdGhlIHpvbmUgYXMgbmVlZGVkLlxuICAgICAgICB6ID0gXCJVVENcIjtcbiAgICAgICAgdGhpcy5kdCA9IGR0Lm9mZnNldCA9PT0gMCA/IGR0IDogZHQuc2V0Wm9uZShcIlVUQ1wiKS5wbHVzKHsgbWludXRlczogZHQub2Zmc2V0IH0pO1xuICAgICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJpYW5hXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1c3RvbSB6b25lcyBjYW4gaGF2ZSBhbnkgb2Zmc2V0IC8gb2Zmc2V0TmFtZSBzbyB3ZSBqdXN0IG1hbnVhbGx5XG4gICAgICAvLyBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgdGhpcy5kdCA9IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgIHRoaXMub3JpZ2luYWxab25lID0gZHQuem9uZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRsT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSBpbnRsT3B0cy50aW1lWm9uZSB8fCB6O1xuICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgdG8gc3Vic3RpdHV0ZSBpbiB0aGUgYWN0dWFsIHpvbmUgbmFtZSwgd2UgaGF2ZSB0byB1c2VcbiAgICAgIC8vIGZvcm1hdFRvUGFydHMgc28gdGhhdCB0aGUgdGltZXpvbmUgY2FuIGJlIHJlcGxhY2VkLlxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VG9QYXJ0cygpXG4gICAgICAgIC5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpXG4gICAgICAgIC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5kdGYuZm9ybWF0VG9QYXJ0cyh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICAgIGlmICh0aGlzLm9yaWdpbmFsWm9uZSkge1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRpbWVab25lTmFtZVwiKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0TmFtZSA9IHRoaXMub3JpZ2luYWxab25lLm9mZnNldE5hbWUodGhpcy5kdC50cywge1xuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmR0LmxvY2FsZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRzLnRpbWVab25lTmFtZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucGFydCxcbiAgICAgICAgICAgIHZhbHVlOiBvZmZzZXROYW1lLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUG9seVJlbEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGlzRW5nbGlzaCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgc3R5bGU6IFwibG9uZ1wiLCAuLi5vcHRzIH07XG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGZhbGxiYWNrV2Vla1NldHRpbmdzID0ge1xuICBmaXJzdERheTogMSxcbiAgbWluaW1hbERheXM6IDQsXG4gIHdlZWtlbmQ6IFs2LCA3XSxcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgIG9wdHMubG9jYWxlLFxuICAgICAgb3B0cy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICBvcHRzLm91dHB1dENhbGVuZGFyLFxuICAgICAgb3B0cy53ZWVrU2V0dGluZ3MsXG4gICAgICBvcHRzLmRlZmF1bHRUb0VOXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZTtcbiAgICAvLyB0aGUgc3lzdGVtIGxvY2FsZSBpcyB1c2VmdWwgZm9yIGh1bWFuLXJlYWRhYmxlIHN0cmluZ3MgYnV0IGFubm95aW5nIGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcga25vd24gZm9ybWF0c1xuICAgIGNvbnN0IGxvY2FsZVIgPSBzcGVjaWZpZWRMb2NhbGUgfHwgKGRlZmF1bHRUb0VOID8gXCJlbi1VU1wiIDogc3lzdGVtTG9jYWxlKCkpO1xuICAgIGNvbnN0IG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICBjb25zdCBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgY29uc3Qgd2Vla1NldHRpbmdzUiA9IHZhbGlkYXRlV2Vla1NldHRpbmdzKHdlZWtTZXR0aW5ncykgfHwgU2V0dGluZ3MuZGVmYXVsdFdlZWtTZXR0aW5ncztcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHdlZWtTZXR0aW5nc1IsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUuY2xlYXIoKTtcbiAgICBpbnRsTnVtQ2FjaGUuY2xlYXIoKTtcbiAgICBpbnRsUmVsQ2FjaGUuY2xlYXIoKTtcbiAgICBpbnRsUmVzb2x2ZWRPcHRpb25zQ2FjaGUuY2xlYXIoKTtcbiAgICB3ZWVrSW5mb0NhY2hlLmNsZWFyKCk7XG4gIH1cblxuICBzdGF0aWMgZnJvbU9iamVjdCh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgbnVtYmVyaW5nLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzLCBzcGVjaWZpZWRMb2NhbGUpIHtcbiAgICBjb25zdCBbcGFyc2VkTG9jYWxlLCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0sIHBhcnNlZE91dHB1dENhbGVuZGFyXSA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLndlZWtTZXR0aW5ncyA9IHdlZWtTZXR0aW5ncztcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG5cbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tb250aHNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGZhc3ROdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkO1xuICB9XG5cbiAgbGlzdGluZ01vZGUoKSB7XG4gICAgY29uc3QgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKTtcbiAgICBjb25zdCBoYXNOb1dlaXJkbmVzcyA9XG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJlxuICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuICAgIHJldHVybiBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MgPyBcImVuXCIgOiBcImludGxcIjtcbiAgfVxuXG4gIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICAgIGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLFxuICAgICAgICBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLFxuICAgICAgICB2YWxpZGF0ZVdlZWtTZXR0aW5ncyhhbHRzLndlZWtTZXR0aW5ncykgfHwgdGhpcy53ZWVrU2V0dGluZ3MsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgXCJqYVwiIGxvY2FsZTogZm9ybWF0VG9QYXJ0cyBkb2VzIG5vdCBsYWJlbCBhbGwgcGFydHMgb2YgdGhlIG1vbnRoXG4gICAgICAvLyBhcyBcIm1vbnRoXCIgYW5kIGZvciB0aGlzIGxvY2FsZSB0aGVyZSBpcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gXCJmb3JtYXRcIiBhbmQgXCJub24tZm9ybWF0XCIuXG4gICAgICAvLyBBcyBzdWNoLCBqdXN0IHVzZSBmb3JtYXQoKSBpbnN0ZWFkIG9mIGZvcm1hdFRvUGFydHMoKSBhbmQgdGFrZSB0aGUgd2hvbGUgc3RyaW5nXG4gICAgICBjb25zdCBtb250aFNwZWNpYWxDYXNlID0gdGhpcy5pbnRsID09PSBcImphXCIgfHwgdGhpcy5pbnRsLnN0YXJ0c1dpdGgoXCJqYS1cIik7XG4gICAgICBmb3JtYXQgJj0gIW1vbnRoU3BlY2lhbENhc2U7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0ID8geyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0gOiB7IG1vbnRoOiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSAhbW9udGhTcGVjaWFsQ2FzZVxuICAgICAgICAgID8gKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIilcbiAgICAgICAgICA6IChkdCkgPT4gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bCkuZm9ybWF0KCk7XG4gICAgICAgIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwTW9udGhzKG1hcHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICB3ZWVrZGF5cyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2gud2Vla2RheXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXRcbiAgICAgICAgICA/IHsgd2Vla2RheTogbGVuZ3RoLCB5ZWFyOiBcIm51bWVyaWNcIiwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH1cbiAgICAgICAgICA6IHsgd2Vla2RheTogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwV2Vla2RheXMoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJ3ZWVrZGF5XCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmlkaWVtcygpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKFxuICAgICAgdGhpcyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgICgpID0+IEVuZ2xpc2gubWVyaWRpZW1zLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBJbiB0aGVvcnkgdGhlcmUgY291bGQgYmUgYXJpYml0cmFyeSBkYXkgcGVyaW9kcy4gV2UncmUgZ29ubmEgYXNzdW1lIHRoZXJlIGFyZSBleGFjdGx5IHR3b1xuICAgICAgICAvLyBmb3IgQU0gYW5kIFBNLiBUaGlzIGlzIHByb2JhYmx5IHdyb25nLCBidXQgaXQncyBtYWtlcyBwYXJzaW5nIHdheSBlYXNpZXIuXG4gICAgICAgIGlmICghdGhpcy5tZXJpZGllbUNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgaW50bCA9IHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9O1xuICAgICAgICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IFtEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCA5KSwgRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgMTkpXS5tYXAoXG4gICAgICAgICAgICAoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJkYXlwZXJpb2RcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyaWRpZW1DYWNoZTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZXJhcyhsZW5ndGgpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC5lcmFzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0geyBlcmE6IGxlbmd0aCB9O1xuXG4gICAgICAvLyBUaGlzIGlzIHByb2JsZW1hdGljLiBEaWZmZXJlbnQgY2FsZW5kYXJzIGFyZSBnb2luZyB0byBkZWZpbmUgZXJhcyB0b3RhbGx5IGRpZmZlcmVudGx5LiBXaGF0IEkgbmVlZCBpcyB0aGUgbWluaW11bSBzZXQgb2YgZGF0ZXNcbiAgICAgIC8vIHRvIGRlZmluaXRlbHkgZW51bWVyYXRlIHRoZW0uXG4gICAgICBpZiAoIXRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLmVyYUNhY2hlW2xlbmd0aF0gPSBbRGF0ZVRpbWUudXRjKC00MCwgMSwgMSksIERhdGVUaW1lLnV0YygyMDE3LCAxLCAxKV0ubWFwKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZXJhXCIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVyYUNhY2hlW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBleHRyYWN0KGR0LCBpbnRsT3B0cywgZmllbGQpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzKSxcbiAgICAgIHJlc3VsdHMgPSBkZi5mb3JtYXRUb1BhcnRzKCksXG4gICAgICBtYXRjaGluZyA9IHJlc3VsdHMuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IGZpZWxkKTtcbiAgICByZXR1cm4gbWF0Y2hpbmcgPyBtYXRjaGluZy52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBudW1iZXJGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgLy8gdGhpcyBmb3JjZXNpbXBsZSBvcHRpb24gaXMgbmV2ZXIgdXNlZCAodGhlIG9ubHkgY2FsbGVyIHNob3J0LWNpcmN1aXRzIG9uIGl0LCBidXQgaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUpXG4gICAgLy8gKGluIGNvbnRyYXN0LCB0aGUgcmVzdCBvZiB0aGUgY29uZGl0aW9uIGlzIHVzZWQgaGVhdmlseSlcbiAgICByZXR1cm4gbmV3IFBvbHlOdW1iZXJGb3JtYXR0ZXIodGhpcy5pbnRsLCBvcHRzLmZvcmNlU2ltcGxlIHx8IHRoaXMuZmFzdE51bWJlcnMsIG9wdHMpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlEYXRlRm9ybWF0dGVyKGR0LCB0aGlzLmludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIHJlbEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlSZWxGb3JtYXR0ZXIodGhpcy5pbnRsLCB0aGlzLmlzRW5nbGlzaCgpLCBvcHRzKTtcbiAgfVxuXG4gIGxpc3RGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIGdldENhY2hlZExGKHRoaXMuaW50bCwgb3B0cyk7XG4gIH1cblxuICBpc0VuZ2xpc2goKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBcImVuXCIgfHxcbiAgICAgIHRoaXMubG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IFwiZW4tdXNcIiB8fFxuICAgICAgZ2V0Q2FjaGVkSW50UmVzb2x2ZWRPcHRpb25zKHRoaXMuaW50bCkubG9jYWxlLnN0YXJ0c1dpdGgoXCJlbi11c1wiKVxuICAgICk7XG4gIH1cblxuICBnZXRXZWVrU2V0dGluZ3MoKSB7XG4gICAgaWYgKHRoaXMud2Vla1NldHRpbmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy53ZWVrU2V0dGluZ3M7XG4gICAgfSBlbHNlIGlmICghaGFzTG9jYWxlV2Vla0luZm8oKSkge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrV2Vla1NldHRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0Q2FjaGVkV2Vla0luZm8odGhpcy5sb2NhbGUpO1xuICAgIH1cbiAgfVxuXG4gIGdldFN0YXJ0T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtTZXR0aW5ncygpLmZpcnN0RGF5O1xuICB9XG5cbiAgZ2V0TWluRGF5c0luRmlyc3RXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtTZXR0aW5ncygpLm1pbmltYWxEYXlzO1xuICB9XG5cbiAgZ2V0V2Vla2VuZERheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1NldHRpbmdzKCkud2Vla2VuZDtcbiAgfVxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gb3RoZXIubG9jYWxlICYmXG4gICAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gb3RoZXIubnVtYmVyaW5nU3lzdGVtICYmXG4gICAgICB0aGlzLm91dHB1dENhbGVuZGFyID09PSBvdGhlci5vdXRwdXRDYWxlbmRhclxuICAgICk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYExvY2FsZSgke3RoaXMubG9jYWxlfSwgJHt0aGlzLm51bWJlcmluZ1N5c3RlbX0sICR7dGhpcy5vdXRwdXRDYWxlbmRhcn0pYDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/regexParser.js":
/*!**********************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/regexParser.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseHTTPDate: () => (/* binding */ parseHTTPDate),\n/* harmony export */   parseISODate: () => (/* binding */ parseISODate),\n/* harmony export */   parseISODuration: () => (/* binding */ parseISODuration),\n/* harmony export */   parseISOTimeOnly: () => (/* binding */ parseISOTimeOnly),\n/* harmony export */   parseRFC2822Date: () => (/* binding */ parseRFC2822Date),\n/* harmony export */   parseSQL: () => (/* binding */ parseSQL)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */\n\nconst ianaRegex = /[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;\n\nfunction combineRegexes(...regexes) {\n  const full = regexes.reduce((f, r) => f + r.source, \"\");\n  return RegExp(`^${full}$`);\n}\n\nfunction combineExtractors(...extractors) {\n  return (m) =>\n    extractors\n      .reduce(\n        ([mergedVals, mergedZone, cursor], ex) => {\n          const [val, zone, next] = ex(m, cursor);\n          return [{ ...mergedVals, ...val }, zone || mergedZone, next];\n        },\n        [{}, null, 1]\n      )\n      .slice(0, 2);\n}\n\nfunction parse(s, ...patterns) {\n  if (s == null) {\n    return [null, null];\n  }\n\n  for (const [regex, extractor] of patterns) {\n    const m = regex.exec(s);\n    if (m) {\n      return extractor(m);\n    }\n  }\n  return [null, null];\n}\n\nfunction simpleParse(...keys) {\n  return (match, cursor) => {\n    const ret = {};\n    let i;\n\n    for (i = 0; i < keys.length; i++) {\n      ret[keys[i]] = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(match[cursor + i]);\n    }\n    return [ret, null, cursor + i];\n  };\n}\n\n// ISO and SQL parsing\nconst offsetRegex = /(?:([Zz])|([+-]\\d\\d)(?::?(\\d\\d))?)/;\nconst isoExtendedZone = `(?:${offsetRegex.source}?(?:\\\\[(${ianaRegex.source})\\\\])?)?`;\nconst isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/;\nconst isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);\nconst isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);\nconst isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/;\nconst isoWeekRegex = /(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/;\nconst isoOrdinalRegex = /(\\d{4})-?(\\d{3})/;\nconst extractISOWeekData = simpleParse(\"weekYear\", \"weekNumber\", \"weekDay\");\nconst extractISOOrdinalData = simpleParse(\"year\", \"ordinal\");\nconst sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/; // dumbed-down version of the ISO one\nconst sqlTimeRegex = RegExp(\n  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`\n);\nconst sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);\n\nfunction int(match, pos, fallback) {\n  const m = match[pos];\n  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(m) ? fallback : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(m);\n}\n\nfunction extractISOYmd(match, cursor) {\n  const item = {\n    year: int(match, cursor),\n    month: int(match, cursor + 1, 1),\n    day: int(match, cursor + 2, 1),\n  };\n\n  return [item, null, cursor + 3];\n}\n\nfunction extractISOTime(match, cursor) {\n  const item = {\n    hours: int(match, cursor, 0),\n    minutes: int(match, cursor + 1, 0),\n    seconds: int(match, cursor + 2, 0),\n    milliseconds: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(match[cursor + 3]),\n  };\n\n  return [item, null, cursor + 4];\n}\n\nfunction extractISOOffset(match, cursor) {\n  const local = !match[cursor] && !match[cursor + 1],\n    fullOffset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(match[cursor + 1], match[cursor + 2]),\n    zone = local ? null : _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(fullOffset);\n  return [{}, zone, cursor + 3];\n}\n\nfunction extractIANAZone(match, cursor) {\n  const zone = match[cursor] ? _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(match[cursor]) : null;\n  return [{}, zone, cursor + 1];\n}\n\n// ISO time parsing\n\nconst isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);\n\n// ISO duration parsing\n\nconst isoDuration =\n  /^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;\n\nfunction extractISODuration(match) {\n  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =\n    match;\n\n  const hasNegativePrefix = s[0] === \"-\";\n  const negativeSeconds = secondStr && secondStr[0] === \"-\";\n\n  const maybeNegate = (num, force = false) =>\n    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;\n\n  return [\n    {\n      years: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(yearStr)),\n      months: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(monthStr)),\n      weeks: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(weekStr)),\n      days: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(dayStr)),\n      hours: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(hourStr)),\n      minutes: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(minuteStr)),\n      seconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(secondStr), secondStr === \"-0\"),\n      milliseconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(millisecondsStr), negativeSeconds),\n    },\n  ];\n}\n\n// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\nconst obsOffsets = {\n  GMT: 0,\n  EDT: -4 * 60,\n  EST: -5 * 60,\n  CDT: -5 * 60,\n  CST: -6 * 60,\n  MDT: -6 * 60,\n  MST: -7 * 60,\n  PDT: -7 * 60,\n  PST: -8 * 60,\n};\n\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n  const result = {\n    year: yearStr.length === 2 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr)) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr),\n    month: _english_js__WEBPACK_IMPORTED_MODULE_1__.monthsShort.indexOf(monthStr) + 1,\n    day: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(dayStr),\n    hour: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(hourStr),\n    minute: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(minuteStr),\n  };\n\n  if (secondStr) result.second = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(secondStr);\n  if (weekdayStr) {\n    result.weekday =\n      weekdayStr.length > 3\n        ? _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysLong.indexOf(weekdayStr) + 1\n        : _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysShort.indexOf(weekdayStr) + 1;\n  }\n\n  return result;\n}\n\n// RFC 2822/5322\nconst rfc2822 =\n  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\n\nfunction extractRFC2822(match) {\n  const [\n      ,\n      weekdayStr,\n      dayStr,\n      monthStr,\n      yearStr,\n      hourStr,\n      minuteStr,\n      secondStr,\n      obsOffset,\n      milOffset,\n      offHourStr,\n      offMinuteStr,\n    ] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  let offset;\n  if (obsOffset) {\n    offset = obsOffsets[obsOffset];\n  } else if (milOffset) {\n    offset = 0;\n  } else {\n    offset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(offHourStr, offMinuteStr);\n  }\n\n  return [result, new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](offset)];\n}\n\nfunction preprocessRFC2822(s) {\n  // Remove comments and folding whitespace and replace multiple-spaces with a single space\n  return s\n    .replace(/\\([^()]*\\)|[\\n\\t]/g, \" \")\n    .replace(/(\\s\\s+)/g, \" \")\n    .trim();\n}\n\n// http date\n\nconst rfc1123 =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  rfc850 =\n    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  ascii =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\n\nfunction extractRFC1123Or850(match) {\n  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nfunction extractASCII(match) {\n  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nconst isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nconst isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);\nconst isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);\nconst isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\n\nconst extractISOYmdTimeAndOffset = combineExtractors(\n  extractISOYmd,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOWeekTimeAndOffset = combineExtractors(\n  extractISOWeekData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOOrdinalDateAndTime = combineExtractors(\n  extractISOOrdinalData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOTimeAndOffset = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\n/*\n * @private\n */\n\nfunction parseISODate(s) {\n  return parse(\n    s,\n    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],\n    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],\n    [isoTimeCombinedRegex, extractISOTimeAndOffset]\n  );\n}\n\nfunction parseRFC2822Date(s) {\n  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);\n}\n\nfunction parseHTTPDate(s) {\n  return parse(\n    s,\n    [rfc1123, extractRFC1123Or850],\n    [rfc850, extractRFC1123Or850],\n    [ascii, extractASCII]\n  );\n}\n\nfunction parseISODuration(s) {\n  return parse(s, [isoDuration, extractISODuration]);\n}\n\nconst extractISOTimeOnly = combineExtractors(extractISOTime);\n\nfunction parseISOTimeOnly(s) {\n  return parse(s, [isoTimeOnly, extractISOTimeOnly]);\n}\n\nconst sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nconst sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\n\nconst extractISOTimeOffsetAndIANAZone = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\nfunction parseSQL(s) {\n  return parse(\n    s,\n    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBT21CO0FBQ3FCO0FBQ2tCO0FBQ2Q7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRix3QkFBd0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsTUFBTSxzQkFBc0IsTUFBTSxvQkFBb0IsTUFBTTs7QUFFM0Y7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0MsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLHFCQUFxQixzREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQixVQUFVLGlCQUFpQjtBQUM1RSxpRUFBaUUsS0FBSztBQUN0RSwrQkFBK0Isd0JBQXdCLEVBQUUsZ0JBQWdCO0FBQ3pFLCtDQUErQyxvQkFBb0I7QUFDbkUsNkJBQTZCLEVBQUUsSUFBSSxFQUFFO0FBQ3JDLDBCQUEwQixFQUFFO0FBQzVCLDZCQUE2QixFQUFFLE9BQU8sRUFBRTtBQUN4QztBQUNBO0FBQ0EseUJBQXlCLEVBQUUsa0JBQWtCO0FBQzdDO0FBQ0EsS0FBSyx5QkFBeUIsTUFBTSxtQkFBbUIsSUFBSSxpQkFBaUI7QUFDNUU7QUFDQSw0Q0FBNEMsb0JBQW9COztBQUVoRTtBQUNBO0FBQ0EsU0FBUyxxREFBVyxpQkFBaUIsc0RBQVk7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBVztBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVk7QUFDN0IsMEJBQTBCLGlFQUFlO0FBQ3pDLFlBQVk7QUFDWjs7QUFFQTtBQUNBLCtCQUErQiwwREFBUTtBQUN2QyxZQUFZO0FBQ1o7O0FBRUE7O0FBRUEsaUNBQWlDLHdCQUF3Qjs7QUFFekQ7O0FBRUE7QUFDQSxtQkFBbUIsS0FBSyxRQUFRLEtBQUssZUFBZSxLQUFLLFFBQVEsS0FBSyxlQUFlLEtBQUssUUFBUSxLQUFLLGVBQWUsS0FBSyxRQUFRLEtBQUssbUJBQW1CLEtBQUssUUFBUSxLQUFLLGVBQWUsS0FBSyxRQUFRLEtBQUssZUFBZSxLQUFLLGNBQWMsS0FBSzs7QUFFclA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFhO0FBQ3RDLDBCQUEwQix1REFBYTtBQUN2Qyx5QkFBeUIsdURBQWE7QUFDdEMsd0JBQXdCLHVEQUFhO0FBQ3JDLHlCQUF5Qix1REFBYTtBQUN0QywyQkFBMkIsdURBQWE7QUFDeEMsMkJBQTJCLHVEQUFhO0FBQ3hDLGdDQUFnQyxxREFBVztBQUMzQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsd0RBQWMsQ0FBQyxzREFBWSxhQUFhLHNEQUFZO0FBQ3JGLFdBQVcsb0RBQW1CO0FBQzlCLFNBQVMsc0RBQVk7QUFDckIsVUFBVSxzREFBWTtBQUN0QixZQUFZLHNEQUFZO0FBQ3hCOztBQUVBLGlDQUFpQyxzREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFvQjtBQUM5QixVQUFVLHNEQUFxQjtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSSwwREFBMEQsSUFBSTs7QUFFL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGFBQWEsc0RBQVk7QUFDekI7O0FBRUEsc0JBQXNCLGlFQUFlO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0dBQWtHLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILEVBQUU7O0FBRTVIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBZTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3JlZ2V4UGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHVudHJ1bmNhdGVZZWFyLFxuICBzaWduZWRPZmZzZXQsXG4gIHBhcnNlSW50ZWdlcixcbiAgcGFyc2VNaWxsaXMsXG4gIGlzVW5kZWZpbmVkLFxuICBwYXJzZUZsb2F0aW5nLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vKlxuICogVGhpcyBmaWxlIGhhbmRsZXMgcGFyc2luZyBmb3Igd2VsbC1zcGVjaWZpZWQgZm9ybWF0cy4gSGVyZSdzIGhvdyBpdCB3b3JrczpcbiAqIFR3byB0aGluZ3MgZ28gaW50byBwYXJzaW5nOiBhIHJlZ2V4IHRvIG1hdGNoIHdpdGggYW5kIGFuIGV4dHJhY3RvciB0byB0YWtlIGFwYXJ0IHRoZSBncm91cHMgaW4gdGhlIG1hdGNoLlxuICogQW4gZXh0cmFjdG9yIGlzIGp1c3QgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcmVnZXggbWF0Y2ggYXJyYXkgYW5kIHJldHVybnMgYSB7IHllYXI6IC4uLiwgbW9udGg6IC4uLiB9IG9iamVjdFxuICogcGFyc2UoKSBkb2VzIHRoZSB3b3JrIG9mIGV4ZWN1dGluZyB0aGUgcmVnZXggYW5kIGFwcGx5aW5nIHRoZSBleHRyYWN0b3IuIEl0IHRha2VzIG11bHRpcGxlIHJlZ2V4L2V4dHJhY3RvciBwYWlycyB0byB0cnkgaW4gc2VxdWVuY2UuXG4gKiBFeHRyYWN0b3JzIGNhbiB0YWtlIGEgXCJjdXJzb3JcIiByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBpbiB0aGUgbWF0Y2ggdG8gbG9vayBhdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNvbWJpbmUgZXh0cmFjdG9ycy5cbiAqIGNvbWJpbmVFeHRyYWN0b3JzKCkgZG9lcyB0aGUgd29yayBvZiBjb21iaW5pbmcgdGhlbSwga2VlcGluZyB0cmFjayBvZiB0aGUgY3Vyc29yIHRocm91Z2ggbXVsdGlwbGUgZXh0cmFjdGlvbnMuXG4gKiBTb21lIGV4dHJhY3Rpb25zIGFyZSBzdXBlciBkdW1iIGFuZCBzaW1wbGVQYXJzZSBhbmQgZnJvbVN0cmluZ3MgaGVscCBEUlkgdGhlbS5cbiAqL1xuXG5jb25zdCBpYW5hUmVnZXggPSAvW0EtWmEtel8rLV17MSwyNTZ9KD86Oj9cXC9bQS1aYS16MC05XystXXsxLDI1Nn0oPzpcXC9bQS1aYS16MC05XystXXsxLDI1Nn0pPyk/LztcblxuZnVuY3Rpb24gY29tYmluZVJlZ2V4ZXMoLi4ucmVnZXhlcykge1xuICBjb25zdCBmdWxsID0gcmVnZXhlcy5yZWR1Y2UoKGYsIHIpID0+IGYgKyByLnNvdXJjZSwgXCJcIik7XG4gIHJldHVybiBSZWdFeHAoYF4ke2Z1bGx9JGApO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lRXh0cmFjdG9ycyguLi5leHRyYWN0b3JzKSB7XG4gIHJldHVybiAobSkgPT5cbiAgICBleHRyYWN0b3JzXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW21lcmdlZFZhbHMsIG1lcmdlZFpvbmUsIGN1cnNvcl0sIGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3ZhbCwgem9uZSwgbmV4dF0gPSBleChtLCBjdXJzb3IpO1xuICAgICAgICAgIHJldHVybiBbeyAuLi5tZXJnZWRWYWxzLCAuLi52YWwgfSwgem9uZSB8fCBtZXJnZWRab25lLCBuZXh0XTtcbiAgICAgICAgfSxcbiAgICAgICAgW3t9LCBudWxsLCAxXVxuICAgICAgKVxuICAgICAgLnNsaWNlKDAsIDIpO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzLCAuLi5wYXR0ZXJucykge1xuICBpZiAocyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIGZvciAoY29uc3QgW3JlZ2V4LCBleHRyYWN0b3JdIG9mIHBhdHRlcm5zKSB7XG4gICAgY29uc3QgbSA9IHJlZ2V4LmV4ZWMocyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHJldHVybiBleHRyYWN0b3IobSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbnVsbCwgbnVsbF07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVBhcnNlKC4uLmtleXMpIHtcbiAgcmV0dXJuIChtYXRjaCwgY3Vyc29yKSA9PiB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2tleXNbaV1dID0gcGFyc2VJbnRlZ2VyKG1hdGNoW2N1cnNvciArIGldKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXQsIG51bGwsIGN1cnNvciArIGldO1xuICB9O1xufVxuXG4vLyBJU08gYW5kIFNRTCBwYXJzaW5nXG5jb25zdCBvZmZzZXRSZWdleCA9IC8oPzooW1p6XSl8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/KS87XG5jb25zdCBpc29FeHRlbmRlZFpvbmUgPSBgKD86JHtvZmZzZXRSZWdleC5zb3VyY2V9Pyg/OlxcXFxbKCR7aWFuYVJlZ2V4LnNvdXJjZX0pXFxcXF0pPyk/YDtcbmNvbnN0IGlzb1RpbWVCYXNlUmVnZXggPSAvKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlsuLF0oXFxkezEsMzB9KSk/KT8pPy87XG5jb25zdCBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtpc29FeHRlbmRlZFpvbmV9YCk7XG5jb25zdCBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OltUdF0ke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKTtcbmNvbnN0IGlzb1ltZFJlZ2V4ID0gLyhbKy1dXFxkezZ9fFxcZHs0fSkoPzotPyhcXGRcXGQpKD86LT8oXFxkXFxkKSk/KT8vO1xuY29uc3QgaXNvV2Vla1JlZ2V4ID0gLyhcXGR7NH0pLT9XKFxcZFxcZCkoPzotPyhcXGQpKT8vO1xuY29uc3QgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS87XG5jb25zdCBleHRyYWN0SVNPV2Vla0RhdGEgPSBzaW1wbGVQYXJzZShcIndlZWtZZWFyXCIsIFwid2Vla051bWJlclwiLCBcIndlZWtEYXlcIik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGEgPSBzaW1wbGVQYXJzZShcInllYXJcIiwgXCJvcmRpbmFsXCIpO1xuY29uc3Qgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvOyAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG5jb25zdCBzcWxUaW1lUmVnZXggPSBSZWdFeHAoXG4gIGAke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSA/KD86JHtvZmZzZXRSZWdleC5zb3VyY2V9fCgke2lhbmFSZWdleC5zb3VyY2V9KSk/YFxuKTtcbmNvbnN0IHNxbFRpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86ICR7c3FsVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuXG5mdW5jdGlvbiBpbnQobWF0Y2gsIHBvcywgZmFsbGJhY2spIHtcbiAgY29uc3QgbSA9IG1hdGNoW3Bvc107XG4gIHJldHVybiBpc1VuZGVmaW5lZChtKSA/IGZhbGxiYWNrIDogcGFyc2VJbnRlZ2VyKG0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPWW1kKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICB5ZWFyOiBpbnQobWF0Y2gsIGN1cnNvciksXG4gICAgbW9udGg6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMSksXG4gICAgZGF5OiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDEpLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09UaW1lKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICBob3VyczogaW50KG1hdGNoLCBjdXJzb3IsIDApLFxuICAgIG1pbnV0ZXM6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMCksXG4gICAgc2Vjb25kczogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAwKSxcbiAgICBtaWxsaXNlY29uZHM6IHBhcnNlTWlsbGlzKG1hdGNoW2N1cnNvciArIDNdKSxcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDRdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPT2Zmc2V0KG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgbG9jYWwgPSAhbWF0Y2hbY3Vyc29yXSAmJiAhbWF0Y2hbY3Vyc29yICsgMV0sXG4gICAgZnVsbE9mZnNldCA9IHNpZ25lZE9mZnNldChtYXRjaFtjdXJzb3IgKyAxXSwgbWF0Y2hbY3Vyc29yICsgMl0pLFxuICAgIHpvbmUgPSBsb2NhbCA/IG51bGwgOiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoZnVsbE9mZnNldCk7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SUFOQVpvbmUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCB6b25lID0gbWF0Y2hbY3Vyc29yXSA/IElBTkFab25lLmNyZWF0ZShtYXRjaFtjdXJzb3JdKSA6IG51bGw7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDFdO1xufVxuXG4vLyBJU08gdGltZSBwYXJzaW5nXG5cbmNvbnN0IGlzb1RpbWVPbmx5ID0gUmVnRXhwKGBeVD8ke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSRgKTtcblxuLy8gSVNPIGR1cmF0aW9uIHBhcnNpbmdcblxuY29uc3QgaXNvRHVyYXRpb24gPVxuICAvXi0/UCg/Oig/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVkpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVcpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUQpPyg/OlQoPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylIKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylNKT8oPzooLT9cXGR7MSwyMH0pKD86Wy4sXSgtP1xcZHsxLDIwfSkpP1MpPyk/KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0SVNPRHVyYXRpb24obWF0Y2gpIHtcbiAgY29uc3QgW3MsIHllYXJTdHIsIG1vbnRoU3RyLCB3ZWVrU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCBtaWxsaXNlY29uZHNTdHJdID1cbiAgICBtYXRjaDtcblxuICBjb25zdCBoYXNOZWdhdGl2ZVByZWZpeCA9IHNbMF0gPT09IFwiLVwiO1xuICBjb25zdCBuZWdhdGl2ZVNlY29uZHMgPSBzZWNvbmRTdHIgJiYgc2Vjb25kU3RyWzBdID09PSBcIi1cIjtcblxuICBjb25zdCBtYXliZU5lZ2F0ZSA9IChudW0sIGZvcmNlID0gZmFsc2UpID0+XG4gICAgbnVtICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IChudW0gJiYgaGFzTmVnYXRpdmVQcmVmaXgpKSA/IC1udW0gOiBudW07XG5cbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB5ZWFyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh5ZWFyU3RyKSksXG4gICAgICBtb250aHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobW9udGhTdHIpKSxcbiAgICAgIHdlZWtzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHdlZWtTdHIpKSxcbiAgICAgIGRheXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoZGF5U3RyKSksXG4gICAgICBob3VyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhob3VyU3RyKSksXG4gICAgICBtaW51dGVzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1pbnV0ZVN0cikpLFxuICAgICAgc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhzZWNvbmRTdHIpLCBzZWNvbmRTdHIgPT09IFwiLTBcIiksXG4gICAgICBtaWxsaXNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlTWlsbGlzKG1pbGxpc2Vjb25kc1N0ciksIG5lZ2F0aXZlU2Vjb25kcyksXG4gICAgfSxcbiAgXTtcbn1cblxuLy8gVGhlc2UgYXJlIGEgbGl0dGxlIGJyYWluZGVhZC4gRURUICpzaG91bGQqIHRlbGwgdXMgdGhhdCB3ZSdyZSBpbiwgc2F5LCBBbWVyaWNhL05ld19Zb3JrXG4vLyBhbmQgbm90IGp1c3QgdGhhdCB3ZSdyZSBpbiAtMjQwICpyaWdodCBub3cqLiBCdXQgc2luY2UgSSBkb24ndCB0aGluayB0aGVzZSBhcmUgdXNlZCB0aGF0IG9mdGVuXG4vLyBJJ20ganVzdCBnb2luZyB0byBpZ25vcmUgdGhhdFxuY29uc3Qgb2JzT2Zmc2V0cyA9IHtcbiAgR01UOiAwLFxuICBFRFQ6IC00ICogNjAsXG4gIEVTVDogLTUgKiA2MCxcbiAgQ0RUOiAtNSAqIDYwLFxuICBDU1Q6IC02ICogNjAsXG4gIE1EVDogLTYgKiA2MCxcbiAgTVNUOiAtNyAqIDYwLFxuICBQRFQ6IC03ICogNjAsXG4gIFBTVDogLTggKiA2MCxcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB5ZWFyOiB5ZWFyU3RyLmxlbmd0aCA9PT0gMiA/IHVudHJ1bmNhdGVZZWFyKHBhcnNlSW50ZWdlcih5ZWFyU3RyKSkgOiBwYXJzZUludGVnZXIoeWVhclN0ciksXG4gICAgbW9udGg6IEVuZ2xpc2gubW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0cikgKyAxLFxuICAgIGRheTogcGFyc2VJbnRlZ2VyKGRheVN0ciksXG4gICAgaG91cjogcGFyc2VJbnRlZ2VyKGhvdXJTdHIpLFxuICAgIG1pbnV0ZTogcGFyc2VJbnRlZ2VyKG1pbnV0ZVN0ciksXG4gIH07XG5cbiAgaWYgKHNlY29uZFN0cikgcmVzdWx0LnNlY29uZCA9IHBhcnNlSW50ZWdlcihzZWNvbmRTdHIpO1xuICBpZiAod2Vla2RheVN0cikge1xuICAgIHJlc3VsdC53ZWVrZGF5ID1cbiAgICAgIHdlZWtkYXlTdHIubGVuZ3RoID4gM1xuICAgICAgICA/IEVuZ2xpc2gud2Vla2RheXNMb25nLmluZGV4T2Yod2Vla2RheVN0cikgKyAxXG4gICAgICAgIDogRW5nbGlzaC53ZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0cikgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gUkZDIDI4MjIvNTMyMlxuY29uc3QgcmZjMjgyMiA9XG4gIC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksXFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfCg/OihbKy1dXFxkXFxkKShcXGRcXGQpKSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzI4MjIobWF0Y2gpIHtcbiAgY29uc3QgW1xuICAgICAgLFxuICAgICAgd2Vla2RheVN0cixcbiAgICAgIGRheVN0cixcbiAgICAgIG1vbnRoU3RyLFxuICAgICAgeWVhclN0cixcbiAgICAgIGhvdXJTdHIsXG4gICAgICBtaW51dGVTdHIsXG4gICAgICBzZWNvbmRTdHIsXG4gICAgICBvYnNPZmZzZXQsXG4gICAgICBtaWxPZmZzZXQsXG4gICAgICBvZmZIb3VyU3RyLFxuICAgICAgb2ZmTWludXRlU3RyLFxuICAgIF0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG5cbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9ic09mZnNldCkge1xuICAgIG9mZnNldCA9IG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgfSBlbHNlIGlmIChtaWxPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpO1xuICB9XG5cbiAgcmV0dXJuIFtyZXN1bHQsIG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KV07XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKVxuICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cblxuLy8gaHR0cCBkYXRlXG5cbmNvbnN0IHJmYzExMjMgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9XG4gICAgL14oTW9uZGF5fFR1ZXNkYXl8V2VkbmVzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheXxTdW5kYXkpLCAoXFxkXFxkKS0oSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLShcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICBhc2NpaSA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICggXFxkfFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgKFxcZHs0fSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzExMjNPcjg1MChtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBkYXlTdHIsIG1vbnRoU3RyLCB5ZWFyU3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QVNDSUkobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIHllYXJTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuY29uc3QgaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1ltZFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29XZWVrUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb09yZGluYWxSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1RpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1ltZCxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPV2Vla0RhdGEsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09PcmRpbmFsRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbi8qXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWVdLFxuICAgIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW3JmYzg1MCwgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW2FzY2lpLCBleHRyYWN0QVNDSUldXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0R1cmF0aW9uKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29EdXJhdGlvbiwgZXh0cmFjdElTT0R1cmF0aW9uXSk7XG59XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT25seSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPVGltZU9ubHkocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1RpbWVPbmx5LCBleHRyYWN0SVNPVGltZU9ubHldKTtcbn1cblxuY29uc3Qgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3Qgc3FsVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxUaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNRTChzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW3NxbFRpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lXVxuICApO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/regexParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/tokenParser.js":
/*!**********************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/tokenParser.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TokenParser: () => (/* binding */ TokenParser),\n/* harmony export */   expandMacroTokens: () => (/* binding */ expandMacroTokens),\n/* harmony export */   explainFromTokens: () => (/* binding */ explainFromTokens),\n/* harmony export */   formatOptsToTokens: () => (/* binding */ formatOptsToTokens),\n/* harmony export */   parseFromTokens: () => (/* binding */ parseFromTokens)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _digits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./digits.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/digits.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\");\n\n\n\n\n\n\n\n\nconst MISSING_FTP = \"missing Intl.DateTimeFormat.formatToParts support\";\n\nfunction intUnit(regex, post = (i) => i) {\n  return { regex, deser: ([s]) => post((0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.parseDigits)(s)) };\n}\n\nconst NBSP = String.fromCharCode(160);\nconst spaceOrNBSP = `[ ${NBSP}]`;\nconst spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, \"g\");\n\nfunction fixListRegex(s) {\n  // make dots optional and also make them literal\n  // make space and non breakable space characters interchangeable\n  return s.replace(/\\./g, \"\\\\.?\").replace(spaceOrNBSPRegExp, spaceOrNBSP);\n}\n\nfunction stripInsensitivities(s) {\n  return s\n    .replace(/\\./g, \"\") // ignore dots that were made optional\n    .replace(spaceOrNBSPRegExp, \" \") // interchange space and nbsp\n    .toLowerCase();\n}\n\nfunction oneOf(strings, startIndex) {\n  if (strings === null) {\n    return null;\n  } else {\n    return {\n      regex: RegExp(strings.map(fixListRegex).join(\"|\")),\n      deser: ([s]) =>\n        strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,\n    };\n  }\n}\n\nfunction offset(regex, groups) {\n  return { regex, deser: ([, h, m]) => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(h, m), groups };\n}\n\nfunction simple(regex) {\n  return { regex, deser: ([s]) => s };\n}\n\nfunction escapeToken(value) {\n  return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n\n/**\n * @param token\n * @param {Locale} loc\n */\nfunction unitForToken(token, loc) {\n  const one = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc),\n    two = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2}\"),\n    three = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{3}\"),\n    four = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4}\"),\n    six = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{6}\"),\n    oneOrTwo = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,2}\"),\n    oneToThree = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,3}\"),\n    oneToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,6}\"),\n    oneToNine = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,9}\"),\n    twoToFour = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2,4}\"),\n    fourToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4,6}\"),\n    literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),\n    unitate = (t) => {\n      if (token.literal) {\n        return literal(t);\n      }\n      switch (t.val) {\n        // era\n        case \"G\":\n          return oneOf(loc.eras(\"short\"), 0);\n        case \"GG\":\n          return oneOf(loc.eras(\"long\"), 0);\n        // years\n        case \"y\":\n          return intUnit(oneToSix);\n        case \"yy\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        case \"yyyy\":\n          return intUnit(four);\n        case \"yyyyy\":\n          return intUnit(fourToSix);\n        case \"yyyyyy\":\n          return intUnit(six);\n        // months\n        case \"M\":\n          return intUnit(oneOrTwo);\n        case \"MM\":\n          return intUnit(two);\n        case \"MMM\":\n          return oneOf(loc.months(\"short\", true), 1);\n        case \"MMMM\":\n          return oneOf(loc.months(\"long\", true), 1);\n        case \"L\":\n          return intUnit(oneOrTwo);\n        case \"LL\":\n          return intUnit(two);\n        case \"LLL\":\n          return oneOf(loc.months(\"short\", false), 1);\n        case \"LLLL\":\n          return oneOf(loc.months(\"long\", false), 1);\n        // dates\n        case \"d\":\n          return intUnit(oneOrTwo);\n        case \"dd\":\n          return intUnit(two);\n        // ordinals\n        case \"o\":\n          return intUnit(oneToThree);\n        case \"ooo\":\n          return intUnit(three);\n        // time\n        case \"HH\":\n          return intUnit(two);\n        case \"H\":\n          return intUnit(oneOrTwo);\n        case \"hh\":\n          return intUnit(two);\n        case \"h\":\n          return intUnit(oneOrTwo);\n        case \"mm\":\n          return intUnit(two);\n        case \"m\":\n          return intUnit(oneOrTwo);\n        case \"q\":\n          return intUnit(oneOrTwo);\n        case \"qq\":\n          return intUnit(two);\n        case \"s\":\n          return intUnit(oneOrTwo);\n        case \"ss\":\n          return intUnit(two);\n        case \"S\":\n          return intUnit(oneToThree);\n        case \"SSS\":\n          return intUnit(three);\n        case \"u\":\n          return simple(oneToNine);\n        case \"uu\":\n          return simple(oneOrTwo);\n        case \"uuu\":\n          return intUnit(one);\n        // meridiem\n        case \"a\":\n          return oneOf(loc.meridiems(), 0);\n        // weekYear (k)\n        case \"kkkk\":\n          return intUnit(four);\n        case \"kk\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        // weekNumber (W)\n        case \"W\":\n          return intUnit(oneOrTwo);\n        case \"WW\":\n          return intUnit(two);\n        // weekdays\n        case \"E\":\n        case \"c\":\n          return intUnit(one);\n        case \"EEE\":\n          return oneOf(loc.weekdays(\"short\", false), 1);\n        case \"EEEE\":\n          return oneOf(loc.weekdays(\"long\", false), 1);\n        case \"ccc\":\n          return oneOf(loc.weekdays(\"short\", true), 1);\n        case \"cccc\":\n          return oneOf(loc.weekdays(\"long\", true), 1);\n        // offset/zone\n        case \"Z\":\n        case \"ZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);\n        case \"ZZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);\n        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing\n        // because we don't have any way to figure out what they are\n        case \"z\":\n          return simple(/[a-z_+-/]{1,256}?/i);\n        // this special-case \"token\" represents a place where a macro-token expanded into a white-space literal\n        // in this case we accept any non-newline white-space\n        case \" \":\n          return simple(/[^\\S\\n\\r]/);\n        default:\n          return literal(t);\n      }\n    };\n\n  const unit = unitate(token) || {\n    invalidReason: MISSING_FTP,\n  };\n\n  unit.token = token;\n\n  return unit;\n}\n\nconst partTypeStyleToTokenVal = {\n  year: {\n    \"2-digit\": \"yy\",\n    numeric: \"yyyyy\",\n  },\n  month: {\n    numeric: \"M\",\n    \"2-digit\": \"MM\",\n    short: \"MMM\",\n    long: \"MMMM\",\n  },\n  day: {\n    numeric: \"d\",\n    \"2-digit\": \"dd\",\n  },\n  weekday: {\n    short: \"EEE\",\n    long: \"EEEE\",\n  },\n  dayperiod: \"a\",\n  dayPeriod: \"a\",\n  hour12: {\n    numeric: \"h\",\n    \"2-digit\": \"hh\",\n  },\n  hour24: {\n    numeric: \"H\",\n    \"2-digit\": \"HH\",\n  },\n  minute: {\n    numeric: \"m\",\n    \"2-digit\": \"mm\",\n  },\n  second: {\n    numeric: \"s\",\n    \"2-digit\": \"ss\",\n  },\n  timeZoneName: {\n    long: \"ZZZZZ\",\n    short: \"ZZZ\",\n  },\n};\n\nfunction tokenForPart(part, formatOpts, resolvedOpts) {\n  const { type, value } = part;\n\n  if (type === \"literal\") {\n    const isSpace = /^\\s+$/.test(value);\n    return {\n      literal: !isSpace,\n      val: isSpace ? \" \" : value,\n    };\n  }\n\n  const style = formatOpts[type];\n\n  // The user might have explicitly specified hour12 or hourCycle\n  // if so, respect their decision\n  // if not, refer back to the resolvedOpts, which are based on the locale\n  let actualType = type;\n  if (type === \"hour\") {\n    if (formatOpts.hour12 != null) {\n      actualType = formatOpts.hour12 ? \"hour12\" : \"hour24\";\n    } else if (formatOpts.hourCycle != null) {\n      if (formatOpts.hourCycle === \"h11\" || formatOpts.hourCycle === \"h12\") {\n        actualType = \"hour12\";\n      } else {\n        actualType = \"hour24\";\n      }\n    } else {\n      // tokens only differentiate between 24 hours or not,\n      // so we do not need to check hourCycle here, which is less supported anyways\n      actualType = resolvedOpts.hour12 ? \"hour12\" : \"hour24\";\n    }\n  }\n  let val = partTypeStyleToTokenVal[actualType];\n  if (typeof val === \"object\") {\n    val = val[style];\n  }\n\n  if (val) {\n    return {\n      literal: false,\n      val,\n    };\n  }\n\n  return undefined;\n}\n\nfunction buildRegex(units) {\n  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, \"\");\n  return [`^${re}$`, units];\n}\n\nfunction match(input, regex, handlers) {\n  const matches = input.match(regex);\n\n  if (matches) {\n    const all = {};\n    let matchIndex = 1;\n    for (const i in handlers) {\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(handlers, i)) {\n        const h = handlers[i],\n          groups = h.groups ? h.groups + 1 : 1;\n        if (!h.literal && h.token) {\n          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));\n        }\n        matchIndex += groups;\n      }\n    }\n    return [matches, all];\n  } else {\n    return [matches, {}];\n  }\n}\n\nfunction dateTimeFromMatches(matches) {\n  const toField = (token) => {\n    switch (token) {\n      case \"S\":\n        return \"millisecond\";\n      case \"s\":\n        return \"second\";\n      case \"m\":\n        return \"minute\";\n      case \"h\":\n      case \"H\":\n        return \"hour\";\n      case \"d\":\n        return \"day\";\n      case \"o\":\n        return \"ordinal\";\n      case \"L\":\n      case \"M\":\n        return \"month\";\n      case \"y\":\n        return \"year\";\n      case \"E\":\n      case \"c\":\n        return \"weekday\";\n      case \"W\":\n        return \"weekNumber\";\n      case \"k\":\n        return \"weekYear\";\n      case \"q\":\n        return \"quarter\";\n      default:\n        return null;\n    }\n  };\n\n  let zone = null;\n  let specificOffset;\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.z)) {\n    zone = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(matches.z);\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.Z)) {\n    if (!zone) {\n      zone = new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matches.Z);\n    }\n    specificOffset = matches.Z;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.q)) {\n    matches.M = (matches.q - 1) * 3 + 1;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.h)) {\n    if (matches.h < 12 && matches.a === 1) {\n      matches.h += 12;\n    } else if (matches.h === 12 && matches.a === 0) {\n      matches.h = 0;\n    }\n  }\n\n  if (matches.G === 0 && matches.y) {\n    matches.y = -matches.y;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.u)) {\n    matches.S = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(matches.u);\n  }\n\n  const vals = Object.keys(matches).reduce((r, k) => {\n    const f = toField(k);\n    if (f) {\n      r[f] = matches[k];\n    }\n\n    return r;\n  }, {});\n\n  return [vals, zone, specificOffset];\n}\n\nlet dummyDateTimeCache = null;\n\nfunction getDummyDateTime() {\n  if (!dummyDateTimeCache) {\n    dummyDateTimeCache = _datetime_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromMillis(1555555555555);\n  }\n\n  return dummyDateTimeCache;\n}\n\nfunction maybeExpandMacroToken(token, locale) {\n  if (token.literal) {\n    return token;\n  }\n\n  const formatOpts = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].macroTokenToFormatOpts(token.val);\n  const tokens = formatOptsToTokens(formatOpts, locale);\n\n  if (tokens == null || tokens.includes(undefined)) {\n    return token;\n  }\n\n  return tokens;\n}\n\nfunction expandMacroTokens(tokens, locale) {\n  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));\n}\n\n/**\n * @private\n */\n\nclass TokenParser {\n  constructor(locale, format) {\n    this.locale = locale;\n    this.format = format;\n    this.tokens = expandMacroTokens(_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parseFormat(format), locale);\n    this.units = this.tokens.map((t) => unitForToken(t, locale));\n    this.disqualifyingUnit = this.units.find((t) => t.invalidReason);\n\n    if (!this.disqualifyingUnit) {\n      const [regexString, handlers] = buildRegex(this.units);\n      this.regex = RegExp(regexString, \"i\");\n      this.handlers = handlers;\n    }\n  }\n\n  explainFromTokens(input) {\n    if (!this.isValid) {\n      return { input, tokens: this.tokens, invalidReason: this.invalidReason };\n    } else {\n      const [rawMatches, matches] = match(input, this.regex, this.handlers),\n        [result, zone, specificOffset] = matches\n          ? dateTimeFromMatches(matches)\n          : [null, null, undefined];\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"a\") && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"H\")) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\n          \"Can't include meridiem when specifying 24-hour format\"\n        );\n      }\n      return {\n        input,\n        tokens: this.tokens,\n        regex: this.regex,\n        rawMatches,\n        matches,\n        result,\n        zone,\n        specificOffset,\n      };\n    }\n  }\n\n  get isValid() {\n    return !this.disqualifyingUnit;\n  }\n\n  get invalidReason() {\n    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;\n  }\n}\n\nfunction explainFromTokens(locale, input, format) {\n  const parser = new TokenParser(locale, format);\n  return parser.explainFromTokens(input);\n}\n\nfunction parseFromTokens(locale, input, format) {\n  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);\n  return [result, zone, specificOffset, invalidReason];\n}\n\nfunction formatOptsToTokens(formatOpts, locale) {\n  if (!formatOpts) {\n    return null;\n  }\n\n  const formatter = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(locale, formatOpts);\n  const df = formatter.dtFormatter(getDummyDateTime());\n  const parts = df.formatToParts();\n  const resolvedOpts = df.resolvedOptions();\n  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC90b2tlblBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUc7QUFDNUQ7QUFDbUI7QUFDZDtBQUNOO0FBQ2dCO0FBQ087O0FBRTdEOztBQUVBO0FBQ0EsV0FBVyw0QkFBNEIsdURBQVc7QUFDbEQ7O0FBRUE7QUFDQSx5QkFBeUIsS0FBSztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDRCQUE0QixzREFBWTtBQUNuRDs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxjQUFjLHNEQUFVO0FBQ3hCLFVBQVUsc0RBQVUsUUFBUSxFQUFFO0FBQzlCLFlBQVksc0RBQVUsUUFBUSxFQUFFO0FBQ2hDLFdBQVcsc0RBQVUsUUFBUSxFQUFFO0FBQy9CLFVBQVUsc0RBQVUsUUFBUSxFQUFFO0FBQzlCLGVBQWUsc0RBQVUsUUFBUSxJQUFJO0FBQ3JDLGlCQUFpQixzREFBVSxRQUFRLElBQUk7QUFDdkMsZUFBZSxzREFBVSxRQUFRLElBQUk7QUFDckMsZ0JBQWdCLHNEQUFVLFFBQVEsSUFBSTtBQUN0QyxnQkFBZ0Isc0RBQVUsUUFBUSxJQUFJO0FBQ3RDLGdCQUFnQixzREFBVSxRQUFRLElBQUk7QUFDdEMsd0JBQXdCLHFFQUFxRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9EQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNB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QUF5QixvREFBUTtBQUNqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxREFBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFEQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBYyxrQkFBa0Isd0RBQWM7QUFDeEQsa0JBQWtCLHFFQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSw4Q0FBOEM7QUFDeEQ7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscURBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC90b2tlblBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBwb3N0KHBhcnNlRGlnaXRzKHMpKSB9O1xufVxuXG5jb25zdCBOQlNQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApO1xuY29uc3Qgc3BhY2VPck5CU1AgPSBgWyAke05CU1B9XWA7XG5jb25zdCBzcGFjZU9yTkJTUFJlZ0V4cCA9IG5ldyBSZWdFeHAoc3BhY2VPck5CU1AsIFwiZ1wiKTtcblxuZnVuY3Rpb24gZml4TGlzdFJlZ2V4KHMpIHtcbiAgLy8gbWFrZSBkb3RzIG9wdGlvbmFsIGFuZCBhbHNvIG1ha2UgdGhlbSBsaXRlcmFsXG4gIC8vIG1ha2Ugc3BhY2UgYW5kIG5vbiBicmVha2FibGUgc3BhY2UgY2hhcmFjdGVycyBpbnRlcmNoYW5nZWFibGVcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFwuL2csIFwiXFxcXC4/XCIpLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIHNwYWNlT3JOQlNQKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykge1xuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXC4vZywgXCJcIikgLy8gaWdub3JlIGRvdHMgdGhhdCB3ZXJlIG1hZGUgb3B0aW9uYWxcbiAgICAucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgXCIgXCIpIC8vIGludGVyY2hhbmdlIHNwYWNlIGFuZCBuYnNwXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG9uZU9mKHN0cmluZ3MsIHN0YXJ0SW5kZXgpIHtcbiAgaWYgKHN0cmluZ3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnZXg6IFJlZ0V4cChzdHJpbmdzLm1hcChmaXhMaXN0UmVnZXgpLmpvaW4oXCJ8XCIpKSxcbiAgICAgIGRlc2VyOiAoW3NdKSA9PlxuICAgICAgICBzdHJpbmdzLmZpbmRJbmRleCgoaSkgPT4gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykgPT09IHN0cmlwSW5zZW5zaXRpdml0aWVzKGkpKSArIHN0YXJ0SW5kZXgsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZzZXQocmVnZXgsIGdyb3Vwcykge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbLCBoLCBtXSkgPT4gc2lnbmVkT2Zmc2V0KGgsIG0pLCBncm91cHMgfTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlKHJlZ2V4KSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcyB9O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVUb2tlbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0b2tlblxuICogQHBhcmFtIHtMb2NhbGV9IGxvY1xuICovXG5mdW5jdGlvbiB1bml0Rm9yVG9rZW4odG9rZW4sIGxvYykge1xuICBjb25zdCBvbmUgPSBkaWdpdFJlZ2V4KGxvYyksXG4gICAgdHdvID0gZGlnaXRSZWdleChsb2MsIFwiezJ9XCIpLFxuICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgIGZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NH1cIiksXG4gICAgc2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezZ9XCIpLFxuICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgb25lVG9UaHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDN9XCIpLFxuICAgIG9uZVRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezEsNn1cIiksXG4gICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgdHdvVG9Gb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezIsNH1cIiksXG4gICAgZm91clRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezQsNn1cIiksXG4gICAgbGl0ZXJhbCA9ICh0KSA9PiAoeyByZWdleDogUmVnRXhwKGVzY2FwZVRva2VuKHQudmFsKSksIGRlc2VyOiAoW3NdKSA9PiBzLCBsaXRlcmFsOiB0cnVlIH0pLFxuICAgIHVuaXRhdGUgPSAodCkgPT4ge1xuICAgICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHQudmFsKSB7XG4gICAgICAgIC8vIGVyYVxuICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcInNob3J0XCIpLCAwKTtcbiAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwibG9uZ1wiKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBkYXRlc1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gb3JkaW5hbHNcbiAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgLy8gdGltZVxuICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVUb05pbmUpO1xuICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIC8vIG1lcmlkaWVtXG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tZXJpZGllbXMoKSwgMCk7XG4gICAgICAgIC8vIHdlZWtZZWFyIChrKVxuICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgLy8gd2Vla051bWJlciAoVylcbiAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIHdlZWtkYXlzXG4gICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgLy8gb2Zmc2V0L3pvbmVcbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoPzo6KCR7dHdvLnNvdXJjZX0pKT9gKSwgMik7XG4gICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSgke3R3by5zb3VyY2V9KT9gKSwgMik7XG4gICAgICAgIC8vIHdlIGRvbid0IHN1cHBvcnQgWlpaWiAoUFNUKSBvciBaWlpaWiAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKSBpbiBwYXJzaW5nXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGFyZVxuICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1thLXpfKy0vXXsxLDI1Nn0/L2kpO1xuICAgICAgICAvLyB0aGlzIHNwZWNpYWwtY2FzZSBcInRva2VuXCIgcmVwcmVzZW50cyBhIHBsYWNlIHdoZXJlIGEgbWFjcm8tdG9rZW4gZXhwYW5kZWQgaW50byBhIHdoaXRlLXNwYWNlIGxpdGVyYWxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGFjY2VwdCBhbnkgbm9uLW5ld2xpbmUgd2hpdGUtc3BhY2VcbiAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bXlxcU1xcblxccl0vKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGNvbnN0IHVuaXQgPSB1bml0YXRlKHRva2VuKSB8fCB7XG4gICAgaW52YWxpZFJlYXNvbjogTUlTU0lOR19GVFAsXG4gIH07XG5cbiAgdW5pdC50b2tlbiA9IHRva2VuO1xuXG4gIHJldHVybiB1bml0O1xufVxuXG5jb25zdCBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbCA9IHtcbiAgeWVhcjoge1xuICAgIFwiMi1kaWdpdFwiOiBcInl5XCIsXG4gICAgbnVtZXJpYzogXCJ5eXl5eVwiLFxuICB9LFxuICBtb250aDoge1xuICAgIG51bWVyaWM6IFwiTVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIk1NXCIsXG4gICAgc2hvcnQ6IFwiTU1NXCIsXG4gICAgbG9uZzogXCJNTU1NXCIsXG4gIH0sXG4gIGRheToge1xuICAgIG51bWVyaWM6IFwiZFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImRkXCIsXG4gIH0sXG4gIHdlZWtkYXk6IHtcbiAgICBzaG9ydDogXCJFRUVcIixcbiAgICBsb25nOiBcIkVFRUVcIixcbiAgfSxcbiAgZGF5cGVyaW9kOiBcImFcIixcbiAgZGF5UGVyaW9kOiBcImFcIixcbiAgaG91cjEyOiB7XG4gICAgbnVtZXJpYzogXCJoXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiaGhcIixcbiAgfSxcbiAgaG91cjI0OiB7XG4gICAgbnVtZXJpYzogXCJIXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiSEhcIixcbiAgfSxcbiAgbWludXRlOiB7XG4gICAgbnVtZXJpYzogXCJtXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwibW1cIixcbiAgfSxcbiAgc2Vjb25kOiB7XG4gICAgbnVtZXJpYzogXCJzXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwic3NcIixcbiAgfSxcbiAgdGltZVpvbmVOYW1lOiB7XG4gICAgbG9uZzogXCJaWlpaWlwiLFxuICAgIHNob3J0OiBcIlpaWlwiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvXlxccyskLy50ZXN0KHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogIWlzU3BhY2UsXG4gICAgICB2YWw6IGlzU3BhY2UgPyBcIiBcIiA6IHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IGZvcm1hdE9wdHNbdHlwZV07XG5cbiAgLy8gVGhlIHVzZXIgbWlnaHQgaGF2ZSBleHBsaWNpdGx5IHNwZWNpZmllZCBob3VyMTIgb3IgaG91ckN5Y2xlXG4gIC8vIGlmIHNvLCByZXNwZWN0IHRoZWlyIGRlY2lzaW9uXG4gIC8vIGlmIG5vdCwgcmVmZXIgYmFjayB0byB0aGUgcmVzb2x2ZWRPcHRzLCB3aGljaCBhcmUgYmFzZWQgb24gdGhlIGxvY2FsZVxuICBsZXQgYWN0dWFsVHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlID09PSBcImhvdXJcIikge1xuICAgIGlmIChmb3JtYXRPcHRzLmhvdXIxMiAhPSBudWxsKSB7XG4gICAgICBhY3R1YWxUeXBlID0gZm9ybWF0T3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlICE9IG51bGwpIHtcbiAgICAgIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTFcIiB8fCBmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTJcIikge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMTJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIyNFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b2tlbnMgb25seSBkaWZmZXJlbnRpYXRlIGJldHdlZW4gMjQgaG91cnMgb3Igbm90LFxuICAgICAgLy8gc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaG91ckN5Y2xlIGhlcmUsIHdoaWNoIGlzIGxlc3Mgc3VwcG9ydGVkIGFueXdheXNcbiAgICAgIGFjdHVhbFR5cGUgPSByZXNvbHZlZE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfVxuICB9XG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFthY3R1YWxUeXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpO1xuXG4gIGlmICh0b2tlbnMgPT0gbnVsbCB8fCB0b2tlbnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKCh0KSA9PiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKSkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNsYXNzIFRva2VuUGFyc2VyIHtcbiAgY29uc3RydWN0b3IobG9jYWxlLCBmb3JtYXQpIHtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLnRva2VucyA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmb3JtYXQpLCBsb2NhbGUpO1xuICAgIHRoaXMudW5pdHMgPSB0aGlzLnRva2Vucy5tYXAoKHQpID0+IHVuaXRGb3JUb2tlbih0LCBsb2NhbGUpKTtcbiAgICB0aGlzLmRpc3F1YWxpZnlpbmdVbml0ID0gdGhpcy51bml0cy5maW5kKCh0KSA9PiB0LmludmFsaWRSZWFzb24pO1xuXG4gICAgaWYgKCF0aGlzLmRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgICBjb25zdCBbcmVnZXhTdHJpbmcsIGhhbmRsZXJzXSA9IGJ1aWxkUmVnZXgodGhpcy51bml0cyk7XG4gICAgICB0aGlzLnJlZ2V4ID0gUmVnRXhwKHJlZ2V4U3RyaW5nLCBcImlcIik7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgfVxuICB9XG5cbiAgZXhwbGFpbkZyb21Ub2tlbnMoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHsgaW5wdXQsIHRva2VuczogdGhpcy50b2tlbnMsIGludmFsaWRSZWFzb246IHRoaXMuaW52YWxpZFJlYXNvbiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbcmF3TWF0Y2hlcywgbWF0Y2hlc10gPSBtYXRjaChpbnB1dCwgdGhpcy5yZWdleCwgdGhpcy5oYW5kbGVycyksXG4gICAgICAgIFtyZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XSA9IG1hdGNoZXNcbiAgICAgICAgICA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcylcbiAgICAgICAgICA6IFtudWxsLCBudWxsLCB1bmRlZmluZWRdO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiYVwiKSAmJiBoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcIkhcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHRva2VuczogdGhpcy50b2tlbnMsXG4gICAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4LFxuICAgICAgICByYXdNYXRjaGVzLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHpvbmUsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0LFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZGlzcXVhbGlmeWluZ1VuaXQ7XG4gIH1cblxuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNxdWFsaWZ5aW5nVW5pdCA/IHRoaXMuZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiA6IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgVG9rZW5QYXJzZXIobG9jYWxlLCBmb3JtYXQpO1xuICByZXR1cm4gcGFyc2VyLmV4cGxhaW5Gcm9tVG9rZW5zKGlucHV0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgeyByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uIH0gPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpO1xuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb25dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIGxvY2FsZSkge1xuICBpZiAoIWZvcm1hdE9wdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlciA9IEZvcm1hdHRlci5jcmVhdGUobG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgY29uc3QgZGYgPSBmb3JtYXR0ZXIuZHRGb3JtYXR0ZXIoZ2V0RHVtbXlEYXRlVGltZSgpKTtcbiAgY29uc3QgcGFydHMgPSBkZi5mb3JtYXRUb1BhcnRzKCk7XG4gIGNvbnN0IHJlc29sdmVkT3B0cyA9IGRmLnJlc29sdmVkT3B0aW9ucygpO1xuICByZXR1cm4gcGFydHMubWFwKChwKSA9PiB0b2tlbkZvclBhcnQocCwgZm9ybWF0T3B0cywgcmVzb2x2ZWRPcHRzKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/tokenParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js":
/*!***************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asNumber: () => (/* binding */ asNumber),\n/* harmony export */   bestBy: () => (/* binding */ bestBy),\n/* harmony export */   daysInMonth: () => (/* binding */ daysInMonth),\n/* harmony export */   daysInYear: () => (/* binding */ daysInYear),\n/* harmony export */   floorMod: () => (/* binding */ floorMod),\n/* harmony export */   formatOffset: () => (/* binding */ formatOffset),\n/* harmony export */   hasLocaleWeekInfo: () => (/* binding */ hasLocaleWeekInfo),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasRelative: () => (/* binding */ hasRelative),\n/* harmony export */   integerBetween: () => (/* binding */ integerBetween),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isLeapYear: () => (/* binding */ isLeapYear),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   maybeArray: () => (/* binding */ maybeArray),\n/* harmony export */   normalizeObject: () => (/* binding */ normalizeObject),\n/* harmony export */   objToLocalTS: () => (/* binding */ objToLocalTS),\n/* harmony export */   padStart: () => (/* binding */ padStart),\n/* harmony export */   parseFloating: () => (/* binding */ parseFloating),\n/* harmony export */   parseInteger: () => (/* binding */ parseInteger),\n/* harmony export */   parseMillis: () => (/* binding */ parseMillis),\n/* harmony export */   parseZoneInfo: () => (/* binding */ parseZoneInfo),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   roundTo: () => (/* binding */ roundTo),\n/* harmony export */   signedOffset: () => (/* binding */ signedOffset),\n/* harmony export */   timeObject: () => (/* binding */ timeObject),\n/* harmony export */   untruncateYear: () => (/* binding */ untruncateYear),\n/* harmony export */   validateWeekSettings: () => (/* binding */ validateWeekSettings),\n/* harmony export */   weeksInWeekYear: () => (/* binding */ weeksInWeekYear)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _conversions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conversions.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/conversions.js\");\n/*\n  This is just a junk drawer, containing anything used across multiple classes.\n  Because Luxon is small(ish), this should stay small and we won't worry about splitting\n  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.\n*/\n\n\n\n\n\n/**\n * @private\n */\n\n// TYPES\n\nfunction isUndefined(o) {\n  return typeof o === \"undefined\";\n}\n\nfunction isNumber(o) {\n  return typeof o === \"number\";\n}\n\nfunction isInteger(o) {\n  return typeof o === \"number\" && o % 1 === 0;\n}\n\nfunction isString(o) {\n  return typeof o === \"string\";\n}\n\nfunction isDate(o) {\n  return Object.prototype.toString.call(o) === \"[object Date]\";\n}\n\n// CAPABILITIES\n\nfunction hasRelative() {\n  try {\n    return typeof Intl !== \"undefined\" && !!Intl.RelativeTimeFormat;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction hasLocaleWeekInfo() {\n  try {\n    return (\n      typeof Intl !== \"undefined\" &&\n      !!Intl.Locale &&\n      (\"weekInfo\" in Intl.Locale.prototype || \"getWeekInfo\" in Intl.Locale.prototype)\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\n// OBJECTS AND ARRAYS\n\nfunction maybeArray(thing) {\n  return Array.isArray(thing) ? thing : [thing];\n}\n\nfunction bestBy(arr, by, compare) {\n  if (arr.length === 0) {\n    return undefined;\n  }\n  return arr.reduce((best, next) => {\n    const pair = [by(next), next];\n    if (!best) {\n      return pair;\n    } else if (compare(best[0], pair[0]) === best[0]) {\n      return best;\n    } else {\n      return pair;\n    }\n  }, null)[1];\n}\n\nfunction pick(obj, keys) {\n  return keys.reduce((a, k) => {\n    a[k] = obj[k];\n    return a;\n  }, {});\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction validateWeekSettings(settings) {\n  if (settings == null) {\n    return null;\n  } else if (typeof settings !== \"object\") {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Week settings must be an object\");\n  } else {\n    if (\n      !integerBetween(settings.firstDay, 1, 7) ||\n      !integerBetween(settings.minimalDays, 1, 7) ||\n      !Array.isArray(settings.weekend) ||\n      settings.weekend.some((v) => !integerBetween(v, 1, 7))\n    ) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Invalid week settings\");\n    }\n    return {\n      firstDay: settings.firstDay,\n      minimalDays: settings.minimalDays,\n      weekend: Array.from(settings.weekend),\n    };\n  }\n}\n\n// NUMBERS AND STRINGS\n\nfunction integerBetween(thing, bottom, top) {\n  return isInteger(thing) && thing >= bottom && thing <= top;\n}\n\n// x % n but takes the sign of n instead of x\nfunction floorMod(x, n) {\n  return x - n * Math.floor(x / n);\n}\n\nfunction padStart(input, n = 2) {\n  const isNeg = input < 0;\n  let padded;\n  if (isNeg) {\n    padded = \"-\" + (\"\" + -input).padStart(n, \"0\");\n  } else {\n    padded = (\"\" + input).padStart(n, \"0\");\n  }\n  return padded;\n}\n\nfunction parseInteger(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseInt(string, 10);\n  }\n}\n\nfunction parseFloating(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseFloat(string);\n  }\n}\n\nfunction parseMillis(fraction) {\n  // Return undefined (instead of 0) in these cases, where fraction is not set\n  if (isUndefined(fraction) || fraction === null || fraction === \"\") {\n    return undefined;\n  } else {\n    const f = parseFloat(\"0.\" + fraction) * 1000;\n    return Math.floor(f);\n  }\n}\n\nfunction roundTo(number, digits, rounding = \"round\") {\n  const factor = 10 ** digits;\n  switch (rounding) {\n    case \"expand\":\n      return number > 0\n        ? Math.ceil(number * factor) / factor\n        : Math.floor(number * factor) / factor;\n    case \"trunc\":\n      return Math.trunc(number * factor) / factor;\n    case \"round\":\n      return Math.round(number * factor) / factor;\n    case \"floor\":\n      return Math.floor(number * factor) / factor;\n    case \"ceil\":\n      return Math.ceil(number * factor) / factor;\n    default:\n      throw new RangeError(`Value rounding ${rounding} is out of range`);\n  }\n}\n\n// DATE BASICS\n\nfunction isLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\nfunction daysInYear(year) {\n  return isLeapYear(year) ? 366 : 365;\n}\n\nfunction daysInMonth(year, month) {\n  const modMonth = floorMod(month - 1, 12) + 1,\n    modYear = year + (month - modMonth) / 12;\n\n  if (modMonth === 2) {\n    return isLeapYear(modYear) ? 29 : 28;\n  } else {\n    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];\n  }\n}\n\n// convert a calendar object to a local timestamp (epoch, but with the offset baked in)\nfunction objToLocalTS(obj) {\n  let d = Date.UTC(\n    obj.year,\n    obj.month - 1,\n    obj.day,\n    obj.hour,\n    obj.minute,\n    obj.second,\n    obj.millisecond\n  );\n\n  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that\n  if (obj.year < 100 && obj.year >= 0) {\n    d = new Date(d);\n    // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not\n    // so if obj.year is in 99, but obj.day makes it roll over into year 100,\n    // the calculations done by Date.UTC are using year 2000 - which is incorrect\n    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);\n  }\n  return +d;\n}\n\n// adapted from moment.js: https://github.com/moment/moment/blob/000ac1800e620f770f4eb31b5ae908f6167b0ab2/src/lib/units/week-calendar-utils.js\nfunction firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {\n  const fwdlw = (0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.isoWeekdayToLocal)((0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.dayOfWeek)(year, 1, minDaysInFirstWeek), startOfWeek);\n  return -fwdlw + minDaysInFirstWeek - 1;\n}\n\nfunction weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);\n  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);\n  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;\n}\n\nfunction untruncateYear(year) {\n  if (year > 99) {\n    return year;\n  } else return year > _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].twoDigitCutoffYear ? 1900 + year : 2000 + year;\n}\n\n// PARSING\n\nfunction parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {\n  const date = new Date(ts),\n    intlOpts = {\n      hourCycle: \"h23\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    };\n\n  if (timeZone) {\n    intlOpts.timeZone = timeZone;\n  }\n\n  const modified = { timeZoneName: offsetFormat, ...intlOpts };\n\n  const parsed = new Intl.DateTimeFormat(locale, modified)\n    .formatToParts(date)\n    .find((m) => m.type.toLowerCase() === \"timezonename\");\n  return parsed ? parsed.value : null;\n}\n\n// signedOffset('-5', '30') -> -330\nfunction signedOffset(offHourStr, offMinuteStr) {\n  let offHour = parseInt(offHourStr, 10);\n\n  // don't || this because we want to preserve -0\n  if (Number.isNaN(offHour)) {\n    offHour = 0;\n  }\n\n  const offMin = parseInt(offMinuteStr, 10) || 0,\n    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;\n  return offHour * 60 + offMinSigned;\n}\n\n// COERCION\n\nfunction asNumber(value) {\n  const numericValue = Number(value);\n  if (typeof value === \"boolean\" || value === \"\" || !Number.isFinite(numericValue))\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(`Invalid unit value ${value}`);\n  return numericValue;\n}\n\nfunction normalizeObject(obj, normalizer) {\n  const normalized = {};\n  for (const u in obj) {\n    if (hasOwnProperty(obj, u)) {\n      const v = obj[u];\n      if (v === undefined || v === null) continue;\n      normalized[normalizer(u)] = asNumber(v);\n    }\n  }\n  return normalized;\n}\n\n/**\n * Returns the offset's value as a string\n * @param {number} ts - Epoch milliseconds for which to get the offset\n * @param {string} format - What style of offset to return.\n *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n * @return {string}\n */\nfunction formatOffset(offset, format) {\n  const hours = Math.trunc(Math.abs(offset / 60)),\n    minutes = Math.trunc(Math.abs(offset % 60)),\n    sign = offset >= 0 ? \"+\" : \"-\";\n\n  switch (format) {\n    case \"short\":\n      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;\n    case \"narrow\":\n      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : \"\"}`;\n    case \"techie\":\n      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;\n    default:\n      throw new RangeError(`Value format ${format} is out of range for property format`);\n  }\n}\n\nfunction timeObject(obj) {\n  return pick(obj, [\"hour\", \"minute\", \"second\", \"millisecond\"]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRDtBQUNkO0FBQzBCOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDREQUFvQjtBQUNsQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWlCLENBQUMsMERBQVM7QUFDM0M7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUksbUJBQW1CLG9EQUFRO0FBQy9COztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGNBQWMsNERBQW9CLHVCQUF1QixNQUFNO0FBQy9EO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSyxFQUFFLG1CQUFtQixHQUFHLHFCQUFxQjtBQUNsRTtBQUNBLGdCQUFnQixLQUFLLEVBQUUsTUFBTSxFQUFFLGtCQUFrQixRQUFRLE9BQU87QUFDaEU7QUFDQSxnQkFBZ0IsS0FBSyxFQUFFLG1CQUFtQixFQUFFLHFCQUFxQjtBQUNqRTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGhpcyBpcyBqdXN0IGEganVuayBkcmF3ZXIsIGNvbnRhaW5pbmcgYW55dGhpbmcgdXNlZCBhY3Jvc3MgbXVsdGlwbGUgY2xhc3Nlcy5cbiAgQmVjYXVzZSBMdXhvbiBpcyBzbWFsbChpc2gpLCB0aGlzIHNob3VsZCBzdGF5IHNtYWxsIGFuZCB3ZSB3b24ndCB3b3JyeSBhYm91dCBzcGxpdHRpbmdcbiAgaXQgdXAgaW50bywgc2F5LCBwYXJzaW5nVXRpbC5qcyBhbmQgYmFzaWNVdGlsLmpzIGFuZCBzbyBvbi4gQnV0IHRoZXkgYXJlIGRpdmlkZWQgdXAgYnkgZmVhdHVyZSBhcmVhLlxuKi9cblxuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgeyBkYXlPZldlZWssIGlzb1dlZWtkYXlUb0xvY2FsIH0gZnJvbSBcIi4vY29udmVyc2lvbnMuanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8vIFRZUEVTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiICYmIG8gJSAxID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbn1cblxuLy8gQ0FQQUJJTElUSUVTXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNSZWxhdGl2ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgISFJbnRsLlJlbGF0aXZlVGltZUZvcm1hdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9jYWxlV2Vla0luZm8oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAhIUludGwuTG9jYWxlICYmXG4gICAgICAoXCJ3ZWVrSW5mb1wiIGluIEludGwuTG9jYWxlLnByb3RvdHlwZSB8fCBcImdldFdlZWtJbmZvXCIgaW4gSW50bC5Mb2NhbGUucHJvdG90eXBlKVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gT0JKRUNUUyBBTkQgQVJSQVlTXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IHRoaW5nIDogW3RoaW5nXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlc3RCeShhcnIsIGJ5LCBjb21wYXJlKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyLnJlZHVjZSgoYmVzdCwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBbYnkobmV4dCksIG5leHRdO1xuICAgIGlmICghYmVzdCkge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSBlbHNlIGlmIChjb21wYXJlKGJlc3RbMF0sIHBhaXJbMF0pID09PSBiZXN0WzBdKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfVxuICB9LCBudWxsKVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYSwgaykgPT4ge1xuICAgIGFba10gPSBvYmpba107XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVdlZWtTZXR0aW5ncyhzZXR0aW5ncykge1xuICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIldlZWsgc2V0dGluZ3MgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgIWludGVnZXJCZXR3ZWVuKHNldHRpbmdzLmZpcnN0RGF5LCAxLCA3KSB8fFxuICAgICAgIWludGVnZXJCZXR3ZWVuKHNldHRpbmdzLm1pbmltYWxEYXlzLCAxLCA3KSB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkoc2V0dGluZ3Mud2Vla2VuZCkgfHxcbiAgICAgIHNldHRpbmdzLndlZWtlbmQuc29tZSgodikgPT4gIWludGVnZXJCZXR3ZWVuKHYsIDEsIDcpKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiSW52YWxpZCB3ZWVrIHNldHRpbmdzXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3REYXk6IHNldHRpbmdzLmZpcnN0RGF5LFxuICAgICAgbWluaW1hbERheXM6IHNldHRpbmdzLm1pbmltYWxEYXlzLFxuICAgICAgd2Vla2VuZDogQXJyYXkuZnJvbShzZXR0aW5ncy53ZWVrZW5kKSxcbiAgICB9O1xuICB9XG59XG5cbi8vIE5VTUJFUlMgQU5EIFNUUklOR1NcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVnZXJCZXR3ZWVuKHRoaW5nLCBib3R0b20sIHRvcCkge1xuICByZXR1cm4gaXNJbnRlZ2VyKHRoaW5nKSAmJiB0aGluZyA+PSBib3R0b20gJiYgdGhpbmcgPD0gdG9wO1xufVxuXG4vLyB4ICUgbiBidXQgdGFrZXMgdGhlIHNpZ24gb2YgbiBpbnN0ZWFkIG9mIHhcbmV4cG9ydCBmdW5jdGlvbiBmbG9vck1vZCh4LCBuKSB7XG4gIHJldHVybiB4IC0gbiAqIE1hdGguZmxvb3IoeCAvIG4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RhcnQoaW5wdXQsIG4gPSAyKSB7XG4gIGNvbnN0IGlzTmVnID0gaW5wdXQgPCAwO1xuICBsZXQgcGFkZGVkO1xuICBpZiAoaXNOZWcpIHtcbiAgICBwYWRkZWQgPSBcIi1cIiArIChcIlwiICsgLWlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFkZGVkID0gKFwiXCIgKyBpbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9XG4gIHJldHVybiBwYWRkZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGbG9hdGluZyhzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNaWxsaXMoZnJhY3Rpb24pIHtcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCAoaW5zdGVhZCBvZiAwKSBpbiB0aGVzZSBjYXNlcywgd2hlcmUgZnJhY3Rpb24gaXMgbm90IHNldFxuICBpZiAoaXNVbmRlZmluZWQoZnJhY3Rpb24pIHx8IGZyYWN0aW9uID09PSBudWxsIHx8IGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmID0gcGFyc2VGbG9hdChcIjAuXCIgKyBmcmFjdGlvbikgKiAxMDAwO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGYpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvKG51bWJlciwgZGlnaXRzLCByb3VuZGluZyA9IFwicm91bmRcIikge1xuICBjb25zdCBmYWN0b3IgPSAxMCAqKiBkaWdpdHM7XG4gIHN3aXRjaCAocm91bmRpbmcpIHtcbiAgICBjYXNlIFwiZXhwYW5kXCI6XG4gICAgICByZXR1cm4gbnVtYmVyID4gMFxuICAgICAgICA/IE1hdGguY2VpbChudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yXG4gICAgICAgIDogTWF0aC5mbG9vcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNhc2UgXCJ0cnVuY1wiOlxuICAgICAgcmV0dXJuIE1hdGgudHJ1bmMobnVtYmVyICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgY2FzZSBcImZsb29yXCI6XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNhc2UgXCJjZWlsXCI6XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBWYWx1ZSByb3VuZGluZyAke3JvdW5kaW5nfSBpcyBvdXQgb2YgcmFuZ2VgKTtcbiAgfVxufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBsb2NhbCB0aW1lc3RhbXAgKGVwb2NoLCBidXQgd2l0aCB0aGUgb2Zmc2V0IGJha2VkIGluKVxuZXhwb3J0IGZ1bmN0aW9uIG9ialRvTG9jYWxUUyhvYmopIHtcbiAgbGV0IGQgPSBEYXRlLlVUQyhcbiAgICBvYmoueWVhcixcbiAgICBvYmoubW9udGggLSAxLFxuICAgIG9iai5kYXksXG4gICAgb2JqLmhvdXIsXG4gICAgb2JqLm1pbnV0ZSxcbiAgICBvYmouc2Vjb25kLFxuICAgIG9iai5taWxsaXNlY29uZFxuICApO1xuXG4gIC8vIGZvciBsZWdhY3kgcmVhc29ucywgeWVhcnMgYmV0d2VlbiAwIGFuZCA5OSBhcmUgaW50ZXJwcmV0ZWQgYXMgMTlYWDsgcmV2ZXJ0IHRoYXRcbiAgaWYgKG9iai55ZWFyIDwgMTAwICYmIG9iai55ZWFyID49IDApIHtcbiAgICBkID0gbmV3IERhdGUoZCk7XG4gICAgLy8gc2V0IHRoZSBtb250aCBhbmQgZGF5IGFnYWluLCB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHllYXIgMjAwMCBpcyBhIGxlYXAgeWVhciwgYnV0IHllYXIgMTAwIGlzIG5vdFxuICAgIC8vIHNvIGlmIG9iai55ZWFyIGlzIGluIDk5LCBidXQgb2JqLmRheSBtYWtlcyBpdCByb2xsIG92ZXIgaW50byB5ZWFyIDEwMCxcbiAgICAvLyB0aGUgY2FsY3VsYXRpb25zIGRvbmUgYnkgRGF0ZS5VVEMgYXJlIHVzaW5nIHllYXIgMjAwMCAtIHdoaWNoIGlzIGluY29ycmVjdFxuICAgIGQuc2V0VVRDRnVsbFllYXIob2JqLnllYXIsIG9iai5tb250aCAtIDEsIG9iai5kYXkpO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuLy8gYWRhcHRlZCBmcm9tIG1vbWVudC5qczogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvYmxvYi8wMDBhYzE4MDBlNjIwZjc3MGY0ZWIzMWI1YWU5MDhmNjE2N2IwYWIyL3NyYy9saWIvdW5pdHMvd2Vlay1jYWxlbmRhci11dGlscy5qc1xuZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspIHtcbiAgY29uc3QgZndkbHcgPSBpc29XZWVrZGF5VG9Mb2NhbChkYXlPZldlZWsoeWVhciwgMSwgbWluRGF5c0luRmlyc3RXZWVrKSwgc3RhcnRPZldlZWspO1xuICByZXR1cm4gLWZ3ZGx3ICsgbWluRGF5c0luRmlyc3RXZWVrIC0gMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICBjb25zdCB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh3ZWVrWWVhciArIDEsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICByZXR1cm4gKGRheXNJblllYXIod2Vla1llYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyKSB7XG4gIGlmICh5ZWFyID4gOTkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHJldHVybiB5ZWFyID4gU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID8gMTkwMCArIHllYXIgOiAyMDAwICsgeWVhcjtcbn1cblxuLy8gUEFSU0lOR1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Vab25lSW5mbyh0cywgb2Zmc2V0Rm9ybWF0LCBsb2NhbGUsIHRpbWVab25lID0gbnVsbCkge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpLFxuICAgIGludGxPcHRzID0ge1xuICAgICAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIH07XG5cbiAgaWYgKHRpbWVab25lKSB7XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSB0aW1lWm9uZTtcbiAgfVxuXG4gIGNvbnN0IG1vZGlmaWVkID0geyB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdCwgLi4uaW50bE9wdHMgfTtcblxuICBjb25zdCBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKVxuICAgIC5mb3JtYXRUb1BhcnRzKGRhdGUpXG4gICAgLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInRpbWV6b25lbmFtZVwiKTtcbiAgcmV0dXJuIHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IG51bGw7XG59XG5cbi8vIHNpZ25lZE9mZnNldCgnLTUnLCAnMzAnKSAtPiAtMzMwXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cikge1xuICBsZXQgb2ZmSG91ciA9IHBhcnNlSW50KG9mZkhvdXJTdHIsIDEwKTtcblxuICAvLyBkb24ndCB8fCB0aGlzIGJlY2F1c2Ugd2Ugd2FudCB0byBwcmVzZXJ2ZSAtMFxuICBpZiAoTnVtYmVyLmlzTmFOKG9mZkhvdXIpKSB7XG4gICAgb2ZmSG91ciA9IDA7XG4gIH1cblxuICBjb25zdCBvZmZNaW4gPSBwYXJzZUludChvZmZNaW51dGVTdHIsIDEwKSB8fCAwLFxuICAgIG9mZk1pblNpZ25lZCA9IG9mZkhvdXIgPCAwIHx8IE9iamVjdC5pcyhvZmZIb3VyLCAtMCkgPyAtb2ZmTWluIDogb2ZmTWluO1xuICByZXR1cm4gb2ZmSG91ciAqIDYwICsgb2ZmTWluU2lnbmVkO1xufVxuXG4vLyBDT0VSQ0lPTlxuXG5leHBvcnQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgY29uc3QgbnVtZXJpY1ZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT09IFwiXCIgfHwgIU51bWJlci5pc0Zpbml0ZShudW1lcmljVmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCB1bml0IHZhbHVlICR7dmFsdWV9YCk7XG4gIHJldHVybiBudW1lcmljVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBjb25zdCB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9mZnNldChvZmZzZXQsIGZvcm1hdCkge1xuICBjb25zdCBob3VycyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0IC8gNjApKSxcbiAgICBtaW51dGVzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgJSA2MCkpLFxuICAgIHNpZ24gPSBvZmZzZXQgPj0gMCA/IFwiK1wiIDogXCItXCI7XG5cbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtob3Vyc30ke21pbnV0ZXMgPiAwID8gYDoke21pbnV0ZXN9YCA6IFwiXCJ9YDtcbiAgICBjYXNlIFwidGVjaGllXCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX0ke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBWYWx1ZSBmb3JtYXQgJHtmb3JtYXR9IGlzIG91dCBvZiByYW5nZSBmb3IgcHJvcGVydHkgZm9ybWF0YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVPYmplY3Qob2JqKSB7XG4gIHJldHVybiBwaWNrKG9iaiwgW1wiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/zoneUtil.js":
/*!*******************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/impl/zoneUtil.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeZone: () => (/* binding */ normalizeZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/invalidZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../zones/systemZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/systemZone.js\");\n/**\n * @private\n */\n\n\n\n\n\n\n\n\n\nfunction normalizeZone(input, defaultZone) {\n  let offset;\n  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(input) || input === null) {\n    return defaultZone;\n  } else if (input instanceof _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    return input;\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isString)(input)) {\n    const lowered = input.toLowerCase();\n    if (lowered === \"default\") return defaultZone;\n    else if (lowered === \"local\" || lowered === \"system\") return _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance;\n    else if (lowered === \"utc\" || lowered === \"gmt\") return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance;\n    else return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parseSpecifier(lowered) || _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(input);\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(input)) {\n    return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(input);\n  } else if (typeof input === \"object\" && \"offset\" in input && typeof input.offset === \"function\") {\n    // This is dumb, but the instanceof check above doesn't seem to really work\n    // so we're duck checking it\n    return input;\n  } else {\n    return new _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](input);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC96b25lVXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUU4QjtBQUNjO0FBQ2M7QUFDUjs7QUFFVTtBQUNaOztBQUV6QztBQUNQO0FBQ0EsTUFBTSxxREFBVztBQUNqQjtBQUNBLElBQUksMEJBQTBCLGdEQUFJO0FBQ2xDO0FBQ0EsSUFBSSxTQUFTLGtEQUFRO0FBQ3JCO0FBQ0E7QUFDQSxpRUFBaUUsNERBQVU7QUFDM0UsNERBQTRELGlFQUFlO0FBQzNFLGdCQUFnQixpRUFBZSw0QkFBNEIsMERBQVE7QUFDbkUsSUFBSSxTQUFTLGtEQUFRO0FBQ3JCLFdBQVcsaUVBQWU7QUFDMUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlLDZEQUFXO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcblxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVab25lKGlucHV0LCBkZWZhdWx0Wm9uZSkge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRab25lO1xuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgWm9uZSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICBjb25zdCBsb3dlcmVkID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJlZCA9PT0gXCJkZWZhdWx0XCIpIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcImxvY2FsXCIgfHwgbG93ZXJlZCA9PT0gXCJzeXN0ZW1cIikgcmV0dXJuIFN5c3RlbVpvbmUuaW5zdGFuY2U7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJ1dGNcIiB8fCBsb3dlcmVkID09PSBcImdtdFwiKSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIGVsc2UgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihsb3dlcmVkKSB8fCBJQU5BWm9uZS5jcmVhdGUoaW5wdXQpO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgIHJldHVybiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBcIm9mZnNldFwiIGluIGlucHV0ICYmIHR5cGVvZiBpbnB1dC5vZmZzZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIFRoaXMgaXMgZHVtYiwgYnV0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byByZWFsbHkgd29ya1xuICAgIC8vIHNvIHdlJ3JlIGR1Y2sgY2hlY2tpbmcgaXRcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/zoneUtil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/info.js":
/*!**********************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/info.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Info)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n\n\n\n\n\n\n\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nclass Info {\n  /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */\n  static hasDST(zone = _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone) {\n    const proto = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].now().setZone(zone).set({ month: 12 });\n\n    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;\n  }\n\n  /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */\n  static isValidIANAZone(zone) {\n    return _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isValidZone(zone);\n  }\n\n  /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone#isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */\n  static normalizeZone(input) {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(input, _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone);\n  }\n\n  /**\n   * Get the weekday on which the week starts according to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday\n   */\n  static getStartOfWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getStartOfWeek();\n  }\n\n  /**\n   * Get the minimum number of days necessary in a week before it is considered part of the next year according\n   * to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number}\n   */\n  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getMinDaysInFirstWeek();\n  }\n\n  /**\n   * Get the weekdays, which are considered the weekend according to the given locale\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday\n   */\n  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {\n    // copy the array, because we cache it internally\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getWeekendDays().slice();\n  }\n\n  /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'\n   * @return {Array}\n   */\n  static months(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length);\n  }\n\n  /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link Info#months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {Array}\n   */\n  static monthsFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length, true);\n  }\n\n  /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''\n   * @return {Array}\n   */\n  static weekdays(length = \"long\", { locale = null, numberingSystem = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length);\n  }\n\n  /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link Info#weekdays}\n   * @param {string} [length='long'] - the length of the month representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @return {Array}\n   */\n  static weekdaysFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length, true);\n  }\n\n  /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]\n   * @return {Array}\n   */\n  static meridiems({ locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale).meridiems();\n  }\n\n  /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\n   * @return {Array}\n   */\n  static eras(length = \"short\", { locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, null, \"gregory\").eras(length);\n  }\n\n  /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `relative`: whether this environment supports relative time formatting\n   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale\n   * @example Info.features() //=> { relative: false, localeWeek: true }\n   * @return {Object}\n   */\n  static features() {\n    return { relative: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasRelative)(), localeWeek: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasLocaleWeekInfo)() };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFDO0FBQ0E7QUFDQztBQUNLO0FBQ1E7O0FBRWE7O0FBRWhFO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQSx1QkFBdUIsb0RBQVE7QUFDL0Isa0JBQWtCLG9EQUFRLDJCQUEyQixXQUFXOztBQUVoRSw2REFBNkQsVUFBVTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVywwREFBUTtBQUNuQjs7QUFFQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVyxnRUFBYSxRQUFRLG9EQUFRO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQSwwQkFBMEIsK0JBQStCLElBQUk7QUFDN0Qsc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBLHFDQUFxQywrQkFBK0IsSUFBSTtBQUN4RSxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLDhCQUE4QiwrQkFBK0IsSUFBSTtBQUNqRTtBQUNBLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZELHVDQUF1QyxjQUFjO0FBQ3JELG9DQUFvQywyQkFBMkI7QUFDL0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUZBQW1GO0FBQ3pGO0FBQ0Esc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1GQUFtRjtBQUN6RjtBQUNBLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hELHVDQUF1QyxjQUFjO0FBQ3JELGNBQWM7QUFDZDtBQUNBLHFDQUFxQyx1REFBdUQsSUFBSTtBQUNoRyxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBdUQ7QUFDN0Q7QUFDQSxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxjQUFjO0FBQ2Q7QUFDQSxxQkFBcUIsZ0JBQWdCLElBQUk7QUFDekMsV0FBVyx1REFBTTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELGNBQWM7QUFDZDtBQUNBLGtDQUFrQyxnQkFBZ0IsSUFBSTtBQUN0RCxXQUFXLHVEQUFNO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsVUFBVSwwREFBVyxnQkFBZ0IsZ0VBQWlCO0FBQ25FO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2luZm8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxuaW1wb3J0IHsgaGFzTG9jYWxlV2Vla0luZm8sIGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFpvbmUoem9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZSNpc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplWm9uZShpbnB1dCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGlucHV0LCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrZGF5IG9uIHdoaWNoIHRoZSB3ZWVrIHN0YXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGxvY2FsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIDEgZm9yIE1vbmRheSB0aHJvdWdoIDcgZm9yIFN1bmRheVxuICAgKi9cbiAgc3RhdGljIGdldFN0YXJ0T2ZXZWVrKHsgbG9jYWxlID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSkpLmdldFN0YXJ0T2ZXZWVrKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBkYXlzIG5lY2Vzc2FyeSBpbiBhIHdlZWsgYmVmb3JlIGl0IGlzIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgbmV4dCB5ZWFyIGFjY29yZGluZ1xuICAgKiB0byB0aGUgZ2l2ZW4gbG9jYWxlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0TWluaW11bURheXNJbkZpcnN0V2Vlayh7IGxvY2FsZSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUpKS5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtkYXlzLCB3aGljaCBhcmUgY29uc2lkZXJlZCB0aGUgd2Vla2VuZCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGxvY2FsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gYW4gYXJyYXkgb2Ygd2Vla2RheXMsIDEgZm9yIE1vbmRheSB0aHJvdWdoIDcgZm9yIFN1bmRheVxuICAgKi9cbiAgc3RhdGljIGdldFdlZWtlbmRXZWVrZGF5cyh7IGxvY2FsZSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgLy8gY29weSB0aGUgYXJyYXksIGJlY2F1c2Ugd2UgY2FjaGUgaXQgaW50ZXJuYWxseVxuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlKSkuZ2V0V2Vla2VuZERheXMoKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIG1vbnRoIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoKVswXSAvLz0+ICdKYW51YXJ5J1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnKVswXSAvLz0+ICdKYW4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJylbMF0gLy89PiAnMSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSApWzBdIC8vPT4gJ2phbnYuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ9mhJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbG9uZycsIHsgb3V0cHV0Q2FsZW5kYXI6ICdpc2xhbWljJyB9KVswXSAvLz0+ICdSYWJpyrsgSSdcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzKFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IG1vbnRoIG5hbWVzLlxuICAgKiBGb3JtYXQgbW9udGhzIGRpZmZlciBmcm9tIHN0YW5kYWxvbmUgbW9udGhzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byB0aGUgZGF5IG9mIHRoZSBtb250aC4gSW4gc29tZSBsYW5ndWFnZXMsIHRoYXRcbiAgICogY2hhbmdlcyB0aGUgc3RyaW5nLlxuICAgKiBTZWUge0BsaW5rIEluZm8jbW9udGhzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRoc0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgd2VlayBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgd2Vla2RheSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKClbMF0gLy89PiAnTW9uZGF5J1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcpWzBdIC8vPT4gJ01vbidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9KVswXSAvLz0+ICdsdW4uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ9in2YTYp9ir2YbZitmGJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5cyhsZW5ndGggPSBcImxvbmdcIiwgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgd2VlayBuYW1lcy5cbiAgICogRm9ybWF0IHdlZWtkYXlzIGRpZmZlciBmcm9tIHN0YW5kYWxvbmUgd2Vla2RheXMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIG1vcmUgZGF0ZSBpbmZvcm1hdGlvbi4gSW4gc29tZSBsYW5ndWFnZXMsIHRoYXRcbiAgICogY2hhbmdlcyB0aGUgc3RyaW5nLlxuICAgKiBTZWUge0BsaW5rIEluZm8jd2Vla2RheXN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT1udWxsXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIG1lcmlkaWVtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKCkgLy89PiBbICdBTScsICdQTScgXVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcyh7IGxvY2FsZTogJ215JyB9KSAvLz0+IFsgJ+GAlOGAtuGAlOGAgOGAuicsICfhgIrhgJThgLEnIF1cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWVyaWRpZW1zKHsgbG9jYWxlID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUpLm1lcmlkaWVtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBlcmFzLCBzdWNoIGFzIFsnQkMnLCAnQUQnXS4gVGhlIGxvY2FsZSBjYW4gYmUgc3BlY2lmaWVkLCBidXQgdGhlIGNhbGVuZGFyIHN5c3RlbSBpcyBhbHdheXMgR3JlZ29yaWFuLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nc2hvcnQnXSAtIHRoZSBsZW5ndGggb2YgdGhlIGVyYSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcInNob3J0XCIgb3IgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoKSAvLz0+IFsgJ0JDJywgJ0FEJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycpIC8vPT4gWyAnQmVmb3JlIENocmlzdCcsICdBbm5vIERvbWluaScgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnLCB7IGxvY2FsZTogJ2ZyJyB9KSAvLz0+IFsgJ2F2YW50IErDqXN1cy1DaHJpc3QnLCAnYXByw6hzIErDqXN1cy1DaHJpc3QnIF1cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgZXJhcyhsZW5ndGggPSBcInNob3J0XCIsIHsgbG9jYWxlID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bGwsIFwiZ3JlZ29yeVwiKS5lcmFzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzZXQgb2YgYXZhaWxhYmxlIGZlYXR1cmVzIGluIHRoaXMgZW52aXJvbm1lbnQuXG4gICAqIFNvbWUgZmVhdHVyZXMgb2YgTHV4b24gYXJlIG5vdCBhdmFpbGFibGUgaW4gYWxsIGVudmlyb25tZW50cy4gRm9yIGV4YW1wbGUsIG9uIG9sZGVyIGJyb3dzZXJzLCByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmcgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLiBVc2UgdGhpcyBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICogS2V5czpcbiAgICogKiBgcmVsYXRpdmVgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nXG4gICAqICogYGxvY2FsZVdlZWtgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgZGlmZmVyZW50IHdlZWtkYXlzIGZvciB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSwgbG9jYWxlV2VlazogdHJ1ZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSwgbG9jYWxlV2VlazogaGFzTG9jYWxlV2Vla0luZm8oKSB9O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/interval.js":
/*!**************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/interval.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interval)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/formats.js\");\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Interval\";\n\n// checks if the start is equal to or before the end\nfunction validateStartEnd(start, end) {\n  if (!start || !start.isValid) {\n    return Interval.invalid(\"missing or invalid start\");\n  } else if (!end || !end.isValid) {\n    return Interval.invalid(\"missing or invalid end\");\n  } else if (end < start) {\n    return Interval.invalid(\n      \"end before start\",\n      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`\n    );\n  } else {\n    return null;\n  }\n}\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.\n * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.\n * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}\n * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.\n */\nclass Interval {\n  /**\n   * @private\n   */\n  constructor(config) {\n    /**\n     * @access private\n     */\n    this.s = config.start;\n    /**\n     * @access private\n     */\n    this.e = config.end;\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.isLuxonInterval = true;\n  }\n\n  /**\n   * Create an invalid Interval.\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Interval}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidIntervalError(invalid);\n    } else {\n      return new Interval({ invalid });\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n   * @param {DateTime|Date|Object} start\n   * @param {DateTime|Date|Object} end\n   * @return {Interval}\n   */\n  static fromDateTimes(start, end) {\n    const builtStart = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start),\n      builtEnd = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n\n    const validateError = validateStartEnd(builtStart, builtEnd);\n\n    if (validateError == null) {\n      return new Interval({\n        start: builtStart,\n        end: builtEnd,\n      });\n    } else {\n      return validateError;\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and a Duration to extend to.\n   * @param {DateTime|Date|Object} start\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static after(start, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start);\n    return Interval.fromDateTimes(dt, dt.plus(dur));\n  }\n\n  /**\n   * Create an Interval from an end DateTime and a Duration to extend backwards to.\n   * @param {DateTime|Date|Object} end\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static before(end, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n    return Interval.fromDateTimes(dt.minus(dur), dt);\n  }\n\n  /**\n   * Create an Interval from an ISO 8601 string.\n   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n   * @param {string} text - the ISO string to parse\n   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {Interval}\n   */\n  static fromISO(text, opts) {\n    const [s, e] = (text || \"\").split(\"/\", 2);\n    if (s && e) {\n      let start, startIsValid;\n      try {\n        start = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(s, opts);\n        startIsValid = start.isValid;\n      } catch (e) {\n        startIsValid = false;\n      }\n\n      let end, endIsValid;\n      try {\n        end = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(e, opts);\n        endIsValid = end.isValid;\n      } catch (e) {\n        endIsValid = false;\n      }\n\n      if (startIsValid && endIsValid) {\n        return Interval.fromDateTimes(start, end);\n      }\n\n      if (startIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(e, opts);\n        if (dur.isValid) {\n          return Interval.after(start, dur);\n        }\n      } else if (endIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(s, opts);\n        if (dur.isValid) {\n          return Interval.before(end, dur);\n        }\n      }\n    }\n    return Interval.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n  }\n\n  /**\n   * Check if an object is an Interval. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isInterval(o) {\n    return (o && o.isLuxonInterval) || false;\n  }\n\n  /**\n   * Returns the start of the Interval\n   * @type {DateTime}\n   */\n  get start() {\n    return this.isValid ? this.s : null;\n  }\n\n  /**\n   * Returns the end of the Interval. This is the first instant which is not part of the interval\n   * (Interval is half-open).\n   * @type {DateTime}\n   */\n  get end() {\n    return this.isValid ? this.e : null;\n  }\n\n  /**\n   * Returns the last DateTime included in the interval (since end is not part of the interval)\n   * @type {DateTime}\n   */\n  get lastDateTime() {\n    return this.isValid ? (this.e ? this.e.minus(1) : null) : null;\n  }\n\n  /**\n   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalidReason === null;\n  }\n\n  /**\n   * Returns an error code if this Interval is invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Returns the length of the Interval in the specified unit.\n   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\n   * @return {number}\n   */\n  length(unit = \"milliseconds\") {\n    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;\n  }\n\n  /**\n   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n   * @param {string} [unit='milliseconds'] - the unit of time to count.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime\n   * @return {number}\n   */\n  count(unit = \"milliseconds\", opts) {\n    if (!this.isValid) return NaN;\n    const start = this.start.startOf(unit, opts);\n    let end;\n    if (opts?.useLocaleWeeks) {\n      end = this.end.reconfigure({ locale: start.locale });\n    } else {\n      end = this.end;\n    }\n    end = end.startOf(unit, opts);\n    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());\n  }\n\n  /**\n   * Returns whether this Interval's start and end are both in the same unit of time\n   * @param {string} unit - the unit of time to check sameness on\n   * @return {boolean}\n   */\n  hasSame(unit) {\n    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end DateTimes.\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.s.valueOf() === this.e.valueOf();\n  }\n\n  /**\n   * Return whether this Interval's start is after the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isAfter(dateTime) {\n    if (!this.isValid) return false;\n    return this.s > dateTime;\n  }\n\n  /**\n   * Return whether this Interval's end is before the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isBefore(dateTime) {\n    if (!this.isValid) return false;\n    return this.e <= dateTime;\n  }\n\n  /**\n   * Return whether this Interval contains the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  contains(dateTime) {\n    if (!this.isValid) return false;\n    return this.s <= dateTime && this.e > dateTime;\n  }\n\n  /**\n   * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n   * @param {Object} values - the values to set\n   * @param {DateTime} values.start - the starting DateTime\n   * @param {DateTime} values.end - the ending DateTime\n   * @return {Interval}\n   */\n  set({ start, end } = {}) {\n    if (!this.isValid) return this;\n    return Interval.fromDateTimes(start || this.s, end || this.e);\n  }\n\n  /**\n   * Split this Interval at each of the specified DateTimes\n   * @param {...DateTime} dateTimes - the unit of time to count.\n   * @return {Array}\n   */\n  splitAt(...dateTimes) {\n    if (!this.isValid) return [];\n    const sorted = dateTimes\n        .map(_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)\n        .filter((d) => this.contains(d))\n        .sort((a, b) => a.toMillis() - b.toMillis()),\n      results = [];\n    let { s } = this,\n      i = 0;\n\n    while (s < this.e) {\n      const added = sorted[i] || this.e,\n        next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      i += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into smaller Intervals, each of the specified length.\n   * Left over time is grouped into a smaller interval\n   * @param {Duration|Object|number} duration - The length of each resulting interval.\n   * @return {Array}\n   */\n  splitBy(duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration);\n\n    if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\n      return [];\n    }\n\n    let { s } = this,\n      idx = 1,\n      next;\n\n    const results = [];\n    while (s < this.e) {\n      const added = this.start.plus(dur.mapUnits((x) => x * idx));\n      next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      idx += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into the specified number of smaller intervals.\n   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\n   * @return {Array}\n   */\n  divideEqually(numberOfParts) {\n    if (!this.isValid) return [];\n    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\n  }\n\n  /**\n   * Return whether this Interval overlaps with the specified Interval\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  overlaps(other) {\n    return this.e > other.s && this.s < other.e;\n  }\n\n  /**\n   * Return whether this Interval's end is adjacent to the specified Interval's start.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsStart(other) {\n    if (!this.isValid) return false;\n    return +this.e === +other.s;\n  }\n\n  /**\n   * Return whether this Interval's start is adjacent to the specified Interval's end.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsEnd(other) {\n    if (!this.isValid) return false;\n    return +other.e === +this.s;\n  }\n\n  /**\n   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  engulfs(other) {\n    if (!this.isValid) return false;\n    return this.s <= other.s && this.e >= other.e;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end as the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    return this.s.equals(other.s) && this.e.equals(other.e);\n  }\n\n  /**\n   * Return an Interval representing the intersection of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n   * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  intersection(other) {\n    if (!this.isValid) return this;\n    const s = this.s > other.s ? this.s : other.s,\n      e = this.e < other.e ? this.e : other.e;\n\n    if (s >= e) {\n      return null;\n    } else {\n      return Interval.fromDateTimes(s, e);\n    }\n  }\n\n  /**\n   * Return an Interval representing the union of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  union(other) {\n    if (!this.isValid) return this;\n    const s = this.s < other.s ? this.s : other.s,\n      e = this.e > other.e ? this.e : other.e;\n    return Interval.fromDateTimes(s, e);\n  }\n\n  /**\n   * Merge an array of Intervals into an equivalent minimal set of Intervals.\n   * Combines overlapping and adjacent Intervals.\n   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval\n   * and ending with the latest.\n   *\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static merge(intervals) {\n    const [found, final] = intervals\n      .sort((a, b) => a.s - b.s)\n      .reduce(\n        ([sofar, current], item) => {\n          if (!current) {\n            return [sofar, item];\n          } else if (current.overlaps(item) || current.abutsStart(item)) {\n            return [sofar, current.union(item)];\n          } else {\n            return [sofar.concat([current]), item];\n          }\n        },\n        [[], null]\n      );\n    if (final) {\n      found.push(final);\n    }\n    return found;\n  }\n\n  /**\n   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static xor(intervals) {\n    let start = null,\n      currentCount = 0;\n    const results = [],\n      ends = intervals.map((i) => [\n        { time: i.s, type: \"s\" },\n        { time: i.e, type: \"e\" },\n      ]),\n      flattened = Array.prototype.concat(...ends),\n      arr = flattened.sort((a, b) => a.time - b.time);\n\n    for (const i of arr) {\n      currentCount += i.type === \"s\" ? 1 : -1;\n\n      if (currentCount === 1) {\n        start = i.time;\n      } else {\n        if (start && +start !== +i.time) {\n          results.push(Interval.fromDateTimes(start, i.time));\n        }\n\n        start = null;\n      }\n    }\n\n    return Interval.merge(results);\n  }\n\n  /**\n   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n   * @param {...Interval} intervals\n   * @return {Array}\n   */\n  difference(...intervals) {\n    return Interval.xor([this].concat(intervals))\n      .map((i) => this.intersection(i))\n      .filter((i) => i && !i.isEmpty());\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for debugging.\n   * @return {string}\n   */\n  toString() {\n    if (!this.isValid) return INVALID;\n    return `[${this.s.toISO()}  ${this.e.toISO()})`;\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;\n    } else {\n      return `Interval { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns a localized string representing this Interval. Accepts the same options as the\n   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as\n   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method\n   * is browser-specific, but in general it will return an appropriate representation of the\n   * Interval in the assigned locale. Defaults to the system's locale if no locale has been\n   * specified.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or\n   * Intl.DateTimeFormat constructor options.\n   * @param {Object} opts - Options to override the configuration of the start DateTime.\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create(this.s.loc.clone(opts), formatOpts).formatInterval(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Interval.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISO(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of date of this Interval.\n   * The time components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {string}\n   */\n  toISODate() {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISODate()}/${this.e.toISODate()}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of time of this Interval.\n   * The date components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISOTime(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this Interval formatted according to the specified format\n   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible\n   * formatting tool.\n   * @param {string} dateFormat - The format string. This string formats the start and end time.\n   * See {@link DateTime#toFormat} for details.\n   * @param {Object} opts - Options.\n   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end\n   * representations.\n   * @return {string}\n   */\n  toFormat(dateFormat, { separator = \"  \" } = {}) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;\n  }\n\n  /**\n   * Return a Duration representing the time spanned by this interval.\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n   * @return {Duration}\n   */\n  toDuration(unit, opts) {\n    if (!this.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].invalid(this.invalidReason);\n    }\n    return this.e.diff(this.s, unit, opts);\n  }\n\n  /**\n   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n   * @param {function} mapFn\n   * @return {Interval}\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n   */\n  mapEndpoints(mapFn) {\n    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW50ZXJ2YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMkQ7QUFDdEI7QUFDQTtBQUNvQztBQUNqQztBQUNJO0FBQ0M7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZSxVQUFVLFlBQVk7QUFDaEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUZBQXlGLGVBQWU7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDZCQUE2QixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixNQUFNLHVCQUF1QjtBQUN6Six3QkFBd0Isc0JBQXNCLEtBQUssb0JBQW9CO0FBQ3ZFLHFEQUFxRCxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsTUFBTSx3QkFBd0I7QUFDaE4sd0VBQXdFLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLDZCQUE2QixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLDRCQUE0QixNQUFNLDBCQUEwQjtBQUNwVCxrRUFBa0Usc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUc7QUFDOUsseUVBQXlFLHdCQUF3QixHQUFHLDhCQUE4QixHQUFHLHFCQUFxQixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHdCQUF3QixPQUFPLDBCQUEwQjtBQUM5UTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFD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LFdBQVc7QUFDM0Q7QUFDQSxRQUFRLDBEQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLDRCQUE0QjtBQUNqRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsNEJBQTRCO0FBQ2pELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QixHQUFHLHVCQUF1QjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLHlCQUF5QjtBQUNuQyxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0EseUJBQXlCLG9CQUFvQixJQUFJO0FBQ2pEO0FBQ0EsY0FBYyw0QkFBNEIsRUFBRSxVQUFVLEVBQUUsNEJBQTRCO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLDhFQUE4RTtBQUM5RSxvRkFBb0Y7QUFDcEYsa0dBQWtHO0FBQ2xHLDZHQUE2RztBQUM3Ryx1RkFBdUY7QUFDdkYsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsY0FBYztBQUNkO0FBQ0Esd0ZBQXdGLFVBQVU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW50ZXJ2YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERhdGVUaW1lLCB7IGZyaWVuZGx5RGF0ZVRpbWUgfSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkSW50ZXJ2YWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIEludGVydmFsXCI7XG5cbi8vIGNoZWNrcyBpZiB0aGUgc3RhcnQgaXMgZXF1YWwgdG8gb3IgYmVmb3JlIHRoZSBlbmRcbmZ1bmN0aW9uIHZhbGlkYXRlU3RhcnRFbmQoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0IHx8ICFzdGFydC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgc3RhcnRcIik7XG4gIH0gZWxzZSBpZiAoIWVuZCB8fCAhZW5kLmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRcIik7XG4gIH0gZWxzZSBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcbiAgICAgIFwiZW5kIGJlZm9yZSBzdGFydFwiLFxuICAgICAgYFRoZSBlbmQgb2YgYW4gaW50ZXJ2YWwgbXVzdCBiZSBhZnRlciBpdHMgc3RhcnQsIGJ1dCB5b3UgaGFkIHN0YXJ0PSR7c3RhcnQudG9JU08oKX0gYW5kIGVuZD0ke2VuZC50b0lTTygpfWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQW4gSW50ZXJ2YWwgb2JqZWN0IHJlcHJlc2VudHMgYSBoYWxmLW9wZW4gaW50ZXJ2YWwgb2YgdGltZSwgd2hlcmUgZWFjaCBlbmRwb2ludCBpcyBhIHtAbGluayBEYXRlVGltZX0uIENvbmNlcHR1YWxseSwgaXQncyBhIGNvbnRhaW5lciBmb3IgdGhvc2UgdHdvIGVuZHBvaW50cywgYWNjb21wYW5pZWQgYnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIGNvbXBhcmluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gSW50ZXJ2YWw6XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGFuIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsLmZyb21EYXRlVGltZXN9LCB7QGxpbmsgSW50ZXJ2YWwuYWZ0ZXJ9LCB7QGxpbmsgSW50ZXJ2YWwuYmVmb3JlfSwgb3Ige0BsaW5rIEludGVydmFsLmZyb21JU099LlxuICogKiAqKkFjY2Vzc29ycyoqIFVzZSB7QGxpbmsgSW50ZXJ2YWwjc3RhcnR9IGFuZCB7QGxpbmsgSW50ZXJ2YWwjZW5kfSB0byBnZXQgdGhlIHN0YXJ0IGFuZCBlbmQuXG4gKiAqICoqSW50ZXJyb2dhdGlvbioqIFRvIGFuYWx5emUgdGhlIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsI2NvdW50fSwge0BsaW5rIEludGVydmFsI2xlbmd0aH0sIHtAbGluayBJbnRlcnZhbCNoYXNTYW1lfSwge0BsaW5rIEludGVydmFsI2NvbnRhaW5zfSwge0BsaW5rIEludGVydmFsI2lzQWZ0ZXJ9LCBvciB7QGxpbmsgSW50ZXJ2YWwjaXNCZWZvcmV9LlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG90aGVyIEludGVydmFscyBvdXQgb2YgdGhpcyBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjc2V0fSwge0BsaW5rIEludGVydmFsI3NwbGl0QXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRCeX0sIHtAbGluayBJbnRlcnZhbCNkaXZpZGVFcXVhbGx5fSwge0BsaW5rIEludGVydmFsLm1lcmdlfSwge0BsaW5rIEludGVydmFsLnhvcn0sIHtAbGluayBJbnRlcnZhbCN1bmlvbn0sIHtAbGluayBJbnRlcnZhbCNpbnRlcnNlY3Rpb259LCBvciB7QGxpbmsgSW50ZXJ2YWwjZGlmZmVyZW5jZX0uXG4gKiAqICoqQ29tcGFyaXNvbioqIFRvIGNvbXBhcmUgdGhpcyBJbnRlcnZhbCB0byBhbm90aGVyIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNlcXVhbHN9LCB7QGxpbmsgSW50ZXJ2YWwjb3ZlcmxhcHN9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNTdGFydH0sIHtAbGluayBJbnRlcnZhbCNhYnV0c0VuZH0sIHtAbGluayBJbnRlcnZhbCNlbmd1bGZzfVxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIEludGVydmFsIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIEludGVydmFsI3RvU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvSVNPfSwge0BsaW5rIEludGVydmFsI3RvSVNPRGF0ZX0sIHtAbGluayBJbnRlcnZhbCN0b0lTT1RpbWV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Gb3JtYXR9LCBhbmQge0BsaW5rIEludGVydmFsI3RvRHVyYXRpb259LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnZhbCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zID0gY29uZmlnLnN0YXJ0O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZSA9IGNvbmZpZy5lbmQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25JbnRlcnZhbCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIEludGVydmFsIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgSW50ZXJ2YWwgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEludGVydmFsRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhbiBlbmQgRGF0ZVRpbWUuIEluY2x1c2l2ZSBvZiB0aGUgc3RhcnQgYnV0IG5vdCB0aGUgZW5kLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVpbHRTdGFydCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpLFxuICAgICAgYnVpbHRFbmQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG5cbiAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gdmFsaWRhdGVTdGFydEVuZChidWlsdFN0YXJ0LCBidWlsdEVuZCk7XG5cbiAgICBpZiAodmFsaWRhdGVFcnJvciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHtcbiAgICAgICAgc3RhcnQ6IGJ1aWx0U3RhcnQsXG4gICAgICAgIGVuZDogYnVpbHRFbmQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGFmdGVyKHN0YXJ0LCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdCwgZHQucGx1cyhkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBlbmQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIGJhY2t3YXJkcyB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYmVmb3JlKGVuZCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0Lm1pbnVzKGR1ciksIGR0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBJU08gODYwMSBzdHJpbmcuXG4gICAqIEFjY2VwdHMgYDxzdGFydD4vPGVuZD5gLCBgPHN0YXJ0Pi88ZHVyYXRpb24+YCwgYW5kIGA8ZHVyYXRpb24+LzxlbmQ+YCBmb3JtYXRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25zIHRvIHBhc3Mge0BsaW5rIERhdGVUaW1lI2Zyb21JU099IGFuZCBvcHRpb25hbGx5IHtAbGluayBEdXJhdGlvbiNmcm9tSVNPfVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtzLCBlXSA9ICh0ZXh0IHx8IFwiXCIpLnNwbGl0KFwiL1wiLCAyKTtcbiAgICBpZiAocyAmJiBlKSB7XG4gICAgICBsZXQgc3RhcnQsIHN0YXJ0SXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gc3RhcnQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbmQsIGVuZElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBlbmQgPSBEYXRlVGltZS5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBlbmRJc1ZhbGlkID0gZW5kLmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVuZElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCAmJiBlbmRJc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5hZnRlcihzdGFydCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5iZWZvcmUoZW5kLCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBJbnRlcnZhbC4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzSW50ZXJ2YWwobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25JbnRlcnZhbCkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmQgb2YgdGhlIEludGVydmFsLiBUaGlzIGlzIHRoZSBmaXJzdCBpbnN0YW50IHdoaWNoIGlzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcnZhbFxuICAgKiAoSW50ZXJ2YWwgaXMgaGFsZi1vcGVuKS5cbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IERhdGVUaW1lIGluY2x1ZGVkIGluIHRoZSBpbnRlcnZhbCAoc2luY2UgZW5kIGlzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcnZhbClcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGxhc3REYXRlVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gKHRoaXMuZSA/IHRoaXMuZS5taW51cygxKSA6IG51bGwpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZFJlYXNvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoKHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbiguLi5bdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBtaW51dGVzLCBob3VycywgZGF5cywgbW9udGhzLCBvciB5ZWFycyBpbmNsdWRlZCBpbiB0aGUgSW50ZXJ2YWwsIGV2ZW4gaW4gcGFydC5cbiAgICogVW5saWtlIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9IHRoaXMgY291bnRzIHNlY3Rpb25zIG9mIHRoZSBjYWxlbmRhciwgbm90IHBlcmlvZHMgb2YgdGltZSwgZS5nLiBzcGVjaWZ5aW5nICdkYXknXG4gICAqIGFza3MgJ3doYXQgZGF0ZXMgYXJlIGluY2x1ZGVkIGluIHRoaXMgaW50ZXJ2YWw/Jywgbm90ICdob3cgbWFueSBkYXlzIGxvbmcgaXMgdGhpcyBpbnRlcnZhbD8nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdD0nbWlsbGlzZWNvbmRzJ10gLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy51c2VMb2NhbGVXZWVrcz1mYWxzZV0gLSBJZiB0cnVlLCB1c2Ugd2Vla3MgYmFzZWQgb24gdGhlIGxvY2FsZSwgaS5lLiB1c2UgdGhlIGxvY2FsZS1kZXBlbmRlbnQgc3RhcnQgb2YgdGhlIHdlZWs7IHRoaXMgb3BlcmF0aW9uIHdpbGwgYWx3YXlzIHVzZSB0aGUgbG9jYWxlIG9mIHRoZSBzdGFydCBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb3VudCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQsIG9wdHMpO1xuICAgIGxldCBlbmQ7XG4gICAgaWYgKG9wdHM/LnVzZUxvY2FsZVdlZWtzKSB7XG4gICAgICBlbmQgPSB0aGlzLmVuZC5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogc3RhcnQubG9jYWxlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0aGlzLmVuZDtcbiAgICB9XG4gICAgZW5kID0gZW5kLnN0YXJ0T2YodW5pdCwgb3B0cyk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KSkgKyAoZW5kLnZhbHVlT2YoKSAhPT0gdGhpcy5lbmQudmFsdWVPZigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGFuZCBlbmQgYXJlIGJvdGggaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZSh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuaXNFbXB0eSgpIHx8IHRoaXMuZS5taW51cygxKS5oYXNTYW1lKHRoaXMucywgdW5pdCkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIERhdGVUaW1lcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucy52YWx1ZU9mKCkgPT09IHRoaXMuZS52YWx1ZU9mKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FmdGVyKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQmVmb3JlKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5lIDw9IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgY29udGFpbnMgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IGRhdGVUaW1lICYmIHRoaXMuZSA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0c1wiIHRoZSBzdGFydCBhbmQvb3IgZW5kIGRhdGVzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgdmFsdWVzIHRvIHNldFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuc3RhcnQgLSB0aGUgc3RhcnRpbmcgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLmVuZCAtIHRoZSBlbmRpbmcgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzZXQoeyBzdGFydCwgZW5kIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCB8fCB0aGlzLnMsIGVuZCB8fCB0aGlzLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgYXQgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIERhdGVUaW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QXQoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICBjb25zdCBzb3J0ZWQgPSBkYXRlVGltZXNcbiAgICAgICAgLm1hcChmcmllbmRseURhdGVUaW1lKVxuICAgICAgICAuZmlsdGVyKChkKSA9PiB0aGlzLmNvbnRhaW5zKGQpKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS50b01pbGxpcygpIC0gYi50b01pbGxpcygpKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIEludGVydmFsIGZ1bGx5IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwsIHNwZWNpZmljYWxseSBpZiB0aGUgaW50ZXJzZWN0IChvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgb3RoZXIgSW50ZXJ2YWwpIGlzIGVxdWFsIHRvIHRoZSBvdGhlciBJbnRlcnZhbDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGFuIGVxdWl2YWxlbnQgbWluaW1hbCBzZXQgb2YgSW50ZXJ2YWxzLlxuICAgKiBDb21iaW5lcyBvdmVybGFwcGluZyBhbmQgYWRqYWNlbnQgSW50ZXJ2YWxzLlxuICAgKiBUaGUgcmVzdWx0aW5nIGFycmF5IHdpbGwgY29udGFpbiB0aGUgSW50ZXJ2YWxzIGluIGFzY2VuZGluZyBvcmRlciwgdGhhdCBpcywgc3RhcnRpbmcgd2l0aCB0aGUgZWFybGllc3QgSW50ZXJ2YWxcbiAgICogYW5kIGVuZGluZyB3aXRoIHRoZSBsYXRlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IOKAkyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgSW50ZXJ2YWwgeyBzdGFydDogJHt0aGlzLnMudG9JU08oKX0sIGVuZDogJHt0aGlzLmUudG9JU08oKX0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgSW50ZXJ2YWwgeyBJbnZhbGlkLCByZWFzb246ICR7dGhpcy5pbnZhbGlkUmVhc29ufSB9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgSW50ZXJ2YWwuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGVcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhc1xuICAgKiB7QGxpbmsgRGF0ZVRpbWUuREFURV9GVUxMfSBvciB7QGxpbmsgRGF0ZVRpbWUuVElNRV9TSU1QTEV9LiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2RcbiAgICogaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAqIEludGVydmFsIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuXG4gICAqIHNwZWNpZmllZC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Zvcm1hdE9wdHM9RGF0ZVRpbWUuREFURV9TSE9SVF0gLSBFaXRoZXIgYSBEYXRlVGltZSBwcmVzZXQgb3JcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHN0YXJ0IERhdGVUaW1lLlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gMTEvNy8yMDIyIOKAkyAxMS84LzIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+IE5vdmVtYmVyIDcg4oCTIDgsIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnItRlInIH0pOyAvLz0+IDfigJM4IG5vdmVtYnJlIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gNjowMCDigJMgODowMCBQTVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+IE1vbiwgTm92IDA3LCA2OjAwIOKAkyA4OjAwIHBcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMucy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdEludGVydmFsKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08ob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPKG9wdHMpfS8ke3RoaXMuZS50b0lTTyhvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBkYXRlIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSB0aW1lIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPRGF0ZSgpfS8ke3RoaXMuZS50b0lTT0RhdGUoKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aW1lIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSBkYXRlIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT1RpbWUob3B0cyl9LyR7dGhpcy5lLnRvSVNPVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0XG4gICAqIHN0cmluZy4gKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZVxuICAgKiBmb3JtYXR0aW5nIHRvb2wuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnNlcGFyYXRvciA9ICAnIOKAkyAnXSAtIEEgc2VwYXJhdG9yIHRvIHBsYWNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICogcmVwcmVzZW50YXRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChkYXRlRm9ybWF0LCB7IHNlcGFyYXRvciA9IFwiIOKAkyBcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0Zvcm1hdChkYXRlRm9ybWF0KX0ke3NlcGFyYXRvcn0ke3RoaXMuZS50b0Zvcm1hdChkYXRlRm9ybWF0KX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIER1cmF0aW9uIHJlcHJlc2VudGluZyB0aGUgdGltZSBzcGFubmVkIGJ5IHRoaXMgaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDg4NDg5MjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignZGF5cycpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDEuMDI0MTgxMjE1Mjc3Nzc3OCB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQuODIwOTUgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQsIHNlY29uZHM6IDQ5LjI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ3NlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBzZWNvbmRzOiA4ODQ4OS4yNTcgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHRvRHVyYXRpb24odW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZCh0aGlzLmludmFsaWRSZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lLmRpZmYodGhpcy5zLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gbWFwRm4gb24gdGhlIGludGVydmFsIHN0YXJ0IGFuZCBlbmQsIHJldHVybmluZyBhIG5ldyBJbnRlcnZhbCBmcm9tIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQudG9VVEMoKSlcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnBsdXMoeyBob3VyczogMiB9KSlcbiAgICovXG4gIG1hcEVuZHBvaW50cyhtYXBGbikge1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKG1hcEZuKHRoaXMucyksIG1hcEZuKHRoaXMuZSkpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/interval.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/luxon.js":
/*!***********************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/luxon.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* reexport safe */ _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Duration: () => (/* reexport safe */ _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   FixedOffsetZone: () => (/* reexport safe */ _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   IANAZone: () => (/* reexport safe */ _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   Info: () => (/* reexport safe */ _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   Interval: () => (/* reexport safe */ _interval_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   InvalidZone: () => (/* reexport safe */ _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   Settings: () => (/* reexport safe */ _settings_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   SystemZone: () => (/* reexport safe */ _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Zone: () => (/* reexport safe */ _zone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/info.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zones/invalidZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"3.7.1\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvbHV4b24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0E7QUFDQTtBQUNSO0FBQ0E7QUFDNEI7QUFDZDtBQUNNO0FBQ0Y7QUFDVjs7QUFFckM7O0FBY0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2x1eG9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuL3pvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjMuNy4xXCI7XG5cbmV4cG9ydCB7XG4gIFZFUlNJT04sXG4gIERhdGVUaW1lLFxuICBEdXJhdGlvbixcbiAgSW50ZXJ2YWwsXG4gIEluZm8sXG4gIFpvbmUsXG4gIEZpeGVkT2Zmc2V0Wm9uZSxcbiAgSUFOQVpvbmUsXG4gIEludmFsaWRab25lLFxuICBTeXN0ZW1ab25lLFxuICBTZXR0aW5ncyxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/luxon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js":
/*!**************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/settings.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Settings)\n/* harmony export */ });\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_digits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/digits.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/digits.js\");\n\n\n\n\n\n\n\n\n\nlet now = () => Date.now(),\n  defaultZone = \"system\",\n  defaultLocale = null,\n  defaultNumberingSystem = null,\n  defaultOutputCalendar = null,\n  twoDigitCutoffYear = 60,\n  throwOnInvalid,\n  defaultWeekSettings = null;\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.\n */\nclass Settings {\n  /**\n   * Get the callback for returning the current timestamp.\n   * @type {function}\n   */\n  static get now() {\n    return now;\n  }\n\n  /**\n   * Set the callback for returning the current timestamp.\n   * The function should return a number, which will be interpreted as an Epoch millisecond count\n   * @type {function}\n   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n   */\n  static set now(n) {\n    now = n;\n  }\n\n  /**\n   * Set the default time zone to create DateTimes in. Does not affect existing instances.\n   * Use the value \"system\" to reset this value to the system's time zone.\n   * @type {string}\n   */\n  static set defaultZone(zone) {\n    defaultZone = zone;\n  }\n\n  /**\n   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.\n   * The default value is the system's time zone (the one set on the machine that runs this code).\n   * @type {Zone}\n   */\n  static get defaultZone() {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(defaultZone, _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance);\n  }\n\n  /**\n   * Get the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultLocale() {\n    return defaultLocale;\n  }\n\n  /**\n   * Set the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultLocale(locale) {\n    defaultLocale = locale;\n  }\n\n  /**\n   * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultNumberingSystem() {\n    return defaultNumberingSystem;\n  }\n\n  /**\n   * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultNumberingSystem(numberingSystem) {\n    defaultNumberingSystem = numberingSystem;\n  }\n\n  /**\n   * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultOutputCalendar() {\n    return defaultOutputCalendar;\n  }\n\n  /**\n   * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultOutputCalendar(outputCalendar) {\n    defaultOutputCalendar = outputCalendar;\n  }\n\n  /**\n   * @typedef {Object} WeekSettings\n   * @property {number} firstDay\n   * @property {number} minimalDays\n   * @property {number[]} weekend\n   */\n\n  /**\n   * @return {WeekSettings|null}\n   */\n  static get defaultWeekSettings() {\n    return defaultWeekSettings;\n  }\n\n  /**\n   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and\n   * how many days are required in the first week of a year.\n   * Does not affect existing instances.\n   *\n   * @param {WeekSettings|null} weekSettings\n   */\n  static set defaultWeekSettings(weekSettings) {\n    defaultWeekSettings = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.validateWeekSettings)(weekSettings);\n  }\n\n  /**\n   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   */\n  static get twoDigitCutoffYear() {\n    return twoDigitCutoffYear;\n  }\n\n  /**\n   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century\n   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century\n   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950\n   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50\n   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50\n   */\n  static set twoDigitCutoffYear(cutoffYear) {\n    twoDigitCutoffYear = cutoffYear % 100;\n  }\n\n  /**\n   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static get throwOnInvalid() {\n    return throwOnInvalid;\n  }\n\n  /**\n   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static set throwOnInvalid(t) {\n    throwOnInvalid = t;\n  }\n\n  /**\n   * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCaches() {\n    _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resetCache();\n    _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resetCache();\n    _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].resetCache();\n    (0,_impl_digits_js__WEBPACK_IMPORTED_MODULE_6__.resetDigitRegexCache)();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBK0M7QUFDSjtBQUNMO0FBQ0Q7O0FBRWM7QUFDRztBQUNFOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsZ0VBQWEsY0FBYyw0REFBVTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsVUFBVTtBQUMxQjs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBLDBCQUEwQixtRUFBb0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxJQUFJLHVEQUFNO0FBQ1YsSUFBSSwwREFBUTtBQUNaLElBQUksb0RBQVE7QUFDWixJQUFJLHFFQUFvQjtBQUN4QjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9zZXR0aW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuXG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVXZWVrU2V0dGluZ3MgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IHJlc2V0RGlnaXRSZWdleENhY2hlIH0gZnJvbSBcIi4vaW1wbC9kaWdpdHMuanNcIjtcblxubGV0IG5vdyA9ICgpID0+IERhdGUubm93KCksXG4gIGRlZmF1bHRab25lID0gXCJzeXN0ZW1cIixcbiAgZGVmYXVsdExvY2FsZSA9IG51bGwsXG4gIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudWxsLFxuICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBudWxsLFxuICB0d29EaWdpdEN1dG9mZlllYXIgPSA2MCxcbiAgdGhyb3dPbkludmFsaWQsXG4gIGRlZmF1bHRXZWVrU2V0dGluZ3MgPSBudWxsO1xuXG4vKipcbiAqIFNldHRpbmdzIGNvbnRhaW5zIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgY29udHJvbCBMdXhvbidzIG92ZXJhbGwgYmVoYXZpb3IuIEx1eG9uIGlzIGEgc2ltcGxlIGxpYnJhcnkgd2l0aCBmZXcgb3B0aW9ucywgYnV0IHRoZSBvbmVzIGl0IGRvZXMgaGF2ZSBsaXZlIGhlcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgbm93KCkge1xuICAgIHJldHVybiBub3c7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXIsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gRXBvY2ggbWlsbGlzZWNvbmQgY291bnRcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiBEYXRlLm5vdygpICsgMzAwMCAvLyBwcmV0ZW5kIGl0IGlzIDMgc2Vjb25kcyBpbiB0aGUgZnV0dXJlXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IDAgLy8gYWx3YXlzIHByZXRlbmQgaXQncyBKYW4gMSwgMTk3MCBhdCBtaWRuaWdodCBpbiBVVEMgdGltZVxuICAgKi9cbiAgc3RhdGljIHNldCBub3cobikge1xuICAgIG5vdyA9IG47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSB0byBjcmVhdGUgRGF0ZVRpbWVzIGluLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBVc2UgdGhlIHZhbHVlIFwic3lzdGVtXCIgdG8gcmVzZXQgdGhpcyB2YWx1ZSB0byB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0Wm9uZSh6b25lKSB7XG4gICAgZGVmYXVsdFpvbmUgPSB6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgb2JqZWN0IGN1cnJlbnRseSB1c2VkIHRvIGNyZWF0ZSBEYXRlVGltZXMuIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUgKHRoZSBvbmUgc2V0IG9uIHRoZSBtYWNoaW5lIHRoYXQgcnVucyB0aGlzIGNvZGUpLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFpvbmUoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoZGVmYXVsdFpvbmUsIFN5c3RlbVpvbmUuaW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TG9jYWxlKCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TG9jYWxlKGxvY2FsZSkge1xuICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbShudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKG91dHB1dENhbGVuZGFyKSB7XG4gICAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gV2Vla1NldHRpbmdzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXJzdERheVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluaW1hbERheXNcbiAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gd2Vla2VuZFxuICAgKi9cblxuICAvKipcbiAgICogQHJldHVybiB7V2Vla1NldHRpbmdzfG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRXZWVrU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXZWVrU2V0dGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgbG9jYWxlIHdlZWsgc2V0dGluZ3MsIGkuZS4gdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCB0aGUgd2Vla2VuZCBhbmRcbiAgICogaG93IG1hbnkgZGF5cyBhcmUgcmVxdWlyZWQgaW4gdGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyLlxuICAgKiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlZWtTZXR0aW5nc3xudWxsfSB3ZWVrU2V0dGluZ3NcbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFdlZWtTZXR0aW5ncyh3ZWVrU2V0dGluZ3MpIHtcbiAgICBkZWZhdWx0V2Vla1NldHRpbmdzID0gdmFsaWRhdGVXZWVrU2V0dGluZ3Mod2Vla1NldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1dG9mZiB5ZWFyIGZvciB3aGV0aGVyIGEgMi1kaWdpdCB5ZWFyIHN0cmluZyBpcyBpbnRlcnByZXRlZCBpbiB0aGUgY3VycmVudCBvciBwcmV2aW91cyBjZW50dXJ5LiBOdW1iZXJzIGhpZ2hlciB0aGFuIHRoZSBjdXRvZmYgd2lsbCBiZSBjb25zaWRlcmVkIHRvIG1lYW4gMTl4eCBhbmQgbnVtYmVycyBsb3dlciBvciBlcXVhbCB0byB0aGUgY3V0b2ZmIHdpbGwgYmUgY29uc2lkZXJlZCAyMHh4LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldCB0d29EaWdpdEN1dG9mZlllYXIoKSB7XG4gICAgcmV0dXJuIHR3b0RpZ2l0Q3V0b2ZmWWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1dG9mZiB5ZWFyIGZvciB3aGV0aGVyIGEgMi1kaWdpdCB5ZWFyIHN0cmluZyBpcyBpbnRlcnByZXRlZCBpbiB0aGUgY3VycmVudCBvciBwcmV2aW91cyBjZW50dXJ5LiBOdW1iZXJzIGhpZ2hlciB0aGFuIHRoZSBjdXRvZmYgd2lsbCBiZSBjb25zaWRlcmVkIHRvIG1lYW4gMTl4eCBhbmQgbnVtYmVycyBsb3dlciBvciBlcXVhbCB0byB0aGUgY3V0b2ZmIHdpbGwgYmUgY29uc2lkZXJlZCAyMHh4LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAwIC8vIGFsbCAneXknIGFyZSBpbnRlcnByZXRlZCBhcyAyMHRoIGNlbnR1cnlcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gOTkgLy8gYWxsICd5eScgYXJlIGludGVycHJldGVkIGFzIDIxc3QgY2VudHVyeVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSA1MCAvLyAnNDknIC0+IDIwNDk7ICc1MCcgLT4gMTk1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAxOTUwIC8vIGludGVycHJldGVkIGFzIDUwXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDIwNTAgLy8gQUxTTyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKi9cbiAgc3RhdGljIHNldCB0d29EaWdpdEN1dG9mZlllYXIoY3V0b2ZmWWVhcikge1xuICAgIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IGN1dG9mZlllYXIgJSAxMDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCB0aHJvd09uSW52YWxpZCgpIHtcbiAgICByZXR1cm4gdGhyb3dPbkludmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldCB0aHJvd09uSW52YWxpZCh0KSB7XG4gICAgdGhyb3dPbkludmFsaWQgPSB0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IEx1eG9uJ3MgZ2xvYmFsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGVzKCkge1xuICAgIExvY2FsZS5yZXNldENhY2hlKCk7XG4gICAgSUFOQVpvbmUucmVzZXRDYWNoZSgpO1xuICAgIERhdGVUaW1lLnJlc2V0Q2FjaGUoKTtcbiAgICByZXNldERpZ2l0UmVnZXhDYWNoZSgpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/settings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js":
/*!**********************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/zone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Zone)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/errors.js\");\n\n\n/**\n * @interface\n */\nclass Zone {\n  /**\n   * The type of zone\n   * @abstract\n   * @type {string}\n   */\n  get type() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The name of this zone.\n   * @abstract\n   * @type {string}\n   */\n  get name() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The IANA name of this zone.\n   * Defaults to `name` if not overwritten by a subclass.\n   * @abstract\n   * @type {string}\n   */\n  get ianaName() {\n    return this.name;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year.\n   * @abstract\n   * @type {boolean}\n   */\n  get isUniversal() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, opts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @abstract\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @abstract\n   * @type {boolean}\n   */\n  get isValid() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWm9uZUlzQWJzdHJhY3RFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9uZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUFOQSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogRGVmYXVsdHMgdG8gYG5hbWVgIGlmIG5vdCBvdmVyd3JpdHRlbiBieSBhIHN1YmNsYXNzLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js":
/*!********************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ IANAZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js\");\n\n\n\nconst dtfCache = new Map();\nfunction makeDTF(zoneName) {\n  let dtf = dtfCache.get(zoneName);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zoneName,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n    dtfCache.set(zoneName, dtf);\n  }\n  return dtf;\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nconst ianaZoneCache = new Map();\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nclass IANAZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    let zone = ianaZoneCache.get(name);\n    if (zone === undefined) {\n      ianaZoneCache.set(name, (zone = new IANAZone(name)));\n    }\n    return zone;\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache.clear();\n    dtfCache.clear();\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /**\n   * The type of zone. `iana` for all instances of `IANAZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"iana\";\n  }\n\n  /**\n   * The name of this zone (i.e. the IANA zone name).\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.zoneName;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns false for all IANA zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return false;\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale, this.name);\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    if (!this.valid) return NaN;\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.objToLocalTS)({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.valid;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlGO0FBQzNEOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QyxZQUFZLGNBQWM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLE1BQU0sVUFBVSwwREFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNlLHVCQUF1QixnREFBSTtBQUMxQztBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxSkFBcUo7QUFDckosYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLFdBQVcsNERBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVywyREFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiwyREFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9JQU5BWm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8sIGlzVW5kZWZpbmVkLCBvYmpUb0xvY2FsVFMgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5jb25zdCBkdGZDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIG1ha2VEVEYoem9uZU5hbWUpIHtcbiAgbGV0IGR0ZiA9IGR0ZkNhY2hlLmdldCh6b25lTmFtZSk7XG4gIGlmIChkdGYgPT09IHVuZGVmaW5lZCkge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIHRpbWVab25lOiB6b25lTmFtZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgICBlcmE6IFwic2hvcnRcIixcbiAgICB9KTtcbiAgICBkdGZDYWNoZS5zZXQoem9uZU5hbWUsIGR0Zik7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxuY29uc3QgdHlwZVRvUG9zID0ge1xuICB5ZWFyOiAwLFxuICBtb250aDogMSxcbiAgZGF5OiAyLFxuICBlcmE6IDMsXG4gIGhvdXI6IDQsXG4gIG1pbnV0ZTogNSxcbiAgc2Vjb25kOiA2LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspIChBRHxCQyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZDtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldO1xuICAgIGNvbnN0IHBvcyA9IHR5cGVUb1Bvc1t0eXBlXTtcblxuICAgIGlmICh0eXBlID09PSBcImVyYVwiKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHBvcykpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxuY29uc3QgaWFuYVpvbmVDYWNoZSA9IG5ldyBNYXAoKTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJQU5BWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG5hbWUpIHtcbiAgICBsZXQgem9uZSA9IGlhbmFab25lQ2FjaGUuZ2V0KG5hbWUpO1xuICAgIGlmICh6b25lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlhbmFab25lQ2FjaGUuc2V0KG5hbWUsICh6b25lID0gbmV3IElBTkFab25lKG5hbWUpKSk7XG4gICAgfVxuICAgIHJldHVybiB6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZS5jbGVhcigpO1xuICAgIGR0ZkNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzcGVjaWZpZXIuIFRoaXMgb25seSBjaGVja3MgdGhlIHN0cmluZydzIGZvcm1hdCwgbm90IHRoYXQgdGhlIHNwZWNpZmllciBpZGVudGlmaWVzIGEga25vd24gem9uZTsgc2VlIGlzVmFsaWRab25lIGZvciB0aGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gY2hlY2sgdmFsaWRpdHkgb25cbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAZGVwcmVjYXRlZCBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmb3J3YXJkcyB0byBpc1ZhbGlkWm9uZSwgYmV0dGVyIHVzZSBgaXNWYWxpZFpvbmUoKWAgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU3BlY2lmaWVyKHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkWm9uZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRab25lKHpvbmUpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogem9uZSB9KS5mb3JtYXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lLiBgaWFuYWAgZm9yIGFsbCBpbnN0YW5jZXMgb2YgYElBTkFab25lYC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpYW5hXCI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyB6b25lIChpLmUuIHRoZSBJQU5BIHpvbmUgbmFtZSkuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyOlxuICAgKiBBbHdheXMgcmV0dXJucyBmYWxzZSBmb3IgYWxsIElBTkEgem9uZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlLCB0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCh0cykge1xuICAgIGlmICghdGhpcy52YWxpZCkgcmV0dXJuIE5hTjtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSByZXR1cm4gTmFOO1xuXG4gICAgY29uc3QgZHRmID0gbWFrZURURih0aGlzLm5hbWUpO1xuICAgIGxldCBbeWVhciwgbW9udGgsIGRheSwgYWRPckJjLCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBkdGYuZm9ybWF0VG9QYXJ0c1xuICAgICAgPyBwYXJ0c09mZnNldChkdGYsIGRhdGUpXG4gICAgICA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSk7XG5cbiAgICBpZiAoYWRPckJjID09PSBcIkJDXCIpIHtcbiAgICAgIHllYXIgPSAtTWF0aC5hYnMoeWVhcikgKyAxO1xuICAgIH1cblxuICAgIC8vIGJlY2F1c2Ugd2UncmUgdXNpbmcgaG91cjEyIGFuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDI1NTY0JmNhbj0yJnE9JTIyMjQlM0EwMCUyMiUyMGRhdGV0aW1lZm9ybWF0XG4gICAgY29uc3QgYWRqdXN0ZWRIb3VyID0gaG91ciA9PT0gMjQgPyAwIDogaG91cjtcblxuICAgIGNvbnN0IGFzVVRDID0gb2JqVG9Mb2NhbFRTKHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICAgIGhvdXI6IGFkanVzdGVkSG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IGFzVFMgPSArZGF0ZTtcbiAgICBjb25zdCBvdmVyID0gYXNUUyAlIDEwMDA7XG4gICAgYXNUUyAtPSBvdmVyID49IDAgPyBvdmVyIDogMTAwMCArIG92ZXI7XG4gICAgcmV0dXJuIChhc1VUQyAtIGFzVFMpIC8gKDYwICogMTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImlhbmFcIiAmJiBvdGhlclpvbmUubmFtZSA9PT0gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/IANAZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js":
/*!***************************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FixedOffsetZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * A zone with a fixed offset (meaning no DST)\n * @implements {Zone}\n */\nclass FixedOffsetZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of UTC\n   * @return {FixedOffsetZone}\n   */\n  static get utcInstance() {\n    if (singleton === null) {\n      singleton = new FixedOffsetZone(0);\n    }\n    return singleton;\n  }\n\n  /**\n   * Get an instance with a specified offset\n   * @param {number} offset - The offset in minutes\n   * @return {FixedOffsetZone}\n   */\n  static instance(offset) {\n    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);\n  }\n\n  /**\n   * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n   * @param {string} s - The offset string to parse\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+6\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+06\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n   * @return {FixedOffsetZone}\n   */\n  static parseSpecifier(s) {\n    if (s) {\n      const r = s.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\n      if (r) {\n        return new FixedOffsetZone((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(r[1], r[2]));\n      }\n    }\n    return null;\n  }\n\n  constructor(offset) {\n    super();\n    /** @private **/\n    this.fixed = offset;\n  }\n\n  /**\n   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"fixed\";\n  }\n\n  /**\n   * The name of this zone.\n   * All fixed zones' names always start with \"UTC\" (plus optional offset)\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.fixed === 0 ? \"UTC\" : `UTC${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, \"narrow\")}`;\n  }\n\n  /**\n   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`\n   *\n   * @override\n   * @type {string}\n   */\n  get ianaName() {\n    if (this.fixed === 0) {\n      return \"Etc/UTC\";\n    } else {\n      return `Etc/GMT${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(-this.fixed, \"narrow\")}`;\n    }\n  }\n\n  /**\n   * Returns the offset's common name at the specified timestamp.\n   *\n   * For fixed offset zones this equals to the zone name.\n   * @override\n   */\n  offsetName() {\n    return this.name;\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, format);\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns true for all fixed offset zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return true;\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   *\n   * For fixed offset zones, this is constant and does not depend on a timestamp.\n   * @override\n   * @return {number}\n   */\n  offset() {\n    return this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"fixed\" && otherZone.fixed === this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is valid:\n   * All fixed offset zones are valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RDtBQUMvQjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNlLDhCQUE4QixnREFBSTtBQUNqRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJLFNBQVMsRUFBRTtBQUN2RDtBQUNBLG1DQUFtQywyREFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNENBQTRDLDJEQUFZLHVCQUF1QjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1QkFBdUIsMkRBQVksd0JBQXdCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVcsMkRBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY2xpZW50LWFwaS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHNpZ25lZE9mZnNldCB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIEEgem9uZSB3aXRoIGEgZml4ZWQgb2Zmc2V0IChtZWFuaW5nIG5vIERTVClcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZE9mZnNldFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBVVENcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCB1dGNJbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgRml4ZWRPZmZzZXRab25lKDApO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWVkIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBpbiBtaW51dGVzXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBpbnN0YW5jZShvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlIDogbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBGaXhlZE9mZnNldFpvbmUgZnJvbSBhIFVUQyBvZmZzZXQgc3RyaW5nLCBsaWtlIFwiVVRDKzZcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBvZmZzZXQgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQys2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQyswNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMtNjowMFwiKVxuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VTcGVjaWZpZXIocykge1xuICAgIGlmIChzKSB7XG4gICAgICBjb25zdCByID0gcy5tYXRjaCgvXnV0Yyg/OihbKy1dXFxkezEsMn0pKD86OihcXGR7Mn0pKT8pPyQvaSk7XG4gICAgICBpZiAocikge1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkT2Zmc2V0Wm9uZShzaWduZWRPZmZzZXQoclsxXSwgclsyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9mZnNldCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMuZml4ZWQgPSBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygem9uZS4gYGZpeGVkYCBmb3IgYWxsIGluc3RhbmNlcyBvZiBgRml4ZWRPZmZzZXRab25lYC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJmaXhlZFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQWxsIGZpeGVkIHpvbmVzJyBuYW1lcyBhbHdheXMgc3RhcnQgd2l0aCBcIlVUQ1wiIChwbHVzIG9wdGlvbmFsIG9mZnNldClcbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZCA9PT0gMCA/IFwiVVRDXCIgOiBgVVRDJHtmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUFOQSBuYW1lIG9mIHRoaXMgem9uZSwgaS5lLiBgRXRjL1VUQ2Agb3IgYEV0Yy9HTVQrLy1ubmBcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaWFuYU5hbWUoKSB7XG4gICAgaWYgKHRoaXMuZml4ZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBcIkV0Yy9VVENcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBFdGMvR01UJHtmb3JtYXRPZmZzZXQoLXRoaXMuZml4ZWQsIFwibmFycm93XCIpfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIGNvbW1vbiBuYW1lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKlxuICAgKiBGb3IgZml4ZWQgb2Zmc2V0IHpvbmVzIHRoaXMgZXF1YWxzIHRvIHRoZSB6b25lIG5hbWUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG9mZnNldCBpcyBrbm93biB0byBiZSBmaXhlZCBmb3IgdGhlIHdob2xlIHllYXI6XG4gICAqIEFsd2F5cyByZXR1cm5zIHRydWUgZm9yIGFsbCBmaXhlZCBvZmZzZXQgem9uZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEZvciBmaXhlZCBvZmZzZXQgem9uZXMsIHRoaXMgaXMgY29uc3RhbnQgYW5kIGRvZXMgbm90IGRlcGVuZCBvbiBhIHRpbWVzdGFtcC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgZXF1YWwgdG8gYW5vdGhlciB6b25lIChpLmUuIGFsc28gZml4ZWQgYW5kIHNhbWUgb2Zmc2V0KVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImZpeGVkXCIgJiYgb3RoZXJab25lLmZpeGVkID09PSB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZDpcbiAgICogQWxsIGZpeGVkIG9mZnNldCB6b25lcyBhcmUgdmFsaWQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/fixedOffsetZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/invalidZone.js":
/*!***********************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/zones/invalidZone.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InvalidZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js\");\n\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n * @implements {Zone}\n */\nclass InvalidZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(zoneName) {\n    super();\n    /**  @private */\n    this.zoneName = zoneName;\n  }\n\n  /** @override **/\n  get type() {\n    return \"invalid\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName() {\n    return null;\n  }\n\n  /** @override **/\n  formatOffset() {\n    return \"\";\n  }\n\n  /** @override **/\n  offset() {\n    return NaN;\n  }\n\n  /** @override **/\n  equals() {\n    return false;\n  }\n\n  /** @override **/\n  get isValid() {\n    return false;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvaW52YWxpZFpvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEI7O0FBRTlCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDZSwwQkFBMEIsZ0RBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9pbnZhbGlkWm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgY29uc3RydWN0b3Ioem9uZU5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/invalidZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/systemZone.js":
/*!**********************************************************************!*\
  !*** ../fjell-client-api/node_modules/luxon/src/zones/systemZone.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SystemZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * Represents the local zone for this JavaScript environment.\n * @implements {Zone}\n */\nclass SystemZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of the local zone\n   * @return {SystemZone}\n   */\n  static get instance() {\n    if (singleton === null) {\n      singleton = new SystemZone();\n    }\n    return singleton;\n  }\n\n  /** @override **/\n  get type() {\n    return \"system\";\n  }\n\n  /** @override **/\n  get name() {\n    return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    return -new Date(ts).getTimezoneOffset();\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"system\";\n  }\n\n  /** @override **/\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jbGllbnQtYXBpL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvc3lzdGVtWm9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFDaEM7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDZSx5QkFBeUIsZ0RBQUk7QUFDNUM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkMsV0FBVyw0REFBYTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyREFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNsaWVudC1hcGkvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9zeXN0ZW1ab25lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGxvY2FsIHpvbmUgZm9yIHRoaXMgSmF2YVNjcmlwdCBlbnZpcm9ubWVudC5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeXN0ZW1ab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGxvY2FsIHpvbmVcbiAgICogQHJldHVybiB7U3lzdGVtWm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgaW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IFN5c3RlbVpvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICByZXR1cm4gLW5ldyBEYXRlKHRzKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-client-api/node_modules/luxon/src/zones/systemZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-http-api/dist/index.js":
/*!***************************************!*\
  !*** ../fjell-http-api/dist/index.js ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   ForbiddenError: () => (/* binding */ ForbiddenError),\n/* harmony export */   GoneError: () => (/* binding */ GoneError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   MethodNotAllowedError: () => (/* binding */ MethodNotAllowedError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),\n/* harmony export */   RequestTimeoutError: () => (/* binding */ RequestTimeoutError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   ServiceUnavailableError: () => (/* binding */ ServiceUnavailableError),\n/* harmony export */   TooManyRequestsError: () => (/* binding */ TooManyRequestsError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   connectMethod: () => (/* binding */ connectMethod),\n/* harmony export */   deleteMethod: () => (/* binding */ deleteMethod2),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getHttp: () => (/* binding */ getHttp),\n/* harmony export */   getHttpApi: () => (/* binding */ getHttpApi),\n/* harmony export */   getHttpFile: () => (/* binding */ getHttpFile),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   optionsMethod: () => (/* binding */ optionsMethod),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   patchMethod: () => (/* binding */ patchMethod),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   postFileMethod: () => (/* binding */ postFileMethod2),\n/* harmony export */   postMethod: () => (/* binding */ postMethod),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   putMethod: () => (/* binding */ putMethod),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   traceMethod: () => (/* binding */ traceMethod),\n/* harmony export */   uploadAsyncMethod: () => (/* binding */ uploadAsyncMethod2)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-http-api/node_modules/@fjell/logging/dist/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// src/errors.ts\nvar APIError = class _APIError extends Error {\n    constructor(message, path, httpResponseCode, options2){\n        super(message, options2);\n        this.httpResponseCode = httpResponseCode;\n        this.path = path;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, _APIError);\n        }\n    }\n};\nvar ClientError = class extends APIError {\n    constructor(message, path, httpResponseCode, options2){\n        super(message, path, httpResponseCode, options2);\n    }\n};\nvar BadRequestError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 400, options2);\n    }\n};\nvar UnauthorizedError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 401, options2);\n    }\n};\nvar ForbiddenError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 403, options2);\n    }\n};\nvar NotFoundError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 404, options2);\n    }\n};\nvar MethodNotAllowedError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 405, options2);\n    }\n};\nvar RequestTimeoutError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 408, options2);\n    }\n};\nvar ConflictError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 409, options2);\n    }\n};\nvar GoneError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 410, options2);\n    }\n};\nvar TooManyRequestsError = class extends ClientError {\n    constructor(message, path, options2){\n        super(\"\".concat(message, \" \").concat(path), path, 429, options2);\n    }\n};\nvar ServerError = class extends APIError {\n    constructor(message, path, httpResponseCode, options2){\n        super(message, path, httpResponseCode, options2);\n    }\n};\nvar InternalServerError = class extends ServerError {\n    constructor(message, path, options2){\n        super(message, path, 500, options2);\n    }\n};\nvar NotImplementedError = class extends ServerError {\n    constructor(message, path, options2){\n        super(message, path, 501, options2);\n    }\n};\nvar ServiceUnavailableError = class extends ServerError {\n    constructor(message, path, options2){\n        super(message, path, 503, options2);\n    }\n};\n// src/api/util.ts\nvar getParameterValue = (value)=>{\n    if (value) {\n        return value instanceof Date ? value.toISOString() : value.toString();\n    } else {\n        return \"\";\n    }\n};\nvar generateQueryParameters = (params)=>Object.keys(params).length > 0 ? \"?\" + Object.keys(params).filter((key)=>params[key] !== void 0 && (typeof params[key] === \"string\" && params[key].length === 0) === false).map((key)=>{\n        let value;\n        if (params[key] === false) {\n            value = \"false\";\n        } else {\n            value = params[key];\n        }\n        return \"\".concat(key, \"=\").concat(encodeURIComponent(getParameterValue(value)));\n    }).join(\"&\") : \"\";\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/http-api\");\nvar logger_default = LibLogger;\n// src/api/http.ts\nvar logger = logger_default.get(\"api\", \"http\");\nfunction getHttp(apiParams) {\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(method, path) {\n        let body = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, httpOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        logger.trace(\"http\", {\n            method,\n            path,\n            body,\n            httpOptions\n        });\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...httpOptions\n        };\n        const config = apiParams.config;\n        const populateAuthHeader = apiParams.populateAuthHeader;\n        const headers = {};\n        if (!options2.skipContentType) {\n            headers[\"Content-Type\"] = options2.contentType;\n        }\n        headers[\"Accept\"] = options2.accept;\n        headers[\"X-Client-Name\"] = config.clientName;\n        const debugOptions = {\n            ...options2,\n            method,\n            path,\n            body\n        };\n        await populateAuthHeader(options2.isAuthenticated, headers);\n        logger.debug(\"http Request: %j, %j\", method, path);\n        const fetchOptions = {\n            method,\n            headers,\n            credentials: options2.requestCredentials\n        };\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            fetchOptions.body = body ? options2.isJsonBody ? JSON.stringify(body) : body : null;\n        }\n        const response = await fetch(\"\".concat(config.url).concat(path).concat(generateQueryParameters(options2.params)), fetchOptions);\n        let returnValue;\n        returnValue = await response.text();\n        if (response.status >= 400) {\n            let error;\n            if (response.status >= 500) {\n                if (response.status === 500) {\n                    error = new InternalServerError(response.statusText, path, debugOptions);\n                } else if (response.status === 501) {\n                    error = new NotImplementedError(response.statusText, path, debugOptions);\n                } else if (response.status === 503) {\n                    error = new ServiceUnavailableError(response.statusText, path, debugOptions);\n                } else {\n                    error = new ServerError(response.statusText, path, response.status, debugOptions);\n                }\n            } else {\n                if (response.status === 400) {\n                    error = new BadRequestError(response.statusText, path, debugOptions);\n                } else if (response.status === 401) {\n                    error = new UnauthorizedError(response.statusText, path, debugOptions);\n                } else if (response.status === 403) {\n                    error = new ForbiddenError(response.statusText, path, debugOptions);\n                } else if (response.status === 404) {\n                    error = new NotFoundError(response.statusText, path, debugOptions);\n                } else if (response.status === 405) {\n                    error = new MethodNotAllowedError(response.statusText, path, debugOptions);\n                } else if (response.status === 408) {\n                    error = new RequestTimeoutError(response.statusText, path, debugOptions);\n                } else if (response.status === 409) {\n                    error = new ConflictError(response.statusText, path, debugOptions);\n                } else if (response.status === 410) {\n                    error = new GoneError(response.statusText, path, debugOptions);\n                } else if (response.status === 429) {\n                    error = new TooManyRequestsError(response.statusText, path, debugOptions);\n                } else {\n                    error = new ClientError(response.statusText, path, response.status, debugOptions);\n                }\n            }\n            throw error;\n        }\n        if (options2.isJson) {\n            try {\n                returnValue = JSON.parse(returnValue);\n                logger.default(\"API RESPONSE JSON: %j\", {\n                    status: response.status,\n                    body: returnValue\n                });\n            } catch (e) {\n                logger.error(\"Error parsing JSON\", {\n                    message: e.message,\n                    stack: e.stack,\n                    returnValue\n                });\n                throw e;\n            }\n        } else {\n            logger.default(\"API RESPONSE TEXT: %j\", {\n                status: response.status,\n                body: returnValue\n            });\n        }\n        return returnValue;\n    };\n}\n// src/api/deleteMethod.ts\nvar logger2 = logger_default.get(\"api\", \"deleteMethod\");\nfunction deleteMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, deleteOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...deleteOptions\n        };\n        logger2.debug(\"httpDelete Request: %j, %j\", path, options2);\n        const s = await http(\"DELETE\", path, body, options2);\n        logger2.default(\"httpDelete Result: %j\", s);\n        return s;\n    };\n}\n// src/api/getMethod.ts\nvar logger3 = logger_default.get(\"api\", \"getMethod\");\nfunction getMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let getOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...getOptions\n        };\n        logger3.debug(\"httpGet Request: %j, %j\", path, options2);\n        const s = await http(\"GET\", path, null, options2);\n        logger3.default(\"httpGet Result: %j\", s);\n        return s;\n    };\n}\n// src/api/postMethod.ts\nvar logger4 = logger_default.get(\"api\", \"postMethod\");\nfunction postMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, getOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...getOptions\n        };\n        logger4.debug(\"httpPost Request: %j, %j\", path, options2);\n        const s = await http(\"POST\", path, body, options2);\n        logger4.default(\"httpPost Result: %j\", s);\n        return s;\n    };\n}\n// src/api/putMethod.ts\nvar logger5 = logger_default.get(\"api\", \"putMethod\");\nfunction putMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, getOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...getOptions\n        };\n        logger5.debug(\"httpPut Request: %j, %j\", path, options2);\n        const s = await http(\"PUT\", path, body, options2);\n        logger5.default(\"httpPut Result: %j\", s);\n        return s;\n    };\n}\n// src/api/optionsMethod.ts\nvar logger6 = logger_default.get(\"api\", \"optionsMethod\");\nfunction optionsMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger6.debug(\"httpOptions Request: %j, %j\", path, opts);\n        const s = await http(\"OPTIONS\", path, null, opts);\n        logger6.default(\"httpOptions Result: %j\", s);\n        return s;\n    };\n}\n// src/api/connectMethod.ts\nvar logger7 = logger_default.get(\"api\", \"connectMethod\");\nfunction connectMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger7.debug(\"httpConnect Request: %j, %j\", path, opts);\n        const s = await http(\"CONNECT\", path, null, opts);\n        logger7.default(\"httpConnect Result: %j\", s);\n        return s;\n    };\n}\n// src/api/traceMethod.ts\nvar logger8 = logger_default.get(\"api\", \"traceMethod\");\nfunction traceMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger8.debug(\"httpTrace Request: %j, %j\", path, opts);\n        const s = await http(\"TRACE\", path, null, opts);\n        logger8.default(\"httpTrace Result: %j\", s);\n        return s;\n    };\n}\n// src/api/patchMethod.ts\nvar logger9 = logger_default.get(\"api\", \"patchMethod\");\nfunction patchMethod(apiParams) {\n    const http = getHttp(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            isJsonBody: true,\n            contentType: \"application/json\",\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            skipContentType: false,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const opts = {\n            ...getOptionDefaults(apiParams),\n            ...options2\n        };\n        logger9.debug(\"httpPatch Request: %j, %j\", path, opts);\n        const s = await http(\"PATCH\", path, body, opts);\n        logger9.default(\"httpPatch Result: %j\", s);\n        return s;\n    };\n}\n// src/api/httpFile.ts\nfunction getHttpFile(apiParams) {\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(method, path, file) {\n        let httpFileOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, body = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, headers = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...httpFileOptions\n        };\n        const config = apiParams.config;\n        const populateAuthHeader = apiParams.populateAuthHeader;\n        try {\n            headers[\"Accept\"] = options2.accept;\n            headers[\"X-Client-Name\"] = config.clientName;\n            await populateAuthHeader(options2.isAuthenticated, headers);\n            const bodyData = new FormData();\n            Object.keys(body).forEach((key)=>{\n                bodyData.set(key, body[key]);\n            });\n            bodyData.set(\"file\", new Blob([\n                new Uint8Array(file.buffer)\n            ]), file.bufferName);\n            const response = await fetch(\"\".concat(config.url).concat(path).concat(generateQueryParameters(options2.params)), {\n                method,\n                headers,\n                body: bodyData,\n                credentials: options2.requestCredentials\n            });\n            const returnValue = options2.isJson ? await response.json() : await response.text();\n            if (response.status >= 400) {\n                console.error(\"Error executing API request httpFile, status: \".concat(response.status, \": \") + JSON.stringify({\n                    method,\n                    path,\n                    params: options2.params,\n                    body,\n                    returnValue\n                }));\n                throw new Error(options2.isJson ? returnValue.message : returnValue);\n            }\n            return returnValue;\n        } catch (e) {\n            console.error(\"Error executing API request http \".concat(method, \" \").concat(path, \" \").concat(generateQueryParameters(options2.params)), e);\n            throw e;\n        }\n    };\n}\n// src/api/postFileMethod.ts\nvar logger10 = logger_default.get(\"api\", \"postFileMethod\");\nfunction postFileMethod(apiParams) {\n    const httpFile = getHttpFile(apiParams);\n    const getOptionDefaults = (apiParams2)=>({\n            isJson: true,\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            requestCredentials: apiParams2.config.requestCredentials\n        });\n    return async function(path) {\n        let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, headers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, file = arguments.length > 3 ? arguments[3] : void 0, postFileOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};\n        const options2 = {\n            ...getOptionDefaults(apiParams),\n            ...postFileOptions\n        };\n        logger10.debug(\"httpPostFileData Request: %s, %j\", path, options2);\n        logger10.default(\"httpPostFileData Request Body: %j\", body);\n        const s = await httpFile(\"POST\", path, file, options2, body, headers);\n        logger10.default(\"httpPostFileData Result: %j\", s);\n        return s;\n    };\n}\n// src/api/uploadAsyncMethod.ts\nfunction uploadAsyncMethod(apiParams) {\n    const getOptionDefaults = ()=>({\n            method: \"POST\",\n            isJson: true,\n            accept: \"application/json\",\n            params: {},\n            isAuthenticated: true,\n            fieldName: \"file\",\n            headers: {}\n        });\n    return async function(path, uri) {\n        let uploadAsyncOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const options2 = {\n            ...getOptionDefaults(),\n            ...uploadAsyncOptions\n        };\n        const config = apiParams.config;\n        const populateAuthHeader = apiParams.populateAuthHeader;\n        const uploadAsyncFile = apiParams.uploadAsyncFile;\n        try {\n            options2.headers[\"Accept\"] = options2.accept;\n            await populateAuthHeader(options2.isAuthenticated, options2.headers);\n            const result = await uploadAsyncFile(\"\".concat(config.url).concat(path).concat(generateQueryParameters(options2.params)), uri, options2.method, \"multipart\", options2.fieldName, options2.headers);\n            const returnValue = options2.isJson ? JSON.parse(result.body) : result.body;\n            return returnValue;\n        } catch (e) {\n            console.error(\"Error executing API request http \".concat(options2.method, \" \").concat(path, \" \").concat(generateQueryParameters(options2.params)), e);\n            throw e;\n        }\n    };\n}\n// src/api.ts\nvar getHttpApi = (apiParams)=>{\n    const httpDelete = deleteMethod(apiParams);\n    const httpGet = getMethod(apiParams);\n    const httpPost = postMethod(apiParams);\n    const httpPut = putMethod(apiParams);\n    const httpOptions = optionsMethod(apiParams);\n    const httpConnect = connectMethod(apiParams);\n    const httpTrace = traceMethod(apiParams);\n    const httpPatch = patchMethod(apiParams);\n    const httpPostFile = postFileMethod(apiParams);\n    const uploadAsync = uploadAsyncMethod(apiParams);\n    return {\n        httpDelete,\n        httpGet,\n        httpPut,\n        httpPost,\n        httpPostFile,\n        uploadAsync,\n        httpOptions,\n        httpConnect,\n        httpTrace,\n        httpPatch\n    };\n};\n// src/simple-api.ts\nvar defaultApiParams = {\n    config: {\n        url: \"\",\n        requestCredentials: \"same-origin\",\n        clientName: \"fjell-http-api-examples\"\n    },\n    populateAuthHeader: async (isAuthenticated, headers)=>{\n        if (isAuthenticated) {\n            headers[\"Authorization\"] = \"Bearer example-token\";\n        }\n    },\n    uploadAsyncFile: async ()=>{\n        return {\n            headers: {},\n            status: 200,\n            mimeType: \"application/json\",\n            body: JSON.stringify({\n                success: true\n            })\n        };\n    }\n};\nvar getImpl = getMethod(defaultApiParams);\nvar postImpl = postMethod(defaultApiParams);\nvar putImpl = putMethod(defaultApiParams);\nvar optionsImpl = optionsMethod(defaultApiParams);\nvar connectImpl = connectMethod(defaultApiParams);\nvar traceImpl = traceMethod(defaultApiParams);\nvar patchImpl = patchMethod(defaultApiParams);\nvar deleteImpl = deleteMethod(defaultApiParams);\nvar postFileImpl = postFileMethod(defaultApiParams);\nvar uploadAsyncImpl = uploadAsyncMethod(defaultApiParams);\nvar get = (path, options2)=>{\n    return getImpl(path, options2);\n};\nvar post = (path, body, options2)=>{\n    return postImpl(path, body, options2);\n};\nvar put = (path, body, options2)=>{\n    return putImpl(path, body, options2);\n};\nvar deleteMethod2 = (path, body, options2)=>{\n    return deleteImpl(path, body, options2);\n};\nvar options = (path, opts)=>{\n    return optionsImpl(path, opts);\n};\nvar connect = (path, opts)=>{\n    return connectImpl(path, opts);\n};\nvar trace = (path, opts)=>{\n    return traceImpl(path, opts);\n};\nvar patch = (path, body, opts)=>{\n    return patchImpl(path, body, opts);\n};\nvar postFileMethod2 = (path, file, options2)=>{\n    const fileBuffer = {\n        buffer: Buffer.from([]),\n        // Placeholder - would need proper File reading in browser\n        bufferName: file.name\n    };\n    return postFileImpl(path, {}, {}, fileBuffer, options2);\n};\nvar uploadAsyncMethod2 = (path, uri, options2)=>{\n    return uploadAsyncImpl(path, uri, options2);\n};\n //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1odHRwLWFwaS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sSUFBTSxXQUFOLE1BQU0sa0JBQWlCLE1BQU07SUFJbEMsWUFBWSxTQUFpQixNQUFjLGtCQUEwQkEsUUFBQUEsQ0FBYztRQUVqRixNQUFNLFNBQVNBLFFBQU87UUFFdEIsS0FBSyxtQkFBbUI7UUFDeEIsS0FBSyxPQUFPO1FBR1osSUFBSSxNQUFNLG1CQUFtQjtZQUMzQixNQUFNLGtCQUFrQixNQUFNLFNBQVE7UUFDeEM7SUFDRjtBQUNGO0FBRU8sSUFBTSxjQUFOLGNBQTBCLFNBQVM7SUFDeEMsWUFBWSxTQUFpQixNQUFjLGtCQUEwQkEsUUFBQUEsQ0FBYztRQUVqRixNQUFNLFNBQVMsTUFBTSxrQkFBa0JBLFFBQU87SUFDaEQ7QUFDRjtBQUVPLElBQU0sa0JBQU4sY0FBOEIsWUFBWTtJQUMvQyxZQUFZLFNBQWlCLE1BQWNBLFFBQUFBLENBQWM7UUFFdkQsTUFBTSxVQUFHLE9BQU8sT0FBUSxPQUFKLElBQUksR0FBSSxNQUFNLEtBQUtBLFFBQU87SUFDaEQ7QUFDRjtBQUVPLElBQU0sb0JBQU4sY0FBZ0MsWUFBWTtJQUNqRCxZQUFZLFNBQWlCLE1BQWNBLFFBQUFBLENBQWM7UUFFdkQsTUFBTSxVQUFHLE9BQU8sT0FBUSxPQUFKLElBQUksR0FBSSxNQUFNLEtBQUtBLFFBQU87SUFDaEQ7QUFDRjtBQUVPLElBQU0saUJBQU4sY0FBNkIsWUFBWTtJQUM5QyxZQUFZLFNBQWlCLE1BQWNBLFFBQUFBLENBQWM7UUFFdkQsTUFBTSxVQUFHLE9BQU8sT0FBUSxPQUFKLElBQUksR0FBSSxNQUFNLEtBQUtBLFFBQU87SUFDaEQ7QUFDRjtBQUVPLElBQU0sZ0JBQU4sY0FBNEIsWUFBWTtJQUM3QyxZQUFZLFNBQWlCLE1BQWNBLFFBQUFBLENBQWM7UUFFdkQsTUFBTSxHQUFjLElB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LENBQUksTUFBY0E7SUFDbkMsT0FBTyxRQUFRLE1BQU1BLFFBQU87QUFDOUI7QUFFTyxJQUFNLE9BQU8sQ0FBSSxNQUFjLE1BQVlBO0lBQ2hELE9BQU8sU0FBUyxNQUFNLE1BQU1BLFFBQU87QUFDckM7QUFFTyxJQUFNLE1BQU0sQ0FBSSxNQUFjLE1BQVlBO0lBQy9DLE9BQU8sUUFBUSxNQUFNLE1BQU1BLFFBQU87QUFDcEM7QUFFTyxJQUFNRyxnQkFBZSxDQUFJLE1BQWMsTUFBWUg7SUFDeEQsT0FBTyxXQUFXLE1BQU0sTUFBTUEsUUFBTztBQUN2QztBQUVPLElBQU0sVUFBVSxDQUFJLE1BQWM7SUFDdkMsT0FBTyxZQUFZLE1BQU0sSUFBSTtBQUMvQjtBQUVPLElBQU0sVUFBVSxDQUFJLE1BQWM7SUFDdkMsT0FBTyxZQUFZLE1BQU0sSUFBSTtBQUMvQjtBQUVPLElBQU0sUUFBUSxDQUFJLE1BQWM7SUFDckMsT0FBTyxVQUFVLE1BQU0sSUFBSTtBQUM3QjtBQUVPLElBQU0sUUFBUSxDQUFJLE1BQWMsTUFBWTtJQUNqRCxPQUFPLFVBQVUsTUFBTSxNQUFNLElBQUk7QUFDbkM7QUFFTyxJQUFNSSxrQkFBaUIsQ0FBSSxNQUFjLE1BQVlKO0lBRzFELE1BQU0sYUFBYTtRQUNqQixRQUFRLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUFBO1FBQ3RCLFlBQVksS0FBSztJQUNuQjtJQUdBLE9BQU8sYUFBYSxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsWUFBWUEsUUFBTztBQUN2RDtBQUVPLElBQU1LLHFCQUFvQixDQUFJLE1BQWMsS0FBYUw7SUFDOUQsT0FBTyxnQkFBZ0IsTUFBTSxLQUFLQSxRQUFPO0FBQzNDIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9lcnJvcnMudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvdXRpbC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2FwaS9odHRwLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL2RlbGV0ZU1ldGhvZC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2FwaS9nZXRNZXRob2QudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvcG9zdE1ldGhvZC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2FwaS9wdXRNZXRob2QudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9hcGkvb3B0aW9uc01ldGhvZC50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2FwaS9jb25uZWN0TWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL3RyYWNlTWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL3BhdGNoTWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL2h0dHBGaWxlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL3Bvc3RGaWxlTWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpL3VwbG9hZEFzeW5jTWV0aG9kLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvYXBpLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvc2ltcGxlLWFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHByaXZhdGUgaHR0cFJlc3BvbnNlQ29kZTogbnVtYmVyO1xuICBwcml2YXRlIHBhdGg6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgaHR0cFJlc3BvbnNlQ29kZTogbnVtYmVyLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaHR0cFJlc3BvbnNlQ29kZSA9IGh0dHBSZXNwb25zZUNvZGU7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcblxuICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEFQSUVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENsaWVudEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgaHR0cFJlc3BvbnNlQ29kZTogbnVtYmVyLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCBodHRwUmVzcG9uc2VDb2RlLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwMCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVuYXV0aG9yaXplZEVycm9yIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwMSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZvcmJpZGRlbkVycm9yIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwMywgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA0LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWV0aG9kTm90QWxsb3dlZEVycm9yIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwNSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlcXVlc3RUaW1lb3V0RXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA4LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RFcnJvciBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDksIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHb25lRXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDEwLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVG9vTWFueVJlcXVlc3RzRXJyb3IgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAvLyBOZWVkIHRvIHBhc3MgYG9wdGlvbnNgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluc3RhbGwgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eS5cbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDI5LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2VydmVyRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcGF0aDogc3RyaW5nLCBodHRwUmVzcG9uc2VDb2RlOiBudW1iZXIsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFNlcnZlckVycm9yIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAwLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm90SW1wbGVtZW50ZWRFcnJvciBleHRlbmRzIFNlcnZlckVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkge1xuICAgIC8vIE5lZWQgdG8gcGFzcyBgb3B0aW9uc2AgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW5zdGFsbCB0aGUgXCJjYXVzZVwiIHByb3BlcnR5LlxuICAgIHN1cGVyKG1lc3NhZ2UsIHBhdGgsIDUwMSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgLy8gTmVlZCB0byBwYXNzIGBvcHRpb25zYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBpbnN0YWxsIHRoZSBcImNhdXNlXCIgcHJvcGVydHkuXG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAzLCBvcHRpb25zKTtcbiAgfVxufVxuIiwiXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbmNvbnN0IGdldFBhcmFtZXRlclZhbHVlID0gKFxuICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWQsXG4pOiBzdHJpbmcgPT4ge1xuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gdmFsdWUudG9JU09TdHJpbmcoKSA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyA9IChwYXJhbXM6IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWQ7XG59KSA9PlxuICBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA+IDBcbiAgICA/IFwiP1wiICtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpXG4gICAgICAuZmlsdGVyKChrZXkpID0+XG4gICAgICAgIChwYXJhbXNba2V5XSAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAodHlwZW9mIHBhcmFtc1trZXldID09PSAnc3RyaW5nJyAmJiAocGFyYW1zW2tleV0gYXMgc3RyaW5nKS5sZW5ndGggPT09IDApID09PSBmYWxzZVxuICAgICAgKVxuICAgICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZTogYW55O1xuICAgICAgICBpZiAocGFyYW1zW2tleV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFsdWUgPSAnZmFsc2UnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW1ldGVyVmFsdWUodmFsdWUpKX1gXG4gICAgICB9KVxuICAgICAgLmpvaW4oXCImXCIpXG4gICAgOiBcIlwiO1xuIiwiaW1wb3J0IExvZ2dpbmcgZnJvbSAnQGZqZWxsL2xvZ2dpbmcnO1xuXG5jb25zdCBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcignQGZqZWxsL2h0dHAtYXBpJyk7XG5cbmV4cG9ydCBkZWZhdWx0IExpYkxvZ2dlcjtcbiIsImltcG9ydCB7IEFwaVBhcmFtcyB9IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7XG4gIEJhZFJlcXVlc3RFcnJvcixcbiAgQ2xpZW50RXJyb3IsXG4gIENvbmZsaWN0RXJyb3IsXG4gIEZvcmJpZGRlbkVycm9yLFxuICBHb25lRXJyb3IsXG4gIEludGVybmFsU2VydmVyRXJyb3IsXG4gIE1ldGhvZE5vdEFsbG93ZWRFcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgUmVxdWVzdFRpbWVvdXRFcnJvcixcbiAgU2VydmVyRXJyb3IsXG4gIFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yLFxuICBUb29NYW55UmVxdWVzdHNFcnJvcixcbiAgVW5hdXRob3JpemVkRXJyb3Jcbn0gZnJvbSBcIi4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiYXBpXCIsIFwiaHR0cFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBIdHRwTWV0aG9kT3B0aW9ucyB7XG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgaXNKc29uQm9keTogYm9vbGVhbjtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZCB9O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIHNraXBDb250ZW50VHlwZTogYm9vbGVhbjtcbiAgcmVxdWVzdENyZWRlbnRpYWxzOiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG59O1xuXG5mdW5jdGlvbiBnZXRIdHRwKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IEh0dHBNZXRob2RPcHRpb25zID0+ICh7XG4gICAgICBpc0pzb246IHRydWUsXG4gICAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBib2R5OiBhbnkgPSB7fSxcbiAgICBodHRwT3B0aW9uczogUGFydGlhbDxIdHRwTWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdodHRwJywgeyBtZXRob2QsIHBhdGgsIGJvZHksIGh0dHBPcHRpb25zIH0pO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5odHRwT3B0aW9ucyxcbiAgICB9O1xuXG4gICAgY29uc3QgY29uZmlnID0gYXBpUGFyYW1zLmNvbmZpZztcbiAgICBjb25zdCBwb3B1bGF0ZUF1dGhIZWFkZXIgPSBhcGlQYXJhbXMucG9wdWxhdGVBdXRoSGVhZGVyO1xuICAgIGNvbnN0IGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcENvbnRlbnRUeXBlKSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICB9XG4gICAgaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMuYWNjZXB0O1xuICAgIGhlYWRlcnNbXCJYLUNsaWVudC1OYW1lXCJdID0gY29uZmlnLmNsaWVudE5hbWU7XG5cbiAgICBjb25zdCBkZWJ1Z09wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbWV0aG9kLFxuICAgICAgcGF0aCxcbiAgICAgIGJvZHksXG4gICAgfTtcbiAgICAvLyBjb25zb2xlLmRlYnVnKFwiQVBJIFJFUVVFU1Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoZGVidWdPcHRpb25zLCBudWxsLCAyKSk7XG5cbiAgICBhd2FpdCBwb3B1bGF0ZUF1dGhIZWFkZXIob3B0aW9ucy5pc0F1dGhlbnRpY2F0ZWQsIGhlYWRlcnMpO1xuXG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cCBSZXF1ZXN0OiAlaiwgJWpcIiwgbWV0aG9kLCBwYXRoKTtcblxuICAgIGNvbnN0IGZldGNoT3B0aW9uczogUmVxdWVzdEluaXQgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH07XG5cbiAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gYm9keSA/IChvcHRpb25zLmlzSnNvbkJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IGJvZHkpIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7Y29uZmlnLnVybH0ke3BhdGh9JHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhvcHRpb25zLnBhcmFtcyl9YCxcbiAgICAgIGZldGNoT3B0aW9ucyxcbiAgICApO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBFcnJvcnMgLSBhbnl0aGluZyBhYm92ZSA0MDBcbiAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgcmV0dXJuVmFsdWUgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAxKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAzKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBTZXJ2ZXJFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCByZXNwb25zZS5zdGF0dXMsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEJhZFJlcXVlc3RFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgVW5hdXRob3JpemVkRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgIGVycm9yID0gbmV3IEZvcmJpZGRlbkVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBOb3RGb3VuZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDUpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBNZXRob2ROb3RBbGxvd2VkRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFJlcXVlc3RUaW1lb3V0RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IENvbmZsaWN0RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQxMCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEdvbmVFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBDbGllbnRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCByZXNwb25zZS5zdGF0dXMsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgQVBJIEVSUk9SOiBFcnJvciBleGVjdXRpbmcgQVBJIHJlcXVlc3Q6YCArIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pc0pzb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gSlNPTi5wYXJzZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgIGxvZ2dlci5kZWZhdWx0KFwiQVBJIFJFU1BPTlNFIEpTT046ICVqXCIsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGJvZHk6IHJldHVyblZhbHVlIH0pO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgcGFyc2luZyBKU09OJywgeyBtZXNzYWdlOiBlLm1lc3NhZ2UsIHN0YWNrOiBlLnN0YWNrLCByZXR1cm5WYWx1ZSB9KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlZmF1bHQoXCJBUEkgUkVTUE9OU0UgVEVYVDogJWpcIiwgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgYm9keTogcmV0dXJuVmFsdWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlIGFzIHVua25vd24gYXMgUztcbiAgfVxufVxuXG5leHBvcnQge1xuICBnZXRIdHRwLFxufSIsImltcG9ydCB7IEFwaVBhcmFtcyB9IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IGdldEh0dHAgfSBmcm9tIFwiLi9odHRwXCI7XG5cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiYXBpXCIsIFwiZGVsZXRlTWV0aG9kXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlbGV0ZU1ldGhvZE9wdGlvbnMge1xuICBpc0pzb246IGJvb2xlYW47XG4gIGlzSnNvbkJvZHk6IGJvb2xlYW47XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGFjY2VwdDogc3RyaW5nO1xuICBwYXJhbXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZFxuICB9O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIHNraXBDb250ZW50VHlwZTogYm9vbGVhbjtcbiAgcmVxdWVzdENyZWRlbnRpYWxzOiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG59O1xuXG5mdW5jdGlvbiBkZWxldGVNZXRob2QoYXBpUGFyYW1zOiBBcGlQYXJhbXMpIHtcblxuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID1cbiAgICAoYXBpUGFyYW1zOiBBcGlQYXJhbXMpOiBEZWxldGVNZXRob2RPcHRpb25zID0+ICh7XG4gICAgICBpc0pzb246IHRydWUsXG4gICAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBib2R5OiBhbnkgPSB7fSxcbiAgICBkZWxldGVPcHRpb25zOiBQYXJ0aWFsPERlbGV0ZU1ldGhvZE9wdGlvbnM+ID0ge30sXG4gICk6IFByb21pc2U8Uz4gPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uZGVsZXRlT3B0aW9ucyxcbiAgICB9O1xuICAgIGxvZ2dlci5kZWJ1ZyhcImh0dHBEZWxldGUgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHM6IFMgPSBhd2FpdCBodHRwPFM+KFxuICAgICAgXCJERUxFVEVcIixcbiAgICAgIHBhdGgsXG4gICAgICBib2R5LFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIGxvZ2dlci5kZWZhdWx0KFwiaHR0cERlbGV0ZSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5leHBvcnQgeyBkZWxldGVNZXRob2QgfVxuIiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cCB9IGZyb20gXCIuL2h0dHBcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJnZXRNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0TWV0aG9kT3B0aW9ucyB7XG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgaXNKc29uQm9keTogYm9vbGVhbjtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkXG4gIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgc2tpcENvbnRlbnRUeXBlOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIGdldE1ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuXG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IEdldE1ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGdldE9wdGlvbnM6IFBhcnRpYWw8R2V0TWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5nZXRPcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cEdldCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgY29uc3QgczogUyA9IGF3YWl0IGh0dHA8Uz4oXCJHRVRcIiwgcGF0aCwgbnVsbCwgb3B0aW9ucyk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoXCJodHRwR2V0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0TWV0aG9kIH07IiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cCB9IGZyb20gXCIuL2h0dHBcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJwb3N0TWV0aG9kXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBvc3RNZXRob2RPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBpc0pzb25Cb2R5OiBib29sZWFuO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWRcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBza2lwQ29udGVudFR5cGU6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gcG9zdE1ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuXG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IFBvc3RNZXRob2RPcHRpb25zID0+ICh7XG4gICAgICBpc0pzb246IHRydWUsXG4gICAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBib2R5OiBhbnkgPSB7fSxcbiAgICBnZXRPcHRpb25zOiBQYXJ0aWFsPFBvc3RNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmdldE9wdGlvbnMsXG4gICAgfTtcbiAgICBsb2dnZXIuZGVidWcoXCJodHRwUG9zdCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgY29uc3QgczogUyA9IGF3YWl0IGh0dHA8Uz4oXCJQT1NUXCIsIHBhdGgsIGJvZHksIG9wdGlvbnMpO1xuICAgIGxvZ2dlci5kZWZhdWx0KFwiaHR0cFBvc3QgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZXhwb3J0IHsgcG9zdE1ldGhvZCB9O1xuIiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cCB9IGZyb20gXCIuL2h0dHBcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJwdXRNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHV0TWV0aG9kT3B0aW9ucyB7XG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgaXNKc29uQm9keTogYm9vbGVhbjtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkXG4gIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgc2tpcENvbnRlbnRUeXBlOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIHB1dE1ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuXG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IFB1dE1ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGdldE9wdGlvbnM6IFBhcnRpYWw8UHV0TWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5nZXRPcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cFB1dCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgY29uc3QgczogUyA9IGF3YWl0IGh0dHA8Uz4oXCJQVVRcIiwgcGF0aCwgYm9keSwgb3B0aW9ucyk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoXCJodHRwUHV0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmV4cG9ydCB7IHB1dE1ldGhvZCB9O1xuIiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cCB9IGZyb20gXCIuL2h0dHBcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJvcHRpb25zTWV0aG9kXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNNZXRob2RPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBpc0pzb25Cb2R5OiBib29sZWFuO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWQ7XG4gIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgc2tpcENvbnRlbnRUeXBlOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIG9wdGlvbnNNZXRob2QoYXBpUGFyYW1zOiBBcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKGFwaVBhcmFtczogQXBpUGFyYW1zKTogT3B0aW9uc01ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtcy5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzLFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYyA8Uz4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9uc01ldGhvZE9wdGlvbnM+ID0ge30sXG4gICk6IFByb21pc2U8Uz4gPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIGxvZ2dlci5kZWJ1ZyhcImh0dHBPcHRpb25zIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRzKTtcbiAgICBjb25zdCBzOiBTID0gYXdhaXQgaHR0cDxTPihcIk9QVElPTlNcIiwgcGF0aCwgbnVsbCwgb3B0cyk7XG4gICAgbG9nZ2VyLmRlZmF1bHQoXCJodHRwT3B0aW9ucyBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5leHBvcnQgeyBvcHRpb25zTWV0aG9kIH07XG4iLCJpbXBvcnQgeyBBcGlQYXJhbXMgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyBnZXRIdHRwIH0gZnJvbSBcIi4vaHR0cFwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcImFwaVwiLCBcImNvbm5lY3RNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdE1ldGhvZE9wdGlvbnMge1xuICBpc0pzb246IGJvb2xlYW47XG4gIGlzSnNvbkJvZHk6IGJvb2xlYW47XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGFjY2VwdDogc3RyaW5nO1xuICBwYXJhbXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBza2lwQ29udGVudFR5cGU6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gY29ubmVjdE1ldGhvZChhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID1cbiAgICAoYXBpUGFyYW1zOiBBcGlQYXJhbXMpOiBDb25uZWN0TWV0aG9kT3B0aW9ucyA9PiAoe1xuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgfSk7XG5cbiAgcmV0dXJuIGFzeW5jIDxTPihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9uczogUGFydGlhbDxDb25uZWN0TWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cENvbm5lY3QgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdHMpO1xuICAgIGNvbnN0IHM6IFMgPSBhd2FpdCBodHRwPFM+KFwiQ09OTkVDVFwiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXIuZGVmYXVsdChcImh0dHBDb25uZWN0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmV4cG9ydCB7IGNvbm5lY3RNZXRob2QgfTtcbiIsImltcG9ydCB7IEFwaVBhcmFtcyB9IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IGdldEh0dHAgfSBmcm9tIFwiLi9odHRwXCI7XG5cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiYXBpXCIsIFwidHJhY2VNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2VNZXRob2RPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBpc0pzb25Cb2R5OiBib29sZWFuO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWQ7XG4gIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgc2tpcENvbnRlbnRUeXBlOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIHRyYWNlTWV0aG9kKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPVxuICAgIChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IFRyYWNlTWV0aG9kT3B0aW9ucyA9PiAoe1xuICAgICAgaXNKc29uOiB0cnVlLFxuICAgICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgfSk7XG5cbiAgcmV0dXJuIGFzeW5jIDxTPihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9uczogUGFydGlhbDxUcmFjZU1ldGhvZE9wdGlvbnM+ID0ge30sXG4gICk6IFByb21pc2U8Uz4gPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIGxvZ2dlci5kZWJ1ZyhcImh0dHBUcmFjZSBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgczogUyA9IGF3YWl0IGh0dHA8Uz4oXCJUUkFDRVwiLCBwYXRoLCBudWxsLCBvcHRzKTtcbiAgICBsb2dnZXIuZGVmYXVsdChcImh0dHBUcmFjZSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5leHBvcnQgeyB0cmFjZU1ldGhvZCB9O1xuIiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2V0SHR0cCB9IGZyb20gXCIuL2h0dHBcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJhcGlcIiwgXCJwYXRjaE1ldGhvZFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBQYXRjaE1ldGhvZE9wdGlvbnMge1xuICBpc0pzb246IGJvb2xlYW47XG4gIGlzSnNvbkJvZHk6IGJvb2xlYW47XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGFjY2VwdDogc3RyaW5nO1xuICBwYXJhbXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBza2lwQ29udGVudFR5cGU6IGJvb2xlYW47XG4gIHJlcXVlc3RDcmVkZW50aWFsczogUmVxdWVzdENyZWRlbnRpYWxzO1xufTtcblxuZnVuY3Rpb24gcGF0Y2hNZXRob2QoYXBpUGFyYW1zOiBBcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKGFwaVBhcmFtczogQXBpUGFyYW1zKTogUGF0Y2hNZXRob2RPcHRpb25zID0+ICh7XG4gICAgICBpc0pzb246IHRydWUsXG4gICAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBib2R5OiBhbnkgPSB7fSxcbiAgICBvcHRpb25zOiBQYXJ0aWFsPFBhdGNoTWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFwiaHR0cFBhdGNoIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRzKTtcbiAgICBjb25zdCBzOiBTID0gYXdhaXQgaHR0cDxTPihcIlBBVENIXCIsIHBhdGgsIGJvZHksIG9wdHMpO1xuICAgIGxvZ2dlci5kZWZhdWx0KFwiaHR0cFBhdGNoIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmV4cG9ydCB7IHBhdGNoTWV0aG9kIH07XG4iLCJcbmltcG9ydCB7IEFwaVBhcmFtcyB9IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IGdlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEh0dHBGaWxlT3B0aW9ucyB7XG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgdW5kZWZpbmVkXG4gIH07XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgcmVxdWVzdENyZWRlbnRpYWxzOiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG59O1xuXG5mdW5jdGlvbiBnZXRIdHRwRmlsZShhcGlQYXJhbXM6IEFwaVBhcmFtcykge1xuXG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID1cbiAgICAoYXBpUGFyYW1zOiBBcGlQYXJhbXMpOiBIdHRwRmlsZU9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmaWxlOiB7IGJ1ZmZlcjogQnVmZmVyOyBidWZmZXJOYW1lOiBzdHJpbmcgfSxcbiAgICBodHRwRmlsZU9wdGlvbnM6IFBhcnRpYWw8SHR0cEZpbGVPcHRpb25zPiA9IHt9LFxuICAgIGJvZHk6IGFueSA9IHt9LFxuICAgIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5odHRwRmlsZU9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBhcGlQYXJhbXMuY29uZmlnO1xuICAgIGNvbnN0IHBvcHVsYXRlQXV0aEhlYWRlciA9IGFwaVBhcmFtcy5wb3B1bGF0ZUF1dGhIZWFkZXJcbiAgICB0cnkge1xuICAgICAgaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMuYWNjZXB0O1xuICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcImh0dHBGaWxlOiBcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgICAgIGhlYWRlcnNbXCJYLUNsaWVudC1OYW1lXCJdID0gY29uZmlnLmNsaWVudE5hbWU7XG5cbiAgICAgIGF3YWl0IHBvcHVsYXRlQXV0aEhlYWRlcihvcHRpb25zLmlzQXV0aGVudGljYXRlZCwgaGVhZGVycyk7XG5cbiAgICAgIGNvbnN0IGJvZHlEYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBPYmplY3Qua2V5cyhib2R5KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGJvZHlEYXRhLnNldChrZXksIGJvZHlba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIGJvZHlEYXRhLnNldCgnZmlsZScsIG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShmaWxlLmJ1ZmZlcildKSwgZmlsZS5idWZmZXJOYW1lKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7Y29uZmlnLnVybH0ke3BhdGh9JHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhvcHRpb25zLnBhcmFtcyl9YCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGJvZHlEYXRhLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3B0aW9ucy5pc0pzb24gPyBhd2FpdCByZXNwb25zZS5qc29uKCkgOiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBFcnJvciBleGVjdXRpbmcgQVBJIHJlcXVlc3QgaHR0cEZpbGUsIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9OiBgICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IG1ldGhvZCwgcGF0aCwgcGFyYW1zOiBvcHRpb25zLnBhcmFtcywgYm9keSwgcmV0dXJuVmFsdWUgfSksXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zLmlzSnNvbiA/IHJldHVyblZhbHVlLm1lc3NhZ2UgOiByZXR1cm5WYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWUgYXMgdW5rbm93biBhcyBTO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdCBodHRwICR7bWV0aG9kfSAke3BhdGh9ICR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMoXG4gICAgICAgICAgb3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICl9YCxcbiAgICAgICAgZSxcbiAgICAgICk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgZ2V0SHR0cEZpbGUgfTtcbiIsIiBcbmltcG9ydCB7IEFwaVBhcmFtcyB9IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IGdldEh0dHBGaWxlIH0gZnJvbSBcIi4vaHR0cEZpbGVcIjtcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KFwiYXBpXCIsIFwicG9zdEZpbGVNZXRob2RcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zdEZpbGVNZXRob2RPcHRpb25zIHtcbiAgaXNKc29uOiBib29sZWFuO1xuICBhY2NlcHQ6IHN0cmluZztcbiAgcGFyYW1zOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCB1bmRlZmluZWRcbiAgfTtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICByZXF1ZXN0Q3JlZGVudGlhbHM6IFJlcXVlc3RDcmVkZW50aWFscztcbn07XG5cbmZ1bmN0aW9uIHBvc3RGaWxlTWV0aG9kKGFwaVBhcmFtczogQXBpUGFyYW1zKSB7XG5cbiAgY29uc3QgaHR0cEZpbGUgPSBnZXRIdHRwRmlsZShhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID1cbiAgICAoYXBpUGFyYW1zOiBBcGlQYXJhbXMpOiBQb3N0RmlsZU1ldGhvZE9wdGlvbnMgPT4gKHtcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFscyxcbiAgICB9KTtcblxuICByZXR1cm4gYXN5bmMgPFM+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBib2R5OiBhbnkgPSB7fSxcbiAgICBoZWFkZXJzOiBhbnkgPSB7fSxcbiAgICBmaWxlOiB7IGJ1ZmZlcjogQnVmZmVyOyBidWZmZXJOYW1lOiBzdHJpbmcgfSxcbiAgICBwb3N0RmlsZU9wdGlvbnM6IFBhcnRpYWw8UG9zdEZpbGVNZXRob2RPcHRpb25zPiA9IHt9LFxuICApOiBQcm9taXNlPFM+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLnBvc3RGaWxlT3B0aW9ucyxcbiAgICB9O1xuICAgIGxvZ2dlci5kZWJ1ZyhcImh0dHBQb3N0RmlsZURhdGEgUmVxdWVzdDogJXMsICVqXCIsIHBhdGgsIG9wdGlvbnMpO1xuICAgIGxvZ2dlci5kZWZhdWx0KFwiaHR0cFBvc3RGaWxlRGF0YSBSZXF1ZXN0IEJvZHk6ICVqXCIsIGJvZHkpO1xuICAgIGNvbnN0IHM6IFMgPSBhd2FpdCBodHRwRmlsZTxTPihcbiAgICAgIFwiUE9TVFwiLFxuICAgICAgcGF0aCxcbiAgICAgIGZpbGUsXG4gICAgICBvcHRpb25zLFxuICAgICAgYm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgKTtcbiAgICBsb2dnZXIuZGVmYXVsdChcImh0dHBQb3N0RmlsZURhdGEgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZXhwb3J0IHsgcG9zdEZpbGVNZXRob2QgfVxuIiwiaW1wb3J0IHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkQXN5bmNNZXRob2RPcHRpb25zIHtcbiAgbWV0aG9kOiBzdHJpbmcsXG4gIGlzSnNvbjogYm9vbGVhbjtcbiAgYWNjZXB0OiBzdHJpbmc7XG4gIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IHVuZGVmaW5lZCB9O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIGZpZWxkTmFtZTogc3RyaW5nO1xuICBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufTtcblxuZnVuY3Rpb24gdXBsb2FkQXN5bmNNZXRob2QoYXBpUGFyYW1zOiBBcGlQYXJhbXMpIHtcblxuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9XG4gICAgKCk6IFVwbG9hZEFzeW5jTWV0aG9kT3B0aW9ucyA9PiAoe1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGlzSnNvbjogdHJ1ZSxcbiAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgZmllbGROYW1lOiBcImZpbGVcIixcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgIH0pO1xuXG4gIHJldHVybiBhc3luYzxTPihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgdXJpOiBzdHJpbmcsXG4gICAgdXBsb2FkQXN5bmNPcHRpb25zOiBQYXJ0aWFsPFVwbG9hZEFzeW5jTWV0aG9kT3B0aW9ucz4gPSB7fSxcbiAgKTogUHJvbWlzZTxTPiA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKCksXG4gICAgICAuLi51cGxvYWRBc3luY09wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBhcGlQYXJhbXMuY29uZmlnO1xuICAgIGNvbnN0IHBvcHVsYXRlQXV0aEhlYWRlciA9IGFwaVBhcmFtcy5wb3B1bGF0ZUF1dGhIZWFkZXI7XG4gICAgY29uc3QgdXBsb2FkQXN5bmNGaWxlID0gYXBpUGFyYW1zLnVwbG9hZEFzeW5jRmlsZTtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzW1wiQWNjZXB0XCJdID0gb3B0aW9ucy5hY2NlcHQ7XG5cbiAgICAgIC8vIGNvbnNvbGUuZGVidWcoXCJ1cGxvYWRBc3luYzogXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XG5cbiAgICAgIGF3YWl0IHBvcHVsYXRlQXV0aEhlYWRlcihvcHRpb25zLmlzQXV0aGVudGljYXRlZCwgb3B0aW9ucy5oZWFkZXJzKTtcblxuICAgICAgY29uc3QgcmVzdWx0OiB7XG4gICAgICAgIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICAgIHN0YXR1czogbnVtYmVyO1xuICAgICAgICBtaW1lVHlwZTogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgYm9keTogc3RyaW5nO1xuICAgICAgfSA9IGF3YWl0IHVwbG9hZEFzeW5jRmlsZShgJHtjb25maWcudXJsfSR7cGF0aH0ke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMucGFyYW1zKX1gLFxuICAgICAgICB1cmksIG9wdGlvbnMubWV0aG9kLCBcIm11bHRpcGFydFwiLCBvcHRpb25zLmZpZWxkTmFtZSwgb3B0aW9ucy5oZWFkZXJzKTtcblxuICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcHRpb25zLmlzSnNvbiA/IEpTT04ucGFyc2UocmVzdWx0LmJvZHkpIDogcmVzdWx0LmJvZHk7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWUgYXMgdW5rbm93biBhcyBTO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEVycm9yIGV4ZWN1dGluZyBBUEkgcmVxdWVzdCBodHRwICR7b3B0aW9ucy5tZXRob2R9ICR7cGF0aH0gJHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhcbiAgICAgICAgICBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgKX1gLFxuICAgICAgICBlLFxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyB1cGxvYWRBc3luY01ldGhvZCB9XG4iLCJpbXBvcnQgeyBkZWxldGVNZXRob2QsIERlbGV0ZU1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvZGVsZXRlTWV0aG9kXCI7XG5pbXBvcnQgeyBnZXRNZXRob2QsIEdldE1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvZ2V0TWV0aG9kXCI7XG5pbXBvcnQgeyBwb3N0TWV0aG9kLCBQb3N0TWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9wb3N0TWV0aG9kXCI7XG5pbXBvcnQgeyBwdXRNZXRob2QsIFB1dE1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvcHV0TWV0aG9kXCI7XG5pbXBvcnQgeyBvcHRpb25zTWV0aG9kLCBPcHRpb25zTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9vcHRpb25zTWV0aG9kXCI7XG5pbXBvcnQgeyBjb25uZWN0TWV0aG9kLCBDb25uZWN0TWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9jb25uZWN0TWV0aG9kXCI7XG5pbXBvcnQgeyB0cmFjZU1ldGhvZCwgVHJhY2VNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3RyYWNlTWV0aG9kXCI7XG5pbXBvcnQgeyBwYXRjaE1ldGhvZCwgUGF0Y2hNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3BhdGNoTWV0aG9kXCI7XG5pbXBvcnQgeyBwb3N0RmlsZU1ldGhvZCwgUG9zdEZpbGVNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3Bvc3RGaWxlTWV0aG9kXCI7XG5pbXBvcnQgeyB1cGxvYWRBc3luY01ldGhvZCwgVXBsb2FkQXN5bmNNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3VwbG9hZEFzeW5jTWV0aG9kXCI7XG5cbi8vIEV4cG9ydCBvcHRpb24gdHlwZXMgZm9yIGV4dGVybmFsIHVzZVxuZXhwb3J0IHR5cGUge1xuICBEZWxldGVNZXRob2RPcHRpb25zLFxuICBHZXRNZXRob2RPcHRpb25zLFxuICBQb3N0TWV0aG9kT3B0aW9ucyxcbiAgUHV0TWV0aG9kT3B0aW9ucyxcbiAgT3B0aW9uc01ldGhvZE9wdGlvbnMsXG4gIENvbm5lY3RNZXRob2RPcHRpb25zLFxuICBUcmFjZU1ldGhvZE9wdGlvbnMsXG4gIFBhdGNoTWV0aG9kT3B0aW9ucyxcbn07XG5cbmV4cG9ydCB0eXBlIEh0dHBEZWxldGUgPSA8Uz4oXG4gIHBhdGg6IHN0cmluZyxcbiAgYm9keT86IGFueSxcbiAgb3B0aW9ucz86IFBhcnRpYWw8RGVsZXRlTWV0aG9kT3B0aW9ucz4sXG4pID0+IFByb21pc2U8Uz47XG5cbmV4cG9ydCB0eXBlIEh0dHBQdXQgPSA8Uz4oXG4gIHBhdGg6IHN0cmluZyxcbiAgYm9keT86IGFueSxcbiAgb3B0aW9ucz86IFBhcnRpYWw8UHV0TWV0aG9kT3B0aW9ucz4sXG4pID0+IFByb21pc2U8Uz47XG5cbmV4cG9ydCB0eXBlIEh0dHBQb3N0ID0gPFM+KFxuICBwYXRoOiBzdHJpbmcsXG4gIGJvZHk/OiBhbnksXG4gIG9wdGlvbnM/OiBQYXJ0aWFsPFBvc3RNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgSHR0cFBvc3RGaWxlID0gPFM+KFxuICBwYXRoOiBzdHJpbmcsXG4gIGJvZHk6IGFueSxcbiAgaGVhZGVyczogYW55LFxuICBmaWxlOiB7IGJ1ZmZlcjogQnVmZmVyOyBidWZmZXJOYW1lOiBzdHJpbmcgfSxcbiAgb3B0aW9ucz86IFBhcnRpYWw8UG9zdEZpbGVNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgSHR0cEdldCA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICBnZXRPcHRpb25zPzogUGFydGlhbDxHZXRNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgSHR0cE9wdGlvbnNNZXRob2QgPSA8Uz4oXG4gIHBhdGg6IHN0cmluZyxcbiAgb3B0aW9ucz86IFBhcnRpYWw8T3B0aW9uc01ldGhvZE9wdGlvbnM+LFxuKSA9PiBQcm9taXNlPFM+O1xuXG5leHBvcnQgdHlwZSBIdHRwQ29ubmVjdCA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRpb25zPzogUGFydGlhbDxDb25uZWN0TWV0aG9kT3B0aW9ucz4sXG4pID0+IFByb21pc2U8Uz47XG5cbmV4cG9ydCB0eXBlIEh0dHBUcmFjZSA9IDxTPihcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRpb25zPzogUGFydGlhbDxUcmFjZU1ldGhvZE9wdGlvbnM+LFxuKSA9PiBQcm9taXNlPFM+O1xuXG5leHBvcnQgdHlwZSBIdHRwUGF0Y2ggPSA8Uz4oXG4gIHBhdGg6IHN0cmluZyxcbiAgYm9keT86IGFueSxcbiAgb3B0aW9ucz86IFBhcnRpYWw8UGF0Y2hNZXRob2RPcHRpb25zPixcbikgPT4gUHJvbWlzZTxTPjtcblxuZXhwb3J0IHR5cGUgVXBsb2FkQXN5bmMgPSA8Uz4oXG4gIHBhdGg6IHN0cmluZyxcbiAgdXJpOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQYXJ0aWFsPFVwbG9hZEFzeW5jTWV0aG9kT3B0aW9ucz4sXG4pID0+IFByb21pc2U8Uz47XG5cbmV4cG9ydCB0eXBlIEh0dHBBcGkgPSB7XG4gIGh0dHBEZWxldGU6IEh0dHBEZWxldGU7XG4gIGh0dHBHZXQ6IEh0dHBHZXQ7XG4gIGh0dHBQdXQ6IEh0dHBQdXQsXG4gIGh0dHBQb3N0OiBIdHRwUG9zdCxcbiAgaHR0cFBvc3RGaWxlOiBIdHRwUG9zdEZpbGUsXG4gIHVwbG9hZEFzeW5jOiBVcGxvYWRBc3luYyxcbiAgaHR0cE9wdGlvbnM6IEh0dHBPcHRpb25zTWV0aG9kLFxuICBodHRwQ29ubmVjdDogSHR0cENvbm5lY3QsXG4gIGh0dHBUcmFjZTogSHR0cFRyYWNlLFxuICBodHRwUGF0Y2g6IEh0dHBQYXRjaCxcbn1cblxuZXhwb3J0IHR5cGUgQXBpQ29uZmlnID0ge1xuICB1cmw6IHN0cmluZyxcbiAgcmVxdWVzdENyZWRlbnRpYWxzOiBSZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIGNsaWVudE5hbWU6IHN0cmluZyxcbn1cblxuZXhwb3J0IHR5cGUgQXBpUG9wdWxhdGVBdXRoSGVhZGVyID1cbiAgKGlzQXV0aGVudGljYXRlZDogYm9vbGVhbiwgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0pID0+IFByb21pc2U8dm9pZD47XG5cbmV4cG9ydCB0eXBlIEFwaVVwbG9hZEFzeW5jRmlsZSA9XG4gIChkZXN0VXJsOiBzdHJpbmcsIGZpbGVVcmk6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsXG4gICAgdXBsb2FkVHlwZTogc3RyaW5nLCBmaWVsZE5hbWU6IHN0cmluZywgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4gUHJvbWlzZTx7XG4gICAgICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgc3RhdHVzOiBudW1iZXI7XG4gICAgICBtaW1lVHlwZTogc3RyaW5nIHwgbnVsbDtcbiAgICAgIGJvZHk6IHN0cmluZztcbiAgICB9PjtcblxuZXhwb3J0IHR5cGUgQXBpUGFyYW1zID0ge1xuICBjb25maWc6IEFwaUNvbmZpZyxcbiAgcG9wdWxhdGVBdXRoSGVhZGVyOiBBcGlQb3B1bGF0ZUF1dGhIZWFkZXIsXG4gIHVwbG9hZEFzeW5jRmlsZTogQXBpVXBsb2FkQXN5bmNGaWxlLFxufVxuXG5leHBvcnQgY29uc3QgZ2V0SHR0cEFwaSA9IChhcGlQYXJhbXM6IEFwaVBhcmFtcyk6IEh0dHBBcGkgPT4ge1xuXG4gIGNvbnN0IGh0dHBEZWxldGU6IEh0dHBEZWxldGUgPSBkZWxldGVNZXRob2QoYXBpUGFyYW1zKTtcblxuICBjb25zdCBodHRwR2V0OiBIdHRwR2V0ID0gZ2V0TWV0aG9kKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgaHR0cFBvc3Q6IEh0dHBQb3N0ID0gcG9zdE1ldGhvZChhcGlQYXJhbXMpXG5cbiAgY29uc3QgaHR0cFB1dDogSHR0cFB1dCA9IHB1dE1ldGhvZChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGh0dHBPcHRpb25zOiBIdHRwT3B0aW9uc01ldGhvZCA9IG9wdGlvbnNNZXRob2QoYXBpUGFyYW1zKTtcblxuICBjb25zdCBodHRwQ29ubmVjdDogSHR0cENvbm5lY3QgPSBjb25uZWN0TWV0aG9kKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgaHR0cFRyYWNlOiBIdHRwVHJhY2UgPSB0cmFjZU1ldGhvZChhcGlQYXJhbXMpO1xuXG4gIGNvbnN0IGh0dHBQYXRjaDogSHR0cFBhdGNoID0gcGF0Y2hNZXRob2QoYXBpUGFyYW1zKTtcblxuICBjb25zdCBodHRwUG9zdEZpbGU6IEh0dHBQb3N0RmlsZSA9IHBvc3RGaWxlTWV0aG9kKGFwaVBhcmFtcyk7XG5cbiAgY29uc3QgdXBsb2FkQXN5bmM6IFVwbG9hZEFzeW5jID0gdXBsb2FkQXN5bmNNZXRob2QoYXBpUGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIGh0dHBEZWxldGUsXG4gICAgaHR0cEdldCxcbiAgICBodHRwUHV0LFxuICAgIGh0dHBQb3N0LFxuICAgIGh0dHBQb3N0RmlsZSxcbiAgICB1cGxvYWRBc3luYyxcbiAgICBodHRwT3B0aW9ucyxcbiAgICBodHRwQ29ubmVjdCxcbiAgICBodHRwVHJhY2UsXG4gICAgaHR0cFBhdGNoLFxuICB9O1xuXG59XG4iLCIvLyBTaW1wbGUgQVBJIHdyYXBwZXJzIGZvciBlYXNpZXIgdXNlIGluIGV4YW1wbGVzIGFuZCBiYXNpYyB1c2FnZVxuaW1wb3J0IHsgZ2V0TWV0aG9kLCBHZXRNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL2dldE1ldGhvZFwiO1xuaW1wb3J0IHsgcG9zdE1ldGhvZCwgUG9zdE1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvcG9zdE1ldGhvZFwiO1xuaW1wb3J0IHsgcHV0TWV0aG9kLCBQdXRNZXRob2RPcHRpb25zIH0gZnJvbSBcIi4vYXBpL3B1dE1ldGhvZFwiO1xuaW1wb3J0IHsgb3B0aW9uc01ldGhvZCwgT3B0aW9uc01ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvb3B0aW9uc01ldGhvZFwiO1xuaW1wb3J0IHsgY29ubmVjdE1ldGhvZCwgQ29ubmVjdE1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvY29ubmVjdE1ldGhvZFwiO1xuaW1wb3J0IHsgdHJhY2VNZXRob2QsIFRyYWNlTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS90cmFjZU1ldGhvZFwiO1xuaW1wb3J0IHsgcGF0Y2hNZXRob2QsIFBhdGNoTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9wYXRjaE1ldGhvZFwiO1xuaW1wb3J0IHsgZGVsZXRlTWV0aG9kIGFzIGRlbGV0ZU1ldGhvZEZhY3RvcnksIERlbGV0ZU1ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvZGVsZXRlTWV0aG9kXCI7XG5pbXBvcnQgeyBwb3N0RmlsZU1ldGhvZCBhcyBwb3N0RmlsZU1ldGhvZEZhY3RvcnksIFBvc3RGaWxlTWV0aG9kT3B0aW9ucyB9IGZyb20gXCIuL2FwaS9wb3N0RmlsZU1ldGhvZFwiO1xuaW1wb3J0IHsgdXBsb2FkQXN5bmNNZXRob2QgYXMgdXBsb2FkQXN5bmNNZXRob2RGYWN0b3J5LCBVcGxvYWRBc3luY01ldGhvZE9wdGlvbnMgfSBmcm9tIFwiLi9hcGkvdXBsb2FkQXN5bmNNZXRob2RcIjtcbmltcG9ydCB0eXBlIHsgQXBpUGFyYW1zIH0gZnJvbSBcIi4vYXBpXCI7XG5cbi8vIEV4dGVuZGVkIG9wdGlvbnMgaW50ZXJmYWNlcyB0aGF0IGluY2x1ZGUgY29tbW9ubHkgdXNlZCBwcm9wZXJ0aWVzXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZUdldE9wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPEdldE1ldGhvZE9wdGlvbnM+IHtcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIC8vIFJlbW92ZSBwYXJhbXMgb3ZlcnJpZGUgdG8gYXZvaWQgdHlwZSBjb25mbGljdHNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVQb3N0T3B0aW9ucyBleHRlbmRzIFBhcnRpYWw8UG9zdE1ldGhvZE9wdGlvbnM+IHtcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIC8vIFJlbW92ZSBwYXJhbXMgb3ZlcnJpZGUgdG8gYXZvaWQgdHlwZSBjb25mbGljdHNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVQdXRPcHRpb25zIGV4dGVuZHMgUGFydGlhbDxQdXRNZXRob2RPcHRpb25zPiB7XG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZURlbGV0ZU9wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPERlbGV0ZU1ldGhvZE9wdGlvbnM+IHtcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlUG9zdEZpbGVPcHRpb25zIGV4dGVuZHMgUGFydGlhbDxQb3N0RmlsZU1ldGhvZE9wdGlvbnM+IHtcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlVXBsb2FkQXN5bmNPcHRpb25zIGV4dGVuZHMgUGFydGlhbDxVcGxvYWRBc3luY01ldGhvZE9wdGlvbnM+IHtcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlT3B0aW9uc09wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPE9wdGlvbnNNZXRob2RPcHRpb25zPiB7XG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZUNvbm5lY3RPcHRpb25zIGV4dGVuZHMgUGFydGlhbDxDb25uZWN0TWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVUcmFjZU9wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPFRyYWNlTWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVQYXRjaE9wdGlvbnMgZXh0ZW5kcyBQYXJ0aWFsPFBhdGNoTWV0aG9kT3B0aW9ucz4ge1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBleGFtcGxlc1xuY29uc3QgZGVmYXVsdEFwaVBhcmFtczogQXBpUGFyYW1zID0ge1xuICBjb25maWc6IHtcbiAgICB1cmw6ICcnLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyBhcyBSZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgY2xpZW50TmFtZTogJ2ZqZWxsLWh0dHAtYXBpLWV4YW1wbGVzJ1xuICB9LFxuICBwb3B1bGF0ZUF1dGhIZWFkZXI6IGFzeW5jIChpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW4sIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pID0+IHtcbiAgICAvLyBNb2NrIGF1dGggaGVhZGVyIHBvcHVsYXRpb24gZm9yIGV4YW1wbGVzXG4gICAgaWYgKGlzQXV0aGVudGljYXRlZCkge1xuICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciBleGFtcGxlLXRva2VuJztcbiAgICB9XG4gIH0sXG4gIHVwbG9hZEFzeW5jRmlsZTogYXN5bmMgKCkgPT4ge1xuICAgIC8vIE1vY2sgZmlsZSB1cGxvYWQgZm9yIGV4YW1wbGVzXG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzdWNjZXNzOiB0cnVlIH0pXG4gICAgfTtcbiAgfVxufTtcblxuLy8gQ3JlYXRlIGNvbmZpZ3VyZWQgaW5zdGFuY2VzXG5jb25zdCBnZXRJbXBsID0gZ2V0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3QgcG9zdEltcGwgPSBwb3N0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3QgcHV0SW1wbCA9IHB1dE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbmNvbnN0IG9wdGlvbnNJbXBsID0gb3B0aW9uc01ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbmNvbnN0IGNvbm5lY3RJbXBsID0gY29ubmVjdE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbmNvbnN0IHRyYWNlSW1wbCA9IHRyYWNlTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xuY29uc3QgcGF0Y2hJbXBsID0gcGF0Y2hNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG5jb25zdCBkZWxldGVJbXBsID0gZGVsZXRlTWV0aG9kRmFjdG9yeShkZWZhdWx0QXBpUGFyYW1zKTtcbmNvbnN0IHBvc3RGaWxlSW1wbCA9IHBvc3RGaWxlTWV0aG9kRmFjdG9yeShkZWZhdWx0QXBpUGFyYW1zKTtcbmNvbnN0IHVwbG9hZEFzeW5jSW1wbCA9IHVwbG9hZEFzeW5jTWV0aG9kRmFjdG9yeShkZWZhdWx0QXBpUGFyYW1zKTtcblxuLy8gRXhwb3J0IHNpbXBsZSBmdW5jdGlvbnMgdGhhdCBtYXRjaCB0aGUgZXhwZWN0ZWQgaW50ZXJmYWNlXG5leHBvcnQgY29uc3QgZ2V0ID0gPFM+KHBhdGg6IHN0cmluZywgb3B0aW9ucz86IFNpbXBsZUdldE9wdGlvbnMpOiBQcm9taXNlPFM+ID0+IHtcbiAgcmV0dXJuIGdldEltcGwocGF0aCwgb3B0aW9ucyk7XG59O1xuXG5leHBvcnQgY29uc3QgcG9zdCA9IDxTPihwYXRoOiBzdHJpbmcsIGJvZHk/OiBhbnksIG9wdGlvbnM/OiBTaW1wbGVQb3N0T3B0aW9ucyk6IFByb21pc2U8Uz4gPT4ge1xuICByZXR1cm4gcG9zdEltcGwocGF0aCwgYm9keSwgb3B0aW9ucyk7XG59O1xuXG5leHBvcnQgY29uc3QgcHV0ID0gPFM+KHBhdGg6IHN0cmluZywgYm9keT86IGFueSwgb3B0aW9ucz86IFNpbXBsZVB1dE9wdGlvbnMpOiBQcm9taXNlPFM+ID0+IHtcbiAgcmV0dXJuIHB1dEltcGwocGF0aCwgYm9keSwgb3B0aW9ucyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGVsZXRlTWV0aG9kID0gPFM+KHBhdGg6IHN0cmluZywgYm9keT86IGFueSwgb3B0aW9ucz86IFNpbXBsZURlbGV0ZU9wdGlvbnMpOiBQcm9taXNlPFM+ID0+IHtcbiAgcmV0dXJuIGRlbGV0ZUltcGwocGF0aCwgYm9keSwgb3B0aW9ucyk7XG59O1xuXG5leHBvcnQgY29uc3Qgb3B0aW9ucyA9IDxTPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBTaW1wbGVPcHRpb25zT3B0aW9ucyk6IFByb21pc2U8Uz4gPT4ge1xuICByZXR1cm4gb3B0aW9uc0ltcGwocGF0aCwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgY29ubmVjdCA9IDxTPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBTaW1wbGVDb25uZWN0T3B0aW9ucyk6IFByb21pc2U8Uz4gPT4ge1xuICByZXR1cm4gY29ubmVjdEltcGwocGF0aCwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgdHJhY2UgPSA8Uz4ocGF0aDogc3RyaW5nLCBvcHRzPzogU2ltcGxlVHJhY2VPcHRpb25zKTogUHJvbWlzZTxTPiA9PiB7XG4gIHJldHVybiB0cmFjZUltcGwocGF0aCwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGF0Y2ggPSA8Uz4ocGF0aDogc3RyaW5nLCBib2R5PzogYW55LCBvcHRzPzogU2ltcGxlUGF0Y2hPcHRpb25zKTogUHJvbWlzZTxTPiA9PiB7XG4gIHJldHVybiBwYXRjaEltcGwocGF0aCwgYm9keSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgcG9zdEZpbGVNZXRob2QgPSA8Uz4ocGF0aDogc3RyaW5nLCBmaWxlOiBGaWxlLCBvcHRpb25zPzogU2ltcGxlUG9zdEZpbGVPcHRpb25zKTogUHJvbWlzZTxTPiA9PiB7XG4gIC8vIENvbnZlcnQgRmlsZSB0byB0aGUgZXhwZWN0ZWQgZm9ybWF0IC0gdGhpcyBpcyBhIHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb25cbiAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgcmVhZCB0aGUgRmlsZSBvYmplY3QgcHJvcGVybHkgdXNpbmcgRmlsZVJlYWRlclxuICBjb25zdCBmaWxlQnVmZmVyID0ge1xuICAgIGJ1ZmZlcjogQnVmZmVyLmZyb20oW10pLCAvLyBQbGFjZWhvbGRlciAtIHdvdWxkIG5lZWQgcHJvcGVyIEZpbGUgcmVhZGluZyBpbiBicm93c2VyXG4gICAgYnVmZmVyTmFtZTogZmlsZS5uYW1lXG4gIH07XG5cbiAgLy8gVXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0cyBmb3IgYm9keSBhbmQgaGVhZGVycywgdGhlbiB0aGUgZmlsZSBvYmplY3QsIHRoZW4gb3B0aW9uc1xuICByZXR1cm4gcG9zdEZpbGVJbXBsKHBhdGgsIHt9LCB7fSwgZmlsZUJ1ZmZlciwgb3B0aW9ucyk7XG59O1xuXG5leHBvcnQgY29uc3QgdXBsb2FkQXN5bmNNZXRob2QgPSA8Uz4ocGF0aDogc3RyaW5nLCB1cmk6IHN0cmluZywgb3B0aW9ucz86IFNpbXBsZVVwbG9hZEFzeW5jT3B0aW9ucyk6IFByb21pc2U8Uz4gPT4ge1xuICByZXR1cm4gdXBsb2FkQXN5bmNJbXBsKHBhdGgsIHVyaSwgb3B0aW9ucyk7XG59O1xuIl0sIm5hbWVzIjpbIm9wdGlvbnMiLCJhcGlQYXJhbXMiLCJsb2dnZXIiLCJkZWxldGVNZXRob2QiLCJwb3N0RmlsZU1ldGhvZCIsInVwbG9hZEFzeW5jTWV0aG9kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-http-api/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-http-api/node_modules/@fjell/logging/dist/index.js":
/*!*******************************************************************!*\
  !*** ../fjell-http-api/node_modules/@fjell/logging/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1odHRwLWFwaS9ub2RlX21vZHVsZXMvQGZqZWxsL2xvZ2dpbmcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxLQUFLO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFNcEI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1odHRwLWFwaS9ub2RlX21vZHVsZXMvQGZqZWxsL2xvZ2dpbmcvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvTG9nRm9ybWF0LnRzXG52YXIgTG9nRm9ybWF0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KExvZ0Zvcm1hdF9leHBvcnRzLCB7XG4gIExvZ0Zvcm1hdHM6ICgpID0+IExvZ0Zvcm1hdHMsXG4gIFNUUlVDVFVSRUQ6ICgpID0+IFNUUlVDVFVSRUQsXG4gIFRFWFQ6ICgpID0+IFRFWFQsXG4gIGdldENvbmZpZzogKCkgPT4gZ2V0Q29uZmlnXG59KTtcbnZhciBURVhUID0ge1xuICBuYW1lOiBcIlRFWFRcIixcbiAgZGVzY3JpcHRpb246IFwiVGV4dCBmb3JtYXRcIlxufTtcbnZhciBTVFJVQ1RVUkVEID0ge1xuICBuYW1lOiBcIlNUUlVDVFVSRURcIixcbiAgZGVzY3JpcHRpb246IFwiU3RydWN0dXJlZCBmb3JtYXRcIlxufTtcbnZhciBMb2dGb3JtYXRzID0gW1xuICBURVhULFxuICBTVFJVQ1RVUkVEXG5dO1xudmFyIGdldENvbmZpZyA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0Zvcm1hdHMuZmluZCgoY29uZmlnMikgPT4gY29uZmlnMi5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG9nIEZvcm1hdCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8vIHNyYy9Mb2dMZXZlbC50c1xudmFyIExvZ0xldmVsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KExvZ0xldmVsX2V4cG9ydHMsIHtcbiAgQUxFUlQ6ICgpID0+IEFMRVJULFxuICBDUklUSUNBTDogKCkgPT4gQ1JJVElDQUwsXG4gIERFQlVHOiAoKSA9PiBERUJVRyxcbiAgREVGQVVMVDogKCkgPT4gREVGQVVMVCxcbiAgRU1FUkdFTkNZOiAoKSA9PiBFTUVSR0VOQ1ksXG4gIEVSUk9SOiAoKSA9PiBFUlJPUixcbiAgSU5GTzogKCkgPT4gSU5GTyxcbiAgTG9nTGV2ZWxzOiAoKSA9PiBMb2dMZXZlbHMsXG4gIE5PVElDRTogKCkgPT4gTk9USUNFLFxuICBUUkFDRTogKCkgPT4gVFJBQ0UsXG4gIFdBUk5JTkc6ICgpID0+IFdBUk5JTkcsXG4gIGdldENvbmZpZzogKCkgPT4gZ2V0Q29uZmlnMlxufSk7XG52YXIgRU1FUkdFTkNZID0ge1xuICBuYW1lOiBcIkVNRVJHRU5DWVwiLFxuICB2YWx1ZTogMFxufTtcbnZhciBBTEVSVCA9IHtcbiAgbmFtZTogXCJBTEVSVFwiLFxuICB2YWx1ZTogMVxufTtcbnZhciBDUklUSUNBTCA9IHtcbiAgbmFtZTogXCJDUklUSUNBTFwiLFxuICB2YWx1ZTogMlxufTtcbnZhciBFUlJPUiA9IHtcbiAgbmFtZTogXCJFUlJPUlwiLFxuICB2YWx1ZTogM1xufTtcbnZhciBXQVJOSU5HID0ge1xuICBuYW1lOiBcIldBUk5JTkdcIixcbiAgdmFsdWU6IDRcbn07XG52YXIgTk9USUNFID0ge1xuICBuYW1lOiBcIk5PVElDRVwiLFxuICB2YWx1ZTogNVxufTtcbnZhciBJTkZPID0ge1xuICBuYW1lOiBcIklORk9cIixcbiAgdmFsdWU6IDZcbn07XG52YXIgREVCVUcgPSB7XG4gIG5hbWU6IFwiREVCVUdcIixcbiAgdmFsdWU6IDdcbn07XG52YXIgVFJBQ0UgPSB7XG4gIG5hbWU6IFwiVFJBQ0VcIixcbiAgdmFsdWU6IDhcbn07XG52YXIgREVGQVVMVCA9IHtcbiAgbmFtZTogXCJERUZBVUxUXCIsXG4gIHZhbHVlOiA5XG59O1xudmFyIExvZ0xldmVscyA9IFtcbiAgRU1FUkdFTkNZLFxuICBBTEVSVCxcbiAgQ1JJVElDQUwsXG4gIEVSUk9SLFxuICBXQVJOSU5HLFxuICBOT1RJQ0UsXG4gIElORk8sXG4gIERFQlVHLFxuICBUUkFDRSxcbiAgREVGQVVMVFxuXTtcbnZhciBnZXRDb25maWcyID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gTG9nTGV2ZWxzLmZpbmQoKGNvbmZpZzIpID0+IGNvbmZpZzIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBMZXZlbCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8vIHNyYy9jb25maWcudHNcbnZhciBkZWZhdWx0TG9nTGV2ZWwgPSBJTkZPO1xudmFyIGRlZmF1bHRMb2dGb3JtYXQgPSBURVhUO1xudmFyIGRlZmF1bHRMb2dnaW5nQ29uZmlnID0ge1xuICBsb2dMZXZlbDogZGVmYXVsdExvZ0xldmVsLFxuICBsb2dGb3JtYXQ6IGRlZmF1bHRMb2dGb3JtYXQsXG4gIG92ZXJyaWRlczoge30sXG4gIGZsb29kQ29udHJvbDoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHRocmVzaG9sZDogMTAsXG4gICAgdGltZWZyYW1lOiAxZTNcbiAgICAvLyAxIHNlY29uZFxuICB9XG59O1xudmFyIGNvbnZlcnRPdmVycmlkZXMgPSAob3ZlcnJpZGVzKSA9PiB7XG4gIGNvbnN0IGNvbnZlcnRlZE92ZXJyaWRlcyA9IHt9O1xuICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMob3ZlcnJpZGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGNvbnZlcnRlZE92ZXJyaWRlc1trZXldID0geyBsb2dMZXZlbDogdmFsdWUubG9nTGV2ZWwgPyBnZXRDb25maWcyKHZhbHVlLmxvZ0xldmVsKSA6IGRlZmF1bHRMb2dMZXZlbCB9O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPdmVycmlkZXM7XG59O1xudmFyIGNvbnZlcnRDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbG9nTGV2ZWw6IGNvbmZpZy5sb2dMZXZlbCA/IGdldENvbmZpZzIoY29uZmlnLmxvZ0xldmVsKSA6IGRlZmF1bHRMb2dMZXZlbCxcbiAgICBsb2dGb3JtYXQ6IGNvbmZpZy5sb2dGb3JtYXQgPyBnZXRDb25maWcoY29uZmlnLmxvZ0Zvcm1hdCkgOiBkZWZhdWx0TG9nRm9ybWF0LFxuICAgIG92ZXJyaWRlczogY29udmVydE92ZXJyaWRlcyhjb25maWcub3ZlcnJpZGVzKSxcbiAgICBmbG9vZENvbnRyb2w6IHtcbiAgICAgIC4uLmRlZmF1bHRMb2dnaW5nQ29uZmlnLmZsb29kQ29udHJvbCxcbiAgICAgIC4uLmNvbmZpZy5mbG9vZENvbnRyb2wgfHwge31cbiAgICB9XG4gIH07XG59O1xudmFyIGNvbmZpZ3VyZUxvZ2dpbmcgPSAoKSA9PiB7XG4gIGxldCBjb25maWcgPSB7fTtcbiAgY29uc3QgbG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkxPR0dJTkdfQ09ORklHO1xuICBjb25zdCBleHBvTG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBjb25zdCBuZXh0TG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBsZXQgbG9nTGV2ZWxFbnYgPSBwcm9jZXNzLmVudi5MT0dfTEVWRUw7XG4gIGxldCBsb2dGb3JtYXRFbnYgPSBwcm9jZXNzLmVudi5MT0dfRk9STUFUO1xuICBpZiAobG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKGxvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIExPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwb0xvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShleHBvTG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gRVhQT19QVUJMSUNfTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0TG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKG5leHRMb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnZlcnRlZENvbmZpZyA9IGNvbnZlcnRDb25maWcoY29uZmlnKTtcbiAgaWYgKGxvZ0xldmVsRW52KSB7XG4gICAgbG9nTGV2ZWxFbnYgPSBsb2dMZXZlbEVudj8udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBsb2dMZXZlbENvbmZpZyA9IGdldENvbmZpZzIobG9nTGV2ZWxFbnYpO1xuICAgIGNvbnZlcnRlZENvbmZpZy5sb2dMZXZlbCA9IGxvZ0xldmVsQ29uZmlnO1xuICB9XG4gIGlmIChsb2dGb3JtYXRFbnYpIHtcbiAgICBsb2dGb3JtYXRFbnYgPSBsb2dGb3JtYXRFbnYudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBsb2dGb3JtYXRDb25maWcgPSBnZXRDb25maWcobG9nRm9ybWF0RW52KTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nRm9ybWF0ID0gbG9nRm9ybWF0Q29uZmlnO1xuICB9XG4gIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZywgLi4uY29udmVydGVkQ29uZmlnIH07XG4gIHJldHVybiBmaW5hbENvbmZpZztcbn07XG5cbi8vIHNyYy9Xcml0ZXIudHNcbnZhciBjcmVhdGVXcml0ZXIgPSAoZm9ybWF0dGVyLCBsb2dNZXRob2QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVzcGVjdEluamVjdGVkTWV0aG9kID0gZmFsc2UsXG4gICAgZXJyb3JNZXRob2QgPSBjb25zb2xlLmVycm9yLFxuICAgIHdhcm5pbmdNZXRob2QgPSBjb25zb2xlLndhcm4sXG4gICAgaW5mb01ldGhvZCA9IGNvbnNvbGUubG9nXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4ge1xuICAgIHdyaXRlOiAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgICBsZXQgZmluYWxMb2dNZXRob2QgPSBsb2dNZXRob2Q7XG4gICAgICBpZiAoIXJlc3BlY3RJbmplY3RlZE1ldGhvZCkge1xuICAgICAgICBpZiAobGV2ZWwubmFtZSA9PT0gRVJST1IubmFtZSB8fCBsZXZlbC5uYW1lID09PSBDUklUSUNBTC5uYW1lIHx8IGxldmVsLm5hbWUgPT09IEFMRVJULm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gRU1FUkdFTkNZLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGVycm9yTWV0aG9kO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsLm5hbWUgPT09IFdBUk5JTkcubmFtZSkge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gd2FybmluZ01ldGhvZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGluZm9NZXRob2Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmFsTG9nTWV0aG9kKGZvcm1hdHRlci5mb3JtYXRMb2cobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2Zvcm1hdHRlci50c1xuaW1wb3J0IHV0aWwgZnJvbSBcInV0aWxcIjtcbnZhciBzYWZlSW5zcGVjdCA9IChvYmopID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KG9iaik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgW09iamVjdDogJHt0eXBlb2Ygb2JqfV1gO1xuICB9XG59O1xudmFyIHNhZmVGb3JtYXQgPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1dGlsLmZvcm1hdChtZXNzYWdlLCAuLi5hcmdzKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGAke21lc3NhZ2V9ICR7c2FmZUluc3BlY3QoYXJncyl9YDtcbiAgfVxufTtcbnZhciBjcmVhdGVGb3JtYXR0ZXIgPSAobG9nRm9ybWF0KSA9PiB7XG4gIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJURVhUXCIpIHtcbiAgICByZXR1cm4gZ2V0VGV4dEZvcm1hdHRlcigpO1xuICB9IGVsc2UgaWYgKGxvZ0Zvcm1hdC5uYW1lID09PSBcIlNUUlVDVFVSRURcIikge1xuICAgIHJldHVybiBnZXRTdHJ1Y3R1cmVkRm9ybWF0dGVyKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxvZyBmb3JtYXQ6ICR7bG9nRm9ybWF0Lm5hbWV9YCk7XG59O1xudmFyIGdldFRleHRGb3JtYXR0ZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGZvcm1hdExvZyA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG4gICAgbGV0IGxvZ01lc3NhZ2U7XG4gICAgaWYgKHBheWxvYWQuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBwYXlsb2FkLm1lc3NhZ2U7XG4gICAgfSBlbHNlIGlmIChoYXNTcGVjaWZpZXJzKSB7XG4gICAgICBsb2dNZXNzYWdlID0gc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBgJHtwYXlsb2FkLm1lc3NhZ2V9ICR7c2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCgkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpfSkgWyR7bGV2ZWwubmFtZX1dIC0gWyR7Y29vcmRpbmF0ZXMuY2F0ZWdvcnl9XSAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9ICR7bG9nTWVzc2FnZX1gO1xuICB9O1xuICBjb25zdCB0aW1lck1lc3NhZ2UgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgcmFuZG9tSW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU2KTtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UyID0gYCgkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpfSkgWyR7bGV2ZWwubmFtZX1dIC0gWyR7Y29vcmRpbmF0ZXMuY2F0ZWdvcnl9XSAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9ICR7c2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSl9ICR7c2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKX0gJHtyYW5kb21JbnR9YDtcbiAgICByZXR1cm4gdGltZXJNZXNzYWdlMjtcbiAgfTtcbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gVEVYVCB9O1xufTtcbnZhciBnZXRTdHJ1Y3R1cmVkRm9ybWF0dGVyID0gKCkgPT4ge1xuICBjb25zdCBmb3JtYXRMb2cgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3Qgc2V2ZXJpdHkgPSBsZXZlbC5uYW1lO1xuICAgIGNvbnN0IGhhc1NwZWNpZmllcnMgPSAvJVtzZGppZm9PJV0vLnRlc3QocGF5bG9hZC5tZXNzYWdlKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc2V2ZXJpdHksXG4gICAgICBtZXNzYWdlOiBoYXNTcGVjaWZpZXJzID8gc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSkgOiBwYXlsb2FkLm1lc3NhZ2UsXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vbGFiZWxzXCI6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBgJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfWBcbiAgICAgIH0sXG4gICAgICAuLi4haGFzU3BlY2lmaWVycyAmJiBwYXlsb2FkLmRhdGEubGVuZ3RoID4gMCAmJiB7IGRhdGE6IHNhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSkgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB0aW1lck1lc3NhZ2UgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3Qgc2V2ZXJpdHkgPSBsZXZlbC5uYW1lO1xuICAgIGNvbnN0IHJhbmRvbUludCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogc2FmZUZvcm1hdChwYXlsb2FkLm1lc3NhZ2UsIC4uLnBheWxvYWQuZGF0YSksXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vbGFiZWxzXCI6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBgJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfWBcbiAgICAgIH0sXG4gICAgICBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL3NwYW5JZFwiOiBTdHJpbmcocmFuZG9tSW50KVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4geyBmb3JtYXRMb2csIHRpbWVyTWVzc2FnZSwgZ2V0TG9nRm9ybWF0OiAoKSA9PiBTVFJVQ1RVUkVEIH07XG59O1xuXG4vLyBzcmMvRmxvb2RDb250cm9sLnRzXG5pbXBvcnQgdXRpbDIgZnJvbSBcInV0aWxcIjtcbnZhciBoYXNoID0gKG1lc3NhZ2UsIGRhdGEpID0+IHtcbiAgY29uc3QgZGF0YVN0cmluZyA9IGRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB1dGlsMi5pbnNwZWN0KGl0ZW0pO1xuICAgIH1cbiAgfSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGAke21lc3NhZ2V9JHtkYXRhU3RyaW5nfWA7XG59O1xudmFyIEZsb29kQ29udHJvbCA9IGNsYXNzIHtcbiAgY29uZmlnO1xuICBoaXN0b3J5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3VwcHJlc3NlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNsZWFudXBUaW1lciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuY2xlYW51cCgpLCB0aGlzLmNvbmZpZy50aW1lZnJhbWUgKiAyKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChjb25zdCBbaGFzaDIsIHRpbWVzdGFtcHNdIG9mIHRoaXMuaGlzdG9yeS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHJlY2VudFRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmZpbHRlcihcbiAgICAgICAgKHRpbWVzdGFtcCkgPT4gbm93IC0gdGltZXN0YW1wIDwgdGhpcy5jb25maWcudGltZWZyYW1lXG4gICAgICApO1xuICAgICAgaWYgKHJlY2VudFRpbWVzdGFtcHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmhpc3Rvcnkuc2V0KGhhc2gyLCByZWNlbnRUaW1lc3RhbXBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5kZWxldGUoaGFzaDIpO1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuZGVsZXRlKGhhc2gyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2sobWVzc2FnZSwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIFwibG9nXCI7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSAodGhpcy5oaXN0b3J5LmdldChtZXNzYWdlSGFzaCkgfHwgW10pLmZpbHRlcihcbiAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICk7XG4gICAgdGltZXN0YW1wcy5wdXNoKG5vdyk7XG4gICAgdGhpcy5oaXN0b3J5LnNldChtZXNzYWdlSGFzaCwgdGltZXN0YW1wcyk7XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID4gdGhpcy5jb25maWcudGhyZXNob2xkKSB7XG4gICAgICBjb25zdCBzdXBwcmVzc2VkSW5mbyA9IHRoaXMuc3VwcHJlc3NlZC5nZXQobWVzc2FnZUhhc2gpO1xuICAgICAgaWYgKHN1cHByZXNzZWRJbmZvKSB7XG4gICAgICAgIHN1cHByZXNzZWRJbmZvLmNvdW50Kys7XG4gICAgICAgIHJldHVybiBcInN1cHByZXNzXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuc2V0KG1lc3NhZ2VIYXNoLCB7IGNvdW50OiAxLCBmaXJzdFRpbWVzdGFtcDogdGltZXN0YW1wc1swXSwgc3VtbWFyeUxvZ2dlZDogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiBcInN1cHByZXNzXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnN1cHByZXNzZWQuaGFzKG1lc3NhZ2VIYXNoKSkge1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuZGVsZXRlKG1lc3NhZ2VIYXNoKTtcbiAgICAgICAgcmV0dXJuIFwicmVzdW1lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcImxvZ1wiO1xuICB9XG4gIGdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSB7XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBoYXNoKG1lc3NhZ2UsIGRhdGEpO1xuICAgIHJldHVybiB0aGlzLnN1cHByZXNzZWQuZ2V0KG1lc3NhZ2VIYXNoKT8uY291bnQgfHwgMDtcbiAgfVxufTtcblxuLy8gc3JjL0xvZ2dlci50c1xudmFyIGNyZWF0ZUxvZ2dlciA9IChsb2dGb3JtYXQsIGxvZ0xldmVsLCBjb29yZGluYXRlcywgZmxvb2RDb250cm9sQ29uZmlnLCB3cml0ZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihsb2dGb3JtYXQpO1xuICBjb25zdCBmbG9vZENvbnRyb2wgPSBmbG9vZENvbnRyb2xDb25maWcuZW5hYmxlZCA/IG5ldyBGbG9vZENvbnRyb2woZmxvb2RDb250cm9sQ29uZmlnKSA6IG51bGw7XG4gIGNvbnN0IGxvZ0Z1bmN0aW9uID0gY29uc29sZS5sb2c7XG4gIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlcihmb3JtYXR0ZXIsIGxvZ0Z1bmN0aW9uLCB3cml0ZXJPcHRpb25zKTtcbiAgY29uc3Qgd3JpdGUgPSAobGV2ZWwsIG1lc3NhZ2UsIGRhdGEpID0+IHtcbiAgICBpZiAobG9nTGV2ZWwudmFsdWUgPCBsZXZlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGVjayA9IGZsb29kQ29udHJvbCA/IGZsb29kQ29udHJvbC5jaGVjayhtZXNzYWdlLCBkYXRhKSA6IFwibG9nXCI7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgbWVzc2FnZSwgZGF0YSB9O1xuICAgIHN3aXRjaCAoY2hlY2spIHtcbiAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN1cHByZXNzXCI6XG4gICAgICAgIGlmIChmbG9vZENvbnRyb2wgJiYgZmxvb2RDb250cm9sLmdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICBjb25zdCBuZXdQYXlsb2FkID0geyBtZXNzYWdlOiBgU3RhcnRlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZWAsIGRhdGE6IFtdIH07XG4gICAgICAgICAgd3JpdGVyLndyaXRlKG9yaWdpbmFsTGV2ZWwsIGNvb3JkaW5hdGVzLCBuZXdQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZXN1bWVcIjoge1xuICAgICAgICBjb25zdCBjb3VudCA9IGZsb29kQ29udHJvbCA/IGZsb29kQ29udHJvbC5nZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkgOiAwO1xuICAgICAgICBjb25zdCByZXN1bWVQYXlsb2FkID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IGBTdG9wcGVkIHN1cHByZXNzaW5nIHJlcGVhdGVkIGxvZyBtZXNzYWdlLiBTdXBwcmVzc2VkICR7Y291bnR9IHRpbWVzLmAsXG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcmVzdW1lUGF5bG9hZCk7XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXJ0VGltZUxvZ2dlciA9IChsb2dMZXZlbDIsIGNvb3JkaW5hdGVzMiwgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHRpbWVyTWVzc2FnZSA9IGZvcm1hdHRlci50aW1lck1lc3NhZ2UobG9nTGV2ZWwyLCBjb29yZGluYXRlczIsIHBheWxvYWQpO1xuICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWUodGltZXJNZXNzYWdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWVFbmQodGltZXJNZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgICBsb2c6ICguLi5kYXRhKSA9PiB7XG4gICAgICAgIGxvZ0xldmVsMi52YWx1ZSA+PSBERUJVRy52YWx1ZSAmJiBjb25zb2xlLnRpbWVMb2codGltZXJNZXNzYWdlLCAuLi5kYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGVtZXJnZW5jeTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEVNRVJHRU5DWSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBhbGVydDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEFMRVJULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGNyaXRpY2FsOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoQ1JJVElDQUwsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShFUlJPUiwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB3YXJuaW5nOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoV0FSTklORywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBub3RpY2U6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShOT1RJQ0UsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgaW5mbzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKElORk8sIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShERUJVRywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0cmFjZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKFRSQUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlZmF1bHQ6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShERUZBVUxULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHRpbWU6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG4gICAgICByZXR1cm4gc3RhcnRUaW1lTG9nZ2VyKGxvZ0xldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgfSxcbiAgICBnZXQ6ICguLi5hZGRpdGlvbmFsQ29tcG9uZW50cykgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihsb2dGb3JtYXQsIGxvZ0xldmVsLCB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogWy4uLmNvb3JkaW5hdGVzLmNvbXBvbmVudHMsIC4uLmFkZGl0aW9uYWxDb21wb25lbnRzXVxuICAgICAgfSwgZmxvb2RDb250cm9sQ29uZmlnLCB3cml0ZXJPcHRpb25zKTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgIGlmIChmbG9vZENvbnRyb2wpIHtcbiAgICAgICAgZmxvb2RDb250cm9sLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbG9nZ2luZy50c1xudmFyIGdldExvZ2dlciA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ3VyZUxvZ2dpbmcoKTtcbiAgY29uc3QgbG9nZ2VyID0gY3JlYXRlQmFzZUxvZ2dlcihuYW1lLCBjb25maWcpO1xuICByZXR1cm4gbG9nZ2VyO1xufTtcbnZhciBjcmVhdGVCYXNlTG9nZ2VyID0gKG5hbWUsIGNvbmZpZykgPT4ge1xuICBsZXQgeyBsb2dMZXZlbCB9ID0gY29uZmlnO1xuICBjb25zdCB7IGxvZ0Zvcm1hdCwgZmxvb2RDb250cm9sIH0gPSBjb25maWc7XG4gIGNvbnN0IG92ZXJyaWRlcyA9IGNvbmZpZy5vdmVycmlkZXM7XG4gIGlmIChvdmVycmlkZXMgJiYgb3ZlcnJpZGVzW25hbWVdKSB7XG4gICAgbG9nTGV2ZWwgPSBvdmVycmlkZXNbbmFtZV0ubG9nTGV2ZWw7XG4gIH1cbiAgY29uc3QgY29vcmRpbmF0ZXMgPSB7IGNhdGVnb3J5OiBuYW1lLCBjb21wb25lbnRzOiBbXSB9O1xuICByZXR1cm4gY3JlYXRlTG9nZ2VyKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBmbG9vZENvbnRyb2wpO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IHsgZ2V0TG9nZ2VyIH07XG5leHBvcnQge1xuICBMb2dGb3JtYXRfZXhwb3J0cyBhcyBMb2dGb3JtYXQsXG4gIExvZ0xldmVsX2V4cG9ydHMgYXMgTG9nTGV2ZWwsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZ2V0TG9nZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-http-api/node_modules/@fjell/logging/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-logging/dist/index.js":
/*!**************************************!*\
  !*** ../fjell-logging/dist/index.js ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n    LogFormats: ()=>LogFormats,\n    STRUCTURED: ()=>STRUCTURED,\n    TEXT: ()=>TEXT,\n    getConfig: ()=>getConfig\n});\nvar TEXT = {\n    name: \"TEXT\",\n    description: \"Text format\"\n};\nvar STRUCTURED = {\n    name: \"STRUCTURED\",\n    description: \"Structured format\"\n};\nvar LogFormats = [\n    TEXT,\n    STRUCTURED\n];\nvar getConfig = (name)=>{\n    const config = LogFormats.find((config2)=>config2.name === name);\n    if (!config) {\n        throw new Error(\"Invalid Log Format Supplied to Logging Configuration '\".concat(name, \"'\"));\n    }\n    return config;\n};\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n    ALERT: ()=>ALERT,\n    CRITICAL: ()=>CRITICAL,\n    DEBUG: ()=>DEBUG,\n    DEFAULT: ()=>DEFAULT,\n    EMERGENCY: ()=>EMERGENCY,\n    ERROR: ()=>ERROR,\n    INFO: ()=>INFO,\n    LogLevels: ()=>LogLevels,\n    NOTICE: ()=>NOTICE,\n    TRACE: ()=>TRACE,\n    WARNING: ()=>WARNING,\n    getConfig: ()=>getConfig2\n});\nvar EMERGENCY = {\n    name: \"EMERGENCY\",\n    value: 0\n};\nvar ALERT = {\n    name: \"ALERT\",\n    value: 1\n};\nvar CRITICAL = {\n    name: \"CRITICAL\",\n    value: 2\n};\nvar ERROR = {\n    name: \"ERROR\",\n    value: 3\n};\nvar WARNING = {\n    name: \"WARNING\",\n    value: 4\n};\nvar NOTICE = {\n    name: \"NOTICE\",\n    value: 5\n};\nvar INFO = {\n    name: \"INFO\",\n    value: 6\n};\nvar DEBUG = {\n    name: \"DEBUG\",\n    value: 7\n};\nvar TRACE = {\n    name: \"TRACE\",\n    value: 8\n};\nvar DEFAULT = {\n    name: \"DEFAULT\",\n    value: 9\n};\nvar LogLevels = [\n    EMERGENCY,\n    ALERT,\n    CRITICAL,\n    ERROR,\n    WARNING,\n    NOTICE,\n    INFO,\n    DEBUG,\n    TRACE,\n    DEFAULT\n];\nvar getConfig2 = (name)=>{\n    const config = LogLevels.find((config2)=>config2.name === name);\n    if (!config) {\n        throw new Error(\"Invalid Log Level Supplied to Logging Configuration '\".concat(name, \"'\"));\n    }\n    return config;\n};\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n    logLevel: defaultLogLevel,\n    logFormat: defaultLogFormat,\n    overrides: {},\n    floodControl: {\n        enabled: false,\n        threshold: 10,\n        timeframe: 1e3\n    }\n};\nvar convertOverrides = (overrides)=>{\n    const convertedOverrides = {};\n    if (overrides) {\n        Object.entries(overrides).forEach((param)=>{\n            let [key, value] = param;\n            convertedOverrides[key] = {\n                logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel\n            };\n        });\n    }\n    return convertedOverrides;\n};\nvar convertConfig = (config)=>{\n    return {\n        logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n        logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n        overrides: convertOverrides(config.overrides),\n        floodControl: {\n            ...defaultLoggingConfig.floodControl,\n            ...config.floodControl || {}\n        }\n    };\n};\nvar configureLogging = ()=>{\n    let config = {};\n    const loggingConfigEnv = process.env.LOGGING_CONFIG;\n    const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n    const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n    let logLevelEnv = process.env.LOG_LEVEL;\n    let logFormatEnv = process.env.LOG_FORMAT;\n    if (loggingConfigEnv) {\n        try {\n            config = JSON.parse(loggingConfigEnv);\n        } catch (error) {\n            console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n            config = {};\n        }\n    } else if (expoLoggingConfigEnv) {\n        try {\n            config = JSON.parse(expoLoggingConfigEnv);\n        } catch (error) {\n            console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n            config = {};\n        }\n    } else if (nextLoggingConfigEnv) {\n        try {\n            config = JSON.parse(nextLoggingConfigEnv);\n        } catch (error) {\n            console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n            config = {};\n        }\n    }\n    const convertedConfig = convertConfig(config);\n    if (logLevelEnv) {\n        logLevelEnv = logLevelEnv === null || logLevelEnv === void 0 ? void 0 : logLevelEnv.toUpperCase();\n        const logLevelConfig = getConfig2(logLevelEnv);\n        convertedConfig.logLevel = logLevelConfig;\n    }\n    if (logFormatEnv) {\n        logFormatEnv = logFormatEnv.toUpperCase();\n        const logFormatConfig = getConfig(logFormatEnv);\n        convertedConfig.logFormat = logFormatConfig;\n    }\n    const finalConfig = {\n        ...defaultLoggingConfig,\n        ...convertedConfig\n    };\n    return finalConfig;\n};\n// src/Writer.ts\nvar createWriter = function(formatter, logMethod) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const { respectInjectedMethod = false, errorMethod = console.error, warningMethod = console.warn, infoMethod = console.log } = options;\n    return {\n        write: (level, coordinates, payload)=>{\n            let finalLogMethod = logMethod;\n            if (!respectInjectedMethod) {\n                if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n                    finalLogMethod = errorMethod;\n                } else if (level.name === WARNING.name) {\n                    finalLogMethod = warningMethod;\n                } else {\n                    finalLogMethod = infoMethod;\n                }\n            }\n            finalLogMethod(formatter.formatLog(level, coordinates, payload));\n        }\n    };\n};\n// src/formatter.ts\n\nvar safeInspect = (obj)=>{\n    try {\n        return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n    } catch (e) {\n        return \"[Object: \".concat(typeof obj, \"]\");\n    }\n};\nvar safeFormat = function(message) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    try {\n        return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n    } catch (e) {\n        return \"\".concat(message, \" \").concat(safeInspect(args));\n    }\n};\nvar createFormatter = (logFormat)=>{\n    if (logFormat.name === \"TEXT\") {\n        return getTextFormatter();\n    } else if (logFormat.name === \"STRUCTURED\") {\n        return getStructuredFormatter();\n    }\n    throw new Error(\"Unknown log format: \".concat(logFormat.name));\n};\nvar getTextFormatter = ()=>{\n    const formatLog = (level, coordinates, payload)=>{\n        const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n        let logMessage;\n        if (payload.data.length === 0) {\n            logMessage = payload.message;\n        } else if (hasSpecifiers) {\n            logMessage = safeFormat(payload.message, ...payload.data);\n        } else {\n            logMessage = \"\".concat(payload.message, \" \").concat(safeInspect(payload.data));\n        }\n        return \"(\".concat(/* @__PURE__ */ new Date().valueOf(), \") [\").concat(level.name, \"] - [\").concat(coordinates.category, \"] \").concat(coordinates.components.map((c)=>\"[\".concat(c, \"]\")), \" \").concat(logMessage);\n    };\n    const timerMessage = (level, coordinates, payload)=>{\n        const randomInt = Math.floor(Math.random() * 1e6);\n        const timerMessage2 = \"(\".concat(/* @__PURE__ */ new Date().valueOf(), \") [\").concat(level.name, \"] - [\").concat(coordinates.category, \"] \").concat(coordinates.components.map((c)=>\"[\".concat(c, \"]\")), \" \").concat(safeFormat(payload.message, ...payload.data), \" \").concat(safeInspect(payload.data), \" \").concat(randomInt);\n        return timerMessage2;\n    };\n    return {\n        formatLog,\n        timerMessage,\n        getLogFormat: ()=>TEXT\n    };\n};\nvar getStructuredFormatter = ()=>{\n    const formatLog = (level, coordinates, payload)=>{\n        const severity = level.name;\n        const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n        return JSON.stringify({\n            severity,\n            message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n            \"logging.googleapis.com/labels\": {\n                category: coordinates.category,\n                components: \"\".concat(coordinates.components.map((c)=>\"[\".concat(c, \"]\")))\n            },\n            ...!hasSpecifiers && payload.data.length > 0 && {\n                data: safeInspect(payload.data)\n            }\n        });\n    };\n    const timerMessage = (level, coordinates, payload)=>{\n        const severity = level.name;\n        const randomInt = Math.floor(Math.random() * 1e6);\n        return JSON.stringify({\n            severity,\n            message: safeFormat(payload.message, ...payload.data),\n            \"logging.googleapis.com/labels\": {\n                category: coordinates.category,\n                components: \"\".concat(coordinates.components.map((c)=>\"[\".concat(c, \"]\")))\n            },\n            data: safeInspect(payload.data),\n            \"logging.googleapis.com/spanId\": String(randomInt)\n        });\n    };\n    return {\n        formatLog,\n        timerMessage,\n        getLogFormat: ()=>STRUCTURED\n    };\n};\n// src/FloodControl.ts\n\nvar hash = (message, data)=>{\n    const dataString = data.map((item)=>{\n        try {\n            return JSON.stringify(item);\n        } catch (e) {\n            return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n        }\n    }).join(\"\");\n    return \"\".concat(message).concat(dataString);\n};\nvar FloodControl = class {\n    destroy() {\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    cleanup() {\n        const now = Date.now();\n        for (const [hash2, timestamps] of this.history.entries()){\n            const recentTimestamps = timestamps.filter((timestamp)=>now - timestamp < this.config.timeframe);\n            if (recentTimestamps.length > 0) {\n                this.history.set(hash2, recentTimestamps);\n            } else {\n                this.history.delete(hash2);\n                this.suppressed.delete(hash2);\n            }\n        }\n    }\n    check(message, data) {\n        if (!this.config.enabled) {\n            return \"log\";\n        }\n        const messageHash = hash(message, data);\n        const now = Date.now();\n        const timestamps = (this.history.get(messageHash) || []).filter((timestamp)=>now - timestamp < this.config.timeframe);\n        timestamps.push(now);\n        this.history.set(messageHash, timestamps);\n        if (timestamps.length > this.config.threshold) {\n            const suppressedInfo = this.suppressed.get(messageHash);\n            if (suppressedInfo) {\n                suppressedInfo.count++;\n                return \"suppress\";\n            } else {\n                this.suppressed.set(messageHash, {\n                    count: 1,\n                    firstTimestamp: timestamps[0],\n                    summaryLogged: false\n                });\n                return \"suppress\";\n            }\n        } else {\n            if (this.suppressed.has(messageHash)) {\n                this.suppressed.delete(messageHash);\n                return \"resume\";\n            }\n        }\n        return \"log\";\n    }\n    getSuppressedCount(message, data) {\n        var _this_suppressed_get;\n        const messageHash = hash(message, data);\n        return ((_this_suppressed_get = this.suppressed.get(messageHash)) === null || _this_suppressed_get === void 0 ? void 0 : _this_suppressed_get.count) || 0;\n    }\n    constructor(config){\n        this.history = /* @__PURE__ */ new Map();\n        this.suppressed = /* @__PURE__ */ new Map();\n        this.cleanupTimer = null;\n        this.config = config;\n        if (this.config.enabled) {\n            this.cleanupTimer = setInterval(()=>this.cleanup(), this.config.timeframe * 2);\n        }\n    }\n};\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions)=>{\n    const formatter = createFormatter(logFormat);\n    const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n    const logFunction = console.log;\n    const writer = createWriter(formatter, logFunction, writerOptions);\n    const write = (level, message, data)=>{\n        if (logLevel.value < level.value) {\n            return;\n        }\n        const check = floodControl ? floodControl.check(message, data) : \"log\";\n        const payload = {\n            message,\n            data\n        };\n        switch(check){\n            case \"log\":\n                writer.write(level, coordinates, payload);\n                break;\n            case \"suppress\":\n                if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n                    const originalLevel = level;\n                    const newPayload = {\n                        message: \"Started suppressing repeated log message\",\n                        data: []\n                    };\n                    writer.write(originalLevel, coordinates, newPayload);\n                }\n                break;\n            case \"resume\":\n                {\n                    const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n                    const resumePayload = {\n                        message: \"Stopped suppressing repeated log message. Suppressed \".concat(count, \" times.\"),\n                        data: []\n                    };\n                    writer.write(level, coordinates, resumePayload);\n                    writer.write(level, coordinates, payload);\n                    break;\n                }\n        }\n    };\n    const startTimeLogger = (logLevel2, coordinates2, payload)=>{\n        const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n        logLevel2.value >= DEBUG.value && console.time(timerMessage);\n        return {\n            end: ()=>{\n                logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n            },\n            log: function() {\n                for(var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++){\n                    data[_key] = arguments[_key];\n                }\n                logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n            }\n        };\n    };\n    return {\n        emergency: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(EMERGENCY, message, data);\n        },\n        alert: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(ALERT, message, data);\n        },\n        critical: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(CRITICAL, message, data);\n        },\n        error: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(ERROR, message, data);\n        },\n        warning: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(WARNING, message, data);\n        },\n        notice: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(NOTICE, message, data);\n        },\n        info: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(INFO, message, data);\n        },\n        debug: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(DEBUG, message, data);\n        },\n        trace: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(TRACE, message, data);\n        },\n        default: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            write(DEFAULT, message, data);\n        },\n        time: function(message) {\n            for(var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                data[_key - 1] = arguments[_key];\n            }\n            const payload = {\n                message,\n                data\n            };\n            return startTimeLogger(logLevel, coordinates, payload);\n        },\n        get: function() {\n            for(var _len = arguments.length, additionalComponents = new Array(_len), _key = 0; _key < _len; _key++){\n                additionalComponents[_key] = arguments[_key];\n            }\n            return createLogger(logFormat, logLevel, {\n                category: coordinates.category,\n                components: [\n                    ...coordinates.components,\n                    ...additionalComponents\n                ]\n            }, floodControlConfig, writerOptions);\n        },\n        destroy: ()=>{\n            if (floodControl) {\n                floodControl.destroy();\n            }\n        }\n    };\n};\n// src/logging.ts\nvar getLogger = (name)=>{\n    const config = configureLogging();\n    const logger = createBaseLogger(name, config);\n    return logger;\n};\nvar createBaseLogger = (name, config)=>{\n    let { logLevel } = config;\n    const { logFormat, floodControl } = config;\n    const overrides = config.overrides;\n    if (overrides && overrides[name]) {\n        logLevel = overrides[name].logLevel;\n    }\n    const coordinates = {\n        category: name,\n        components: []\n    };\n    return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n// src/index.ts\nvar index_default = {\n    getLogger\n};\n //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1sb2dnaW5nL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7QUFBQTtBQU9PLElBQU0sT0FBZTtJQUMxQixNQUFNO0lBQ04sYUFBYTtBQUNmO0FBRU8sSUFBTSxhQUFxQjtJQUNoQyxNQUFNO0lBQ04sYUFBYTtBQUNmO0FBRU8sSUFBTSxhQUF1QjtJQUNsQztJQUNBO0NBQ0Y7QUFFTyxJQUFNLFlBQVksQ0FBQztJQUN4QixNQUFNLFNBQVMsV0FBVyxLQUFLLENBQUFBLFVBQVVBLFFBQU8sU0FBUyxJQUFJO0lBQzdELElBQUksQ0FBQyxRQUFRO1FBQ1gsTUFBTSxJQUFJLE1BQU0seURBQTZELE9BQUosSUFBSSxJQUFHO0lBQ2xGO0lBQ0EsT0FBTztBQUNUOztBQzVCQTtBQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBLGVBQUFDO0FBQUE7QUFRTyxJQUFNLFlBQW9CO0lBQy9CLE1BQU07SUFDTixPQUFPO0FBQ1Q7QUFDTyxJQUFNLFFBQWdCO0lBQzNCLE1BQU07SUFDTixPQUFPO0FBQ1Q7QUFDTyxJQUFNLFdBQW1CO0lBQzlCLE1BQU07SUFDTixPQUFPO0FBQ1Q7QUFDTyxJQUFNLFFBQWdCO0lBQzNCLE1BQU07SUFDTixPQUFPO0FBQ1Q7QUFDTyxJQUFNLFVBQWtCO0lBQzdCLE1BQU07SUFDTixPQUFPO0FBQ1Q7QUFDTyxJQUFNLFNBQWlCO0lBQzVCLE1BQU07SUFDTixPQUFPO0FBQ1Q7QUFDTyxJQUFNLE9BQWU7SUFDMUIsTUFBTTtJQUNOLE9BQU87QUFDVDtBQUNPLElBQU0sUUFBZ0I7SUFDM0IsTUFBTTtJQUNOLE9BQU87QUFDVDtBQUNPLElBQU0sUUFBZ0I7SUFDM0IsTUFBTTtJQUNOLE9BQU87QUFDVDtBQUNPLElBQU0sVUFBa0I7SUFDN0IsTUFBTTtJQUNO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QUFPLFNBQUM7O2dCQUFvQixTQUFnQjs7WUFDMUMsTUFBZSxPQUFPLFNBQVMsSUFBSTtRQUNyQztRQUNBLFNBQVMsU0FBQzs7Z0JBQW9CLFNBQWdCOztZQUM1QyxNQUFlLFNBQVMsU0FBUyxJQUFJO1FBQ3ZDO1FBQ0EsTUFBTSxTQUFDOztnQkFBb0IsU0FBZ0I7O1lBQ3pDLE1BQU0sVUFBVTtnQkFBRTtnQkFBUztZQUFLO1lBQ2hDLE9BQU8sZ0JBQWdCLFVBQVUsYUFBYSxPQUFPO1FBQ3ZEO1FBQ0EsS0FBSzs7Z0JBQUkseUJBQW1DOztZQUMxQyxPQUFPLGFBQWEsV0FBVyxVQUFVO2dCQUN2QyxVQUFVLFlBQVk7Z0JBQ3RCLFlBQVksQ0FBQzt1QkFBRyxZQUFZO3VCQUFlLG9CQUFvQjtpQkFBQTtZQUNqRSxHQUFHLG9CQUFvQixhQUFhO1FBQ3RDO1FBQ0EsU0FBUztZQUNQLElBQUksY0FBYztnQkFDaEIsYUFBYSxRQUFRO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGOztBQ3ZKTyxJQUFNLFlBQVksQ0FBQztJQUN4QixNQUFNLFNBQVMsaUJBQWlCO0lBQ2hDLE1BQU0sU0FBUyxpQkFBaUIsTUFBTSxNQUFNO0lBQzVDLE9BQU87QUFDVDtBQUVBLElBQU0sbUJBQW1CLENBQUMsTUFBYztJQUN0QyxJQUFJLEVBQUUsU0FBUyxJQUFJO0lBQ25CLE1BQU0sRUFBRSxXQUFXLGFBQWEsSUFBSTtJQUNwQyxNQUFNLFlBQVksT0FBTztJQUN6QixJQUFJLGFBQWEsVUFBVSxJQUFJLEdBQUc7UUFDaEMsV0FBVyxVQUFVLElBQUksRUFBRTtJQUM3QjtJQUVBLE1BQU0sY0FBYztRQUFFLFVBQVU7UUFBTSxZQUFZLENBQUM7SUFBRTtJQUNyRCxPQUFPLGFBQWEsV0FBVyxVQUFVLGFBQWEsWUFBWTtBQUNwRTs7QUNWQSxJQUFPLGdCQUFRO0lBQUU7QUFBVSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvTG9nRm9ybWF0LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvTG9nTGV2ZWwudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9jb25maWcudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9Xcml0ZXIudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9mb3JtYXR0ZXIudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9GbG9vZENvbnRyb2wudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9Mb2dnZXIudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9sb2dnaW5nLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgTG9nRm9ybWF0TmFtZSA9IFwiVEVYVFwiIHwgXCJTVFJVQ1RVUkVEXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnIHtcbiAgICBuYW1lOiBMb2dGb3JtYXROYW1lO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBURVhUOiBDb25maWcgPSB7XG4gIG5hbWU6IFwiVEVYVFwiLFxuICBkZXNjcmlwdGlvbjogXCJUZXh0IGZvcm1hdFwiLFxufVxuXG5leHBvcnQgY29uc3QgU1RSVUNUVVJFRDogQ29uZmlnID0ge1xuICBuYW1lOiBcIlNUUlVDVFVSRURcIixcbiAgZGVzY3JpcHRpb246IFwiU3RydWN0dXJlZCBmb3JtYXRcIixcbn1cblxuZXhwb3J0IGNvbnN0IExvZ0Zvcm1hdHM6IENvbmZpZ1tdID0gW1xuICBURVhULFxuICBTVFJVQ1RVUkVELFxuXVxuXG5leHBvcnQgY29uc3QgZ2V0Q29uZmlnID0gKG5hbWU6IExvZ0Zvcm1hdE5hbWUpOiBDb25maWcgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dGb3JtYXRzLmZpbmQoY29uZmlnID0+IGNvbmZpZy5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG9nIEZvcm1hdCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn0iLCJleHBvcnQgdHlwZSBMb2dMZXZlbE5hbWUgPVxuICBcIkVNRVJHRU5DWVwiIHwgXCJBTEVSVFwiIHwgXCJDUklUSUNBTFwiIHwgXCJFUlJPUlwiIHwgXCJXQVJOSU5HXCIgfCBcIk5PVElDRVwiIHwgXCJJTkZPXCIgfCBcIkRFQlVHXCIgfCBcIlRSQUNFXCIgfCBcIkRFRkFVTFRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICBuYW1lOiBMb2dMZXZlbE5hbWU7XG4gIHZhbHVlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBFTUVSR0VOQ1k6IENvbmZpZyA9IHtcbiAgbmFtZTogXCJFTUVSR0VOQ1lcIixcbiAgdmFsdWU6IDAsXG59XG5leHBvcnQgY29uc3QgQUxFUlQ6IENvbmZpZyA9IHtcbiAgbmFtZTogXCJBTEVSVFwiLFxuICB2YWx1ZTogMSxcbn1cbmV4cG9ydCBjb25zdCBDUklUSUNBTDogQ29uZmlnID0ge1xuICBuYW1lOiBcIkNSSVRJQ0FMXCIsXG4gIHZhbHVlOiAyLFxufVxuZXhwb3J0IGNvbnN0IEVSUk9SOiBDb25maWcgPSB7XG4gIG5hbWU6IFwiRVJST1JcIixcbiAgdmFsdWU6IDMsXG59XG5leHBvcnQgY29uc3QgV0FSTklORzogQ29uZmlnID0ge1xuICBuYW1lOiBcIldBUk5JTkdcIixcbiAgdmFsdWU6IDQsXG59XG5leHBvcnQgY29uc3QgTk9USUNFOiBDb25maWcgPSB7XG4gIG5hbWU6IFwiTk9USUNFXCIsXG4gIHZhbHVlOiA1LFxufVxuZXhwb3J0IGNvbnN0IElORk86IENvbmZpZyA9IHtcbiAgbmFtZTogXCJJTkZPXCIsXG4gIHZhbHVlOiA2LFxufVxuZXhwb3J0IGNvbnN0IERFQlVHOiBDb25maWcgPSB7XG4gIG5hbWU6IFwiREVCVUdcIixcbiAgdmFsdWU6IDcsXG59XG5leHBvcnQgY29uc3QgVFJBQ0U6IENvbmZpZyA9IHtcbiAgbmFtZTogXCJUUkFDRVwiLFxuICB2YWx1ZTogOCxcbn1cbmV4cG9ydCBjb25zdCBERUZBVUxUOiBDb25maWcgPSB7XG4gIG5hbWU6IFwiREVGQVVMVFwiLFxuICB2YWx1ZTogOSxcbn1cblxuZXhwb3J0IGNvbnN0IExvZ0xldmVsczogQ29uZmlnW10gPSBbXG4gIEVNRVJHRU5DWSxcbiAgQUxFUlQsXG4gIENSSVRJQ0FMLFxuICBFUlJPUixcbiAgV0FSTklORyxcbiAgTk9USUNFLFxuICBJTkZPLFxuICBERUJVRyxcbiAgVFJBQ0UsXG4gIERFRkFVTFQsXG5dO1xuXG5leHBvcnQgY29uc3QgZ2V0Q29uZmlnID0gKG5hbWU6IExvZ0xldmVsTmFtZSk6IENvbmZpZyA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0xldmVscy5maW5kKGNvbmZpZyA9PiBjb25maWcubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBMZXZlbCBTdXBwbGllZCB0byBMb2dnaW5nIENvbmZpZ3VyYXRpb24gJyR7bmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn1cbiIsImltcG9ydCAqIGFzIExvZ0Zvcm1hdCBmcm9tIFwiLi9Mb2dGb3JtYXRcIjtcbmltcG9ydCAqIGFzIExvZ0xldmVsIGZyb20gXCIuL0xvZ0xldmVsXCI7XG5pbXBvcnQgeyBGbG9vZENvbnRyb2xDb25maWcgfSBmcm9tIFwiLi9GbG9vZENvbnRyb2xcIjtcblxuZXhwb3J0IHR5cGUgTG9nZ2luZ0NvbmZpZyA9IHtcbiAgbG9nRm9ybWF0OiBMb2dGb3JtYXQuQ29uZmlnO1xuICBsb2dMZXZlbDogTG9nTGV2ZWwuQ29uZmlnO1xuICBvdmVycmlkZXM6IFJlY29yZDxzdHJpbmcsIHsgbG9nTGV2ZWw6IExvZ0xldmVsLkNvbmZpZyB9PjtcbiAgZmxvb2RDb250cm9sOiBGbG9vZENvbnRyb2xDb25maWc7XG59O1xuXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWw6IExvZ0xldmVsLkNvbmZpZyA9IExvZ0xldmVsLklORk87XG5jb25zdCBkZWZhdWx0TG9nRm9ybWF0OiBMb2dGb3JtYXQuQ29uZmlnID0gTG9nRm9ybWF0LlRFWFQ7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0TG9nZ2luZ0NvbmZpZzogTG9nZ2luZ0NvbmZpZyA9IHtcbiAgbG9nTGV2ZWw6IGRlZmF1bHRMb2dMZXZlbCxcbiAgbG9nRm9ybWF0OiBkZWZhdWx0TG9nRm9ybWF0LFxuICBvdmVycmlkZXM6IHt9LFxuICBmbG9vZENvbnRyb2w6IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICAgIHRpbWVmcmFtZTogMTAwMCwgLy8gMSBzZWNvbmRcbiAgfVxufVxuXG4vLyBXaGVuIHdlIHJlYWQgdGhlIGNvbmZpZyBmcm9tIHRoZSBlbnZpcm9ubWVudCwgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBvdmVycmlkZXMgdG8gdGhlIGNvcnJlY3QgZm9ybWF0XG5leHBvcnQgY29uc3QgY29udmVydE92ZXJyaWRlcyA9IChvdmVycmlkZXM6IGFueSk6IFJlY29yZDxzdHJpbmcsIHsgbG9nTGV2ZWw6IExvZ0xldmVsLkNvbmZpZyB9PiA9PiB7XG4gIGNvbnN0IGNvbnZlcnRlZE92ZXJyaWRlczogUmVjb3JkPHN0cmluZywgeyBsb2dMZXZlbDogTG9nTGV2ZWwuQ29uZmlnIH0+ID0ge307XG4gIGlmIChvdmVycmlkZXMpIHtcbiAgICBPYmplY3QuZW50cmllcyhvdmVycmlkZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgY29udmVydGVkT3ZlcnJpZGVzW2tleV0gPSB7IGxvZ0xldmVsOiB2YWx1ZS5sb2dMZXZlbCA/IExvZ0xldmVsLmdldENvbmZpZyh2YWx1ZS5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3ZlcnJpZGVzO1xufVxuXG4vLyBXaGVuIHdlIHJlYWQgdGhlIGNvbmZpZyBmcm9tIHRoZSBlbnZpcm9ubWVudCwgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBjb25maWcgdG8gdGhlIGNvcnJlY3QgZm9ybWF0XG5leHBvcnQgY29uc3QgY29udmVydENvbmZpZyA9IChjb25maWc6IGFueSk6IExvZ2dpbmdDb25maWcgPT4ge1xuICByZXR1cm4ge1xuICAgIGxvZ0xldmVsOiBjb25maWcubG9nTGV2ZWwgPyBMb2dMZXZlbC5nZXRDb25maWcoY29uZmlnLmxvZ0xldmVsKSA6IGRlZmF1bHRMb2dMZXZlbCxcbiAgICBsb2dGb3JtYXQ6IGNvbmZpZy5sb2dGb3JtYXQgPyBMb2dGb3JtYXQuZ2V0Q29uZmlnKGNvbmZpZy5sb2dGb3JtYXQpIDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgICBvdmVycmlkZXM6IGNvbnZlcnRPdmVycmlkZXMoY29uZmlnLm92ZXJyaWRlcyksXG4gICAgZmxvb2RDb250cm9sOiB7XG4gICAgICAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZy5mbG9vZENvbnRyb2wsXG4gICAgICAuLi4oY29uZmlnLmZsb29kQ29udHJvbCB8fCB7fSlcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgY29uZmlndXJlTG9nZ2luZyA9ICgpOiBMb2dnaW5nQ29uZmlnID0+IHtcbiAgbGV0IGNvbmZpZzogYW55ID0ge307XG5cbiAgY29uc3QgbG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkxPR0dJTkdfQ09ORklHO1xuICBjb25zdCBleHBvTG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52LkVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBjb25zdCBuZXh0TG9nZ2luZ0NvbmZpZ0VudiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0xPR0dJTkdfQ09ORklHO1xuICBsZXQgbG9nTGV2ZWxFbnYgPSBwcm9jZXNzLmVudi5MT0dfTEVWRUw7XG4gIGxldCBsb2dGb3JtYXRFbnYgPSBwcm9jZXNzLmVudi5MT0dfRk9STUFUO1xuXG4gIGlmIChsb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UobG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgSlNPTiBpbiBMT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTonLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwb0xvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShleHBvTG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgSlNPTiBpbiBFWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTonLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV4dExvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShuZXh0TG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgSlNPTiBpbiBORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTonLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb252ZXJ0ZWRDb25maWc6IExvZ2dpbmdDb25maWcgPSBjb252ZXJ0Q29uZmlnKGNvbmZpZyk7XG5cbiAgaWYgKGxvZ0xldmVsRW52KSB7XG4gICAgbG9nTGV2ZWxFbnYgPSBsb2dMZXZlbEVudj8udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBsb2dMZXZlbENvbmZpZyA9IExvZ0xldmVsLmdldENvbmZpZyhsb2dMZXZlbEVudiBhcyBMb2dMZXZlbC5Mb2dMZXZlbE5hbWUpO1xuICAgIGNvbnZlcnRlZENvbmZpZy5sb2dMZXZlbCA9IGxvZ0xldmVsQ29uZmlnO1xuICB9XG5cbiAgaWYgKGxvZ0Zvcm1hdEVudikge1xuICAgIGxvZ0Zvcm1hdEVudiA9IGxvZ0Zvcm1hdEVudi50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGxvZ0Zvcm1hdENvbmZpZyA9IExvZ0Zvcm1hdC5nZXRDb25maWcobG9nRm9ybWF0RW52IGFzIExvZ0Zvcm1hdC5Mb2dGb3JtYXROYW1lKTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nRm9ybWF0ID0gbG9nRm9ybWF0Q29uZmlnO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgYW55dGhpbmcgbWlzc2luZyB3aXRoIGRlZmF1bHRzXG4gIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZywgLi4uY29udmVydGVkQ29uZmlnIH07XG5cbiAgcmV0dXJuIGZpbmFsQ29uZmlnO1xufVxuIiwiaW1wb3J0IHsgRm9ybWF0dGVyIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgKiBhcyBMb2dMZXZlbCBmcm9tIFwiLi9Mb2dMZXZlbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdyaXRlciB7XG4gIHdyaXRlOiAoXG4gICAgbGV2ZWw6IExvZ0xldmVsLkNvbmZpZyxcbiAgICBjb29yZGluYXRlczoge1xuICAgICAgY2F0ZWdvcnk6IHN0cmluZyxcbiAgICAgIGNvbXBvbmVudHM6IHN0cmluZ1tdXG4gICAgfSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgICBkYXRhOiBhbnlbXSxcbiAgICB9LFxuICApID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV3JpdGVyT3B0aW9ucyB7XG4gIHJlc3BlY3RJbmplY3RlZE1ldGhvZD86IGJvb2xlYW47XG4gIGVycm9yTWV0aG9kPzogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuICB3YXJuaW5nTWV0aG9kPzogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuICBpbmZvTWV0aG9kPzogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlV3JpdGVyID0gKFxuICBmb3JtYXR0ZXI6IEZvcm1hdHRlcixcbiAgbG9nTWV0aG9kOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQsXG4gIG9wdGlvbnM6IFdyaXRlck9wdGlvbnMgPSB7fVxuKTogV3JpdGVyID0+IHtcbiAgY29uc3Qge1xuICAgIHJlc3BlY3RJbmplY3RlZE1ldGhvZCA9IGZhbHNlLFxuICAgIGVycm9yTWV0aG9kID0gY29uc29sZS5lcnJvcixcbiAgICB3YXJuaW5nTWV0aG9kID0gY29uc29sZS53YXJuLFxuICAgIGluZm9NZXRob2QgPSBjb25zb2xlLmxvZ1xuICB9ID0gb3B0aW9ucztcblxuICByZXR1cm4ge1xuICAgIHdyaXRlOiAoXG4gICAgICBsZXZlbDogTG9nTGV2ZWwuQ29uZmlnLFxuICAgICAgY29vcmRpbmF0ZXM6IHsgY2F0ZWdvcnk6IHN0cmluZywgY29tcG9uZW50czogc3RyaW5nW10gfSxcbiAgICAgIHBheWxvYWQ6IHsgbWVzc2FnZTogc3RyaW5nLCBkYXRhOiBhbnlbXSB9LFxuICAgICkgPT4ge1xuICAgICAgbGV0IGZpbmFsTG9nTWV0aG9kID0gbG9nTWV0aG9kO1xuXG4gICAgICAvLyBJZiByZXNwZWN0SW5qZWN0ZWRNZXRob2QgaXMgdHJ1ZSwgdXNlIHRoZSBpbmplY3RlZCBtZXRob2QgZm9yIGFsbCBsZXZlbHNcbiAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxldmVsLXNwZWNpZmljIHJvdXRpbmcgKGJhY2t3YXJkIGNvbXBhdGlibGUgYmVoYXZpb3IpXG4gICAgICBpZiAoIXJlc3BlY3RJbmplY3RlZE1ldGhvZCkge1xuICAgICAgICBpZiAobGV2ZWwubmFtZSA9PT0gTG9nTGV2ZWwuRVJST1IubmFtZSB8fFxuICAgICAgICAgIGxldmVsLm5hbWUgPT09IExvZ0xldmVsLkNSSVRJQ0FMLm5hbWUgfHxcbiAgICAgICAgICBsZXZlbC5uYW1lID09PSBMb2dMZXZlbC5BTEVSVC5uYW1lIHx8XG4gICAgICAgICAgbGV2ZWwubmFtZSA9PT0gTG9nTGV2ZWwuRU1FUkdFTkNZLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGVycm9yTWV0aG9kO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsLm5hbWUgPT09IExvZ0xldmVsLldBUk5JTkcubmFtZSkge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gd2FybmluZ01ldGhvZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IGluZm9NZXRob2Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxMb2dNZXRob2QoZm9ybWF0dGVyLmZvcm1hdExvZyhsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpKTtcbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBMb2dGb3JtYXQgZnJvbSBcIi4vTG9nRm9ybWF0XCI7XG5pbXBvcnQgKiBhcyBMb2dMZXZlbCBmcm9tIFwiLi9Mb2dMZXZlbFwiO1xuXG4vLyBTYWZlIHdyYXBwZXIgYXJvdW5kIHV0aWwuaW5zcGVjdCB0aGF0IGhhbmRsZXMgYW55IHNlcmlhbGl6YXRpb24gZXJyb3JzXG5jb25zdCBzYWZlSW5zcGVjdCA9IChvYmo6IGFueSk6IHN0cmluZyA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChvYmopO1xuICB9IGNhdGNoIHtcbiAgICAvLyBJZiB1dGlsLmluc3BlY3QgZmFpbHMgKHdoaWNoIGlzIHZlcnkgcmFyZSksIGZhbGwgYmFjayB0byBhIHNhZmUgcmVwcmVzZW50YXRpb25cbiAgICByZXR1cm4gYFtPYmplY3Q6ICR7dHlwZW9mIG9ian1dYDtcbiAgfVxufTtcblxuLy8gU2FmZSB3cmFwcGVyIGFyb3VuZCB1dGlsLmZvcm1hdCB0aGF0IGhhbmRsZXMgYW55IGZvcm1hdCBlcnJvcnNcbmNvbnN0IHNhZmVGb3JtYXQgPSAobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSk6IHN0cmluZyA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuZm9ybWF0KG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIHtcbiAgICAvLyBJZiB1dGlsLmZvcm1hdCBmYWlscywgcmV0dXJuIHRoZSBtZXNzYWdlIHdpdGggYSBzYWZlIHJlcHJlc2VudGF0aW9uIG9mIGFyZ3NcbiAgICByZXR1cm4gYCR7bWVzc2FnZX0gJHtzYWZlSW5zcGVjdChhcmdzKX1gO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHRlciB7XG5cbiAgZ2V0TG9nRm9ybWF0OiAoKSA9PiBMb2dGb3JtYXQuQ29uZmlnO1xuXG4gIGZvcm1hdExvZzogKFxuICAgIGxldmVsOiBMb2dMZXZlbC5Db25maWcsXG4gICAgY29vcmRpbmF0ZXM6IHsgY2F0ZWdvcnk6IHN0cmluZywgY29tcG9uZW50czogc3RyaW5nW10gfSxcbiAgICBwYXlsb2FkOiB7IG1lc3NhZ2U6IHN0cmluZywgZGF0YTogYW55W10gfSxcbiAgKSA9PiBzdHJpbmc7XG5cbiAgdGltZXJNZXNzYWdlOiAoXG4gICAgbGV2ZWw6IExvZ0xldmVsLkNvbmZpZyxcbiAgICBjb29yZGluYXRlczogeyBjYXRlZ29yeTogc3RyaW5nLCBjb21wb25lbnRzOiBzdHJpbmdbXSB9LFxuICAgIHBheWxvYWQ6IHsgbWVzc2FnZTogc3RyaW5nLCBkYXRhOiBhbnlbXSB9LFxuICApID0+IHN0cmluZztcblxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlRm9ybWF0dGVyID0gKGxvZ0Zvcm1hdDogTG9nRm9ybWF0LkNvbmZpZyk6IEZvcm1hdHRlciA9PiB7XG4gIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJURVhUXCIpIHtcbiAgICByZXR1cm4gZ2V0VGV4dEZvcm1hdHRlcigpO1xuICB9IGVsc2UgaWYgKGxvZ0Zvcm1hdC5uYW1lID09PSBcIlNUUlVDVFVSRURcIikge1xuICAgIHJldHVybiBnZXRTdHJ1Y3R1cmVkRm9ybWF0dGVyKCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbG9nIGZvcm1hdDogJHtsb2dGb3JtYXQubmFtZX1gKTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldFRleHRGb3JtYXR0ZXIgPSAoKTogRm9ybWF0dGVyID0+IHtcblxuICBjb25zdCBmb3JtYXRMb2cgPSAoXG4gICAgbGV2ZWw6IExvZ0xldmVsLkNvbmZpZyxcbiAgICBjb29yZGluYXRlczogeyBjYXRlZ29yeTogc3RyaW5nLCBjb21wb25lbnRzOiBzdHJpbmdbXSB9LFxuICAgIHBheWxvYWQ6IHsgbWVzc2FnZTogc3RyaW5nLCBkYXRhOiBhbnlbXSB9LFxuICApID0+IHtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG5cbiAgICBsZXQgbG9nTWVzc2FnZTtcbiAgICBpZiAocGF5bG9hZC5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nTWVzc2FnZSA9IHBheWxvYWQubWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKGhhc1NwZWNpZmllcnMpIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nTWVzc2FnZSA9IGAke3BheWxvYWQubWVzc2FnZX0gJHtzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAoJHtuZXcgRGF0ZSgpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIGAgK1xuICAgICAgYFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSBgICtcbiAgICAgIGAke2xvZ01lc3NhZ2V9YDtcbiAgfVxuXG4gIGNvbnN0IHRpbWVyTWVzc2FnZSA9IChcbiAgICBsZXZlbDogTG9nTGV2ZWwuQ29uZmlnLFxuICAgIGNvb3JkaW5hdGVzOiB7IGNhdGVnb3J5OiBzdHJpbmcsIGNvbXBvbmVudHM6IHN0cmluZ1tdIH0sXG4gICAgcGF5bG9hZDogeyBtZXNzYWdlOiBzdHJpbmcsIGRhdGE6IGFueVtdIH0sXG4gICkgPT4ge1xuXG4gICAgY29uc3QgcmFuZG9tSW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlID1cbiAgICAgIGAoJHtuZXcgRGF0ZSgpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIGAgK1xuICAgICAgYFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSBgICtcbiAgICAgIGAke3NhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9ICR7cmFuZG9tSW50fWA7XG5cbiAgICByZXR1cm4gdGltZXJNZXNzYWdlO1xuICB9XG5cbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gTG9nRm9ybWF0LlRFWFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldFN0cnVjdHVyZWRGb3JtYXR0ZXIgPSAoKTogRm9ybWF0dGVyID0+IHtcblxuICBjb25zdCBmb3JtYXRMb2cgPSAoXG4gICAgbGV2ZWw6IExvZ0xldmVsLkNvbmZpZyxcbiAgICBjb29yZGluYXRlczogeyBjYXRlZ29yeTogc3RyaW5nLCBjb21wb25lbnRzOiBzdHJpbmdbXSB9LFxuICAgIHBheWxvYWQ6IHsgbWVzc2FnZTogc3RyaW5nLCBkYXRhOiBhbnlbXSB9LFxuICApID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogaGFzU3BlY2lmaWVycyA/IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpIDogcGF5bG9hZC5tZXNzYWdlLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gLFxuICAgICAgfSxcbiAgICAgIC4uLighaGFzU3BlY2lmaWVycyAmJiBwYXlsb2FkLmRhdGEubGVuZ3RoID4gMCAmJiB7IGRhdGE6IHNhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSkgfSksXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB0aW1lck1lc3NhZ2UgPSAoXG4gICAgbGV2ZWw6IExvZ0xldmVsLkNvbmZpZyxcbiAgICBjb29yZGluYXRlczogeyBjYXRlZ29yeTogc3RyaW5nLCBjb21wb25lbnRzOiBzdHJpbmdbXSB9LFxuICAgIHBheWxvYWQ6IHsgbWVzc2FnZTogc3RyaW5nLCBkYXRhOiBhbnlbXSB9LFxuICApID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG5cbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc2V2ZXJpdHksXG4gICAgICBtZXNzYWdlOiBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9sYWJlbHNcIjoge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IGAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9YCxcbiAgICAgIH0sXG4gICAgICBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL3NwYW5JZFwiOiBTdHJpbmcocmFuZG9tSW50KVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gTG9nRm9ybWF0LlNUUlVDVFVSRUQgfTtcbn1cbiIsImltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuXG5leHBvcnQgY29uc3QgaGFzaCA9IChtZXNzYWdlOiBzdHJpbmcsIGRhdGE6IGFueVtdKTogc3RyaW5nID0+IHtcbiAgY29uc3QgZGF0YVN0cmluZyA9IGRhdGEubWFwKGl0ZW0gPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBGYWxsYmFjayB0byB1dGlsLmluc3BlY3QgZm9yIG9iamVjdHMgd2l0aCBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICByZXR1cm4gdXRpbC5pbnNwZWN0KGl0ZW0pO1xuICAgIH1cbiAgfSkuam9pbignJyk7XG4gIHJldHVybiBgJHttZXNzYWdlfSR7ZGF0YVN0cmluZ31gO1xufVxuXG5leHBvcnQgdHlwZSBGbG9vZENvbnRyb2xDb25maWcgPSB7XG4gIGVuYWJsZWQ6IGJvb2xlYW47XG4gIHRocmVzaG9sZDogbnVtYmVyO1xuICB0aW1lZnJhbWU6IG51bWJlcjsgLy8gaW4gbWlsbGlzZWNvbmRzXG59O1xuXG5leHBvcnQgY2xhc3MgRmxvb2RDb250cm9sIHtcbiAgcHJpdmF0ZSBjb25maWc6IEZsb29kQ29udHJvbENvbmZpZztcbiAgcHJpdmF0ZSBoaXN0b3J5OiBNYXA8c3RyaW5nLCBudW1iZXJbXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgc3VwcHJlc3NlZDogTWFwPHN0cmluZywgeyBjb3VudDogbnVtYmVyLCBmaXJzdFRpbWVzdGFtcDogbnVtYmVyLCBzdW1tYXJ5TG9nZ2VkOiBib29sZWFuIH0+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGNsZWFudXBUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEZsb29kQ29udHJvbENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuY2xlYW51cCgpLCB0aGlzLmNvbmZpZy50aW1lZnJhbWUgKiAyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYW51cCgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2hhc2gsIHRpbWVzdGFtcHNdIG9mIHRoaXMuaGlzdG9yeS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHJlY2VudFRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmZpbHRlcihcbiAgICAgICAgKHRpbWVzdGFtcCkgPT4gbm93IC0gdGltZXN0YW1wIDwgdGhpcy5jb25maWcudGltZWZyYW1lXG4gICAgICApO1xuICAgICAgaWYgKHJlY2VudFRpbWVzdGFtcHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmhpc3Rvcnkuc2V0KGhhc2gsIHJlY2VudFRpbWVzdGFtcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LmRlbGV0ZShoYXNoKTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShoYXNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2hlY2sobWVzc2FnZTogc3RyaW5nLCBkYXRhOiBhbnlbXSk6ICdsb2cnIHwgJ3N1cHByZXNzJyB8ICdyZXN1bWUnIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiAnbG9nJztcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSAodGhpcy5oaXN0b3J5LmdldChtZXNzYWdlSGFzaCkgfHwgW10pLmZpbHRlcihcbiAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICk7XG4gICAgdGltZXN0YW1wcy5wdXNoKG5vdyk7XG4gICAgdGhpcy5oaXN0b3J5LnNldChtZXNzYWdlSGFzaCwgdGltZXN0YW1wcyk7XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPiB0aGlzLmNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgIGNvbnN0IHN1cHByZXNzZWRJbmZvID0gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk7XG4gICAgICBpZiAoc3VwcHJlc3NlZEluZm8pIHtcbiAgICAgICAgc3VwcHJlc3NlZEluZm8uY291bnQrKztcbiAgICAgICAgcmV0dXJuICdzdXBwcmVzcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1cHByZXNzZWQuc2V0KG1lc3NhZ2VIYXNoLCB7IGNvdW50OiAxLCBmaXJzdFRpbWVzdGFtcDogdGltZXN0YW1wc1swXSwgc3VtbWFyeUxvZ2dlZDogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiAnc3VwcHJlc3MnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zdXBwcmVzc2VkLmhhcyhtZXNzYWdlSGFzaCkpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShtZXNzYWdlSGFzaCk7XG4gICAgICAgIHJldHVybiAncmVzdW1lJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJ2xvZyc7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2U6IHN0cmluZywgZGF0YTogYW55W10pOiBudW1iZXIge1xuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk/LmNvdW50IHx8IDA7XG4gIH1cbn1cbiIsIi8vIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9uc1xuaW1wb3J0ICogYXMgTG9nTGV2ZWwgZnJvbSBcIi4vTG9nTGV2ZWxcIjtcbmltcG9ydCAqIGFzIExvZ0Zvcm1hdCBmcm9tIFwiLi9Mb2dGb3JtYXRcIjtcbmltcG9ydCB7IGNyZWF0ZVdyaXRlciwgV3JpdGVyT3B0aW9ucyB9IGZyb20gXCIuL1dyaXRlclwiO1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgeyBGbG9vZENvbnRyb2wsIEZsb29kQ29udHJvbENvbmZpZyB9IGZyb20gXCIuL0Zsb29kQ29udHJvbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVMb2dnZXIge1xuICBlbmQ6ICgpID0+IHZvaWQ7XG4gIGxvZzogKC4uLmRhdGE6IGFueVtdKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gIGVtZXJnZW5jeTogKG1lc3NhZ2U6IHN0cmluZywgLi4uZGF0YTogYW55W10pID0+IHZvaWQ7XG4gIGFsZXJ0OiAobWVzc2FnZTogc3RyaW5nLCAuLi5kYXRhOiBhbnlbXSkgPT4gdm9pZDtcbiAgY3JpdGljYWw6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB2b2lkO1xuICBlcnJvcjogKG1lc3NhZ2U6IHN0cmluZywgLi4uZGF0YTogYW55W10pID0+IHZvaWQ7XG4gIHdhcm5pbmc6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB2b2lkO1xuICBub3RpY2U6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB2b2lkO1xuICBpbmZvOiAobWVzc2FnZTogc3RyaW5nLCAuLi5kYXRhOiBhbnlbXSkgPT4gdm9pZDtcbiAgZGVidWc6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB2b2lkO1xuICB0cmFjZTogKG1lc3NhZ2U6IHN0cmluZywgLi4uZGF0YTogYW55W10pID0+IHZvaWQ7XG4gIGRlZmF1bHQ6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB2b2lkO1xuICB0aW1lOiAobWVzc2FnZTogc3RyaW5nLCAuLi5kYXRhOiBhbnlbXSkgPT4gVGltZUxvZ2dlcjtcbiAgZ2V0OiAoLi4uYWRkaXRpb25hbENvbXBvbmVudHM6IHN0cmluZ1tdKSA9PiBMb2dnZXI7XG4gIGRlc3Ryb3k6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVMb2dnZXIgPSAoXG4gIGxvZ0Zvcm1hdDogTG9nRm9ybWF0LkNvbmZpZyxcbiAgbG9nTGV2ZWw6IExvZ0xldmVsLkNvbmZpZyxcbiAgY29vcmRpbmF0ZXM6IHsgY2F0ZWdvcnk6IHN0cmluZywgY29tcG9uZW50czogc3RyaW5nW10gfSxcbiAgZmxvb2RDb250cm9sQ29uZmlnOiBGbG9vZENvbnRyb2xDb25maWcsXG4gIHdyaXRlck9wdGlvbnM/OiBXcml0ZXJPcHRpb25zLFxuKTogTG9nZ2VyID0+IHtcbiAgY29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGxvZ0Zvcm1hdCk7XG4gIGNvbnN0IGZsb29kQ29udHJvbCA9IGZsb29kQ29udHJvbENvbmZpZy5lbmFibGVkID8gbmV3IEZsb29kQ29udHJvbChmbG9vZENvbnRyb2xDb25maWcpIDogbnVsbDtcblxuICAvLyBUT0RPOiBPaywgdGhpcyBuZWVkcyB0byBiZSBhIGJpdCBtb3JlIGNvbmZpZ3VyYWJsZS5cbiAgY29uc3QgbG9nRnVuY3Rpb24gPSBjb25zb2xlLmxvZztcblxuICAvLyBUT0RPOiBUaGlzIGlzIHdoZXJlIHlvdSBjb3VsZCBjaGFuZ2UgdGhlIGRlc3RpbmF0aW9uLlxuICBjb25zdCB3cml0ZXIgPSBjcmVhdGVXcml0ZXIoZm9ybWF0dGVyLCBsb2dGdW5jdGlvbiwgd3JpdGVyT3B0aW9ucyk7XG5cbiAgY29uc3Qgd3JpdGUgPSAobGV2ZWw6IExvZ0xldmVsLkNvbmZpZywgbWVzc2FnZTogc3RyaW5nLCBkYXRhOiBhbnlbXSkgPT4ge1xuICAgIGlmIChsb2dMZXZlbC52YWx1ZSA8IGxldmVsLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2sgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuY2hlY2sobWVzc2FnZSwgZGF0YSkgOiAnbG9nJztcbiAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG5cbiAgICBzd2l0Y2ggKGNoZWNrKSB7XG4gICAgICBjYXNlICdsb2cnOlxuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdXBwcmVzcyc6XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHN1cHByZXNzLCB3ZSBjb3VsZCBsb2cgYSBtZXNzYWdlLlxuICAgICAgICAvLyBGb3Igbm93LCB3ZSBkbyBub3RoaW5nLiBUaGUgcmVxdWlyZW1lbnQgaXMgdG8ganVzdCBkaWFsLWRvd24uXG4gICAgICAgIGlmIChmbG9vZENvbnRyb2wgJiYgZmxvb2RDb250cm9sLmdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICBjb25zdCBuZXdQYXlsb2FkID0geyBtZXNzYWdlOiBgU3RhcnRlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZWAsIGRhdGE6IFtdIH07XG4gICAgICAgICAgd3JpdGVyLndyaXRlKG9yaWdpbmFsTGV2ZWwsIGNvb3JkaW5hdGVzLCBuZXdQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3VtZSc6IHtcbiAgICAgICAgY29uc3QgY291bnQgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIDogMDtcbiAgICAgICAgY29uc3QgcmVzdW1lUGF5bG9hZCA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBgU3RvcHBlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZS4gU3VwcHJlc3NlZCAke2NvdW50fSB0aW1lcy5gLFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHJlc3VtZVBheWxvYWQpO1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTsgLy8gbG9nIHRoZSBjdXJyZW50IG1lc3NhZ2VcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhcnRUaW1lTG9nZ2VyID0gKFxuICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5Db25maWcsXG4gICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgIGNhdGVnb3J5OiBzdHJpbmcsXG4gICAgICBjb21wb25lbnRzOiBzdHJpbmdbXVxuICAgIH0sXG4gICAgcGF5bG9hZDoge1xuICAgICAgbWVzc2FnZTogc3RyaW5nLFxuICAgICAgZGF0YTogYW55W10sXG4gICAgfVxuICApOiBUaW1lTG9nZ2VyID0+IHtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UgPSBmb3JtYXR0ZXIudGltZXJNZXNzYWdlKGxvZ0xldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKGBTdGFydGluZyBUaW1lciAke3RpbWVyTWVzc2FnZX1gKTtcbiAgICBsb2dMZXZlbC52YWx1ZSA+PSBMb2dMZXZlbC5ERUJVRy52YWx1ZSAmJlxuICAgICAgY29uc29sZS50aW1lKHRpbWVyTWVzc2FnZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgIGxvZ0xldmVsLnZhbHVlID49IExvZ0xldmVsLkRFQlVHLnZhbHVlICYmXG4gICAgICAgICAgY29uc29sZS50aW1lRW5kKHRpbWVyTWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgbG9nOiAoLi4uZGF0YTogYW55W10pID0+IHtcbiAgICAgICAgbG9nTGV2ZWwudmFsdWUgPj0gTG9nTGV2ZWwuREVCVUcudmFsdWUgJiZcbiAgICAgICAgICBjb25zb2xlLnRpbWVMb2codGltZXJNZXNzYWdlLCAuLi5kYXRhKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGVtZXJnZW5jeTogKG1lc3NhZ2U6IHN0cmluZywgLi4uZGF0YTogYW55W10pID0+IHtcbiAgICAgIHdyaXRlKExvZ0xldmVsLkVNRVJHRU5DWSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBhbGVydDogKG1lc3NhZ2U6IHN0cmluZywgLi4uZGF0YTogYW55W10pID0+IHtcbiAgICAgIHdyaXRlKExvZ0xldmVsLkFMRVJULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGNyaXRpY2FsOiAobWVzc2FnZTogc3RyaW5nLCAuLi5kYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgd3JpdGUoTG9nTGV2ZWwuQ1JJVElDQUwsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZXJyb3I6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB7XG4gICAgICB3cml0ZShMb2dMZXZlbC5FUlJPUiwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB3YXJuaW5nOiAobWVzc2FnZTogc3RyaW5nLCAuLi5kYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgd3JpdGUoTG9nTGV2ZWwuV0FSTklORywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBub3RpY2U6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB7XG4gICAgICB3cml0ZShMb2dMZXZlbC5OT1RJQ0UsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgaW5mbzogKG1lc3NhZ2U6IHN0cmluZywgLi4uZGF0YTogYW55W10pID0+IHtcbiAgICAgIHdyaXRlKExvZ0xldmVsLklORk8sIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB7XG4gICAgICB3cml0ZShMb2dMZXZlbC5ERUJVRywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0cmFjZTogKG1lc3NhZ2U6IHN0cmluZywgLi4uZGF0YTogYW55W10pID0+IHtcbiAgICAgIHdyaXRlKExvZ0xldmVsLlRSQUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlZmF1bHQ6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB7XG4gICAgICB3cml0ZShMb2dMZXZlbC5ERUZBVUxULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHRpbWU6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmRhdGE6IGFueVtdKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG4gICAgICByZXR1cm4gc3RhcnRUaW1lTG9nZ2VyKGxvZ0xldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgfSxcbiAgICBnZXQ6ICguLi5hZGRpdGlvbmFsQ29tcG9uZW50czogc3RyaW5nW10pID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IFsuLi5jb29yZGluYXRlcy5jb21wb25lbnRzLCAuLi5hZGRpdGlvbmFsQ29tcG9uZW50c10sXG4gICAgICB9LCBmbG9vZENvbnRyb2xDb25maWcsIHdyaXRlck9wdGlvbnMpO1xuICAgIH0sXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgaWYgKGZsb29kQ29udHJvbCkge1xuICAgICAgICBmbG9vZENvbnRyb2wuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IGNvbmZpZ3VyZUxvZ2dpbmcsIExvZ2dpbmdDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciwgTG9nZ2VyIH0gZnJvbSBcIi4vTG9nZ2VyXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRMb2dnZXIgPSAobmFtZTogc3RyaW5nKTogTG9nZ2VyID0+IHtcbiAgY29uc3QgY29uZmlnID0gY29uZmlndXJlTG9nZ2luZygpO1xuICBjb25zdCBsb2dnZXIgPSBjcmVhdGVCYXNlTG9nZ2VyKG5hbWUsIGNvbmZpZyk7XG4gIHJldHVybiBsb2dnZXI7XG59XG5cbmNvbnN0IGNyZWF0ZUJhc2VMb2dnZXIgPSAobmFtZTogc3RyaW5nLCBjb25maWc6IExvZ2dpbmdDb25maWcpOiBMb2dnZXIgPT4ge1xuICBsZXQgeyBsb2dMZXZlbCB9ID0gY29uZmlnO1xuICBjb25zdCB7IGxvZ0Zvcm1hdCwgZmxvb2RDb250cm9sIH0gPSBjb25maWc7XG4gIGNvbnN0IG92ZXJyaWRlcyA9IGNvbmZpZy5vdmVycmlkZXM7XG4gIGlmIChvdmVycmlkZXMgJiYgb3ZlcnJpZGVzW25hbWVdKSB7XG4gICAgbG9nTGV2ZWwgPSBvdmVycmlkZXNbbmFtZV0ubG9nTGV2ZWw7XG4gIH1cblxuICBjb25zdCBjb29yZGluYXRlcyA9IHsgY2F0ZWdvcnk6IG5hbWUsIGNvbXBvbmVudHM6IFtdIH07XG4gIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbCk7XG59O1xuIiwiaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSBcIi4vbG9nZ2luZ1wiO1xuXG5leHBvcnQgeyBnZXRMb2dnZXIgfTtcbmV4cG9ydCB0eXBlIHsgTG9nZ2VyLCBUaW1lTG9nZ2VyIH0gZnJvbSBcIi4vTG9nZ2VyXCI7XG5leHBvcnQgdHlwZSB7IExvZ2dpbmdDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcbmV4cG9ydCB0eXBlIHsgRmxvb2RDb250cm9sQ29uZmlnIH0gZnJvbSBcIi4vRmxvb2RDb250cm9sXCI7XG5leHBvcnQgKiBhcyBMb2dMZXZlbCBmcm9tIFwiLi9Mb2dMZXZlbFwiO1xuZXhwb3J0ICogYXMgTG9nRm9ybWF0IGZyb20gXCIuL0xvZ0Zvcm1hdFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7IGdldExvZ2dlciB9O1xuIl0sIm5hbWVzIjpbImNvbmZpZyIsImdldENvbmZpZyIsInRpbWVyTWVzc2FnZSIsInV0aWwiLCJoYXNoIiwibG9nTGV2ZWwiLCJjb29yZGluYXRlcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-logging/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-registry/dist/index.js":
/*!***************************************!*\
  !*** ../fjell-registry/dist/index.js ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = function(kta) {\n    let scopes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    const ktArray = Array.isArray(kta) ? kta : [\n        kta\n    ];\n    const toString = ()=>{\n        logger.debug(\"toString\", {\n            kta,\n            scopes\n        });\n        return \"\".concat(ktArray.join(\", \"), \" - \").concat(scopes.join(\", \"));\n    };\n    logger.debug(\"createCoordinate\", {\n        kta: ktArray,\n        scopes,\n        toString\n    });\n    return {\n        kta: ktArray,\n        scopes,\n        toString\n    };\n};\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate)=>{\n    logger2.debug(\"createInstance\", {\n        coordinate,\n        registry\n    });\n    return {\n        coordinate,\n        registry\n    };\n};\nvar isInstance = (instance)=>{\n    return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n// src/RegistryStats.ts\nvar RegistryStats = class {\n    /**\n   * Records a get() call for the specified coordinate and client\n   */ recordGetCall(kta, scopes, client) {\n        this.totalCalls++;\n        const ktaKey = kta.join(\".\");\n        const scopeKey = this.createScopeKey(scopes || []);\n        const clientKey = this.createClientKey(client);\n        if (!this.coordinateCalls.has(ktaKey)) {\n            this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n        }\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap.has(scopeKey)) {\n            scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n        }\n        const clientMap = scopeMap.get(scopeKey);\n        const currentCount = clientMap.get(clientKey) || 0;\n        clientMap.set(clientKey, currentCount + 1);\n    }\n    /**\n   * Gets the current statistics snapshot\n   */ getStatistics() {\n        const coordinateCallRecords = [];\n        let serviceCalls = 0;\n        let applicationCalls = 0;\n        let unidentifiedCalls = 0;\n        for (const [ktaKey, scopeMap] of this.coordinateCalls){\n            for (const [scopeKey, clientMap] of scopeMap){\n                const clientCalls = [];\n                let totalCount = 0;\n                for (const [clientKey, count] of clientMap){\n                    const client = this.parseClientKey(clientKey);\n                    if (client !== null) {\n                        clientCalls.push({\n                            client,\n                            count\n                        });\n                    }\n                    totalCount += count;\n                    if (clientKey === \"__no_client__\") {\n                        unidentifiedCalls += count;\n                    } else if (typeof client === \"string\") {\n                        applicationCalls += count;\n                    } else if (client !== null) {\n                        serviceCalls += count;\n                    }\n                }\n                coordinateCallRecords.push({\n                    kta: ktaKey.split(\".\"),\n                    scopes: this.parseScopeKey(scopeKey),\n                    count: totalCount,\n                    clientCalls: [\n                        ...clientCalls\n                    ]\n                });\n            }\n        }\n        return {\n            totalGetCalls: this.totalCalls,\n            coordinateCallRecords: [\n                ...coordinateCallRecords\n            ],\n            // Return a copy\n            clientSummary: {\n                serviceCalls,\n                applicationCalls,\n                unidentifiedCalls\n            }\n        };\n    }\n    /**\n   * Gets call count for a specific coordinate combination\n   */ getCallCount(kta, scopes) {\n        const ktaKey = kta.join(\".\");\n        const scopeKey = this.createScopeKey(scopes || []);\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap) return 0;\n        const clientMap = scopeMap.get(scopeKey);\n        if (!clientMap) return 0;\n        let total = 0;\n        for (const count of clientMap.values()){\n            total += count;\n        }\n        return total;\n    }\n    /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */ getCallCountByClient(kta, scopes, client) {\n        const ktaKey = kta.join(\".\");\n        const scopeKey = this.createScopeKey(scopes || []);\n        const clientKey = this.createClientKey(client);\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap) return 0;\n        const clientMap = scopeMap.get(scopeKey);\n        if (!clientMap) return 0;\n        return clientMap.get(clientKey) || 0;\n    }\n    /**\n   * Gets total calls for a specific kta (across all scopes)\n   */ getTotalCallsForKta(kta) {\n        const ktaKey = kta.join(\".\");\n        const scopeMap = this.coordinateCalls.get(ktaKey);\n        if (!scopeMap) return 0;\n        let total = 0;\n        for (const clientMap of scopeMap.values()){\n            for (const count of clientMap.values()){\n                total += count;\n            }\n        }\n        return total;\n    }\n    /**\n   * Gets all unique kta paths that have been called\n   */ getCalledKtaPaths() {\n        const ktaPaths = [];\n        for (const ktaKey of this.coordinateCalls.keys()){\n            ktaPaths.push(ktaKey.split(\".\"));\n        }\n        return ktaPaths;\n    }\n    /**\n   * Creates a normalized scope key from scopes array\n   */ createScopeKey(scopes) {\n        if (scopes.length === 0) return \"__no_scopes__\";\n        return [\n            ...scopes\n        ].sort().join(\",\");\n    }\n    /**\n   * Parses a scope key back to scopes array\n   */ parseScopeKey(scopeKey) {\n        if (scopeKey === \"__no_scopes__\") return [];\n        return scopeKey.split(\",\");\n    }\n    /**\n   * Creates a normalized client key from client identifier\n   */ createClientKey(client) {\n        if (!client) return \"__no_client__\";\n        if (typeof client === \"string\") {\n            return \"app:\".concat(client);\n        }\n        const coordKey = \"\".concat(client.coordinate.kta.join(\".\"), \";\").concat(this.createScopeKey(client.coordinate.scopes));\n        return \"service:\".concat(client.registryType, \":\").concat(coordKey);\n    }\n    /**\n   * Parses a client key back to client identifier\n   */ parseClientKey(clientKey) {\n        if (clientKey === \"__no_client__\") return null;\n        if (clientKey.startsWith(\"app:\")) {\n            return clientKey.substring(4);\n        }\n        if (clientKey.startsWith(\"service:\")) {\n            const parts = clientKey.substring(8).split(\":\");\n            if (parts.length !== 2) return null;\n            const registryType = parts[0];\n            const coordParts = parts[1].split(\";\");\n            if (coordParts.length !== 2) return null;\n            const kta = coordParts[0].split(\".\");\n            const scopes = this.parseScopeKey(coordParts[1]);\n            return {\n                registryType,\n                coordinate: {\n                    kta,\n                    scopes\n                }\n            };\n        }\n        return null;\n    }\n    constructor(){\n        this.totalCalls = 0;\n        // Map structure: ktaKey -> scopeKey -> clientKey -> count\n        this.coordinateCalls = /* @__PURE__ */ new Map();\n    }\n};\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes)=>{\n    if (!requestedScopes || requestedScopes.length === 0) {\n        var _scopedInstances_;\n        const firstInstance = (_scopedInstances_ = scopedInstances[0]) === null || _scopedInstances_ === void 0 ? void 0 : _scopedInstances_.instance;\n        if (!firstInstance) {\n            throw new Error(\"No instances available\");\n        }\n        return firstInstance;\n    }\n    const matchingInstance = scopedInstances.find((scopedInstance)=>{\n        if (!scopedInstance.scopes) return false;\n        return requestedScopes.every((scope)=>scopedInstance.scopes && scopedInstance.scopes.includes(scope));\n    });\n    if (!matchingInstance) {\n        throw new Error(\"No instance found matching scopes: \".concat(requestedScopes.join(\", \")));\n    }\n    return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub)=>{\n    const instanceTree = {};\n    const registryStats = new RegistryStats();\n    const createProxiedRegistry = (callingCoordinate)=>{\n        const serviceClient = {\n            registryType: type,\n            coordinate: {\n                kta: callingCoordinate.kta,\n                scopes: callingCoordinate.scopes\n            }\n        };\n        return {\n            ...registry,\n            get: (kta, options)=>{\n                const clientToUse = (options === null || options === void 0 ? void 0 : options.client) || serviceClient;\n                return registry.get(kta, {\n                    ...options,\n                    client: clientToUse\n                });\n            }\n        };\n    };\n    const createInstance2 = (kta, scopes, factory)=>{\n        logger3.debug(\"Creating and registering instance for key path and scopes\", kta, scopes, \"in registry type: \".concat(type));\n        const coordinate = createCoordinate(kta, scopes);\n        const proxiedRegistry = createProxiedRegistry(coordinate);\n        const instance = factory(coordinate, {\n            registry: proxiedRegistry,\n            registryHub\n        });\n        if (!isInstance(instance)) {\n            throw new Error(\"Factory did not return a valid instance for: \".concat(kta.join(\".\")));\n        }\n        registerInternal(kta, instance, {\n            scopes\n        });\n        return instance;\n    };\n    const registerInternal = (kta, instance, options)=>{\n        const keyPath = [\n            ...kta\n        ].reverse();\n        let currentLevel = instanceTree;\n        logger3.debug(\"Registering instance for key path and scopes\", keyPath, options === null || options === void 0 ? void 0 : options.scopes, \"in registry type: \".concat(type));\n        if (!isInstance(instance)) {\n            throw new Error(\"Attempting to register a non-instance: \".concat(kta.join(\".\")));\n        }\n        for(let i = 0; i < keyPath.length; i++){\n            const keyType = keyPath[i];\n            const isLeaf = i === keyPath.length - 1;\n            if (!currentLevel[keyType]) {\n                currentLevel[keyType] = {\n                    instances: [],\n                    children: isLeaf ? null : {}\n                };\n            }\n            if (isLeaf) {\n                currentLevel[keyType].instances.push({\n                    scopes: options === null || options === void 0 ? void 0 : options.scopes,\n                    instance\n                });\n            } else {\n                if (!currentLevel[keyType].children) {\n                    currentLevel[keyType].children = {};\n                }\n                currentLevel = currentLevel[keyType].children;\n            }\n        }\n    };\n    const register = (kta, instance, options)=>{\n        logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n        registerInternal(kta, instance, options);\n    };\n    const get = (kta, options)=>{\n        registryStats.recordGetCall(kta, options === null || options === void 0 ? void 0 : options.scopes, options === null || options === void 0 ? void 0 : options.client);\n        const keyPath = [\n            ...kta\n        ].reverse();\n        let currentLevel = instanceTree;\n        for(let i = 0; i < keyPath.length; i++){\n            const keyType = keyPath[i];\n            const isLeaf = i === keyPath.length - 1;\n            if (!currentLevel[keyType]) {\n                throw new Error(\"Instance not found for key path: \".concat(kta.join(\".\"), \", Missing key: \").concat(keyType));\n            }\n            if (isLeaf) {\n                const scopedInstances = currentLevel[keyType].instances;\n                if (scopedInstances.length === 0) {\n                    throw new Error(\"No instances registered for key path: \".concat(kta.join(\".\")));\n                }\n                return findScopedInstance(scopedInstances, options === null || options === void 0 ? void 0 : options.scopes);\n            } else {\n                if (!currentLevel[keyType].children) {\n                    throw new Error(\"Instance not found for key path: \".concat(kta.join(\".\"), \", No children for: \").concat(keyType));\n                }\n                currentLevel = currentLevel[keyType].children;\n            }\n        }\n        return null;\n    };\n    const getCoordinates = ()=>{\n        const coordinates = [];\n        const traverseTree = (node)=>{\n            for(const keyType in node){\n                const treeNode = node[keyType];\n                for (const scopedInstance of treeNode.instances){\n                    coordinates.push(scopedInstance.instance.coordinate);\n                }\n                if (treeNode.children) {\n                    traverseTree(treeNode.children);\n                }\n            }\n        };\n        traverseTree(instanceTree);\n        return coordinates;\n    };\n    const getStatistics = ()=>{\n        return registryStats.getStatistics();\n    };\n    const registry = {\n        type,\n        registryHub,\n        createInstance: createInstance2,\n        register,\n        get,\n        getCoordinates,\n        getStatistics,\n        instanceTree\n    };\n    return registry;\n};\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n    getDetails() {\n        const details = [\n            this.message\n        ];\n        if (this.registryType) {\n            details.push(\"Registry Type: \".concat(this.registryType));\n        }\n        if (this.context) {\n            details.push(\"Context: \".concat(JSON.stringify(this.context, null, 2)));\n        }\n        return details.join(\"\\n\");\n    }\n    constructor(message, registryType, context){\n        super(message);\n        this.name = this.constructor.name;\n        this.registryType = registryType;\n        this.context = context;\n        const ErrorConstructor = Error;\n        if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n            ErrorConstructor.captureStackTrace(this, this.constructor);\n        }\n    }\n};\nvar RegistryCreationError = class extends RegistryError {\n    constructor(type, reason, context){\n        super(\"Failed to create registry of type '\".concat(type, \"': \").concat(reason), type, context);\n    }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n    constructor(keyPath, factoryResult, registryType){\n        const keyPathStr = keyPath.join(\".\");\n        super(\"Factory did not return a valid instance for: \".concat(keyPathStr, \". Expected instance with 'coordinate' and 'registry' properties, got: \").concat(typeof factoryResult), registryType, {\n            keyPath,\n            factoryResult: typeof factoryResult\n        });\n        this.keyPath = keyPath;\n        this.factoryResult = factoryResult;\n    }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n    constructor(keyPath, attemptedRegistration, registryType){\n        const keyPathStr = keyPath.join(\".\");\n        super(\"Attempting to register a non-instance: \".concat(keyPathStr, \". Expected instance with 'coordinate' and 'registry' properties, got: \").concat(typeof attemptedRegistration), registryType, {\n            keyPath,\n            attemptedRegistration: typeof attemptedRegistration\n        });\n        this.keyPath = keyPath;\n        this.attemptedRegistration = attemptedRegistration;\n    }\n};\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n    constructor(message, hubType, context){\n        const enrichedContext = hubType ? {\n            ...context,\n            hubType\n        } : context;\n        super(message, \"\", enrichedContext);\n        this.hubType = hubType;\n    }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n    constructor(type, context){\n        super(\"Registry already registered under type: \".concat(type, \". Each registry type must be unique within a registry hub.\"), \"\", {\n            ...context,\n            duplicateType: type\n        });\n        this.duplicateType = type;\n    }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n    constructor(requestedType, availableTypes = [], context){\n        let message = \"No registry registered under type: \".concat(requestedType);\n        if (availableTypes.length > 0) {\n            message += \". Available types: [\".concat(availableTypes.join(\", \"), \"]\");\n        }\n        super(message, \"\", {\n            ...context,\n            requestedType,\n            availableTypes\n        });\n        this.requestedType = requestedType;\n        this.availableTypes = availableTypes;\n    }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n    constructor(type, factoryError, context){\n        super(\"Registry factory failed to create registry of type '\".concat(type, \"': \").concat(factoryError.message), \"\", {\n            ...context,\n            attemptedType: type,\n            originalError: factoryError.message\n        });\n        this.factoryError = factoryError;\n        this.attemptedType = type;\n    }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n    constructor(type, factoryResult, context){\n        super(\"Registry factory returned invalid registry for type '\".concat(type, \"'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: \").concat(typeof factoryResult), \"\", {\n            ...context,\n            attemptedType: type,\n            factoryResult: typeof factoryResult\n        });\n        this.factoryResult = factoryResult;\n        this.attemptedType = type;\n    }\n};\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = ()=>{\n    const registries = {};\n    const createRegistry2 = (type, factory)=>{\n        logger4.debug(\"Creating new registry with type: \".concat(type));\n        if (registries[type]) {\n            throw new DuplicateRegistryTypeError(type);\n        }\n        const registry = factory(type, hub);\n        if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n            registry.registryHub = hub;\n        }\n        registries[type] = registry;\n        logger4.debug(\"Successfully created and registered new registry with type: \".concat(type));\n        return registry;\n    };\n    const registerRegistry = (registry)=>{\n        const type = registry.type;\n        logger4.debug(\"Registering registry with type: \".concat(type));\n        if (registries[type]) {\n            throw new DuplicateRegistryTypeError(type);\n        }\n        registries[type] = registry;\n        if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n            registry.registryHub = hub;\n        }\n        logger4.debug(\"Successfully registered registry with type: \".concat(type));\n    };\n    const get = (type, kta, options)=>{\n        var _options_scopes;\n        logger4.debug(\"Looking up instance for type: \".concat(type, \", kta: \").concat(kta.join(\".\"), \", scopes: \").concat((options === null || options === void 0 ? void 0 : (_options_scopes = options.scopes) === null || _options_scopes === void 0 ? void 0 : _options_scopes.join(\",\")) || \"none\"));\n        const registry = registries[type];\n        if (!registry) {\n            const availableTypes = Object.keys(registries);\n            throw new RegistryTypeNotFoundError(type, availableTypes);\n        }\n        return registry.get(kta, options);\n    };\n    const getRegistry = (type)=>{\n        return registries[type] || null;\n    };\n    const getRegisteredTypes = ()=>{\n        return Object.keys(registries);\n    };\n    const unregisterRegistry = (type)=>{\n        if (registries[type]) {\n            delete registries[type];\n            logger4.debug(\"Unregistered registry under type: \".concat(type));\n            return true;\n        }\n        return false;\n    };\n    const getAllCoordinates = ()=>{\n        const allCoordinates = [];\n        for(const registryType in registries){\n            const registry = registries[registryType];\n            const coordinates = registry.getCoordinates();\n            coordinates.forEach((coordinate)=>{\n                allCoordinates.push({\n                    coordinate,\n                    registryType\n                });\n            });\n        }\n        logger4.debug(\"Retrieved \".concat(allCoordinates.length, \" total coordinates from \").concat(Object.keys(registries).length, \" registries\"));\n        return allCoordinates;\n    };\n    const hub = {\n        createRegistry: createRegistry2,\n        registerRegistry,\n        get,\n        getRegistry,\n        getRegisteredTypes,\n        getAllCoordinates,\n        unregisterRegistry\n    };\n    return hub;\n};\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n    constructor(message, keyPath, registryType, context){\n        super(message, registryType, {\n            ...context,\n            keyPath\n        });\n        this.keyPath = keyPath;\n    }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n    constructor(keyPath, missingKey, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        let message = \"Instance not found for key path: \".concat(keyPathStr);\n        if (missingKey) {\n            message += \", Missing key: \".concat(missingKey);\n        }\n        super(message, keyPath, registryType, {\n            ...context,\n            missingKey\n        });\n        this.missingKey = missingKey;\n    }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n    constructor(keyPath, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        super(\"No instances registered for key path: \".concat(keyPathStr, \". The key path exists in the registry tree but contains no instances.\"), keyPath, registryType, context);\n    }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n    constructor(keyPath, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        super(\"No instances available for key path: \".concat(keyPathStr, \". This typically indicates an internal registry state issue.\"), keyPath, registryType, context);\n    }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n    constructor(keyPath, requestedScopes, availableScopes = [], registryType){\n        const keyPathStr = keyPath.join(\".\");\n        const scopesStr = requestedScopes.join(\", \");\n        const availableScopesStr = availableScopes.map((scopes)=>\"[\".concat(scopes.join(\", \"), \"]\")).join(\", \");\n        let message = \"No instance found matching scopes: \".concat(scopesStr, \" for key path: \").concat(keyPathStr);\n        if (availableScopes.length > 0) {\n            message += \". Available scopes: \".concat(availableScopesStr);\n        }\n        super(message, keyPath, registryType, {\n            requestedScopes,\n            availableScopes\n        });\n        this.requestedScopes = requestedScopes;\n        this.availableScopes = availableScopes;\n    }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n    constructor(keyPath, parentKey, registryType, context){\n        const keyPathStr = keyPath.join(\".\");\n        super(\"Instance not found for key path: \".concat(keyPathStr, \", No children for: \").concat(parentKey, \". The path cannot be traversed further as '\").concat(parentKey, \"' has no child nodes.\"), keyPath, registryType, {\n            ...context,\n            parentKey\n        });\n        this.parentKey = parentKey;\n    }\n};\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n    constructor(message, kta, scopes, context){\n        super(message, \"\", {\n            ...context,\n            kta,\n            scopes\n        });\n        this.kta = kta;\n        this.scopes = scopes;\n    }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n    constructor(kta, scopes, reason, context){\n        super(\"Invalid coordinate parameters: \".concat(reason, \". KTA: \").concat(JSON.stringify(kta), \", Scopes: [\").concat(scopes.join(\", \"), \"]\"), kta, scopes, {\n            ...context,\n            reason\n        });\n    }\n};\nvar InvalidKTAError = class extends CoordinateError {\n    constructor(kta, reason, context){\n        super(\"Invalid KTA (Key Type Array): \".concat(reason, \". Expected string or array of strings, got: \").concat(JSON.stringify(kta)), kta, [], {\n            ...context,\n            reason\n        });\n    }\n};\nvar InvalidScopesError = class extends CoordinateError {\n    constructor(scopes, invalidScopes, reason, context){\n        super(\"Invalid scopes: \".concat(reason, \". Invalid scope values: \").concat(JSON.stringify(invalidScopes)), null, scopes.filter((s)=>typeof s === \"string\"), {\n            ...context,\n            reason,\n            invalidScopes\n        });\n        this.invalidScopes = invalidScopes;\n    }\n};\n //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1yZWdpc3RyeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQjtBQUVwQixJQUFNLFlBQVksZ0VBQVEsQ0FBVSxpQkFBaUI7QUFFckQsSUFBTyxpQkFBUTs7QUNBZixJQUFNLFNBQVMsZUFBVSxJQUFJLFlBQVk7QUFlbEMsSUFBTSxtQkFBbUIsU0FPOUI7UUFBK0MsMEVBQW1CLENBQUM7SUFDbkUsTUFBTSxVQUFVLE1BQU0sUUFBUSxHQUFHLElBQUksTUFBTTtRQUFDLEdBQUc7S0FBQTtJQUMvQyxNQUFNLFdBQVc7UUFDZixPQUFPLE1BQU0sWUFBWTtZQUFFO1lBQUs7UUFBTyxDQUFDO1FBQ3hDLE9BQU8sR0FBMkIsT0FBeEIsUUFBUSxLQUFLLElBQUksQ0FBQyxTQUF1QixjQUFWLEtBQUssSUFBSSxDQUFDO0lBQ3JEO0lBQ0EsT0FBTyxNQUFNLG9CQUFvQjtRQUFFLEtBQUs7UUFBUztRQUFRO0lBQVMsQ0FBQztJQUNuRSxPQUFPO1FBQUUsS0FBSztRQUFpRDtRQUFRO0lBQVM7QUFDbEY7O0FDNUJBLElBQU1BLFVBQVMsZUFBVSxJQUFJLFVBQVU7QUFnQ2hDLElBQU0saUJBQWlCLENBUTVCLFVBQ0E7SUFFQUEsUUFBTyxNQUFNLGtCQUFrQjtRQUFFO1FBQVk7SUFBUyxDQUFDO0lBQ3ZELE9BQU87UUFBRTtRQUFZO0lBQVM7QUFDaEM7QUFFTyxJQUFNLGFBQWEsQ0FBQztJQUN6QixPQUFPLGFBQWEsUUFDbEIsYUFBYSxVQUNiLFNBQVMsZUFBZSxVQUN4QixTQUFTLGFBQWE7QUFDMUI7O0FDUU8sSUFBTSxnQkFBTixNQUFvQjtJQUdtRDs7R0FBQSxHQUs1RSxjQU9FLEtBQStDLFFBQW1CLFFBQWlDO1FBQ25HLEtBQUs7UUFFTCxNQUFNLFNBQVMsSUFBSSxLQUFLLEdBQUc7UUFDM0IsTUFBTSxXQUFXLEtBQUssZUFBZSxVQUFVLENBQUMsQ0FBQztRQUNq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U0FBUyxpREFDeEIsT0FBVCxTQUFTLDRCQUNyRCxTQUNBLGNBQ0E7WUFBRSxHQUFHO1lBQVM7UUFBVTtRQUUxQixLQUFLLFlBQVk7SUFDbkI7QUFDRjs7QUN6R08sSUFBZSxrQkFBZixjQUF1QyxjQUFjO0lBSTFELFlBQVksU0FBaUIsS0FBVyxRQUFtQixRQUErQjtRQUN4RixNQUFNLFNBQVMsSUFBSTtZQUFFLEdBQUc7WUFBUztZQUFLO1FBQU8sQ0FBQztRQUM5QyxLQUFLLE1BQU07UUFDWCxLQUFLLFNBQVM7SUFDaEI7QUFDRjtBQUtPLElBQU0seUJBQU4sY0FBcUMsZ0JBQWdCO0lBQzFELFlBQVksS0FBVSxRQUFrQixRQUFnQixRQUErQjtRQUNyRixNQUNFLHlDQUFrQyxNQUFNLGFBQ0MsT0FBakMsS0FBSyxVQUFVLEdBQUcsQ0FBQyxpQkFBK0IsY0FBVixLQUFLLElBQUksQ0FBQyxRQUMxRCxLQUNBLFFBQ0E7WUFBRSxHQUFHO1lBQVM7UUFBTztJQUV6QjtBQUNGO0FBS08sSUFBTSxrQkFBTixjQUE4QixnQkFBZ0I7SUFDbkQsWUFBWSxLQUFVLFFBQWdCLFFBQStCO1FBQ25FLE1BQ0Usd0NBQWlDLE1BQU0sa0RBQ3lCLE9BQW5CLEtBQUssVUFBVSxHQUFHLENBQUMsR0FDaEUsS0FDQSxDQUFDLEdBQ0Q7WUFBRSxHQUFHO1lBQVM7UUFBTztJQUV6QjtBQUNGO0FBS08sSUFBTSxxQkFBTixjQUFpQyxnQkFBZ0I7SUFHdEQsWUFBWSxRQUFlLGVBQXNCLFFBQWdCLFFBQStCO1FBQzlGLE1BQ0UsMEJBQW1CLE1BQU0sOEJBQzZCLE9BQTdCLEtBQUssVUFBVSxhQUFhLENBQUMsR0FDdEQsTUFDQSxPQUFPLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxHQUN4QztZQUFFLEdBQUc7WUFBUztZQUFRO1FBQWM7UUFFdEMsS0FBSyxnQkFBZ0I7SUFDdkI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvbG9nZ2VyLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvQ29vcmRpbmF0ZS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0luc3RhbmNlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvUmVnaXN0cnlTdGF0cy50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL1JlZ2lzdHJ5LnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXJyb3JzL1JlZ2lzdHJ5RXJyb3IudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9lcnJvcnMvUmVnaXN0cnlIdWJFcnJvci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL1JlZ2lzdHJ5SHViLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZXJyb3JzL0luc3RhbmNlRXJyb3IudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9lcnJvcnMvQ29vcmRpbmF0ZUVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnaW5nIGZyb20gJ0BmamVsbC9sb2dnaW5nJztcblxuY29uc3QgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoJ0BmamVsbC9yZWdpc3RyeScpO1xuXG5leHBvcnQgZGVmYXVsdCBMaWJMb2dnZXI7XG4iLCJpbXBvcnQgeyBJdGVtVHlwZUFycmF5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJDb29yZGluYXRlXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvb3JkaW5hdGU8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4+IHtcbiAga3RhOiBJdGVtVHlwZUFycmF5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gIHNjb3Blczogc3RyaW5nW107XG4gIHRvU3RyaW5nOiAoKSA9PiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb29yZGluYXRlID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuPihrdGE6IEl0ZW1UeXBlQXJyYXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFMsIHNjb3Blczogc3RyaW5nW10gPSBbXSk6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG4gIGNvbnN0IGt0QXJyYXkgPSBBcnJheS5pc0FycmF5KGt0YSkgPyBrdGEgOiBba3RhXTtcbiAgY29uc3QgdG9TdHJpbmcgPSAoKSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKFwidG9TdHJpbmdcIiwgeyBrdGEsIHNjb3BlcyB9KTtcbiAgICByZXR1cm4gYCR7a3RBcnJheS5qb2luKCcsICcpfSAtICR7c2NvcGVzLmpvaW4oJywgJyl9YDtcbiAgfVxuICBsb2dnZXIuZGVidWcoXCJjcmVhdGVDb29yZGluYXRlXCIsIHsga3RhOiBrdEFycmF5LCBzY29wZXMsIHRvU3RyaW5nIH0pO1xuICByZXR1cm4geyBrdGE6IGt0QXJyYXkgYXMgSXRlbVR5cGVBcnJheTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBzY29wZXMsIHRvU3RyaW5nIH07XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCB7IFJlZ2lzdHJ5IH0gZnJvbSBcIi4vUmVnaXN0cnlcIjtcbmltcG9ydCB7IENvb3JkaW5hdGUgfSBmcm9tIFwiLi9Db29yZGluYXRlXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJJbnN0YW5jZVwiKTtcblxuLyoqXG4gKiBUaGUgSW5zdGFuY2UgaW50ZXJmYWNlIHJlcHJlc2VudHMgYSBkYXRhIG1vZGVsIGluc3RhbmNlIHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIGJvdGggaXRzIHN0cnVjdHVyZVxuICogYW5kIG9wZXJhdGlvbnMuIEl0IHNlcnZlcyBhcyB0aGUgbWFpbiBpbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggZGF0YSBtb2RlbHMgaW4gdGhlIHN5c3RlbS5cbiAqXG4gKiBUaGUgaW50ZXJmYWNlIGNvbnNpc3RzIG9mIHR3byBtYWluIGNvbXBvbmVudHM6XG4gKiAxLiBkZWZpbml0aW9uOiBEZWZpbmVzIHRoZSBzdHJ1Y3R1cmUsIGtleXMsIGFuZCByZWxhdGlvbnNoaXBzIG9mIHRoZSBkYXRhIG1vZGVsXG4gKiAyLiBvcGVyYXRpb25zOiBQcm92aWRlcyBtZXRob2RzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBkYXRhIG1vZGVsIChnZXQsIGZpbmQsIGFsbCwgZXRjLilcbiAqIDMuIHJlZ2lzdHJ5OiBNYW5hZ2VzIHRoZSByZWdpc3RyYXRpb24gYW5kIGxvb2t1cCBvZiBMaWJyYXJ5IGluc3RhbmNlc1xuICpcbiAqIFRoZSBJbnN0YW5jZSBpbnRlcmZhY2UgaXMgZ2VuZXJpYyBhbmQgc3VwcG9ydHMgdXAgdG8gNSBsZXZlbHMgb2YgbG9jYXRpb24gaGllcmFyY2h5IChMMS1MNSlcbiAqIGZvciBjb250YWluZWQgaW5zdGFuY2VzLCBhbGxvd2luZyBmb3IgY29tcGxleCBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEB0ZW1wbGF0ZSBWIC0gVGhlIHR5cGUgb2YgdGhlIGRhdGEgbW9kZWwgaXRlbSwgZXh0ZW5kaW5nIEl0ZW1cbiAqIEB0ZW1wbGF0ZSBTIC0gVGhlIHN0cmluZyBsaXRlcmFsIHR5cGUgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCdzIGtleSB0eXBlXG4gKiBAdGVtcGxhdGUgTDEtTDUgLSBPcHRpb25hbCBzdHJpbmcgbGl0ZXJhbCB0eXBlcyBmb3IgbG9jYXRpb24gaGllcmFyY2h5IGxldmVsc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbmNlPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IHtcbiAgY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIC8qKiBUaGUgcmVnaXN0cnkgb2JqZWN0IHRoYXQgbWFuYWdlcyB0aGUgcmVnaXN0cmF0aW9uIGFuZCBsb29rdXAgb2YgbW9kZWwgaW5zdGFuY2VzICovXG4gIHJlZ2lzdHJ5OiBSZWdpc3RyeTtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluc3RhbmNlID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICByZWdpc3RyeTogUmVnaXN0cnksXG4gIGNvb3JkaW5hdGU6IENvb3JkaW5hdGU8UywgTDEsIEwyLCBMMywgTDQsIEw1Pixcbik6IEluc3RhbmNlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBsb2dnZXIuZGVidWcoXCJjcmVhdGVJbnN0YW5jZVwiLCB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5IH0pO1xuICByZXR1cm4geyBjb29yZGluYXRlLCByZWdpc3RyeSB9O1xufVxuXG5leHBvcnQgY29uc3QgaXNJbnN0YW5jZSA9IChpbnN0YW5jZTogYW55KTogaW5zdGFuY2UgaXMgSW5zdGFuY2U8YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4gPT4ge1xuICByZXR1cm4gaW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICBpbnN0YW5jZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgaW5zdGFuY2UuY29vcmRpbmF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgaW5zdGFuY2UucmVnaXN0cnkgIT09IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IEFsbEl0ZW1UeXBlQXJyYXlzIH0gZnJvbSAnQGZqZWxsL2NvcmUnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzZXJ2aWNlIGNsaWVudCAoYW5vdGhlciBzZXJ2aWNlIG1ha2luZyB0aGUgcmVxdWVzdClcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlQ2xpZW50IHtcbiAgLyoqIFRoZSB0eXBlIG9mIHJlZ2lzdHJ5IHdoZXJlIHRoZSBjYWxsaW5nIHNlcnZpY2UgaXMgcmVnaXN0ZXJlZCAqL1xuICByZWdpc3RyeVR5cGU6IHN0cmluZztcbiAgLyoqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBjYWxsaW5nIHNlcnZpY2UgKi9cbiAgY29vcmRpbmF0ZToge1xuICAgIGt0YTogc3RyaW5nW107XG4gICAgc2NvcGVzOiBzdHJpbmdbXTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGVpdGhlciBhIHNlcnZpY2Ugb3IgYXBwbGljYXRpb24gY2xpZW50XG4gKi9cbmV4cG9ydCB0eXBlIENsaWVudElkZW50aWZpZXIgPSBTZXJ2aWNlQ2xpZW50IHwgc3RyaW5nO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyBjb29yZGluYXRlIGNhbGwgd2l0aCBib3RoIGt0YSBhbmQgc2NvcGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29vcmRpbmF0ZUNhbGxSZWNvcmQge1xuICAvKiogVGhlIGtleSB0eXBlIGFycmF5IHRoYXQgd2FzIHJlcXVlc3RlZCAqL1xuICBrdGE6IHN0cmluZ1tdO1xuICAvKiogVGhlIHNjb3BlcyB0aGF0IHdlcmUgcmVxdWVzdGVkIChlbXB0eSBhcnJheSBpZiBubyBzY29wZXMpICovXG4gIHNjb3Blczogc3RyaW5nW107XG4gIC8qKiBOdW1iZXIgb2YgdGltZXMgdGhpcyBleGFjdCBjb21iaW5hdGlvbiB3YXMgY2FsbGVkICovXG4gIGNvdW50OiBudW1iZXI7XG4gIC8qKiBCcmVha2Rvd24gb2YgY2FsbHMgYnkgY2xpZW50ICovXG4gIGNsaWVudENhbGxzOiBDbGllbnRDYWxsUmVjb3JkW107XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBjYWxscyBmcm9tIGEgc3BlY2lmaWMgY2xpZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50Q2FsbFJlY29yZCB7XG4gIC8qKiBUaGUgY2xpZW50IHRoYXQgbWFkZSB0aGUgY2FsbHMgKi9cbiAgY2xpZW50OiBDbGllbnRJZGVudGlmaWVyO1xuICAvKiogTnVtYmVyIG9mIGNhbGxzIGZyb20gdGhpcyBjbGllbnQgKi9cbiAgY291bnQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBTdGF0aXN0aWNzIGFib3V0IFJlZ2lzdHJ5IGdldCgpIG1ldGhvZCBjYWxscyB3aXRoIGRldGFpbGVkIGNvb3JkaW5hdGUgdHJhY2tpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RyeVN0YXRpc3RpY3Mge1xuICAvKiogVG90YWwgbnVtYmVyIG9mIGdldCgpIGNhbGxzIG1hZGUgb24gdGhpcyByZWdpc3RyeSAqL1xuICB0b3RhbEdldENhbGxzOiBudW1iZXI7XG4gIC8qKiBEZXRhaWxlZCByZWNvcmRzIG9mIGVhY2ggdW5pcXVlIGNvb3JkaW5hdGUgY29tYmluYXRpb24gYW5kIHRoZWlyIGNhbGwgY291bnRzICovXG4gIGNvb3JkaW5hdGVDYWxsUmVjb3JkczogQ29vcmRpbmF0ZUNhbGxSZWNvcmRbXTtcbiAgLyoqIFN1bW1hcnkgb2YgY2FsbHMgYnkgY2xpZW50IHR5cGUgKi9cbiAgY2xpZW50U3VtbWFyeToge1xuICAgIC8qKiBUb3RhbCBjYWxscyBmcm9tIHNlcnZpY2VzIChzZXJ2aWNlLXRvLXNlcnZpY2UpICovXG4gICAgc2VydmljZUNhbGxzOiBudW1iZXI7XG4gICAgLyoqIFRvdGFsIGNhbGxzIGZyb20gYXBwbGljYXRpb25zIChkaXJlY3QgYXBwbGljYXRpb24gY2FsbHMpICovXG4gICAgYXBwbGljYXRpb25DYWxsczogbnVtYmVyO1xuICAgIC8qKiBUb3RhbCBjYWxscyB3aXRoIG5vIGNsaWVudCBzcGVjaWZpZWQgKi9cbiAgICB1bmlkZW50aWZpZWRDYWxsczogbnVtYmVyO1xuICB9O1xufVxuXG4vKipcbiAqIEludGVybmFsIGNsYXNzIGZvciB0cmFja2luZyBSZWdpc3RyeSBzdGF0aXN0aWNzIHdpdGggY29tcGxleCBjb29yZGluYXRlIGNvbWJpbmF0aW9ucyBhbmQgY2xpZW50IHRyYWNraW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeVN0YXRzIHtcbiAgcHJpdmF0ZSB0b3RhbENhbGxzID0gMDtcbiAgLy8gTWFwIHN0cnVjdHVyZToga3RhS2V5IC0+IHNjb3BlS2V5IC0+IGNsaWVudEtleSAtPiBjb3VudFxuICBwcml2YXRlIGNvb3JkaW5hdGVDYWxscyA9IG5ldyBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBudW1iZXI+Pj4oKTtcblxuICAvKipcbiAgICogUmVjb3JkcyBhIGdldCgpIGNhbGwgZm9yIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBhbmQgY2xpZW50XG4gICAqL1xuICByZWNvcmRHZXRDYWxsPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcgPSBhbnksXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBhbnkgfCBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IGFueSB8IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gYW55IHwgbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBhbnkgfCBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IGFueSB8IG5ldmVyLFxuICA+KGt0YTogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1Piwgc2NvcGVzPzogc3RyaW5nW10sIGNsaWVudD86IENsaWVudElkZW50aWZpZXIpOiB2b2lkIHtcbiAgICB0aGlzLnRvdGFsQ2FsbHMrKztcblxuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKCcuJyk7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG4gICAgY29uc3QgY2xpZW50S2V5ID0gdGhpcy5jcmVhdGVDbGllbnRLZXkoY2xpZW50KTtcblxuICAgIGlmICghdGhpcy5jb29yZGluYXRlQ2FsbHMuaGFzKGt0YUtleSkpIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZUNhbGxzLnNldChrdGFLZXksIG5ldyBNYXAoKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KSE7XG4gICAgaWYgKCFzY29wZU1hcC5oYXMoc2NvcGVLZXkpKSB7XG4gICAgICBzY29wZU1hcC5zZXQoc2NvcGVLZXksIG5ldyBNYXAoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KSE7XG4gICAgY29uc3QgY3VycmVudENvdW50ID0gY2xpZW50TWFwLmdldChjbGllbnRLZXkpIHx8IDA7XG4gICAgY2xpZW50TWFwLnNldChjbGllbnRLZXksIGN1cnJlbnRDb3VudCArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGlzdGljcyBzbmFwc2hvdFxuICAgKi9cbiAgZ2V0U3RhdGlzdGljcygpOiBSZWdpc3RyeVN0YXRpc3RpY3Mge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVDYWxsUmVjb3JkczogQ29vcmRpbmF0ZUNhbGxSZWNvcmRbXSA9IFtdO1xuICAgIGxldCBzZXJ2aWNlQ2FsbHMgPSAwO1xuICAgIGxldCBhcHBsaWNhdGlvbkNhbGxzID0gMDtcbiAgICBsZXQgdW5pZGVudGlmaWVkQ2FsbHMgPSAwO1xuXG4gICAgZm9yIChjb25zdCBba3RhS2V5LCBzY29wZU1hcF0gb2YgdGhpcy5jb29yZGluYXRlQ2FsbHMpIHtcbiAgICAgIGZvciAoY29uc3QgW3Njb3BlS2V5LCBjbGllbnRNYXBdIG9mIHNjb3BlTWFwKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudENhbGxzOiBDbGllbnRDYWxsUmVjb3JkW10gPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsQ291bnQgPSAwO1xuXG4gICAgICAgIGZvciAoY29uc3QgW2NsaWVudEtleSwgY291bnRdIG9mIGNsaWVudE1hcCkge1xuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMucGFyc2VDbGllbnRLZXkoY2xpZW50S2V5KTtcbiAgICAgICAgICBpZiAoY2xpZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGllbnRDYWxscy5wdXNoKHsgY2xpZW50LCBjb3VudCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxDb3VudCArPSBjb3VudDtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBjbGllbnQgc3VtbWFyeVxuICAgICAgICAgIGlmIChjbGllbnRLZXkgPT09ICdfX25vX2NsaWVudF9fJykge1xuICAgICAgICAgICAgdW5pZGVudGlmaWVkQ2FsbHMgKz0gY291bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2xpZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXBwbGljYXRpb25DYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VydmljZUNhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvb3JkaW5hdGVDYWxsUmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICBrdGE6IGt0YUtleS5zcGxpdCgnLicpLFxuICAgICAgICAgIHNjb3BlczogdGhpcy5wYXJzZVNjb3BlS2V5KHNjb3BlS2V5KSxcbiAgICAgICAgICBjb3VudDogdG90YWxDb3VudCxcbiAgICAgICAgICBjbGllbnRDYWxsczogWy4uLmNsaWVudENhbGxzXSAvLyBSZXR1cm4gYSBjb3B5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEdldENhbGxzOiB0aGlzLnRvdGFsQ2FsbHMsXG4gICAgICBjb29yZGluYXRlQ2FsbFJlY29yZHM6IFsuLi5jb29yZGluYXRlQ2FsbFJlY29yZHNdLCAvLyBSZXR1cm4gYSBjb3B5XG4gICAgICBjbGllbnRTdW1tYXJ5OiB7XG4gICAgICAgIHNlcnZpY2VDYWxscyxcbiAgICAgICAgYXBwbGljYXRpb25DYWxscyxcbiAgICAgICAgdW5pZGVudGlmaWVkQ2FsbHNcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbCBjb3VudCBmb3IgYSBzcGVjaWZpYyBjb29yZGluYXRlIGNvbWJpbmF0aW9uXG4gICAqL1xuICBnZXRDYWxsQ291bnQoa3RhOiBzdHJpbmdbXSwgc2NvcGVzPzogc3RyaW5nW10pOiBudW1iZXIge1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKCcuJyk7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG5cbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuXG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBpZiAoIWNsaWVudE1hcCkgcmV0dXJuIDA7XG5cbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgY291bnQgb2YgY2xpZW50TWFwLnZhbHVlcygpKSB7XG4gICAgICB0b3RhbCArPSBjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbCBjb3VudCBmb3IgYSBzcGVjaWZpYyBjb29yZGluYXRlIGNvbWJpbmF0aW9uIGZyb20gYSBzcGVjaWZpYyBjbGllbnRcbiAgICovXG4gIGdldENhbGxDb3VudEJ5Q2xpZW50KGt0YTogc3RyaW5nW10sIHNjb3Blcz86IHN0cmluZ1tdLCBjbGllbnQ/OiBDbGllbnRJZGVudGlmaWVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbignLicpO1xuICAgIGNvbnN0IHNjb3BlS2V5ID0gdGhpcy5jcmVhdGVTY29wZUtleShzY29wZXMgfHwgW10pO1xuICAgIGNvbnN0IGNsaWVudEtleSA9IHRoaXMuY3JlYXRlQ2xpZW50S2V5KGNsaWVudCk7XG5cbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuXG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBpZiAoIWNsaWVudE1hcCkgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gY2xpZW50TWFwLmdldChjbGllbnRLZXkpIHx8IDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0b3RhbCBjYWxscyBmb3IgYSBzcGVjaWZpYyBrdGEgKGFjcm9zcyBhbGwgc2NvcGVzKVxuICAgKi9cbiAgZ2V0VG90YWxDYWxsc0Zvckt0YShrdGE6IHN0cmluZ1tdKTogbnVtYmVyIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbignLicpO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gdGhpcy5jb29yZGluYXRlQ2FsbHMuZ2V0KGt0YUtleSk7XG4gICAgaWYgKCFzY29wZU1hcCkgcmV0dXJuIDA7XG5cbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgY2xpZW50TWFwIG9mIHNjb3BlTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvdW50IG9mIGNsaWVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgICB0b3RhbCArPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHVuaXF1ZSBrdGEgcGF0aHMgdGhhdCBoYXZlIGJlZW4gY2FsbGVkXG4gICAqL1xuICBnZXRDYWxsZWRLdGFQYXRocygpOiBzdHJpbmdbXVtdIHtcbiAgICBjb25zdCBrdGFQYXRoczogc3RyaW5nW11bXSA9IFtdO1xuICAgIGZvciAoY29uc3Qga3RhS2V5IG9mIHRoaXMuY29vcmRpbmF0ZUNhbGxzLmtleXMoKSkge1xuICAgICAga3RhUGF0aHMucHVzaChrdGFLZXkuc3BsaXQoJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBrdGFQYXRocztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9ybWFsaXplZCBzY29wZSBrZXkgZnJvbSBzY29wZXMgYXJyYXlcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlU2NvcGVLZXkoc2NvcGVzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgaWYgKHNjb3Blcy5sZW5ndGggPT09IDApIHJldHVybiAnX19ub19zY29wZXNfXyc7XG4gICAgcmV0dXJuIFsuLi5zY29wZXNdLnNvcnQoKS5qb2luKCcsJyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgc2NvcGUga2V5IGJhY2sgdG8gc2NvcGVzIGFycmF5XG4gICAqL1xuICBwcml2YXRlIHBhcnNlU2NvcGVLZXkoc2NvcGVLZXk6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBpZiAoc2NvcGVLZXkgPT09ICdfX25vX3Njb3Blc19fJykgcmV0dXJuIFtdO1xuICAgIHJldHVybiBzY29wZUtleS5zcGxpdCgnLCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBub3JtYWxpemVkIGNsaWVudCBrZXkgZnJvbSBjbGllbnQgaWRlbnRpZmllclxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVDbGllbnRLZXkoY2xpZW50PzogQ2xpZW50SWRlbnRpZmllcik6IHN0cmluZyB7XG4gICAgaWYgKCFjbGllbnQpIHJldHVybiAnX19ub19jbGllbnRfXyc7XG5cbiAgICBpZiAodHlwZW9mIGNsaWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBgYXBwOiR7Y2xpZW50fWA7XG4gICAgfVxuXG4gICAgLy8gU2VydmljZSBjbGllbnRcbiAgICBjb25zdCBjb29yZEtleSA9IGAke2NsaWVudC5jb29yZGluYXRlLmt0YS5qb2luKCcuJyl9OyR7dGhpcy5jcmVhdGVTY29wZUtleShjbGllbnQuY29vcmRpbmF0ZS5zY29wZXMpfWA7XG4gICAgcmV0dXJuIGBzZXJ2aWNlOiR7Y2xpZW50LnJlZ2lzdHJ5VHlwZX06JHtjb29yZEtleX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGNsaWVudCBrZXkgYmFjayB0byBjbGllbnQgaWRlbnRpZmllclxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZUNsaWVudEtleShjbGllbnRLZXk6IHN0cmluZyk6IENsaWVudElkZW50aWZpZXIgfCBudWxsIHtcbiAgICBpZiAoY2xpZW50S2V5ID09PSAnX19ub19jbGllbnRfXycpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGNsaWVudEtleS5zdGFydHNXaXRoKCdhcHA6JykpIHtcbiAgICAgIHJldHVybiBjbGllbnRLZXkuc3Vic3RyaW5nKDQpO1xuICAgIH1cblxuICAgIGlmIChjbGllbnRLZXkuc3RhcnRzV2l0aCgnc2VydmljZTonKSkge1xuICAgICAgY29uc3QgcGFydHMgPSBjbGllbnRLZXkuc3Vic3RyaW5nKDgpLnNwbGl0KCc6Jyk7XG4gICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSByZXR1cm4gbnVsbDtcblxuICAgICAgY29uc3QgcmVnaXN0cnlUeXBlID0gcGFydHNbMF07XG4gICAgICBjb25zdCBjb29yZFBhcnRzID0gcGFydHNbMV0uc3BsaXQoJzsnKTtcbiAgICAgIGlmIChjb29yZFBhcnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IGt0YSA9IGNvb3JkUGFydHNbMF0uc3BsaXQoJy4nKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMucGFyc2VTY29wZUtleShjb29yZFBhcnRzWzFdKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgICBjb29yZGluYXRlOiB7IGt0YSwgc2NvcGVzIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBJbnN0YW5jZSwgaXNJbnN0YW5jZSB9IGZyb20gJy4vSW5zdGFuY2UnO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSwgY3JlYXRlQ29vcmRpbmF0ZSB9IGZyb20gJy4vQ29vcmRpbmF0ZSc7XG5pbXBvcnQgeyBBbGxJdGVtVHlwZUFycmF5cyB9IGZyb20gJ0BmamVsbC9jb3JlJztcbmltcG9ydCB7XG4gIEluc3RhbmNlRmFjdG9yeSxcbiAgSW5zdGFuY2VUcmVlLFxuICBSZWdpc3RyeSxcbiAgUmVnaXN0cnlIdWIsXG4gIFNjb3BlZEluc3RhbmNlXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQ2xpZW50SWRlbnRpZmllciwgUmVnaXN0cnlTdGF0aXN0aWNzLCBSZWdpc3RyeVN0YXRzLCBTZXJ2aWNlQ2xpZW50IH0gZnJvbSAnLi9SZWdpc3RyeVN0YXRzJztcblxuLy8gUmUtZXhwb3J0IHR5cGVzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnQgdHlwZSB7IFJlZ2lzdHJ5LCBSZWdpc3RyeUh1YiwgSW5zdGFuY2VGYWN0b3J5LCBSZWdpc3RyeUZhY3RvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIlJlZ2lzdHJ5XCIpO1xuXG5jb25zdCBmaW5kU2NvcGVkSW5zdGFuY2UgPSAoXG4gIHNjb3BlZEluc3RhbmNlczogU2NvcGVkSW5zdGFuY2VbXSxcbiAgcmVxdWVzdGVkU2NvcGVzPzogc3RyaW5nW10sXG5cbik6IEluc3RhbmNlPGFueSwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyPiA9PiB7XG4gIGlmICghcmVxdWVzdGVkU2NvcGVzIHx8IHJlcXVlc3RlZFNjb3Blcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5zdGFuY2UgaWYgbm8gc2NvcGVzIHNwZWNpZmllZFxuICAgIGNvbnN0IGZpcnN0SW5zdGFuY2UgPSBzY29wZWRJbnN0YW5jZXNbMF0/Lmluc3RhbmNlO1xuICAgIGlmICghZmlyc3RJbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnN0YW5jZXMgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdEluc3RhbmNlO1xuICB9XG5cbiAgLy8gRmluZCBpbnN0YW5jZSB0aGF0IG1hdGNoZXMgYWxsIHJlcXVlc3RlZCBzY29wZXNcbiAgY29uc3QgbWF0Y2hpbmdJbnN0YW5jZSA9IHNjb3BlZEluc3RhbmNlcy5maW5kKHNjb3BlZEluc3RhbmNlID0+IHtcbiAgICBpZiAoIXNjb3BlZEluc3RhbmNlLnNjb3BlcykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiByZXF1ZXN0ZWRTY29wZXMuZXZlcnkoc2NvcGUgPT5cbiAgICAgIHNjb3BlZEluc3RhbmNlLnNjb3BlcyAmJiBzY29wZWRJbnN0YW5jZS5zY29wZXMuaW5jbHVkZXMoc2NvcGUpXG4gICAgKTtcbiAgfSk7XG5cbiAgaWYgKCFtYXRjaGluZ0luc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnN0YW5jZSBmb3VuZCBtYXRjaGluZyBzY29wZXM6ICR7cmVxdWVzdGVkU2NvcGVzLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hpbmdJbnN0YW5jZS5pbnN0YW5jZTtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZ2lzdHJ5ID0gKHR5cGU6IHN0cmluZywgcmVnaXN0cnlIdWI/OiBSZWdpc3RyeUh1Yik6IFJlZ2lzdHJ5ID0+IHtcbiAgY29uc3QgaW5zdGFuY2VUcmVlOiBJbnN0YW5jZVRyZWUgPSB7fTtcblxuICAvLyBTdGF0aXN0aWNzIHRyYWNraW5nXG4gIGNvbnN0IHJlZ2lzdHJ5U3RhdHMgPSBuZXcgUmVnaXN0cnlTdGF0cygpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJveGllZCBSZWdpc3RyeSB0aGF0IGF1dG9tYXRpY2FsbHkgaW5qZWN0cyBjbGllbnQgaW5mb3JtYXRpb24gZm9yIHNlcnZpY2UtdG8tc2VydmljZSBjYWxsc1xuICAgKi9cbiAgY29uc3QgY3JlYXRlUHJveGllZFJlZ2lzdHJ5ID0gKGNhbGxpbmdDb29yZGluYXRlOiBDb29yZGluYXRlPGFueSwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyPik6IFJlZ2lzdHJ5ID0+IHtcbiAgICBjb25zdCBzZXJ2aWNlQ2xpZW50OiBTZXJ2aWNlQ2xpZW50ID0ge1xuICAgICAgcmVnaXN0cnlUeXBlOiB0eXBlLFxuICAgICAgY29vcmRpbmF0ZToge1xuICAgICAgICBrdGE6IGNhbGxpbmdDb29yZGluYXRlLmt0YSxcbiAgICAgICAgc2NvcGVzOiBjYWxsaW5nQ29vcmRpbmF0ZS5zY29wZXNcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlZ2lzdHJ5LFxuICAgICAgZ2V0OiA8XG4gICAgICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgICA+KGt0YTogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1Piwgb3B0aW9ucz86IHsgc2NvcGVzPzogc3RyaW5nW107IGNsaWVudD86IENsaWVudElkZW50aWZpZXIgfSk6IEluc3RhbmNlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBudWxsID0+IHtcbiAgICAgICAgLy8gQXV0b21hdGljYWxseSBpbmplY3QgdGhlIGNhbGxpbmcgc2VydmljZSBhcyB0aGUgY2xpZW50IGlmIG5vIGNsaWVudCBpcyBzcGVjaWZpZWRcbiAgICAgICAgY29uc3QgY2xpZW50VG9Vc2UgPSBvcHRpb25zPy5jbGllbnQgfHwgc2VydmljZUNsaWVudDtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChrdGEsIHsgLi4ub3B0aW9ucywgY2xpZW50OiBjbGllbnRUb1VzZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZUluc3RhbmNlID0gPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICA+KFxuICAgIGt0YTogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBzY29wZXM6IHN0cmluZ1tdLFxuICAgIGZhY3Rvcnk6IEluc3RhbmNlRmFjdG9yeTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICk6IEluc3RhbmNlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhgQ3JlYXRpbmcgYW5kIHJlZ2lzdGVyaW5nIGluc3RhbmNlIGZvciBrZXkgcGF0aCBhbmQgc2NvcGVzYCwga3RhLCBzY29wZXMsIGBpbiByZWdpc3RyeSB0eXBlOiAke3R5cGV9YCk7XG5cbiAgICAvLyBDcmVhdGUgY29vcmRpbmF0ZSBmb3IgdGhlIGluc3RhbmNlXG4gICAgY29uc3QgY29vcmRpbmF0ZSA9IGNyZWF0ZUNvb3JkaW5hdGUoa3RhIGFzIGFueSwgc2NvcGVzKTtcblxuICAgIC8vIENyZWF0ZSBhIHByb3hpZWQgcmVnaXN0cnkgdGhhdCBhdXRvbWF0aWNhbGx5IHRyYWNrcyB0aGlzIHNlcnZpY2UgYXMgdGhlIGNsaWVudFxuICAgIGNvbnN0IHByb3hpZWRSZWdpc3RyeSA9IGNyZWF0ZVByb3hpZWRSZWdpc3RyeShjb29yZGluYXRlKTtcblxuICAgIC8vIFVzZSBmYWN0b3J5IHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgcHJveGllZCByZWdpc3RyeVxuICAgIGNvbnN0IGluc3RhbmNlID0gZmFjdG9yeShjb29yZGluYXRlLCB7XG4gICAgICByZWdpc3RyeTogcHJveGllZFJlZ2lzdHJ5LFxuICAgICAgcmVnaXN0cnlIdWIsXG4gICAgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgIGlmICghaXNJbnN0YW5jZShpbnN0YW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFjdG9yeSBkaWQgbm90IHJldHVybiBhIHZhbGlkIGluc3RhbmNlIGZvcjogJHtrdGEuam9pbignLicpfWApO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBpbnN0YW5jZVxuICAgIHJlZ2lzdGVySW50ZXJuYWwoa3RhLCBpbnN0YW5jZSwgeyBzY29wZXMgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgY29uc3QgcmVnaXN0ZXJJbnRlcm5hbCA9IDxcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgPihrdGE6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIGluc3RhbmNlOiBJbnN0YW5jZTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBvcHRpb25zPzogeyBzY29wZXM/OiBzdHJpbmdbXSB9KTogdm9pZCA9PiB7XG4gICAgY29uc3Qga2V5UGF0aCA9IFsuLi5rdGFdLnJldmVyc2UoKTsgLy8gV29yayBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3Qgc3BlY2lmaWNcbiAgICBsZXQgY3VycmVudExldmVsID0gaW5zdGFuY2VUcmVlO1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBSZWdpc3RlcmluZyBpbnN0YW5jZSBmb3Iga2V5IHBhdGggYW5kIHNjb3Blc2AsIGtleVBhdGgsIG9wdGlvbnM/LnNjb3BlcywgYGluIHJlZ2lzdHJ5IHR5cGU6ICR7dHlwZX1gKTtcblxuICAgIGlmICghaXNJbnN0YW5jZShpbnN0YW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIG5vbi1pbnN0YW5jZTogJHtrdGEuam9pbignLicpfWApO1xuICAgIH1cblxuICAgIC8vIE5hdmlnYXRlIHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uIGluIHRoZSB0cmVlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlUeXBlID0ga2V5UGF0aFtpXTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGkgPT09IGtleVBhdGgubGVuZ3RoIC0gMTtcblxuICAgICAgaWYgKCFjdXJyZW50TGV2ZWxba2V5VHlwZV0pIHtcbiAgICAgICAgY3VycmVudExldmVsW2tleVR5cGVdID0ge1xuICAgICAgICAgIGluc3RhbmNlczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IGlzTGVhZiA/IG51bGwgOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIC8vIEFkZCBpbnN0YW5jZSB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5pbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGVzOiBvcHRpb25zPy5zY29wZXMsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOYXZpZ2F0ZSBkZWVwZXIgaW50byB0aGUgdHJlZVxuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbikge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbiE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZ2lzdGVyID0gPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICA+KGt0YTogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PiwgaW5zdGFuY2U6IEluc3RhbmNlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIG9wdGlvbnM/OiB7IHNjb3Blcz86IHN0cmluZ1tdIH0pOiB2b2lkID0+IHtcbiAgICBsb2dnZXIuZGVidWcoJ1VzaW5nIGRlcHJlY2F0ZWQgcmVnaXN0ZXIgbWV0aG9kLiBDb25zaWRlciB1c2luZyBjcmVhdGVJbnN0YW5jZSBpbnN0ZWFkLicpO1xuICAgIHJlZ2lzdGVySW50ZXJuYWwoa3RhLCBpbnN0YW5jZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgY29uc3QgZ2V0ID0gPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICA+KGt0YTogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1Piwgb3B0aW9ucz86IHsgc2NvcGVzPzogc3RyaW5nW107IGNsaWVudD86IENsaWVudElkZW50aWZpZXIgfSk6IEluc3RhbmNlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBudWxsID0+IHtcbiAgICAvLyBUcmFjayBzdGF0aXN0aWNzIHdpdGgga3RhLCBzY29wZXMsIGFuZCBjbGllbnRcbiAgICByZWdpc3RyeVN0YXRzLnJlY29yZEdldENhbGwoa3RhLCBvcHRpb25zPy5zY29wZXMsIG9wdGlvbnM/LmNsaWVudCk7XG5cbiAgICBjb25zdCBrZXlQYXRoID0gWy4uLmt0YV0ucmV2ZXJzZSgpO1xuICAgIGxldCBjdXJyZW50TGV2ZWwgPSBpbnN0YW5jZVRyZWU7XG5cbiAgICAvLyBOYXZpZ2F0ZSB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleVBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleVR5cGUgPSBrZXlQYXRoW2ldO1xuICAgICAgY29uc3QgaXNMZWFmID0gaSA9PT0ga2V5UGF0aC5sZW5ndGggLSAxO1xuXG4gICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oJy4nKX0sIE1pc3Npbmcga2V5OiAke2tleVR5cGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgLy8gRm91bmQgdGhlIHRhcmdldCBub2RlLCBleHRyYWN0IGluc3RhbmNlXG4gICAgICAgIGNvbnN0IHNjb3BlZEluc3RhbmNlcyA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5pbnN0YW5jZXM7XG5cbiAgICAgICAgaWYgKHNjb3BlZEluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluc3RhbmNlcyByZWdpc3RlcmVkIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbignLicpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbmRTY29wZWRJbnN0YW5jZShzY29wZWRJbnN0YW5jZXMsIG9wdGlvbnM/LnNjb3Blcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb250aW51ZSBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICghY3VycmVudExldmVsW2tleVR5cGVdLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2t0YS5qb2luKCcuJyl9LCBObyBjaGlsZHJlbiBmb3I6ICR7a2V5VHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW4hO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGNvbnN0IGdldENvb3JkaW5hdGVzID0gKCk6IENvb3JkaW5hdGU8YW55LCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXI+W10gPT4ge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzOiBDb29yZGluYXRlPGFueSwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyLCBhbnkgfCBuZXZlciwgYW55IHwgbmV2ZXIsIGFueSB8IG5ldmVyPltdID0gW107XG5cbiAgICBjb25zdCB0cmF2ZXJzZVRyZWUgPSAobm9kZTogSW5zdGFuY2VUcmVlKTogdm9pZCA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleVR5cGUgaW4gbm9kZSkge1xuICAgICAgICBjb25zdCB0cmVlTm9kZSA9IG5vZGVba2V5VHlwZV07XG5cbiAgICAgICAgLy8gQ29sbGVjdCBjb29yZGluYXRlcyBmcm9tIGluc3RhbmNlcyBhdCB0aGlzIGxldmVsXG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGVkSW5zdGFuY2Ugb2YgdHJlZU5vZGUuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucHVzaChzY29wZWRJbnN0YW5jZS5pbnN0YW5jZS5jb29yZGluYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGNoaWxkcmVuIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdHJhdmVyc2VUcmVlKHRyZWVOb2RlLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmF2ZXJzZVRyZWUoaW5zdGFuY2VUcmVlKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgY29uc3QgZ2V0U3RhdGlzdGljcyA9ICgpOiBSZWdpc3RyeVN0YXRpc3RpY3MgPT4ge1xuICAgIHJldHVybiByZWdpc3RyeVN0YXRzLmdldFN0YXRpc3RpY3MoKTtcbiAgfTtcblxuICBjb25zdCByZWdpc3RyeTogUmVnaXN0cnkgPSB7XG4gICAgdHlwZSxcbiAgICByZWdpc3RyeUh1YixcbiAgICBjcmVhdGVJbnN0YW5jZSxcbiAgICByZWdpc3RlcixcbiAgICBnZXQsXG4gICAgZ2V0Q29vcmRpbmF0ZXMsXG4gICAgZ2V0U3RhdGlzdGljcyxcbiAgICBpbnN0YW5jZVRyZWUsXG4gIH07XG5cbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufVxuIiwiLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgcmVnaXN0cnktcmVsYXRlZCBlcnJvcnNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlZ2lzdHJ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSByZWdpc3RyeVR5cGU/OiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PjtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHJlZ2lzdHJ5VHlwZT86IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5yZWdpc3RyeVR5cGUgPSByZWdpc3RyeVR5cGU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChOb2RlLmpzIHNwZWNpZmljKVxuICAgIGNvbnN0IEVycm9yQ29uc3RydWN0b3IgPSBFcnJvciBhcyBhbnk7XG4gICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBFcnJvckNvbnN0cnVjdG9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXREZXRhaWxzKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZGV0YWlsczogc3RyaW5nW10gPSBbdGhpcy5tZXNzYWdlXTtcblxuICAgIGlmICh0aGlzLnJlZ2lzdHJ5VHlwZSkge1xuICAgICAgZGV0YWlscy5wdXNoKGBSZWdpc3RyeSBUeXBlOiAke3RoaXMucmVnaXN0cnlUeXBlfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgIGRldGFpbHMucHVzaChgQ29udGV4dDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNvbnRleHQsIG51bGwsIDIpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBkZXRhaWxzLmpvaW4oJ1xcbicpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBjcmVhdGUgYSByZWdpc3RyeSB3aXRoIGludmFsaWQgcGFyYW1ldGVyc1xuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0cnlDcmVhdGlvbkVycm9yIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgcmVhc29uOiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoYEZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cnkgb2YgdHlwZSAnJHt0eXBlfSc6ICR7cmVhc29ufWAsIHR5cGUsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBmYWN0b3J5IGZ1bmN0aW9uIHJldHVybnMgYW4gaW52YWxpZCBpbnN0YW5jZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEZhY3RvcnlSZXN1bHRFcnJvciBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkga2V5UGF0aDogc3RyaW5nW107XG4gIHB1YmxpYyByZWFkb25seSBmYWN0b3J5UmVzdWx0OiBhbnk7XG5cbiAgY29uc3RydWN0b3Ioa2V5UGF0aDogc3RyaW5nW10sIGZhY3RvcnlSZXN1bHQ6IGFueSwgcmVnaXN0cnlUeXBlPzogc3RyaW5nKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbignLicpO1xuICAgIHN1cGVyKFxuICAgICAgYEZhY3RvcnkgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBmb3I6ICR7a2V5UGF0aFN0cn0uIGAgK1xuICAgICAgYEV4cGVjdGVkIGluc3RhbmNlIHdpdGggJ2Nvb3JkaW5hdGUnIGFuZCAncmVnaXN0cnknIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgZmFjdG9yeVJlc3VsdH1gLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyBrZXlQYXRoLCBmYWN0b3J5UmVzdWx0OiB0eXBlb2YgZmFjdG9yeVJlc3VsdCB9XG4gICAgKTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMuZmFjdG9yeVJlc3VsdCA9IGZhY3RvcnlSZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgbm9uLWluc3RhbmNlIG9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEluc3RhbmNlUmVnaXN0cmF0aW9uRXJyb3IgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGtleVBhdGg6IHN0cmluZ1tdO1xuICBwdWJsaWMgcmVhZG9ubHkgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uOiBhbnk7XG5cbiAgY29uc3RydWN0b3Ioa2V5UGF0aDogc3RyaW5nW10sIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbjogYW55LCByZWdpc3RyeVR5cGU/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKCcuJyk7XG4gICAgc3VwZXIoXG4gICAgICBgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIG5vbi1pbnN0YW5jZTogJHtrZXlQYXRoU3RyfS4gYCArXG4gICAgICBgRXhwZWN0ZWQgaW5zdGFuY2Ugd2l0aCAnY29vcmRpbmF0ZScgYW5kICdyZWdpc3RyeScgcHJvcGVydGllcywgZ290OiAke3R5cGVvZiBhdHRlbXB0ZWRSZWdpc3RyYXRpb259YCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsga2V5UGF0aCwgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uOiB0eXBlb2YgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uIH1cbiAgICApO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpc3RyYXRpb24gPSBhdHRlbXB0ZWRSZWdpc3RyYXRpb247XG4gIH1cbn1cbiIsImltcG9ydCB7IFJlZ2lzdHJ5RXJyb3IgfSBmcm9tICcuL1JlZ2lzdHJ5RXJyb3InO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHJlZ2lzdHJ5IGh1Yi1yZWxhdGVkIGVycm9yc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVnaXN0cnlIdWJFcnJvciBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgaHViVHlwZT86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGh1YlR5cGU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgY29uc3QgZW5yaWNoZWRDb250ZXh0ID0gaHViVHlwZSA/IHsgLi4uY29udGV4dCwgaHViVHlwZSB9IDogY29udGV4dDtcbiAgICBzdXBlcihtZXNzYWdlLCAnJywgZW5yaWNoZWRDb250ZXh0KTtcbiAgICB0aGlzLmh1YlR5cGUgPSBodWJUeXBlO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHJlZ2lzdHJ5IHdpdGggYSB0eXBlIHRoYXQgYWxyZWFkeSBleGlzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBkdXBsaWNhdGVUeXBlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGFscmVhZHkgcmVnaXN0ZXJlZCB1bmRlciB0eXBlOiAke3R5cGV9LiBgICtcbiAgICAgIGBFYWNoIHJlZ2lzdHJ5IHR5cGUgbXVzdCBiZSB1bmlxdWUgd2l0aGluIGEgcmVnaXN0cnkgaHViLmAsXG4gICAgICAnJyxcbiAgICAgIHsgLi4uY29udGV4dCwgZHVwbGljYXRlVHlwZTogdHlwZSB9XG4gICAgKTtcbiAgICB0aGlzLmR1cGxpY2F0ZVR5cGUgPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhY2Nlc3MgYSByZWdpc3RyeSB0eXBlIHRoYXQgZG9lc24ndCBleGlzdFxuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvciBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWVzdGVkVHlwZTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgYXZhaWxhYmxlVHlwZXM6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKHJlcXVlc3RlZFR5cGU6IHN0cmluZywgYXZhaWxhYmxlVHlwZXM6IHN0cmluZ1tdID0gW10sIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgTm8gcmVnaXN0cnkgcmVnaXN0ZXJlZCB1bmRlciB0eXBlOiAke3JlcXVlc3RlZFR5cGV9YDtcbiAgICBpZiAoYXZhaWxhYmxlVHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZSArPSBgLiBBdmFpbGFibGUgdHlwZXM6IFske2F2YWlsYWJsZVR5cGVzLmpvaW4oJywgJyl9XWA7XG4gICAgfVxuXG4gICAgc3VwZXIobWVzc2FnZSwgJycsIHsgLi4uY29udGV4dCwgcmVxdWVzdGVkVHlwZSwgYXZhaWxhYmxlVHlwZXMgfSk7XG4gICAgdGhpcy5yZXF1ZXN0ZWRUeXBlID0gcmVxdWVzdGVkVHlwZTtcbiAgICB0aGlzLmF2YWlsYWJsZVR5cGVzID0gYXZhaWxhYmxlVHlwZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHJlZ2lzdHJ5IGZhY3RvcnkgZnVuY3Rpb24gZmFpbHMgdG8gY3JlYXRlIGEgdmFsaWQgcmVnaXN0cnlcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lzdHJ5RmFjdG9yeUVycm9yIGV4dGVuZHMgUmVnaXN0cnlIdWJFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBmYWN0b3J5RXJyb3I6IEVycm9yO1xuICBwdWJsaWMgcmVhZG9ubHkgYXR0ZW1wdGVkVHlwZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgZmFjdG9yeUVycm9yOiBFcnJvciwgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBmYWN0b3J5IGZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cnkgb2YgdHlwZSAnJHt0eXBlfSc6ICR7ZmFjdG9yeUVycm9yLm1lc3NhZ2V9YCxcbiAgICAgICcnLFxuICAgICAgeyAuLi5jb250ZXh0LCBhdHRlbXB0ZWRUeXBlOiB0eXBlLCBvcmlnaW5hbEVycm9yOiBmYWN0b3J5RXJyb3IubWVzc2FnZSB9XG4gICAgKTtcbiAgICB0aGlzLmZhY3RvcnlFcnJvciA9IGZhY3RvcnlFcnJvcjtcbiAgICB0aGlzLmF0dGVtcHRlZFR5cGUgPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBmYWN0b3J5IHJldHVybnMgYW4gaW52YWxpZCByZWdpc3RyeSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRSZWdpc3RyeUZhY3RvcnlSZXN1bHRFcnJvciBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgZmFjdG9yeVJlc3VsdDogYW55O1xuICBwdWJsaWMgcmVhZG9ubHkgYXR0ZW1wdGVkVHlwZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgZmFjdG9yeVJlc3VsdDogYW55LCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGZhY3RvcnkgcmV0dXJuZWQgaW52YWxpZCByZWdpc3RyeSBmb3IgdHlwZSAnJHt0eXBlfScuIGAgK1xuICAgICAgYEV4cGVjdGVkIHJlZ2lzdHJ5IHdpdGggJ3R5cGUnLCAnZ2V0JywgJ3JlZ2lzdGVyJywgYW5kICdjcmVhdGVJbnN0YW5jZScgcHJvcGVydGllcywgYCArXG4gICAgICBgZ290OiAke3R5cGVvZiBmYWN0b3J5UmVzdWx0fWAsXG4gICAgICAnJyxcbiAgICAgIHsgLi4uY29udGV4dCwgYXR0ZW1wdGVkVHlwZTogdHlwZSwgZmFjdG9yeVJlc3VsdDogdHlwZW9mIGZhY3RvcnlSZXN1bHQgfVxuICAgICk7XG4gICAgdGhpcy5mYWN0b3J5UmVzdWx0ID0gZmFjdG9yeVJlc3VsdDtcbiAgICB0aGlzLmF0dGVtcHRlZFR5cGUgPSB0eXBlO1xuICB9XG59XG4iLCJcbmltcG9ydCBMaWJMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZVdpdGhSZWdpc3RyeSwgUmVnaXN0cnksIFJlZ2lzdHJ5RmFjdG9yeSwgUmVnaXN0cnlIdWIgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEluc3RhbmNlIH0gZnJvbSAnLi9JbnN0YW5jZSc7XG5pbXBvcnQgeyBDbGllbnRJZGVudGlmaWVyIH0gZnJvbSAnLi9SZWdpc3RyeVN0YXRzJztcbmltcG9ydCB7XG4gIER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yLFxuICBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yLFxufSBmcm9tICcuL2Vycm9ycy9SZWdpc3RyeUh1YkVycm9yJztcbmltcG9ydCB7IEFsbEl0ZW1UeXBlQXJyYXlzIH0gZnJvbSAnQGZqZWxsL2NvcmUnO1xuXG4vLyBSZS1leHBvcnQgdHlwZXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydCB0eXBlIHsgUmVnaXN0cnlIdWIgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldChcIlJlZ2lzdHJ5SHViXCIpO1xuXG5pbnRlcmZhY2UgUmVnaXN0cnlIdWJEYXRhIHtcbiAgW3R5cGU6IHN0cmluZ106IFJlZ2lzdHJ5O1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVnaXN0cnlIdWIgPSAoKTogUmVnaXN0cnlIdWIgPT4ge1xuICBjb25zdCByZWdpc3RyaWVzOiBSZWdpc3RyeUh1YkRhdGEgPSB7fTtcblxuICBjb25zdCBjcmVhdGVSZWdpc3RyeSA9ICh0eXBlOiBzdHJpbmcsIGZhY3Rvcnk6IFJlZ2lzdHJ5RmFjdG9yeSk6IFJlZ2lzdHJ5ID0+IHtcbiAgICBsb2dnZXIuZGVidWcoYENyZWF0aW5nIG5ldyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcblxuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSByZWdpc3RyeSB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoaXMgaHViXG4gICAgY29uc3QgcmVnaXN0cnkgPSBmYWN0b3J5KHR5cGUsIGh1Yik7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgcmVnaXN0cnkgaGFzIGEgcmVmZXJlbmNlIHRvIHRoaXMgaHViIGlmIG5vdCBhbHJlYWR5IHNldFxuICAgIGlmICghKCdyZWdpc3RyeUh1YicgaW4gcmVnaXN0cnkpIHx8IHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViICE9PSBodWIpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHJlZ2lzdHJ5SHViIGlzIG9wdGlvbmFsIGFuZCBtYXkgYmUgcmVhZG9ubHksIGJ1dCB3ZSB3YW50IHRvIHNldCBpdCBmb3IgaHViIGF3YXJlbmVzc1xuICAgICAgcmVnaXN0cnkucmVnaXN0cnlIdWIgPSBodWI7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGNyZWF0ZWQgcmVnaXN0cnlcbiAgICByZWdpc3RyaWVzW3R5cGVdID0gcmVnaXN0cnk7XG4gICAgbG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgY3JlYXRlZCBhbmQgcmVnaXN0ZXJlZCBuZXcgcmVnaXN0cnkgd2l0aCB0eXBlOiAke3R5cGV9YCk7XG5cbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH07XG5cbiAgY29uc3QgcmVnaXN0ZXJSZWdpc3RyeSA9IChyZWdpc3RyeTogUmVnaXN0cnkpOiB2b2lkID0+IHtcbiAgICBjb25zdCB0eXBlID0gcmVnaXN0cnkudHlwZTtcbiAgICBsb2dnZXIuZGVidWcoYFJlZ2lzdGVyaW5nIHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuXG4gICAgaWYgKHJlZ2lzdHJpZXNbdHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG5cbiAgICByZWdpc3RyaWVzW3R5cGVdID0gcmVnaXN0cnk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgcmVnaXN0cnkgaGFzIGEgcmVmZXJlbmNlIHRvIHRoaXMgaHViIGlmIG5vdCBhbHJlYWR5IHNldFxuICAgIGlmICghKCdyZWdpc3RyeUh1YicgaW4gcmVnaXN0cnkpIHx8IHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViICE9PSBodWIpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHJlZ2lzdHJ5SHViIGlzIG9wdGlvbmFsIGFuZCBtYXkgYmUgcmVhZG9ubHksIGJ1dCB3ZSB3YW50IHRvIHNldCBpdCBmb3IgaHViIGF3YXJlbmVzc1xuICAgICAgcmVnaXN0cnkucmVnaXN0cnlIdWIgPSBodWI7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgfTtcblxuICBjb25zdCBnZXQgPSA8XG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gID4oXG4gICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICBrdGE6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgICBvcHRpb25zPzogeyBzY29wZXM/OiBzdHJpbmdbXTsgY2xpZW50PzogQ2xpZW50SWRlbnRpZmllciB9LFxuICAgICk6IEluc3RhbmNlPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBudWxsID0+IHtcbiAgICBsb2dnZXIuZGVidWcoYExvb2tpbmcgdXAgaW5zdGFuY2UgZm9yIHR5cGU6ICR7dHlwZX0sIGt0YTogJHtrdGEuam9pbignLicpfSwgc2NvcGVzOiAke29wdGlvbnM/LnNjb3Blcz8uam9pbignLCcpIHx8ICdub25lJ31gKTtcblxuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gcmVnaXN0cmllc1t0eXBlXTtcbiAgICBpZiAoIXJlZ2lzdHJ5KSB7XG4gICAgICBjb25zdCBhdmFpbGFibGVUeXBlcyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJpZXMpO1xuICAgICAgdGhyb3cgbmV3IFJlZ2lzdHJ5VHlwZU5vdEZvdW5kRXJyb3IodHlwZSwgYXZhaWxhYmxlVHlwZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpc3RyeS5nZXQoa3RhLCBvcHRpb25zKTtcbiAgfTtcblxuICBjb25zdCBnZXRSZWdpc3RyeSA9ICh0eXBlOiBzdHJpbmcpOiBSZWdpc3RyeSB8IG51bGwgPT4ge1xuICAgIHJldHVybiByZWdpc3RyaWVzW3R5cGVdIHx8IG51bGw7XG4gIH07XG5cbiAgY29uc3QgZ2V0UmVnaXN0ZXJlZFR5cGVzID0gKCk6IHN0cmluZ1tdID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cmllcyk7XG4gIH07XG5cbiAgY29uc3QgdW5yZWdpc3RlclJlZ2lzdHJ5ID0gKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICBkZWxldGUgcmVnaXN0cmllc1t0eXBlXTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgVW5yZWdpc3RlcmVkIHJlZ2lzdHJ5IHVuZGVyIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgY29uc3QgZ2V0QWxsQ29vcmRpbmF0ZXMgPSAoKTogQ29vcmRpbmF0ZVdpdGhSZWdpc3RyeVtdID0+IHtcbiAgICBjb25zdCBhbGxDb29yZGluYXRlczogQ29vcmRpbmF0ZVdpdGhSZWdpc3RyeVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHJlZ2lzdHJ5VHlwZSBpbiByZWdpc3RyaWVzKSB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IHJlZ2lzdHJpZXNbcmVnaXN0cnlUeXBlXTtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcmVnaXN0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcblxuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChjb29yZGluYXRlID0+IHtcbiAgICAgICAgYWxsQ29vcmRpbmF0ZXMucHVzaCh7XG4gICAgICAgICAgY29vcmRpbmF0ZSxcbiAgICAgICAgICByZWdpc3RyeVR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoYFJldHJpZXZlZCAke2FsbENvb3JkaW5hdGVzLmxlbmd0aH0gdG90YWwgY29vcmRpbmF0ZXMgZnJvbSAke09iamVjdC5rZXlzKHJlZ2lzdHJpZXMpLmxlbmd0aH0gcmVnaXN0cmllc2ApO1xuICAgIHJldHVybiBhbGxDb29yZGluYXRlcztcbiAgfTtcblxuICBjb25zdCBodWI6IFJlZ2lzdHJ5SHViID0ge1xuICAgIGNyZWF0ZVJlZ2lzdHJ5LFxuICAgIHJlZ2lzdGVyUmVnaXN0cnksXG4gICAgZ2V0LFxuICAgIGdldFJlZ2lzdHJ5LFxuICAgIGdldFJlZ2lzdGVyZWRUeXBlcyxcbiAgICBnZXRBbGxDb29yZGluYXRlcyxcbiAgICB1bnJlZ2lzdGVyUmVnaXN0cnksXG4gIH0gYXMgdW5rbm93biBhcyBSZWdpc3RyeUh1YjtcblxuICByZXR1cm4gaHViO1xufTtcbiIsImltcG9ydCB7IFJlZ2lzdHJ5RXJyb3IgfSBmcm9tICcuL1JlZ2lzdHJ5RXJyb3InO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGluc3RhbmNlLXJlbGF0ZWQgZXJyb3JzXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbnN0YW5jZUVycm9yIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBrZXlQYXRoOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGtleVBhdGg6IHN0cmluZ1tdLCByZWdpc3RyeVR5cGU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcmVnaXN0cnlUeXBlLCB7IC4uLmNvbnRleHQsIGtleVBhdGggfSk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGFuIGluc3RhbmNlIGNhbm5vdCBiZSBmb3VuZCBmb3IgYSBnaXZlbiBrZXkgcGF0aFxuICovXG5leHBvcnQgY2xhc3MgSW5zdGFuY2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBtaXNzaW5nS2V5Pzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGtleVBhdGg6IHN0cmluZ1tdLCBtaXNzaW5nS2V5Pzogc3RyaW5nLCByZWdpc3RyeVR5cGU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbignLicpO1xuICAgIGxldCBtZXNzYWdlID0gYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn1gO1xuXG4gICAgaWYgKG1pc3NpbmdLZXkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCwgTWlzc2luZyBrZXk6ICR7bWlzc2luZ0tleX1gO1xuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgeyAuLi5jb250ZXh0LCBtaXNzaW5nS2V5IH0pO1xuICAgIHRoaXMubWlzc2luZ0tleSA9IG1pc3NpbmdLZXk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBubyBpbnN0YW5jZXMgYXJlIHJlZ2lzdGVyZWQgZm9yIGEga2V5IHBhdGggdGhhdCBleGlzdHMgaW4gdGhlIHRyZWVcbiAqL1xuZXhwb3J0IGNsYXNzIE5vSW5zdGFuY2VzUmVnaXN0ZXJlZEVycm9yIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGg6IHN0cmluZ1tdLCByZWdpc3RyeVR5cGU/OiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbignLicpO1xuICAgIHN1cGVyKFxuICAgICAgYE5vIGluc3RhbmNlcyByZWdpc3RlcmVkIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfS4gYCArXG4gICAgICBgVGhlIGtleSBwYXRoIGV4aXN0cyBpbiB0aGUgcmVnaXN0cnkgdHJlZSBidXQgY29udGFpbnMgbm8gaW5zdGFuY2VzLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBubyBpbnN0YW5jZXMgYXJlIGF2YWlsYWJsZSAoZW1wdHkgaW5zdGFuY2VzIGFycmF5KVxuICovXG5leHBvcnQgY2xhc3MgTm9JbnN0YW5jZXNBdmFpbGFibGVFcnJvciBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoOiBzdHJpbmdbXSwgcmVnaXN0cnlUeXBlPzogc3RyaW5nLCBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oJy4nKTtcbiAgICBzdXBlcihcbiAgICAgIGBObyBpbnN0YW5jZXMgYXZhaWxhYmxlIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfS4gYCArXG4gICAgICBgVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIGFuIGludGVybmFsIHJlZ2lzdHJ5IHN0YXRlIGlzc3VlLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBubyBpbnN0YW5jZSBtYXRjaGVzIHRoZSByZXF1ZXN0ZWQgc2NvcGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBTY29wZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVlc3RlZFNjb3Blczogc3RyaW5nW107XG4gIHB1YmxpYyByZWFkb25seSBhdmFpbGFibGVTY29wZXM6IHN0cmluZ1tdW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAga2V5UGF0aDogc3RyaW5nW10sXG4gICAgcmVxdWVzdGVkU2NvcGVzOiBzdHJpbmdbXSxcbiAgICBhdmFpbGFibGVTY29wZXM6IHN0cmluZ1tdW10gPSBbXSxcbiAgICByZWdpc3RyeVR5cGU/OiBzdHJpbmdcbiAgKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbignLicpO1xuICAgIGNvbnN0IHNjb3Blc1N0ciA9IHJlcXVlc3RlZFNjb3Blcy5qb2luKCcsICcpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVNjb3Blc1N0ciA9IGF2YWlsYWJsZVNjb3Blcy5tYXAoc2NvcGVzID0+IGBbJHtzY29wZXMuam9pbignLCAnKX1dYCkuam9pbignLCAnKTtcblxuICAgIGxldCBtZXNzYWdlID0gYE5vIGluc3RhbmNlIGZvdW5kIG1hdGNoaW5nIHNjb3BlczogJHtzY29wZXNTdHJ9IGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfWA7XG4gICAgaWYgKGF2YWlsYWJsZVNjb3Blcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlICs9IGAuIEF2YWlsYWJsZSBzY29wZXM6ICR7YXZhaWxhYmxlU2NvcGVzU3RyfWA7XG4gICAgfVxuXG4gICAgc3VwZXIobWVzc2FnZSwga2V5UGF0aCwgcmVnaXN0cnlUeXBlLCB7IHJlcXVlc3RlZFNjb3BlcywgYXZhaWxhYmxlU2NvcGVzIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkU2NvcGVzID0gcmVxdWVzdGVkU2NvcGVzO1xuICAgIHRoaXMuYXZhaWxhYmxlU2NvcGVzID0gYXZhaWxhYmxlU2NvcGVzO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBrZXkgcGF0aCBoYXMgbm8gY2hpbGRyZW4gYnV0IGNoaWxkcmVuIGFyZSBleHBlY3RlZFxuICovXG5leHBvcnQgY2xhc3MgTm9DaGlsZHJlbkF2YWlsYWJsZUVycm9yIGV4dGVuZHMgSW5zdGFuY2VFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBwYXJlbnRLZXk6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihrZXlQYXRoOiBzdHJpbmdbXSwgcGFyZW50S2V5OiBzdHJpbmcsIHJlZ2lzdHJ5VHlwZT86IHN0cmluZywgY29udGV4dD86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKCcuJyk7XG4gICAgc3VwZXIoXG4gICAgICBgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfSwgTm8gY2hpbGRyZW4gZm9yOiAke3BhcmVudEtleX0uIGAgK1xuICAgICAgYFRoZSBwYXRoIGNhbm5vdCBiZSB0cmF2ZXJzZWQgZnVydGhlciBhcyAnJHtwYXJlbnRLZXl9JyBoYXMgbm8gY2hpbGQgbm9kZXMuYCxcbiAgICAgIGtleVBhdGgsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IC4uLmNvbnRleHQsIHBhcmVudEtleSB9XG4gICAgKTtcbiAgICB0aGlzLnBhcmVudEtleSA9IHBhcmVudEtleTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVnaXN0cnlFcnJvciB9IGZyb20gJy4vUmVnaXN0cnlFcnJvcic7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29vcmRpbmF0ZS1yZWxhdGVkIGVycm9yc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29vcmRpbmF0ZUVycm9yIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBrdGE/OiBhbnk7XG4gIHB1YmxpYyByZWFkb25seSBzY29wZXM/OiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGt0YT86IGFueSwgc2NvcGVzPzogc3RyaW5nW10sIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJycsIHsgLi4uY29udGV4dCwga3RhLCBzY29wZXMgfSk7XG4gICAgdGhpcy5rdGEgPSBrdGE7XG4gICAgdGhpcy5zY29wZXMgPSBzY29wZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBjb29yZGluYXRlIGNyZWF0aW9uIGZhaWxzIGR1ZSB0byBpbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDb29yZGluYXRlRXJyb3IgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrdGE6IGFueSwgc2NvcGVzOiBzdHJpbmdbXSwgcmVhc29uOiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBjb29yZGluYXRlIHBhcmFtZXRlcnM6ICR7cmVhc29ufS4gYCArXG4gICAgICBgS1RBOiAke0pTT04uc3RyaW5naWZ5KGt0YSl9LCBTY29wZXM6IFske3Njb3Blcy5qb2luKCcsICcpfV1gLFxuICAgICAga3RhLFxuICAgICAgc2NvcGVzLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24gfVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBLVEEgKEtleSBUeXBlIEFycmF5KSBpcyBpbnZhbGlkXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkS1RBRXJyb3IgZXh0ZW5kcyBDb29yZGluYXRlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrdGE6IGFueSwgcmVhc29uOiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBLVEEgKEtleSBUeXBlIEFycmF5KTogJHtyZWFzb259LiBgICtcbiAgICAgIGBFeHBlY3RlZCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncywgZ290OiAke0pTT04uc3RyaW5naWZ5KGt0YSl9YCxcbiAgICAgIGt0YSxcbiAgICAgIFtdLFxuICAgICAgeyAuLi5jb250ZXh0LCByZWFzb24gfVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBzY29wZXMgYXJyYXkgY29udGFpbnMgaW52YWxpZCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTY29wZXNFcnJvciBleHRlbmRzIENvb3JkaW5hdGVFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBpbnZhbGlkU2NvcGVzOiBhbnlbXTtcblxuICBjb25zdHJ1Y3RvcihzY29wZXM6IGFueVtdLCBpbnZhbGlkU2NvcGVzOiBhbnlbXSwgcmVhc29uOiBzdHJpbmcsIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBzY29wZXM6ICR7cmVhc29ufS4gYCArXG4gICAgICBgSW52YWxpZCBzY29wZSB2YWx1ZXM6ICR7SlNPTi5zdHJpbmdpZnkoaW52YWxpZFNjb3Blcyl9YCxcbiAgICAgIG51bGwsXG4gICAgICBzY29wZXMuZmlsdGVyKHMgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnKSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uLCBpbnZhbGlkU2NvcGVzIH1cbiAgICApO1xuICAgIHRoaXMuaW52YWxpZFNjb3BlcyA9IGludmFsaWRTY29wZXM7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJsb2dnZXIiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVJlZ2lzdHJ5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-registry/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/api/WidgetAPI.ts":
/*!*************************************!*\
  !*** ./src/client/api/WidgetAPI.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   widgetApi: () => (/* binding */ widgetApi),\n/* harmony export */   widgetTypeApi: () => (/* binding */ widgetTypeApi)\n/* harmony export */ });\n/* harmony import */ var _fjell_client_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/client-api */ \"(app-pages-browser)/../fjell-client-api/dist/index.js\");\n/* harmony import */ var _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/http-api */ \"(app-pages-browser)/../fjell-http-api/dist/index.js\");\n\n\n// Create HttpApi configuration for browser environment\nconst createApiParams = function() {\n    let baseUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'http://localhost:3001/api';\n    return {\n        config: {\n            url: baseUrl,\n            requestCredentials: 'same-origin',\n            clientName: 'fjell-sample-app-widget-client'\n        },\n        populateAuthHeader: async (isAuthenticated, headers)=>{\n            // In a real app, you'd get the token from your auth system\n            if (isAuthenticated) {\n                const token = localStorage.getItem('authToken') || 'demo-token';\n                headers['Authorization'] = \"Bearer \".concat(token);\n            }\n        },\n        uploadAsyncFile: async ()=>{\n            // Mock implementation for file uploads\n            return {\n                headers: {},\n                status: 200,\n                mimeType: 'application/json',\n                body: JSON.stringify({\n                    success: true\n                })\n            };\n        }\n    };\n};\n// Create HttpApi instance\nconst apiParams = createApiParams();\nconst baseHttpApi = (0,_fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.getHttpApi)(apiParams);\n// fjell-express-router returns data directly, no wrapper needed\nconst httpApi = baseHttpApi;\n// Create Fjell Client APIs for Widget and WidgetType\nconst widgetApi = (0,_fjell_client_api__WEBPACK_IMPORTED_MODULE_0__.createPItemApi)(httpApi, 'widget', 'widgets', {\n    readAuthenticated: false,\n    writeAuthenticated: true,\n    enableErrorHandling: true,\n    retryConfig: {\n        maxRetries: 3,\n        initialDelayMs: 1000,\n        maxDelayMs: 10000,\n        backoffMultiplier: 2,\n        enableJitter: true\n    }\n});\nconst widgetTypeApi = (0,_fjell_client_api__WEBPACK_IMPORTED_MODULE_0__.createPItemApi)(httpApi, 'widgetType', 'widget-types', {\n    readAuthenticated: false,\n    writeAuthenticated: true,\n    enableErrorHandling: true,\n    retryConfig: {\n        maxRetries: 3,\n        initialDelayMs: 1000,\n        maxDelayMs: 10000,\n        backoffMultiplier: 2,\n        enableJitter: true\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvYXBpL1dpZGdldEFQSS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ0w7QUFZeEQsdURBQXVEO0FBQ3ZELE1BQU1FLGtCQUFrQjtRQUFDQywyRUFBa0I7V0FBNEM7UUFDckZDLFFBQVE7WUFDTkMsS0FBS0Y7WUFDTEcsb0JBQW9CO1lBQ3BCQyxZQUFZO1FBQ2Q7UUFDQUMsb0JBQW9CLE9BQU9DLGlCQUEwQkM7WUFDbkQsMkRBQTJEO1lBQzNELElBQUlELGlCQUFpQjtnQkFDbkIsTUFBTUUsUUFBUUMsYUFBYUMsT0FBTyxDQUFDLGdCQUFnQjtnQkFDbkRILE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxVQUFnQixPQUFOQztZQUN2QztRQUNGO1FBQ0FHLGlCQUFpQjtZQUNmLHVDQUF1QztZQUN2QyxPQUFPO2dCQUNMSixTQUFTLENBQUM7Z0JBQ1ZLLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRUMsU0FBUztnQkFBSztZQUN2QztRQUNGO0lBQ0Y7O0FBRUEsMEJBQTBCO0FBQzFCLE1BQU1DLFlBQVluQjtBQUNsQixNQUFNb0IsY0FBY3JCLDJEQUFVQSxDQUFDb0I7QUFFL0IsZ0VBQWdFO0FBQ2hFLE1BQU1FLFVBQVVEO0FBRWhCLHFEQUFxRDtBQUM5QyxNQUFNRSxZQUF3Q3hCLGlFQUFjQSxDQUNqRXVCLFNBQ0EsVUFDQSxXQUNBO0lBQ0VFLG1CQUFtQjtJQUNuQkMsb0JBQW9CO0lBQ3BCQyxxQkFBcUI7SUFDckJDLGFBQWE7UUFDWEMsWUFBWTtRQUNaQyxnQkFBZ0I7UUFDaEJDLFlBQVk7UUFDWkMsbUJBQW1CO1FBQ25CQyxjQUFjO0lBQ2hCO0FBQ0YsR0FDQTtBQUVLLE1BQU1DLGdCQUFvRGxDLGlFQUFjQSxDQUM3RXVCLFNBQ0EsY0FDQSxnQkFDQTtJQUNFRSxtQkFBbUI7SUFDbkJDLG9CQUFvQjtJQUNwQkMscUJBQXFCO0lBQ3JCQyxhQUFhO1FBQ1hDLFlBQVk7UUFDWkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLG1CQUFtQjtRQUNuQkMsY0FBYztJQUNoQjtBQUNGLEdBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtc2FtcGxlLWFwcC9zcmMvY2xpZW50L2FwaS9XaWRnZXRBUEkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUEl0ZW1BcGksIFBJdGVtQXBpIH0gZnJvbSAnQGZqZWxsL2NsaWVudC1hcGknO1xuaW1wb3J0IHsgQXBpUGFyYW1zLCBnZXRIdHRwQXBpIH0gZnJvbSAnQGZqZWxsL2h0dHAtYXBpJztcbmltcG9ydCB0eXBlIHsgV2lkZ2V0IH0gZnJvbSAnLi4vLi4vbW9kZWwvV2lkZ2V0JztcbmltcG9ydCB0eXBlIHsgV2lkZ2V0VHlwZSB9IGZyb20gJy4uLy4uL21vZGVsL1dpZGdldFR5cGUnO1xuXG4vLyBXaWRnZXQgU3VtbWFyeSBpbnRlcmZhY2UgZm9yIGJ1c2luZXNzIGFuYWx5dGljc1xuZXhwb3J0IGludGVyZmFjZSBXaWRnZXRTdW1tYXJ5IHtcbiAgdG90YWw6IG51bWJlcjtcbiAgYWN0aXZlOiBudW1iZXI7XG4gIGluYWN0aXZlOiBudW1iZXI7XG4gIGFjdGl2ZVBlcmNlbnRhZ2U6IG51bWJlcjtcbn1cblxuLy8gQ3JlYXRlIEh0dHBBcGkgY29uZmlndXJhdGlvbiBmb3IgYnJvd3NlciBlbnZpcm9ubWVudFxuY29uc3QgY3JlYXRlQXBpUGFyYW1zID0gKGJhc2VVcmw6IHN0cmluZyA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpJyk6IEFwaVBhcmFtcyA9PiAoe1xuICBjb25maWc6IHtcbiAgICB1cmw6IGJhc2VVcmwsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIGNsaWVudE5hbWU6ICdmamVsbC1zYW1wbGUtYXBwLXdpZGdldC1jbGllbnQnXG4gIH0sXG4gIHBvcHVsYXRlQXV0aEhlYWRlcjogYXN5bmMgKGlzQXV0aGVudGljYXRlZDogYm9vbGVhbiwgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSdkIGdldCB0aGUgdG9rZW4gZnJvbSB5b3VyIGF1dGggc3lzdGVtXG4gICAgaWYgKGlzQXV0aGVudGljYXRlZCkge1xuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJykgfHwgJ2RlbW8tdG9rZW4nO1xuICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICB9LFxuICB1cGxvYWRBc3luY0ZpbGU6IGFzeW5jICgpID0+IHtcbiAgICAvLyBNb2NrIGltcGxlbWVudGF0aW9uIGZvciBmaWxlIHVwbG9hZHNcbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyczoge30sXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gQ3JlYXRlIEh0dHBBcGkgaW5zdGFuY2VcbmNvbnN0IGFwaVBhcmFtcyA9IGNyZWF0ZUFwaVBhcmFtcygpO1xuY29uc3QgYmFzZUh0dHBBcGkgPSBnZXRIdHRwQXBpKGFwaVBhcmFtcyk7XG5cbi8vIGZqZWxsLWV4cHJlc3Mtcm91dGVyIHJldHVybnMgZGF0YSBkaXJlY3RseSwgbm8gd3JhcHBlciBuZWVkZWRcbmNvbnN0IGh0dHBBcGkgPSBiYXNlSHR0cEFwaTtcblxuLy8gQ3JlYXRlIEZqZWxsIENsaWVudCBBUElzIGZvciBXaWRnZXQgYW5kIFdpZGdldFR5cGVcbmV4cG9ydCBjb25zdCB3aWRnZXRBcGk6IFBJdGVtQXBpPFdpZGdldCwgJ3dpZGdldCc+ID0gY3JlYXRlUEl0ZW1BcGkoXG4gIGh0dHBBcGksXG4gICd3aWRnZXQnLFxuICAnd2lkZ2V0cycsIC8vIEFQSSBwYXRoXG4gIHtcbiAgICByZWFkQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgd3JpdGVBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIGVuYWJsZUVycm9ySGFuZGxpbmc6IHRydWUsXG4gICAgcmV0cnlDb25maWc6IHtcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICBpbml0aWFsRGVsYXlNczogMTAwMCxcbiAgICAgIG1heERlbGF5TXM6IDEwMDAwLFxuICAgICAgYmFja29mZk11bHRpcGxpZXI6IDIsXG4gICAgICBlbmFibGVKaXR0ZXI6IHRydWVcbiAgICB9XG4gIH1cbik7XG5cbmV4cG9ydCBjb25zdCB3aWRnZXRUeXBlQXBpOiBQSXRlbUFwaTxXaWRnZXRUeXBlLCAnd2lkZ2V0VHlwZSc+ID0gY3JlYXRlUEl0ZW1BcGkoXG4gIGh0dHBBcGksXG4gICd3aWRnZXRUeXBlJyxcbiAgJ3dpZGdldC10eXBlcycsIC8vIEFQSSBwYXRoXG4gIHtcbiAgICByZWFkQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgd3JpdGVBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIGVuYWJsZUVycm9ySGFuZGxpbmc6IHRydWUsXG4gICAgcmV0cnlDb25maWc6IHtcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICBpbml0aWFsRGVsYXlNczogMTAwMCxcbiAgICAgIG1heERlbGF5TXM6IDEwMDAwLFxuICAgICAgYmFja29mZk11bHRpcGxpZXI6IDIsXG4gICAgICBlbmFibGVKaXR0ZXI6IHRydWVcbiAgICB9XG4gIH1cbik7XG4iXSwibmFtZXMiOlsiY3JlYXRlUEl0ZW1BcGkiLCJnZXRIdHRwQXBpIiwiY3JlYXRlQXBpUGFyYW1zIiwiYmFzZVVybCIsImNvbmZpZyIsInVybCIsInJlcXVlc3RDcmVkZW50aWFscyIsImNsaWVudE5hbWUiLCJwb3B1bGF0ZUF1dGhIZWFkZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJoZWFkZXJzIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidXBsb2FkQXN5bmNGaWxlIiwic3RhdHVzIiwibWltZVR5cGUiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInN1Y2Nlc3MiLCJhcGlQYXJhbXMiLCJiYXNlSHR0cEFwaSIsImh0dHBBcGkiLCJ3aWRnZXRBcGkiLCJyZWFkQXV0aGVudGljYXRlZCIsIndyaXRlQXV0aGVudGljYXRlZCIsImVuYWJsZUVycm9ySGFuZGxpbmciLCJyZXRyeUNvbmZpZyIsIm1heFJldHJpZXMiLCJpbml0aWFsRGVsYXlNcyIsIm1heERlbGF5TXMiLCJiYWNrb2ZmTXVsdGlwbGllciIsImVuYWJsZUppdHRlciIsIndpZGdldFR5cGVBcGkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/api/WidgetAPI.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/cache/WidgetTypeCache.ts":
/*!*********************************************!*\
  !*** ./src/client/cache/WidgetTypeCache.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   widgetTypeCache: () => (/* binding */ widgetTypeCache),\n/* harmony export */   widgetTypeCacheUtils: () => (/* binding */ widgetTypeCacheUtils)\n/* harmony export */ });\n/* harmony import */ var _fjell_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/cache */ \"(app-pages-browser)/../fjell-cache/dist/index.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/registry */ \"(app-pages-browser)/../fjell-registry/dist/index.js\");\n/* harmony import */ var _api_WidgetAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/WidgetAPI */ \"(app-pages-browser)/./src/client/api/WidgetAPI.ts\");\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ \"(app-pages-browser)/./src/client/cache/registry.ts\");\n\n\n\n\n// Cache configuration optimized for browser environment with IndexedDB\nconst createCacheOptions = (dbName, storeName)=>({\n        cacheType: 'indexedDB',\n        indexedDBConfig: {\n            dbName,\n            version: 1,\n            storeName\n        },\n        enableDebugLogging: true,\n        autoSync: true,\n        maxRetries: 5,\n        retryDelay: 2000,\n        ttl: 900000,\n        evictionPolicy: 'lru',\n        evictionConfig: {\n            type: 'lru'\n        }\n    });\n// WidgetType Cache Instance\nconst widgetTypeCache = (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_0__.createCache)(_api_WidgetAPI__WEBPACK_IMPORTED_MODULE_2__.widgetTypeApi, (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_1__.createCoordinate)('widgetType'), _registry__WEBPACK_IMPORTED_MODULE_3__.cacheRegistry, createCacheOptions('WidgetAppCache_WidgetTypes', 'widgetTypes'));\n// Utility functions for widget type cache management\nconst widgetTypeCacheUtils = {\n    /**\n   * Clear widget type cache\n   */ clear: async ()=>{\n        await widgetTypeCache.operations.reset();\n    },\n    /**\n   * Get widget type cache information for debugging\n   */ getCacheInfo: ()=>widgetTypeCache.getCacheInfo(),\n    /**\n   * Manually invalidate widget type caches when external changes occur\n   */ invalidate: ()=>{\n        widgetTypeCache.cacheMap.clearQueryResults();\n    },\n    /**\n   * Get widget type cache statistics for monitoring\n   */ getCacheStats: ()=>{\n        const sizeInfo = widgetTypeCache.cacheMap.getCurrentSize();\n        return {\n            ...sizeInfo\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvY2FjaGUvV2lkZ2V0VHlwZUNhY2hlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrRDtBQUNDO0FBRUY7QUFDTjtBQUUzQyx1RUFBdUU7QUFDdkUsTUFBTUkscUJBQXFCLENBQUNDLFFBQWdCQyxZQUF1QjtRQUNqRUMsV0FBVztRQUNYQyxpQkFBaUI7WUFDZkg7WUFDQUksU0FBUztZQUNUSDtRQUNGO1FBQ0FJLG9CQUFvQjtRQUNwQkMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLFlBQVk7UUFDWkMsS0FBSztRQUNMQyxnQkFBZ0I7UUFDaEJDLGdCQUFnQjtZQUNkQyxNQUFNO1FBQ1I7SUFDRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNQyxrQkFBbURsQix5REFBV0EsQ0FDekVFLHlEQUFhQSxFQUNiRCxpRUFBZ0JBLENBQUMsZUFDakJFLG9EQUFhQSxFQUNiQyxtQkFBbUIsOEJBQThCLGdCQUNqRDtBQUVGLHFEQUFxRDtBQUM5QyxNQUFNZSx1QkFBdUI7SUFDbEM7O0dBRUMsR0FDREMsT0FBTztRQUNMLE1BQU1GLGdCQUFnQkcsVUFBVSxDQUFDQyxLQUFLO0lBQ3hDO0lBRUE7O0dBRUMsR0FDREMsY0FBYyxJQUFNTCxnQkFBZ0JLLFlBQVk7SUFFaEQ7O0dBRUMsR0FDREMsWUFBWTtRQUNWTixnQkFBZ0JPLFFBQVEsQ0FBQ0MsaUJBQWlCO0lBQzVDO0lBRUE7O0dBRUMsR0FDREMsZUFBZTtRQUNiLE1BQU1DLFdBQVdWLGdCQUFnQk8sUUFBUSxDQUFDSSxjQUFjO1FBQ3hELE9BQU87WUFDTCxHQUFHRCxRQUFRO1FBQ2I7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtc2FtcGxlLWFwcC9zcmMvY2xpZW50L2NhY2hlL1dpZGdldFR5cGVDYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYWNoZSwgY3JlYXRlQ2FjaGUgfSBmcm9tICdAZmplbGwvY2FjaGUnO1xuaW1wb3J0IHsgY3JlYXRlQ29vcmRpbmF0ZSB9IGZyb20gJ0BmamVsbC9yZWdpc3RyeSc7XG5pbXBvcnQgdHlwZSB7IFdpZGdldFR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbC9XaWRnZXRUeXBlJztcbmltcG9ydCB7IHdpZGdldFR5cGVBcGkgfSBmcm9tICcuLi9hcGkvV2lkZ2V0QVBJJztcbmltcG9ydCB7IGNhY2hlUmVnaXN0cnkgfSBmcm9tICcuL3JlZ2lzdHJ5JztcblxuLy8gQ2FjaGUgY29uZmlndXJhdGlvbiBvcHRpbWl6ZWQgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnQgd2l0aCBJbmRleGVkREJcbmNvbnN0IGNyZWF0ZUNhY2hlT3B0aW9ucyA9IChkYk5hbWU6IHN0cmluZywgc3RvcmVOYW1lOiBzdHJpbmcpID0+ICh7XG4gIGNhY2hlVHlwZTogJ2luZGV4ZWREQicgYXMgY29uc3QsXG4gIGluZGV4ZWREQkNvbmZpZzoge1xuICAgIGRiTmFtZSxcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHN0b3JlTmFtZVxuICB9LFxuICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IHRydWUsIC8vIEVuYWJsZSBkZWJ1ZyBsb2dnaW5nXG4gIGF1dG9TeW5jOiB0cnVlLFxuICBtYXhSZXRyaWVzOiA1LFxuICByZXRyeURlbGF5OiAyMDAwLFxuICB0dGw6IDkwMDAwMCwgLy8gMTUgbWludXRlc1xuICBldmljdGlvblBvbGljeTogJ2xydScgYXMgY29uc3QsXG4gIGV2aWN0aW9uQ29uZmlnOiB7XG4gICAgdHlwZTogJ2xydScgYXMgY29uc3RcbiAgfVxufSk7XG5cbi8vIFdpZGdldFR5cGUgQ2FjaGUgSW5zdGFuY2VcbmV4cG9ydCBjb25zdCB3aWRnZXRUeXBlQ2FjaGU6IENhY2hlPFdpZGdldFR5cGUsICd3aWRnZXRUeXBlJz4gPSBjcmVhdGVDYWNoZShcbiAgd2lkZ2V0VHlwZUFwaSxcbiAgY3JlYXRlQ29vcmRpbmF0ZSgnd2lkZ2V0VHlwZScpLFxuICBjYWNoZVJlZ2lzdHJ5LFxuICBjcmVhdGVDYWNoZU9wdGlvbnMoJ1dpZGdldEFwcENhY2hlX1dpZGdldFR5cGVzJywgJ3dpZGdldFR5cGVzJylcbik7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3aWRnZXQgdHlwZSBjYWNoZSBtYW5hZ2VtZW50XG5leHBvcnQgY29uc3Qgd2lkZ2V0VHlwZUNhY2hlVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBDbGVhciB3aWRnZXQgdHlwZSBjYWNoZVxuICAgKi9cbiAgY2xlYXI6IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB3aWRnZXRUeXBlQ2FjaGUub3BlcmF0aW9ucy5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgd2lkZ2V0IHR5cGUgY2FjaGUgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgKi9cbiAgZ2V0Q2FjaGVJbmZvOiAoKSA9PiB3aWRnZXRUeXBlQ2FjaGUuZ2V0Q2FjaGVJbmZvKCksXG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGludmFsaWRhdGUgd2lkZ2V0IHR5cGUgY2FjaGVzIHdoZW4gZXh0ZXJuYWwgY2hhbmdlcyBvY2N1clxuICAgKi9cbiAgaW52YWxpZGF0ZTogKCkgPT4ge1xuICAgIHdpZGdldFR5cGVDYWNoZS5jYWNoZU1hcC5jbGVhclF1ZXJ5UmVzdWx0cygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgd2lkZ2V0IHR5cGUgY2FjaGUgc3RhdGlzdGljcyBmb3IgbW9uaXRvcmluZ1xuICAgKi9cbiAgZ2V0Q2FjaGVTdGF0czogKCkgPT4ge1xuICAgIGNvbnN0IHNpemVJbmZvID0gd2lkZ2V0VHlwZUNhY2hlLmNhY2hlTWFwLmdldEN1cnJlbnRTaXplKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNpemVJbmZvXG4gICAgfTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDYWNoZSIsImNyZWF0ZUNvb3JkaW5hdGUiLCJ3aWRnZXRUeXBlQXBpIiwiY2FjaGVSZWdpc3RyeSIsImNyZWF0ZUNhY2hlT3B0aW9ucyIsImRiTmFtZSIsInN0b3JlTmFtZSIsImNhY2hlVHlwZSIsImluZGV4ZWREQkNvbmZpZyIsInZlcnNpb24iLCJlbmFibGVEZWJ1Z0xvZ2dpbmciLCJhdXRvU3luYyIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwidHRsIiwiZXZpY3Rpb25Qb2xpY3kiLCJldmljdGlvbkNvbmZpZyIsInR5cGUiLCJ3aWRnZXRUeXBlQ2FjaGUiLCJ3aWRnZXRUeXBlQ2FjaGVVdGlscyIsImNsZWFyIiwib3BlcmF0aW9ucyIsInJlc2V0IiwiZ2V0Q2FjaGVJbmZvIiwiaW52YWxpZGF0ZSIsImNhY2hlTWFwIiwiY2xlYXJRdWVyeVJlc3VsdHMiLCJnZXRDYWNoZVN0YXRzIiwic2l6ZUluZm8iLCJnZXRDdXJyZW50U2l6ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/cache/WidgetTypeCache.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/cache/registry.ts":
/*!**************************************!*\
  !*** ./src/client/cache/registry.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheRegistry: () => (/* binding */ cacheRegistry)\n/* harmony export */ });\n/* harmony import */ var _fjell_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/cache */ \"(app-pages-browser)/../fjell-cache/dist/index.js\");\n\n// Create Cache Registry - centralized registry for all cache instances\nconst cacheRegistry = (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_0__.createRegistry)();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvY2FjaGUvcmVnaXN0cnkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEM7QUFFOUMsdUVBQXVFO0FBQ2hFLE1BQU1DLGdCQUFnQkQsNERBQWNBLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtc2FtcGxlLWFwcC9zcmMvY2xpZW50L2NhY2hlL3JlZ2lzdHJ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlZ2lzdHJ5IH0gZnJvbSAnQGZqZWxsL2NhY2hlJztcblxuLy8gQ3JlYXRlIENhY2hlIFJlZ2lzdHJ5IC0gY2VudHJhbGl6ZWQgcmVnaXN0cnkgZm9yIGFsbCBjYWNoZSBpbnN0YW5jZXNcbmV4cG9ydCBjb25zdCBjYWNoZVJlZ2lzdHJ5ID0gY3JlYXRlUmVnaXN0cnkoKTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVSZWdpc3RyeSIsImNhY2hlUmVnaXN0cnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/cache/registry.ts\n"));

/***/ })

}]);