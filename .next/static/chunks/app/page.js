/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/../fjell-core/dist/index.js":
/*!***********************************!*\
  !*** ../fjell-core/dist/index.js ***!
  \***********************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItemService: () => (/* binding */ AItemService),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   IFactory: () => (/* binding */ IFactory),\n/* harmony export */   IQFactory: () => (/* binding */ IQFactory),\n/* harmony export */   abbrevAgg: () => (/* binding */ abbrevAgg),\n/* harmony export */   abbrevCompoundCondition: () => (/* binding */ abbrevCompoundCondition),\n/* harmony export */   abbrevCondition: () => (/* binding */ abbrevCondition),\n/* harmony export */   abbrevIK: () => (/* binding */ abbrevIK),\n/* harmony export */   abbrevLKA: () => (/* binding */ abbrevLKA),\n/* harmony export */   abbrevQuery: () => (/* binding */ abbrevQuery),\n/* harmony export */   abbrevRef: () => (/* binding */ abbrevRef),\n/* harmony export */   cPK: () => (/* binding */ cPK),\n/* harmony export */   constructPriKey: () => (/* binding */ constructPriKey),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   generateKeyArray: () => (/* binding */ generateKeyArray),\n/* harmony export */   ikToLKA: () => (/* binding */ ikToLKA),\n/* harmony export */   isComItem: () => (/* binding */ isComItem),\n/* harmony export */   isComKey: () => (/* binding */ isComKey),\n/* harmony export */   isComKeyEqual: () => (/* binding */ isComKeyEqual),\n/* harmony export */   isComKeyEqualNormalized: () => (/* binding */ isComKeyEqualNormalized),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isItemKey: () => (/* binding */ isItemKey),\n/* harmony export */   isItemKeyEqual: () => (/* binding */ isItemKeyEqual),\n/* harmony export */   isItemKeyEqualNormalized: () => (/* binding */ isItemKeyEqualNormalized),\n/* harmony export */   isLocKey: () => (/* binding */ isLocKey),\n/* harmony export */   isLocKeyEqual: () => (/* binding */ isLocKeyEqual),\n/* harmony export */   isLocKeyEqualNormalized: () => (/* binding */ isLocKeyEqualNormalized),\n/* harmony export */   isPriItem: () => (/* binding */ isPriItem),\n/* harmony export */   isPriKey: () => (/* binding */ isPriKey),\n/* harmony export */   isPriKeyEqual: () => (/* binding */ isPriKeyEqual),\n/* harmony export */   isPriKeyEqualNormalized: () => (/* binding */ isPriKeyEqualNormalized),\n/* harmony export */   isQueryMatch: () => (/* binding */ isQueryMatch),\n/* harmony export */   isValidComKey: () => (/* binding */ isValidComKey),\n/* harmony export */   isValidItemKey: () => (/* binding */ isValidItemKey),\n/* harmony export */   isValidLocKey: () => (/* binding */ isValidLocKey),\n/* harmony export */   isValidLocKeyArray: () => (/* binding */ isValidLocKeyArray),\n/* harmony export */   isValidPriKey: () => (/* binding */ isValidPriKey),\n/* harmony export */   itemKeyToLocKeyArray: () => (/* binding */ itemKeyToLocKeyArray),\n/* harmony export */   lkaToIK: () => (/* binding */ lkaToIK),\n/* harmony export */   locKeyArrayToItemKey: () => (/* binding */ locKeyArrayToItemKey),\n/* harmony export */   paramsToQuery: () => (/* binding */ paramsToQuery),\n/* harmony export */   primaryType: () => (/* binding */ primaryType),\n/* harmony export */   queryToParams: () => (/* binding */ queryToParams),\n/* harmony export */   toKeyTypeArray: () => (/* binding */ toKeyTypeArray),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys),\n/* harmony export */   validatePK: () => (/* binding */ validatePK)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-core/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/../fjell-core/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! luxon */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/luxon.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/core\");\nvar logger_default = LibLogger;\n// src/dictionary.ts\nvar logger = logger_default.get(\"Dictionary\");\nvar Dictionary = class _Dictionary {\n    set(key, item) {\n        logger.trace(\"set\", {\n            key,\n            item\n        });\n        const hashedKey = this.hashFunction(key);\n        this.map[hashedKey] = {\n            originalKey: key,\n            value: item\n        };\n    }\n    get(key) {\n        logger.trace(\"get\", {\n            key\n        });\n        const hashedKey = this.hashFunction(key);\n        const entry = this.map[hashedKey];\n        return entry && this.keysEqual(entry.originalKey, key) ? entry.value : null;\n    }\n    keysEqual(key1, key2) {\n        return key1 === key2;\n    }\n    delete(key) {\n        logger.trace(\"delete\", {\n            key\n        });\n        const hashedKey = this.hashFunction(key);\n        delete this.map[hashedKey];\n    }\n    keys() {\n        return Object.values(this.map).map((entry)=>entry.originalKey);\n    }\n    values() {\n        return Object.values(this.map).map((entry)=>entry.value);\n    }\n    includesKey(key) {\n        const hashedKey = this.hashFunction(key);\n        const entry = this.map[hashedKey];\n        return entry ? this.keysEqual(entry.originalKey, key) : false;\n    }\n    clone() {\n        const clonedMap = {};\n        Object.entries(this.map).forEach((param)=>{\n            let [hashedKey, entry] = param;\n            clonedMap[hashedKey] = entry.value;\n        });\n        const clone = new _Dictionary(clonedMap, this.hashFunction);\n        clone.map = Object.assign({}, this.map);\n        return clone;\n    }\n    constructor(map, hashFunction){\n        this.map = {};\n        this.hashFunction = (key)=>JSON.stringify(key);\n        if (hashFunction) {\n            this.hashFunction = hashFunction;\n        }\n        if (map) {\n            Object.entries(map).forEach((param)=>{\n                let [hashedKey, value] = param;\n                try {\n                    const originalKey = JSON.parse(hashedKey);\n                    this.map[hashedKey] = {\n                        originalKey,\n                        value\n                    };\n                } catch (e) {\n                    logger.warning(\"Cannot recover original key from legacy map entry\", {\n                        hashedKey\n                    });\n                }\n            });\n        }\n    }\n};\n// src/item/IFactory.ts\n\n// src/key/KUtils.ts\nvar logger2 = logger_default.get(\"KUtils\");\nvar normalizeKeyValue = (value)=>{\n    return String(value);\n};\nvar createNormalizedHashFunction = ()=>{\n    return (key)=>{\n        if (typeof key === \"object\" && key !== null) {\n            const normalizedKey = JSON.parse(JSON.stringify(key));\n            if (\"pk\" in normalizedKey && normalizedKey.pk !== void 0 && normalizedKey.pk !== null) {\n                normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n            }\n            if (\"lk\" in normalizedKey && normalizedKey.lk !== void 0 && normalizedKey.lk !== null) {\n                normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n            }\n            if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n                normalizedKey.loc = normalizedKey.loc.map((locItem)=>{\n                    if (locItem && \"lk\" in locItem && locItem.lk !== void 0 && locItem.lk !== null) {\n                        return {\n                            ...locItem,\n                            lk: normalizeKeyValue(locItem.lk)\n                        };\n                    }\n                    return locItem;\n                });\n            }\n            return JSON.stringify(normalizedKey);\n        }\n        return JSON.stringify(key);\n    };\n};\nvar isPriKeyEqualNormalized = (a, b)=>{\n    logger2.trace(\"isPriKeyEqualNormalized\", {\n        a,\n        b\n    });\n    return a && b && normalizeKeyValue(a.pk) === normalizeKeyValue(b.pk) && a.kt === b.kt;\n};\nvar isLocKeyEqualNormalized = (a, b)=>{\n    logger2.trace(\"isLocKeyEqualNormalized\", {\n        a,\n        b\n    });\n    return a && b && normalizeKeyValue(a.lk) === normalizeKeyValue(b.lk) && a.kt === b.kt;\n};\nvar isComKeyEqualNormalized = (a, b)=>{\n    logger2.trace(\"isComKeyEqualNormalized\", {\n        a,\n        b\n    });\n    if (a && b && isPriKeyEqualNormalized({\n        kt: a.kt,\n        pk: a.pk\n    }, {\n        kt: b.kt,\n        pk: b.pk\n    })) {\n        if (a.loc.length === b.loc.length) {\n            for(let i = 0; i < a.loc.length; i++){\n                if (!isLocKeyEqualNormalized(a.loc[i], b.loc[i])) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n};\nvar isItemKeyEqualNormalized = (a, b)=>{\n    logger2.trace(\"isItemKeyEqualNormalized\", {\n        a,\n        b\n    });\n    if (isComKey(a) && isComKey(b)) {\n        return isComKeyEqualNormalized(a, b);\n    } else if (isPriKey(a) && isPriKey(b)) {\n        if (isComKey(a) || isComKey(b)) {\n            return false;\n        } else {\n            return isPriKeyEqualNormalized(a, b);\n        }\n    } else {\n        return false;\n    }\n};\nvar isItemKeyEqual = (a, b)=>{\n    logger2.trace(\"isKeyEqual\", {\n        a,\n        b\n    });\n    if (isComKey(a) && isComKey(b)) {\n        return isComKeyEqual(a, b);\n    } else if (isPriKey(a) && isPriKey(b)) {\n        if (isComKey(a) || isComKey(b)) {\n            return false;\n        } else {\n            return isPriKeyEqual(a, b);\n        }\n    } else {\n        return false;\n    }\n};\nvar isPriKeyEqual = (a, b)=>{\n    logger2.trace(\"isPriKeyEqual\", {\n        a,\n        b\n    });\n    return a && b && a.pk === b.pk && a.kt === b.kt;\n};\nvar isLocKeyEqual = (a, b)=>{\n    logger2.trace(\"isLocKeyEqual\", {\n        a,\n        b\n    });\n    return a && b && a.lk === b.lk && a.kt === b.kt;\n};\nvar isComKeyEqual = (a, b)=>{\n    logger2.trace(\"isComKeyEqual\", {\n        a,\n        b\n    });\n    if (a && b && isPriKeyEqual({\n        kt: a.kt,\n        pk: a.pk\n    }, {\n        kt: b.kt,\n        pk: b.pk\n    })) {\n        if (a.loc.length === b.loc.length) {\n            for(let i = 0; i < a.loc.length; i++){\n                if (!isLocKeyEqual(a.loc[i], b.loc[i])) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n};\nvar isItemKey = (key)=>{\n    logger2.trace(\"isItemKey\", {\n        key\n    });\n    return key !== void 0 && (isComKey(key) || isPriKey(key));\n};\nvar isComKey = (key)=>{\n    logger2.trace(\"isComKey\", {\n        key\n    });\n    return key !== void 0 && key.pk !== void 0 && key.kt !== void 0 && key.loc !== void 0 && key.loc.length > 0;\n};\nvar isPriKey = (key)=>{\n    logger2.trace(\"isPriKey\", {\n        key\n    });\n    return key !== void 0 && key.pk !== void 0 && key.kt !== void 0 && (key.loc === void 0 || key.loc.length === 0);\n};\nvar isLocKey = (key)=>{\n    logger2.trace(\"isLocKey\", {\n        key\n    });\n    return key !== void 0 && key.lk !== void 0 && key.kt !== void 0;\n};\nvar generateKeyArray = (key)=>{\n    logger2.trace(\"generateKeyArray\", {\n        key\n    });\n    const keys = [];\n    if (isComKey(key) || isPriKey(key)) {\n        if (isComKey(key)) {\n            const comKey = key;\n            keys.push({\n                pk: comKey.pk,\n                kt: comKey.kt\n            });\n            for(let i = 0; i < comKey.loc.length; i++){\n                keys.push(comKey.loc[i]);\n            }\n        } else {\n            keys.push(key);\n        }\n    } else {\n        const locKeys = key;\n        for(let i = 0; i < locKeys.length; i++){\n            keys.push(locKeys[i]);\n        }\n    }\n    return keys;\n};\nvar constructPriKey = (pk, kt)=>{\n    logger2.trace(\"constructPriKey\", {\n        pk,\n        kt\n    });\n    let pri;\n    if (typeof pk === \"string\" || typeof pk === \"number\") {\n        pri = {\n            kt,\n            pk\n        };\n    } else {\n        pri = pk;\n    }\n    return pri;\n};\nvar cPK = constructPriKey;\nvar toKeyTypeArray = (ik)=>{\n    logger2.trace(\"toKeyTypeArray\", {\n        ik\n    });\n    if (isComKey(ik)) {\n        const ck = ik;\n        return [\n            ck.kt,\n            ...ck.loc.map((l)=>l.kt)\n        ];\n    } else {\n        return [\n            ik.kt\n        ];\n    }\n};\nvar abbrevIK = (ik)=>{\n    logger2.trace(\"abbrevIK\", {\n        ik\n    });\n    if (ik) {\n        if (isComKey(ik)) {\n            const ck = ik;\n            return \"\".concat(ck.kt, \":\").concat(ck.pk, \":\").concat(ck.loc.map((l)=>\"\".concat(l.kt, \":\").concat(l.lk)).join(\",\"));\n        } else {\n            return \"\".concat(ik.kt, \":\").concat(ik.pk);\n        }\n    } else {\n        return \"null IK\";\n    }\n};\nvar abbrevLKA = (keyArray)=>{\n    logger2.trace(\"abbrevLKA\", {\n        keyArray\n    });\n    if (keyArray === void 0 || keyArray === null) {\n        return \"null LKA\";\n    } else {\n        return keyArray.map((key)=>{\n            if (key) {\n                return \"\".concat(key.kt, \":\").concat(key.lk);\n            } else {\n                return key;\n            }\n        }).join(\",\");\n    }\n};\nvar primaryType = (ik)=>{\n    logger2.trace(\"primaryType\", {\n        ik\n    });\n    if (isComKey(ik)) {\n        return ik.kt;\n    } else {\n        return ik.kt;\n    }\n};\nvar itemKeyToLocKeyArray = (ik)=>{\n    logger2.trace(\"itemKeyToLocKeyArray\", {\n        ik: abbrevIK(ik)\n    });\n    let lka = [];\n    if (isComKey(ik)) {\n        const ck = ik;\n        lka = [\n            {\n                kt: ck.kt,\n                lk: ck.pk\n            },\n            ...ck.loc\n        ];\n    } else {\n        const pk = ik;\n        lka = [\n            {\n                kt: pk.kt,\n                lk: pk.pk\n            }\n        ];\n    }\n    logger2.trace(\"itemKeyToLocKeyArray Results\", {\n        ik: abbrevIK(ik),\n        lka: abbrevLKA(lka)\n    });\n    return lka;\n};\nvar ikToLKA = itemKeyToLocKeyArray;\nvar locKeyArrayToItemKey = (lka)=>{\n    logger2.trace(\"locKeyArrayToItemKey\", {\n        lka: abbrevLKA(lka)\n    });\n    if (lka && lka.length === 1) {\n        const priKey = cPK(lka[0].lk, lka[0].kt);\n        return priKey;\n    } else if (lka && lka.length > 1 && lka[0] !== void 0) {\n        const locs = lka.slice(1);\n        const priKey = cPK(lka[0].lk, lka[0].kt);\n        const comKey = {\n            kt: priKey.kt,\n            pk: priKey.pk,\n            loc: locs\n        };\n        return comKey;\n    } else {\n        throw new Error(\"locKeyArrayToItemKey: lka is undefined or empty\");\n    }\n};\nvar isValidPriKey = (key)=>{\n    const valid = key !== void 0 && key !== null && key.pk !== void 0 && key.pk !== null && key.pk !== \"\" && key.pk !== \"null\" && key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\";\n    return valid;\n};\nvar isValidLocKey = (key)=>{\n    const valid = key !== void 0 && key !== null && key.lk !== void 0 && key.lk !== null && key.lk !== \"\" && key.lk !== \"null\" && key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\";\n    return valid;\n};\nvar isValidLocKeyArray = (keyArray)=>{\n    return keyArray !== void 0 && keyArray !== null && keyArray.every(isValidLocKey);\n};\nvar isValidComKey = (key)=>{\n    return key !== void 0 && key !== null && isValidPriKey(key) && isValidLocKeyArray(key.loc);\n};\nvar isValidItemKey = (key)=>{\n    return isComKey(key) && isValidComKey(key) || isPriKey(key) && isValidPriKey(key);\n};\nvar lkaToIK = locKeyArrayToItemKey;\n// src/item/IFactory.ts\nvar IFactory = class _IFactory {\n    addRef(i, name) {\n        const ik = i.key;\n        const refName = name || primaryType(ik);\n        if (!this.item.refs) {\n            this.item.refs = {};\n        }\n        this.item.refs[refName] = ik;\n        return this;\n    }\n    static addRef(i, name) {\n        return new _IFactory().addRef(i, name);\n    }\n    addDefaultEvents() {\n        if (!this.item.events) {\n            this.item.events = {};\n        }\n        const now = /* @__PURE__ */ new Date();\n        if (!this.item.events.created) {\n            this.item.events.created = {\n                at: now\n            };\n        }\n        if (!this.item.events.updated) {\n            this.item.events.updated = {\n                at: now\n            };\n        }\n        if (!this.item.events.deleted) {\n            this.item.events.deleted = {\n                at: null\n            };\n        }\n        return this;\n    }\n    addEvent(name, at, by) {\n        if (!this.item.events) {\n            this.item.events = {};\n        }\n        this.item.events[name] = {\n            at,\n            by\n        };\n        return this;\n    }\n    static addEvent(name, at, by) {\n        return new _IFactory().addEvent(name, at, by);\n    }\n    addProp(name, value) {\n        this.item[name] = value;\n        return this;\n    }\n    static addProp(name, value) {\n        return new _IFactory().addProp(name, value);\n    }\n    addProps(props) {\n        this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n        return this;\n    }\n    static addProps(props) {\n        return new _IFactory().addProps(props);\n    }\n    toItem() {\n        return this.item;\n    }\n    constructor(props = {}){\n        this.item = {};\n        this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n    }\n};\n// src/AItemService.ts\nvar AItemService = class {\n    constructor(pkType, parentService){\n        this.parentService = null;\n        this.getPkType = ()=>{\n            return this.pkType;\n        };\n        this.getKeyTypes = ()=>{\n            let keyTypes = [\n                this.getPkType()\n            ];\n            if (this.parentService) {\n                keyTypes = keyTypes.concat(this.parentService.getKeyTypes());\n            }\n            return keyTypes;\n        };\n        this.pkType = pkType;\n        if (parentService) {\n            this.parentService = parentService;\n        }\n    }\n};\n// src/item/ItemQuery.ts\nvar isCondition = (condition)=>{\n    return (typeof condition.column === \"string\" && Array.isArray(condition.value) && condition.value.every((item)=>typeof item === \"string\") || Array.isArray(condition.value) && condition.value.every((item)=>typeof item === \"number\") || typeof condition.value === \"string\" || typeof condition.value === \"number\" || typeof condition.value === \"boolean\" || condition.value instanceof Date) && (condition.operator ? typeof condition.operator === \"string\" : true);\n};\n// src/item/IQFactory.ts\nvar IQFactory = class _IQFactory {\n    orderBy(field) {\n        let direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"asc\";\n        if (!this.query.orderBy) {\n            this.query.orderBy = [];\n        }\n        this.query.orderBy.push({\n            field,\n            direction\n        });\n        return this;\n    }\n    agg(name, query) {\n        if (!this.query.aggs) {\n            this.query.aggs = {};\n        }\n        this.query.aggs[name] = query;\n        return this;\n    }\n    event(name, query) {\n        if (!this.query.events) {\n            this.query.events = {};\n        }\n        this.query.events[name] = query;\n        return this;\n    }\n    conditions(conditions) {\n        let compoundType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"AND\";\n        for (const condition of conditions){\n            if (!isCondition(condition)) {\n                throw new Error(\"Invalid condition: \".concat(JSON.stringify(condition)));\n            }\n        }\n        if (!this.query.compoundCondition) {\n            this.query.compoundCondition = {\n                compoundType,\n                conditions\n            };\n        } else {\n            const compoundCondition = {\n                compoundType,\n                conditions\n            };\n            this.query.compoundCondition.conditions.push(compoundCondition);\n        }\n        return this;\n    }\n    limit(limit) {\n        this.query.limit = limit;\n        return this;\n    }\n    offset(offset) {\n        this.query.offset = offset;\n        return this;\n    }\n    // TODO: right now, we're only supporting PK refs for queries.  Should add support for CKs\n    pk(kt, pk, name) {\n        if (!this.query.refs) {\n            this.query.refs = {};\n        }\n        const refName = name || kt;\n        this.query.refs[refName] = cPK(pk, kt);\n        return this;\n    }\n    condition(column, value) {\n        let operator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"==\";\n        const condition = {\n            column,\n            value,\n            operator\n        };\n        if (isCondition(condition)) {\n            if (!this.query.compoundCondition) {\n                this.query.compoundCondition = {\n                    compoundType: \"AND\",\n                    conditions: []\n                };\n            }\n            this.query.compoundCondition.conditions.push(condition);\n            return this;\n        } else {\n            throw new Error(\"Invalid condition: \".concat(JSON.stringify(condition)));\n        }\n    }\n    static all() {\n        const iqFactory = new _IQFactory();\n        return iqFactory;\n    }\n    static orderBy(field) {\n        let direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"asc\";\n        const iqFactory = new _IQFactory();\n        return iqFactory.orderBy(field, direction);\n    }\n    static agg(name, query) {\n        const iqFactory = new _IQFactory();\n        return iqFactory.agg(name, query);\n    }\n    static event(name, query) {\n        const iqFactory = new _IQFactory();\n        return iqFactory.event(name, query);\n    }\n    static limit(limit) {\n        const iqFactory = new _IQFactory();\n        return iqFactory.limit(limit);\n    }\n    static offset(offset) {\n        const iqFactory = new _IQFactory();\n        return iqFactory.offset(offset);\n    }\n    static pk(kt, pk, name) {\n        const iqFactory = new _IQFactory();\n        return iqFactory.pk(kt, pk, name);\n    }\n    static condition(column, value) {\n        let operator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"==\";\n        const iqFactory = new _IQFactory();\n        return iqFactory.condition(column, value, operator);\n    }\n    static conditions(conditions) {\n        let compoundType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"AND\";\n        const iqFactory = new _IQFactory();\n        return iqFactory.conditions(conditions, compoundType);\n    }\n    toQuery() {\n        return this.query;\n    }\n    constructor(query = {}){\n        this.query = {};\n        this.query = query;\n    }\n};\n// src/item/IQUtils.ts\n\nvar logger3 = logger_default.get(\"IQUtils\");\nvar queryToParams = (query)=>{\n    const params = {};\n    if (query.compoundCondition) {\n        params.compoundCondition = JSON.stringify(query.compoundCondition);\n    }\n    if (query.refs) {\n        params.refs = JSON.stringify(query.refs);\n    }\n    if (query.limit) {\n        params.limit = query.limit;\n    }\n    if (query.offset) {\n        params.offset = query.offset;\n    }\n    if (query.aggs) {\n        params.aggs = JSON.stringify(query.aggs);\n    }\n    if (query.events) {\n        params.events = JSON.stringify(query.events);\n    }\n    return params;\n};\nvar dateTimeReviver = function(key, value) {\n    if (typeof value === \"string\") {\n        const parsedDate = luxon__WEBPACK_IMPORTED_MODULE_2__.DateTime.fromISO(value);\n        if (parsedDate.isValid) {\n            return parsedDate.toJSDate();\n            ;\n        }\n    }\n    return value;\n};\nvar paramsToQuery = (params)=>{\n    const query = {};\n    if (params.compoundCondition) {\n        query.compoundCondition = JSON.parse(params.compoundCondition);\n    }\n    if (params.refs) {\n        query.refs = JSON.parse(params.refs);\n    }\n    if (params.limit) {\n        query.limit = Number(params.limit);\n    }\n    if (params.offset) {\n        query.offset = Number(params.offset);\n    }\n    if (params.aggs) {\n        query.aggs = JSON.parse(params.aggs);\n    }\n    if (params.events) {\n        query.events = JSON.parse(params.events, dateTimeReviver);\n    }\n    return query;\n};\nvar isRefQueryMatch = (refKey, queryRef, references)=>{\n    logger3.trace(\"doesRefMatch\", {\n        queryRef,\n        references\n    });\n    logger3.debug(\"Comparing Ref\", {\n        refKey,\n        itemRef: references[refKey],\n        queryRef\n    });\n    return isItemKeyEqual(queryRef, references[refKey]);\n};\nvar isCompoundConditionQueryMatch = (queryCondition, item)=>{\n    if (queryCondition.compoundType === \"AND\") {\n        return queryCondition.conditions.every((condition)=>isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item));\n    } else {\n        return queryCondition.conditions.some((condition)=>isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item));\n    }\n};\nvar isConditionQueryMatch = (queryCondition, item)=>{\n    const propKey = queryCondition.column;\n    logger3.trace(\"doesConditionMatch\", {\n        propKey,\n        queryCondition,\n        item\n    });\n    if (item[propKey] === void 0) {\n        logger3.debug(\"Item does not contain prop under key\", {\n            propKey,\n            item\n        });\n        return false;\n    }\n    logger3.debug(\"Comparing Condition\", {\n        propKey,\n        itemProp: item[propKey],\n        queryCondition\n    });\n    let result = false;\n    switch(queryCondition.operator){\n        case \"==\":\n            result = item[propKey] === queryCondition.value;\n            break;\n        case \"!=\":\n            result = item[propKey] !== queryCondition.value;\n            break;\n        case \">\":\n            result = item[propKey] > queryCondition.value;\n            break;\n        case \">=\":\n            result = item[propKey] >= queryCondition.value;\n            break;\n        case \"<\":\n            result = item[propKey] < queryCondition.value;\n            break;\n        case \"<=\":\n            result = item[propKey] <= queryCondition.value;\n            break;\n        case \"in\":\n            result = queryCondition.value.includes(item[propKey]);\n            break;\n        case \"not-in\":\n            result = !queryCondition.value.includes(item[propKey]);\n            break;\n        case \"array-contains\":\n            result = item[propKey].includes(queryCondition.value);\n            break;\n        case \"array-contains-any\":\n            result = queryCondition.value.some((value)=>item[propKey].includes(value));\n            break;\n    }\n    return result;\n};\nvar isAggQueryMatch = (aggKey, aggQuery, agg)=>{\n    const aggItem = agg.item;\n    logger3.debug(\"Comparing Agg\", {\n        aggKey,\n        aggItem,\n        aggQuery\n    });\n    return isQueryMatch(aggItem, aggQuery);\n};\nvar isEventQueryMatch = (eventKey, eventQuery, item)=>{\n    if (!item.events[eventKey]) {\n        logger3.debug(\"Item does not contain event under key\", {\n            eventKey,\n            events: item.events\n        });\n        return false;\n    } else {\n        const itemEvent = item.events[eventKey];\n        if (itemEvent.at !== null) {\n            if (eventQuery.start && !(eventQuery.start.getTime() <= itemEvent.at.getTime())) {\n                logger3.debug(\"Item date before event start query\", {\n                    eventQuery,\n                    itemEvent\n                });\n                return false;\n            }\n            if (eventQuery.end && !(eventQuery.end.getTime() > itemEvent.at.getTime())) {\n                logger3.debug(\"Item date after event end query\", {\n                    eventQuery,\n                    itemEvent\n                });\n                return false;\n            }\n        } else {\n            logger3.debug(\"Item event does contains a null at\", {\n                itemEvent\n            });\n            return false;\n        }\n        return true;\n    }\n};\nvar isQueryMatch = (item, query)=>{\n    logger3.trace(\"isMatch\", {\n        item,\n        query\n    });\n    if (query.refs && item.refs) {\n        for(const key in query.refs){\n            const queryRef = query.refs[key];\n            if (!isRefQueryMatch(key, queryRef, item.refs)) return false;\n        }\n    } else if (query.refs && !item.refs) {\n        logger3.debug(\"Query contains refs but item does not have refs\", {\n            query,\n            item\n        });\n        return false;\n    }\n    if (query.compoundCondition && item) {\n        if (!isCompoundConditionQueryMatch(query.compoundCondition, item)) return false;\n    }\n    if (query.events && item.events) {\n        for(const key in query.events){\n            const queryEvent = query.events[key];\n            if (!isEventQueryMatch(key, queryEvent, item)) return false;\n        }\n        return true;\n    }\n    if (query.aggs && item.aggs) {\n        for(const key in query.aggs){\n            const aggQuery = query.aggs[key];\n            if (item.aggs[key] && !isAggQueryMatch(key, aggQuery, item.aggs[key])) return false;\n        }\n    }\n    if (query.aggs && !item.aggs) {\n        logger3.debug(\"Query contains aggs but item does not have aggs\", {\n            query,\n            item\n        });\n        return false;\n    }\n    return true;\n};\nvar abbrevQuery = (query)=>{\n    const abbrev = [\n        \"IQ\"\n    ];\n    if (query) {\n        if (query.refs) {\n            for(const key in query.refs){\n                const ref = abbrevRef(key, query.refs[key]);\n                abbrev.push(ref);\n            }\n        }\n        if (query.compoundCondition) {\n            const props = abbrevCompoundCondition(query.compoundCondition);\n            abbrev.push(props);\n        }\n        if (query.aggs) {\n            for(const key in query.aggs){\n                const agg = abbrevAgg(key, query.aggs[key]);\n                abbrev.push(agg);\n            }\n        }\n        if (query.events) {\n            const events = \"(E\".concat(Object.keys(query.events).join(\",\"), \")\");\n            abbrev.push(events);\n        }\n        if (query.limit) {\n            abbrev.push(\"L\".concat(query.limit));\n        }\n        if (query.offset) {\n            abbrev.push(\"O\".concat(query.offset));\n        }\n    } else {\n        abbrev.push(\"(empty)\");\n    }\n    return abbrev.join(\" \");\n};\nvar abbrevRef = (key, ref)=>{\n    if (isPriKey(ref)) {\n        const priKey = ref;\n        return \"R(\".concat(key, \",\").concat(priKey.kt, \",\").concat(priKey.pk, \")\");\n    } else {\n        const comKey = ref;\n        return \"R(\".concat(key, \",\").concat(JSON.stringify(comKey), \")\");\n    }\n};\nvar abbrevAgg = (key, agg)=>{\n    return \"A(\".concat(key, \",\").concat(abbrevQuery(agg), \")\");\n};\nvar abbrevCompoundCondition = (compoundCondition)=>{\n    return \"CC(\".concat(compoundCondition.compoundType, \",\").concat(compoundCondition.conditions ? compoundCondition.conditions.map(abbrevCondition).join(\",\") : \"No Conditions\", \")\");\n};\nvar abbrevCondition = (condition)=>{\n    if (isCondition(condition)) {\n        return \"(\".concat(condition.column, \",\").concat(condition.value, \",\").concat(condition.operator, \")\");\n    } else {\n        return abbrevCompoundCondition(condition);\n    }\n};\n// src/item/IUtils.ts\nvar logger4 = logger_default.get(\"IUtils\");\nvar validatePKForItem = (item, pkType)=>{\n    if (!item) {\n        logger4.error(\"Validating PK, Item is undefined\", {\n            item\n        });\n        throw new Error(\"Validating PK, Item is undefined\");\n    }\n    if (!item.key) {\n        logger4.error(\"Validating PK, Item does not have a key\", {\n            item\n        });\n        throw new Error(\"Validating PK, Item does not have a key\");\n    }\n    const keyTypeArray = toKeyTypeArray(item.key);\n    if (keyTypeArray[0] !== pkType) {\n        logger4.error(\"Key Type Array Mismatch\", {\n            keyTypeArray,\n            pkType\n        });\n        throw new Error(\"Item does not have the correct primary key type. Expected \".concat(pkType, \", got \").concat(keyTypeArray[0]));\n    }\n    return item;\n};\nvar validatePK = (input, pkType)=>{\n    logger4.trace(\"Checking Return Type\", {\n        input\n    });\n    if (Array.isArray(input)) {\n        return input.map((item)=>validatePKForItem(item, pkType));\n    }\n    return validatePKForItem(input, pkType);\n};\nvar validateKeys = (item, keyTypes)=>{\n    logger4.trace(\"Checking Return Type\", {\n        item\n    });\n    if (!item) {\n        throw new Error(\"validating keys, item is undefined\");\n    }\n    if (!item.key) {\n        throw new Error(\"validating keys, item does not have a key: \" + JSON.stringify(item));\n    }\n    const keyTypeArray = toKeyTypeArray(item.key);\n    if (keyTypeArray.length !== keyTypes.length) {\n        throw new Error(\"Item does not have the correct number of keys. Expected \".concat(keyTypes.length, \", but got \").concat(keyTypeArray.length));\n    }\n    const match = JSON.stringify(keyTypeArray) === JSON.stringify(keyTypes);\n    if (!match) {\n        logger4.error(\"Key Type Array Mismatch\", {\n            keyTypeArray,\n            thisKeyTypes: keyTypes\n        });\n        throw new Error(\"Item does not have the correct key types. Expected [\".concat(keyTypes.join(\", \"), \"], but got [\").concat(keyTypeArray.join(\", \"), \"]\"));\n    }\n    return item;\n};\nvar isPriItem = (item)=>{\n    return !!(item && item.key && isPriKey(item.key));\n};\nvar isComItem = (item)=>{\n    return !!(item && item.key && isComKey(item.key));\n};\n //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0I7QUFFcEIsSUFBTSxZQUFZLGdFQUFRLENBQVUsYUFBYTtBQUVqRCxJQUFPLGlCQUFROztBQ0ZmLElBQU0sU0FBUyxlQUFVLElBQUksWUFBWTtBQU9sQyxJQUFNLGFBQU4sTUFBTSxZQUFpQjtJQXVCckIsSUFBSSxLQUFRLE1BQWU7UUFDaEMsT0FBTyxNQUFNLE9BQU87WUFBRTtZQUFLO1FBQUssQ0FBQztRQUNqQyxNQUFNLFlBQVksS0FBSyxhQUFhLEdBQUc7UUFDdkMsS0FBSyxJQUFJLFNBQVMsSUFBSTtZQUFFLGFBQWE7WUFBSyxPQUFPO1FBQUs7SUFDeEQ7SUFFTyxJQUFJLEtBQWtCO1FBQzNCLE9BQU8sTUFBTSxPQUFPO1lBQUU7UUFBSSxDQUFDO1FBQzNCLE1BQU0sWUFBWSxLQUFLLGFBQWEsR0FBRztRQUN2QyxNQUFNLFFBQVEsS0FBSyxJQUFJLFNBQVM7UUFFaEMsT0FBTyxTQUFTLEtBQUssVUFBVSxNQUFNLGFBQWEsR0FBRyxJQUFJLE1BQU0sUUFBUTtJQUN6RTtJQUVRLFVBQVUsTUFBUyxNQUFrQjtRQUczQyxPQUFPLFNBQVM7SUFDbEI7SUFFTyxPQUFPLEtBQWM7UUFDMUIsT0FBTyxNQUFNLFVBQVU7WUFBRTtRQUFJLENBQUM7UUFDOUIsTUFBTSxZQUFZLEtBQUssYUFBYSxHQUFHO1FBQ3ZDLE9BQU8sS0FBSyxJQUFJLFNBQVM7SUFDM0I7SUFFTyxPQUFZO1FBQ2pCLE9BQU8sT0FBTyxPQUFPLEtBQUssR0FBRyxFQUFFLElBQUksU0FBUyxNQUFNLFdBQVc7SUFDL0Q7SUFFTyxTQUFjO1FBQ25CLE9BQU8sT0FBTyxPQUFPLEtBQUssR0FBRyxFQUFFLElBQUksU0FBUyxNQUFNLEtBQUs7SUFDekQ7SUFFTyxZQUFZLEtBQWlCO1FBQ2xDLE1B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Q0FBQyxNQUFNO1FBQ1QsTUFBTSxJQUFJLE1BQU0sb0NBQW9DO0lBQ3REO0lBQ0EsSUFBSSxDQUFDLEtBQUssS0FBSztRQUNiLE1BQU0sSUFBSSxNQUFNLGdEQUFnRCxLQUFLLFVBQVUsSUFBSSxDQUFDO0lBQ3RGO0lBRUEsTUFBTSxlQUFlLGVBQWUsS0FBSyxHQUFnRDtJQUN6RixJQUFJLGFBQWEsV0FBVyxTQUFTLFFBQVE7UUFDM0MsTUFBTSxJQUFJLE1BQU0sMkRBQXVGLE9BQTVCLFNBQVMsTUFBTSxnQkFBZ0MsQ0FBRSxtQkFBUixNQUFNO0lBQzVIO0lBRUEsTUFBTSxRQUFpQixLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxRQUFRO0lBQy9FLElBQUksQ0FBQyxPQUFPO1FBQ1ZBLFFBQU8sTUFBTSwyQkFBMkI7WUFBRTtZQUFjLGNBQWM7UUFBUyxDQUFDO1FBQ2hGLE1BQU0sSUFBSSxNQUFNLHVEQUF5RixPQUFsQyxTQUFTLEtBQUssSUFBSSxDQUFDLGtCQUFzQyxvQkFBVixLQUFLLElBQUksQ0FBQyxJQUFHO0lBQ3JJO0lBQ0EsT0FBTztBQUNUO0FBRU8sSUFBTSxZQUFZLENBUXZCO0lBRUEsT0FBTyxDQUFDLEVBQUUsUUFBUSxLQUFLLE9BQU8sU0FBUyxLQUFLLElBQUc7QUFDakQ7QUFFTyxJQUFNLFlBQVksQ0FRdkI7SUFFQSxPQUFPLENBQUMsRUFBRSxRQUFRLEtBQUssT0FBTyxTQUFTLEtBQUssSUFBRztBQUNqRCIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvbG9nZ2VyLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvZGljdGlvbmFyeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2l0ZW0vSUZhY3RvcnkudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9rZXkvS1V0aWxzLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvQUl0ZW1TZXJ2aWNlLnRzIiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvaXRlbS9JdGVtUXVlcnkudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9pdGVtL0lRRmFjdG9yeS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2l0ZW0vSVFVdGlscy50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2l0ZW0vSVV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnaW5nIGZyb20gJ0BmamVsbC9sb2dnaW5nJztcblxuY29uc3QgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoJ0BmamVsbC9jb3JlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IExpYkxvZ2dlcjtcbiIsImltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4vbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoXCJEaWN0aW9uYXJ5XCIpO1xuXG5pbnRlcmZhY2UgRGljdGlvbmFyeUVudHJ5PFQsIFY+IHtcbiAgb3JpZ2luYWxLZXk6IFQ7XG4gIHZhbHVlOiBWO1xufVxuXG5leHBvcnQgY2xhc3MgRGljdGlvbmFyeTxULCBWPiB7XG4gIHByb3RlY3RlZCBtYXA6IHsgW2tleTogc3RyaW5nXTogRGljdGlvbmFyeUVudHJ5PFQsIFY+IH0gPSB7fVxuICBwcm90ZWN0ZWQgaGFzaEZ1bmN0aW9uID0gKGtleTogVCkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcblxuICBjb25zdHJ1Y3RvcihtYXA/OiB7IFtrZXk6IHN0cmluZ106IFYgfSwgaGFzaEZ1bmN0aW9uPzogKGtleTogVCkgPT4gc3RyaW5nKSB7XG4gICAgaWYgKGhhc2hGdW5jdGlvbikge1xuICAgICAgdGhpcy5oYXNoRnVuY3Rpb24gPSBoYXNoRnVuY3Rpb25cbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgLy8gQ29udmVydCBsZWdhY3kgbWFwIGZvcm1hdCB0byBuZXcgZm9ybWF0XG4gICAgICBPYmplY3QuZW50cmllcyhtYXApLmZvckVhY2goKFtoYXNoZWRLZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUga2V5IGlmIGl0IGxvb2tzIGxpa2UgSlNPTlxuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsS2V5ID0gSlNPTi5wYXJzZShoYXNoZWRLZXkpIGFzIFQ7XG4gICAgICAgICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHsgb3JpZ2luYWxLZXksIHZhbHVlIH07XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIHdlIGNhbid0IHJlY292ZXIgdGhlIG9yaWdpbmFsIGtleVxuICAgICAgICAgIGxvZ2dlci53YXJuaW5nKCdDYW5ub3QgcmVjb3ZlciBvcmlnaW5hbCBrZXkgZnJvbSBsZWdhY3kgbWFwIGVudHJ5JywgeyBoYXNoZWRLZXkgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXQoa2V5OiBULCBpdGVtOiBWKTogdm9pZCB7XG4gICAgbG9nZ2VyLnRyYWNlKCdzZXQnLCB7IGtleSwgaXRlbSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIHRoaXMubWFwW2hhc2hlZEtleV0gPSB7IG9yaWdpbmFsS2V5OiBrZXksIHZhbHVlOiBpdGVtIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0KGtleTogVCk6IFYgfCBudWxsIHtcbiAgICBsb2dnZXIudHJhY2UoJ2dldCcsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBBTkQgdGhlIG9yaWdpbmFsIGtleSBtYXRjaGVzIHRoZSByZXF1ZXN0ZWQga2V5XG4gICAgcmV0dXJuIGVudHJ5ICYmIHRoaXMua2V5c0VxdWFsKGVudHJ5Lm9yaWdpbmFsS2V5LCBrZXkpID8gZW50cnkudmFsdWUgOiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBrZXlzRXF1YWwoa2V5MTogVCwga2V5MjogVCk6IGJvb2xlYW4ge1xuICAgIC8vIEZvciBiYXNpYyBlcXVhbGl0eSBjaGVjayAtIHRoaXMgd29ya3MgZm9yIHByaW1pdGl2ZXMgYW5kIG9iamVjdCByZWZlcmVuY2VzXG4gICAgLy8gRm9yIGRlZXAgZXF1YWxpdHksIHVzZXJzIGNhbiBwcm92aWRlIGEgY3VzdG9tIGhhc2ggZnVuY3Rpb24gdGhhdCBhdm9pZHMgY29sbGlzaW9uc1xuICAgIHJldHVybiBrZXkxID09PSBrZXkyO1xuICB9XG5cbiAgcHVibGljIGRlbGV0ZShrZXk6IFQpOiB2b2lkIHtcbiAgICBsb2dnZXIudHJhY2UoJ2RlbGV0ZScsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgZGVsZXRlIHRoaXMubWFwW2hhc2hlZEtleV07XG4gIH1cblxuICBwdWJsaWMga2V5cygpOiBUW10ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoZW50cnkgPT4gZW50cnkub3JpZ2luYWxLZXkpO1xuICB9XG5cbiAgcHVibGljIHZhbHVlcygpOiBWW10ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5tYXAoZW50cnkgPT4gZW50cnkudmFsdWUpO1xuICB9XG5cbiAgcHVibGljIGluY2x1ZGVzS2V5KGtleTogVCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiBlbnRyeSA/IHRoaXMua2V5c0VxdWFsKGVudHJ5Lm9yaWdpbmFsS2V5LCBrZXkpIDogZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogRGljdGlvbmFyeTxULCBWPiB7XG4gICAgY29uc3QgY2xvbmVkTWFwOiB7IFtrZXk6IHN0cmluZ106IFYgfSA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMubWFwKS5mb3JFYWNoKChbaGFzaGVkS2V5LCBlbnRyeV0pID0+IHtcbiAgICAgIGNsb25lZE1hcFtoYXNoZWRLZXldID0gZW50cnkudmFsdWU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBjbG9uZSA9IG5ldyBEaWN0aW9uYXJ5PFQsIFY+KGNsb25lZE1hcCwgdGhpcy5oYXNoRnVuY3Rpb24pO1xuICAgIC8vIENvcHkgdGhlIGVudHJpZXMgZGlyZWN0bHkgdG8gcHJlc2VydmUgb3JpZ2luYWwga2V5c1xuICAgIGNsb25lLm1hcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWFwKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiIsImltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCB7IEl0ZW0gfSBmcm9tICcuLi9pdGVtcyc7XG5pbXBvcnQgeyBwcmltYXJ5VHlwZSB9IGZyb20gJy4uL2tleS9LVXRpbHMnO1xuaW1wb3J0IHsgQ29tS2V5LCBQcmlLZXkgfSBmcm9tICcuLi9rZXlzJztcblxuZXhwb3J0IGNsYXNzIElGYWN0b3J5PFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPiB7XG4gIHByaXZhdGUgaXRlbTogYW55ID0ge1xuICB9O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcm9wczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9KSB7XG4gICAgdGhpcy5pdGVtID0gZGVlcG1lcmdlKHRoaXMuaXRlbSwgcHJvcHMpO1xuICB9XG5cbiAgcHVibGljIGFkZFJlZihpOiBJdGVtPGFueSwgYW55fG5ldmVyLCBhbnl8bmV2ZXIsIGFueXxuZXZlciwgYW55fG5ldmVyLCBhbnl8bmV2ZXI+LCBuYW1lPzogc3RyaW5nKSB7XG4gICAgY29uc3QgaWs6IENvbUtleTxhbnksIGFueXxuZXZlciwgYW55fG5ldmVyLCBhbnl8bmV2ZXIsIGFueXxuZXZlciwgYW55fG5ldmVyPiB8IFByaUtleTxhbnk+ID0gaS5rZXk7XG5cbiAgICBjb25zdCByZWZOYW1lID0gbmFtZSB8fCBwcmltYXJ5VHlwZShpayk7XG4gICAgaWYgKCF0aGlzLml0ZW0ucmVmcykge1xuICAgICAgdGhpcy5pdGVtLnJlZnMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLnJlZnNbcmVmTmFtZV0gPSBpaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYWRkUmVmPFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihpOiBWLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBJRmFjdG9yeTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KCkuYWRkUmVmKGksIG5hbWUpO1xuICB9XG5cbiAgcHVibGljIGFkZERlZmF1bHRFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzID0ge307XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzLmNyZWF0ZWQpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMuY3JlYXRlZCA9IHsgYXQ6IG5vdyB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMudXBkYXRlZCkge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cy51cGRhdGVkID0geyBhdDogbm93IH07XG4gICAgfVxuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cy5kZWxldGVkKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzLmRlbGV0ZWQgPSB7IGF0OiBudWxsIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGFkZEV2ZW50KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBhdDogRGF0ZSB8IG51bGwsXG4gICAgYnk/OiBDb21LZXk8YW55LCBhbnl8bmV2ZXIsIGFueXxuZXZlciwgYW55fG5ldmVyLCBhbnl8bmV2ZXIsIGFueXxuZXZlcj4gfCBQcmlLZXk8YW55PlxuICApIHtcbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLmV2ZW50c1tuYW1lXSA9IHsgYXQsIGJ5IH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFkZEV2ZW50PFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihuYW1lOiBzdHJpbmcsIGF0OiBEYXRlIHwgbnVsbCwgYnk/OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPikge1xuICAgIHJldHVybiBuZXcgSUZhY3Rvcnk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PigpLmFkZEV2ZW50KG5hbWUsIGF0LCBieSk7XG4gIH1cblxuICBwdWJsaWMgYWRkUHJvcChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSkge1xuICAgIHRoaXMuaXRlbVtuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhZGRQcm9wPFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSkge1xuICAgIHJldHVybiBuZXcgSUZhY3Rvcnk8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PigpLmFkZFByb3AobmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgcHVibGljIGFkZFByb3BzKHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgdGhpcy5pdGVtID0gZGVlcG1lcmdlKHRoaXMuaXRlbSwgcHJvcHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhZGRQcm9wczxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4ocHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICByZXR1cm4gbmV3IElGYWN0b3J5PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oKS5hZGRQcm9wcyhwcm9wcyk7XG4gIH1cblxuICB0b0l0ZW0oKTogViB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbSBhcyBWO1xuICB9XG59IiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5pbXBvcnQge1xuICBDb21LZXksXG4gIExvY0tleSxcbiAgTG9jS2V5QXJyYXksXG4gIFByaUtleVxufSBmcm9tIFwiLi4va2V5c1wiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnS1V0aWxzJyk7XG5cbi8vIE5vcm1hbGl6ZSBhIGtleSB2YWx1ZSB0byBzdHJpbmcgZm9yIGNvbnNpc3RlbnQgY29tcGFyaXNvbiBhbmQgaGFzaGluZ1xuY29uc3Qgbm9ybWFsaXplS2V5VmFsdWUgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufTtcblxuLy8gTm9ybWFsaXplZCBoYXNoIGZ1bmN0aW9uIGZvciBEaWN0aW9uYXJ5IHRoYXQgY29udmVydHMgcGsvbGsgdmFsdWVzIHRvIHN0cmluZ3NcbmV4cG9ydCBjb25zdCBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gPFQ+KCkgPT4ge1xuICByZXR1cm4gKGtleTogVCk6IHN0cmluZyA9PiB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgLy8gQ3JlYXRlIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBrZXkgd2l0aCBzdHJpbmcgdmFsdWVzXG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShrZXkpKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHBrIHZhbHVlc1xuICAgICAgaWYgKCdwaycgaW4gbm9ybWFsaXplZEtleSAmJiAobm9ybWFsaXplZEtleS5wayAhPT0gdW5kZWZpbmVkICYmIG5vcm1hbGl6ZWRLZXkucGsgIT09IG51bGwpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkucGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LnBrKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGxrIHZhbHVlc1xuICAgICAgaWYgKCdsaycgaW4gbm9ybWFsaXplZEtleSAmJiAobm9ybWFsaXplZEtleS5sayAhPT0gdW5kZWZpbmVkICYmIG5vcm1hbGl6ZWRLZXkubGsgIT09IG51bGwpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LmxrKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGxvYyBhcnJheSBsayB2YWx1ZXNcbiAgICAgIGlmICgnbG9jJyBpbiBub3JtYWxpemVkS2V5ICYmIEFycmF5LmlzQXJyYXkobm9ybWFsaXplZEtleS5sb2MpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubG9jID0gbm9ybWFsaXplZEtleS5sb2MubWFwKChsb2NJdGVtOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAobG9jSXRlbSAmJiAnbGsnIGluIGxvY0l0ZW0gJiYgKGxvY0l0ZW0ubGsgIT09IHVuZGVmaW5lZCAmJiBsb2NJdGVtLmxrICE9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubG9jSXRlbSwgbGs6IG5vcm1hbGl6ZUtleVZhbHVlKGxvY0l0ZW0ubGspIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NJdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgfTtcbn07XG5cbi8vIE5vcm1hbGl6ZWQgY29tcGFyaXNvbiBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBpc1ByaUtleUVxdWFsTm9ybWFsaXplZCA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbj4oYTogUHJpS2V5PFM+LCBiOiBQcmlLZXk8Uz4pOiBib29sZWFuID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdpc1ByaUtleUVxdWFsTm9ybWFsaXplZCcsIHsgYSwgYiB9KTtcbiAgcmV0dXJuIGEgJiYgYiAmJlxuICAgIG5vcm1hbGl6ZUtleVZhbHVlKGEucGspID09PSBub3JtYWxpemVLZXlWYWx1ZShiLnBrKSAmJlxuICAgIGEua3QgPT09IGIua3Q7XG59O1xuXG5leHBvcnQgY29uc3QgaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQgPSA8XG4gIEwxIGV4dGVuZHMgc3RyaW5nLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGE6IExvY0tleTxMMSB8IEwyIHwgTDMgfCBMNCB8IEw1PiwgYjogTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+KTogYm9vbGVhbiA9PiB7XG4gIGxvZ2dlci50cmFjZSgnaXNMb2NLZXlFcXVhbE5vcm1hbGl6ZWQnLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiZcbiAgICBub3JtYWxpemVLZXlWYWx1ZShhLmxrKSA9PT0gbm9ybWFsaXplS2V5VmFsdWUoYi5saykgJiZcbiAgICBhLmt0ID09PSBiLmt0O1xufTtcblxuZXhwb3J0IGNvbnN0IGlzQ29tS2V5RXF1YWxOb3JtYWxpemVkID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGE6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBiOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1Pik6IGJvb2xlYW4gPT4ge1xuICBsb2dnZXIudHJhY2UoJ2lzQ29tS2V5RXF1YWxOb3JtYWxpemVkJywgeyBhLCBiIH0pO1xuICBpZiAoYSAmJiBiICYmIGlzUHJpS2V5RXF1YWxOb3JtYWxpemVkKHsga3Q6IGEua3QsIHBrOiBhLnBrIH0gYXMgUHJpS2V5PFM+LCB7IGt0OiBiLmt0LCBwazogYi5wayB9IGFzIFByaUtleTxTPikpIHtcbiAgICBpZiAoYS5sb2MubGVuZ3RoID09PSBiLmxvYy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0xvY0tleUVxdWFsTm9ybWFsaXplZDxMMSwgTDIsIEwzLCBMNCwgTDU+KGEubG9jW2ldLCBiLmxvY1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzSXRlbUtleUVxdWFsTm9ybWFsaXplZCA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihhOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgYjogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBib29sZWFuID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWQnLCB7IGEsIGIgfSk7XG4gIGlmIChpc0NvbUtleShhKSAmJiBpc0NvbUtleShiKSkge1xuICAgIHJldHVybiBpc0NvbUtleUVxdWFsTm9ybWFsaXplZChhIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBiIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KTtcbiAgfSBlbHNlIGlmIChpc1ByaUtleShhKSAmJiBpc1ByaUtleShiKSkge1xuICAgIGlmIChpc0NvbUtleShhKSB8fCBpc0NvbUtleShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQoYSBhcyBQcmlLZXk8Uz4sIGIgYXMgUHJpS2V5PFM+KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBPcmlnaW5hbCBjb21wYXJpc29uIGZ1bmN0aW9ucyAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbmV4cG9ydCBjb25zdCBpc0l0ZW1LZXlFcXVhbCA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihhOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPiwgYjogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBib29sZWFuID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdpc0tleUVxdWFsJywgeyBhLCBiIH0pO1xuICBpZiAoaXNDb21LZXkoYSkgJiYgaXNDb21LZXkoYikpIHtcbiAgICByZXR1cm4gaXNDb21LZXlFcXVhbChhIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBiIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KTtcbiAgfSBlbHNlIGlmIChpc1ByaUtleShhKSAmJiBpc1ByaUtleShiKSkge1xuICAgIGlmIChpc0NvbUtleShhKSB8fCBpc0NvbUtleShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNQcmlLZXlFcXVhbChhIGFzIFByaUtleTxTPiwgYiBhcyBQcmlLZXk8Uz4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc1ByaUtleUVxdWFsID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuPihhOiBQcmlLZXk8Uz4sIGI6IFByaUtleTxTPik6IGJvb2xlYW4gPT4ge1xuICBsb2dnZXIudHJhY2UoJ2lzUHJpS2V5RXF1YWwnLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgYS5wayA9PT0gYi5wayAmJiBhLmt0ID09PSBiLmt0O1xufVxuXG5leHBvcnQgY29uc3QgaXNMb2NLZXlFcXVhbCA9IDxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oYTogTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+LCBiOiBMb2NLZXk8TDEgfCBMMiB8IEwzIHwgTDQgfCBMNT4pOiBib29sZWFuID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdpc0xvY0tleUVxdWFsJywgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIGEubGsgPT09IGIubGsgJiYgYS5rdCA9PT0gYi5rdDtcbn1cblxuZXhwb3J0IGNvbnN0IGlzQ29tS2V5RXF1YWwgPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oYTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIGI6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KTogYm9vbGVhbiA9PiB7XG4gIGxvZ2dlci50cmFjZSgnaXNDb21LZXlFcXVhbCcsIHsgYSwgYiB9KTtcbiAgaWYgKGEgJiYgYiAmJiBpc1ByaUtleUVxdWFsKHsga3Q6IGEua3QsIHBrOiBhLnBrIH0gYXMgUHJpS2V5PFM+LCB7IGt0OiBiLmt0LCBwazogYi5wayB9IGFzIFByaUtleTxTPikpIHtcbiAgICBpZiAoYS5sb2MubGVuZ3RoID09PSBiLmxvYy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0xvY0tleUVxdWFsPEwxLCBMMiwgTDMsIEw0LCBMNT4oYS5sb2NbaV0sIGIubG9jW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpc0l0ZW1LZXkgPSAoa2V5OiBhbnkpOiBib29sZWFuID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdpc0l0ZW1LZXknLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdW5kZWZpbmVkICYmIChpc0NvbUtleShrZXkpIHx8IGlzUHJpS2V5KGtleSkpO1xufVxuXG5leHBvcnQgY29uc3QgaXNDb21LZXkgPSAoa2V5OiBhbnkpOiBib29sZWFuID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdpc0NvbUtleScsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAoa2V5LnBrICE9PSB1bmRlZmluZWQgJiYga2V5Lmt0ICE9PSB1bmRlZmluZWQpICYmIChrZXkubG9jICE9PSB1bmRlZmluZWQgJiYga2V5LmxvYy5sZW5ndGggPiAwKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzUHJpS2V5ID0gKGtleTogYW55KTogYm9vbGVhbiA9PiB7XG4gIGxvZ2dlci50cmFjZSgnaXNQcmlLZXknLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGtleS5wayAhPT0gdW5kZWZpbmVkICYmIGtleS5rdCAhPT0gdW5kZWZpbmVkKSAmJiAoa2V5LmxvYyA9PT0gdW5kZWZpbmVkIHx8IGtleS5sb2MubGVuZ3RoID09PSAwKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzTG9jS2V5ID0gKGtleTogYW55KTogYm9vbGVhbiA9PiB7XG4gIGxvZ2dlci50cmFjZSgnaXNMb2NLZXknLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdW5kZWZpbmVkICYmIChrZXkubGsgIT09IHVuZGVmaW5lZCAmJiBrZXkua3QgIT09IHVuZGVmaW5lZCk7XG59XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUtleUFycmF5ID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuPihrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+IHwgTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PiB8IFtdKTpcbiAgQXJyYXk8UHJpS2V5PFM+IHwgTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+PiA9PiB7XG4gIGxvZ2dlci50cmFjZSgnZ2VuZXJhdGVLZXlBcnJheScsIHsga2V5IH0pO1xuICBjb25zdCBrZXlzOiBBcnJheTxQcmlLZXk8Uz4gfCBMb2NLZXk8TDEgfCBMMiB8IEwzIHwgTDQgfCBMNT4+ID0gW107XG5cbiAgaWYgKGlzQ29tS2V5KGtleSkgfHwgaXNQcmlLZXkoa2V5KSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdpdCBpcyBhbiBpdGVtIGtleScpO1xuICAgIGlmIChpc0NvbUtleShrZXkpKSB7XG4gICAgICAvLyAgY29uc29sZS5sb2coJ2l0IGlzIGEgY29tcG9zaXRlIGtleScpO1xuICAgICAgY29uc3QgY29tS2V5ID0ga2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgICAga2V5cy5wdXNoKHsgcGs6IGNvbUtleS5waywga3Q6IGNvbUtleS5rdCB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tS2V5LmxvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXlzLnB1c2goY29tS2V5LmxvY1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaChrZXkgYXMgUHJpS2V5PFM+KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2lzIGlzIGFuIGFycmF5LCBsZW5ndGg6ICcgKyBrZXkubGVuZ3RoKTtcbiAgICBjb25zdCBsb2NLZXlzID0ga2V5IGFzIExvY0tleTxMMSB8IEwyIHwgTDMgfCBMNCB8IEw1PltdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ1B1c2hpbmcgYSBrZXknKTtcbiAgICAgIGtleXMucHVzaChsb2NLZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8vIFRPRE86IEV4YWN0bHkgdGhlIHNhbWUgYXMgaW4gQ29udGFpbmVkSXRlbUxpYlxuZXhwb3J0IGNvbnN0IGNvbnN0cnVjdFByaUtleSA9IDxTIGV4dGVuZHMgc3RyaW5nPihcbiAgcGs6IHN0cmluZyB8IG51bWJlciB8IFByaUtleTxTPixcbiAga3Q6IFMsXG4pID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdjb25zdHJ1Y3RQcmlLZXknLCB7IHBrLCBrdCB9KTtcbiAgbGV0IHByaTogUHJpS2V5PFM+O1xuICBpZiAodHlwZW9mIHBrID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGsgPT09ICdudW1iZXInKSB7XG4gICAgcHJpID0geyBrdDoga3QgYXMgUywgcGs6IHBrIH07XG4gIH0gZWxzZSB7XG4gICAgcHJpID0gcGs7XG4gIH1cbiAgcmV0dXJuIHByaTtcbn1cblxuLy8gVE9ETzogRXhhY3RseSB0aGUgc2FtZSBhcyBpbiBDb250YWluZWRJdGVtTGliXG5leHBvcnQgY29uc3QgY1BLID0gY29uc3RydWN0UHJpS2V5O1xuXG5leHBvcnQgY29uc3QgdG9LZXlUeXBlQXJyYXkgPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oaWs6IFByaUtleTxTPiB8IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KTpcbiAgc3RyaW5nW10gPT4ge1xuICBsb2dnZXIudHJhY2UoJ3RvS2V5VHlwZUFycmF5JywgeyBpayB9KTtcbiAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgIGNvbnN0IGNrID0gaWsgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgcmV0dXJuIFtjay5rdCwgLi4uY2subG9jLm1hcCgobDogTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+KSA9PiBsLmt0KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFsoaWsgYXMgUHJpS2V5PFM+KS5rdF07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGFiYnJldklLID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGlrOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IHN0cmluZyA9PiB7XG4gIGxvZ2dlci50cmFjZSgnYWJicmV2SUsnLCB7IGlrIH0pO1xuICBpZiAoaWspIHtcbiAgICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgICBjb25zdCBjayA9IGlrIGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgICAgcmV0dXJuIGAke2NrLmt0fToke2NrLnBrfToke2NrLmxvYy5tYXAoKGw6IExvY0tleTxMMSB8IEwyIHwgTDMgfCBMNCB8IEw1PikgPT4gYCR7bC5rdH06JHtsLmxrfWApLmpvaW4oJywnKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7KGlrIGFzIFByaUtleTxTPikua3R9OiR7KGlrIGFzIFByaUtleTxTPikucGt9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdudWxsIElLJztcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYWJicmV2TEtBID0gPFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihrZXlBcnJheTogQXJyYXk8TG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+PiB8IG51bGwpOiBzdHJpbmcgPT4ge1xuICBsb2dnZXIudHJhY2UoJ2FiYnJldkxLQScsIHsga2V5QXJyYXkgfSk7XG4gIGlmIChrZXlBcnJheSA9PT0gdW5kZWZpbmVkIHx8IGtleUFycmF5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsIExLQSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUFycmF5Lm1hcChrZXkgPT4ge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICByZXR1cm4gYCR7a2V5Lmt0fToke2tleS5sa31gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9KS5qb2luKCcsJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByaW1hcnlUeXBlID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGlrOiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik6IHN0cmluZyA9PiB7XG4gIGxvZ2dlci50cmFjZSgncHJpbWFyeVR5cGUnLCB7IGlrIH0pO1xuICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgcmV0dXJuIChpayBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1Pikua3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChpayBhcyBQcmlLZXk8Uz4pLmt0O1xuICB9XG59XG5cbi8qKlxuICAgKlxuICAgKiBAcGFyYW0gaWsgSXRlbUtleSB0byBiZSB1c2VkIGFzIGEgYmFzaXMgZm9yIGEgbG9jYXRpb25cbiAgICogQHJldHVybnNcbiAgICovXG5leHBvcnQgY29uc3QgaXRlbUtleVRvTG9jS2V5QXJyYXkgPVxuICA8XG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPihpazogUHJpS2V5PFM+IHwgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pOiBMb2NLZXlBcnJheTxTLCBMMSwgTDIsIEwzLCBMND4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnaXRlbUtleVRvTG9jS2V5QXJyYXknLCB7IGlrOiBhYmJyZXZJSyhpaykgfSk7XG4gICAgbGV0IGxrYTogQXJyYXk8TG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+PiA9IFtdO1xuICAgIGlmIChpc0NvbUtleShpaykpIHtcbiAgICAgIGNvbnN0IGNrID0gaWsgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgICBsa2EgPSBbeyBrdDogY2sua3QsIGxrOiBjay5wayB9IGFzIHVua25vd24gYXMgTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+LCAuLi5jay5sb2NdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwayA9IGlrIGFzIFByaUtleTxTPjtcbiAgICAgIGxrYSA9IFt7IGt0OiBway5rdCwgbGs6IHBrLnBrIH0gYXMgdW5rbm93biBhcyBMb2NLZXk8TDEgfCBMMiB8IEwzIHwgTDQgfCBMNT5dO1xuICAgIH1cbiAgICBsb2dnZXIudHJhY2UoJ2l0ZW1LZXlUb0xvY0tleUFycmF5IFJlc3VsdHMnLCB7IGlrOiBhYmJyZXZJSyhpayksIGxrYTogYWJicmV2TEtBKGxrYSkgfSk7XG4gICAgcmV0dXJuIGxrYSBhcyBMb2NLZXlBcnJheTxTLCBMMSwgTDIsIEwzLCBMND47XG4gIH1cblxuZXhwb3J0IGNvbnN0IGlrVG9MS0EgPSBpdGVtS2V5VG9Mb2NLZXlBcnJheTtcblxuLyoqXG4gICAqIFNvbWV0aW1lcyB5b3UgbmVlZCB0byB0YWtlIGEgbG9jYXRpb24ga2V5IGFycmF5IGFuZCBjb252ZXJ0IGl0IHRvIHRoZSBpdGVtIGtleSB0aGF0IHBvaW50cyB0byB0aGUgY29udGFpbmluZyBpdGVtLlxuICAgKiBAcGFyYW0gbGthIEEgbG9jYXRpb24ga2V5IGFycmF5XG4gICAqIEByZXR1cm5zIEFuIGl0ZW0ga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNvbnRhaW5pbmcgaXRlbSB0aGlzIGxvY2F0aW9uIHJlZmVycyB0by5cbiAgICovXG5leHBvcnQgY29uc3QgbG9jS2V5QXJyYXlUb0l0ZW1LZXkgPVxuICA8XG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+KGxrYTogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1Pik6XG4gICAgUHJpS2V5PEwxPiB8IENvbUtleTxMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2xvY0tleUFycmF5VG9JdGVtS2V5JywgeyBsa2E6IGFiYnJldkxLQShsa2EgYXMgQXJyYXk8TG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+PikgfSk7XG5cbiAgICBpZiAobGthICYmIGxrYS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHByaUtleSA9IGNQSyhsa2FbMF0ubGssIGxrYVswXS5rdCk7XG4gICAgICByZXR1cm4gcHJpS2V5IGFzIFByaUtleTxMMT47XG4gICAgfSBlbHNlIGlmIChsa2EgJiYgbGthLmxlbmd0aCA+IDEgJiYgbGthWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGxvY3MgPSBsa2Euc2xpY2UoMSk7XG4gICAgICBjb25zdCBwcmlLZXkgPSBjUEsobGthWzBdLmxrLCBsa2FbMF0ua3QpO1xuICAgICAgY29uc3QgY29tS2V5ID0geyBrdDogcHJpS2V5Lmt0LCBwazogcHJpS2V5LnBrLCBsb2M6IGxvY3MgYXMgdW5rbm93biBhcyBMb2NLZXlBcnJheTxMMiwgTDMsIEw0LCBMNT4gfTtcbiAgICAgIHJldHVybiBjb21LZXkgYXMgQ29tS2V5PEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG9jS2V5QXJyYXlUb0l0ZW1LZXk6IGxrYSBpcyB1bmRlZmluZWQgb3IgZW1wdHknKTtcbiAgICB9XG4gIH1cblxuLy8gVE9ETzogVGhpcyBpcyBhbm5veWluZyB0aGF0IHdlIGhhdmUgdG8gY2hlY2sgZm9yICcnIGFuZCAnbnVsbCdcbmV4cG9ydCBjb25zdCBpc1ZhbGlkUHJpS2V5ID0gPFMgZXh0ZW5kcyBzdHJpbmc+KGtleTogUHJpS2V5PFM+KTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHZhbGlkID0gKGtleSAhPT0gdW5kZWZpbmVkICYmIGtleSAhPT0gbnVsbClcbiAgICAmJiAoa2V5LnBrICE9PSB1bmRlZmluZWQgJiYga2V5LnBrICE9PSBudWxsICYmIGtleS5wayAhPT0gJycgJiYga2V5LnBrICE9PSAnbnVsbCcpXG4gICAgJiYgKGtleS5rdCAhPT0gdW5kZWZpbmVkICYmIGtleS5rdCAhPT0gbnVsbCAmJiBrZXkua3QgIT09ICcnICYmIGtleS5rdCAhPT0gJ251bGwnKTtcbiAgcmV0dXJuIHZhbGlkO1xufVxuXG4vLyBUT0RPOiBUaGlzIGlzIGFubm95aW5nIHRoYXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgJycgYW5kICdudWxsJ1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRMb2NLZXkgPSA8XG4gIEwxIGV4dGVuZHMgc3RyaW5nLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGtleTogTG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+KTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHZhbGlkID0gKGtleSAhPT0gdW5kZWZpbmVkICYmIGtleSAhPT0gbnVsbClcbiAgICAmJiAoa2V5LmxrICE9PSB1bmRlZmluZWQgJiYga2V5LmxrICE9PSBudWxsICYmIGtleS5sayAhPT0gJycgJiYga2V5LmxrICE9PSAnbnVsbCcpXG4gICAgJiYgKGtleS5rdCAhPT0gdW5kZWZpbmVkICYmIGtleS5rdCAhPT0gbnVsbCAmJiBrZXkua3QgIT09ICcnICYmIGtleS5rdCAhPT0gJ251bGwnKTtcbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5leHBvcnQgY29uc3QgaXNWYWxpZExvY0tleUFycmF5ID0gPFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihrZXlBcnJheTogQXJyYXk8TG9jS2V5PEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+Pik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKGtleUFycmF5ICE9PSB1bmRlZmluZWQgJiYga2V5QXJyYXkgIT09IG51bGwpICYmIGtleUFycmF5LmV2ZXJ5KGlzVmFsaWRMb2NLZXkpO1xufVxuXG5leHBvcnQgY29uc3QgaXNWYWxpZENvbUtleSA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAoa2V5ICE9PSB1bmRlZmluZWRcbiAgICAmJiBrZXkgIT09IG51bGwpICYmIGlzVmFsaWRQcmlLZXkoa2V5KSAmJiBpc1ZhbGlkTG9jS2V5QXJyYXkoa2V5LmxvYyBhcyBBcnJheTxMb2NLZXk8TDEgfCBMMiB8IEwzIHwgTDQgfCBMNT4+KTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRJdGVtS2V5ID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIChpc0NvbUtleShrZXkpICYmXG4gICAgaXNWYWxpZENvbUtleShrZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pKSB8fCAoaXNQcmlLZXkoa2V5KSAmJiBpc1ZhbGlkUHJpS2V5KGtleSBhcyBQcmlLZXk8Uz4pKTtcbn1cblxuZXhwb3J0IGNvbnN0IGxrYVRvSUsgPSBsb2NLZXlBcnJheVRvSXRlbUtleTtcbiIsImltcG9ydCB7IEFsbEl0ZW1UeXBlQXJyYXlzIH0gZnJvbSBcIi4va2V5c1wiO1xuXG5leHBvcnQgY2xhc3MgQUl0ZW1TZXJ2aWNlPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiB7XG5cbiAgcHJpdmF0ZSBwa1R5cGU6IFM7XG4gIHByaXZhdGUgcGFyZW50U2VydmljZTogQUl0ZW1TZXJ2aWNlPEwxLCBMMiwgTDMsIEw0LCBMNSwgbmV2ZXI+IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGtUeXBlOiBTLFxuICAgIHBhcmVudFNlcnZpY2U/OiBBSXRlbVNlcnZpY2U8TDEsIEwyLCBMMywgTDQsIEw1LCBuZXZlcj4sXG4gICkge1xuICAgIHRoaXMucGtUeXBlID0gcGtUeXBlO1xuICAgIGlmIChwYXJlbnRTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnBhcmVudFNlcnZpY2UgPSBwYXJlbnRTZXJ2aWNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRQa1R5cGUgPSAoKTogUyA9PiB7XG4gICAgcmV0dXJuIHRoaXMucGtUeXBlO1xuICB9XG5cbiAgcHVibGljIGdldEtleVR5cGVzID0gKCk6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICAgIGxldCBrZXlUeXBlczogcmVhZG9ubHkgc3RyaW5nW10gPSBbdGhpcy5nZXRQa1R5cGUoKV07XG5cbiAgICBpZiAodGhpcy5wYXJlbnRTZXJ2aWNlKSB7XG4gICAgICBrZXlUeXBlcyA9IGtleVR5cGVzLmNvbmNhdCh0aGlzLnBhcmVudFNlcnZpY2UuZ2V0S2V5VHlwZXMoKSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlUeXBlcyBhcyBBbGxJdGVtVHlwZUFycmF5czxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICB9XG5cbn1cbiIsImltcG9ydCB7IFJlZmVyZW5jZXMgfSBmcm9tICcuLi9pdGVtcyc7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5UGFyYW1zID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+O1xuXG4vKipcbiAqIFRoZSBvcGVyYXRvciBmb3IgYSBjb25kaXRpb24uICBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBvcGVyYXRvcnMgdXNlZCBpbiB0aGUgRmlyZXN0b3JlIHF1ZXJ5IGxhbmd1YWdlLlxuICovXG5leHBvcnQgdHlwZSBDb25kaXRpb25PcGVyYXRvciA9XG4gICc9PScgfCAnIT0nIHwgJz4nIHwgJz49JyB8ICc8JyB8ICc8PScgfCAnaW4nIHwgJ25vdC1pbicgfCAnYXJyYXktY29udGFpbnMnIHwgJ2FycmF5LWNvbnRhaW5zLWFueSc7XG5cbi8qKlxuICogQSBzaW5nbGUgcHJvcGVydHkgY29uZGl0aW9uIGlzIGRlZmluZWQgd2l0aCBhIGNvbHVtbiwgdmFsdWUsIGFuZCBvcGVyYXRvci5cbiAqIFRoaXMgaXMgYSBjb25kaXRpb24gdGhhdCBpcyB1c2VkIGluIGEgcXVlcnkuXG4gKi9cbmV4cG9ydCB0eXBlIENvbmRpdGlvbiA9IHtcbiAgY29sdW1uOiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmdbXSB8IHN0cmluZyB8IG51bWJlcltdIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUsXG4gIG9wZXJhdG9yOiBDb25kaXRpb25PcGVyYXRvcixcbn07XG5cbi8qKlxuICogV2hlbiBhcHBseWluZyBhIGNvbXBvdW5kIGNvbmRpdGlvbiwgdGhlIENvbXBvdW5kVHlwZSBkZWZpbmVzIHRoZSB0eXBlIG9mIGNvbXBvdW5kIGNvbmRpdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgQ29tcG91bmRUeXBlID0gJ0FORCcgfCAnT1InO1xuXG4vKipcbiAqIFdoZW4gY29uZmlndXJpbmcgYSBDb21wb3VuZENvbmRpdGlvbiB0aGlzIGNhbiBjb250YWluIGEgY29sbGVjdGlvbiBvZiBjb25kaXRpb25zXG4gKiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcXVlcnkuICBCeSBkZWZhdWx0LCB0aGlzIGlzIGFuIEFORCBjb25kaXRpaW9uIHRoYXQgaXMgYXNzb2NpYXRlZFxuICogd2l0aCBhbiBhcnJheSBvZiBDb25kaXRpb24gb2JqZWN0cyBPUiBhbiBhcnJheSBvZiBDb21wb3VuZENvbmRpdGlvbiBvYmplY3RzLlxuICpcbiAqIEZvciBleGFtcGxlLCBJIGNvdWxkIGhhdmUgeyBjb21wb3VuZFR5cGU6ICdBTkQnLCBjb25kaXRpb25zOiBbe2NvbHVtbjogJ25hbWUnLCB2YWx1ZTogJ3Rlc3QnLCBvcGVyYXRvcjogJz09J30sXG4gKiB7Y29sdW1uOiAnYWdlJywgdmFsdWU6IDIxLCBvcGVyYXRvcjogJz49J31dfSB3aGljaCB3b3VsZCBmaWx0ZXIgdGhlIHF1ZXJ5IHRvIG9ubHkgaW5jbHVkZSBpdGVtc1xuICogd2hlcmUgdGhlIG5hbWUgaXMgJ3Rlc3QnIGFuZCB0aGUgYWdlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyMS5cbiAqXG4gKiBPciwgSSBjb3VsZCBoYXZlIGEgeyBjb21wb3VuZFR5cGU6ICdPUicsIGNvbmRpdGlvbnM6IFt7Y29sdW1uOiAnbmFtZScsIHZhbHVlOiAndGVzdCcsIG9wZXJhdG9yOiAnPT0nfSxcbiAqIHtjb2x1bW46ICdhZ2UnLCB2YWx1ZTogMjEsIG9wZXJhdG9yOiAnPj0nfV19IHdoaWNoIHdvdWxkIGZpbHRlciB0aGUgcXVlcnkgdG8gb25seSBpbmNsdWRlIGl0ZW1zXG4gKiB3aGVyZSB0aGUgbmFtZSBpcyAndGVzdCcgT1IgdGhlIGFnZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMjEuXG4gKlxuICogSSBjb3VsZCBhbHNvIG5lc3QgYW4gT1Igd2l0aGluIGFuIEFORCwgbGlrZSB0aGlzOlxuICogWydBTkQnLCBbe2NvbHVtbjogJ25hbWUnLCB2YWx1ZTogJ3Rlc3QnLCBvcGVyYXRvcjogJz09J30sXG4gKiB7IGNvbXBvdW5kVHlwZTogJ09SJywgY29uZGl0aW9uczogW3tjb2x1bW46ICdhZ2UnLCB2YWx1ZTogMjEsIG9wZXJhdG9yOiAnPD0nfSxcbiAqIHtjb2x1bW46ICdhZ2UnLCB2YWx1ZTogNTIsIG9wZXJhdG9yOiAnPj0nfV19XV0gd2hpY2ggd291bGQgZmlsdGVyIHRoZSBxdWVyeSB0byBvbmx5IGluY2x1ZGUgaXRlbXMgd2hlcmUgdGhlXG4gKiBuYW1lIGlzICd0ZXN0JyBhbmQgdGhlIGFnZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjEgb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDUyLlxuICovXG5leHBvcnQgdHlwZSBDb21wb3VuZENvbmRpdGlvbiA9IHtcbiAgY29tcG91bmRUeXBlOiBDb21wb3VuZFR5cGUsXG4gIGNvbmRpdGlvbnM6IEFycmF5PENvbmRpdGlvbiB8IENvbXBvdW5kQ29uZGl0aW9uPlxufTtcblxuZXhwb3J0IGNvbnN0IGlzQ29uZGl0aW9uID0gKGNvbmRpdGlvbjogYW55KTogY29uZGl0aW9uIGlzIENvbmRpdGlvbiA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGNvbmRpdGlvbi5jb2x1bW4gPT09ICdzdHJpbmcnICYmXG4gICAgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uLnZhbHVlKSAmJiBjb25kaXRpb24udmFsdWUuZXZlcnkoKGl0ZW06IGFueSkgPT4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSkgfHxcbiAgICAoQXJyYXkuaXNBcnJheShjb25kaXRpb24udmFsdWUpICYmIGNvbmRpdGlvbi52YWx1ZS5ldmVyeSgoaXRlbTogYW55KSA9PiB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicpKSB8fFxuICAgIHR5cGVvZiBjb25kaXRpb24udmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIGNvbmRpdGlvbi52YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgY29uZGl0aW9uLnZhbHVlID09PSAnYm9vbGVhbicgfHxcbiAgICBjb25kaXRpb24udmFsdWUgaW5zdGFuY2VvZiBEYXRlXG4gICkgJiYgKGNvbmRpdGlvbi5vcGVyYXRvciA/IHR5cGVvZiBjb25kaXRpb24ub3BlcmF0b3IgPT09ICdzdHJpbmcnIDogdHJ1ZSk7XG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50UXVlcnkgPSB7XG4gIHN0YXJ0PzogRGF0ZSxcbiAgZW5kPzogRGF0ZSxcbiAgYnk/OiBzdHJpbmcsXG59XG5cbmV4cG9ydCB0eXBlIE9yZGVyRGlyZWN0aW9uID0gJ2FzYycgfCAnZGVzYyc7XG5cbmV4cG9ydCB0eXBlIE9yZGVyQnkgPSB7XG4gIGZpZWxkOiBzdHJpbmc7XG4gIGRpcmVjdGlvbjogT3JkZXJEaXJlY3Rpb247XG59XG5cbmV4cG9ydCB0eXBlIEl0ZW1RdWVyeSA9IHtcbiAgcmVmcz86IFJlZmVyZW5jZXM7XG4gIGNvbXBvdW5kQ29uZGl0aW9uPzogQ29tcG91bmRDb25kaXRpb247XG4gIGxpbWl0PzogbnVtYmVyO1xuICBvZmZzZXQ/OiBudW1iZXI7XG4gIGFnZ3M/OiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIEl0ZW1RdWVyeVxuICA+O1xuICBldmVudHM/OiBSZWNvcmQ8c3RyaW5nLCBFdmVudFF1ZXJ5PjtcbiAgb3JkZXJCeT86IE9yZGVyQnlbXTtcbn07XG5cbiIsImltcG9ydCB7IGNQSyB9IGZyb20gJy4uL2tleS9LVXRpbHMnO1xuaW1wb3J0IHtcbiAgQ29tcG91bmRUeXBlLFxuICBDb25kaXRpb24sXG4gIENvbmRpdGlvbk9wZXJhdG9yLFxuICBFdmVudFF1ZXJ5LFxuICBpc0NvbmRpdGlvbixcbiAgSXRlbVF1ZXJ5LFxuICBPcmRlckRpcmVjdGlvblxufSBmcm9tIFwiLi9JdGVtUXVlcnlcIjtcblxuZXhwb3J0IGNsYXNzIElRRmFjdG9yeSB7XG5cbiAgcHJpdmF0ZSBxdWVyeTogSXRlbVF1ZXJ5ID0ge307XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSkge1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfVxuXG4gIHB1YmxpYyBvcmRlckJ5KGZpZWxkOiBzdHJpbmcsIGRpcmVjdGlvbjogT3JkZXJEaXJlY3Rpb24gPSAnYXNjJykge1xuICAgIGlmICghdGhpcy5xdWVyeS5vcmRlckJ5KSB7XG4gICAgICB0aGlzLnF1ZXJ5Lm9yZGVyQnkgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeS5vcmRlckJ5LnB1c2goeyBmaWVsZCwgZGlyZWN0aW9uIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGFnZyhuYW1lOiBzdHJpbmcsIHF1ZXJ5OiBJdGVtUXVlcnkpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkuYWdncykge1xuICAgICAgdGhpcy5xdWVyeS5hZ2dzID0ge307XG4gICAgfVxuICAgIHRoaXMucXVlcnkuYWdnc1tuYW1lXSA9IHF1ZXJ5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGV2ZW50KG5hbWU6IHN0cmluZywgcXVlcnk6IEV2ZW50UXVlcnkpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkuZXZlbnRzKSB7XG4gICAgICB0aGlzLnF1ZXJ5LmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5LmV2ZW50c1tuYW1lXSA9IHF1ZXJ5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGNvbmRpdGlvbnMoY29uZGl0aW9uczogQ29uZGl0aW9uW10sIGNvbXBvdW5kVHlwZTogQ29tcG91bmRUeXBlID0gJ0FORCcpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbiBvZiBjb25kaXRpb25zKSB7XG4gICAgICBpZiAoIWlzQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbmRpdGlvbjogJHtKU09OLnN0cmluZ2lmeShjb25kaXRpb24pfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHRvcC1sZXZlbCBjb21wb3VuZCBjb25kaXRpb24sIGNyZWF0ZSBvbmVcbiAgICAgIC8vIHdpdGggdGhlIGdpdmVuIGNvbXBvdW5kIHR5cGUuICAgVGhpcyB3aWxsIG1vc3RseSBsaWtlbHkgYmUgdGhlIG1vc3QgY29tbW9uIGNhc2UuXG4gICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICBjb21wb3VuZFR5cGUsXG4gICAgICAgIGNvbmRpdGlvbnM6IGNvbmRpdGlvbnMsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgdG9wLWxldmVsIGNvbXBvdW5kIGNvbmRpdGlvbiwgY3JlYXRlIGEgbmV3IGNvbXBvdW5kIGNvbmRpdGlvblxuICAgICAgLy8gYW5kIGFkZCBpdCB0byB0aGUgY29uZGl0aW9ucyBhcnJheSBvZiB0aGUgdG9wLWxldmVsIGNvbXBvdW5kIGNvbmRpdGlvbi5cbiAgICAgIGNvbnN0IGNvbXBvdW5kQ29uZGl0aW9uID0ge1xuICAgICAgICBjb21wb3VuZFR5cGUsXG4gICAgICAgIGNvbmRpdGlvbnMsXG4gICAgICB9O1xuICAgICAgdGhpcy5xdWVyeS5jb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zLnB1c2goY29tcG91bmRDb25kaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBsaW1pdChsaW1pdDogbnVtYmVyKSB7XG4gICAgdGhpcy5xdWVyeS5saW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIG9mZnNldChvZmZzZXQ6IG51bWJlcikge1xuICAgIHRoaXMucXVlcnkub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gVE9ETzogcmlnaHQgbm93LCB3ZSdyZSBvbmx5IHN1cHBvcnRpbmcgUEsgcmVmcyBmb3IgcXVlcmllcy4gIFNob3VsZCBhZGQgc3VwcG9ydCBmb3IgQ0tzXG4gIHB1YmxpYyBwayhrdDogc3RyaW5nLCBwazogc3RyaW5nLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LnJlZnMpIHtcbiAgICAgIHRoaXMucXVlcnkucmVmcyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCByZWZOYW1lID0gbmFtZSB8fCBrdDtcbiAgICB0aGlzLnF1ZXJ5LnJlZnNbcmVmTmFtZV0gPSBjUEs8c3RyaW5nPihwaywga3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGNvbmRpdGlvbihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nW10gfCBzdHJpbmcgfCBudW1iZXJbXSB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlLFxuICAgIG9wZXJhdG9yOiBDb25kaXRpb25PcGVyYXRvciA9ICc9PScsXG4gICkge1xuICAgIGNvbnN0IGNvbmRpdGlvbjogQ29uZGl0aW9uID0geyBjb2x1bW4sIHZhbHVlLCBvcGVyYXRvciB9O1xuICAgIGlmIChpc0NvbmRpdGlvbihjb25kaXRpb24pKSB7XG4gICAgICBpZiAoIXRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdG9wLWxldmVsIGNvbXBvdW5kIGNvbmRpdGlvbiwgY3JlYXRlIG9uZVxuICAgICAgICAvLyB3aXRoIHRoZSBkZWZhdWx0IGNvbXBvdW5kIHR5cGUgb2YgJ0FORCcuXG4gICAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24gPSB7XG4gICAgICAgICAgY29tcG91bmRUeXBlOiAnQU5EJyxcbiAgICAgICAgICBjb25kaXRpb25zOiBbXSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbmRpdGlvbjogJHtKU09OLnN0cmluZ2lmeShjb25kaXRpb24pfWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYWxsKCkge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBJUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5O1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBvcmRlckJ5KGZpZWxkOiBzdHJpbmcsIGRpcmVjdGlvbjogT3JkZXJEaXJlY3Rpb24gPSAnYXNjJykge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBJUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5Lm9yZGVyQnkoZmllbGQsIGRpcmVjdGlvbik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFnZyhuYW1lOiBzdHJpbmcsIHF1ZXJ5OiBJdGVtUXVlcnkpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5hZ2cobmFtZSwgcXVlcnkpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBldmVudChuYW1lOiBzdHJpbmcsIHF1ZXJ5OiBFdmVudFF1ZXJ5KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IElRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuZXZlbnQobmFtZSwgcXVlcnkpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBsaW1pdChsaW1pdDogbnVtYmVyKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IElRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkubGltaXQobGltaXQpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBvZmZzZXQob2Zmc2V0OiBudW1iZXIpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5vZmZzZXQob2Zmc2V0KTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGsoa3Q6IHN0cmluZywgcGs6IHN0cmluZywgbmFtZT86IHN0cmluZykge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBJUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LnBrKGt0LCBwaywgbmFtZSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNvbmRpdGlvbihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nW10gfCBzdHJpbmcgfCBudW1iZXJbXSB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlLFxuICAgIG9wZXJhdG9yOiBDb25kaXRpb25PcGVyYXRvciA9ICc9PSdcbiAgKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IElRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkuY29uZGl0aW9uKGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY29uZGl0aW9ucyhjb25kaXRpb25zOiBDb25kaXRpb25bXSwgY29tcG91bmRUeXBlOiBDb21wb3VuZFR5cGUgPSAnQU5EJykge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBJUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmNvbmRpdGlvbnMoY29uZGl0aW9ucywgY29tcG91bmRUeXBlKTtcbiAgfVxuXG4gIHRvUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cbn0iLCJpbXBvcnQgeyBJdGVtLCBSZWZlcmVuY2VJdGVtLCBSZWZlcmVuY2VzIH0gZnJvbSBcIi4uL2l0ZW1zXCI7XG5pbXBvcnQgeyBpc0l0ZW1LZXlFcXVhbCwgaXNQcmlLZXkgfSBmcm9tIFwiLi4va2V5L0tVdGlsc1wiO1xuaW1wb3J0IHsgQ29tS2V5LCBQcmlLZXkgfSBmcm9tIFwiLi4va2V5c1wiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgKiBhcyBsdXhvbiBmcm9tICdsdXhvbic7XG5pbXBvcnQgeyBDb21wb3VuZENvbmRpdGlvbiwgQ29uZGl0aW9uLCBFdmVudFF1ZXJ5LCBpc0NvbmRpdGlvbiwgSXRlbVF1ZXJ5LCBRdWVyeVBhcmFtcyB9IGZyb20gXCIuL0l0ZW1RdWVyeVwiO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdJUVV0aWxzJyk7XG5cbi8qKlxuICogV2hlbiB3ZSBxdWVyeSBvciBzZWFyY2gsIHdlJ3JlIHNlbmRpbmcgYSBHRVQgcmVxdWVzdC4gIFRoaXMgY29udmVydHMgZXZlcnl0aGluZyBpbiBJdGVtUXVlcnkgaW50byBhIGZsYXRcbiAqIG9iamVjdCB0aGF0IGNhbiBiZSBzZW50IG92ZXIgYSBHRVQgcmVxdWVzdC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgc29tZSBkaXNjdXNzaW9uIGFib3V0IHRoaXMuICBFdmlkZW50bHkgRWxhc3RpYyBzdXBwb3J0cyBzZWFyY2ggd2l0aCBQT1NULCBidXQgdGhhdCBhbHNvXG4gKiBmZWVscyBsaWtlIGEgYml0IG9mIGEgaGFjay4gSXQncyBub3QgYSBSRVNUZnVsIHdheSB0byBkbyB0aGluZ3MuICBTbyB3ZSdyZSBzdGlja2luZyB3aXRoIEdFVCBmb3Igbm93LlxuICpcbiAqIEZvciByZWZlcmVuY2UsIGxvb2sgYXQgUkZDIDkxMTAgXCJIVFRQIFNlbWFudGljc1wiLCBKdW5lIHdoaWNoIGNsYXJpZmllZCBvbiB0b3Agb2YgYW5kIFJGQyA3MjMxLiAgSXQncyBwb3NzaWJsZVxuICogYnV0IHRoZXJlIGFyZSBzbyBtYW55IGNhdmVhdHMgYW5kIGNvbmRpdGlvbnMgaW4gdGhlIHN0YW5kYXJkLCBpdCdzIG5vdCB3b3J0aCBpdC5cbiAqXG4gKiBBbnRpY2lwYXRpbmcgdGhlIG5leHQgcXVlc3Rpb24gLSBcImlzbid0IHRoZXJlIGEgbGltaXQgdG8gdGhlIGxlbmd0aCBvZiBhIFVSTD9cIiAgIFRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90XG4gKiBzcGVjaWZ5IGEgbGltaXQsIGFuZCB0aGVyZSBhcmUgbGltaXRzIGluIHZhcmlvdXMgYnJvd3NlcnMgYW5kIHNlcnZlcnMgLSBBcGFjaGUgaXMgNCwwMDAgY2hhcnMsIENocm9tZSBpcyAyTSBjaGFycy5cbiAqIFNob3J0IGFuc3dlciBpcyB0aGF0IGlmIHRoaXMgcXVlcnkgaXMgYmVpbmcgdXNlZCB0byBjcmFmdCBzb21ldGhpbmcgdGhhdCBjb21wbGV4LCBpdCBpcyBwcm9iYWJseSBhIGJldHRlciBpZGVhXG4gKiB0byBwcm92aWRlIGFuIGFjdGlvbiBvciBhIGN1c3RvbSBxdWVyeSBlbmRwb2ludCBvbiB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBxdWVyeVxuICogQHJldHVybnMgUXVlcnlQYXJhbXMgcmVhZHkgdG8gYmUgZ2V0IG92ZXIgYSBHRVQgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5VG9QYXJhbXMgPSAocXVlcnk6IEl0ZW1RdWVyeSk6IFF1ZXJ5UGFyYW1zID0+IHtcbiAgY29uc3QgcGFyYW1zOiBRdWVyeVBhcmFtcyA9IHt9O1xuICBpZiAocXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICBwYXJhbXMuY29tcG91bmRDb25kaXRpb24gPSBKU09OLnN0cmluZ2lmeShxdWVyeS5jb21wb3VuZENvbmRpdGlvbik7XG4gIH1cbiAgaWYgKHF1ZXJ5LnJlZnMpIHtcbiAgICBwYXJhbXMucmVmcyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LnJlZnMpO1xuICB9XG4gIGlmIChxdWVyeS5saW1pdCkge1xuICAgIHBhcmFtcy5saW1pdCA9IHF1ZXJ5LmxpbWl0O1xuICB9XG4gIGlmIChxdWVyeS5vZmZzZXQpIHtcbiAgICBwYXJhbXMub2Zmc2V0ID0gcXVlcnkub2Zmc2V0O1xuICB9XG4gIGlmIChxdWVyeS5hZ2dzKSB7XG4gICAgcGFyYW1zLmFnZ3MgPSBKU09OLnN0cmluZ2lmeShxdWVyeS5hZ2dzKTtcbiAgfVxuICBpZiAocXVlcnkuZXZlbnRzKSB7XG4gICAgcGFyYW1zLmV2ZW50cyA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LmV2ZW50cyk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLy8gVGhpcyBpcyBhIGRhdGVUaW1lUmV2aXZlciB1c2VkIGZvciBKU09OIHBhcnNlIC0gd2hlbiB3ZSBjb252ZXJ0IGEgcGFyYW0gYmFjayB0byBhIHF1ZXJ5LCB3ZSBuZWVkIHRoaXMuXG5jb25zdCBkYXRlVGltZVJldml2ZXIgPSBmdW5jdGlvbiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBwYXJzZWREYXRlID0gbHV4b24uRGF0ZVRpbWUuZnJvbUlTTyh2YWx1ZSk7XG4gICAgaWYgKHBhcnNlZERhdGUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERhdGUudG9KU0RhdGUoKTs7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0cmFuc2xhdGVzIGZyb20gYSBmbGF0IFF1ZXJ5UGFyYW1zIG9iamVjdCB3aXRoIHN0cmluZ2lmeSdkIEpTT04gYmFjayB0byBhIGZ1bGwgSXRlbVF1ZXJ5LlxuICpcbiAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBzZW50IG92ZXIgYSBHRVQgcmVxdWVzdFxuICogQHJldHVybnMgQSBmdWxseSBoeWRyYXRlZCBJdGVtUXVlcnkgb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgcGFyYW1zVG9RdWVyeSA9IChwYXJhbXM6IFF1ZXJ5UGFyYW1zKTogSXRlbVF1ZXJ5ID0+IHtcbiAgY29uc3QgcXVlcnk6IEl0ZW1RdWVyeSA9IHt9O1xuICBpZiAocGFyYW1zLmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgcXVlcnkuY29tcG91bmRDb25kaXRpb24gPSBKU09OLnBhcnNlKHBhcmFtcy5jb21wb3VuZENvbmRpdGlvbiBhcyBzdHJpbmcpIGFzIENvbXBvdW5kQ29uZGl0aW9uO1xuICB9XG4gIGlmIChwYXJhbXMucmVmcykge1xuICAgIHF1ZXJ5LnJlZnMgPSBKU09OLnBhcnNlKHBhcmFtcy5yZWZzIGFzIHN0cmluZykgYXMgUmVmZXJlbmNlcztcbiAgfVxuICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgcXVlcnkubGltaXQgPSBOdW1iZXIocGFyYW1zLmxpbWl0KTtcbiAgfVxuICBpZiAocGFyYW1zLm9mZnNldCkge1xuICAgIHF1ZXJ5Lm9mZnNldCA9IE51bWJlcihwYXJhbXMub2Zmc2V0KTtcbiAgfVxuICBpZiAocGFyYW1zLmFnZ3MpIHtcbiAgICBxdWVyeS5hZ2dzID0gSlNPTi5wYXJzZShwYXJhbXMuYWdncyBhcyBzdHJpbmcpIGFzIFJlY29yZDxzdHJpbmcsIEl0ZW1RdWVyeT47XG4gIH1cbiAgaWYgKHBhcmFtcy5ldmVudHMpIHtcbiAgICBxdWVyeS5ldmVudHMgPSBKU09OLnBhcnNlKHBhcmFtcy5ldmVudHMgYXMgc3RyaW5nLCBkYXRlVGltZVJldml2ZXIpIGFzIFJlY29yZDxzdHJpbmcsIHsgc3RhcnQ/OiBEYXRlLCBlbmQ/OiBEYXRlIH0+O1xuICB9XG4gIHJldHVybiBxdWVyeTtcbn1cblxuY29uc3QgaXNSZWZRdWVyeU1hdGNoID1cbiAgPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4oXG4gICAgcmVmS2V5OiBzdHJpbmcsXG4gICAgcXVlcnlSZWY6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIHJlZmVyZW5jZXM6IFJlZmVyZW5jZXMsXG4gICk6IGJvb2xlYW4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnZG9lc1JlZk1hdGNoJywgeyBxdWVyeVJlZiwgcmVmZXJlbmNlcyB9KTtcbiAgICBsb2dnZXIuZGVidWcoJ0NvbXBhcmluZyBSZWYnLCB7IHJlZktleSwgaXRlbVJlZjogcmVmZXJlbmNlc1tyZWZLZXldLCBxdWVyeVJlZiB9KTtcbiAgICByZXR1cm4gaXNJdGVtS2V5RXF1YWwocXVlcnlSZWYsIHJlZmVyZW5jZXNbcmVmS2V5XSk7XG4gIH1cblxuY29uc3QgaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2ggPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgcXVlcnlDb25kaXRpb246IENvbXBvdW5kQ29uZGl0aW9uLFxuICAgIGl0ZW06IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgKTogYm9vbGVhbiA9PiB7XG4gIGlmIChxdWVyeUNvbmRpdGlvbi5jb21wb3VuZFR5cGUgPT09ICdBTkQnKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBBTkQgY29tcG91bmQgY29uZGl0aW9uLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGFsbCBvZiB0aGUgY29uZGl0aW9ucyBtYXRjaFxuICAgIHJldHVybiBxdWVyeUNvbmRpdGlvbi5jb25kaXRpb25zLmV2ZXJ5KFxuICAgICAgKGNvbmRpdGlvbjogQ29uZGl0aW9uIHwgQ29tcG91bmRDb25kaXRpb24pID0+XG4gICAgICAgIGlzQ29uZGl0aW9uKGNvbmRpdGlvbikgP1xuICAgICAgICAgIGlzQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pIDpcbiAgICAgICAgICBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGlzIGlzIGFuIE9SIGNvbXBvdW5kIGNvbmRpdGlvbiwgd2UgbmVlZCB0byBjaGVjayBpZiBhbnkgb2YgdGhlIGNvbmRpdGlvbnMgbWF0Y2hcbiAgICByZXR1cm4gcXVlcnlDb25kaXRpb24uY29uZGl0aW9ucy5zb21lKFxuICAgICAgKGNvbmRpdGlvbjogQ29uZGl0aW9uIHwgQ29tcG91bmRDb25kaXRpb24pID0+XG4gICAgICAgIGlzQ29uZGl0aW9uKGNvbmRpdGlvbikgP1xuICAgICAgICAgIGlzQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pIDpcbiAgICAgICAgICBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBpc0NvbmRpdGlvblF1ZXJ5TWF0Y2ggPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAgcXVlcnlDb25kaXRpb246IENvbmRpdGlvbixcbiAgICBpdGVtOiBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBwcm9wS2V5ID0gcXVlcnlDb25kaXRpb24uY29sdW1uO1xuICBsb2dnZXIudHJhY2UoJ2RvZXNDb25kaXRpb25NYXRjaCcsIHsgcHJvcEtleSwgcXVlcnlDb25kaXRpb24sIGl0ZW0gfSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKGl0ZW1bcHJvcEtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnSXRlbSBkb2VzIG5vdCBjb250YWluIHByb3AgdW5kZXIga2V5JywgeyBwcm9wS2V5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2dnZXIuZGVidWcoJ0NvbXBhcmluZyBDb25kaXRpb24nLCB7IHByb3BLZXksIGl0ZW1Qcm9wOiBpdGVtW3Byb3BLZXldLCBxdWVyeUNvbmRpdGlvbiB9KTtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICBzd2l0Y2ggKHF1ZXJ5Q29uZGl0aW9uLm9wZXJhdG9yKSB7XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA9PT0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICchPSc6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldICE9PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz4nOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA+IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA+PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzwnOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA8IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA8PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2luJzpcbiAgICAgIHJlc3VsdCA9IChxdWVyeUNvbmRpdGlvbi52YWx1ZSBhcyB1bmtub3duIGFzIHN0cmluZ1tdKS5pbmNsdWRlcyhpdGVtW3Byb3BLZXldIGFzIHN0cmluZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdub3QtaW4nOlxuICAgICAgcmVzdWx0ID0gIShxdWVyeUNvbmRpdGlvbi52YWx1ZSBhcyB1bmtub3duIGFzIHN0cmluZ1tdKS5pbmNsdWRlcyhpdGVtW3Byb3BLZXldIGFzIHN0cmluZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhcnJheS1jb250YWlucyc6XG4gICAgICByZXN1bHQgPSAoaXRlbVtwcm9wS2V5XSBhcyB1bmtub3duIGFzIHN0cmluZ1tdKS5pbmNsdWRlcyhxdWVyeUNvbmRpdGlvbi52YWx1ZSBhcyBzdHJpbmcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYXJyYXktY29udGFpbnMtYW55JzpcbiAgICAgIHJlc3VsdCA9IChxdWVyeUNvbmRpdGlvbi52YWx1ZSBhcyB1bmtub3duIGFzIHN0cmluZ1tdKVxuICAgICAgICAuc29tZSh2YWx1ZSA9PiAoaXRlbVtwcm9wS2V5XSBhcyB1bmtub3duIGFzIHN0cmluZ1tdKS5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgaXNBZ2dRdWVyeU1hdGNoID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIGFnZ0tleTogc3RyaW5nLFxuICAgIGFnZ1F1ZXJ5OiBJdGVtUXVlcnksXG4gICAgYWdnOiBSZWZlcmVuY2VJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IGFnZ0l0ZW0gPSBhZ2cuaXRlbTtcbiAgbG9nZ2VyLmRlYnVnKCdDb21wYXJpbmcgQWdnJywgeyBhZ2dLZXksIGFnZ0l0ZW0sIGFnZ1F1ZXJ5IH0pO1xuICAvLyBGYW5jeSwgcmlnaHQ/ICBUaGlzIGlzIGEgcmVjdXJzaXZlIGNhbGwgdG8gaXNRdWVyeU1hdGNoXG4gIHJldHVybiBpc1F1ZXJ5TWF0Y2goYWdnSXRlbSwgYWdnUXVlcnkpO1xufVxuXG5jb25zdCBpc0V2ZW50UXVlcnlNYXRjaCA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICBldmVudEtleTogc3RyaW5nLFxuICAgIGV2ZW50UXVlcnk6IEV2ZW50UXVlcnksXG4gICAgaXRlbTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICApOiBib29sZWFuID0+IHtcbiAgaWYgKCFpdGVtLmV2ZW50c1tldmVudEtleV0pIHtcbiAgICBsb2dnZXIuZGVidWcoJ0l0ZW0gZG9lcyBub3QgY29udGFpbiBldmVudCB1bmRlciBrZXknLCB7IGV2ZW50S2V5LCBldmVudHM6IGl0ZW0uZXZlbnRzIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpdGVtRXZlbnQgPSBpdGVtLmV2ZW50c1tldmVudEtleV07XG4gICAgaWYgKGl0ZW1FdmVudC5hdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV2ZW50UXVlcnkuc3RhcnQgJiYgIShldmVudFF1ZXJ5LnN0YXJ0LmdldFRpbWUoKSA8PSBpdGVtRXZlbnQuYXQuZ2V0VGltZSgpKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0l0ZW0gZGF0ZSBiZWZvcmUgZXZlbnQgc3RhcnQgcXVlcnknLCB7IGV2ZW50UXVlcnksIGl0ZW1FdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50UXVlcnkuZW5kICYmICEoZXZlbnRRdWVyeS5lbmQuZ2V0VGltZSgpID4gaXRlbUV2ZW50LmF0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdJdGVtIGRhdGUgYWZ0ZXIgZXZlbnQgZW5kIHF1ZXJ5JywgeyBldmVudFF1ZXJ5LCBpdGVtRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdJdGVtIGV2ZW50IGRvZXMgY29udGFpbnMgYSBudWxsIGF0JywgeyBpdGVtRXZlbnQgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpc1F1ZXJ5TWF0Y2ggPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oaXRlbTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LCBxdWVyeTogSXRlbVF1ZXJ5KTogYm9vbGVhbiA9PiB7XG5cbiAgbG9nZ2VyLnRyYWNlKCdpc01hdGNoJywgeyBpdGVtLCBxdWVyeSB9KTtcbiAgaWYgKHF1ZXJ5LnJlZnMgJiYgaXRlbS5yZWZzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkucmVmcykge1xuICAgICAgY29uc3QgcXVlcnlSZWYgPSBxdWVyeS5yZWZzW2tleV07XG4gICAgICBpZiAoIWlzUmVmUXVlcnlNYXRjaChrZXksIHF1ZXJ5UmVmLCBpdGVtLnJlZnMpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKHF1ZXJ5LnJlZnMgJiYgIWl0ZW0ucmVmcykge1xuICAgIGxvZ2dlci5kZWJ1ZygnUXVlcnkgY29udGFpbnMgcmVmcyBidXQgaXRlbSBkb2VzIG5vdCBoYXZlIHJlZnMnLCB7IHF1ZXJ5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChxdWVyeS5jb21wb3VuZENvbmRpdGlvbiAmJiBpdGVtKSB7XG4gICAgaWYgKCFpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChxdWVyeS5jb21wb3VuZENvbmRpdGlvbiwgaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChxdWVyeS5ldmVudHMgJiYgaXRlbS5ldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5ldmVudHMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5RXZlbnQgPSBxdWVyeS5ldmVudHNba2V5XTtcbiAgICAgIGlmICghaXNFdmVudFF1ZXJ5TWF0Y2goa2V5LCBxdWVyeUV2ZW50LCBpdGVtKSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHF1ZXJ5LmFnZ3MgJiYgaXRlbS5hZ2dzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkuYWdncykge1xuICAgICAgY29uc3QgYWdnUXVlcnkgPSBxdWVyeS5hZ2dzW2tleV07XG4gICAgICBpZiAoaXRlbS5hZ2dzW2tleV0gJiYgIWlzQWdnUXVlcnlNYXRjaChrZXksIGFnZ1F1ZXJ5LCBpdGVtLmFnZ3Nba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gaWYgKHF1ZXJ5LmFnZ3MgJiYgIWl0ZW0uYWdncykge1xuICAgIGxvZ2dlci5kZWJ1ZygnUXVlcnkgY29udGFpbnMgYWdncyBidXQgaXRlbSBkb2VzIG5vdCBoYXZlIGFnZ3MnLCB7IHF1ZXJ5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIGl0IGhhc24ndCByZXR1cm5lZCBmYWxzZSBieSBub3csIGl0IG11c3QgYmUgYSBtYXRjaFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGNvbnN0IGFiYnJldlF1ZXJ5ID0gKHF1ZXJ5OiBJdGVtUXVlcnkgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nID0+IHtcbiAgY29uc3QgYWJicmV2ID0gWydJUSddO1xuICBpZiggcXVlcnkgKSB7XG4gICAgaWYgKHF1ZXJ5LnJlZnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LnJlZnMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gYWJicmV2UmVmKGtleSwgcXVlcnkucmVmc1trZXldKTtcbiAgICAgICAgYWJicmV2LnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgICAgIGFiYnJldi5wdXNoKHByb3BzKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmFnZ3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LmFnZ3MpIHtcbiAgICAgICAgY29uc3QgYWdnID0gYWJicmV2QWdnKGtleSwgcXVlcnkuYWdnc1trZXldKTtcbiAgICAgICAgYWJicmV2LnB1c2goYWdnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmV2ZW50cykge1xuICAgICAgY29uc3QgZXZlbnRzID0gYChFJHtPYmplY3Qua2V5cyhxdWVyeS5ldmVudHMpLmpvaW4oJywnKX0pYDtcbiAgICAgIGFiYnJldi5wdXNoKGV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5saW1pdCkge1xuICAgICAgYWJicmV2LnB1c2goYEwke3F1ZXJ5LmxpbWl0fWApO1xuICAgIH1cbiAgICBpZiAocXVlcnkub2Zmc2V0KSB7XG4gICAgICBhYmJyZXYucHVzaChgTyR7cXVlcnkub2Zmc2V0fWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhYmJyZXYucHVzaCgnKGVtcHR5KScpO1xuICB9XG4gIHJldHVybiBhYmJyZXYuam9pbignICcpO1xufVxuXG5leHBvcnQgY29uc3QgYWJicmV2UmVmID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGtleTogc3RyaW5nLCByZWY6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogc3RyaW5nID0+IHtcbiAgaWYgKGlzUHJpS2V5KHJlZikpIHtcbiAgICBjb25zdCBwcmlLZXkgPSByZWYgYXMgUHJpS2V5PFM+O1xuICAgIHJldHVybiBgUigke2tleX0sJHtwcmlLZXkua3R9LCR7cHJpS2V5LnBrfSlgO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbUtleSA9IHJlZiBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICByZXR1cm4gYFIoJHtrZXl9LCR7SlNPTi5zdHJpbmdpZnkoY29tS2V5KX0pYDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYWJicmV2QWdnID0gKGtleTogc3RyaW5nLCBhZ2c6IEl0ZW1RdWVyeSk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBgQSgke2tleX0sJHthYmJyZXZRdWVyeShhZ2cpfSlgO1xufVxuXG5leHBvcnQgY29uc3QgYWJicmV2Q29tcG91bmRDb25kaXRpb24gPSAoY29tcG91bmRDb25kaXRpb246IENvbXBvdW5kQ29uZGl0aW9uKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGBDQygke2NvbXBvdW5kQ29uZGl0aW9uLmNvbXBvdW5kVHlwZX0sYCArXG4gICAgYCR7Y29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucyA/IGNvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMubWFwKGFiYnJldkNvbmRpdGlvbikuam9pbignLCcpIDogJ05vIENvbmRpdGlvbnMnfSlgO1xufVxuXG5leHBvcnQgY29uc3QgYWJicmV2Q29uZGl0aW9uID0gKGNvbmRpdGlvbjogQ29uZGl0aW9uIHwgQ29tcG91bmRDb25kaXRpb24pOiBzdHJpbmcgPT4ge1xuICBpZiAoaXNDb25kaXRpb24oY29uZGl0aW9uKSkge1xuICAgIHJldHVybiBgKCR7Y29uZGl0aW9uLmNvbHVtbn0sJHtjb25kaXRpb24udmFsdWV9LCR7Y29uZGl0aW9uLm9wZXJhdG9yfSlgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhYmJyZXZDb21wb3VuZENvbmRpdGlvbihjb25kaXRpb24pO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbiBcbmltcG9ydCB7IEl0ZW0gfSBmcm9tIFwiLi4vaXRlbXNcIjtcbmltcG9ydCB7IGlzQ29tS2V5LCBpc1ByaUtleSwgdG9LZXlUeXBlQXJyYXkgfSBmcm9tIFwiLi4va2V5L0tVdGlsc1wiO1xuaW1wb3J0IHsgQWxsSXRlbVR5cGVBcnJheXMsIENvbUtleSwgUHJpS2V5IH0gZnJvbSBcIi4uL2tleXNcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tICcuLi9sb2dnZXInO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdJVXRpbHMnKTtcblxuY29uc3QgdmFsaWRhdGVQS0Zvckl0ZW0gPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4+KGl0ZW06IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiwgcGtUeXBlOiBTKTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgaWYgKCFpdGVtKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdWYWxpZGF0aW5nIFBLLCBJdGVtIGlzIHVuZGVmaW5lZCcsIHsgaXRlbSB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpbmcgUEssIEl0ZW0gaXMgdW5kZWZpbmVkJyk7XG4gIH1cbiAgaWYgKCFpdGVtLmtleSkge1xuICAgIGxvZ2dlci5lcnJvcignVmFsaWRhdGluZyBQSywgSXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5JywgeyBpdGVtIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGluZyBQSywgSXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5Jyk7XG4gIH1cblxuICBjb25zdCBrZXlUeXBlQXJyYXkgPSB0b0tleVR5cGVBcnJheShpdGVtLmtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPik7XG4gIGlmIChrZXlUeXBlQXJyYXlbMF0gIT09IHBrVHlwZSkge1xuICAgIGxvZ2dlci5lcnJvcignS2V5IFR5cGUgQXJyYXkgTWlzbWF0Y2gnLCB7IGtleVR5cGVBcnJheSwgcGtUeXBlIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IHByaW1hcnkga2V5IHR5cGUuIEV4cGVjdGVkICR7cGtUeXBlfSwgZ290ICR7a2V5VHlwZUFycmF5WzBdfWApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlUEsgPSA8XG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4+KFxuICBpbnB1dDogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+W10sXG4gIHBrVHlwZTogUyxcbik6IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PltdID0+IHtcbiAgbG9nZ2VyLnRyYWNlKCdDaGVja2luZyBSZXR1cm4gVHlwZScsIHsgaW5wdXQgfSk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gdmFsaWRhdGVQS0Zvckl0ZW0oaXRlbSwgcGtUeXBlKSk7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlUEtGb3JJdGVtKGlucHV0LCBwa1R5cGUpO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlS2V5cyA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbj4oXG4gIGl0ZW06IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAga2V5VHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4pOiBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBsb2dnZXIudHJhY2UoJ0NoZWNraW5nIFJldHVybiBUeXBlJywgeyBpdGVtIH0pO1xuICBpZiAoIWl0ZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRpbmcga2V5cywgaXRlbSBpcyB1bmRlZmluZWQnKTtcbiAgfVxuICBpZiAoIWl0ZW0ua2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2YWxpZGF0aW5nIGtleXMsIGl0ZW0gZG9lcyBub3QgaGF2ZSBhIGtleTogJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgfVxuXG4gIGNvbnN0IGtleVR5cGVBcnJheSA9IHRvS2V5VHlwZUFycmF5KGl0ZW0ua2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTtcbiAgaWYgKGtleVR5cGVBcnJheS5sZW5ndGggIT09IGtleVR5cGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBrZXlzLiBFeHBlY3RlZCAke2tleVR5cGVzLmxlbmd0aH0sIGJ1dCBnb3QgJHtrZXlUeXBlQXJyYXkubGVuZ3RofWApO1xuICB9XG5cbiAgY29uc3QgbWF0Y2g6IGJvb2xlYW4gPSBKU09OLnN0cmluZ2lmeShrZXlUeXBlQXJyYXkpID09PSBKU09OLnN0cmluZ2lmeShrZXlUeXBlcyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0tleSBUeXBlIEFycmF5IE1pc21hdGNoJywgeyBrZXlUeXBlQXJyYXksIHRoaXNLZXlUeXBlczoga2V5VHlwZXMgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3Qga2V5IHR5cGVzLiBFeHBlY3RlZCBbJHtrZXlUeXBlcy5qb2luKCcsICcpfV0sIGJ1dCBnb3QgWyR7a2V5VHlwZUFycmF5LmpvaW4oJywgJyl9XWApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzUHJpSXRlbSA9IDxcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbj4oXG4gIGl0ZW06IEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pixcbik6IGl0ZW0gaXMgSXRlbTxTPiAmIHsga2V5OiBQcmlLZXk8Uz4gfSA9PiB7XG4gIHJldHVybiAhIShpdGVtICYmIGl0ZW0ua2V5ICYmIGlzUHJpS2V5KGl0ZW0ua2V5KSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNDb21JdGVtID0gPFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuPihcbiAgaXRlbTogSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuKTogaXRlbSBpcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gJiB7IGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfSA9PiB7XG4gIHJldHVybiAhIShpdGVtICYmIGl0ZW0ua2V5ICYmIGlzQ29tS2V5KGl0ZW0ua2V5KSk7XG59OyJdLCJuYW1lcyI6WyJsb2dnZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/@fjell/logging/dist/index.js":
/*!***************************************************************!*\
  !*** ../fjell-core/node_modules/@fjell/logging/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9AZmplbGwvbG9nZ2luZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEtBQUs7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkIsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQU1wQjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL0BmamVsbC9sb2dnaW5nL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL0xvZ0Zvcm1hdC50c1xudmFyIExvZ0Zvcm1hdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dGb3JtYXRfZXhwb3J0cywge1xuICBMb2dGb3JtYXRzOiAoKSA9PiBMb2dGb3JtYXRzLFxuICBTVFJVQ1RVUkVEOiAoKSA9PiBTVFJVQ1RVUkVELFxuICBURVhUOiAoKSA9PiBURVhULFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZ1xufSk7XG52YXIgVEVYVCA9IHtcbiAgbmFtZTogXCJURVhUXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlRleHQgZm9ybWF0XCJcbn07XG52YXIgU1RSVUNUVVJFRCA9IHtcbiAgbmFtZTogXCJTVFJVQ1RVUkVEXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZWQgZm9ybWF0XCJcbn07XG52YXIgTG9nRm9ybWF0cyA9IFtcbiAgVEVYVCxcbiAgU1RSVUNUVVJFRFxuXTtcbnZhciBnZXRDb25maWcgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dGb3JtYXRzLmZpbmQoKGNvbmZpZzIpID0+IGNvbmZpZzIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIExvZyBGb3JtYXQgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvTG9nTGV2ZWwudHNcbnZhciBMb2dMZXZlbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChMb2dMZXZlbF9leHBvcnRzLCB7XG4gIEFMRVJUOiAoKSA9PiBBTEVSVCxcbiAgQ1JJVElDQUw6ICgpID0+IENSSVRJQ0FMLFxuICBERUJVRzogKCkgPT4gREVCVUcsXG4gIERFRkFVTFQ6ICgpID0+IERFRkFVTFQsXG4gIEVNRVJHRU5DWTogKCkgPT4gRU1FUkdFTkNZLFxuICBFUlJPUjogKCkgPT4gRVJST1IsXG4gIElORk86ICgpID0+IElORk8sXG4gIExvZ0xldmVsczogKCkgPT4gTG9nTGV2ZWxzLFxuICBOT1RJQ0U6ICgpID0+IE5PVElDRSxcbiAgVFJBQ0U6ICgpID0+IFRSQUNFLFxuICBXQVJOSU5HOiAoKSA9PiBXQVJOSU5HLFxuICBnZXRDb25maWc6ICgpID0+IGdldENvbmZpZzJcbn0pO1xudmFyIEVNRVJHRU5DWSA9IHtcbiAgbmFtZTogXCJFTUVSR0VOQ1lcIixcbiAgdmFsdWU6IDBcbn07XG52YXIgQUxFUlQgPSB7XG4gIG5hbWU6IFwiQUxFUlRcIixcbiAgdmFsdWU6IDFcbn07XG52YXIgQ1JJVElDQUwgPSB7XG4gIG5hbWU6IFwiQ1JJVElDQUxcIixcbiAgdmFsdWU6IDJcbn07XG52YXIgRVJST1IgPSB7XG4gIG5hbWU6IFwiRVJST1JcIixcbiAgdmFsdWU6IDNcbn07XG52YXIgV0FSTklORyA9IHtcbiAgbmFtZTogXCJXQVJOSU5HXCIsXG4gIHZhbHVlOiA0XG59O1xudmFyIE5PVElDRSA9IHtcbiAgbmFtZTogXCJOT1RJQ0VcIixcbiAgdmFsdWU6IDVcbn07XG52YXIgSU5GTyA9IHtcbiAgbmFtZTogXCJJTkZPXCIsXG4gIHZhbHVlOiA2XG59O1xudmFyIERFQlVHID0ge1xuICBuYW1lOiBcIkRFQlVHXCIsXG4gIHZhbHVlOiA3XG59O1xudmFyIFRSQUNFID0ge1xuICBuYW1lOiBcIlRSQUNFXCIsXG4gIHZhbHVlOiA4XG59O1xudmFyIERFRkFVTFQgPSB7XG4gIG5hbWU6IFwiREVGQVVMVFwiLFxuICB2YWx1ZTogOVxufTtcbnZhciBMb2dMZXZlbHMgPSBbXG4gIEVNRVJHRU5DWSxcbiAgQUxFUlQsXG4gIENSSVRJQ0FMLFxuICBFUlJPUixcbiAgV0FSTklORyxcbiAgTk9USUNFLFxuICBJTkZPLFxuICBERUJVRyxcbiAgVFJBQ0UsXG4gIERFRkFVTFRcbl07XG52YXIgZ2V0Q29uZmlnMiA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IExvZ0xldmVscy5maW5kKChjb25maWcyKSA9PiBjb25maWcyLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMb2cgTGV2ZWwgU3VwcGxpZWQgdG8gTG9nZ2luZyBDb25maWd1cmF0aW9uICcke25hbWV9J2ApO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgZGVmYXVsdExvZ0xldmVsID0gSU5GTztcbnZhciBkZWZhdWx0TG9nRm9ybWF0ID0gVEVYVDtcbnZhciBkZWZhdWx0TG9nZ2luZ0NvbmZpZyA9IHtcbiAgbG9nTGV2ZWw6IGRlZmF1bHRMb2dMZXZlbCxcbiAgbG9nRm9ybWF0OiBkZWZhdWx0TG9nRm9ybWF0LFxuICBvdmVycmlkZXM6IHt9LFxuICBmbG9vZENvbnRyb2w6IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICAgIHRpbWVmcmFtZTogMWUzXG4gICAgLy8gMSBzZWNvbmRcbiAgfVxufTtcbnZhciBjb252ZXJ0T3ZlcnJpZGVzID0gKG92ZXJyaWRlcykgPT4ge1xuICBjb25zdCBjb252ZXJ0ZWRPdmVycmlkZXMgPSB7fTtcbiAgaWYgKG92ZXJyaWRlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKG92ZXJyaWRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjb252ZXJ0ZWRPdmVycmlkZXNba2V5XSA9IHsgbG9nTGV2ZWw6IHZhbHVlLmxvZ0xldmVsID8gZ2V0Q29uZmlnMih2YWx1ZS5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3ZlcnJpZGVzO1xufTtcbnZhciBjb252ZXJ0Q29uZmlnID0gKGNvbmZpZykgPT4ge1xuICByZXR1cm4ge1xuICAgIGxvZ0xldmVsOiBjb25maWcubG9nTGV2ZWwgPyBnZXRDb25maWcyKGNvbmZpZy5sb2dMZXZlbCkgOiBkZWZhdWx0TG9nTGV2ZWwsXG4gICAgbG9nRm9ybWF0OiBjb25maWcubG9nRm9ybWF0ID8gZ2V0Q29uZmlnKGNvbmZpZy5sb2dGb3JtYXQpIDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgICBvdmVycmlkZXM6IGNvbnZlcnRPdmVycmlkZXMoY29uZmlnLm92ZXJyaWRlcyksXG4gICAgZmxvb2RDb250cm9sOiB7XG4gICAgICAuLi5kZWZhdWx0TG9nZ2luZ0NvbmZpZy5mbG9vZENvbnRyb2wsXG4gICAgICAuLi5jb25maWcuZmxvb2RDb250cm9sIHx8IHt9XG4gICAgfVxuICB9O1xufTtcbnZhciBjb25maWd1cmVMb2dnaW5nID0gKCkgPT4ge1xuICBsZXQgY29uZmlnID0ge307XG4gIGNvbnN0IGxvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgZXhwb0xvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5FWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgY29uc3QgbmV4dExvZ2dpbmdDb25maWdFbnYgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MT0dHSU5HX0NPTkZJRztcbiAgbGV0IGxvZ0xldmVsRW52ID0gcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuICBsZXQgbG9nRm9ybWF0RW52ID0gcHJvY2Vzcy5lbnYuTE9HX0ZPUk1BVDtcbiAgaWYgKGxvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShsb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBMT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cG9Mb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoZXhwb0xvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIEVYUE9fUFVCTElDX0xPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV4dExvZ2dpbmdDb25maWdFbnYpIHtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShuZXh0TG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gTkVYVF9QVUJMSUNfTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfVxuICBjb25zdCBjb252ZXJ0ZWRDb25maWcgPSBjb252ZXJ0Q29uZmlnKGNvbmZpZyk7XG4gIGlmIChsb2dMZXZlbEVudikge1xuICAgIGxvZ0xldmVsRW52ID0gbG9nTGV2ZWxFbnY/LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nTGV2ZWxDb25maWcgPSBnZXRDb25maWcyKGxvZ0xldmVsRW52KTtcbiAgICBjb252ZXJ0ZWRDb25maWcubG9nTGV2ZWwgPSBsb2dMZXZlbENvbmZpZztcbiAgfVxuICBpZiAobG9nRm9ybWF0RW52KSB7XG4gICAgbG9nRm9ybWF0RW52ID0gbG9nRm9ybWF0RW52LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgbG9nRm9ybWF0Q29uZmlnID0gZ2V0Q29uZmlnKGxvZ0Zvcm1hdEVudik7XG4gICAgY29udmVydGVkQ29uZmlnLmxvZ0Zvcm1hdCA9IGxvZ0Zvcm1hdENvbmZpZztcbiAgfVxuICBjb25zdCBmaW5hbENvbmZpZyA9IHsgLi4uZGVmYXVsdExvZ2dpbmdDb25maWcsIC4uLmNvbnZlcnRlZENvbmZpZyB9O1xuICByZXR1cm4gZmluYWxDb25maWc7XG59O1xuXG4vLyBzcmMvV3JpdGVyLnRzXG52YXIgY3JlYXRlV3JpdGVyID0gKGZvcm1hdHRlciwgbG9nTWV0aG9kLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlc3BlY3RJbmplY3RlZE1ldGhvZCA9IGZhbHNlLFxuICAgIGVycm9yTWV0aG9kID0gY29uc29sZS5lcnJvcixcbiAgICB3YXJuaW5nTWV0aG9kID0gY29uc29sZS53YXJuLFxuICAgIGluZm9NZXRob2QgPSBjb25zb2xlLmxvZ1xuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICB3cml0ZTogKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgICAgbGV0IGZpbmFsTG9nTWV0aG9kID0gbG9nTWV0aG9kO1xuICAgICAgaWYgKCFyZXNwZWN0SW5qZWN0ZWRNZXRob2QpIHtcbiAgICAgICAgaWYgKGxldmVsLm5hbWUgPT09IEVSUk9SLm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gQ1JJVElDQUwubmFtZSB8fCBsZXZlbC5uYW1lID09PSBBTEVSVC5uYW1lIHx8IGxldmVsLm5hbWUgPT09IEVNRVJHRU5DWS5uYW1lKSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBlcnJvck1ldGhvZDtcbiAgICAgICAgfSBlbHNlIGlmIChsZXZlbC5uYW1lID09PSBXQVJOSU5HLm5hbWUpIHtcbiAgICAgICAgICBmaW5hbExvZ01ldGhvZCA9IHdhcm5pbmdNZXRob2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSBpbmZvTWV0aG9kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5hbExvZ01ldGhvZChmb3JtYXR0ZXIuZm9ybWF0TG9nKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9mb3JtYXR0ZXIudHNcbmltcG9ydCB1dGlsIGZyb20gXCJ1dGlsXCI7XG52YXIgc2FmZUluc3BlY3QgPSAob2JqKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChvYmopO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYFtPYmplY3Q6ICR7dHlwZW9mIG9ian1dYDtcbiAgfVxufTtcbnZhciBzYWZlRm9ybWF0ID0gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdXRpbC5mb3JtYXQobWVzc2FnZSwgLi4uYXJncyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgJHttZXNzYWdlfSAke3NhZmVJbnNwZWN0KGFyZ3MpfWA7XG4gIH1cbn07XG52YXIgY3JlYXRlRm9ybWF0dGVyID0gKGxvZ0Zvcm1hdCkgPT4ge1xuICBpZiAobG9nRm9ybWF0Lm5hbWUgPT09IFwiVEVYVFwiKSB7XG4gICAgcmV0dXJuIGdldFRleHRGb3JtYXR0ZXIoKTtcbiAgfSBlbHNlIGlmIChsb2dGb3JtYXQubmFtZSA9PT0gXCJTVFJVQ1RVUkVEXCIpIHtcbiAgICByZXR1cm4gZ2V0U3RydWN0dXJlZEZvcm1hdHRlcigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsb2cgZm9ybWF0OiAke2xvZ0Zvcm1hdC5uYW1lfWApO1xufTtcbnZhciBnZXRUZXh0Rm9ybWF0dGVyID0gKCkgPT4ge1xuICBjb25zdCBmb3JtYXRMb2cgPSAobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuICAgIGxldCBsb2dNZXNzYWdlO1xuICAgIGlmIChwYXlsb2FkLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dNZXNzYWdlID0gcGF5bG9hZC5tZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAoaGFzU3BlY2lmaWVycykge1xuICAgICAgbG9nTWVzc2FnZSA9IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dNZXNzYWdlID0gYCR7cGF5bG9hZC5tZXNzYWdlfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke2xvZ01lc3NhZ2V9YDtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHJhbmRvbUludCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlMiA9IGAoJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKX0pIFske2xldmVsLm5hbWV9XSAtIFske2Nvb3JkaW5hdGVzLmNhdGVnb3J5fV0gJHtjb29yZGluYXRlcy5jb21wb25lbnRzLm1hcCgoYykgPT4gYFske2N9XWApfSAke3NhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpfSAke3NhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSl9ICR7cmFuZG9tSW50fWA7XG4gICAgcmV0dXJuIHRpbWVyTWVzc2FnZTI7XG4gIH07XG4gIHJldHVybiB7IGZvcm1hdExvZywgdGltZXJNZXNzYWdlLCBnZXRMb2dGb3JtYXQ6ICgpID0+IFRFWFQgfTtcbn07XG52YXIgZ2V0U3RydWN0dXJlZEZvcm1hdHRlciA9ICgpID0+IHtcbiAgY29uc3QgZm9ybWF0TG9nID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gLyVbc2RqaWZvTyVdLy50ZXN0KHBheWxvYWQubWVzc2FnZSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHNldmVyaXR5LFxuICAgICAgbWVzc2FnZTogaGFzU3BlY2lmaWVycyA/IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpIDogcGF5bG9hZC5tZXNzYWdlLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgLi4uIWhhc1NwZWNpZmllcnMgJiYgcGF5bG9hZC5kYXRhLmxlbmd0aCA+IDAgJiYgeyBkYXRhOiBzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdGltZXJNZXNzYWdlID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHNldmVyaXR5ID0gbGV2ZWwubmFtZTtcbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzZXZlcml0eSxcbiAgICAgIG1lc3NhZ2U6IHNhZmVGb3JtYXQocGF5bG9hZC5tZXNzYWdlLCAuLi5wYXlsb2FkLmRhdGEpLFxuICAgICAgXCJsb2dnaW5nLmdvb2dsZWFwaXMuY29tL2xhYmVsc1wiOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb29yZGluYXRlcy5jYXRlZ29yeSxcbiAgICAgICAgY29tcG9uZW50czogYCR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX1gXG4gICAgICB9LFxuICAgICAgZGF0YTogc2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9zcGFuSWRcIjogU3RyaW5nKHJhbmRvbUludClcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHsgZm9ybWF0TG9nLCB0aW1lck1lc3NhZ2UsIGdldExvZ0Zvcm1hdDogKCkgPT4gU1RSVUNUVVJFRCB9O1xufTtcblxuLy8gc3JjL0Zsb29kQ29udHJvbC50c1xuaW1wb3J0IHV0aWwyIGZyb20gXCJ1dGlsXCI7XG52YXIgaGFzaCA9IChtZXNzYWdlLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGRhdGFTdHJpbmcgPSBkYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdXRpbDIuaW5zcGVjdChpdGVtKTtcbiAgICB9XG4gIH0pLmpvaW4oXCJcIik7XG4gIHJldHVybiBgJHttZXNzYWdlfSR7ZGF0YVN0cmluZ31gO1xufTtcbnZhciBGbG9vZENvbnRyb2wgPSBjbGFzcyB7XG4gIGNvbmZpZztcbiAgaGlzdG9yeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN1cHByZXNzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjbGVhbnVwVGltZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmNsZWFudXAoKSwgdGhpcy5jb25maWcudGltZWZyYW1lICogMik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2hhc2gyLCB0aW1lc3RhbXBzXSBvZiB0aGlzLmhpc3RvcnkuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByZWNlbnRUaW1lc3RhbXBzID0gdGltZXN0YW1wcy5maWx0ZXIoXG4gICAgICAgICh0aW1lc3RhbXApID0+IG5vdyAtIHRpbWVzdGFtcCA8IHRoaXMuY29uZmlnLnRpbWVmcmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChyZWNlbnRUaW1lc3RhbXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LnNldChoYXNoMiwgcmVjZW50VGltZXN0YW1wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpc3RvcnkuZGVsZXRlKGhhc2gyKTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShoYXNoMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBcImxvZ1wiO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gKHRoaXMuaGlzdG9yeS5nZXQobWVzc2FnZUhhc2gpIHx8IFtdKS5maWx0ZXIoXG4gICAgICAodGltZXN0YW1wKSA9PiBub3cgLSB0aW1lc3RhbXAgPCB0aGlzLmNvbmZpZy50aW1lZnJhbWVcbiAgICApO1xuICAgIHRpbWVzdGFtcHMucHVzaChub3cpO1xuICAgIHRoaXMuaGlzdG9yeS5zZXQobWVzc2FnZUhhc2gsIHRpbWVzdGFtcHMpO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA+IHRoaXMuY29uZmlnLnRocmVzaG9sZCkge1xuICAgICAgY29uc3Qgc3VwcHJlc3NlZEluZm8gPSB0aGlzLnN1cHByZXNzZWQuZ2V0KG1lc3NhZ2VIYXNoKTtcbiAgICAgIGlmIChzdXBwcmVzc2VkSW5mbykge1xuICAgICAgICBzdXBwcmVzc2VkSW5mby5jb3VudCsrO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLnNldChtZXNzYWdlSGFzaCwgeyBjb3VudDogMSwgZmlyc3RUaW1lc3RhbXA6IHRpbWVzdGFtcHNbMF0sIHN1bW1hcnlMb2dnZWQ6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gXCJzdXBwcmVzc1wiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zdXBwcmVzc2VkLmhhcyhtZXNzYWdlSGFzaCkpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2VkLmRlbGV0ZShtZXNzYWdlSGFzaCk7XG4gICAgICAgIHJldHVybiBcInJlc3VtZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJsb2dcIjtcbiAgfVxuICBnZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkge1xuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gaGFzaChtZXNzYWdlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk/LmNvdW50IHx8IDA7XG4gIH1cbn07XG5cbi8vIHNyYy9Mb2dnZXIudHNcbnZhciBjcmVhdGVMb2dnZXIgPSAobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIobG9nRm9ybWF0KTtcbiAgY29uc3QgZmxvb2RDb250cm9sID0gZmxvb2RDb250cm9sQ29uZmlnLmVuYWJsZWQgPyBuZXcgRmxvb2RDb250cm9sKGZsb29kQ29udHJvbENvbmZpZykgOiBudWxsO1xuICBjb25zdCBsb2dGdW5jdGlvbiA9IGNvbnNvbGUubG9nO1xuICBjb25zdCB3cml0ZXIgPSBjcmVhdGVXcml0ZXIoZm9ybWF0dGVyLCBsb2dGdW5jdGlvbiwgd3JpdGVyT3B0aW9ucyk7XG4gIGNvbnN0IHdyaXRlID0gKGxldmVsLCBtZXNzYWdlLCBkYXRhKSA9PiB7XG4gICAgaWYgKGxvZ0xldmVsLnZhbHVlIDwgbGV2ZWwudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hlY2sgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuY2hlY2sobWVzc2FnZSwgZGF0YSkgOiBcImxvZ1wiO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7IG1lc3NhZ2UsIGRhdGEgfTtcbiAgICBzd2l0Y2ggKGNoZWNrKSB7XG4gICAgICBjYXNlIFwibG9nXCI6XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdXBwcmVzc1wiOlxuICAgICAgICBpZiAoZmxvb2RDb250cm9sICYmIGZsb29kQ29udHJvbC5nZXRTdXBwcmVzc2VkQ291bnQobWVzc2FnZSwgZGF0YSkgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgY29uc3QgbmV3UGF5bG9hZCA9IHsgbWVzc2FnZTogYFN0YXJ0ZWQgc3VwcHJlc3NpbmcgcmVwZWF0ZWQgbG9nIG1lc3NhZ2VgLCBkYXRhOiBbXSB9O1xuICAgICAgICAgIHdyaXRlci53cml0ZShvcmlnaW5hbExldmVsLCBjb29yZGluYXRlcywgbmV3UGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVzdW1lXCI6IHtcbiAgICAgICAgY29uc3QgY291bnQgPSBmbG9vZENvbnRyb2wgPyBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIDogMDtcbiAgICAgICAgY29uc3QgcmVzdW1lUGF5bG9hZCA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBgU3RvcHBlZCBzdXBwcmVzc2luZyByZXBlYXRlZCBsb2cgbWVzc2FnZS4gU3VwcHJlc3NlZCAke2NvdW50fSB0aW1lcy5gLFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlci53cml0ZShsZXZlbCwgY29vcmRpbmF0ZXMsIHJlc3VtZVBheWxvYWQpO1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGFydFRpbWVMb2dnZXIgPSAobG9nTGV2ZWwyLCBjb29yZGluYXRlczIsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB0aW1lck1lc3NhZ2UgPSBmb3JtYXR0ZXIudGltZXJNZXNzYWdlKGxvZ0xldmVsMiwgY29vcmRpbmF0ZXMyLCBwYXlsb2FkKTtcbiAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lKHRpbWVyTWVzc2FnZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuZDogKCkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lRW5kKHRpbWVyTWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgbG9nOiAoLi4uZGF0YSkgPT4ge1xuICAgICAgICBsb2dMZXZlbDIudmFsdWUgPj0gREVCVUcudmFsdWUgJiYgY29uc29sZS50aW1lTG9nKHRpbWVyTWVzc2FnZSwgLi4uZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBlbWVyZ2VuY3k6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShFTUVSR0VOQ1ksIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgYWxlcnQ6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShBTEVSVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBjcml0aWNhbDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKENSSVRJQ0FMLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGVycm9yOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoRVJST1IsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgd2FybmluZzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKFdBUk5JTkcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgbm90aWNlOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoTk9USUNFLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGluZm86IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShJTkZPLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVCVUcsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgdHJhY2U6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShUUkFDRSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBkZWZhdWx0OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoREVGQVVMVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICB0aW1lOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHsgbWVzc2FnZSwgZGF0YSB9O1xuICAgICAgcmV0dXJuIHN0YXJ0VGltZUxvZ2dlcihsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpO1xuICAgIH0sXG4gICAgZ2V0OiAoLi4uYWRkaXRpb25hbENvbXBvbmVudHMpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IFsuLi5jb29yZGluYXRlcy5jb21wb25lbnRzLCAuLi5hZGRpdGlvbmFsQ29tcG9uZW50c11cbiAgICAgIH0sIGZsb29kQ29udHJvbENvbmZpZywgd3JpdGVyT3B0aW9ucyk7XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBpZiAoZmxvb2RDb250cm9sKSB7XG4gICAgICAgIGZsb29kQ29udHJvbC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2xvZ2dpbmcudHNcbnZhciBnZXRMb2dnZXIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBjb25maWd1cmVMb2dnaW5nKCk7XG4gIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUJhc2VMb2dnZXIobmFtZSwgY29uZmlnKTtcbiAgcmV0dXJuIGxvZ2dlcjtcbn07XG52YXIgY3JlYXRlQmFzZUxvZ2dlciA9IChuYW1lLCBjb25maWcpID0+IHtcbiAgbGV0IHsgbG9nTGV2ZWwgfSA9IGNvbmZpZztcbiAgY29uc3QgeyBsb2dGb3JtYXQsIGZsb29kQ29udHJvbCB9ID0gY29uZmlnO1xuICBjb25zdCBvdmVycmlkZXMgPSBjb25maWcub3ZlcnJpZGVzO1xuICBpZiAob3ZlcnJpZGVzICYmIG92ZXJyaWRlc1tuYW1lXSkge1xuICAgIGxvZ0xldmVsID0gb3ZlcnJpZGVzW25hbWVdLmxvZ0xldmVsO1xuICB9XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0geyBjYXRlZ29yeTogbmFtZSwgY29tcG9uZW50czogW10gfTtcbiAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihsb2dGb3JtYXQsIGxvZ0xldmVsLCBjb29yZGluYXRlcywgZmxvb2RDb250cm9sKTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSB7IGdldExvZ2dlciB9O1xuZXhwb3J0IHtcbiAgTG9nRm9ybWF0X2V4cG9ydHMgYXMgTG9nRm9ybWF0LFxuICBMb2dMZXZlbF9leHBvcnRzIGFzIExvZ0xldmVsLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGdldExvZ2dlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/@fjell/logging/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/deepmerge/dist/cjs.js":
/*!********************************************************!*\
  !*** ../fjell-core/node_modules/deepmerge/dist/cjs.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwgc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/deepmerge/dist/cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js":
/*!********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/datetime.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DateTime),\n/* harmony export */   friendlyDateTime: () => (/* binding */ friendlyDateTime)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/info.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_diff_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./impl/diff.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/diff.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./impl/tokenParser.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/tokenParser.js\");\n/* harmony import */ var _impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./impl/conversions.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/conversions.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/invalid.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid DateTime\";\nconst MAX_DATE = 8.64e15;\n\nfunction unsupportedZone(zone) {\n  return new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unsupported zone\", `the zone \"${zone.name}\" is not supported`);\n}\n\n// we cache week data on the DT object and this intermediates the cache\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedWeekData(dt) {\n  if (dt.weekData === null) {\n    dt.weekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(dt.c);\n  }\n  return dt.weekData;\n}\n\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedLocalWeekData(dt) {\n  if (dt.localWeekData === null) {\n    dt.localWeekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(\n      dt.c,\n      dt.loc.getMinDaysInFirstWeek(),\n      dt.loc.getStartOfWeek()\n    );\n  }\n  return dt.localWeekData;\n}\n\n// clone really means, \"make a new object with these modifications\". all \"setters\" really use this\n// to create a new object while only changing some of the properties\nfunction clone(inst, alts) {\n  const current = {\n    ts: inst.ts,\n    zone: inst.zone,\n    c: inst.c,\n    o: inst.o,\n    loc: inst.loc,\n    invalid: inst.invalid,\n  };\n  return new DateTime({ ...current, ...alts, old: current });\n}\n\n// find the right offset a given local time. The o input is our guess, which determines which\n// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)\nfunction fixOffset(localTS, o, tz) {\n  // Our UTC time is just a guess because our offset is just a guess\n  let utcGuess = localTS - o * 60 * 1000;\n\n  // Test whether the zone matches the offset for this ts\n  const o2 = tz.offset(utcGuess);\n\n  // If so, offset didn't change and we're done\n  if (o === o2) {\n    return [utcGuess, o];\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= (o2 - o) * 60 * 1000;\n\n  // If that gives us the local time we want, we're done\n  const o3 = tz.offset(utcGuess);\n  if (o2 === o3) {\n    return [utcGuess, o2];\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];\n}\n\n// convert an epoch timestamp into a calendar object with the given offset\nfunction tsToObj(ts, offset) {\n  ts += offset * 60 * 1000;\n\n  const d = new Date(ts);\n\n  return {\n    year: d.getUTCFullYear(),\n    month: d.getUTCMonth() + 1,\n    day: d.getUTCDate(),\n    hour: d.getUTCHours(),\n    minute: d.getUTCMinutes(),\n    second: d.getUTCSeconds(),\n    millisecond: d.getUTCMilliseconds(),\n  };\n}\n\n// convert a calendar object to a epoch timestamp\nfunction objToTS(obj, offset, zone) {\n  return fixOffset((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(obj), offset, zone);\n}\n\n// create a new DT instance by adding a duration, adjusting for DSTs\nfunction adjustTime(inst, dur) {\n  const oPre = inst.o,\n    year = inst.c.year + Math.trunc(dur.years),\n    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,\n    c = {\n      ...inst.c,\n      year,\n      month,\n      day:\n        Math.min(inst.c.day, (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(year, month)) +\n        Math.trunc(dur.days) +\n        Math.trunc(dur.weeks) * 7,\n    },\n    millisToAdd = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject({\n      years: dur.years - Math.trunc(dur.years),\n      quarters: dur.quarters - Math.trunc(dur.quarters),\n      months: dur.months - Math.trunc(dur.months),\n      weeks: dur.weeks - Math.trunc(dur.weeks),\n      days: dur.days - Math.trunc(dur.days),\n      hours: dur.hours,\n      minutes: dur.minutes,\n      seconds: dur.seconds,\n      milliseconds: dur.milliseconds,\n    }).as(\"milliseconds\"),\n    localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(c);\n\n  let [ts, o] = fixOffset(localTS, oPre, inst.zone);\n\n  if (millisToAdd !== 0) {\n    ts += millisToAdd;\n    // that could have changed the offset by going over a DST, but we want to keep the ts the same\n    o = inst.zone.offset(ts);\n  }\n\n  return { ts, o };\n}\n\n// helper useful in turning the results of parsing into real dates\n// by handling the zone options\nfunction parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {\n  const { setZone, zone } = opts;\n  if ((parsed && Object.keys(parsed).length !== 0) || parsedZone) {\n    const interpretationZone = parsedZone || zone,\n      inst = DateTime.fromObject(parsed, {\n        ...opts,\n        zone: interpretationZone,\n        specificOffset,\n      });\n    return setZone ? inst : inst.setZone(zone);\n  } else {\n    return DateTime.invalid(\n      new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unparsable\", `the input \"${text}\" can't be parsed as ${format}`)\n    );\n  }\n}\n\n// if you want to output a technical format (e.g. RFC 2822), this helper\n// helps handle the details\nfunction toTechFormat(dt, format, allowZ = true) {\n  return dt.isValid\n    ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(_impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create(\"en-US\"), {\n        allowZ,\n        forceSimple: true,\n      }).formatDateTimeFromString(dt, format)\n    : null;\n}\n\nfunction toISODate(o, extended, precision) {\n  const longFormat = o.c.year > 9999 || o.c.year < 0;\n  let c = \"\";\n  if (longFormat && o.c.year >= 0) c += \"+\";\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.year, longFormat ? 6 : 4);\n  if (precision === \"year\") return c;\n  if (extended) {\n    c += \"-\";\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n    c += \"-\";\n  } else {\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n  }\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.day);\n  return c;\n}\n\nfunction toISOTime(\n  o,\n  extended,\n  suppressSeconds,\n  suppressMilliseconds,\n  includeOffset,\n  extendedZone,\n  precision\n) {\n  let showSeconds = !suppressSeconds || o.c.millisecond !== 0 || o.c.second !== 0,\n    c = \"\";\n  switch (precision) {\n    case \"day\":\n    case \"month\":\n    case \"year\":\n      break;\n    default:\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.hour);\n      if (precision === \"hour\") break;\n      if (extended) {\n        c += \":\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += \":\";\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      } else {\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      }\n      if (precision === \"second\") break;\n      if (showSeconds && (!suppressMilliseconds || o.c.millisecond !== 0)) {\n        c += \".\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.millisecond, 3);\n      }\n  }\n\n  if (includeOffset) {\n    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {\n      c += \"Z\";\n    } else if (o.o < 0) {\n      c += \"-\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o % 60));\n    } else {\n      c += \"+\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o % 60));\n    }\n  }\n\n  if (extendedZone) {\n    c += \"[\" + o.zone.ianaName + \"]\";\n  }\n  return c;\n}\n\n// defaults for unspecified units in the supported calendars\nconst defaultUnitValues = {\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultWeekUnitValues = {\n    weekNumber: 1,\n    weekday: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultOrdinalUnitValues = {\n    ordinal: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  };\n\n// Units in the supported calendars, sorted by bigness\nconst orderedUnits = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"],\n  orderedWeekUnits = [\n    \"weekYear\",\n    \"weekNumber\",\n    \"weekday\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\",\n  ],\n  orderedOrdinalUnits = [\"year\", \"ordinal\", \"hour\", \"minute\", \"second\", \"millisecond\"];\n\n// standardize case and plurality in units\nfunction normalizeUnit(unit) {\n  const normalized = {\n    year: \"year\",\n    years: \"year\",\n    month: \"month\",\n    months: \"month\",\n    day: \"day\",\n    days: \"day\",\n    hour: \"hour\",\n    hours: \"hour\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    second: \"second\",\n    seconds: \"second\",\n    millisecond: \"millisecond\",\n    milliseconds: \"millisecond\",\n    weekday: \"weekday\",\n    weekdays: \"weekday\",\n    weeknumber: \"weekNumber\",\n    weeksnumber: \"weekNumber\",\n    weeknumbers: \"weekNumber\",\n    weekyear: \"weekYear\",\n    weekyears: \"weekYear\",\n    ordinal: \"ordinal\",\n  }[unit.toLowerCase()];\n\n  if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidUnitError(unit);\n\n  return normalized;\n}\n\nfunction normalizeUnitWithLocalWeeks(unit) {\n  switch (unit.toLowerCase()) {\n    case \"localweekday\":\n    case \"localweekdays\":\n      return \"localWeekday\";\n    case \"localweeknumber\":\n    case \"localweeknumbers\":\n      return \"localWeekNumber\";\n    case \"localweekyear\":\n    case \"localweekyears\":\n      return \"localWeekYear\";\n    default:\n      return normalizeUnit(unit);\n  }\n}\n\n// cache offsets for zones based on the current timestamp when this function is\n// first called. When we are handling a datetime from components like (year,\n// month, day, hour) in a time zone, we need a guess about what the timezone\n// offset is so that we can convert into a UTC timestamp. One way is to find the\n// offset of now in the zone. The actual date may have a different offset (for\n// example, if we handle a date in June while we're in December in a zone that\n// observes DST), but we can check and adjust that.\n//\n// When handling many dates, calculating the offset for now every time is\n// expensive. It's just a guess, so we can cache the offset to use even if we\n// are right on a time change boundary (we'll just correct in the other\n// direction). Using a timestamp from first read is a slight optimization for\n// handling dates close to the current date, since those dates will usually be\n// in the same offset (we could set the timestamp statically, instead). We use a\n// single timestamp for all zones to make things a bit more predictable.\n//\n// This is safe for quickDT (used by local() and utc()) because we don't fill in\n// higher-order units from tsNow (as we do in fromObject, this requires that\n// offset is calculated from tsNow).\n/**\n * @param {Zone} zone\n * @return {number}\n */\nfunction guessOffsetForZone(zone) {\n  if (zoneOffsetTs === undefined) {\n    zoneOffsetTs = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  // Do not cache anything but IANA zones, because it is not safe to do so.\n  // Guessing an offset which is not present in the zone can cause wrong results from fixOffset\n  if (zone.type !== \"iana\") {\n    return zone.offset(zoneOffsetTs);\n  }\n  const zoneName = zone.name;\n  let offsetGuess = zoneOffsetGuessCache.get(zoneName);\n  if (offsetGuess === undefined) {\n    offsetGuess = zone.offset(zoneOffsetTs);\n    zoneOffsetGuessCache.set(zoneName, offsetGuess);\n  }\n  return offsetGuess;\n}\n\n// this is a dumbed down version of fromObject() that runs about 60% faster\n// but doesn't do any validation, makes a bunch of assumptions about what units\n// are present, and so on.\nfunction quickDT(obj, opts) {\n  const zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  if (!zone.isValid) {\n    return DateTime.invalid(unsupportedZone(zone));\n  }\n\n  const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n\n  let ts, o;\n\n  // assume we have the higher-order units\n  if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj.year)) {\n    for (const u of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj[u])) {\n        obj[u] = defaultUnitValues[u];\n      }\n    }\n\n    const invalid = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(obj) || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(obj);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    const offsetProvis = guessOffsetForZone(zone);\n    [ts, o] = objToTS(obj, offsetProvis, zone);\n  } else {\n    ts = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  return new DateTime({ ts, zone, loc, o });\n}\n\nfunction diffRelative(start, end, opts) {\n  const round = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.round) ? true : opts.round,\n    rounding = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.rounding) ? \"trunc\" : opts.rounding,\n    format = (c, unit) => {\n      c = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.roundTo)(c, round || opts.calendary ? 0 : 2, opts.calendary ? \"round\" : rounding);\n      const formatter = end.loc.clone(opts).relFormatter(opts);\n      return formatter.format(c, unit);\n    },\n    differ = (unit) => {\n      if (opts.calendary) {\n        if (!end.hasSame(start, unit)) {\n          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);\n        } else return 0;\n      } else {\n        return end.diff(start, unit).get(unit);\n      }\n    };\n\n  if (opts.unit) {\n    return format(differ(opts.unit), opts.unit);\n  }\n\n  for (const unit of opts.units) {\n    const count = differ(unit);\n    if (Math.abs(count) >= 1) {\n      return format(count, unit);\n    }\n  }\n  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);\n}\n\nfunction lastOpts(argList) {\n  let opts = {},\n    args;\n  if (argList.length > 0 && typeof argList[argList.length - 1] === \"object\") {\n    opts = argList[argList.length - 1];\n    args = Array.from(argList).slice(0, argList.length - 1);\n  } else {\n    args = Array.from(argList);\n  }\n  return [opts, args];\n}\n\n/**\n * Timestamp to use for cached zone offset guesses (exposed for test)\n */\nlet zoneOffsetTs;\n/**\n * Cache for zone offset guesses (exposed for test).\n *\n * This optimizes quickDT via guessOffsetForZone to avoid repeated calls of\n * zone.offset().\n */\nconst zoneOffsetGuessCache = new Map();\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},\n * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.\n * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nclass DateTime {\n  /**\n   * @access private\n   */\n  constructor(config) {\n    const zone = config.zone || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone;\n\n    let invalid =\n      config.invalid ||\n      (Number.isNaN(config.ts) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null) ||\n      (!zone.isValid ? unsupportedZone(zone) : null);\n    /**\n     * @access private\n     */\n    this.ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(config.ts) ? _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now() : config.ts;\n\n    let c = null,\n      o = null;\n    if (!invalid) {\n      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);\n\n      if (unchanged) {\n        [c, o] = [config.old.c, config.old.o];\n      } else {\n        // If an offset has been passed and we have not been called from\n        // clone(), we can trust it and avoid the offset calculation.\n        const ot = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(config.o) && !config.old ? config.o : zone.offset(this.ts);\n        c = tsToObj(this.ts, ot);\n        invalid = Number.isNaN(c.year) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null;\n        c = invalid ? null : c;\n        o = invalid ? null : ot;\n      }\n    }\n\n    /**\n     * @access private\n     */\n    this._zone = zone;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.invalid = invalid;\n    /**\n     * @access private\n     */\n    this.weekData = null;\n    /**\n     * @access private\n     */\n    this.localWeekData = null;\n    /**\n     * @access private\n     */\n    this.c = c;\n    /**\n     * @access private\n     */\n    this.o = o;\n    /**\n     * @access private\n     */\n    this.isLuxonDateTime = true;\n  }\n\n  // CONSTRUCT\n\n  /**\n   * Create a DateTime for the current instant, in the system's time zone.\n   *\n   * Use Settings to override these default values if needed.\n   * @example DateTime.now().toISO() //~> now in the ISO format\n   * @return {DateTime}\n   */\n  static now() {\n    return new DateTime({});\n  }\n\n  /**\n   * Create a local DateTime\n   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month, 1-indexed\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @example DateTime.local()                                  //~> now\n   * @example DateTime.local({ zone: \"America/New_York\" })      //~> now, in US east coast time\n   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00\n   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00\n   * @example DateTime.local(2017, 3, 12, { locale: \"fr\" })     //~> 2017-03-12T00:00:00, with a French locale\n   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00\n   * @example DateTime.local(2017, 3, 12, 5, { zone: \"utc\" })   //~> 2017-03-12T05:00:00, in UTC\n   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765\n   * @return {DateTime}\n   */\n  static local() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime in UTC\n   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.utc()                                              //~> now\n   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z\n   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: \"fr\" })          //~> 2017-03-12T05:45:00Z with a French locale\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: \"fr\" }) //~> 2017-03-12T05:45:10.765Z with a French locale\n   * @return {DateTime}\n   */\n  static utc() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n\n    opts.zone = _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].utcInstance;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime from a JavaScript Date object. Uses the default zone.\n   * @param {Date} date - a JavaScript Date object\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @return {DateTime}\n   */\n  static fromJSDate(date, options = {}) {\n    const ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isDate)(date) ? date.valueOf() : NaN;\n    if (Number.isNaN(ts)) {\n      return DateTime.invalid(\"invalid input\");\n    }\n\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    return new DateTime({\n      ts: ts,\n      zone: zoneToUse,\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n    });\n  }\n\n  /**\n   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} milliseconds - a number of milliseconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromMillis(milliseconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(milliseconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`\n      );\n    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {\n      // this isn't perfect because we can still end up out of range because of additional shifting, but it's a start\n      return DateTime.invalid(\"Timestamp out of range\");\n    } else {\n      return new DateTime({\n        ts: milliseconds,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} seconds - a number of seconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromSeconds(seconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(seconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromSeconds requires a numerical input\");\n    } else {\n      return new DateTime({\n        ts: seconds * 1000,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.year - a year, such as 1987\n   * @param {number} obj.month - a month, 1-12\n   * @param {number} obj.day - a day of the month, 1-31, depending on the month\n   * @param {number} obj.ordinal - day of the year, 1-365 or 366\n   * @param {number} obj.weekYear - an ISO week year\n   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n   * @param {number} obj.localWeekYear - a week year, according to the locale\n   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale\n   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale\n   * @param {number} obj.hour - hour of the day, 0-23\n   * @param {number} obj.minute - minute of the hour, 0-59\n   * @param {number} obj.second - second of the minute, 0-59\n   * @param {number} obj.millisecond - millisecond of the second, 0-999\n   * @param {Object} opts - options for creating this DateTime\n   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()\n   * @param {string} [opts.locale='system\\'s locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })\n   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: \"en-US\" }).toISODate() //=> '2021-12-26'\n   * @return {DateTime}\n   */\n  static fromObject(obj, opts = {}) {\n    obj = obj || {};\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(obj, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, loc);\n\n    const tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now(),\n      offsetProvis = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.specificOffset)\n        ? opts.specificOffset\n        : zoneToUse.offset(tsNow),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    // cases:\n    // just a weekday -> this week's instance of that weekday, no worries\n    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error\n    // (gregorian month or day) + ordinal -> error\n    // otherwise just use weeks or ordinals or gregorian, depending on what's specified\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);\n\n    // configure ourselves to deal with gregorian dates or week stuff\n    let units,\n      defaultValues,\n      objNow = tsToObj(tsNow, offsetProvis);\n    if (useWeekData) {\n      units = orderedWeekUnits;\n      defaultValues = defaultWeekUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(objNow, minDaysInFirstWeek, startOfWeek);\n    } else if (containsOrdinal) {\n      units = orderedOrdinalUnits;\n      defaultValues = defaultOrdinalUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(objNow);\n    } else {\n      units = orderedUnits;\n      defaultValues = defaultUnitValues;\n    }\n\n    // set default values for missing stuff\n    let foundFirst = false;\n    for (const u of units) {\n      const v = normalized[u];\n      if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(v)) {\n        foundFirst = true;\n      } else if (foundFirst) {\n        normalized[u] = defaultValues[u];\n      } else {\n        normalized[u] = objNow[u];\n      }\n    }\n\n    // make sure the values we have are in range\n    const higherOrderInvalid = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidWeekData)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidOrdinalData)(normalized)\n        : (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(normalized),\n      invalid = higherOrderInvalid || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(normalized);\n\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    // compute the actual time\n    const gregorian = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)(normalized)\n        : normalized,\n      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),\n      inst = new DateTime({\n        ts: tsFinal,\n        zone: zoneToUse,\n        o: offsetFinal,\n        loc,\n      });\n\n    // gregorian data + weekday serves only to validate\n    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {\n      return DateTime.invalid(\n        \"mismatched weekday\",\n        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`\n      );\n    }\n\n    if (!inst.isValid) {\n      return DateTime.invalid(inst.invalid);\n    }\n\n    return inst;\n  }\n\n  /**\n   * Create a DateTime from an ISO 8601 string\n   * @param {string} text - the ISO string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n   * @example DateTime.fromISO('2016-W05-4')\n   * @return {DateTime}\n   */\n  static fromISO(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseISODate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"ISO 8601\", text);\n  }\n\n  /**\n   * Create a DateTime from an RFC 2822 string\n   * @param {string} text - the RFC 2822 string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n   * @return {DateTime}\n   */\n  static fromRFC2822(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseRFC2822Date)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"RFC 2822\", text);\n  }\n\n  /**\n   * Create a DateTime from an HTTP header date\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @param {string} text - the HTTP header date\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n   * @return {DateTime}\n   */\n  static fromHTTP(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseHTTPDate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"HTTP\", opts);\n  }\n\n  /**\n   * Create a DateTime from an input string and format string.\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromFormat(text, fmt, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(fmt)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromFormat requires an input string and a format\");\n    }\n\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      }),\n      [vals, parsedZone, specificOffset, invalid] = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.parseFromTokens)(localeToUse, text, fmt);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    } else {\n      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);\n    }\n  }\n\n  /**\n   * @deprecated use fromFormat instead\n   */\n  static fromString(text, fmt, opts = {}) {\n    return DateTime.fromFormat(text, fmt, opts);\n  }\n\n  /**\n   * Create a DateTime from a SQL date, time, or datetime\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale\n   * @param {string} text - the string to parse\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @example DateTime.fromSQL('2017-05-15')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n   * @example DateTime.fromSQL('09:12:34.342')\n   * @return {DateTime}\n   */\n  static fromSQL(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseSQL)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"SQL\", text);\n  }\n\n  /**\n   * Create an invalid DateTime.\n   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {DateTime}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"need to specify a reason the DateTime is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidDateTimeError(invalid);\n    } else {\n      return new DateTime({ invalid });\n    }\n  }\n\n  /**\n   * Check if an object is an instance of DateTime. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDateTime(o) {\n    return (o && o.isLuxonDateTime) || false;\n  }\n\n  /**\n   * Produce the format string for a set of options\n   * @param formatOpts\n   * @param localeOpts\n   * @returns {string}\n   */\n  static parseFormatForOpts(formatOpts, localeOpts = {}) {\n    const tokenList = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.formatOptsToTokens)(formatOpts, _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join(\"\");\n  }\n\n  /**\n   * Produce the the fully expanded format token for the locale\n   * Does NOT quote characters, so quoted tokens will not round trip correctly\n   * @param fmt\n   * @param localeOpts\n   * @returns {string}\n   */\n  static expandFormat(fmt, localeOpts = {}) {\n    const expanded = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.expandMacroTokens)(_impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseFormat(fmt), _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return expanded.map((t) => t.val).join(\"\");\n  }\n\n  static resetCache() {\n    zoneOffsetTs = undefined;\n    zoneOffsetGuessCache.clear();\n  }\n\n  // INFO\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7\n   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4\n   * @return {number}\n   */\n  get(unit) {\n    return this[unit];\n  }\n\n  /**\n   * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n   * * The DateTime was created by an operation on another invalid date\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get outputCalendar() {\n    return this.isValid ? this.loc.outputCalendar : null;\n  }\n\n  /**\n   * Get the time zone associated with this DateTime.\n   * @type {Zone}\n   */\n  get zone() {\n    return this._zone;\n  }\n\n  /**\n   * Get the name of the time zone.\n   * @type {string}\n   */\n  get zoneName() {\n    return this.isValid ? this.zone.name : null;\n  }\n\n  /**\n   * Get the year\n   * @example DateTime.local(2017, 5, 25).year //=> 2017\n   * @type {number}\n   */\n  get year() {\n    return this.isValid ? this.c.year : NaN;\n  }\n\n  /**\n   * Get the quarter\n   * @example DateTime.local(2017, 5, 25).quarter //=> 2\n   * @type {number}\n   */\n  get quarter() {\n    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\n  }\n\n  /**\n   * Get the month (1-12).\n   * @example DateTime.local(2017, 5, 25).month //=> 5\n   * @type {number}\n   */\n  get month() {\n    return this.isValid ? this.c.month : NaN;\n  }\n\n  /**\n   * Get the day of the month (1-30ish).\n   * @example DateTime.local(2017, 5, 25).day //=> 25\n   * @type {number}\n   */\n  get day() {\n    return this.isValid ? this.c.day : NaN;\n  }\n\n  /**\n   * Get the hour of the day (0-23).\n   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n   * @type {number}\n   */\n  get hour() {\n    return this.isValid ? this.c.hour : NaN;\n  }\n\n  /**\n   * Get the minute of the hour (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n   * @type {number}\n   */\n  get minute() {\n    return this.isValid ? this.c.minute : NaN;\n  }\n\n  /**\n   * Get the second of the minute (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n   * @type {number}\n   */\n  get second() {\n    return this.isValid ? this.c.second : NaN;\n  }\n\n  /**\n   * Get the millisecond of the second (0-999).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n   * @type {number}\n   */\n  get millisecond() {\n    return this.isValid ? this.c.millisecond : NaN;\n  }\n\n  /**\n   * Get the week year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015\n   * @type {number}\n   */\n  get weekYear() {\n    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the week number of the week year (1-52ish).\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21\n   * @type {number}\n   */\n  get weekNumber() {\n    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the day of the week.\n   * 1 is Monday and 7 is Sunday\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 11, 31).weekday //=> 4\n   * @type {number}\n   */\n  get weekday() {\n    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Returns true if this date is on a weekend according to the locale, false otherwise\n   * @returns {boolean}\n   */\n  get isWeekend() {\n    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);\n  }\n\n  /**\n   * Get the day of the week according to the locale.\n   * 1 is the first day of the week and 7 is the last day of the week.\n   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,\n   * @returns {number}\n   */\n  get localWeekday() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,\n   * because the week can start on different days of the week (see localWeekday) and because a different number of days\n   * is required for a week to count as the first week of a year.\n   * @returns {number}\n   */\n  get localWeekNumber() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)\n   * differently, see localWeekNumber.\n   * @returns {number}\n   */\n  get localWeekYear() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the ordinal (meaning the day of the year)\n   * @example DateTime.local(2017, 5, 25).ordinal //=> 145\n   * @type {number|DateTime}\n   */\n  get ordinal() {\n    return this.isValid ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c).ordinal : NaN;\n  }\n\n  /**\n   * Get the human readable short month name, such as 'Oct'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct\n   * @type {string}\n   */\n  get monthShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"short\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable long month name, such as 'October'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthLong //=> October\n   * @type {string}\n   */\n  get monthLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"long\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable short weekday, such as 'Mon'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n   * @type {string}\n   */\n  get weekdayShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"short\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the human readable long weekday, such as 'Monday'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n   * @type {string}\n   */\n  get weekdayLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"long\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the UTC offset of this DateTime in minutes\n   * @example DateTime.now().offset //=> -240\n   * @example DateTime.utc().offset //=> 0\n   * @type {number}\n   */\n  get offset() {\n    return this.isValid ? +this.o : NaN;\n  }\n\n  /**\n   * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameShort() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"short\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameLong() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"long\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get whether this zone's offset ever changes, as in a DST.\n   * @type {boolean}\n   */\n  get isOffsetFixed() {\n    return this.isValid ? this.zone.isUniversal : null;\n  }\n\n  /**\n   * Get whether the DateTime is in a DST.\n   * @type {boolean}\n   */\n  get isInDST() {\n    if (this.isOffsetFixed) {\n      return false;\n    } else {\n      return (\n        this.offset > this.set({ month: 1, day: 1 }).offset ||\n        this.offset > this.set({ month: 5 }).offset\n      );\n    }\n  }\n\n  /**\n   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC\n   * in this DateTime's zone. During DST changes local time can be ambiguous, for example\n   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.\n   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.\n   * @returns {DateTime[]}\n   */\n  getPossibleOffsets() {\n    if (!this.isValid || this.isOffsetFixed) {\n      return [this];\n    }\n    const dayMs = 86400000;\n    const minuteMs = 60000;\n    const localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(this.c);\n    const oEarlier = this.zone.offset(localTS - dayMs);\n    const oLater = this.zone.offset(localTS + dayMs);\n\n    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);\n    const o2 = this.zone.offset(localTS - oLater * minuteMs);\n    if (o1 === o2) {\n      return [this];\n    }\n    const ts1 = localTS - o1 * minuteMs;\n    const ts2 = localTS - o2 * minuteMs;\n    const c1 = tsToObj(ts1, o1);\n    const c2 = tsToObj(ts2, o2);\n    if (\n      c1.hour === c2.hour &&\n      c1.minute === c2.minute &&\n      c1.second === c2.second &&\n      c1.millisecond === c2.millisecond\n    ) {\n      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];\n    }\n    return [this];\n  }\n\n  /**\n   * Returns true if this DateTime is in a leap year, false otherwise\n   * @example DateTime.local(2016).isInLeapYear //=> true\n   * @example DateTime.local(2013).isInLeapYear //=> false\n   * @type {boolean}\n   */\n  get isInLeapYear() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isLeapYear)(this.year);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's month\n   * @example DateTime.local(2016, 2).daysInMonth //=> 29\n   * @example DateTime.local(2016, 3).daysInMonth //=> 31\n   * @type {number}\n   */\n  get daysInMonth() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(this.year, this.month);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's year\n   * @example DateTime.local(2016).daysInYear //=> 366\n   * @example DateTime.local(2013).daysInYear //=> 365\n   * @type {number}\n   */\n  get daysInYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInYear)(this.year) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2004).weeksInWeekYear //=> 53\n   * @example DateTime.local(2013).weeksInWeekYear //=> 52\n   * @type {number}\n   */\n  get weeksInWeekYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(this.weekYear) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's local week year\n   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52\n   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53\n   * @type {number}\n   */\n  get weeksInLocalWeekYear() {\n    return this.isValid\n      ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(\n          this.localWeekYear,\n          this.loc.getMinDaysInFirstWeek(),\n          this.loc.getStartOfWeek()\n        )\n      : NaN;\n  }\n\n  /**\n   * Returns the resolved Intl options for this DateTime.\n   * This is useful in understanding the behavior of formatting methods\n   * @param {Object} opts - the same options as toLocaleString\n   * @return {Object}\n   */\n  resolvedLocaleOptions(opts = {}) {\n    const { locale, numberingSystem, calendar } = _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(\n      this.loc.clone(opts),\n      opts\n    ).resolvedOptions(this);\n    return { locale, numberingSystem, outputCalendar: calendar };\n  }\n\n  // TRANSFORM\n\n  /**\n   * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to {@link DateTime#setZone}('utc')\n   * @param {number} [offset=0] - optionally, an offset from UTC in minutes\n   * @param {Object} [opts={}] - options to pass to `setZone()`\n   * @return {DateTime}\n   */\n  toUTC(offset = 0, opts = {}) {\n    return this.setZone(_zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance(offset), opts);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to `setZone('local')`\n   * @return {DateTime}\n   */\n  toLocal() {\n    return this.setZone(_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n   *\n   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.\n   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.\n   * @return {DateTime}\n   */\n  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {\n    zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (zone.equals(this.zone)) {\n      return this;\n    } else if (!zone.isValid) {\n      return DateTime.invalid(unsupportedZone(zone));\n    } else {\n      let newTS = this.ts;\n      if (keepLocalTime || keepCalendarTime) {\n        const offsetGuess = zone.offset(this.ts);\n        const asObj = this.toObject();\n        [newTS] = objToTS(asObj, offsetGuess, zone);\n      }\n      return clone(this, { ts: newTS, zone });\n    }\n  }\n\n  /**\n   * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\n   * @param {Object} properties - the properties to set\n   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\n   * @return {DateTime}\n   */\n  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });\n    return clone(this, { loc });\n  }\n\n  /**\n   * \"Set\" the locale. Returns a newly-constructed DateTime.\n   * Just a convenient alias for reconfigure({ locale })\n   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')\n   * @return {DateTime}\n   */\n  setLocale(locale) {\n    return this.reconfigure({ locale });\n  }\n\n  /**\n   * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n   * You can only set units with this method; for \"setting\" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.\n   *\n   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.\n   * They cannot be mixed with ISO-week units like `weekday`.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dt.set({ year: 2017 })\n   * @example dt.set({ hour: 8, minute: 30 })\n   * @example dt.set({ weekday: 5 })\n   * @example dt.set({ year: 2005, ordinal: 234 })\n   * @return {DateTime}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(values, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, this.loc);\n\n    const settingWeekStuff =\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekYear) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekNumber) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekday),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    let mixed;\n    if (settingWeekStuff) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(\n        { ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },\n        minDaysInFirstWeek,\n        startOfWeek\n      );\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal)) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)({ ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c), ...normalized });\n    } else {\n      mixed = { ...this.toObject(), ...normalized };\n\n      // if we didn't set the day but we ended up on an overflow date,\n      // use the last day of the right month\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day)) {\n        mixed.day = Math.min((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(mixed.year, mixed.month), mixed.day);\n      }\n    }\n\n    const [ts, o] = objToTS(mixed, this.o, this.zone);\n    return clone(this, { ts, o });\n  }\n\n  /**\n   * Add a period of time to this DateTime and return the resulting DateTime\n   *\n   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @example DateTime.now().plus(123) //~> in 123 milliseconds\n   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday\n   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n   * @return {DateTime}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration);\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * Subtract a period of time to this DateTime and return the resulting DateTime\n   * See {@link DateTime#plus}\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   @return {DateTime}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration).negate();\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * \"Set\" this DateTime to the beginning of a unit of time.\n   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n   * @return {DateTime}\n   */\n  startOf(unit, { useLocaleWeeks = false } = {}) {\n    if (!this.isValid) return this;\n\n    const o = {},\n      normalizedUnit = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit(unit);\n    switch (normalizedUnit) {\n      case \"years\":\n        o.month = 1;\n      // falls through\n      case \"quarters\":\n      case \"months\":\n        o.day = 1;\n      // falls through\n      case \"weeks\":\n      case \"days\":\n        o.hour = 0;\n      // falls through\n      case \"hours\":\n        o.minute = 0;\n      // falls through\n      case \"minutes\":\n        o.second = 0;\n      // falls through\n      case \"seconds\":\n        o.millisecond = 0;\n        break;\n      case \"milliseconds\":\n        break;\n      // no default, invalid units throw in normalizeUnit()\n    }\n\n    if (normalizedUnit === \"weeks\") {\n      if (useLocaleWeeks) {\n        const startOfWeek = this.loc.getStartOfWeek();\n        const { weekday } = this;\n        if (weekday < startOfWeek) {\n          o.weekNumber = this.weekNumber - 1;\n        }\n        o.weekday = startOfWeek;\n      } else {\n        o.weekday = 1;\n      }\n    }\n\n    if (normalizedUnit === \"quarters\") {\n      const q = Math.ceil(this.month / 3);\n      o.month = (q - 1) * 3 + 1;\n    }\n\n    return this.set(o);\n  }\n\n  /**\n   * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n   * @return {DateTime}\n   */\n  endOf(unit, opts) {\n    return this.isValid\n      ? this.plus({ [unit]: 1 })\n          .startOf(unit, opts)\n          .minus(1)\n      : this;\n  }\n\n  // OUTPUT\n\n  /**\n   * Returns a string representation of this DateTime formatted according to the specified format string.\n   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.\n   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation\n   * of the DateTime in the assigned locale.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toLocaleString(); //=> 4/20/2017\n   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'\n   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), formatOpts).formatDateTime(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an array of format \"parts\", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\n   * @example DateTime.now().toLocaleParts(); //=> [\n   *                                   //=>   { type: 'day', value: '25' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'month', value: '05' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'year', value: '1982' }\n   *                                   //=> ]\n   */\n  toLocaleParts(opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), opts).formatDateTimeParts(this)\n      : [];\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n   * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'\n   * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'\n   * @return {string|null}\n   */\n  toISO({\n    format = \"extended\",\n    suppressSeconds = false,\n    suppressMilliseconds = false,\n    includeOffset = true,\n    extendedZone = false,\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    const ext = format === \"extended\";\n\n    let c = toISODate(this, ext, precision);\n    if (orderedUnits.indexOf(precision) >= 3) c += \"T\";\n    c += toISOTime(\n      this,\n      ext,\n      suppressSeconds,\n      suppressMilliseconds,\n      includeOffset,\n      extendedZone,\n      precision\n    );\n    return c;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's date component\n   * @param {Object} opts - options\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.\n   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'\n   * @return {string|null}\n   */\n  toISODate({ format = \"extended\", precision = \"day\" } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, format === \"extended\", normalizeUnit(precision));\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's week date\n   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n   * @return {string}\n   */\n  toISOWeekDate() {\n    return toTechFormat(this, \"kkkk-'W'WW-c\");\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's time component\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'\n   * @return {string}\n   */\n  toISOTime({\n    suppressMilliseconds = false,\n    suppressSeconds = false,\n    includeOffset = true,\n    includePrefix = false,\n    extendedZone = false,\n    format = \"extended\",\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    let c = includePrefix && orderedUnits.indexOf(precision) >= 3 ? \"T\" : \"\";\n    return (\n      c +\n      toISOTime(\n        this,\n        format === \"extended\",\n        suppressSeconds,\n        suppressMilliseconds,\n        includeOffset,\n        extendedZone,\n        precision\n      )\n    );\n  }\n\n  /**\n   * Returns an RFC 2822-compatible string representation of this DateTime\n   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n   * @return {string}\n   */\n  toRFC2822() {\n    return toTechFormat(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\", false);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.\n   * Specifically, the string conforms to RFC 1123.\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n   * @return {string}\n   */\n  toHTTP() {\n    return toTechFormat(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\");\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Date\n   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n   * @return {string|null}\n   */\n  toSQLDate() {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Time\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc().toSQL() //=> '05:15:16.345'\n   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n   * @return {string}\n   */\n  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {\n    let fmt = \"HH:mm:ss.SSS\";\n\n    if (includeZone || includeOffset) {\n      if (includeOffsetSpace) {\n        fmt += \" \";\n      }\n      if (includeZone) {\n        fmt += \"z\";\n      } else if (includeOffset) {\n        fmt += \"ZZ\";\n      }\n    }\n\n    return toTechFormat(this, fmt, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n   * @return {string}\n   */\n  toSQL(opts = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for debugging\n   * @return {string}\n   */\n  toString() {\n    return this.isValid ? this.toISO() : INVALID;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;\n    } else {\n      return `DateTime { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime.\n   * @return {number}\n   */\n  toMillis() {\n    return this.isValid ? this.ts : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.\n   * @return {number}\n   */\n  toSeconds() {\n    return this.isValid ? this.ts / 1000 : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (as a whole number) of this DateTime.\n   * @return {number}\n   */\n  toUnixInteger() {\n    return this.isValid ? Math.floor(this.ts / 1000) : NaN;\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a BSON serializable equivalent to this DateTime.\n   * @return {Date}\n   */\n  toBSON() {\n    return this.toJSDate();\n  }\n\n  /**\n   * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n   * @param opts - options for generating the object\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\n   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n   * @return {Object}\n   */\n  toObject(opts = {}) {\n    if (!this.isValid) return {};\n\n    const base = { ...this.c };\n\n    if (opts.includeConfig) {\n      base.outputCalendar = this.outputCalendar;\n      base.numberingSystem = this.loc.numberingSystem;\n      base.locale = this.loc.locale;\n    }\n    return base;\n  }\n\n  /**\n   * Returns a JavaScript Date equivalent to this DateTime.\n   * @return {Date}\n   */\n  toJSDate() {\n    return new Date(this.isValid ? this.ts : NaN);\n  }\n\n  // COMPARE\n\n  /**\n   * Return the difference between two DateTimes as a Duration.\n   * @param {DateTime} otherDateTime - the DateTime to compare this one to\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example\n   * var i1 = DateTime.fromISO('1982-05-25T09:45'),\n   *     i2 = DateTime.fromISO('1983-10-14T10:30');\n   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n   * @return {Duration}\n   */\n  diff(otherDateTime, unit = \"milliseconds\", opts = {}) {\n    if (!this.isValid || !otherDateTime.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].invalid(\"created by diffing an invalid DateTime\");\n    }\n\n    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };\n\n    const units = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.maybeArray)(unit).map(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit),\n      otherIsLater = otherDateTime.valueOf() > this.valueOf(),\n      earlier = otherIsLater ? this : otherDateTime,\n      later = otherIsLater ? otherDateTime : this,\n      diffed = (0,_impl_diff_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(earlier, later, units, durOpts);\n\n    return otherIsLater ? diffed.negate() : diffed;\n  }\n\n  /**\n   * Return the difference between this DateTime and right now.\n   * See {@link DateTime#diff}\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  diffNow(unit = \"milliseconds\", opts = {}) {\n    return this.diff(DateTime.now(), unit, opts);\n  }\n\n  /**\n   * Return an Interval spanning between this DateTime and another DateTime\n   * @param {DateTime} otherDateTime - the other end point of the Interval\n   * @return {Interval|DateTime}\n   */\n  until(otherDateTime) {\n    return this.isValid ? _interval_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDateTimes(this, otherDateTime) : this;\n  }\n\n  /**\n   * Return whether this DateTime is in the same unit of time as another DateTime.\n   * Higher-order units must also be identical for this function to return `true`.\n   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.\n   * @param {DateTime} otherDateTime - the other DateTime\n   * @param {string} unit - the unit of time to check sameness on\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used\n   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n   * @return {boolean}\n   */\n  hasSame(otherDateTime, unit, opts) {\n    if (!this.isValid) return false;\n\n    const inputMs = otherDateTime.valueOf();\n    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });\n    return (\n      adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts)\n    );\n  }\n\n  /**\n   * Equality check\n   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.\n   * To compare just the millisecond values, use `+dt1 === +dt2`.\n   * @param {DateTime} other - the other DateTime\n   * @return {boolean}\n   */\n  equals(other) {\n    return (\n      this.isValid &&\n      other.isValid &&\n      this.valueOf() === other.valueOf() &&\n      this.zone.equals(other.zone) &&\n      this.loc.equals(other.loc)\n    );\n  }\n\n  /**\n   * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\n   * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} [options.style=\"long\"] - the style of units, must be \"long\", \"short\", or \"narrow\"\n   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of \"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", or \"seconds\"\n   * @param {boolean} [options.round=true] - whether to round the numbers in the output.\n   * @param {string} [options.rounding=\"trunc\"] - rounding method to use when rounding the numbers in the output. Can be \"trunc\" (toward zero), \"expand\" (away from zero), \"round\", \"floor\", or \"ceil\".\n   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n   * @example DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"\n   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n   */\n  toRelative(options = {}) {\n    if (!this.isValid) return null;\n    const base = options.base || DateTime.fromObject({}, { zone: this.zone }),\n      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;\n    let units = [\"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\"];\n    let unit = options.unit;\n    if (Array.isArray(options.unit)) {\n      units = options.unit;\n      unit = undefined;\n    }\n    return diffRelative(base, this.plus(padding), {\n      ...options,\n      numeric: \"always\",\n      units,\n      unit,\n    });\n  }\n\n  /**\n   * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"years\", \"quarters\", \"months\", \"weeks\", or \"days\"\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n   * @example DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"maana\"\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n   */\n  toRelativeCalendar(options = {}) {\n    if (!this.isValid) return null;\n\n    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {\n      ...options,\n      numeric: \"auto\",\n      units: [\"years\", \"months\", \"days\"],\n      calendary: true,\n    });\n  }\n\n  /**\n   * Return the min of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum\n   * @return {DateTime} the min DateTime, or undefined if called with no argument\n   */\n  static min(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"min requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.min);\n  }\n\n  /**\n   * Return the max of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum\n   * @return {DateTime} the max DateTime, or undefined if called with no argument\n   */\n  static max(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"max requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.max);\n  }\n\n  // MISC\n\n  /**\n   * Explain how a string would be parsed by fromFormat()\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see description)\n   * @param {Object} options - options taken by fromFormat()\n   * @return {Object}\n   */\n  static fromFormatExplain(text, fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.explainFromTokens)(localeToUse, text, fmt);\n  }\n\n  /**\n   * @deprecated use fromFormatExplain instead\n   */\n  static fromStringExplain(text, fmt, options = {}) {\n    return DateTime.fromFormatExplain(text, fmt, options);\n  }\n\n  /**\n   * Build a parser for `fmt` using the given locale. This parser can be passed\n   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This\n   * can be used to optimize cases where many dates need to be parsed in a\n   * specific format.\n   *\n   * @param {String} fmt - the format the string is expected to be in (see\n   * description)\n   * @param {Object} options - options used to set locale and numberingSystem\n   * for parser\n   * @returns {TokenParser} - opaque object to be used\n   */\n  static buildFormatParser(fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return new _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.TokenParser(localeToUse, fmt);\n  }\n\n  /**\n   * Create a DateTime from an input string and format parser.\n   *\n   * The format parser must have been created with the same locale as this call.\n   *\n   * @param {String} text - the string to parse\n   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}\n   * @param {Object} opts - options taken by fromFormat()\n   * @returns {DateTime}\n   */\n  static fromFormatParser(text, formatParser, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(formatParser)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        \"fromFormatParser requires an input string and a format parser\"\n      );\n    }\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n\n    if (!localeToUse.equals(formatParser.locale)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromFormatParser called with a locale of ${localeToUse}, ` +\n          `but the format parser was created for ${formatParser.locale}`\n      );\n    }\n\n    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);\n\n    if (invalidReason) {\n      return DateTime.invalid(invalidReason);\n    } else {\n      return parseDataToDateTime(\n        result,\n        zone,\n        opts,\n        `format ${formatParser.format}`,\n        text,\n        specificOffset\n      );\n    }\n  }\n\n  // FORMAT PRESETS\n\n  /**\n   * {@link DateTime#toLocaleString} format like 10/14/1983\n   * @type {Object}\n   */\n  static get DATE_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE_WITH_SECONDS;\n  }\n}\n\n/**\n * @private\n */\nfunction friendlyDateTime(dateTimeish) {\n  if (DateTime.isDateTime(dateTimeish)) {\n    return dateTimeish;\n  } else if (dateTimeish && dateTimeish.valueOf && (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(dateTimeish.valueOf())) {\n    return DateTime.fromJSDate(dateTimeish);\n  } else if (dateTimeish && typeof dateTimeish === \"object\") {\n    return DateTime.fromObject(dateTimeish);\n  } else {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`\n    );\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0E7QUFDQTtBQUNSO0FBQ2U7QUFDYTtBQUNuQjtBQWVkO0FBQzJCO0FBQ2pCO0FBQzhEO0FBT2pFO0FBWUE7QUFDYztBQU14QjtBQUNtQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBLGFBQWEseURBQU8sa0NBQWtDLFVBQVU7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0VBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzRUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwyREFBWTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwREFBVztBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixvREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0ws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LFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSwrQ0FBK0MsdURBQVE7QUFDM0Q7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osY0FBYyw2REFBb0I7QUFDbEMsb0NBQW9DLFlBQVksWUFBWSxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kYXRldGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNVbmRlZmluZWQsXG4gIG1heWJlQXJyYXksXG4gIGlzRGF0ZSxcbiAgaXNOdW1iZXIsXG4gIGJlc3RCeSxcbiAgZGF5c0luTW9udGgsXG4gIGRheXNJblllYXIsXG4gIGlzTGVhcFllYXIsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxuICBvYmpUb0xvY2FsVFMsXG4gIHBhZFN0YXJ0LFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgZGlmZiBmcm9tIFwiLi9pbXBsL2RpZmYuanNcIjtcbmltcG9ydCB7IHBhcnNlUkZDMjgyMkRhdGUsIHBhcnNlSVNPRGF0ZSwgcGFyc2VIVFRQRGF0ZSwgcGFyc2VTUUwgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBwYXJzZUZyb21Ub2tlbnMsXG4gIGV4cGxhaW5Gcm9tVG9rZW5zLFxuICBmb3JtYXRPcHRzVG9Ub2tlbnMsXG4gIGV4cGFuZE1hY3JvVG9rZW5zLFxuICBUb2tlblBhcnNlcixcbn0gZnJvbSBcIi4vaW1wbC90b2tlblBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgZ3JlZ29yaWFuVG9XZWVrLFxuICB3ZWVrVG9HcmVnb3JpYW4sXG4gIGdyZWdvcmlhblRvT3JkaW5hbCxcbiAgb3JkaW5hbFRvR3JlZ29yaWFuLFxuICBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YSxcbiAgaGFzSW52YWxpZFdlZWtEYXRhLFxuICBoYXNJbnZhbGlkT3JkaW5hbERhdGEsXG4gIGhhc0ludmFsaWRUaW1lRGF0YSxcbiAgdXNlc0xvY2FsV2Vla1ZhbHVlcyxcbiAgaXNvV2Vla2RheVRvTG9jYWwsXG59IGZyb20gXCIuL2ltcGwvY29udmVyc2lvbnMuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5pbXBvcnQge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IsXG4gIEludmFsaWRVbml0RXJyb3IsXG4gIEludmFsaWREYXRlVGltZUVycm9yLFxufSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIERhdGVUaW1lXCI7XG5jb25zdCBNQVhfREFURSA9IDguNjRlMTU7XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkWm9uZSh6b25lKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcInVuc3VwcG9ydGVkIHpvbmVcIiwgYHRoZSB6b25lIFwiJHt6b25lLm5hbWV9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xufVxuXG4vLyB3ZSBjYWNoZSB3ZWVrIGRhdGEgb24gdGhlIERUIG9iamVjdCBhbmQgdGhpcyBpbnRlcm1lZGlhdGVzIHRoZSBjYWNoZVxuLyoqXG4gKiBAcGFyYW0ge0RhdGVUaW1lfSBkdFxuICovXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG4gIHJldHVybiBkdC53ZWVrRGF0YTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RhdGVUaW1lfSBkdFxuICovXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEoZHQpIHtcbiAgaWYgKGR0LmxvY2FsV2Vla0RhdGEgPT09IG51bGwpIHtcbiAgICBkdC5sb2NhbFdlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKFxuICAgICAgZHQuYyxcbiAgICAgIGR0LmxvYy5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSxcbiAgICAgIGR0LmxvYy5nZXRTdGFydE9mV2VlaygpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZHQubG9jYWxXZWVrRGF0YTtcbn1cblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zLCBcIm1ha2UgYSBuZXcgb2JqZWN0IHdpdGggdGhlc2UgbW9kaWZpY2F0aW9uc1wiLiBhbGwgXCJzZXR0ZXJzXCIgcmVhbGx5IHVzZSB0aGlzXG4vLyB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHdoaWxlIG9ubHkgY2hhbmdpbmcgc29tZSBvZiB0aGUgcHJvcGVydGllc1xuZnVuY3Rpb24gY2xvbmUoaW5zdCwgYWx0cykge1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkLFxuICB9O1xuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgLi4uY3VycmVudCwgLi4uYWx0cywgb2xkOiBjdXJyZW50IH0pO1xufVxuXG4vLyBmaW5kIHRoZSByaWdodCBvZmZzZXQgYSBnaXZlbiBsb2NhbCB0aW1lLiBUaGUgbyBpbnB1dCBpcyBvdXIgZ3Vlc3MsIHdoaWNoIGRldGVybWluZXMgd2hpY2hcbi8vIG9mZnNldCB3ZSdsbCBwaWNrIGluIGFtYmlndW91cyBjYXNlcyAoZS5nLiB0aGVyZSBhcmUgdHdvIDMgQU1zIGIvYyBGYWxsYmFjayBEU1QpXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIGxldCB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwO1xuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGUgem9uZSBtYXRjaGVzIHRoZSBvZmZzZXQgZm9yIHRoaXMgdHNcbiAgY29uc3QgbzIgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIC8vIElmIHNvLCBvZmZzZXQgZGlkbid0IGNoYW5nZSBhbmQgd2UncmUgZG9uZVxuICBpZiAobyA9PT0gbzIpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvXTtcbiAgfVxuXG4gIC8vIElmIG5vdCwgY2hhbmdlIHRoZSB0cyBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgb2Zmc2V0XG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwO1xuXG4gIC8vIElmIHRoYXQgZ2l2ZXMgdXMgdGhlIGxvY2FsIHRpbWUgd2Ugd2FudCwgd2UncmUgZG9uZVxuICBjb25zdCBvMyA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH1cblxuICAvLyBJZiBpdCdzIGRpZmZlcmVudCwgd2UncmUgaW4gYSBob2xlIHRpbWUuIFRoZSBvZmZzZXQgaGFzIGNoYW5nZWQsIGJ1dCB0aGUgd2UgZG9uJ3QgYWRqdXN0IHRoZSB0aW1lXG4gIHJldHVybiBbbG9jYWxUUyAtIE1hdGgubWluKG8yLCBvMykgKiA2MCAqIDEwMDAsIE1hdGgubWF4KG8yLCBvMyldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGVwb2NoIHRpbWVzdGFtcCBpbnRvIGEgY2FsZW5kYXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG9mZnNldFxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcblxuICBjb25zdCBkID0gbmV3IERhdGUodHMpO1xuXG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgfTtcbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGVwb2NoIHRpbWVzdGFtcFxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuZnVuY3Rpb24gYWRqdXN0VGltZShpbnN0LCBkdXIpIHtcbiAgY29uc3Qgb1ByZSA9IGluc3QubyxcbiAgICB5ZWFyID0gaW5zdC5jLnllYXIgKyBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICBjID0ge1xuICAgICAgLi4uaW5zdC5jLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5OlxuICAgICAgICBNYXRoLm1pbihpbnN0LmMuZGF5LCBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIuZGF5cykgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci53ZWVrcykgKiA3LFxuICAgIH0sXG4gICAgbWlsbGlzVG9BZGQgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtcbiAgICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgICBxdWFydGVyczogZHVyLnF1YXJ0ZXJzIC0gTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpLFxuICAgICAgbW9udGhzOiBkdXIubW9udGhzIC0gTWF0aC50cnVuYyhkdXIubW9udGhzKSxcbiAgICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgICBkYXlzOiBkdXIuZGF5cyAtIE1hdGgudHJ1bmMoZHVyLmRheXMpLFxuICAgICAgaG91cnM6IGR1ci5ob3VycyxcbiAgICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgICAgc2Vjb25kczogZHVyLnNlY29uZHMsXG4gICAgICBtaWxsaXNlY29uZHM6IGR1ci5taWxsaXNlY29uZHMsXG4gICAgfSkuYXMoXCJtaWxsaXNlY29uZHNcIiksXG4gICAgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyhjKTtcblxuICBsZXQgW3RzLCBvXSA9IGZpeE9mZnNldChsb2NhbFRTLCBvUHJlLCBpbnN0LnpvbmUpO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkO1xuICAgIC8vIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBvZmZzZXQgYnkgZ29pbmcgb3ZlciBhIERTVCwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgdHMgdGhlIHNhbWVcbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4geyB0cywgbyB9O1xufVxuXG4vLyBoZWxwZXIgdXNlZnVsIGluIHR1cm5pbmcgdGhlIHJlc3VsdHMgb2YgcGFyc2luZyBpbnRvIHJlYWwgZGF0ZXNcbi8vIGJ5IGhhbmRsaW5nIHRoZSB6b25lIG9wdGlvbnNcbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQsIHNwZWNpZmljT2Zmc2V0KSB7XG4gIGNvbnN0IHsgc2V0Wm9uZSwgem9uZSB9ID0gb3B0cztcbiAgaWYgKChwYXJzZWQgJiYgT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggIT09IDApIHx8IHBhcnNlZFpvbmUpIHtcbiAgICBjb25zdCBpbnRlcnByZXRhdGlvblpvbmUgPSBwYXJzZWRab25lIHx8IHpvbmUsXG4gICAgICBpbnN0ID0gRGF0ZVRpbWUuZnJvbU9iamVjdChwYXJzZWQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgICBzcGVjaWZpY09mZnNldCxcbiAgICAgIH0pO1xuICAgIHJldHVybiBzZXRab25lID8gaW5zdCA6IGluc3Quc2V0Wm9uZSh6b25lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgIG5ldyBJbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyAke2Zvcm1hdH1gKVxuICAgICk7XG4gIH1cbn1cblxuLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcbmZ1bmN0aW9uIHRvVGVjaEZvcm1hdChkdCwgZm9ybWF0LCBhbGxvd1ogPSB0cnVlKSB7XG4gIHJldHVybiBkdC5pc1ZhbGlkXG4gICAgPyBGb3JtYXR0ZXIuY3JlYXRlKExvY2FsZS5jcmVhdGUoXCJlbi1VU1wiKSwge1xuICAgICAgICBhbGxvd1osXG4gICAgICAgIGZvcmNlU2ltcGxlOiB0cnVlLFxuICAgICAgfSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmb3JtYXQpXG4gICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0lTT0RhdGUobywgZXh0ZW5kZWQsIHByZWNpc2lvbikge1xuICBjb25zdCBsb25nRm9ybWF0ID0gby5jLnllYXIgPiA5OTk5IHx8IG8uYy55ZWFyIDwgMDtcbiAgbGV0IGMgPSBcIlwiO1xuICBpZiAobG9uZ0Zvcm1hdCAmJiBvLmMueWVhciA+PSAwKSBjICs9IFwiK1wiO1xuICBjICs9IHBhZFN0YXJ0KG8uYy55ZWFyLCBsb25nRm9ybWF0ID8gNiA6IDQpO1xuICBpZiAocHJlY2lzaW9uID09PSBcInllYXJcIikgcmV0dXJuIGM7XG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGlmIChwcmVjaXNpb24gPT09IFwibW9udGhcIikgcmV0dXJuIGM7XG4gICAgYyArPSBcIi1cIjtcbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgaWYgKHByZWNpc2lvbiA9PT0gXCJtb250aFwiKSByZXR1cm4gYztcbiAgfVxuICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gdG9JU09UaW1lKFxuICBvLFxuICBleHRlbmRlZCxcbiAgc3VwcHJlc3NTZWNvbmRzLFxuICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgaW5jbHVkZU9mZnNldCxcbiAgZXh0ZW5kZWRab25lLFxuICBwcmVjaXNpb25cbikge1xuICBsZXQgc2hvd1NlY29uZHMgPSAhc3VwcHJlc3NTZWNvbmRzIHx8IG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCBvLmMuc2Vjb25kICE9PSAwLFxuICAgIGMgPSBcIlwiO1xuICBzd2l0Y2ggKHByZWNpc2lvbikge1xuICAgIGNhc2UgXCJkYXlcIjpcbiAgICBjYXNlIFwibW9udGhcIjpcbiAgICBjYXNlIFwieWVhclwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGMgKz0gcGFkU3RhcnQoby5jLmhvdXIpO1xuICAgICAgaWYgKHByZWNpc2lvbiA9PT0gXCJob3VyXCIpIGJyZWFrO1xuICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgIGMgKz0gXCI6XCI7XG4gICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IFwibWludXRlXCIpIGJyZWFrO1xuICAgICAgICBpZiAoc2hvd1NlY29uZHMpIHtcbiAgICAgICAgICBjICs9IFwiOlwiO1xuICAgICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLnNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IFwibWludXRlXCIpIGJyZWFrO1xuICAgICAgICBpZiAoc2hvd1NlY29uZHMpIHtcbiAgICAgICAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJlY2lzaW9uID09PSBcInNlY29uZFwiKSBicmVhaztcbiAgICAgIGlmIChzaG93U2Vjb25kcyAmJiAoIXN1cHByZXNzTWlsbGlzZWNvbmRzIHx8IG8uYy5taWxsaXNlY29uZCAhPT0gMCkpIHtcbiAgICAgICAgYyArPSBcIi5cIjtcbiAgICAgICAgYyArPSBwYWRTdGFydChvLmMubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwICYmICFleHRlbmRlZFpvbmUpIHtcbiAgICAgIGMgKz0gXCJaXCI7XG4gICAgfSBlbHNlIGlmIChvLm8gPCAwKSB7XG4gICAgICBjICs9IFwiLVwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vICUgNjApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyArPSBcIitcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gJSA2MCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHRlbmRlZFpvbmUpIHtcbiAgICBjICs9IFwiW1wiICsgby56b25lLmlhbmFOYW1lICsgXCJdXCI7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRXaXRoTG9jYWxXZWVrcyh1bml0KSB7XG4gIHN3aXRjaCAodW5pdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImxvY2Fsd2Vla2RheVwiOlxuICAgIGNhc2UgXCJsb2NhbHdlZWtkYXlzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtkYXlcIjtcbiAgICBjYXNlIFwibG9jYWx3ZWVrbnVtYmVyXCI6XG4gICAgY2FzZSBcImxvY2Fsd2Vla251bWJlcnNcIjpcbiAgICAgIHJldHVybiBcImxvY2FsV2Vla051bWJlclwiO1xuICAgIGNhc2UgXCJsb2NhbHdlZWt5ZWFyXCI6XG4gICAgY2FzZSBcImxvY2Fsd2Vla3llYXJzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtZZWFyXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub3JtYWxpemVVbml0KHVuaXQpO1xuICB9XG59XG5cbi8vIGNhY2hlIG9mZnNldHMgZm9yIHpvbmVzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRpbWVzdGFtcCB3aGVuIHRoaXMgZnVuY3Rpb24gaXNcbi8vIGZpcnN0IGNhbGxlZC4gV2hlbiB3ZSBhcmUgaGFuZGxpbmcgYSBkYXRldGltZSBmcm9tIGNvbXBvbmVudHMgbGlrZSAoeWVhcixcbi8vIG1vbnRoLCBkYXksIGhvdXIpIGluIGEgdGltZSB6b25lLCB3ZSBuZWVkIGEgZ3Vlc3MgYWJvdXQgd2hhdCB0aGUgdGltZXpvbmVcbi8vIG9mZnNldCBpcyBzbyB0aGF0IHdlIGNhbiBjb252ZXJ0IGludG8gYSBVVEMgdGltZXN0YW1wLiBPbmUgd2F5IGlzIHRvIGZpbmQgdGhlXG4vLyBvZmZzZXQgb2Ygbm93IGluIHRoZSB6b25lLiBUaGUgYWN0dWFsIGRhdGUgbWF5IGhhdmUgYSBkaWZmZXJlbnQgb2Zmc2V0IChmb3Jcbi8vIGV4YW1wbGUsIGlmIHdlIGhhbmRsZSBhIGRhdGUgaW4gSnVuZSB3aGlsZSB3ZSdyZSBpbiBEZWNlbWJlciBpbiBhIHpvbmUgdGhhdFxuLy8gb2JzZXJ2ZXMgRFNUKSwgYnV0IHdlIGNhbiBjaGVjayBhbmQgYWRqdXN0IHRoYXQuXG4vL1xuLy8gV2hlbiBoYW5kbGluZyBtYW55IGRhdGVzLCBjYWxjdWxhdGluZyB0aGUgb2Zmc2V0IGZvciBub3cgZXZlcnkgdGltZSBpc1xuLy8gZXhwZW5zaXZlLiBJdCdzIGp1c3QgYSBndWVzcywgc28gd2UgY2FuIGNhY2hlIHRoZSBvZmZzZXQgdG8gdXNlIGV2ZW4gaWYgd2Vcbi8vIGFyZSByaWdodCBvbiBhIHRpbWUgY2hhbmdlIGJvdW5kYXJ5ICh3ZSdsbCBqdXN0IGNvcnJlY3QgaW4gdGhlIG90aGVyXG4vLyBkaXJlY3Rpb24pLiBVc2luZyBhIHRpbWVzdGFtcCBmcm9tIGZpcnN0IHJlYWQgaXMgYSBzbGlnaHQgb3B0aW1pemF0aW9uIGZvclxuLy8gaGFuZGxpbmcgZGF0ZXMgY2xvc2UgdG8gdGhlIGN1cnJlbnQgZGF0ZSwgc2luY2UgdGhvc2UgZGF0ZXMgd2lsbCB1c3VhbGx5IGJlXG4vLyBpbiB0aGUgc2FtZSBvZmZzZXQgKHdlIGNvdWxkIHNldCB0aGUgdGltZXN0YW1wIHN0YXRpY2FsbHksIGluc3RlYWQpLiBXZSB1c2UgYVxuLy8gc2luZ2xlIHRpbWVzdGFtcCBmb3IgYWxsIHpvbmVzIHRvIG1ha2UgdGhpbmdzIGEgYml0IG1vcmUgcHJlZGljdGFibGUuXG4vL1xuLy8gVGhpcyBpcyBzYWZlIGZvciBxdWlja0RUICh1c2VkIGJ5IGxvY2FsKCkgYW5kIHV0YygpKSBiZWNhdXNlIHdlIGRvbid0IGZpbGwgaW5cbi8vIGhpZ2hlci1vcmRlciB1bml0cyBmcm9tIHRzTm93IChhcyB3ZSBkbyBpbiBmcm9tT2JqZWN0LCB0aGlzIHJlcXVpcmVzIHRoYXRcbi8vIG9mZnNldCBpcyBjYWxjdWxhdGVkIGZyb20gdHNOb3cpLlxuLyoqXG4gKiBAcGFyYW0ge1pvbmV9IHpvbmVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ3Vlc3NPZmZzZXRGb3Jab25lKHpvbmUpIHtcbiAgaWYgKHpvbmVPZmZzZXRUcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgem9uZU9mZnNldFRzID0gU2V0dGluZ3Mubm93KCk7XG4gIH1cblxuICAvLyBEbyBub3QgY2FjaGUgYW55dGhpbmcgYnV0IElBTkEgem9uZXMsIGJlY2F1c2UgaXQgaXMgbm90IHNhZmUgdG8gZG8gc28uXG4gIC8vIEd1ZXNzaW5nIGFuIG9mZnNldCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiB0aGUgem9uZSBjYW4gY2F1c2Ugd3JvbmcgcmVzdWx0cyBmcm9tIGZpeE9mZnNldFxuICBpZiAoem9uZS50eXBlICE9PSBcImlhbmFcIikge1xuICAgIHJldHVybiB6b25lLm9mZnNldCh6b25lT2Zmc2V0VHMpO1xuICB9XG4gIGNvbnN0IHpvbmVOYW1lID0gem9uZS5uYW1lO1xuICBsZXQgb2Zmc2V0R3Vlc3MgPSB6b25lT2Zmc2V0R3Vlc3NDYWNoZS5nZXQoem9uZU5hbWUpO1xuICBpZiAob2Zmc2V0R3Vlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQoem9uZU9mZnNldFRzKTtcbiAgICB6b25lT2Zmc2V0R3Vlc3NDYWNoZS5zZXQoem9uZU5hbWUsIG9mZnNldEd1ZXNzKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0R3Vlc3M7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCBvcHRzKSB7XG4gIGNvbnN0IHpvbmUgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICBpZiAoIXpvbmUuaXNWYWxpZCkge1xuICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gIH1cblxuICBjb25zdCBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKTtcblxuICBsZXQgdHMsIG87XG5cbiAgLy8gYXNzdW1lIHdlIGhhdmUgdGhlIGhpZ2hlci1vcmRlciB1bml0c1xuICBpZiAoIWlzVW5kZWZpbmVkKG9iai55ZWFyKSkge1xuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICAgIG9ialt1XSA9IGRlZmF1bHRVbml0VmFsdWVzW3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHx8IGhhc0ludmFsaWRUaW1lRGF0YShvYmopO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXRQcm92aXMgPSBndWVzc09mZnNldEZvclpvbmUoem9uZSk7XG4gICAgW3RzLCBvXSA9IG9ialRvVFMob2JqLCBvZmZzZXRQcm92aXMsIHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRzID0gU2V0dGluZ3Mubm93KCk7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgdHMsIHpvbmUsIGxvYywgbyB9KTtcbn1cblxuZnVuY3Rpb24gZGlmZlJlbGF0aXZlKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgY29uc3Qgcm91bmQgPSBpc1VuZGVmaW5lZChvcHRzLnJvdW5kKSA/IHRydWUgOiBvcHRzLnJvdW5kLFxuICAgIHJvdW5kaW5nID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZGluZykgPyBcInRydW5jXCIgOiBvcHRzLnJvdW5kaW5nLFxuICAgIGZvcm1hdCA9IChjLCB1bml0KSA9PiB7XG4gICAgICBjID0gcm91bmRUbyhjLCByb3VuZCB8fCBvcHRzLmNhbGVuZGFyeSA/IDAgOiAyLCBvcHRzLmNhbGVuZGFyeSA/IFwicm91bmRcIiA6IHJvdW5kaW5nKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGVuZC5sb2MuY2xvbmUob3B0cykucmVsRm9ybWF0dGVyKG9wdHMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoYywgdW5pdCk7XG4gICAgfSxcbiAgICBkaWZmZXIgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKG9wdHMuY2FsZW5kYXJ5KSB7XG4gICAgICAgIGlmICghZW5kLmhhc1NhbWUoc3RhcnQsIHVuaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZC5zdGFydE9mKHVuaXQpLmRpZmYoc3RhcnQuc3RhcnRPZih1bml0KSwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGlmIChvcHRzLnVuaXQpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRpZmZlcihvcHRzLnVuaXQpLCBvcHRzLnVuaXQpO1xuICB9XG5cbiAgZm9yIChjb25zdCB1bml0IG9mIG9wdHMudW5pdHMpIHtcbiAgICBjb25zdCBjb3VudCA9IGRpZmZlcih1bml0KTtcbiAgICBpZiAoTWF0aC5hYnMoY291bnQpID49IDEpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHN0YXJ0ID4gZW5kID8gLTAgOiAwLCBvcHRzLnVuaXRzW29wdHMudW5pdHMubGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBsYXN0T3B0cyhhcmdMaXN0KSB7XG4gIGxldCBvcHRzID0ge30sXG4gICAgYXJncztcbiAgaWYgKGFyZ0xpc3QubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0cyA9IGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXTtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KS5zbGljZSgwLCBhcmdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpO1xuICB9XG4gIHJldHVybiBbb3B0cywgYXJnc107XG59XG5cbi8qKlxuICogVGltZXN0YW1wIHRvIHVzZSBmb3IgY2FjaGVkIHpvbmUgb2Zmc2V0IGd1ZXNzZXMgKGV4cG9zZWQgZm9yIHRlc3QpXG4gKi9cbmxldCB6b25lT2Zmc2V0VHM7XG4vKipcbiAqIENhY2hlIGZvciB6b25lIG9mZnNldCBndWVzc2VzIChleHBvc2VkIGZvciB0ZXN0KS5cbiAqXG4gKiBUaGlzIG9wdGltaXplcyBxdWlja0RUIHZpYSBndWVzc09mZnNldEZvclpvbmUgdG8gYXZvaWQgcmVwZWF0ZWQgY2FsbHMgb2ZcbiAqIHpvbmUub2Zmc2V0KCkuXG4gKi9cbmNvbnN0IHpvbmVPZmZzZXRHdWVzc0NhY2hlID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEEgRGF0ZVRpbWUgaXMgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGRhdGUgYW5kIHRpbWUgYW5kIGFjY29tcGFueWluZyBtZXRob2RzLiBJdCBjb250YWlucyBjbGFzcyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBBIERhdGVUaW1lIGNvbXByaXNlcyBvZjpcbiAqICogQSB0aW1lc3RhbXAuIEVhY2ggRGF0ZVRpbWUgaW5zdGFuY2UgcmVmZXJzIHRvIGEgc3BlY2lmaWMgbWlsbGlzZWNvbmQgb2YgdGhlIFVuaXggZXBvY2guXG4gKiAqIEEgdGltZSB6b25lLiBFYWNoIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpYyB6b25lIChieSBkZWZhdWx0IHRoZSBsb2NhbCBzeXN0ZW0ncyB6b25lKS5cbiAqICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgZWZmZWN0IGhvdyBvdXRwdXQgc3RyaW5ncyBhcmUgZm9ybWF0dGVkLCBzdWNoIGFzIGBsb2NhbGVgLCBgbnVtYmVyaW5nU3lzdGVtYCwgYW5kIGBvdXRwdXRDYWxlbmRhcmAuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgZnVuY3Rpb25hbGl0eSBpdCBwcm92aWRlczpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKjogVG8gY3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBpdHMgY29tcG9uZW50cywgdXNlIG9uZSBvZiBpdHMgZmFjdG9yeSBjbGFzcyBtZXRob2RzOiB7QGxpbmsgRGF0ZVRpbWUubG9jYWx9LCB7QGxpbmsgRGF0ZVRpbWUudXRjfSwgYW5kIChtb3N0IGZsZXhpYmx5KSB7QGxpbmsgRGF0ZVRpbWUuZnJvbU9iamVjdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIHN0YW5kYXJkIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUlTT30sIHtAbGluayBEYXRlVGltZS5mcm9tSFRUUH0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUuZnJvbVJGQzI4MjJ9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBjdXN0b20gc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgbmF0aXZlIEpTIGRhdGUsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUpTRGF0ZX0uXG4gKiAqICoqR3JlZ29yaWFuIGNhbGVuZGFyIGFuZCB0aW1lKio6IFRvIGV4YW1pbmUgdGhlIEdyZWdvcmlhbiBwcm9wZXJ0aWVzIG9mIGEgRGF0ZVRpbWUgaW5kaXZpZHVhbGx5IChpLmUgYXMgb3Bwb3NlZCB0byBjb2xsZWN0aXZlbHkgdGhyb3VnaCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9KSwgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjeWVhcn0sIHtAbGluayBEYXRlVGltZSNtb250aH0sXG4gKiB7QGxpbmsgRGF0ZVRpbWUjZGF5fSwge0BsaW5rIERhdGVUaW1lI2hvdXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXRlfSwge0BsaW5rIERhdGVUaW1lI3NlY29uZH0sIHtAbGluayBEYXRlVGltZSNtaWxsaXNlY29uZH0gYWNjZXNzb3JzLlxuICogKiAqKldlZWsgY2FsZW5kYXIqKjogRm9yIElTTyB3ZWVrIGNhbGVuZGFyIGF0dHJpYnV0ZXMsIHNlZSB0aGUge0BsaW5rIERhdGVUaW1lI3dlZWtZZWFyfSwge0BsaW5rIERhdGVUaW1lI3dlZWtOdW1iZXJ9LCBhbmQge0BsaW5rIERhdGVUaW1lI3dlZWtkYXl9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjbG9jYWxlfSBhbmQge0BsaW5rIERhdGVUaW1lI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKio6IFRvIHRyYW5zZm9ybSB0aGUgRGF0ZVRpbWUgaW50byBvdGhlciBEYXRlVGltZXMsIHVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0fSwge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSwge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0TG9jYWxlfSwge0BsaW5rIERhdGVUaW1lLnBsdXN9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXN9LCB7QGxpbmsgRGF0ZVRpbWUjZW5kT2Z9LCB7QGxpbmsgRGF0ZVRpbWUjc3RhcnRPZn0sIHtAbGluayBEYXRlVGltZSN0b1VUQ30sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0uXG4gKiAqICoqT3V0cHV0Kio6IFRvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZX0sIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlQ2FsZW5kYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9KU09OfSwge0BsaW5rIERhdGVUaW1lI3RvSVNPfSwge0BsaW5rIERhdGVUaW1lI3RvSFRUUH0sIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0sIHtAbGluayBEYXRlVGltZSN0b1JGQzI4MjJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9TdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9LCB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9KU0RhdGV9LlxuICpcbiAqIFRoZXJlJ3MgcGxlbnR5IG90aGVycyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiwgdGltZSB6b25lcywgYWx0ZXJuYXRpdmUgY2FsZW5kYXJzLCB2YWxpZGl0eSwgYW5kIHNvIG9uLCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVUaW1lIHtcbiAgLyoqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3Qgem9uZSA9IGNvbmZpZy56b25lIHx8IFNldHRpbmdzLmRlZmF1bHRab25lO1xuXG4gICAgbGV0IGludmFsaWQgPVxuICAgICAgY29uZmlnLmludmFsaWQgfHxcbiAgICAgIChOdW1iZXIuaXNOYU4oY29uZmlnLnRzKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGwpIHx8XG4gICAgICAoIXpvbmUuaXNWYWxpZCA/IHVuc3VwcG9ydGVkWm9uZSh6b25lKSA6IG51bGwpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHMgPSBpc1VuZGVmaW5lZChjb25maWcudHMpID8gU2V0dGluZ3Mubm93KCkgOiBjb25maWcudHM7XG5cbiAgICBsZXQgYyA9IG51bGwsXG4gICAgICBvID0gbnVsbDtcbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGNvbmZpZy5vbGQgJiYgY29uZmlnLm9sZC50cyA9PT0gdGhpcy50cyAmJiBjb25maWcub2xkLnpvbmUuZXF1YWxzKHpvbmUpO1xuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIFtjLCBvXSA9IFtjb25maWcub2xkLmMsIGNvbmZpZy5vbGQub107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBhbiBvZmZzZXQgaGFzIGJlZW4gcGFzc2VkIGFuZCB3ZSBoYXZlIG5vdCBiZWVuIGNhbGxlZCBmcm9tXG4gICAgICAgIC8vIGNsb25lKCksIHdlIGNhbiB0cnVzdCBpdCBhbmQgYXZvaWQgdGhlIG9mZnNldCBjYWxjdWxhdGlvbi5cbiAgICAgICAgY29uc3Qgb3QgPSBpc051bWJlcihjb25maWcubykgJiYgIWNvbmZpZy5vbGQgPyBjb25maWcubyA6IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjID0gdHNUb09iaih0aGlzLnRzLCBvdCk7XG4gICAgICAgIGludmFsaWQgPSBOdW1iZXIuaXNOYU4oYy55ZWFyKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGw7XG4gICAgICAgIGMgPSBpbnZhbGlkID8gbnVsbCA6IGM7XG4gICAgICAgIG8gPSBpbnZhbGlkID8gbnVsbCA6IG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3pvbmUgPSB6b25lO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsV2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCh7IHpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pICAgICAgLy9+PiBub3csIGluIFVTIGVhc3QgY29hc3QgdGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwLCB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgeyB6b25lOiBcInV0Y1wiIH0pICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwLCBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGxvY2FsKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud2Vla1NldHRpbmdzXSAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCB7IGxvY2FsZTogXCJmclwiIH0pICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1LCB7IGxvY2FsZTogXCJmclwiIH0pIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIHV0YygpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuXG4gICAgb3B0cy56b25lID0gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0LiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAtIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNEYXRlKGRhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRzID0gaXNEYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiBOYU47XG4gICAgaWYgKE51bWJlci5pc05hTih0cykpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgIHRzOiB0cyxcbiAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihtaWxsaXNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBmcm9tTWlsbGlzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0LCBidXQgcmVjZWl2ZWQgYSAke3R5cGVvZiBtaWxsaXNlY29uZHN9IHdpdGggdmFsdWUgJHttaWxsaXNlY29uZHN9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kcyA8IC1NQVhfREFURSB8fCBtaWxsaXNlY29uZHMgPiBNQVhfREFURSkge1xuICAgICAgLy8gdGhpcyBpc24ndCBwZXJmZWN0IGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyAtIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbVNlY29uZHMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogc2Vjb25kcyAqIDEwMDAsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFyJyBhbmQgJ2hvdXInIHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhciAtIGEgeWVhciwgc3VjaCBhcyAxOTg3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGggLSBhIG1vbnRoLCAxLTEyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5IC0gYSBkYXkgb2YgdGhlIG1vbnRoLCAxLTMxLCBkZXBlbmRpbmcgb24gdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoub3JkaW5hbCAtIGRheSBvZiB0aGUgeWVhciwgMS0zNjUgb3IgMzY2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla1llYXIgLSBhbiBJU08gd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla051bWJlciAtIGFuIElTTyB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla2RheSAtIGFuIElTTyB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmxvY2FsV2Vla1llYXIgLSBhIHdlZWsgeWVhciwgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5sb2NhbFdlZWtOdW1iZXIgLSBhIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXIsIGFjY29yZGluZyB0byB0aGUgbG9jYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubG9jYWxXZWVrZGF5IC0gYSB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgdGhlIGZpcnN0IGFuZCA3IGlzIHRoZSBsYXN0IGRheSBvZiB0aGUgd2VlaywgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3VyIC0gaG91ciBvZiB0aGUgZGF5LCAwLTIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlIC0gbWludXRlIG9mIHRoZSBob3VyLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kIC0gc2Vjb25kIG9mIHRoZSBtaW51dGUsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIDAtOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gaW50ZXJwcmV0IHRoZSBudW1iZXJzIGluIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciB6b25lLiBDYW4gdGFrZSBhbnkgdmFsdWUgdGFrZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHNldFpvbmUoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW1cXCdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAndXRjJyB9KSxcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgbG9jYWxXZWVrWWVhcjogMjAyMiwgbG9jYWxXZWVrTnVtYmVyOiAxLCBsb2NhbFdlZWtkYXk6IDEgfSwgeyBsb2NhbGU6IFwiZW4tVVNcIiB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDIxLTEyLTI2J1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgb2JqID0gb2JqIHx8IHt9O1xuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3MpO1xuICAgIGNvbnN0IHsgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayB9ID0gdXNlc0xvY2FsV2Vla1ZhbHVlcyhub3JtYWxpemVkLCBsb2MpO1xuXG4gICAgY29uc3QgdHNOb3cgPSBTZXR0aW5ncy5ub3coKSxcbiAgICAgIG9mZnNldFByb3ZpcyA9ICFpc1VuZGVmaW5lZChvcHRzLnNwZWNpZmljT2Zmc2V0KVxuICAgICAgICA/IG9wdHMuc3BlY2lmaWNPZmZzZXRcbiAgICAgICAgOiB6b25lVG9Vc2Uub2Zmc2V0KHRzTm93KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXI7XG5cbiAgICAvLyBjYXNlczpcbiAgICAvLyBqdXN0IGEgd2Vla2RheSAtPiB0aGlzIHdlZWsncyBpbnN0YW5jZSBvZiB0aGF0IHdlZWtkYXksIG5vIHdvcnJpZXNcbiAgICAvLyAoZ3JlZ29yaWFuIGRhdGEgb3Igb3JkaW5hbCkgKyAod2Vla1llYXIgb3Igd2Vla051bWJlcikgLT4gZXJyb3JcbiAgICAvLyAoZ3JlZ29yaWFuIG1vbnRoIG9yIGRheSkgKyBvcmRpbmFsIC0+IGVycm9yXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXNlIHdlZWtzIG9yIG9yZGluYWxzIG9yIGdyZWdvcmlhbiwgZGVwZW5kaW5nIG9uIHdoYXQncyBzcGVjaWZpZWRcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VXZWVrRGF0YSA9IGRlZmluaXRlV2Vla0RlZiB8fCAobm9ybWFsaXplZC53ZWVrZGF5ICYmICFjb250YWluc0dyZWdvcik7XG5cbiAgICAvLyBjb25maWd1cmUgb3Vyc2VsdmVzIHRvIGRlYWwgd2l0aCBncmVnb3JpYW4gZGF0ZXMgb3Igd2VlayBzdHVmZlxuICAgIGxldCB1bml0cyxcbiAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICBvYmpOb3cgPSB0c1RvT2JqKHRzTm93LCBvZmZzZXRQcm92aXMpO1xuICAgIGlmICh1c2VXZWVrRGF0YSkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkV2Vla1VuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRXZWVrVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvV2VlayhvYmpOb3csIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRPcmRpbmFsVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9PcmRpbmFsKG9iak5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyBzdHVmZlxuICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB1IG9mIHVuaXRzKSB7XG4gICAgICBjb25zdCB2ID0gbm9ybWFsaXplZFt1XTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRmlyc3QpIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IGRlZmF1bHRWYWx1ZXNbdV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gb2JqTm93W3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdmFsdWVzIHdlIGhhdmUgYXJlIGluIHJhbmdlXG4gICAgY29uc3QgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZCwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgIGludmFsaWQgPSBoaWdoZXJPcmRlckludmFsaWQgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGFjdHVhbCB0aW1lXG4gICAgY29uc3QgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZCwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvYyxcbiAgICAgIH0pO1xuXG4gICAgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG4gICAgaWYgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiBjb250YWluc0dyZWdvciAmJiBvYmoud2Vla2RheSAhPT0gaW5zdC53ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgICAgXCJtaXNtYXRjaGVkIHdlZWtkYXlcIixcbiAgICAgICAgYHlvdSBjYW4ndCBzcGVjaWZ5IGJvdGggYSB3ZWVrZGF5IG9mICR7bm9ybWFsaXplZC53ZWVrZGF5fSBhbmQgYSBkYXRlIG9mICR7aW5zdC50b0lTTygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnN0LmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGluc3QuaW52YWxpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy53ZWVrU2V0dGluZ3NdIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJywge3NldFpvbmU6IHRydWV9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycsIHt6b25lOiAndXRjJ30pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtVzA1LTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSVNPRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIklTTyA4NjAxXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIHRoZSBvZmZzZXQgaXMgYWx3YXlzIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzOjEyIEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCdGcmksIDI1IE5vdiAyMDE2IDEzOjIzOjEyICswNjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzIFonKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tUkZDMjgyMih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVJGQzI4MjJEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiUkZDIDI4MjJcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSBIVFRQIGRhdGVzIGFyZSBhbHdheXMgaW4gVVRDLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCB0aGUgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcuIEZvciBIVFRQIGRhdGVzLCB0aGlzIGlzIGFsd2F5cyBVVEMsIHNvIHRoaXMgb3B0aW9uIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYHpvbmVgIG9wdGlvbiB0byAndXRjJywgYnV0IHRoaXMgb3B0aW9uIGlzIGluY2x1ZGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHNpbWlsYXIgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biwgMDYgTm92IDE5OTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1bmRheSwgMDYtTm92LTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4gTm92ICA2IDA4OjQ5OjM3IDE5OTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSFRUUCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUhUVFBEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSFRUUFwiLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIGlucHV0IHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZy5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9wYXJzaW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgdGhlIGxpbmsgYmVsb3cgZm9yIHRoZSBmb3JtYXRzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRleHQpIHx8IGlzVW5kZWZpbmVkKGZtdCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21Gb3JtYXQgcmVxdWlyZXMgYW4gaW5wdXQgc3RyaW5nIGFuZCBhIGZvcm1hdFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdHMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICAgW3ZhbHMsIHBhcnNlZFpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkXSA9IHBhcnNlRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIGBmb3JtYXQgJHtmbXR9YCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIFNRTCBkYXRlLCB0aW1lLCBvciBkYXRldGltZVxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJywgeyBzZXRab25lOiB0cnVlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJywgeyB6b25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMDk6MTI6MzQuMzQyJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNRTCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVNRTCh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlNRTFwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRGF0ZVRpbWUgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGVUaW1lRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZVRpbWUuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0RhdGVUaW1lKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRGF0ZVRpbWUpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIGZvcm1hdCBzdHJpbmcgZm9yIGEgc2V0IG9mIG9wdGlvbnNcbiAgICogQHBhcmFtIGZvcm1hdE9wdHNcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBwYXJzZUZvcm1hdEZvck9wdHMoZm9ybWF0T3B0cywgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdG9rZW5MaXN0ID0gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gIXRva2VuTGlzdCA/IG51bGwgOiB0b2tlbkxpc3QubWFwKCh0KSA9PiAodCA/IHQudmFsIDogbnVsbCkpLmpvaW4oXCJcIik7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgdGhlIGZ1bGx5IGV4cGFuZGVkIGZvcm1hdCB0b2tlbiBmb3IgdGhlIGxvY2FsZVxuICAgKiBEb2VzIE5PVCBxdW90ZSBjaGFyYWN0ZXJzLCBzbyBxdW90ZWQgdG9rZW5zIHdpbGwgbm90IHJvdW5kIHRyaXAgY29ycmVjdGx5XG4gICAqIEBwYXJhbSBmbXRcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBleHBhbmRGb3JtYXQoZm10LCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuIGV4cGFuZGVkLm1hcCgodCkgPT4gdC52YWwpLmpvaW4oXCJcIik7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICB6b25lT2Zmc2V0VHMgPSB1bmRlZmluZWQ7XG4gICAgem9uZU9mZnNldEd1ZXNzQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8vIElORk9cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnbW9udGgnKTsgLy89PiA3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnZGF5Jyk7IC8vPT4gNFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgdmFsaWQuIEludmFsaWQgRGF0ZVRpbWVzIG9jY3VyIHdoZW46XG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGZyb20gaW52YWxpZCBjYWxlbmRhciBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgMTN0aCBtb250aCBvciBGZWJydWFyeSAzMFxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBieSBhbiBvcGVyYXRpb24gb24gYW5vdGhlciBpbnZhbGlkIGRhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEYXRlVGltZSwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG91dHB1dCBjYWxlbmRhciBvZiBhIERhdGVUaW1lLCBzdWNoICdpc2xhbWljJy4gVGhlIG91dHB1dCBjYWxlbmRhciBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIGdldCB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHpvbmVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUubmFtZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS55ZWFyIC8vPT4gMjAxN1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy55ZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucXVhcnRlciAvLz0+IDJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCAoMS0xMikuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1vbnRoIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5kYXkgLy89PiAyNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmRheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXIgb2YgdGhlIGRheSAoMC0yMykuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5KS5ob3VyIC8vPT4gOVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlIG9mIHRoZSBob3VyICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbnV0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1Mikuc2Vjb25kIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5zZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kICgwLTk5OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIsIDY1NCkubWlsbGlzZWNvbmQgLy89PiA2NTRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMiwgMzEpLndlZWtZZWFyIC8vPT4gMjAxNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtZZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciAoMS01MmlzaCkuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrTnVtYmVyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZGF0ZSBpcyBvbiBhIHdlZWtlbmQgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1dlZWtlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCAmJiB0aGlzLmxvYy5nZXRXZWVrZW5kRGF5cygpLmluY2x1ZGVzKHRoaXMud2Vla2RheSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUuXG4gICAqIDEgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBhbmQgNyBpcyB0aGUgbGFzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIElmIHRoZSBsb2NhbGUgYXNzaWducyBTdW5kYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgdGhlbiBhIGRhdGUgd2hpY2ggaXMgYSBTdW5kYXkgd2lsbCByZXR1cm4gMSxcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbFdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZS4gRGlmZmVyZW50IGxvY2FsZXMgYXNzaWduIHdlZWsgbnVtYmVycyBkaWZmZXJlbnRseSxcbiAgICogYmVjYXVzZSB0aGUgd2VlayBjYW4gc3RhcnQgb24gZGlmZmVyZW50IGRheXMgb2YgdGhlIHdlZWsgKHNlZSBsb2NhbFdlZWtkYXkpIGFuZCBiZWNhdXNlIGEgZGlmZmVyZW50IG51bWJlciBvZiBkYXlzXG4gICAqIGlzIHJlcXVpcmVkIGZvciBhIHdlZWsgdG8gY291bnQgYXMgdGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvY2FsV2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXIgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUuIERpZmZlcmVudCBsb2NhbGVzIGFzc2lnbiB3ZWVrIG51bWJlcnMgKGFuZCB0aGVyZWZvciB3ZWVrIHllYXJzKVxuICAgKiBkaWZmZXJlbnRseSwgc2VlIGxvY2FsV2Vla051bWJlci5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbFdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5vcmRpbmFsIC8vPT4gMTQ1XG4gICAqIEB0eXBlIHtudW1iZXJ8RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgb3JkaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYykub3JkaW5hbCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdCcuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aFNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyBtb250aCBuYW1lLCBzdWNoIGFzICdPY3RvYmVyJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhMb25nIC8vPT4gT2N0b2JlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoTG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheVNob3J0IC8vPT4gTW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgd2Vla2RheSwgc3VjaCBhcyAnTW9uZGF5Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5TG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFVUQyBvZmZzZXQgb2YgdGhpcyBEYXRlVGltZSBpbiBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm9mZnNldCAvLz0+IC0yNDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkub2Zmc2V0IC8vPT4gMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gK3RoaXMubyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRVNUXCIgb3IgXCJFRFRcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZVNob3J0KCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvbmcgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcIiBvciBcIkVhc3Rlcm4gRGF5bGlnaHQgVGltZVwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lTG9uZygpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwibG9uZ1wiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGlzIHpvbmUncyBvZmZzZXQgZXZlciBjaGFuZ2VzLCBhcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNPZmZzZXRGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLmlzVW5pdmVyc2FsIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5EU1QoKSB7XG4gICAgaWYgKHRoaXMuaXNPZmZzZXRGaXhlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDEsIGRheTogMSB9KS5vZmZzZXQgfHxcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiA1IH0pLm9mZnNldFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRob3NlIERhdGVUaW1lcyB3aGljaCBoYXZlIHRoZSBzYW1lIGxvY2FsIHRpbWUgYXMgdGhpcyBEYXRlVGltZSwgYnV0IGEgZGlmZmVyZW50IG9mZnNldCBmcm9tIFVUQ1xuICAgKiBpbiB0aGlzIERhdGVUaW1lJ3Mgem9uZS4gRHVyaW5nIERTVCBjaGFuZ2VzIGxvY2FsIHRpbWUgY2FuIGJlIGFtYmlndW91cywgZm9yIGV4YW1wbGVcbiAgICogYDIwMjMtMTAtMjlUMDI6MzA6MDBgIGluIGBFdXJvcGUvQmVybGluYCBjYW4gaGF2ZSBvZmZzZXQgYCswMTowMGAgb3IgYCswMjowMGAuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGJvdGggcG9zc2libGUgRGF0ZVRpbWVzIGlmIHRoaXMgRGF0ZVRpbWUncyBsb2NhbCB0aW1lIGlzIGFtYmlndW91cy5cbiAgICogQHJldHVybnMge0RhdGVUaW1lW119XG4gICAqL1xuICBnZXRQb3NzaWJsZU9mZnNldHMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgdGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCBkYXlNcyA9IDg2NDAwMDAwO1xuICAgIGNvbnN0IG1pbnV0ZU1zID0gNjAwMDA7XG4gICAgY29uc3QgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyh0aGlzLmMpO1xuICAgIGNvbnN0IG9FYXJsaWVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gZGF5TXMpO1xuICAgIGNvbnN0IG9MYXRlciA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyArIGRheU1zKTtcblxuICAgIGNvbnN0IG8xID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gb0VhcmxpZXIgKiBtaW51dGVNcyk7XG4gICAgY29uc3QgbzIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvTGF0ZXIgKiBtaW51dGVNcyk7XG4gICAgaWYgKG8xID09PSBvMikge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgY29uc3QgdHMxID0gbG9jYWxUUyAtIG8xICogbWludXRlTXM7XG4gICAgY29uc3QgdHMyID0gbG9jYWxUUyAtIG8yICogbWludXRlTXM7XG4gICAgY29uc3QgYzEgPSB0c1RvT2JqKHRzMSwgbzEpO1xuICAgIGNvbnN0IGMyID0gdHNUb09iaih0czIsIG8yKTtcbiAgICBpZiAoXG4gICAgICBjMS5ob3VyID09PSBjMi5ob3VyICYmXG4gICAgICBjMS5taW51dGUgPT09IGMyLm1pbnV0ZSAmJlxuICAgICAgYzEuc2Vjb25kID09PSBjMi5zZWNvbmQgJiZcbiAgICAgIGMxLm1pbGxpc2Vjb25kID09PSBjMi5taWxsaXNlY29uZFxuICAgICkge1xuICAgICAgcmV0dXJuIFtjbG9uZSh0aGlzLCB7IHRzOiB0czEgfSksIGNsb25lKHRoaXMsIHsgdHM6IHRzMiB9KV07XG4gICAgfVxuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW4gYSBsZWFwIHllYXIsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5pc0luTGVhcFllYXIgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmlzSW5MZWFwWWVhciAvLz0+IGZhbHNlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5MZWFwWWVhcigpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyBtb250aFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAyKS5kYXlzSW5Nb250aCAvLz0+IDI5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDMpLmRheXNJbk1vbnRoIC8vPT4gMzFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5kYXlzSW5ZZWFyIC8vPT4gMzY2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmRheXNJblllYXIgLy89PiAzNjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBkYXlzSW5ZZWFyKHRoaXMueWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDA0KS53ZWVrc0luV2Vla1llYXIgLy89PiA1M1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS53ZWVrc0luV2Vla1llYXIgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gd2Vla3NJbldlZWtZZWFyKHRoaXMud2Vla1llYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGlzIERhdGVUaW1lJ3MgbG9jYWwgd2VlayB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMjAsIDYsIHtsb2NhbGU6ICdlbi1VUyd9KS53ZWVrc0luTG9jYWxXZWVrWWVhciAvLz0+IDUyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMjAsIDYsIHtsb2NhbGU6ICdkZS1ERSd9KS53ZWVrc0luTG9jYWxXZWVrWWVhciAvLz0+IDUzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbkxvY2FsV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB3ZWVrc0luV2Vla1llYXIoXG4gICAgICAgICAgdGhpcy5sb2NhbFdlZWtZZWFyLFxuICAgICAgICAgIHRoaXMubG9jLmdldE1pbkRheXNJbkZpcnN0V2VlaygpLFxuICAgICAgICAgIHRoaXMubG9jLmdldFN0YXJ0T2ZXZWVrKClcbiAgICAgICAgKVxuICAgICAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWxzbyBzdXBwb3J0cyBzZXR0aW5nIGxvY2FsZS1iYXNlZCB3ZWVrIHVuaXRzLCBpLmUuIGBsb2NhbFdlZWtkYXlgLCBgbG9jYWxXZWVrTnVtYmVyYCBhbmQgYGxvY2FsV2Vla1llYXJgLlxuICAgKiBUaGV5IGNhbm5vdCBiZSBtaXhlZCB3aXRoIElTTy13ZWVrIHVuaXRzIGxpa2UgYHdlZWtkYXlgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyBob3VyOiA4LCBtaW51dGU6IDMwIH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHdlZWtkYXk6IDUgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAwNSwgb3JkaW5hbDogMjM0IH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3QodmFsdWVzLCBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3MpO1xuICAgIGNvbnN0IHsgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayB9ID0gdXNlc0xvY2FsV2Vla1ZhbHVlcyhub3JtYWxpemVkLCB0aGlzLmxvYyk7XG5cbiAgICBjb25zdCBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKFxuICAgICAgICB7IC4uLmdyZWdvcmlhblRvV2Vlayh0aGlzLmMsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspLCAuLi5ub3JtYWxpemVkIH0sXG4gICAgICAgIG1pbkRheXNJbkZpcnN0V2VlayxcbiAgICAgICAgc3RhcnRPZldlZWtcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vla1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3dlZWsnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMycsIHdlZWtzIGFsd2F5cyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhcnRPZih1bml0LCB7IHVzZUxvY2FsZVdlZWtzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIGlmICh1c2VMb2NhbGVXZWVrcykge1xuICAgICAgICBjb25zdCBzdGFydE9mV2VlayA9IHRoaXMubG9jLmdldFN0YXJ0T2ZXZWVrKCk7XG4gICAgICAgIGNvbnN0IHsgd2Vla2RheSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHdlZWtkYXkgPCBzdGFydE9mV2Vlaykge1xuICAgICAgICAgIG8ud2Vla051bWJlciA9IHRoaXMud2Vla051bWJlciAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgby53ZWVrZGF5ID0gc3RhcnRPZldlZWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLndlZWtkYXkgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJxdWFydGVyc1wiKSB7XG4gICAgICBjb25zdCBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgZW5kIChtZWFuaW5nIHRoZSBsYXN0IG1pbGxpc2Vjb25kKSBvZiBhIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBlbmQgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vla1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignbW9udGgnKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3llYXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTEyLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3dlZWsnKS50b0lTTygpOyAvLyA9PiAnMjAxNC0wMy0wOVQyMzo1OTo1OS45OTktMDU6MDAnLCB3ZWVrcyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignZGF5JykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignaG91cicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMDU6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIGVuZE9mKHVuaXQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IHRoaXMucGx1cyh7IFt1bml0XTogMSB9KVxuICAgICAgICAgIC5zdGFydE9mKHVuaXQsIG9wdHMpXG4gICAgICAgICAgLm1pbnVzKDEpXG4gICAgICA6IHRoaXM7XG4gIH1cblxuICAvLyBPVVRQVVRcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLlxuICAgKiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlIGZvcm1hdHRpbmcgdG9vbC4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvZm9ybWF0dGluZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgQXByIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2ZyJykudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnLCB7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoXCJISCAnaG91cnMgYW5kJyBtbSAnbWludXRlcydcIikgLy89PiAnMjAgaG91cnMgYW5kIDU1IG1pbnV0ZXMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLnJlZGVmYXVsdFRvRU4ob3B0cykpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgZGF0ZS4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzIGBEYXRlVGltZS5EQVRFX0ZVTExgIG9yIGBEYXRlVGltZS5USU1FX1NJTVBMRWAuXG4gICAqIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvblxuICAgKiBvZiB0aGUgRGF0ZVRpbWUgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdE9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gNC8yMC8yMDE3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZW4tZ2InKS50b0xvY2FsZVN0cmluZygpOyAvLz0+ICcyMC8wNC8yMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+ICdBcHJpbCAyMCwgMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyJyB9KTsgLy89PiAnMjggYW/Du3QgMjAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+ICcxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfU0hPUlQpOyAvLz0+ICc0LzIwLzIwMTcsIDExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdsb25nJywgbW9udGg6ICdsb25nJywgZGF5OiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodXJzZGF5LCBBcHJpbCAyMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodSwgQXByIDIwLCAxMToyNyBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnLCBob3VyQ3ljbGU6ICdoMjMnIH0pOyAvLz0+ICcxMTozMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXREYXRlVGltZSh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZm9ybWF0IFwicGFydHNcIiwgbWVhbmluZyBpbmRpdmlkdWFsIHRva2VucyBhbG9uZyB3aXRoIG1ldGFkYXRhLiBUaGlzIGlzIGFsbG93cyBjYWxsZXJzIHRvIHBvc3QtcHJvY2VzcyBpbmRpdmlkdWFsIHNlY3Rpb25zIG9mIHRoZSBmb3JtYXR0ZWQgb3V0cHV0LlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdC9mb3JtYXRUb1BhcnRzXG4gICAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLCBzYW1lIGFzIGB0b0xvY2FsZVN0cmluZ2AuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlUGFydHMoKTsgLy89PiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnZGF5JywgdmFsdWU6ICcyNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ21vbnRoJywgdmFsdWU6ICcwNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ3llYXInLCB2YWx1ZTogJzE5ODInIH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gXVxuICAgKi9cbiAgdG9Mb2NhbGVQYXJ0cyhvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIG9wdHMpLmZvcm1hdERhdGVUaW1lUGFydHModGhpcylcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPWZhbHNlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wcmVjaXNpb249J21pbGxpc2Vjb25kcyddIC0gdHJ1bmNhdGUgb3V0cHV0IHRvIGRlc2lyZWQgcHJlc2ljaW9uOiAneWVhcnMnLCAnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJyBvciAnbWlsbGlzZWNvbmRzJy4gV2hlbiBwcmVjaXNpb24gYW5kIHN1cHByZXNzU2Vjb25kcyBvciBzdXBwcmVzc01pbGxpc2Vjb25kcyBhcmUgdXNlZCB0b2dldGhlciwgcHJlY2lzaW9uIHNldHMgdGhlIG1heGltdW0gdW5pdCBzaG93biBpbiB0aGUgb3V0cHV0LCBob3dldmVyIHNlY29uZHMgb3IgbWlsbGlzZWNvbmRzIHdpbGwgc3RpbGwgYmUgc3VwcHJlc3NlZCBpZiB0aGV5IGFyZSAwLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MywgNSwgMjUpLnRvSVNPKCkgLy89PiAnMTk4Mi0wNS0yNVQwMDowMDowMC4wMDBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1LTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcyMDE3MDQyMlQyMDQ3MDUuMzM1LTA0MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgcHJlY2lzaW9uOiAnZGF5JyB9KSAvLz0+ICcyMDE3LTA0LTIyWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBwcmVjaXNpb246ICdtaW51dGUnIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDdaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICovXG4gIHRvSVNPKHtcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgICBwcmVjaXNpb24gPSBcIm1pbGxpc2Vjb25kc1wiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJlY2lzaW9uID0gbm9ybWFsaXplVW5pdChwcmVjaXNpb24pO1xuICAgIGNvbnN0IGV4dCA9IGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiO1xuXG4gICAgbGV0IGMgPSB0b0lTT0RhdGUodGhpcywgZXh0LCBwcmVjaXNpb24pO1xuICAgIGlmIChvcmRlcmVkVW5pdHMuaW5kZXhPZihwcmVjaXNpb24pID49IDMpIGMgKz0gXCJUXCI7XG4gICAgYyArPSB0b0lTT1RpbWUoXG4gICAgICB0aGlzLFxuICAgICAgZXh0LFxuICAgICAgc3VwcHJlc3NTZWNvbmRzLFxuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgZXh0ZW5kZWRab25lLFxuICAgICAgcHJlY2lzaW9uXG4gICAgKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByZWNpc2lvbj0nZGF5J10gLSB0cnVuY2F0ZSBvdXRwdXQgdG8gZGVzaXJlZCBwcmVjaXNpb246ICd5ZWFycycsICdtb250aHMnLCBvciAnZGF5cycuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTk4MjA1MjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgcHJlY2lzaW9uOiAnbW9udGgnIH0pIC8vPT4gJzE5ODItMDUnXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiLCBwcmVjaXNpb24gPSBcImRheVwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIiwgbm9ybWFsaXplVW5pdChwcmVjaXNpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9dHJ1ZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJlY2lzaW9uPSdtaWxsaXNlY29uZHMnXSAtIHRydW5jYXRlIG91dHB1dCB0byBkZXNpcmVkIHByZXNpY2lvbjogJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycgb3IgJ21pbGxpc2Vjb25kcycuIFdoZW4gcHJlY2lzaW9uIGFuZCBzdXBwcmVzc1NlY29uZHMgb3Igc3VwcHJlc3NNaWxsaXNlY29uZHMgYXJlIHVzZWQgdG9nZXRoZXIsIHByZWNpc2lvbiBzZXRzIHRoZSBtYXhpbXVtIHVuaXQgc2hvd24gaW4gdGhlIG91dHB1dCwgaG93ZXZlciBzZWNvbmRzIG9yIG1pbGxpc2Vjb25kcyB3aWxsIHN0aWxsIGJlIHN1cHByZXNzZWQgaWYgdGhleSBhcmUgMC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoKSAvLz0+ICcwNzozNDoxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0LCBzZWNvbmRzOiAwLCBtaWxsaXNlY29uZHM6IDAgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzA3OjM0WidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMDczNDE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kOiA1NiB9KS50b0lTT1RpbWUoeyBwcmVjaXNpb246ICdtaW51dGUnIH0pIC8vPT4gJzA3OjM0WidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKHtcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGluY2x1ZGVQcmVmaXggPSBmYWxzZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgcHJlY2lzaW9uID0gXCJtaWxsaXNlY29uZHNcIixcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByZWNpc2lvbiA9IG5vcm1hbGl6ZVVuaXQocHJlY2lzaW9uKTtcbiAgICBsZXQgYyA9IGluY2x1ZGVQcmVmaXggJiYgb3JkZXJlZFVuaXRzLmluZGV4T2YocHJlY2lzaW9uKSA+PSAzID8gXCJUXCIgOiBcIlwiO1xuICAgIHJldHVybiAoXG4gICAgICBjICtcbiAgICAgIHRvSVNPVGltZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIsXG4gICAgICAgIHN1cHByZXNzU2Vjb25kcyxcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICAgIGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIGV4dGVuZGVkWm9uZSxcbiAgICAgICAgcHJlY2lzaW9uXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFJGQyAyODIyLWNvbXBhdGlibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwICswMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCAtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9SRkMyODIyKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzIFpaWlwiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJzLiBUaGUgb3V0cHV0IGlzIGFsd2F5cyBleHByZXNzZWQgaW4gR01ULlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSBzdHJpbmcgY29uZm9ybXMgdG8gUkZDIDExMjMuXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCBHTVQnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMywgMTkpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMTk6MDA6MDAgR01UJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0hUVFAoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLnRvVVRDKCksIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyAnR01UJ1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMRGF0ZSgpIC8vPT4gJzIwMTQtMDctMTMnXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlWm9uZTogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1IEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMVGltZSh7IGluY2x1ZGVPZmZzZXQgPSB0cnVlLCBpbmNsdWRlWm9uZSA9IGZhbHNlLCBpbmNsdWRlT2Zmc2V0U3BhY2UgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBmbXQgPSBcIkhIOm1tOnNzLlNTU1wiO1xuXG4gICAgaWYgKGluY2x1ZGVab25lIHx8IGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgIGlmIChpbmNsdWRlT2Zmc2V0U3BhY2UpIHtcbiAgICAgICAgZm10ICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgICAgIGZtdCArPSBcInpcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgICAgICBmbXQgKz0gXCJaWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgZm10LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgRGF0ZVRpbWUgeyB0czogJHt0aGlzLnRvSVNPKCl9LCB6b25lOiAke3RoaXMuem9uZS5uYW1lfSwgbG9jYWxlOiAke3RoaXMubG9jYWxlfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBEYXRlVGltZSB7IEludmFsaWQsIHJlYXNvbjogJHt0aGlzLmludmFsaWRSZWFzb259IH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS4gQWxpYXMgb2Yge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgKGluY2x1ZGluZyBtaWxsaXNlY29uZHMgaW4gdGhlIGZyYWN0aW9uYWwgcGFydCkgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIC8gMTAwMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIChhcyBhIHdob2xlIG51bWJlcikgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9Vbml4SW50ZWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5mbG9vcih0aGlzLnRzIC8gMTAwMCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEJTT04gc2VyaWFsaXphYmxlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTRGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRGF0ZVRpbWUncyB5ZWFyLCBtb250aCwgZGF5LCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvT2JqZWN0KCkgLy89PiB7IHllYXI6IDIwMTcsIG1vbnRoOiA0LCBkYXk6IDIyLCBob3VyOiAyMCwgbWludXRlOiA0OSwgc2Vjb25kOiA0MiwgbWlsbGlzZWNvbmQ6IDI2OCB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBiYXNlID0geyAuLi50aGlzLmMgfTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVDb25maWcpIHtcbiAgICAgIGJhc2Uub3V0cHV0Q2FsZW5kYXIgPSB0aGlzLm91dHB1dENhbGVuZGFyO1xuICAgICAgYmFzZS5udW1iZXJpbmdTeXN0ZW0gPSB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICBiYXNlLmxvY2FsZSA9IHRoaXMubG9jLmxvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgRGF0ZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0pTRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTik7XG4gIH1cblxuICAvLyBDT01QQVJFXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBEYXRlVGltZXMgYXMgYSBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBEYXRlVGltZSB0byBjb21wYXJlIHRoaXMgb25lIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIGFycmF5IG9mIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpMSA9IERhdGVUaW1lLmZyb21JU08oJzE5ODItMDUtMjVUMDk6NDUnKSxcbiAgICogICAgIGkyID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4My0xMC0xNFQxMDozMCcpO1xuICAgKiBpMi5kaWZmKGkxKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDQzODA3NTAwMDAwIH1cbiAgICogaTIuZGlmZihpMSwgJ2hvdXJzJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDEyMTY4Ljc1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOS4wMzEyNSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTksIGhvdXJzOiAwLjc1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmKG90aGVyRGF0ZVRpbWUsIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXJEYXRlVGltZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcImNyZWF0ZWQgYnkgZGlmZmluZyBhbiBpbnZhbGlkIERhdGVUaW1lXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGR1ck9wdHMgPSB7IGxvY2FsZTogdGhpcy5sb2NhbGUsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sIC4uLm9wdHMgfTtcblxuICAgIGNvbnN0IHVuaXRzID0gbWF5YmVBcnJheSh1bml0KS5tYXAoRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBvdGhlcklzTGF0ZXIgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKSA+IHRoaXMudmFsdWVPZigpLFxuICAgICAgZWFybGllciA9IG90aGVySXNMYXRlciA/IHRoaXMgOiBvdGhlckRhdGVUaW1lLFxuICAgICAgbGF0ZXIgPSBvdGhlcklzTGF0ZXIgPyBvdGhlckRhdGVUaW1lIDogdGhpcyxcbiAgICAgIGRpZmZlZCA9IGRpZmYoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBkdXJPcHRzKTtcblxuICAgIHJldHVybiBvdGhlcklzTGF0ZXIgPyBkaWZmZWQubmVnYXRlKCkgOiBkaWZmZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgcmlnaHQgbm93LlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI2RpZmZ9XG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmTm93KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmKERhdGVUaW1lLm5vdygpLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgc3Bhbm5pbmcgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCBhbm90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbHxEYXRlVGltZX1cbiAgICovXG4gIHVudGlsKG90aGVyRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyh0aGlzLCBvdGhlckRhdGVUaW1lKSA6IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBEYXRlVGltZSBpcyBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWUgYXMgYW5vdGhlciBEYXRlVGltZS5cbiAgICogSGlnaGVyLW9yZGVyIHVuaXRzIG11c3QgYWxzbyBiZSBpZGVudGljYWwgZm9yIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGB0cnVlYC5cbiAgICogTm90ZSB0aGF0IHRpbWUgem9uZXMgYXJlICoqaWdub3JlZCoqIGluIHRoaXMgY29tcGFyaXNvbiwgd2hpY2ggY29tcGFyZXMgdGhlICoqbG9jYWwqKiBjYWxlbmRhciB0aW1lLiBVc2Uge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9IHRvIGNvbnZlcnQgb25lIG9mIHRoZSBkYXRlcyBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vlazsgb25seSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWUgaXMgdXNlZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5oYXNTYW1lKG90aGVyRFQsICdkYXknKTsgLy9+PiB0cnVlIGlmIG90aGVyRFQgaXMgaW4gdGhlIHNhbWUgY3VycmVudCBjYWxlbmRhciBkYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUob3RoZXJEYXRlVGltZSwgdW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgY29uc3QgYWRqdXN0ZWRUb1pvbmUgPSB0aGlzLnNldFpvbmUob3RoZXJEYXRlVGltZS56b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgIGFkanVzdGVkVG9ab25lLnN0YXJ0T2YodW5pdCwgb3B0cykgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IGFkanVzdGVkVG9ab25lLmVuZE9mKHVuaXQsIG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRGF0ZVRpbWVzIGFyZSBlcXVhbCBpZiBhbmQgb25seSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIHRvd2FyZHMgemVybyBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3R5bGU9XCJsb25nXCJdIC0gdGhlIHN0eWxlIG9mIHVuaXRzLCBtdXN0IGJlIFwibG9uZ1wiLCBcInNob3J0XCIsIG9yIFwibmFycm93XCJcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHM7IGlmIG9taXR0ZWQsIG9yIGFuIGFycmF5LCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgYmVzdCB1bml0LiBVc2UgYW4gYXJyYXkgb3Igb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBvciBcInNlY29uZHNcIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJvdW5kPXRydWVdIC0gd2hldGhlciB0byByb3VuZCB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm91bmRpbmc9XCJ0cnVuY1wiXSAtIHJvdW5kaW5nIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZyB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LiBDYW4gYmUgXCJ0cnVuY1wiICh0b3dhcmQgemVybyksIFwiZXhwYW5kXCIgKGF3YXkgZnJvbSB6ZXJvKSwgXCJyb3VuZFwiLCBcImZsb29yXCIsIG9yIFwiY2VpbFwiLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGFkZGluZz0wXSAtIHBhZGRpbmcgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIGFsbG93cyB5b3UgdG8gcm91bmQgdXAgdGhlIHJlc3VsdCBpZiBpdCBmaXRzIGluc2lkZSB0aGUgdGhyZXNob2xkLiBEb24ndCB1c2UgaW4gY29tYmluYXRpb24gd2l0aCB7cm91bmQ6IGZhbHNlfSBiZWNhdXNlIHRoZSBkZWNpbWFsIG91dHB1dCB3aWxsIGluY2x1ZGUgdGhlIHBhZGRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiaW4gMSBkYXlcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS50b1JlbGF0aXZlKHsgZGF5czogMSB9KSAvLz0+IFwiZGVudHJvIGRlIDEgZMOtYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGFucyAyMyBoZXVyZXNcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoeyB1bml0OiBcImhvdXJzXCIgfSkgLy89PiBcIjQ4IGhvdXJzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgaG91cnM6IDM2IH0pLnRvUmVsYXRpdmUoeyByb3VuZDogZmFsc2UgfSkgLy89PiBcIjEuNSBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBiYXNlID0gb3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyA/ICh0aGlzIDwgYmFzZSA/IC1vcHRpb25zLnBhZGRpbmcgOiBvcHRpb25zLnBhZGRpbmcpIDogMDtcbiAgICBsZXQgdW5pdHMgPSBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdO1xuICAgIGxldCB1bml0ID0gb3B0aW9ucy51bml0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudW5pdCkpIHtcbiAgICAgIHVuaXRzID0gb3B0aW9ucy51bml0O1xuICAgICAgdW5pdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShiYXNlLCB0aGlzLnBsdXMocGFkZGluZyksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImFsd2F5c1wiLFxuICAgICAgdW5pdHMsXG4gICAgICB1bml0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlIHJlbGF0aXZlIHRvIHRvZGF5LCBzdWNoIGFzIFwieWVzdGVyZGF5XCIgb3IgXCJuZXh0IG1vbnRoXCIuXG4gICAqIE9ubHkgaW50ZXJuYXRpb25hbGl6ZXMgb24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdDsgaWYgb21pdHRlZCwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIHVuaXQuIFVzZSBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgb3IgXCJkYXlzXCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwidG9tb3Jyb3dcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcIlwibWHDsWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcih7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkZW1haW5cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLCB0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluIG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtaW5pbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWluIERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtaW4oLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5tYXgpO1xuICB9XG5cbiAgLy8gTUlTQ1xuXG4gIC8qKlxuICAgKiBFeHBsYWluIGhvdyBhIHN0cmluZyB3b3VsZCBiZSBwYXJzZWQgYnkgZnJvbUZvcm1hdCgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgcGFyc2VyIGZvciBgZm10YCB1c2luZyB0aGUgZ2l2ZW4gbG9jYWxlLiBUaGlzIHBhcnNlciBjYW4gYmUgcGFzc2VkXG4gICAqIHRvIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0UGFyc2VyfSB0byBhIHBhcnNlIGEgZGF0ZSBpbiB0aGlzIGZvcm1hdC4gVGhpc1xuICAgKiBjYW4gYmUgdXNlZCB0byBvcHRpbWl6ZSBjYXNlcyB3aGVyZSBtYW55IGRhdGVzIG5lZWQgdG8gYmUgcGFyc2VkIGluIGFcbiAgICogc3BlY2lmaWMgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWVcbiAgICogZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB1c2VkIHRvIHNldCBsb2NhbGUgYW5kIG51bWJlcmluZ1N5c3RlbVxuICAgKiBmb3IgcGFyc2VyXG4gICAqIEByZXR1cm5zIHtUb2tlblBhcnNlcn0gLSBvcGFxdWUgb2JqZWN0IHRvIGJlIHVzZWRcbiAgICovXG4gIHN0YXRpYyBidWlsZEZvcm1hdFBhcnNlcihmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0aW9ucyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUb2tlblBhcnNlcihsb2NhbGVUb1VzZSwgZm10KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIGlucHV0IHN0cmluZyBhbmQgZm9ybWF0IHBhcnNlci5cbiAgICpcbiAgICogVGhlIGZvcm1hdCBwYXJzZXIgbXVzdCBoYXZlIGJlZW4gY3JlYXRlZCB3aXRoIHRoZSBzYW1lIGxvY2FsZSBhcyB0aGlzIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge1Rva2VuUGFyc2VyfSBmb3JtYXRQYXJzZXIgLSBwYXJzZXIgZnJvbSB7QGxpbmsgRGF0ZVRpbWUuYnVpbGRGb3JtYXRQYXJzZXJ9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybnMge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRQYXJzZXIodGV4dCwgZm9ybWF0UGFyc2VyLCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGV4dCkgfHwgaXNVbmRlZmluZWQoZm9ybWF0UGFyc2VyKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBcImZyb21Gb3JtYXRQYXJzZXIgcmVxdWlyZXMgYW4gaW5wdXQgc3RyaW5nIGFuZCBhIGZvcm1hdCBwYXJzZXJcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcblxuICAgIGlmICghbG9jYWxlVG9Vc2UuZXF1YWxzKGZvcm1hdFBhcnNlci5sb2NhbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBmcm9tRm9ybWF0UGFyc2VyIGNhbGxlZCB3aXRoIGEgbG9jYWxlIG9mICR7bG9jYWxlVG9Vc2V9LCBgICtcbiAgICAgICAgICBgYnV0IHRoZSBmb3JtYXQgcGFyc2VyIHdhcyBjcmVhdGVkIGZvciAke2Zvcm1hdFBhcnNlci5sb2NhbGV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGZvcm1hdFBhcnNlci5leHBsYWluRnJvbVRva2Vucyh0ZXh0KTtcblxuICAgIGlmIChpbnZhbGlkUmVhc29uKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkUmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUoXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgem9uZSxcbiAgICAgICAgb3B0cyxcbiAgICAgICAgYGZvcm1hdCAke2Zvcm1hdFBhcnNlci5mb3JtYXR9YCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/duration.js":
/*!********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/duration.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accurateMatrix: () => (/* binding */ accurateMatrix),\n/* harmony export */   casualMatrix: () => (/* binding */ casualMatrix),\n/* harmony export */   daysInMonthAccurate: () => (/* binding */ daysInMonthAccurate),\n/* harmony export */   daysInYearAccurate: () => (/* binding */ daysInYearAccurate),\n/* harmony export */   \"default\": () => (/* binding */ Duration),\n/* harmony export */   lowOrderMatrix: () => (/* binding */ lowOrderMatrix)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\");\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Duration\";\n\n// unit conversion constants\nconst lowOrderMatrix = {\n    weeks: {\n      days: 7,\n      hours: 7 * 24,\n      minutes: 7 * 24 * 60,\n      seconds: 7 * 24 * 60 * 60,\n      milliseconds: 7 * 24 * 60 * 60 * 1000,\n    },\n    days: {\n      hours: 24,\n      minutes: 24 * 60,\n      seconds: 24 * 60 * 60,\n      milliseconds: 24 * 60 * 60 * 1000,\n    },\n    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },\n    minutes: { seconds: 60, milliseconds: 60 * 1000 },\n    seconds: { milliseconds: 1000 },\n  },\n  casualMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: 52,\n      days: 365,\n      hours: 365 * 24,\n      minutes: 365 * 24 * 60,\n      seconds: 365 * 24 * 60 * 60,\n      milliseconds: 365 * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: 13,\n      days: 91,\n      hours: 91 * 24,\n      minutes: 91 * 24 * 60,\n      seconds: 91 * 24 * 60 * 60,\n      milliseconds: 91 * 24 * 60 * 60 * 1000,\n    },\n    months: {\n      weeks: 4,\n      days: 30,\n      hours: 30 * 24,\n      minutes: 30 * 24 * 60,\n      seconds: 30 * 24 * 60 * 60,\n      milliseconds: 30 * 24 * 60 * 60 * 1000,\n    },\n\n    ...lowOrderMatrix,\n  },\n  daysInYearAccurate = 146097.0 / 400,\n  daysInMonthAccurate = 146097.0 / 4800,\n  accurateMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: daysInYearAccurate / 7,\n      days: daysInYearAccurate,\n      hours: daysInYearAccurate * 24,\n      minutes: daysInYearAccurate * 24 * 60,\n      seconds: daysInYearAccurate * 24 * 60 * 60,\n      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: daysInYearAccurate / 28,\n      days: daysInYearAccurate / 4,\n      hours: (daysInYearAccurate * 24) / 4,\n      minutes: (daysInYearAccurate * 24 * 60) / 4,\n      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,\n      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,\n    },\n    months: {\n      weeks: daysInMonthAccurate / 7,\n      days: daysInMonthAccurate,\n      hours: daysInMonthAccurate * 24,\n      minutes: daysInMonthAccurate * 24 * 60,\n      seconds: daysInMonthAccurate * 24 * 60 * 60,\n      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,\n    },\n    ...lowOrderMatrix,\n  };\n\n// units ordered by size\nconst orderedUnits = [\n  \"years\",\n  \"quarters\",\n  \"months\",\n  \"weeks\",\n  \"days\",\n  \"hours\",\n  \"minutes\",\n  \"seconds\",\n  \"milliseconds\",\n];\n\nconst reverseUnits = orderedUnits.slice(0).reverse();\n\n// clone really means \"create another instance just like this one, but with these changes\"\nfunction clone(dur, alts, clear = false) {\n  // deep merge for vals\n  const conf = {\n    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },\n    loc: dur.loc.clone(alts.loc),\n    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,\n    matrix: alts.matrix || dur.matrix,\n  };\n  return new Duration(conf);\n}\n\nfunction durationToMillis(matrix, vals) {\n  let sum = vals.milliseconds ?? 0;\n  for (const unit of reverseUnits.slice(1)) {\n    if (vals[unit]) {\n      sum += vals[unit] * matrix[unit][\"milliseconds\"];\n    }\n  }\n  return sum;\n}\n\n// NB: mutates parameters\nfunction normalizeValues(matrix, vals) {\n  // the logic below assumes the overall value of the duration is positive\n  // if this is not the case, factor is used to make it so\n  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;\n\n  orderedUnits.reduceRight((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const previousVal = vals[previous] * factor;\n        const conv = matrix[current][previous];\n\n        // if (previousVal < 0):\n        // lower order unit is negative (e.g. { years: 2, days: -2 })\n        // normalize this by reducing the higher order unit by the appropriate amount\n        // and increasing the lower order unit\n        // this can never make the higher order unit negative, because this function only operates\n        // on positive durations, so the amount of time represented by the lower order unit cannot\n        // be larger than the higher order unit\n        // else:\n        // lower order unit is positive (e.g. { years: 2, days: 450 } or { years: -2, days: 450 })\n        // in this case we attempt to convert as much as possible from the lower order unit into\n        // the higher order one\n        //\n        // Math.floor takes care of both of these cases, rounding away from 0\n        // if previousVal < 0 it makes the absolute value larger\n        // if previousVal >= it makes the absolute value smaller\n        const rollUp = Math.floor(previousVal / conv);\n        vals[current] += rollUp * factor;\n        vals[previous] -= rollUp * conv * factor;\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n\n  // try to convert any decimals into smaller units if possible\n  // for example for { years: 2.5, days: 0, seconds: 0 } we want to get { years: 2, days: 182, hours: 12 }\n  orderedUnits.reduce((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const fraction = vals[previous] % 1;\n        vals[previous] -= fraction;\n        vals[current] += fraction * matrix[previous][current];\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n}\n\n// Remove all properties with a value of 0 from an object\nfunction removeZeroes(vals) {\n  const newVals = {};\n  for (const [key, value] of Object.entries(vals)) {\n    if (value !== 0) {\n      newVals[key] = value;\n    }\n  }\n  return newVals;\n}\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nclass Duration {\n  /**\n   * @private\n   */\n  constructor(config) {\n    const accurate = config.conversionAccuracy === \"longterm\" || false;\n    let matrix = accurate ? accurateMatrix : casualMatrix;\n\n    if (config.matrix) {\n      matrix = config.matrix;\n    }\n\n    /**\n     * @access private\n     */\n    this.values = config.values;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.matrix = matrix;\n    /**\n     * @access private\n     */\n    this.isLuxonDuration = true;\n  }\n\n  /**\n   * Create Duration from a number of milliseconds.\n   * @param {number} count of milliseconds\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  static fromMillis(count, opts) {\n    return Duration.fromObject({ milliseconds: count }, opts);\n  }\n\n  /**\n   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n   * If this object is empty then a zero milliseconds duration is returned.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.years\n   * @param {number} obj.quarters\n   * @param {number} obj.months\n   * @param {number} obj.weeks\n   * @param {number} obj.days\n   * @param {number} obj.hours\n   * @param {number} obj.minutes\n   * @param {number} obj.seconds\n   * @param {number} obj.milliseconds\n   * @param {Object} [opts=[]] - options for creating this Duration\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the custom conversion system to use\n   * @return {Duration}\n   */\n  static fromObject(obj, opts = {}) {\n    if (obj == null || typeof obj !== \"object\") {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Duration.fromObject: argument expected to be an object, got ${\n          obj === null ? \"null\" : typeof obj\n        }`\n      );\n    }\n\n    return new Duration({\n      values: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(obj, Duration.normalizeUnit),\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromObject(opts),\n      conversionAccuracy: opts.conversionAccuracy,\n      matrix: opts.matrix,\n    });\n  }\n\n  /**\n   * Create a Duration from DurationLike.\n   *\n   * @param {Object | number | Duration} durationLike\n   * One of:\n   * - object with keys like 'years' and 'hours'.\n   * - number representing milliseconds\n   * - Duration instance\n   * @return {Duration}\n   */\n  static fromDurationLike(durationLike) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(durationLike)) {\n      return Duration.fromMillis(durationLike);\n    } else if (Duration.isDuration(durationLike)) {\n      return durationLike;\n    } else if (typeof durationLike === \"object\") {\n      return Duration.fromObject(durationLike);\n    } else {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`\n      );\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 duration string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the preset conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n   * @return {Duration}\n   */\n  static fromISO(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISODuration)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 time string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @return {Duration}\n   */\n  static fromISOTime(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISOTimeOnly)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create an invalid Duration.\n   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Duration}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidDurationError(invalid);\n    } else {\n      return new Duration({ invalid });\n    }\n  }\n\n  /**\n   * @private\n   */\n  static normalizeUnit(unit) {\n    const normalized = {\n      year: \"years\",\n      years: \"years\",\n      quarter: \"quarters\",\n      quarters: \"quarters\",\n      month: \"months\",\n      months: \"months\",\n      week: \"weeks\",\n      weeks: \"weeks\",\n      day: \"days\",\n      days: \"days\",\n      hour: \"hours\",\n      hours: \"hours\",\n      minute: \"minutes\",\n      minutes: \"minutes\",\n      second: \"seconds\",\n      seconds: \"seconds\",\n      millisecond: \"milliseconds\",\n      milliseconds: \"milliseconds\",\n    }[unit ? unit.toLowerCase() : unit];\n\n    if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUnitError(unit);\n\n    return normalized;\n  }\n\n  /**\n   * Check if an object is a Duration. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDuration(o) {\n    return (o && o.isLuxonDuration) || false;\n  }\n\n  /**\n   * Get  the locale of a Duration, such 'en-GB'\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n   * * `S` for milliseconds\n   * * `s` for seconds\n   * * `m` for minutes\n   * * `h` for hours\n   * * `d` for days\n   * * `w` for weeks\n   * * `M` for months\n   * * `y` for years\n   * Notes:\n   * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n   * * Tokens can be escaped by wrapping with single quotes.\n   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - options\n   * @param {boolean} [opts.floor=true] - floor numerical values\n   * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n   * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"+6 +2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"-6 -2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"negativeLargestOnly\" }) //=> \"-6 2\"\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    // reverse-compat since 1.2; we always round down now, never up, and we do it by default\n    const fmtOpts = {\n      ...opts,\n      floor: opts.round !== false && opts.floor !== false,\n    };\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(this.loc, fmtOpts).formatDurationFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a string representation of a Duration with all units included.\n   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options\n   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.\n   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.\n   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero\n   * @example\n   * ```js\n   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })\n   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'\n   * dur.toHuman({ listStyle: \"long\" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'\n   * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 mth, 0 wks, 5 hr, 6 min'\n   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'\n   * ```\n   */\n  toHuman(opts = {}) {\n    if (!this.isValid) return INVALID;\n\n    const showZeros = opts.showZeros !== false;\n\n    const l = orderedUnits\n      .map((unit) => {\n        const val = this.values[unit];\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(val) || (val === 0 && !showZeros)) {\n          return null;\n        }\n        return this.loc\n          .numberFormatter({ style: \"unit\", unitDisplay: \"long\", ...opts, unit: unit.slice(0, -1) })\n          .format(val);\n      })\n      .filter((n) => n);\n\n    return this.loc\n      .listFormatter({ type: \"conjunction\", style: opts.listStyle || \"narrow\", ...opts })\n      .format(l);\n  }\n\n  /**\n   * Returns a JavaScript object with this Duration's values.\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n   * @return {Object}\n   */\n  toObject() {\n    if (!this.isValid) return {};\n    return { ...this.values };\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n   * @return {string}\n   */\n  toISO() {\n    // we could use the formatter, but this is an easier way to get the minimum string\n    if (!this.isValid) return null;\n\n    let s = \"P\";\n    if (this.years !== 0) s += this.years + \"Y\";\n    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\n    if (this.weeks !== 0) s += this.weeks + \"W\";\n    if (this.days !== 0) s += this.days + \"D\";\n    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)\n      s += \"T\";\n    if (this.hours !== 0) s += this.hours + \"H\";\n    if (this.minutes !== 0) s += this.minutes + \"M\";\n    if (this.seconds !== 0 || this.milliseconds !== 0)\n      // this will handle \"floating point madness\" by removing extra decimal places\n      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken\n      s += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.roundTo)(this.seconds + this.milliseconds / 1000, 3) + \"S\";\n    if (s === \"P\") s += \"T0S\";\n    return s;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n   * @return {string}\n   */\n  toISOTime(opts = {}) {\n    if (!this.isValid) return null;\n\n    const millis = this.toMillis();\n    if (millis < 0 || millis >= 86400000) return null;\n\n    opts = {\n      suppressMilliseconds: false,\n      suppressSeconds: false,\n      includePrefix: false,\n      format: \"extended\",\n      ...opts,\n      includeOffset: false,\n    };\n\n    const dateTime = _datetime_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromMillis(millis, { zone: \"UTC\" });\n    return dateTime.toISOTime(opts);\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n   * @return {string}\n   */\n  toString() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a string representation of this Duration appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Duration { values: ${JSON.stringify(this.values)} }`;\n    } else {\n      return `Duration { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration.\n   * @return {number}\n   */\n  toMillis() {\n    if (!this.isValid) return NaN;\n\n    return durationToMillis(this.matrix, this.values);\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration),\n      result = {};\n\n    for (const k of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(dur.values, k) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(this.values, k)) {\n        result[k] = dur.get(k) + this.get(k);\n      }\n    }\n\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration);\n    return this.plus(dur.negate());\n  }\n\n  /**\n   * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === \"hours\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n   * @return {Duration}\n   */\n  mapUnits(fn) {\n    if (!this.isValid) return this;\n    const result = {};\n    for (const k of Object.keys(this.values)) {\n      result[k] = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.asNumber)(fn(this.values[k], k));\n    }\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n   * @return {number}\n   */\n  get(unit) {\n    return this[Duration.normalizeUnit(unit)];\n  }\n\n  /**\n   * \"Set\" the values of specified units. Return a newly-constructed Duration.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dur.set({ years: 2017 })\n   * @example dur.set({ hours: 8, minutes: 30 })\n   * @return {Duration}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const mixed = { ...this.values, ...(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(values, Duration.normalizeUnit) };\n    return clone(this, { values: mixed });\n  }\n\n  /**\n   * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n   * @example dur.reconfigure({ locale: 'en-GB' })\n   * @return {Duration}\n   */\n  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem });\n    const opts = { loc, matrix, conversionAccuracy };\n    return clone(this, opts);\n  }\n\n  /**\n   * Return the length of the duration in the specified unit.\n   * @param {string} unit - a unit such as 'minutes' or 'days'\n   * @example Duration.fromObject({years: 1}).as('days') //=> 365\n   * @example Duration.fromObject({years: 1}).as('months') //=> 12\n   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\n   * @return {number}\n   */\n  as(unit) {\n    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\n  }\n\n  /**\n   * Reduce this Duration to its canonical representation in its current units.\n   * Assuming the overall value of the Duration is positive, this means:\n   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)\n   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise\n   *   the overall value would be negative, see third example)\n   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)\n   *\n   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.\n   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }\n   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }\n   * @return {Duration}\n   */\n  normalize() {\n    if (!this.isValid) return this;\n    const vals = this.toObject();\n    normalizeValues(this.matrix, vals);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Rescale units to its largest representation\n   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }\n   * @return {Duration}\n   */\n  rescale() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.normalize().shiftToAll().toObject());\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Convert this Duration into its representation in a different set of units.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n   * @return {Duration}\n   */\n  shiftTo(...units) {\n    if (!this.isValid) return this;\n\n    if (units.length === 0) {\n      return this;\n    }\n\n    units = units.map((u) => Duration.normalizeUnit(u));\n\n    const built = {},\n      accumulated = {},\n      vals = this.toObject();\n    let lastUnit;\n\n    for (const k of orderedUnits) {\n      if (units.indexOf(k) >= 0) {\n        lastUnit = k;\n\n        let own = 0;\n\n        // anything we haven't boiled down yet should get boiled to this unit\n        for (const ak in accumulated) {\n          own += this.matrix[ak][k] * accumulated[ak];\n          accumulated[ak] = 0;\n        }\n\n        // plus anything that's already in this unit\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n          own += vals[k];\n        }\n\n        // only keep the integer part for now in the hopes of putting any decimal part\n        // into a smaller unit later\n        const i = Math.trunc(own);\n        built[k] = i;\n        accumulated[k] = (own * 1000 - i * 1000) / 1000;\n\n        // otherwise, keep it in the wings to boil it later\n      } else if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n        accumulated[k] = vals[k];\n      }\n    }\n\n    // anything leftover becomes the decimal for the last unit\n    // lastUnit must be defined since units is not empty\n    for (const key in accumulated) {\n      if (accumulated[key] !== 0) {\n        built[lastUnit] +=\n          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\n      }\n    }\n\n    normalizeValues(this.matrix, built);\n    return clone(this, { values: built }, true);\n  }\n\n  /**\n   * Shift this Duration to all available units.\n   * Same as shiftTo(\"years\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"milliseconds\")\n   * @return {Duration}\n   */\n  shiftToAll() {\n    if (!this.isValid) return this;\n    return this.shiftTo(\n      \"years\",\n      \"months\",\n      \"weeks\",\n      \"days\",\n      \"hours\",\n      \"minutes\",\n      \"seconds\",\n      \"milliseconds\"\n    );\n  }\n\n  /**\n   * Return the negative of this Duration.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n   * @return {Duration}\n   */\n  negate() {\n    if (!this.isValid) return this;\n    const negated = {};\n    for (const k of Object.keys(this.values)) {\n      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];\n    }\n    return clone(this, { values: negated }, true);\n  }\n\n  /**\n   * Removes all units with values equal to 0 from this Duration.\n   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }\n   * @return {Duration}\n   */\n  removeZeros() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.values);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Get the years.\n   * @type {number}\n   */\n  get years() {\n    return this.isValid ? this.values.years || 0 : NaN;\n  }\n\n  /**\n   * Get the quarters.\n   * @type {number}\n   */\n  get quarters() {\n    return this.isValid ? this.values.quarters || 0 : NaN;\n  }\n\n  /**\n   * Get the months.\n   * @type {number}\n   */\n  get months() {\n    return this.isValid ? this.values.months || 0 : NaN;\n  }\n\n  /**\n   * Get the weeks\n   * @type {number}\n   */\n  get weeks() {\n    return this.isValid ? this.values.weeks || 0 : NaN;\n  }\n\n  /**\n   * Get the days.\n   * @type {number}\n   */\n  get days() {\n    return this.isValid ? this.values.days || 0 : NaN;\n  }\n\n  /**\n   * Get the hours.\n   * @type {number}\n   */\n  get hours() {\n    return this.isValid ? this.values.hours || 0 : NaN;\n  }\n\n  /**\n   * Get the minutes.\n   * @type {number}\n   */\n  get minutes() {\n    return this.isValid ? this.values.minutes || 0 : NaN;\n  }\n\n  /**\n   * Get the seconds.\n   * @return {number}\n   */\n  get seconds() {\n    return this.isValid ? this.values.seconds || 0 : NaN;\n  }\n\n  /**\n   * Get the milliseconds.\n   * @return {number}\n   */\n  get milliseconds() {\n    return this.isValid ? this.values.milliseconds || 0 : NaN;\n  }\n\n  /**\n   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n   * on invalid DateTimes or Intervals.\n   * @return {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this Duration became invalid, or null if the Duration is valid\n   * @return {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Equality check\n   * Two Durations are equal iff they have the same units and the same values for each unit.\n   * @param {Duration} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    if (!this.loc.equals(other.loc)) {\n      return false;\n    }\n\n    function eq(v1, v2) {\n      // Consider 0 and undefined as equal\n      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;\n      return v1 === v2;\n    }\n\n    for (const u of orderedUnits) {\n      if (!eq(this.values[u], other.values[u])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7QUFDL0M7QUFDSjtBQUNGO0FBQ3FDO0FBUW5EO0FBQ2E7QUFDQTs7QUFFckM7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWEsNkRBQTZEO0FBQzFFLGVBQWUsc0NBQXNDO0FBQ3JELGVBQWUsb0JBQW9CO0FBQ25DLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQ0FBb0MsR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDBE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QTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZER1cmF0aW9uRXJyb3IsIEludmFsaWRVbml0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VJU09EdXJhdGlvbiwgcGFyc2VJU09UaW1lT25seSB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGFzTnVtYmVyLFxuICBoYXNPd25Qcm9wZXJ0eSxcbiAgaXNOdW1iZXIsXG4gIGlzVW5kZWZpbmVkLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBEdXJhdGlvblwiO1xuXG4vLyB1bml0IGNvbnZlcnNpb24gY29uc3RhbnRzXG5leHBvcnQgY29uc3QgbG93T3JkZXJNYXRyaXggPSB7XG4gICAgd2Vla3M6IHtcbiAgICAgIGRheXM6IDcsXG4gICAgICBob3VyczogNyAqIDI0LFxuICAgICAgbWludXRlczogNyAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiA3ICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGRheXM6IHtcbiAgICAgIGhvdXJzOiAyNCxcbiAgICAgIG1pbnV0ZXM6IDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBob3VyczogeyBtaW51dGVzOiA2MCwgc2Vjb25kczogNjAgKiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDYwICogMTAwMCB9LFxuICAgIG1pbnV0ZXM6IHsgc2Vjb25kczogNjAsIG1pbGxpc2Vjb25kczogNjAgKiAxMDAwIH0sXG4gICAgc2Vjb25kczogeyBtaWxsaXNlY29uZHM6IDEwMDAgfSxcbiAgfSxcbiAgY2FzdWFsTWF0cml4ID0ge1xuICAgIHllYXJzOiB7XG4gICAgICBxdWFydGVyczogNCxcbiAgICAgIG1vbnRoczogMTIsXG4gICAgICB3ZWVrczogNTIsXG4gICAgICBkYXlzOiAzNjUsXG4gICAgICBob3VyczogMzY1ICogMjQsXG4gICAgICBtaW51dGVzOiAzNjUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiAxMyxcbiAgICAgIGRheXM6IDkxLFxuICAgICAgaG91cnM6IDkxICogMjQsXG4gICAgICBtaW51dGVzOiA5MSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogNCxcbiAgICAgIGRheXM6IDMwLFxuICAgICAgaG91cnM6IDMwICogMjQsXG4gICAgICBtaW51dGVzOiAzMCAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG5cbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfSxcbiAgZGF5c0luWWVhckFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0MDAsXG4gIGRheXNJbk1vbnRoQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQ4MDAsXG4gIGFjY3VyYXRlTWF0cml4ID0ge1xuICAgIHllYXJzOiB7XG4gICAgICBxdWFydGVyczogNCxcbiAgICAgIG1vbnRoczogMTIsXG4gICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gNyxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSxcbiAgICAgIGhvdXJzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBxdWFydGVyczoge1xuICAgICAgbW9udGhzOiAzLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDI4LFxuICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlIC8gNCxcbiAgICAgIGhvdXJzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQpIC8gNCxcbiAgICAgIG1pbnV0ZXM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwKSAvIDQsXG4gICAgICBzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwKSAvIDQsXG4gICAgICBtaWxsaXNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwKSAvIDQsXG4gICAgfSxcbiAgICBtb250aHM6IHtcbiAgICAgIHdlZWtzOiBkYXlzSW5Nb250aEFjY3VyYXRlIC8gNyxcbiAgICAgIGRheXM6IGRheXNJbk1vbnRoQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0LFxuICAgICAgbWludXRlczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIC4uLmxvd09yZGVyTWF0cml4LFxuICB9O1xuXG4vLyB1bml0cyBvcmRlcmVkIGJ5IHNpemVcbmNvbnN0IG9yZGVyZWRVbml0cyA9IFtcbiAgXCJ5ZWFyc1wiLFxuICBcInF1YXJ0ZXJzXCIsXG4gIFwibW9udGhzXCIsXG4gIFwid2Vla3NcIixcbiAgXCJkYXlzXCIsXG4gIFwiaG91cnNcIixcbiAgXCJtaW51dGVzXCIsXG4gIFwic2Vjb25kc1wiLFxuICBcIm1pbGxpc2Vjb25kc1wiLFxuXTtcblxuY29uc3QgcmV2ZXJzZVVuaXRzID0gb3JkZXJlZFVuaXRzLnNsaWNlKDApLnJldmVyc2UoKTtcblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zIFwiY3JlYXRlIGFub3RoZXIgaW5zdGFuY2UganVzdCBsaWtlIHRoaXMgb25lLCBidXQgd2l0aCB0aGVzZSBjaGFuZ2VzXCJcbmZ1bmN0aW9uIGNsb25lKGR1ciwgYWx0cywgY2xlYXIgPSBmYWxzZSkge1xuICAvLyBkZWVwIG1lcmdlIGZvciB2YWxzXG4gIGNvbnN0IGNvbmYgPSB7XG4gICAgdmFsdWVzOiBjbGVhciA/IGFsdHMudmFsdWVzIDogeyAuLi5kdXIudmFsdWVzLCAuLi4oYWx0cy52YWx1ZXMgfHwge30pIH0sXG4gICAgbG9jOiBkdXIubG9jLmNsb25lKGFsdHMubG9jKSxcbiAgICBjb252ZXJzaW9uQWNjdXJhY3k6IGFsdHMuY29udmVyc2lvbkFjY3VyYWN5IHx8IGR1ci5jb252ZXJzaW9uQWNjdXJhY3ksXG4gICAgbWF0cml4OiBhbHRzLm1hdHJpeCB8fCBkdXIubWF0cml4LFxuICB9O1xuICByZXR1cm4gbmV3IER1cmF0aW9uKGNvbmYpO1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvblRvTWlsbGlzKG1hdHJpeCwgdmFscykge1xuICBsZXQgc3VtID0gdmFscy5taWxsaXNlY29uZHMgPz8gMDtcbiAgZm9yIChjb25zdCB1bml0IG9mIHJldmVyc2VVbml0cy5zbGljZSgxKSkge1xuICAgIGlmICh2YWxzW3VuaXRdKSB7XG4gICAgICBzdW0gKz0gdmFsc1t1bml0XSAqIG1hdHJpeFt1bml0XVtcIm1pbGxpc2Vjb25kc1wiXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuLy8gTkI6IG11dGF0ZXMgcGFyYW1ldGVyc1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWVzKG1hdHJpeCwgdmFscykge1xuICAvLyB0aGUgbG9naWMgYmVsb3cgYXNzdW1lcyB0aGUgb3ZlcmFsbCB2YWx1ZSBvZiB0aGUgZHVyYXRpb24gaXMgcG9zaXRpdmVcbiAgLy8gaWYgdGhpcyBpcyBub3QgdGhlIGNhc2UsIGZhY3RvciBpcyB1c2VkIHRvIG1ha2UgaXQgc29cbiAgY29uc3QgZmFjdG9yID0gZHVyYXRpb25Ub01pbGxpcyhtYXRyaXgsIHZhbHMpIDwgMCA/IC0xIDogMTtcblxuICBvcmRlcmVkVW5pdHMucmVkdWNlUmlnaHQoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsID0gdmFsc1twcmV2aW91c10gKiBmYWN0b3I7XG4gICAgICAgIGNvbnN0IGNvbnYgPSBtYXRyaXhbY3VycmVudF1bcHJldmlvdXNdO1xuXG4gICAgICAgIC8vIGlmIChwcmV2aW91c1ZhbCA8IDApOlxuICAgICAgICAvLyBsb3dlciBvcmRlciB1bml0IGlzIG5lZ2F0aXZlIChlLmcuIHsgeWVhcnM6IDIsIGRheXM6IC0yIH0pXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0aGlzIGJ5IHJlZHVjaW5nIHRoZSBoaWdoZXIgb3JkZXIgdW5pdCBieSB0aGUgYXBwcm9wcmlhdGUgYW1vdW50XG4gICAgICAgIC8vIGFuZCBpbmNyZWFzaW5nIHRoZSBsb3dlciBvcmRlciB1bml0XG4gICAgICAgIC8vIHRoaXMgY2FuIG5ldmVyIG1ha2UgdGhlIGhpZ2hlciBvcmRlciB1bml0IG5lZ2F0aXZlLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gb25seSBvcGVyYXRlc1xuICAgICAgICAvLyBvbiBwb3NpdGl2ZSBkdXJhdGlvbnMsIHNvIHRoZSBhbW91bnQgb2YgdGltZSByZXByZXNlbnRlZCBieSB0aGUgbG93ZXIgb3JkZXIgdW5pdCBjYW5ub3RcbiAgICAgICAgLy8gYmUgbGFyZ2VyIHRoYW4gdGhlIGhpZ2hlciBvcmRlciB1bml0XG4gICAgICAgIC8vIGVsc2U6XG4gICAgICAgIC8vIGxvd2VyIG9yZGVyIHVuaXQgaXMgcG9zaXRpdmUgKGUuZy4geyB5ZWFyczogMiwgZGF5czogNDUwIH0gb3IgeyB5ZWFyczogLTIsIGRheXM6IDQ1MCB9KVxuICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgYXR0ZW1wdCB0byBjb252ZXJ0IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgbG93ZXIgb3JkZXIgdW5pdCBpbnRvXG4gICAgICAgIC8vIHRoZSBoaWdoZXIgb3JkZXIgb25lXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGguZmxvb3IgdGFrZXMgY2FyZSBvZiBib3RoIG9mIHRoZXNlIGNhc2VzLCByb3VuZGluZyBhd2F5IGZyb20gMFxuICAgICAgICAvLyBpZiBwcmV2aW91c1ZhbCA8IDAgaXQgbWFrZXMgdGhlIGFic29sdXRlIHZhbHVlIGxhcmdlclxuICAgICAgICAvLyBpZiBwcmV2aW91c1ZhbCA+PSBpdCBtYWtlcyB0aGUgYWJzb2x1dGUgdmFsdWUgc21hbGxlclxuICAgICAgICBjb25zdCByb2xsVXAgPSBNYXRoLmZsb29yKHByZXZpb3VzVmFsIC8gY29udik7XG4gICAgICAgIHZhbHNbY3VycmVudF0gKz0gcm9sbFVwICogZmFjdG9yO1xuICAgICAgICB2YWxzW3ByZXZpb3VzXSAtPSByb2xsVXAgKiBjb252ICogZmFjdG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gIH0sIG51bGwpO1xuXG4gIC8vIHRyeSB0byBjb252ZXJ0IGFueSBkZWNpbWFscyBpbnRvIHNtYWxsZXIgdW5pdHMgaWYgcG9zc2libGVcbiAgLy8gZm9yIGV4YW1wbGUgZm9yIHsgeWVhcnM6IDIuNSwgZGF5czogMCwgc2Vjb25kczogMCB9IHdlIHdhbnQgdG8gZ2V0IHsgeWVhcnM6IDIsIGRheXM6IDE4MiwgaG91cnM6IDEyIH1cbiAgb3JkZXJlZFVuaXRzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSB2YWxzW3ByZXZpb3VzXSAlIDE7XG4gICAgICAgIHZhbHNbcHJldmlvdXNdIC09IGZyYWN0aW9uO1xuICAgICAgICB2YWxzW2N1cnJlbnRdICs9IGZyYWN0aW9uICogbWF0cml4W3ByZXZpb3VzXVtjdXJyZW50XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcbn1cblxuLy8gUmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIHdpdGggYSB2YWx1ZSBvZiAwIGZyb20gYW4gb2JqZWN0XG5mdW5jdGlvbiByZW1vdmVaZXJvZXModmFscykge1xuICBjb25zdCBuZXdWYWxzID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICBuZXdWYWxzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHM7XG59XG5cbi8qKlxuICogQSBEdXJhdGlvbiBvYmplY3QgcmVwcmVzZW50cyBhIHBlcmlvZCBvZiB0aW1lLCBsaWtlIFwiMiBtb250aHNcIiBvciBcIjEgZGF5LCAxIGhvdXJcIi4gQ29uY2VwdHVhbGx5LCBpdCdzIGp1c3QgYSBtYXAgb2YgdW5pdHMgdG8gdGhlaXIgcXVhbnRpdGllcywgYWNjb21wYW5pZWQgYnkgc29tZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gYW5kIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uIFRoZXkgY2FuIGJlIHVzZWQgb24gdGhlaXIgb3duIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgTHV4b24gdHlwZXM7IGZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c30gdG8gYWRkIGEgRHVyYXRpb24gb2JqZWN0IHRvIGEgRGF0ZVRpbWUsIHByb2R1Y2luZyBhbm90aGVyIERhdGVUaW1lLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gRHVyYXRpb246XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGEgRHVyYXRpb24sIHVzZSB7QGxpbmsgRHVyYXRpb24uZnJvbU1pbGxpc30sIHtAbGluayBEdXJhdGlvbi5mcm9tT2JqZWN0fSwgb3Ige0BsaW5rIER1cmF0aW9uLmZyb21JU099LlxuICogKiAqKlVuaXQgdmFsdWVzKiogU2VlIHRoZSB7QGxpbmsgRHVyYXRpb24jeWVhcnN9LCB7QGxpbmsgRHVyYXRpb24jbW9udGhzfSwge0BsaW5rIER1cmF0aW9uI3dlZWtzfSwge0BsaW5rIER1cmF0aW9uI2RheXN9LCB7QGxpbmsgRHVyYXRpb24jaG91cnN9LCB7QGxpbmsgRHVyYXRpb24jbWludXRlc30sIHtAbGluayBEdXJhdGlvbiNzZWNvbmRzfSwge0BsaW5rIER1cmF0aW9uI21pbGxpc2Vjb25kc30gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgIHtAbGluayBEdXJhdGlvbiNsb2NhbGV9IGFuZCB7QGxpbmsgRHVyYXRpb24jbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgbmV3IER1cmF0aW9ucyBvdXQgb2Ygb2xkIG9uZXMgdXNlIHtAbGluayBEdXJhdGlvbiNwbHVzfSwge0BsaW5rIER1cmF0aW9uI21pbnVzfSwge0BsaW5rIER1cmF0aW9uI25vcm1hbGl6ZX0sIHtAbGluayBEdXJhdGlvbiNzZXR9LCB7QGxpbmsgRHVyYXRpb24jcmVjb25maWd1cmV9LCB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30sIGFuZCB7QGxpbmsgRHVyYXRpb24jbmVnYXRlfS5cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBEdXJhdGlvbiBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBEdXJhdGlvbiNhc30sIHtAbGluayBEdXJhdGlvbiN0b0lTT30sIHtAbGluayBEdXJhdGlvbiN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgRHVyYXRpb24jdG9KU09OfVxuICpcbiAqIFRoZXJlJ3MgYXJlIG1vcmUgbWV0aG9kcyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgdmFsaWRpdHksIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVyYXRpb24ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY3VyYXRlID0gY29uZmlnLmNvbnZlcnNpb25BY2N1cmFjeSA9PT0gXCJsb25ndGVybVwiIHx8IGZhbHNlO1xuICAgIGxldCBtYXRyaXggPSBhY2N1cmF0ZSA/IGFjY3VyYXRlTWF0cml4IDogY2FzdWFsTWF0cml4O1xuXG4gICAgaWYgKGNvbmZpZy5tYXRyaXgpIHtcbiAgICAgIG1hdHJpeCA9IGNvbmZpZy5tYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBjb25maWcudmFsdWVzO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb252ZXJzaW9uQWNjdXJhY3kgPSBhY2N1cmF0ZSA/IFwibG9uZ3Rlcm1cIiA6IFwiY2FzdWFsXCI7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EdXJhdGlvbiA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIER1cmF0aW9uIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgb2YgbWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tTWlsbGlzKGNvdW50LCBvcHRzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IGNvdW50IH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiBJZiB0aGlzIG9iamVjdCBpcyBlbXB0eSB0aGVuIGEgemVybyBtaWxsaXNlY29uZHMgZHVyYXRpb24gaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoucXVhcnRlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3Vyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz1bXV0gLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY3VzdG9tIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYER1cmF0aW9uLmZyb21PYmplY3Q6IGFyZ3VtZW50IGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgZ290ICR7XG4gICAgICAgICAgb2JqID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygb2JqXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRHVyYXRpb24oe1xuICAgICAgdmFsdWVzOiBub3JtYWxpemVPYmplY3Qob2JqLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0cyksXG4gICAgICBjb252ZXJzaW9uQWNjdXJhY3k6IG9wdHMuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgICAgbWF0cml4OiBvcHRzLm1hdHJpeCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIER1cmF0aW9uTGlrZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBEdXJhdGlvbn0gZHVyYXRpb25MaWtlXG4gICAqIE9uZSBvZjpcbiAgICogLSBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogLSBudW1iZXIgcmVwcmVzZW50aW5nIG1pbGxpc2Vjb25kc1xuICAgKiAtIER1cmF0aW9uIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb25MaWtlKSB7XG4gICAgaWYgKGlzTnVtYmVyKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIGlmIChEdXJhdGlvbi5pc0R1cmF0aW9uKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBkdXJhdGlvbkxpa2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25MaWtlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBVbmtub3duIGR1cmF0aW9uIGFyZ3VtZW50ICR7ZHVyYXRpb25MaWtlfSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uTGlrZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDNZNk0xVzREVDEySDMwTTVTJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDMsIG1vbnRoczogNiwgd2Vla3M6IDEsIGRheXM6IDQsIGhvdXJzOiAxMiwgbWludXRlczogMzAsIHNlY29uZHM6IDUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQVDIzSCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyMyB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1A1WTNNJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDUsIG1vbnRoczogMyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09EdXJhdGlvbih0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSB0aW1lIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMToyMjozMy40NDQnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDIyLCBzZWNvbmRzOiAzMywgbWlsbGlzZWNvbmRzOiA0NDQgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnVDExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExMDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnVDExMDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPVGltZSh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT1RpbWVPbmx5KHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgZGF0ZXRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRHVyYXRpb25FcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICAgIHllYXI6IFwieWVhcnNcIixcbiAgICAgIHllYXJzOiBcInllYXJzXCIsXG4gICAgICBxdWFydGVyOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBxdWFydGVyczogXCJxdWFydGVyc1wiLFxuICAgICAgbW9udGg6IFwibW9udGhzXCIsXG4gICAgICBtb250aHM6IFwibW9udGhzXCIsXG4gICAgICB3ZWVrOiBcIndlZWtzXCIsXG4gICAgICB3ZWVrczogXCJ3ZWVrc1wiLFxuICAgICAgZGF5OiBcImRheXNcIixcbiAgICAgIGRheXM6IFwiZGF5c1wiLFxuICAgICAgaG91cjogXCJob3Vyc1wiLFxuICAgICAgaG91cnM6IFwiaG91cnNcIixcbiAgICAgIG1pbnV0ZTogXCJtaW51dGVzXCIsXG4gICAgICBtaW51dGVzOiBcIm1pbnV0ZXNcIixcbiAgICAgIHNlY29uZDogXCJzZWNvbmRzXCIsXG4gICAgICBzZWNvbmRzOiBcInNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgIH1bdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6IHVuaXRdO1xuXG4gICAgaWYgKCFub3JtYWxpemVkKSB0aHJvdyBuZXcgSW52YWxpZFVuaXRFcnJvcih1bml0KTtcblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhIER1cmF0aW9uLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEdXJhdGlvbihvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkR1cmF0aW9uKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgIHRoZSBsb2NhbGUgb2YgYSBEdXJhdGlvbiwgc3VjaCAnZW4tR0InXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIER1cmF0aW9uLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIER1cmF0aW9uXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy4gWW91IG1heSB1c2UgdGhlc2UgdG9rZW5zOlxuICAgKiAqIGBTYCBmb3IgbWlsbGlzZWNvbmRzXG4gICAqICogYHNgIGZvciBzZWNvbmRzXG4gICAqICogYG1gIGZvciBtaW51dGVzXG4gICAqICogYGhgIGZvciBob3Vyc1xuICAgKiAqIGBkYCBmb3IgZGF5c1xuICAgKiAqIGB3YCBmb3Igd2Vla3NcbiAgICogKiBgTWAgZm9yIG1vbnRoc1xuICAgKiAqIGB5YCBmb3IgeWVhcnNcbiAgICogTm90ZXM6XG4gICAqICogQWRkIHBhZGRpbmcgYnkgcmVwZWF0aW5nIHRoZSB0b2tlbiwgZS5nLiBcInl5XCIgcGFkcyB0aGUgeWVhcnMgdG8gdHdvIGRpZ2l0cywgXCJoaGhoXCIgcGFkcyB0aGUgaG91cnMgb3V0IHRvIGZvdXIgZGlnaXRzXG4gICAqICogVG9rZW5zIGNhbiBiZSBlc2NhcGVkIGJ5IHdyYXBwaW5nIHdpdGggc2luZ2xlIHF1b3Rlcy5cbiAgICogKiBUaGUgZHVyYXRpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdGhlIHNldCBvZiB1bml0cyBpbiB0aGUgZm9ybWF0IHN0cmluZyB1c2luZyB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30gYW5kIHRoZSBEdXJhdGlvbnMncyBjb252ZXJzaW9uIGFjY3VyYWN5IHNldHRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5mbG9vcj10cnVlXSAtIGZsb29yIG51bWVyaWNhbCB2YWx1ZXNcbiAgICogQHBhcmFtIHsnbmVnYXRpdmUnfCdhbGwnfCduZWdhdGl2ZUxhcmdlc3RPbmx5J30gW29wdHMuc2lnbk1vZGU9bmVnYXRpdmVdIC0gSG93IHRvIGhhbmRsZSBzaWduc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJkIHNcIiwgeyBzaWduTW9kZTogXCJhbGxcIiB9KSAvLz0+IFwiKzYgKzJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogLTYsIHNlY29uZHM6IC0yIH0pLnRvRm9ybWF0KFwiZCBzXCIsIHsgc2lnbk1vZGU6IFwiYWxsXCIgfSkgLy89PiBcIi02IC0yXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IC02LCBzZWNvbmRzOiAtMiB9KS50b0Zvcm1hdChcImQgc1wiLCB7IHNpZ25Nb2RlOiBcIm5lZ2F0aXZlTGFyZ2VzdE9ubHlcIiB9KSAvLz0+IFwiLTYgMlwiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgLy8gcmV2ZXJzZS1jb21wYXQgc2luY2UgMS4yOyB3ZSBhbHdheXMgcm91bmQgZG93biBub3csIG5ldmVyIHVwLCBhbmQgd2UgZG8gaXQgYnkgZGVmYXVsdFxuICAgIGNvbnN0IGZtdE9wdHMgPSB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgZmxvb3I6IG9wdHMucm91bmQgIT09IGZhbHNlICYmIG9wdHMuZmxvb3IgIT09IGZhbHNlLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLCBmbXRPcHRzKS5mb3JtYXREdXJhdGlvbkZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBEdXJhdGlvbiB3aXRoIGFsbCB1bml0cyBpbmNsdWRlZC5cbiAgICogVG8gbW9kaWZ5IGl0cyBiZWhhdmlvciwgdXNlIGBsaXN0U3R5bGVgIGFuZCBhbnkgSW50bC5OdW1iZXJGb3JtYXQgb3B0aW9uLCB0aG91Z2ggYHVuaXREaXNwbGF5YCBpcyBlc3BlY2lhbGx5IHJlbGV2YW50LlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvTnVtYmVyRm9ybWF0L051bWJlckZvcm1hdCNvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gRm9ybWF0dGluZyBvcHRpb25zLiBBY2NlcHRzIHRoZSBzYW1lIGtleXMgYXMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIHRoZSBuYXRpdmUgYEludGwuTnVtYmVyRm9ybWF0YCBjb25zdHJ1Y3RvciwgYXMgd2VsbCBhcyBgbGlzdFN0eWxlYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxpc3RTdHlsZT0nbmFycm93J10gLSBIb3cgdG8gZm9ybWF0IHRoZSBtZXJnZWQgbGlzdC4gQ29ycmVzcG9uZHMgdG8gdGhlIGBzdHlsZWAgcHJvcGVydHkgb2YgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIHRoZSBuYXRpdmUgYEludGwuTGlzdEZvcm1hdGAgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2hvd1plcm9zPXRydWVdIC0gU2hvdyBhbGwgdW5pdHMgcHJldmlvdXNseSB1c2VkIGJ5IHRoZSBkdXJhdGlvbiBldmVuIGlmIHRoZXkgYXJlIHplcm9cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEsIHdlZWtzOiAwLCBob3VyczogNSwgbWludXRlczogNiB9KVxuICAgKiBkdXIudG9IdW1hbigpIC8vPT4gJzEgbW9udGgsIDAgd2Vla3MsIDUgaG91cnMsIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyBsaXN0U3R5bGU6IFwibG9uZ1wiIH0pIC8vPT4gJzEgbW9udGgsIDAgd2Vla3MsIDUgaG91cnMsIGFuZCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgdW5pdERpc3BsYXk6IFwic2hvcnRcIiB9KSAvLz0+ICcxIG10aCwgMCB3a3MsIDUgaHIsIDYgbWluJ1xuICAgKiBkdXIudG9IdW1hbih7IHNob3daZXJvczogZmFsc2UgfSkgLy89PiAnMSBtb250aCwgNSBob3VycywgNiBtaW51dGVzJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvSHVtYW4ob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuXG4gICAgY29uc3Qgc2hvd1plcm9zID0gb3B0cy5zaG93WmVyb3MgIT09IGZhbHNlO1xuXG4gICAgY29uc3QgbCA9IG9yZGVyZWRVbml0c1xuICAgICAgLm1hcCgodW5pdCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlc1t1bml0XTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbCkgfHwgKHZhbCA9PT0gMCAmJiAhc2hvd1plcm9zKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgICAgIC5udW1iZXJGb3JtYXR0ZXIoeyBzdHlsZTogXCJ1bml0XCIsIHVuaXREaXNwbGF5OiBcImxvbmdcIiwgLi4ub3B0cywgdW5pdDogdW5pdC5zbGljZSgwLCAtMSkgfSlcbiAgICAgICAgICAuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigobikgPT4gbik7XG5cbiAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgIC5saXN0Rm9ybWF0dGVyKHsgdHlwZTogXCJjb25qdW5jdGlvblwiLCBzdHlsZTogb3B0cy5saXN0U3R5bGUgfHwgXCJuYXJyb3dcIiwgLi4ub3B0cyB9KVxuICAgICAgLmZvcm1hdChsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIER1cmF0aW9uJ3MgdmFsdWVzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7IC4uLnRoaXMudmFsdWVzIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMywgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQM1lUNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA0LCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1A0TVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDUgfSkudG9JU08oKSAvLz0+ICdQNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiA1IH0pLnRvSVNPKCkgLy89PiAnUFQ1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogNiB9KS50b0lTTygpIC8vPT4gJ1BUMC4wMDZTJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTygpIHtcbiAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGZvcm1hdHRlciwgYnV0IHRoaXMgaXMgYW4gZWFzaWVyIHdheSB0byBnZXQgdGhlIG1pbmltdW0gc3RyaW5nXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgbGV0IHMgPSBcIlBcIjtcbiAgICBpZiAodGhpcy55ZWFycyAhPT0gMCkgcyArPSB0aGlzLnllYXJzICsgXCJZXCI7XG4gICAgaWYgKHRoaXMubW9udGhzICE9PSAwIHx8IHRoaXMucXVhcnRlcnMgIT09IDApIHMgKz0gdGhpcy5tb250aHMgKyB0aGlzLnF1YXJ0ZXJzICogMyArIFwiTVwiO1xuICAgIGlmICh0aGlzLndlZWtzICE9PSAwKSBzICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICBpZiAodGhpcy5kYXlzICE9PSAwKSBzICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwIHx8IHRoaXMubWludXRlcyAhPT0gMCB8fCB0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICBzICs9IFwiVFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwKSBzICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICBpZiAodGhpcy5taW51dGVzICE9PSAwKSBzICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgIGlmICh0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICAvLyB0aGlzIHdpbGwgaGFuZGxlIFwiZmxvYXRpbmcgcG9pbnQgbWFkbmVzc1wiIGJ5IHJlbW92aW5nIGV4dHJhIGRlY2ltYWwgcGxhY2VzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODgwMDQvaXMtZmxvYXRpbmctcG9pbnQtbWF0aC1icm9rZW5cbiAgICAgIHMgKz0gcm91bmRUbyh0aGlzLnNlY29uZHMgKyB0aGlzLm1pbGxpc2Vjb25kcyAvIDEwMDAsIDMpICsgXCJTXCI7XG4gICAgaWYgKHMgPT09IFwiUFwiKSBzICs9IFwiVDBTXCI7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24sIGZvcm1hdHRlZCBhcyBhIHRpbWUgb2YgZGF5LlxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBkdXJhdGlvbiBpcyBpbnZhbGlkLCBuZWdhdGl2ZSwgb3IgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDI0IGhvdXJzLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKCkgLy89PiAnMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzTWlsbGlzZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzExMDAwMC4wMDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBtaWxsaXMgPSB0aGlzLnRvTWlsbGlzKCk7XG4gICAgaWYgKG1pbGxpcyA8IDAgfHwgbWlsbGlzID49IDg2NDAwMDAwKSByZXR1cm4gbnVsbDtcblxuICAgIG9wdHMgPSB7XG4gICAgICBzdXBwcmVzc01pbGxpc2Vjb25kczogZmFsc2UsXG4gICAgICBzdXBwcmVzc1NlY29uZHM6IGZhbHNlLFxuICAgICAgaW5jbHVkZVByZWZpeDogZmFsc2UsXG4gICAgICBmb3JtYXQ6IFwiZXh0ZW5kZWRcIixcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0OiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3QgZGF0ZVRpbWUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKG1pbGxpcywgeyB6b25lOiBcIlVUQ1wiIH0pO1xuICAgIHJldHVybiBkYXRlVGltZS50b0lTT1RpbWUob3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgRHVyYXRpb24geyB2YWx1ZXM6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBEdXJhdGlvbiB7IEludmFsaWQsIHJlYXNvbjogJHt0aGlzLmludmFsaWRSZWFzb259IH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcblxuICAgIHJldHVybiBkdXJhdGlvblRvTWlsbGlzKHRoaXMubWF0cml4LCB0aGlzLnZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIGxvbmdlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShkdXIudmFsdWVzLCBrKSB8fCBoYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlcywgaykpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZHVyLmdldChrKSArIHRoaXMuZ2V0KGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhpcyBEdXJhdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdW5pdC4gQXJpdHkgaXMgMSBvciAyOiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgYW5kLCBvcHRpb25hbGx5LCB0aGUgdW5pdCBuYW1lLiBNdXN0IHJldHVybiBhIG51bWJlci5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cyh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cygoeCwgdSkgPT4gdSA9PT0gXCJob3Vyc1wiID8geCAqIDIgOiB4KSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtYXBVbml0cyhmbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICByZXN1bHRba10gPSBhc051bWJlcihmbih0aGlzLnZhbHVlc1trXSwgaykpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ3llYXJzJykgLy89PiAyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdtb250aHMnKSAvLz0+IDBcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ2RheXMnKSAvLz0+IDNcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1tEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyB5ZWFyczogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgaG91cnM6IDgsIG1pbnV0ZXM6IDMwIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG1peGVkID0geyAuLi50aGlzLnZhbHVlcywgLi4ubm9ybWFsaXplT2JqZWN0KHZhbHVlcywgRHVyYXRpb24ubm9ybWFsaXplVW5pdCkgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG1peGVkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSBhbmQvb3IgbnVtYmVyaW5nU3lzdGVtLiAgUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBkdXIucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjb252ZXJzaW9uQWNjdXJhY3ksIG1hdHJpeCB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtIH0pO1xuICAgIGNvbnN0IG9wdHMgPSB7IGxvYywgbWF0cml4LCBjb252ZXJzaW9uQWNjdXJhY3kgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGR1cmF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlcycgb3IgJ2RheXMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ2RheXMnKSAvLz0+IDM2NVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdtb250aHMnKSAvLz0+IDEyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe2hvdXJzOiA2MH0pLmFzKCdkYXlzJykgLy89PiAyLjVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYXModW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnNoaWZ0VG8odW5pdCkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEFzc3VtaW5nIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBEdXJhdGlvbiBpcyBwb3NpdGl2ZSwgdGhpcyBtZWFuczpcbiAgICogLSBleGNlc3NpdmUgdmFsdWVzIGZvciBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmaXJzdCBhbmQgc2Vjb25kIGV4YW1wbGUpXG4gICAqIC0gbmVnYXRpdmUgbG93ZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBoaWdoZXIgb3JkZXIgdW5pdHMgKHRoZXJlIG11c3QgYmUgc3VjaCBhIGhpZ2hlciBvcmRlciB1bml0LCBvdGhlcndpc2VcbiAgICogICB0aGUgb3ZlcmFsbCB2YWx1ZSB3b3VsZCBiZSBuZWdhdGl2ZSwgc2VlIHRoaXJkIGV4YW1wbGUpXG4gICAqIC0gZnJhY3Rpb25hbCB2YWx1ZXMgZm9yIGhpZ2hlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGxvd2VyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZvdXJ0aCBleGFtcGxlKVxuICAgKlxuICAgKiBJZiB0aGUgb3ZlcmFsbCB2YWx1ZSBpcyBuZWdhdGl2ZSwgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGB0aGlzLm5lZ2F0ZSgpLm5vcm1hbGl6ZSgpLm5lZ2F0ZSgpYC5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxNSwgZGF5czogMjU1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDUwMDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgZGF5czogNTAwMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLjUsIGRheXM6IDAsIGhvdXJzOiAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbm9ybWFsaXplKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIG5vcm1hbGl6ZVZhbHVlcyh0aGlzLm1hdHJpeCwgdmFscyk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2NhbGUgdW5pdHMgdG8gaXRzIGxhcmdlc3QgcmVwcmVzZW50YXRpb25cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogOTAwMDAgfSkucmVzY2FsZSgpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDEsIHNlY29uZHM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZXNjYWxlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gcmVtb3ZlWmVyb2VzKHRoaXMubm9ybWFsaXplKCkuc2hpZnRUb0FsbCgpLnRvT2JqZWN0KCkpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoaXMgRHVyYXRpb24gaW50byBpdHMgcmVwcmVzZW50YXRpb24gaW4gYSBkaWZmZXJlbnQgc2V0IG9mIHVuaXRzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLnNoaWZ0VG8oJ21pbnV0ZXMnLCAnbWlsbGlzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogNjAsIG1pbGxpc2Vjb25kczogMzAwMDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG8oLi4udW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcCgodSkgPT4gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1KSk7XG5cbiAgICBjb25zdCBidWlsdCA9IHt9LFxuICAgICAgYWNjdW11bGF0ZWQgPSB7fSxcbiAgICAgIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbGV0IGxhc3RVbml0O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKHVuaXRzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICBsYXN0VW5pdCA9IGs7XG5cbiAgICAgICAgbGV0IG93biA9IDA7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgd2UgaGF2ZW4ndCBib2lsZWQgZG93biB5ZXQgc2hvdWxkIGdldCBib2lsZWQgdG8gdGhpcyB1bml0XG4gICAgICAgIGZvciAoY29uc3QgYWsgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgICAgICBvd24gKz0gdGhpcy5tYXRyaXhbYWtdW2tdICogYWNjdW11bGF0ZWRbYWtdO1xuICAgICAgICAgIGFjY3VtdWxhdGVkW2FrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwbHVzIGFueXRoaW5nIHRoYXQncyBhbHJlYWR5IGluIHRoaXMgdW5pdFxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgICBvd24gKz0gdmFsc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkga2VlcCB0aGUgaW50ZWdlciBwYXJ0IGZvciBub3cgaW4gdGhlIGhvcGVzIG9mIHB1dHRpbmcgYW55IGRlY2ltYWwgcGFydFxuICAgICAgICAvLyBpbnRvIGEgc21hbGxlciB1bml0IGxhdGVyXG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLnRydW5jKG93bik7XG4gICAgICAgIGJ1aWx0W2tdID0gaTtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSAob3duICogMTAwMCAtIGkgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBrZWVwIGl0IGluIHRoZSB3aW5ncyB0byBib2lsIGl0IGxhdGVyXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBsZWZ0b3ZlciBiZWNvbWVzIHRoZSBkZWNpbWFsIGZvciB0aGUgbGFzdCB1bml0XG4gICAgLy8gbGFzdFVuaXQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIHVuaXRzIGlzIG5vdCBlbXB0eVxuICAgIGZvciAoY29uc3Qga2V5IGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICBpZiAoYWNjdW11bGF0ZWRba2V5XSAhPT0gMCkge1xuICAgICAgICBidWlsdFtsYXN0VW5pdF0gKz1cbiAgICAgICAgICBrZXkgPT09IGxhc3RVbml0ID8gYWNjdW11bGF0ZWRba2V5XSA6IGFjY3VtdWxhdGVkW2tleV0gLyB0aGlzLm1hdHJpeFtsYXN0VW5pdF1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIGJ1aWx0KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IGJ1aWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaWZ0IHRoaXMgRHVyYXRpb24gdG8gYWxsIGF2YWlsYWJsZSB1bml0cy5cbiAgICogU2FtZSBhcyBzaGlmdFRvKFwieWVhcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUb0FsbCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnRUbyhcbiAgICAgIFwieWVhcnNcIixcbiAgICAgIFwibW9udGhzXCIsXG4gICAgICBcIndlZWtzXCIsXG4gICAgICBcImRheXNcIixcbiAgICAgIFwiaG91cnNcIixcbiAgICAgIFwibWludXRlc1wiLFxuICAgICAgXCJzZWNvbmRzXCIsXG4gICAgICBcIm1pbGxpc2Vjb25kc1wiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkubmVnYXRlKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IC0xLCBzZWNvbmRzOiAtMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmVnYXRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIG5lZ2F0ZWRba10gPSB0aGlzLnZhbHVlc1trXSA9PT0gMCA/IDAgOiAtdGhpcy52YWx1ZXNba107XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbmVnYXRlZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB1bml0cyB3aXRoIHZhbHVlcyBlcXVhbCB0byAwIGZyb20gdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiAwLCBob3VyczogMCwgbWludXRlczogMCB9KS5yZW1vdmVaZXJvcygpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAyIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZW1vdmVaZXJvcygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHJlbW92ZVplcm9lcyh0aGlzLnZhbHVlcyk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnllYXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMucXVhcnRlcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRocy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1vbnRocyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMud2Vla3MgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuZGF5cyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91cnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmhvdXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGVzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbnV0ZXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5zZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbGxpc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRHVyYXRpb24gaXMgaW52YWxpZC4gSW52YWxpZCBkdXJhdGlvbnMgYXJlIHJldHVybmVkIGJ5IGRpZmYgb3BlcmF0aW9uc1xuICAgKiBvbiBpbnZhbGlkIERhdGVUaW1lcyBvciBJbnRlcnZhbHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIER1cmF0aW9ucyBhcmUgZXF1YWwgaWZmIHRoZXkgaGF2ZSB0aGUgc2FtZSB1bml0cyBhbmQgdGhlIHNhbWUgdmFsdWVzIGZvciBlYWNoIHVuaXQuXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcSh2MSwgdjIpIHtcbiAgICAgIC8vIENvbnNpZGVyIDAgYW5kIHVuZGVmaW5lZCBhcyBlcXVhbFxuICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgfHwgdjEgPT09IDApIHJldHVybiB2MiA9PT0gdW5kZWZpbmVkIHx8IHYyID09PSAwO1xuICAgICAgcmV0dXJuIHYxID09PSB2MjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoIWVxKHRoaXMudmFsdWVzW3VdLCBvdGhlci52YWx1ZXNbdV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/duration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js":
/*!******************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingSpecificationError: () => (/* binding */ ConflictingSpecificationError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDateTimeError: () => (/* binding */ InvalidDateTimeError),\n/* harmony export */   InvalidDurationError: () => (/* binding */ InvalidDurationError),\n/* harmony export */   InvalidIntervalError: () => (/* binding */ InvalidIntervalError),\n/* harmony export */   InvalidUnitError: () => (/* binding */ InvalidUnitError),\n/* harmony export */   ZoneIsAbstractError: () => (/* binding */ ZoneIsAbstractError)\n/* harmony export */ });\n// these aren't really private, but nor are they really useful to document\n\n/**\n * @private\n */\nclass LuxonError extends Error {}\n\n/**\n * @private\n */\nclass InvalidDateTimeError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid DateTime: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidIntervalError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Interval: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidDurationError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Duration: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass ConflictingSpecificationError extends LuxonError {}\n\n/**\n * @private\n */\nclass InvalidUnitError extends LuxonError {\n  constructor(unit) {\n    super(`Invalid unit ${unit}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidArgumentError extends LuxonError {}\n\n/**\n * @private\n */\nclass ZoneIsAbstractError extends LuxonError {\n  constructor() {\n    super(\"Zone is an abstract class\");\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhlc2UgYXJlbid0IHJlYWxseSBwcml2YXRlLCBidXQgbm9yIGFyZSB0aGV5IHJlYWxseSB1c2VmdWwgdG8gZG9jdW1lbnRcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBMdXhvbkVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGVUaW1lRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRGF0ZVRpbWU6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnRlcnZhbEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIEludGVydmFsOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRHVyYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEdXJhdGlvbjogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRVbml0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IodW5pdCkge1xuICAgIHN1cGVyKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBab25lSXNBYnN0cmFjdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiWm9uZSBpcyBhbiBhYnN0cmFjdCBjbGFzc1wiKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/conversions.js":
/*!****************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/conversions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dayOfWeek: () => (/* binding */ dayOfWeek),\n/* harmony export */   gregorianToOrdinal: () => (/* binding */ gregorianToOrdinal),\n/* harmony export */   gregorianToWeek: () => (/* binding */ gregorianToWeek),\n/* harmony export */   hasInvalidGregorianData: () => (/* binding */ hasInvalidGregorianData),\n/* harmony export */   hasInvalidOrdinalData: () => (/* binding */ hasInvalidOrdinalData),\n/* harmony export */   hasInvalidTimeData: () => (/* binding */ hasInvalidTimeData),\n/* harmony export */   hasInvalidWeekData: () => (/* binding */ hasInvalidWeekData),\n/* harmony export */   isoWeekdayToLocal: () => (/* binding */ isoWeekdayToLocal),\n/* harmony export */   ordinalToGregorian: () => (/* binding */ ordinalToGregorian),\n/* harmony export */   usesLocalWeekValues: () => (/* binding */ usesLocalWeekValues),\n/* harmony export */   weekToGregorian: () => (/* binding */ weekToGregorian)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _invalid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invalid.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\");\n\n\n\n\nconst nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n\nfunction unitOutOfRange(unit, value) {\n  return new _invalid_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n    \"unit out of range\",\n    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`\n  );\n}\n\nfunction dayOfWeek(year, month, day) {\n  const d = new Date(Date.UTC(year, month - 1, day));\n\n  if (year < 100 && year >= 0) {\n    d.setUTCFullYear(d.getUTCFullYear() - 1900);\n  }\n\n  const js = d.getUTCDay();\n\n  return js === 0 ? 7 : js;\n}\n\nfunction computeOrdinal(year, month, day) {\n  return day + ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder)[month - 1];\n}\n\nfunction uncomputeOrdinal(year, ordinal) {\n  const table = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder,\n    month0 = table.findIndex((i) => i < ordinal),\n    day = ordinal - table[month0];\n  return { month: month0 + 1, day };\n}\n\nfunction isoWeekdayToLocal(isoWeekday, startOfWeek) {\n  return ((isoWeekday - startOfWeek + 7) % 7) + 1;\n}\n\n/**\n * @private\n */\n\nfunction gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { year, month, day } = gregObj,\n    ordinal = computeOrdinal(year, month, day),\n    weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);\n\n  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7),\n    weekYear;\n\n  if (weekNumber < 1) {\n    weekYear = year - 1;\n    weekNumber = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(weekYear, minDaysInFirstWeek, startOfWeek);\n  } else if (weekNumber > (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(year, minDaysInFirstWeek, startOfWeek)) {\n    weekYear = year + 1;\n    weekNumber = 1;\n  } else {\n    weekYear = year;\n  }\n\n  return { weekYear, weekNumber, weekday, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregObj) };\n}\n\nfunction weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { weekYear, weekNumber, weekday } = weekData,\n    weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek),\n    yearInDays = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n\n  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek,\n    year;\n\n  if (ordinal < 1) {\n    year = weekYear - 1;\n    ordinal += (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(year);\n  } else if (ordinal > yearInDays) {\n    year = weekYear + 1;\n    ordinal -= (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n  } else {\n    year = weekYear;\n  }\n\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(weekData) };\n}\n\nfunction gregorianToOrdinal(gregData) {\n  const { year, month, day } = gregData;\n  const ordinal = computeOrdinal(year, month, day);\n  return { year, ordinal, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregData) };\n}\n\nfunction ordinalToGregorian(ordinalData) {\n  const { year, ordinal } = ordinalData;\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(ordinalData) };\n}\n\n/**\n * Check if local week units like localWeekday are used in obj.\n * If so, validates that they are not mixed with ISO week units and then copies them to the normal week unit properties.\n * Modifies obj in-place!\n * @param obj the object values\n */\nfunction usesLocalWeekValues(obj, loc) {\n  const hasLocaleWeekData =\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear);\n  if (hasLocaleWeekData) {\n    const hasIsoWeekData =\n      !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekday) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekNumber) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekYear);\n\n    if (hasIsoWeekData) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingSpecificationError(\n        \"Cannot mix locale-based week fields with ISO-based week fields\"\n      );\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday)) obj.weekday = obj.localWeekday;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;\n    delete obj.localWeekday;\n    delete obj.localWeekNumber;\n    delete obj.localWeekYear;\n    return {\n      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),\n      startOfWeek: loc.getStartOfWeek(),\n    };\n  } else {\n    return { minDaysInFirstWeek: 4, startOfWeek: 1 };\n  }\n}\n\nfunction hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.weekYear),\n    validWeek = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(\n      obj.weekNumber,\n      1,\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(obj.weekYear, minDaysInFirstWeek, startOfWeek)\n    ),\n    validWeekday = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.weekday, 1, 7);\n\n  if (!validYear) {\n    return unitOutOfRange(\"weekYear\", obj.weekYear);\n  } else if (!validWeek) {\n    return unitOutOfRange(\"week\", obj.weekNumber);\n  } else if (!validWeekday) {\n    return unitOutOfRange(\"weekday\", obj.weekday);\n  } else return false;\n}\n\nfunction hasInvalidOrdinalData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validOrdinal = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.ordinal, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(obj.year));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validOrdinal) {\n    return unitOutOfRange(\"ordinal\", obj.ordinal);\n  } else return false;\n}\n\nfunction hasInvalidGregorianData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validMonth = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.month, 1, 12),\n    validDay = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.day, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInMonth)(obj.year, obj.month));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validMonth) {\n    return unitOutOfRange(\"month\", obj.month);\n  } else if (!validDay) {\n    return unitOutOfRange(\"day\", obj.day);\n  } else return false;\n}\n\nfunction hasInvalidTimeData(obj) {\n  const { hour, minute, second, millisecond } = obj;\n  const validHour =\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(hour, 0, 23) ||\n      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),\n    validMinute = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(minute, 0, 59),\n    validSecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(second, 0, 59),\n    validMillisecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(millisecond, 0, 999);\n\n  if (!validHour) {\n    return unitOutOfRange(\"hour\", hour);\n  } else if (!validMinute) {\n    return unitOutOfRange(\"minute\", minute);\n  } else if (!validSecond) {\n    return unitOutOfRange(\"second\", second);\n  } else if (!validMillisecond) {\n    return unitOutOfRange(\"millisecond\", millisecond);\n  } else return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9jb252ZXJzaW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQVNtQjtBQUNnQjtBQUMwQjs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbURBQU87QUFDcEI7QUFDQSxxQkFBcUIsT0FBTyxXQUFXLGFBQWEsU0FBUyxLQUFLO0FBQ2xFO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixvREFBVTtBQUMxQjs7QUFFQTtBQUNBLGdCQUFnQixvREFBVTtBQUMxQjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix5REFBZTtBQUNoQyxJQUFJLHNCQUFzQix5REFBZTtBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsV0FBVyxrQ0FBa0Msb0RBQVU7QUFDdkQ7O0FBRU87QUFDUCxVQUFVLGdDQUFnQztBQUMxQztBQUNBLGlCQUFpQixvREFBVTs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvREFBVTtBQUN6QixJQUFJO0FBQ0o7QUFDQSxlQUFlLG9EQUFVO0FBQ3pCLElBQUk7QUFDSjtBQUNBOztBQUVBLFVBQVUsYUFBYTtBQUN2QixXQUFXLHFCQUFxQixvREFBVTtBQUMxQzs7QUFFTztBQUNQLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0EsV0FBVyxrQkFBa0Isb0RBQVU7QUFDdkM7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQixVQUFVLGFBQWE7QUFDdkIsV0FBVyxxQkFBcUIsb0RBQVU7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLEtBQUsscURBQVc7QUFDaEIsS0FBSyxxREFBVztBQUNoQixLQUFLLHFEQUFXO0FBQ2hCO0FBQ0E7QUFDQSxPQUFPLHFEQUFXLGtCQUFrQixxREFBVyxxQkFBcUIscURBQVc7O0FBRS9FO0FBQ0EsZ0JBQWdCLHFFQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFXO0FBQ3BCLFNBQVMscURBQVc7QUFDcEIsU0FBUyxxREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFTztBQUNQLG9CQUFvQixtREFBUztBQUM3QixnQkFBZ0Isd0RBQWM7QUFDOUI7QUFDQTtBQUNBLE1BQU0seURBQWU7QUFDckI7QUFDQSxtQkFBbUIsd0RBQWM7O0FBRWpDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRU87QUFDUCxvQkFBb0IsbURBQVM7QUFDN0IsbUJBQW1CLHdEQUFjLGlCQUFpQixvREFBVTs7QUFFNUQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFTztBQUNQLG9CQUFvQixtREFBUztBQUM3QixpQkFBaUIsd0RBQWM7QUFDL0IsZUFBZSx3REFBYyxhQUFhLHFEQUFXOztBQUVyRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVPO0FBQ1AsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQSxNQUFNLHdEQUFjO0FBQ3BCO0FBQ0Esa0JBQWtCLHdEQUFjO0FBQ2hDLGtCQUFrQix3REFBYztBQUNoQyx1QkFBdUIsd0RBQWM7O0FBRXJDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaW50ZWdlckJldHdlZW4sXG4gIGlzTGVhcFllYXIsXG4gIHRpbWVPYmplY3QsXG4gIGRheXNJblllYXIsXG4gIGRheXNJbk1vbnRoLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIGlzSW50ZWdlcixcbiAgaXNVbmRlZmluZWQsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ludmFsaWQuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgbGVhcExhZGRlciA9IFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNV07XG5cbmZ1bmN0aW9uIHVuaXRPdXRPZlJhbmdlKHVuaXQsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcbiAgICBcInVuaXQgb3V0IG9mIHJhbmdlXCIsXG4gICAgYHlvdSBzcGVjaWZpZWQgJHt2YWx1ZX0gKG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9KSBhcyBhICR7dW5pdH0sIHdoaWNoIGlzIGludmFsaWRgXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICBjb25zdCBkID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXkpKTtcblxuICBpZiAoeWVhciA8IDEwMCAmJiB5ZWFyID49IDApIHtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG5cbiAgY29uc3QganMgPSBkLmdldFVUQ0RheSgpO1xuXG4gIHJldHVybiBqcyA9PT0gMCA/IDcgOiBqcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSkge1xuICByZXR1cm4gZGF5ICsgKGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcilbbW9udGggLSAxXTtcbn1cblxuZnVuY3Rpb24gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKSB7XG4gIGNvbnN0IHRhYmxlID0gaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyLFxuICAgIG1vbnRoMCA9IHRhYmxlLmZpbmRJbmRleCgoaSkgPT4gaSA8IG9yZGluYWwpLFxuICAgIGRheSA9IG9yZGluYWwgLSB0YWJsZVttb250aDBdO1xuICByZXR1cm4geyBtb250aDogbW9udGgwICsgMSwgZGF5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc29XZWVrZGF5VG9Mb2NhbChpc29XZWVrZGF5LCBzdGFydE9mV2Vlaykge1xuICByZXR1cm4gKChpc29XZWVrZGF5IC0gc3RhcnRPZldlZWsgKyA3KSAlIDcpICsgMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub1dlZWsoZ3JlZ09iaiwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ09iaixcbiAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgd2Vla2RheSA9IGlzb1dlZWtkYXlUb0xvY2FsKGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSwgc3RhcnRPZldlZWspO1xuXG4gIGxldCB3ZWVrTnVtYmVyID0gTWF0aC5mbG9vcigob3JkaW5hbCAtIHdlZWtkYXkgKyAxNCAtIG1pbkRheXNJbkZpcnN0V2VlaykgLyA3KSxcbiAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaykpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5LCAuLi50aW1lT2JqZWN0KGdyZWdPYmopIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrVG9HcmVnb3JpYW4od2Vla0RhdGEsIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5IH0gPSB3ZWVrRGF0YSxcbiAgICB3ZWVrZGF5T2ZKYW40ID0gaXNvV2Vla2RheVRvTG9jYWwoZGF5T2ZXZWVrKHdlZWtZZWFyLCAxLCBtaW5EYXlzSW5GaXJzdFdlZWspLCBzdGFydE9mV2VlayksXG4gICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuXG4gIGxldCBvcmRpbmFsID0gd2Vla051bWJlciAqIDcgKyB3ZWVrZGF5IC0gd2Vla2RheU9mSmFuNCAtIDcgKyBtaW5EYXlzSW5GaXJzdFdlZWssXG4gICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qod2Vla0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub09yZGluYWwoZ3JlZ0RhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnRGF0YTtcbiAgY29uc3Qgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpO1xuICByZXR1cm4geyB5ZWFyLCBvcmRpbmFsLCAuLi50aW1lT2JqZWN0KGdyZWdEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgb3JkaW5hbCB9ID0gb3JkaW5hbERhdGE7XG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdChvcmRpbmFsRGF0YSkgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsb2NhbCB3ZWVrIHVuaXRzIGxpa2UgbG9jYWxXZWVrZGF5IGFyZSB1c2VkIGluIG9iai5cbiAqIElmIHNvLCB2YWxpZGF0ZXMgdGhhdCB0aGV5IGFyZSBub3QgbWl4ZWQgd2l0aCBJU08gd2VlayB1bml0cyBhbmQgdGhlbiBjb3BpZXMgdGhlbSB0byB0aGUgbm9ybWFsIHdlZWsgdW5pdCBwcm9wZXJ0aWVzLlxuICogTW9kaWZpZXMgb2JqIGluLXBsYWNlIVxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlc0xvY2FsV2Vla1ZhbHVlcyhvYmosIGxvYykge1xuICBjb25zdCBoYXNMb2NhbGVXZWVrRGF0YSA9XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtkYXkpIHx8XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtOdW1iZXIpIHx8XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtZZWFyKTtcbiAgaWYgKGhhc0xvY2FsZVdlZWtEYXRhKSB7XG4gICAgY29uc3QgaGFzSXNvV2Vla0RhdGEgPVxuICAgICAgIWlzVW5kZWZpbmVkKG9iai53ZWVrZGF5KSB8fCAhaXNVbmRlZmluZWQob2JqLndlZWtOdW1iZXIpIHx8ICFpc1VuZGVmaW5lZChvYmoud2Vla1llYXIpO1xuXG4gICAgaWYgKGhhc0lzb1dlZWtEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IG1peCBsb2NhbGUtYmFzZWQgd2VlayBmaWVsZHMgd2l0aCBJU08tYmFzZWQgd2VlayBmaWVsZHNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrZGF5KSkgb2JqLndlZWtkYXkgPSBvYmoubG9jYWxXZWVrZGF5O1xuICAgIGlmICghaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla051bWJlcikpIG9iai53ZWVrTnVtYmVyID0gb2JqLmxvY2FsV2Vla051bWJlcjtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtZZWFyKSkgb2JqLndlZWtZZWFyID0gb2JqLmxvY2FsV2Vla1llYXI7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtkYXk7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtOdW1iZXI7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtZZWFyO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5EYXlzSW5GaXJzdFdlZWs6IGxvYy5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSxcbiAgICAgIHN0YXJ0T2ZXZWVrOiBsb2MuZ2V0U3RhcnRPZldlZWsoKSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IG1pbkRheXNJbkZpcnN0V2VlazogNCwgc3RhcnRPZldlZWs6IDEgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaiwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKFxuICAgICAgb2JqLndlZWtOdW1iZXIsXG4gICAgICAxLFxuICAgICAgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICApLFxuICAgIHZhbGlkV2Vla2RheSA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrZGF5LCAxLCA3KTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtZZWFyXCIsIG9iai53ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vlaykge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtcIiwgb2JqLndlZWtOdW1iZXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWtkYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrZGF5XCIsIG9iai53ZWVrZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRPcmRpbmFsRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE9yZGluYWwgPSBpbnRlZ2VyQmV0d2VlbihvYmoub3JkaW5hbCwgMSwgZGF5c0luWWVhcihvYmoueWVhcikpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkT3JkaW5hbCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm9yZGluYWxcIiwgb2JqLm9yZGluYWwpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRNb250aCA9IGludGVnZXJCZXR3ZWVuKG9iai5tb250aCwgMSwgMTIpLFxuICAgIHZhbGlkRGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLmRheSwgMSwgZGF5c0luTW9udGgob2JqLnllYXIsIG9iai5tb250aCkpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTW9udGgpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtb250aFwiLCBvYmoubW9udGgpO1xuICB9IGVsc2UgaWYgKCF2YWxpZERheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImRheVwiLCBvYmouZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRUaW1lRGF0YShvYmopIHtcbiAgY29uc3QgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSA9IG9iajtcbiAgY29uc3QgdmFsaWRIb3VyID1cbiAgICAgIGludGVnZXJCZXR3ZWVuKGhvdXIsIDAsIDIzKSB8fFxuICAgICAgKGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDApLFxuICAgIHZhbGlkTWludXRlID0gaW50ZWdlckJldHdlZW4obWludXRlLCAwLCA1OSksXG4gICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICB2YWxpZE1pbGxpc2Vjb25kID0gaW50ZWdlckJldHdlZW4obWlsbGlzZWNvbmQsIDAsIDk5OSk7XG5cbiAgaWYgKCF2YWxpZEhvdXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJob3VyXCIsIGhvdXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbnV0ZSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbnV0ZVwiLCBtaW51dGUpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInNlY29uZFwiLCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbGxpc2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWlsbGlzZWNvbmRcIiwgbWlsbGlzZWNvbmQpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/conversions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/diff.js":
/*!*********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/diff.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../duration.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/duration.js\");\n\n\nfunction dayDiff(earlier, later) {\n  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf(\"day\").valueOf(),\n    ms = utcDayStart(later) - utcDayStart(earlier);\n  return Math.floor(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(ms).as(\"days\"));\n}\n\nfunction highOrderDiffs(cursor, later, units) {\n  const differs = [\n    [\"years\", (a, b) => b.year - a.year],\n    [\"quarters\", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],\n    [\"months\", (a, b) => b.month - a.month + (b.year - a.year) * 12],\n    [\n      \"weeks\",\n      (a, b) => {\n        const days = dayDiff(a, b);\n        return (days - (days % 7)) / 7;\n      },\n    ],\n    [\"days\", dayDiff],\n  ];\n\n  const results = {};\n  const earlier = cursor;\n  let lowestOrder, highWater;\n\n  /* This loop tries to diff using larger units first.\n     If we overshoot, we backtrack and try the next smaller unit.\n     \"cursor\" starts out at the earlier timestamp and moves closer and closer to \"later\"\n     as we use smaller and smaller units.\n     highWater keeps track of where we would be if we added one more of the smallest unit,\n     this is used later to potentially convert any difference smaller than the smallest higher order unit\n     into a fraction of that smallest higher order unit\n  */\n  for (const [unit, differ] of differs) {\n    if (units.indexOf(unit) >= 0) {\n      lowestOrder = unit;\n\n      results[unit] = differ(cursor, later);\n      highWater = earlier.plus(results);\n\n      if (highWater > later) {\n        // we overshot the end point, backtrack cursor by 1\n        results[unit]--;\n        cursor = earlier.plus(results);\n\n        // if we are still overshooting now, we need to backtrack again\n        // this happens in certain situations when diffing times in different zones,\n        // because this calculation ignores time zones\n        if (cursor > later) {\n          // keep the \"overshot by 1\" around as highWater\n          highWater = cursor;\n          // backtrack cursor by 1\n          results[unit]--;\n          cursor = earlier.plus(results);\n        }\n      } else {\n        cursor = highWater;\n      }\n    }\n  }\n\n  return [cursor, results, highWater, lowestOrder];\n}\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(earlier, later, units, opts) {\n  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);\n\n  const remainingMillis = later - cursor;\n\n  const lowerOrderUnits = units.filter(\n    (u) => [\"hours\", \"minutes\", \"seconds\", \"milliseconds\"].indexOf(u) >= 0\n  );\n\n  if (lowerOrderUnits.length === 0) {\n    if (highWater < later) {\n      highWater = cursor.plus({ [lowestOrder]: 1 });\n    }\n\n    if (highWater !== cursor) {\n      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);\n    }\n  }\n\n  const duration = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject(results, opts);\n\n  if (lowerOrderUnits.length > 0) {\n    return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(remainingMillis, opts)\n      .shiftTo(...lowerOrderUnits)\n      .plus(duration);\n  } else {\n    return duration;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDOztBQUV0QztBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQSxvQkFBb0Isb0RBQVE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBVTtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9EQUFROztBQUUzQjtBQUNBLFdBQVcsb0RBQVE7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4uL2R1cmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIGRheURpZmYoZWFybGllciwgbGF0ZXIpIHtcbiAgY29uc3QgdXRjRGF5U3RhcnQgPSAoZHQpID0+IGR0LnRvVVRDKDAsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KS5zdGFydE9mKFwiZGF5XCIpLnZhbHVlT2YoKSxcbiAgICBtcyA9IHV0Y0RheVN0YXJ0KGxhdGVyKSAtIHV0Y0RheVN0YXJ0KGVhcmxpZXIpO1xuICByZXR1cm4gTWF0aC5mbG9vcihEdXJhdGlvbi5mcm9tTWlsbGlzKG1zKS5hcyhcImRheXNcIikpO1xufVxuXG5mdW5jdGlvbiBoaWdoT3JkZXJEaWZmcyhjdXJzb3IsIGxhdGVyLCB1bml0cykge1xuICBjb25zdCBkaWZmZXJzID0gW1xuICAgIFtcInllYXJzXCIsIChhLCBiKSA9PiBiLnllYXIgLSBhLnllYXJdLFxuICAgIFtcInF1YXJ0ZXJzXCIsIChhLCBiKSA9PiBiLnF1YXJ0ZXIgLSBhLnF1YXJ0ZXIgKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDRdLFxuICAgIFtcIm1vbnRoc1wiLCAoYSwgYikgPT4gYi5tb250aCAtIGEubW9udGggKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDEyXSxcbiAgICBbXG4gICAgICBcIndlZWtzXCIsXG4gICAgICAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkYXlzID0gZGF5RGlmZihhLCBiKTtcbiAgICAgICAgcmV0dXJuIChkYXlzIC0gKGRheXMgJSA3KSkgLyA3O1xuICAgICAgfSxcbiAgICBdLFxuICAgIFtcImRheXNcIiwgZGF5RGlmZl0sXG4gIF07XG5cbiAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICBjb25zdCBlYXJsaWVyID0gY3Vyc29yO1xuICBsZXQgbG93ZXN0T3JkZXIsIGhpZ2hXYXRlcjtcblxuICAvKiBUaGlzIGxvb3AgdHJpZXMgdG8gZGlmZiB1c2luZyBsYXJnZXIgdW5pdHMgZmlyc3QuXG4gICAgIElmIHdlIG92ZXJzaG9vdCwgd2UgYmFja3RyYWNrIGFuZCB0cnkgdGhlIG5leHQgc21hbGxlciB1bml0LlxuICAgICBcImN1cnNvclwiIHN0YXJ0cyBvdXQgYXQgdGhlIGVhcmxpZXIgdGltZXN0YW1wIGFuZCBtb3ZlcyBjbG9zZXIgYW5kIGNsb3NlciB0byBcImxhdGVyXCJcbiAgICAgYXMgd2UgdXNlIHNtYWxsZXIgYW5kIHNtYWxsZXIgdW5pdHMuXG4gICAgIGhpZ2hXYXRlciBrZWVwcyB0cmFjayBvZiB3aGVyZSB3ZSB3b3VsZCBiZSBpZiB3ZSBhZGRlZCBvbmUgbW9yZSBvZiB0aGUgc21hbGxlc3QgdW5pdCxcbiAgICAgdGhpcyBpcyB1c2VkIGxhdGVyIHRvIHBvdGVudGlhbGx5IGNvbnZlcnQgYW55IGRpZmZlcmVuY2Ugc21hbGxlciB0aGFuIHRoZSBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICBpbnRvIGEgZnJhY3Rpb24gb2YgdGhhdCBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAqL1xuICBmb3IgKGNvbnN0IFt1bml0LCBkaWZmZXJdIG9mIGRpZmZlcnMpIHtcbiAgICBpZiAodW5pdHMuaW5kZXhPZih1bml0KSA+PSAwKSB7XG4gICAgICBsb3dlc3RPcmRlciA9IHVuaXQ7XG5cbiAgICAgIHJlc3VsdHNbdW5pdF0gPSBkaWZmZXIoY3Vyc29yLCBsYXRlcik7XG4gICAgICBoaWdoV2F0ZXIgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICAvLyB3ZSBvdmVyc2hvdCB0aGUgZW5kIHBvaW50LCBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIG92ZXJzaG9vdGluZyBub3csIHdlIG5lZWQgdG8gYmFja3RyYWNrIGFnYWluXG4gICAgICAgIC8vIHRoaXMgaGFwcGVucyBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgd2hlbiBkaWZmaW5nIHRpbWVzIGluIGRpZmZlcmVudCB6b25lcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGNhbGN1bGF0aW9uIGlnbm9yZXMgdGltZSB6b25lc1xuICAgICAgICBpZiAoY3Vyc29yID4gbGF0ZXIpIHtcbiAgICAgICAgICAvLyBrZWVwIHRoZSBcIm92ZXJzaG90IGJ5IDFcIiBhcm91bmQgYXMgaGlnaFdhdGVyXG4gICAgICAgICAgaGlnaFdhdGVyID0gY3Vyc29yO1xuICAgICAgICAgIC8vIGJhY2t0cmFjayBjdXJzb3IgYnkgMVxuICAgICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvciA9IGhpZ2hXYXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlYXJsaWVyLCBsYXRlciwgdW5pdHMsIG9wdHMpIHtcbiAgbGV0IFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdID0gaGlnaE9yZGVyRGlmZnMoZWFybGllciwgbGF0ZXIsIHVuaXRzKTtcblxuICBjb25zdCByZW1haW5pbmdNaWxsaXMgPSBsYXRlciAtIGN1cnNvcjtcblxuICBjb25zdCBsb3dlck9yZGVyVW5pdHMgPSB1bml0cy5maWx0ZXIoXG4gICAgKHUpID0+IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIl0uaW5kZXhPZih1KSA+PSAwXG4gICk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaGlnaFdhdGVyIDwgbGF0ZXIpIHtcbiAgICAgIGhpZ2hXYXRlciA9IGN1cnNvci5wbHVzKHsgW2xvd2VzdE9yZGVyXTogMSB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGlnaFdhdGVyICE9PSBjdXJzb3IpIHtcbiAgICAgIHJlc3VsdHNbbG93ZXN0T3JkZXJdID0gKHJlc3VsdHNbbG93ZXN0T3JkZXJdIHx8IDApICsgcmVtYWluaW5nTWlsbGlzIC8gKGhpZ2hXYXRlciAtIGN1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHJlc3VsdHMsIG9wdHMpO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKHJlbWFpbmluZ01pbGxpcywgb3B0cylcbiAgICAgIC5zaGlmdFRvKC4uLmxvd2VyT3JkZXJVbml0cylcbiAgICAgIC5wbHVzKGR1cmF0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/diff.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/digits.js":
/*!***********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/digits.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   digitRegex: () => (/* binding */ digitRegex),\n/* harmony export */   parseDigits: () => (/* binding */ parseDigits),\n/* harmony export */   resetDigitRegexCache: () => (/* binding */ resetDigitRegexCache)\n/* harmony export */ });\nconst numberingSystems = {\n  arab: \"[\\u0660-\\u0669]\",\n  arabext: \"[\\u06F0-\\u06F9]\",\n  bali: \"[\\u1B50-\\u1B59]\",\n  beng: \"[\\u09E6-\\u09EF]\",\n  deva: \"[\\u0966-\\u096F]\",\n  fullwide: \"[\\uFF10-\\uFF19]\",\n  gujr: \"[\\u0AE6-\\u0AEF]\",\n  hanidec: \"[|||||||||]\",\n  khmr: \"[\\u17E0-\\u17E9]\",\n  knda: \"[\\u0CE6-\\u0CEF]\",\n  laoo: \"[\\u0ED0-\\u0ED9]\",\n  limb: \"[\\u1946-\\u194F]\",\n  mlym: \"[\\u0D66-\\u0D6F]\",\n  mong: \"[\\u1810-\\u1819]\",\n  mymr: \"[\\u1040-\\u1049]\",\n  orya: \"[\\u0B66-\\u0B6F]\",\n  tamldec: \"[\\u0BE6-\\u0BEF]\",\n  telu: \"[\\u0C66-\\u0C6F]\",\n  thai: \"[\\u0E50-\\u0E59]\",\n  tibt: \"[\\u0F20-\\u0F29]\",\n  latn: \"\\\\d\",\n};\n\nconst numberingSystemsUTF16 = {\n  arab: [1632, 1641],\n  arabext: [1776, 1785],\n  bali: [6992, 7001],\n  beng: [2534, 2543],\n  deva: [2406, 2415],\n  fullwide: [65296, 65303],\n  gujr: [2790, 2799],\n  khmr: [6112, 6121],\n  knda: [3302, 3311],\n  laoo: [3792, 3801],\n  limb: [6470, 6479],\n  mlym: [3430, 3439],\n  mong: [6160, 6169],\n  mymr: [4160, 4169],\n  orya: [2918, 2927],\n  tamldec: [3046, 3055],\n  telu: [3174, 3183],\n  thai: [3664, 3673],\n  tibt: [3872, 3881],\n};\n\nconst hanidecChars = numberingSystems.hanidec.replace(/[\\[|\\]]/g, \"\").split(\"\");\n\nfunction parseDigits(str) {\n  let value = parseInt(str, 10);\n  if (isNaN(value)) {\n    value = \"\";\n    for (let i = 0; i < str.length; i++) {\n      const code = str.charCodeAt(i);\n\n      if (str[i].search(numberingSystems.hanidec) !== -1) {\n        value += hanidecChars.indexOf(str[i]);\n      } else {\n        for (const key in numberingSystemsUTF16) {\n          const [min, max] = numberingSystemsUTF16[key];\n          if (code >= min && code <= max) {\n            value += code - min;\n          }\n        }\n      }\n    }\n    return parseInt(value, 10);\n  } else {\n    return value;\n  }\n}\n\n// cache of {numberingSystem: {append: regex}}\nconst digitRegexCache = new Map();\nfunction resetDigitRegexCache() {\n  digitRegexCache.clear();\n}\n\nfunction digitRegex({ numberingSystem }, append = \"\") {\n  const ns = numberingSystem || \"latn\";\n\n  let appendCache = digitRegexCache.get(ns);\n  if (appendCache === undefined) {\n    appendCache = new Map();\n    digitRegexCache.set(ns, appendCache);\n  }\n  let regex = appendCache.get(append);\n  if (regex === undefined) {\n    regex = new RegExp(`${numberingSystems[ns]}${append}`);\n    appendCache.set(append, regex);\n  }\n\n  return regex;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWdpdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPO0FBQ1A7QUFDQTs7QUFFTyxzQkFBc0IsaUJBQWlCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQixFQUFFLE9BQU87QUFDeEQ7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBudW1iZXJpbmdTeXN0ZW1zID0ge1xuICBhcmFiOiBcIltcXHUwNjYwLVxcdTA2NjldXCIsXG4gIGFyYWJleHQ6IFwiW1xcdTA2RjAtXFx1MDZGOV1cIixcbiAgYmFsaTogXCJbXFx1MUI1MC1cXHUxQjU5XVwiLFxuICBiZW5nOiBcIltcXHUwOUU2LVxcdTA5RUZdXCIsXG4gIGRldmE6IFwiW1xcdTA5NjYtXFx1MDk2Rl1cIixcbiAgZnVsbHdpZGU6IFwiW1xcdUZGMTAtXFx1RkYxOV1cIixcbiAgZ3VqcjogXCJbXFx1MEFFNi1cXHUwQUVGXVwiLFxuICBoYW5pZGVjOiBcIlvjgId85LiAfOS6jHzkuIl85ZubfOS6lHzlha185LiDfOWFq3zkuZ1dXCIsXG4gIGtobXI6IFwiW1xcdTE3RTAtXFx1MTdFOV1cIixcbiAga25kYTogXCJbXFx1MENFNi1cXHUwQ0VGXVwiLFxuICBsYW9vOiBcIltcXHUwRUQwLVxcdTBFRDldXCIsXG4gIGxpbWI6IFwiW1xcdTE5NDYtXFx1MTk0Rl1cIixcbiAgbWx5bTogXCJbXFx1MEQ2Ni1cXHUwRDZGXVwiLFxuICBtb25nOiBcIltcXHUxODEwLVxcdTE4MTldXCIsXG4gIG15bXI6IFwiW1xcdTEwNDAtXFx1MTA0OV1cIixcbiAgb3J5YTogXCJbXFx1MEI2Ni1cXHUwQjZGXVwiLFxuICB0YW1sZGVjOiBcIltcXHUwQkU2LVxcdTBCRUZdXCIsXG4gIHRlbHU6IFwiW1xcdTBDNjYtXFx1MEM2Rl1cIixcbiAgdGhhaTogXCJbXFx1MEU1MC1cXHUwRTU5XVwiLFxuICB0aWJ0OiBcIltcXHUwRjIwLVxcdTBGMjldXCIsXG4gIGxhdG46IFwiXFxcXGRcIixcbn07XG5cbmNvbnN0IG51bWJlcmluZ1N5c3RlbXNVVEYxNiA9IHtcbiAgYXJhYjogWzE2MzIsIDE2NDFdLFxuICBhcmFiZXh0OiBbMTc3NiwgMTc4NV0sXG4gIGJhbGk6IFs2OTkyLCA3MDAxXSxcbiAgYmVuZzogWzI1MzQsIDI1NDNdLFxuICBkZXZhOiBbMjQwNiwgMjQxNV0sXG4gIGZ1bGx3aWRlOiBbNjUyOTYsIDY1MzAzXSxcbiAgZ3VqcjogWzI3OTAsIDI3OTldLFxuICBraG1yOiBbNjExMiwgNjEyMV0sXG4gIGtuZGE6IFszMzAyLCAzMzExXSxcbiAgbGFvbzogWzM3OTIsIDM4MDFdLFxuICBsaW1iOiBbNjQ3MCwgNjQ3OV0sXG4gIG1seW06IFszNDMwLCAzNDM5XSxcbiAgbW9uZzogWzYxNjAsIDYxNjldLFxuICBteW1yOiBbNDE2MCwgNDE2OV0sXG4gIG9yeWE6IFsyOTE4LCAyOTI3XSxcbiAgdGFtbGRlYzogWzMwNDYsIDMwNTVdLFxuICB0ZWx1OiBbMzE3NCwgMzE4M10sXG4gIHRoYWk6IFszNjY0LCAzNjczXSxcbiAgdGlidDogWzM4NzIsIDM4ODFdLFxufTtcblxuY29uc3QgaGFuaWRlY0NoYXJzID0gbnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjLnJlcGxhY2UoL1tcXFt8XFxdXS9nLCBcIlwiKS5zcGxpdChcIlwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGlnaXRzKHN0cikge1xuICBsZXQgdmFsdWUgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHZhbHVlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoc3RyW2ldLnNlYXJjaChudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMpICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSArPSBoYW5pZGVjQ2hhcnMuaW5kZXhPZihzdHJbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbnVtYmVyaW5nU3lzdGVtc1VURjE2KSB7XG4gICAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IG51bWJlcmluZ1N5c3RlbXNVVEYxNltrZXldO1xuICAgICAgICAgIGlmIChjb2RlID49IG1pbiAmJiBjb2RlIDw9IG1heCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gY29kZSAtIG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8vIGNhY2hlIG9mIHtudW1iZXJpbmdTeXN0ZW06IHthcHBlbmQ6IHJlZ2V4fX1cbmNvbnN0IGRpZ2l0UmVnZXhDYWNoZSA9IG5ldyBNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiByZXNldERpZ2l0UmVnZXhDYWNoZSgpIHtcbiAgZGlnaXRSZWdleENhY2hlLmNsZWFyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWdpdFJlZ2V4KHsgbnVtYmVyaW5nU3lzdGVtIH0sIGFwcGVuZCA9IFwiXCIpIHtcbiAgY29uc3QgbnMgPSBudW1iZXJpbmdTeXN0ZW0gfHwgXCJsYXRuXCI7XG5cbiAgbGV0IGFwcGVuZENhY2hlID0gZGlnaXRSZWdleENhY2hlLmdldChucyk7XG4gIGlmIChhcHBlbmRDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXBwZW5kQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgZGlnaXRSZWdleENhY2hlLnNldChucywgYXBwZW5kQ2FjaGUpO1xuICB9XG4gIGxldCByZWdleCA9IGFwcGVuZENhY2hlLmdldChhcHBlbmQpO1xuICBpZiAocmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgJHtudW1iZXJpbmdTeXN0ZW1zW25zXX0ke2FwcGVuZH1gKTtcbiAgICBhcHBlbmRDYWNoZS5zZXQoYXBwZW5kLCByZWdleCk7XG4gIH1cblxuICByZXR1cm4gcmVnZXg7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/digits.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/english.js":
/*!************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/english.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eraForDateTime: () => (/* binding */ eraForDateTime),\n/* harmony export */   eras: () => (/* binding */ eras),\n/* harmony export */   erasLong: () => (/* binding */ erasLong),\n/* harmony export */   erasNarrow: () => (/* binding */ erasNarrow),\n/* harmony export */   erasShort: () => (/* binding */ erasShort),\n/* harmony export */   formatRelativeTime: () => (/* binding */ formatRelativeTime),\n/* harmony export */   formatString: () => (/* binding */ formatString),\n/* harmony export */   meridiemForDateTime: () => (/* binding */ meridiemForDateTime),\n/* harmony export */   meridiems: () => (/* binding */ meridiems),\n/* harmony export */   monthForDateTime: () => (/* binding */ monthForDateTime),\n/* harmony export */   months: () => (/* binding */ months),\n/* harmony export */   monthsLong: () => (/* binding */ monthsLong),\n/* harmony export */   monthsNarrow: () => (/* binding */ monthsNarrow),\n/* harmony export */   monthsShort: () => (/* binding */ monthsShort),\n/* harmony export */   weekdayForDateTime: () => (/* binding */ weekdayForDateTime),\n/* harmony export */   weekdays: () => (/* binding */ weekdays),\n/* harmony export */   weekdaysLong: () => (/* binding */ weekdaysLong),\n/* harmony export */   weekdaysNarrow: () => (/* binding */ weekdaysNarrow),\n/* harmony export */   weekdaysShort: () => (/* binding */ weekdaysShort)\n/* harmony export */ });\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n\n\n\nfunction stringify(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\n\n/**\n * @private\n */\n\nconst monthsLong = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n];\n\nconst monthsShort = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\nconst monthsNarrow = [\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"];\n\nfunction months(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...monthsNarrow];\n    case \"short\":\n      return [...monthsShort];\n    case \"long\":\n      return [...monthsLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"];\n    case \"2-digit\":\n      return [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\n    default:\n      return null;\n  }\n}\n\nconst weekdaysLong = [\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\",\n];\n\nconst weekdaysShort = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n\nconst weekdaysNarrow = [\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\"];\n\nfunction weekdays(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...weekdaysNarrow];\n    case \"short\":\n      return [...weekdaysShort];\n    case \"long\":\n      return [...weekdaysLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n    default:\n      return null;\n  }\n}\n\nconst meridiems = [\"AM\", \"PM\"];\n\nconst erasLong = [\"Before Christ\", \"Anno Domini\"];\n\nconst erasShort = [\"BC\", \"AD\"];\n\nconst erasNarrow = [\"B\", \"A\"];\n\nfunction eras(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...erasNarrow];\n    case \"short\":\n      return [...erasShort];\n    case \"long\":\n      return [...erasLong];\n    default:\n      return null;\n  }\n}\n\nfunction meridiemForDateTime(dt) {\n  return meridiems[dt.hour < 12 ? 0 : 1];\n}\n\nfunction weekdayForDateTime(dt, length) {\n  return weekdays(length)[dt.weekday - 1];\n}\n\nfunction monthForDateTime(dt, length) {\n  return months(length)[dt.month - 1];\n}\n\nfunction eraForDateTime(dt, length) {\n  return eras(length)[dt.year < 0 ? 0 : 1];\n}\n\nfunction formatRelativeTime(unit, count, numeric = \"always\", narrow = false) {\n  const units = {\n    years: [\"year\", \"yr.\"],\n    quarters: [\"quarter\", \"qtr.\"],\n    months: [\"month\", \"mo.\"],\n    weeks: [\"week\", \"wk.\"],\n    days: [\"day\", \"day\", \"days\"],\n    hours: [\"hour\", \"hr.\"],\n    minutes: [\"minute\", \"min.\"],\n    seconds: [\"second\", \"sec.\"],\n  };\n\n  const lastable = [\"hours\", \"minutes\", \"seconds\"].indexOf(unit) === -1;\n\n  if (numeric === \"auto\" && lastable) {\n    const isDay = unit === \"days\";\n    switch (count) {\n      case 1:\n        return isDay ? \"tomorrow\" : `next ${units[unit][0]}`;\n      case -1:\n        return isDay ? \"yesterday\" : `last ${units[unit][0]}`;\n      case 0:\n        return isDay ? \"today\" : `this ${units[unit][0]}`;\n      default: // fall through\n    }\n  }\n\n  const isInPast = Object.is(count, -0) || count < 0,\n    fmtValue = Math.abs(count),\n    singular = fmtValue === 1,\n    lilUnits = units[unit],\n    fmtUnit = narrow\n      ? singular\n        ? lilUnits[1]\n        : lilUnits[2] || lilUnits[1]\n      : singular\n      ? units[unit][0]\n      : unit;\n  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;\n}\n\nfunction formatString(knownFormat) {\n  // these all have the offsets removed because we don't have access to them\n  // without all the intl stuff this is backfilling\n  const filtered = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.pick)(knownFormat, [\n      \"weekday\",\n      \"era\",\n      \"year\",\n      \"month\",\n      \"day\",\n      \"hour\",\n      \"minute\",\n      \"second\",\n      \"timeZoneName\",\n      \"hourCycle\",\n    ]),\n    key = stringify(filtered),\n    dateTimeHuge = \"EEEE, LLLL d, yyyy, h:mm a\";\n  switch (key) {\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_SHORT):\n      return \"M/d/yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED):\n      return \"LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED_WITH_WEEKDAY):\n      return \"EEE, LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_FULL):\n      return \"LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_HUGE):\n      return \"EEEE, LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_SIMPLE):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SECONDS):\n      return \"h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SHORT_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_LONG_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_SIMPLE):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SECONDS):\n      return \"HH:mm:ss\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SHORT_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_LONG_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT):\n      return \"M/d/yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED):\n      return \"LLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL):\n      return \"LLLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE):\n      return dateTimeHuge;\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT_WITH_SECONDS):\n      return \"M/d/yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_SECONDS):\n      return \"LLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_WEEKDAY):\n      return \"EEE, d LLL yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL_WITH_SECONDS):\n      return \"LLLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE_WITH_SECONDS):\n      return \"EEEE, LLLL d, yyyy, h:mm:ss a\";\n    default:\n      return dateTimeHuge;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9lbmdsaXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNQOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVSxFQUFFLFNBQVMsYUFBYSxVQUFVLEVBQUUsUUFBUTtBQUM3RTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsOENBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBa0I7QUFDckM7QUFDQSxtQkFBbUIsaURBQWdCO0FBQ25DO0FBQ0EsbUJBQW1CLDhEQUE2QjtBQUNoRDtBQUNBLG1CQUFtQixrREFBaUI7QUFDcEM7QUFDQSxtQkFBbUIsa0RBQWlCO0FBQ3BDO0FBQ0EsbUJBQW1CLG9EQUFtQjtBQUN0QztBQUNBLG1CQUFtQiwwREFBeUI7QUFDNUM7QUFDQSxtQkFBbUIsK0RBQThCO0FBQ2pEO0FBQ0EsbUJBQW1CLDhEQUE2QjtBQUNoRDtBQUNBLG1CQUFtQix1REFBc0I7QUFDekM7QUFDQSxtQkFBbUIsNkRBQTRCO0FBQy9DO0FBQ0EsbUJBQW1CLGtFQUFpQztBQUNwRDtBQUNBLG1CQUFtQixpRUFBZ0M7QUFDbkQ7QUFDQSxtQkFBbUIsdURBQXNCO0FBQ3pDO0FBQ0EsbUJBQW1CLHFEQUFvQjtBQUN2QztBQUNBLG1CQUFtQixzREFBcUI7QUFDeEM7QUFDQSxtQkFBbUIsc0RBQXFCO0FBQ3hDO0FBQ0EsbUJBQW1CLG9FQUFtQztBQUN0RDtBQUNBLG1CQUFtQixrRUFBaUM7QUFDcEQ7QUFDQSxtQkFBbUIsa0VBQWlDO0FBQ3BEO0FBQ0EsbUJBQW1CLG1FQUFrQztBQUNyRDtBQUNBLG1CQUFtQixtRUFBa0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9lbmdsaXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgbW9udGhzTG9uZyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc1Nob3J0ID0gW1xuICBcIkphblwiLFxuICBcIkZlYlwiLFxuICBcIk1hclwiLFxuICBcIkFwclwiLFxuICBcIk1heVwiLFxuICBcIkp1blwiLFxuICBcIkp1bFwiLFxuICBcIkF1Z1wiLFxuICBcIlNlcFwiLFxuICBcIk9jdFwiLFxuICBcIk5vdlwiLFxuICBcIkRlY1wiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBjYXNlIFwiMi1kaWdpdFwiOlxuICAgICAgcmV0dXJuIFtcIjAxXCIsIFwiMDJcIiwgXCIwM1wiLCBcIjA0XCIsIFwiMDVcIiwgXCIwNlwiLCBcIjA3XCIsIFwiMDhcIiwgXCIwOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTG9uZyA9IFtcbiAgXCJNb25kYXlcIixcbiAgXCJUdWVzZGF5XCIsXG4gIFwiV2VkbmVzZGF5XCIsXG4gIFwiVGh1cnNkYXlcIixcbiAgXCJGcmlkYXlcIixcbiAgXCJTYXR1cmRheVwiLFxuICBcIlN1bmRheVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSBbXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc0xvbmcgPSBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzU2hvcnQgPSBbXCJCQ1wiLCBcIkFEXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNMb25nXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMgPSBcImFsd2F5c1wiLCBuYXJyb3cgPSBmYWxzZSkge1xuICBjb25zdCB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXSxcbiAgfTtcblxuICBjb25zdCBsYXN0YWJsZSA9IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl0uaW5kZXhPZih1bml0KSA9PT0gLTE7XG5cbiAgaWYgKG51bWVyaWMgPT09IFwiYXV0b1wiICYmIGxhc3RhYmxlKSB7XG4gICAgY29uc3QgaXNEYXkgPSB1bml0ID09PSBcImRheXNcIjtcbiAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9tb3Jyb3dcIiA6IGBuZXh0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwieWVzdGVyZGF5XCIgOiBgbGFzdCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IGB0aGlzICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGRlZmF1bHQ6IC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgIGZtdFZhbHVlID0gTWF0aC5hYnMoY291bnQpLFxuICAgIHNpbmd1bGFyID0gZm10VmFsdWUgPT09IDEsXG4gICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICBmbXRVbml0ID0gbmFycm93XG4gICAgICA/IHNpbmd1bGFyXG4gICAgICAgID8gbGlsVW5pdHNbMV1cbiAgICAgICAgOiBsaWxVbml0c1syXSB8fCBsaWxVbml0c1sxXVxuICAgICAgOiBzaW5ndWxhclxuICAgICAgPyB1bml0c1t1bml0XVswXVxuICAgICAgOiB1bml0O1xuICByZXR1cm4gaXNJblBhc3QgPyBgJHtmbXRWYWx1ZX0gJHtmbXRVbml0fSBhZ29gIDogYGluICR7Zm10VmFsdWV9ICR7Zm10VW5pdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGtub3duRm9ybWF0KSB7XG4gIC8vIHRoZXNlIGFsbCBoYXZlIHRoZSBvZmZzZXRzIHJlbW92ZWQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIC8vIHdpdGhvdXQgYWxsIHRoZSBpbnRsIHN0dWZmIHRoaXMgaXMgYmFja2ZpbGxpbmdcbiAgY29uc3QgZmlsdGVyZWQgPSBwaWNrKGtub3duRm9ybWF0LCBbXG4gICAgICBcIndlZWtkYXlcIixcbiAgICAgIFwiZXJhXCIsXG4gICAgICBcInllYXJcIixcbiAgICAgIFwibW9udGhcIixcbiAgICAgIFwiZGF5XCIsXG4gICAgICBcImhvdXJcIixcbiAgICAgIFwibWludXRlXCIsXG4gICAgICBcInNlY29uZFwiLFxuICAgICAgXCJ0aW1lWm9uZU5hbWVcIixcbiAgICAgIFwiaG91ckN5Y2xlXCIsXG4gICAgXSksXG4gICAga2V5ID0gc3RyaW5naWZ5KGZpbHRlcmVkKSxcbiAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/english.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formats.js":
/*!************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/formats.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DATETIME_FULL: () => (/* binding */ DATETIME_FULL),\n/* harmony export */   DATETIME_FULL_WITH_SECONDS: () => (/* binding */ DATETIME_FULL_WITH_SECONDS),\n/* harmony export */   DATETIME_HUGE: () => (/* binding */ DATETIME_HUGE),\n/* harmony export */   DATETIME_HUGE_WITH_SECONDS: () => (/* binding */ DATETIME_HUGE_WITH_SECONDS),\n/* harmony export */   DATETIME_MED: () => (/* binding */ DATETIME_MED),\n/* harmony export */   DATETIME_MED_WITH_SECONDS: () => (/* binding */ DATETIME_MED_WITH_SECONDS),\n/* harmony export */   DATETIME_MED_WITH_WEEKDAY: () => (/* binding */ DATETIME_MED_WITH_WEEKDAY),\n/* harmony export */   DATETIME_SHORT: () => (/* binding */ DATETIME_SHORT),\n/* harmony export */   DATETIME_SHORT_WITH_SECONDS: () => (/* binding */ DATETIME_SHORT_WITH_SECONDS),\n/* harmony export */   DATE_FULL: () => (/* binding */ DATE_FULL),\n/* harmony export */   DATE_HUGE: () => (/* binding */ DATE_HUGE),\n/* harmony export */   DATE_MED: () => (/* binding */ DATE_MED),\n/* harmony export */   DATE_MED_WITH_WEEKDAY: () => (/* binding */ DATE_MED_WITH_WEEKDAY),\n/* harmony export */   DATE_SHORT: () => (/* binding */ DATE_SHORT),\n/* harmony export */   TIME_24_SIMPLE: () => (/* binding */ TIME_24_SIMPLE),\n/* harmony export */   TIME_24_WITH_LONG_OFFSET: () => (/* binding */ TIME_24_WITH_LONG_OFFSET),\n/* harmony export */   TIME_24_WITH_SECONDS: () => (/* binding */ TIME_24_WITH_SECONDS),\n/* harmony export */   TIME_24_WITH_SHORT_OFFSET: () => (/* binding */ TIME_24_WITH_SHORT_OFFSET),\n/* harmony export */   TIME_SIMPLE: () => (/* binding */ TIME_SIMPLE),\n/* harmony export */   TIME_WITH_LONG_OFFSET: () => (/* binding */ TIME_WITH_LONG_OFFSET),\n/* harmony export */   TIME_WITH_SECONDS: () => (/* binding */ TIME_WITH_SECONDS),\n/* harmony export */   TIME_WITH_SHORT_OFFSET: () => (/* binding */ TIME_WITH_SHORT_OFFSET)\n/* harmony export */ });\n/**\n * @private\n */\n\nconst n = \"numeric\",\n  s = \"short\",\n  l = \"long\";\n\nconst DATE_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n};\n\nconst DATE_MED = {\n  year: n,\n  month: s,\n  day: n,\n};\n\nconst DATE_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n};\n\nconst DATE_FULL = {\n  year: n,\n  month: l,\n  day: n,\n};\n\nconst DATE_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n};\n\nconst TIME_SIMPLE = {\n  hour: n,\n  minute: n,\n};\n\nconst TIME_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst TIME_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst TIME_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n\nconst TIME_24_SIMPLE = {\n  hour: n,\n  minute: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: s,\n};\n\nconst TIME_24_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: l,\n};\n\nconst DATETIME_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_SHORT_WITH_SECONDS = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_MED_WITH_SECONDS = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_FULL = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_FULL_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  timeZoneName: l,\n};\n\nconst DATETIME_HUGE_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBuID0gXCJudW1lcmljXCIsXG4gIHMgPSBcInNob3J0XCIsXG4gIGwgPSBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formats.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formatter.js":
/*!**************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/formatter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Formatter)\n/* harmony export */ });\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n\n\n\n\nfunction stringifyTokens(splits, tokenToString) {\n  let s = \"\";\n  for (const token of splits) {\n    if (token.literal) {\n      s += token.val;\n    } else {\n      s += tokenToString(token.val);\n    }\n  }\n  return s;\n}\n\nconst macroTokenToFormatOpts = {\n  D: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_SHORT,\n  DD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_MED,\n  DDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_FULL,\n  DDDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_HUGE,\n  t: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_SIMPLE,\n  tt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SECONDS,\n  ttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SHORT_OFFSET,\n  tttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_LONG_OFFSET,\n  T: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_SIMPLE,\n  TT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SECONDS,\n  TTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SHORT_OFFSET,\n  TTTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_LONG_OFFSET,\n  f: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT,\n  ff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED,\n  fff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL,\n  ffff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE,\n  F: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT_WITH_SECONDS,\n  FF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED_WITH_SECONDS,\n  FFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL_WITH_SECONDS,\n  FFFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE_WITH_SECONDS,\n};\n\n/**\n * @private\n */\n\nclass Formatter {\n  static create(locale, opts = {}) {\n    return new Formatter(locale, opts);\n  }\n\n  static parseFormat(fmt) {\n    // white-space is always considered a literal in user-provided formats\n    // the \" \" token has a special meaning (see unitForToken)\n\n    let current = null,\n      currentFull = \"\",\n      bracketed = false;\n    const splits = [];\n    for (let i = 0; i < fmt.length; i++) {\n      const c = fmt.charAt(i);\n      if (c === \"'\") {\n        // turn '' into a literal signal quote instead of just skipping the empty literal\n        if (currentFull.length > 0 || bracketed) {\n          splits.push({\n            literal: bracketed || /^\\s+$/.test(currentFull),\n            val: currentFull === \"\" ? \"'\" : currentFull,\n          });\n        }\n        current = null;\n        currentFull = \"\";\n        bracketed = !bracketed;\n      } else if (bracketed) {\n        currentFull += c;\n      } else if (c === current) {\n        currentFull += c;\n      } else {\n        if (currentFull.length > 0) {\n          splits.push({ literal: /^\\s+$/.test(currentFull), val: currentFull });\n        }\n        currentFull = c;\n        current = c;\n      }\n    }\n\n    if (currentFull.length > 0) {\n      splits.push({ literal: bracketed || /^\\s+$/.test(currentFull), val: currentFull });\n    }\n\n    return splits;\n  }\n\n  static macroTokenToFormatOpts(token) {\n    return macroTokenToFormatOpts[token];\n  }\n\n  constructor(locale, formatOpts) {\n    this.opts = formatOpts;\n    this.loc = locale;\n    this.systemLoc = null;\n  }\n\n  formatWithSystemDefault(dt, opts) {\n    if (this.systemLoc === null) {\n      this.systemLoc = this.loc.redefaultToSystem();\n    }\n    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });\n    return df.format();\n  }\n\n  dtFormatter(dt, opts = {}) {\n    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });\n  }\n\n  formatDateTime(dt, opts) {\n    return this.dtFormatter(dt, opts).format();\n  }\n\n  formatDateTimeParts(dt, opts) {\n    return this.dtFormatter(dt, opts).formatToParts();\n  }\n\n  formatInterval(interval, opts) {\n    const df = this.dtFormatter(interval.start, opts);\n    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());\n  }\n\n  resolvedOptions(dt, opts) {\n    return this.dtFormatter(dt, opts).resolvedOptions();\n  }\n\n  num(n, p = 0, signDisplay = undefined) {\n    // we get some perf out of doing this here, annoyingly\n    if (this.opts.forceSimple) {\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.padStart)(n, p);\n    }\n\n    const opts = { ...this.opts };\n\n    if (p > 0) {\n      opts.padTo = p;\n    }\n    if (signDisplay) {\n      opts.signDisplay = signDisplay;\n    }\n\n    return this.loc.numberFormatter(opts).format(n);\n  }\n\n  formatDateTimeFromString(dt, fmt) {\n    const knownEnglish = this.loc.listingMode() === \"en\",\n      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== \"gregory\",\n      string = (opts, extract) => this.loc.extract(dt, opts, extract),\n      formatOffset = (opts) => {\n        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {\n          return \"Z\";\n        }\n\n        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : \"\";\n      },\n      meridiem = () =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.meridiemForDateTime(dt)\n          : string({ hour: \"numeric\", hourCycle: \"h12\" }, \"dayperiod\"),\n      month = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.monthForDateTime(dt, length)\n          : string(standalone ? { month: length } : { month: length, day: \"numeric\" }, \"month\"),\n      weekday = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.weekdayForDateTime(dt, length)\n          : string(\n              standalone ? { weekday: length } : { weekday: length, month: \"long\", day: \"numeric\" },\n              \"weekday\"\n            ),\n      maybeMacro = (token) => {\n        const formatOpts = Formatter.macroTokenToFormatOpts(token);\n        if (formatOpts) {\n          return this.formatWithSystemDefault(dt, formatOpts);\n        } else {\n          return token;\n        }\n      },\n      era = (length) =>\n        knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_0__.eraForDateTime(dt, length) : string({ era: length }, \"era\"),\n      tokenToString = (token) => {\n        // Where possible: https://cldr.unicode.org/translation/date-time/date-time-symbols\n        switch (token) {\n          // ms\n          case \"S\":\n            return this.num(dt.millisecond);\n          case \"u\":\n          // falls through\n          case \"SSS\":\n            return this.num(dt.millisecond, 3);\n          // seconds\n          case \"s\":\n            return this.num(dt.second);\n          case \"ss\":\n            return this.num(dt.second, 2);\n          // fractional seconds\n          case \"uu\":\n            return this.num(Math.floor(dt.millisecond / 10), 2);\n          case \"uuu\":\n            return this.num(Math.floor(dt.millisecond / 100));\n          // minutes\n          case \"m\":\n            return this.num(dt.minute);\n          case \"mm\":\n            return this.num(dt.minute, 2);\n          // hours\n          case \"h\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);\n          case \"hh\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);\n          case \"H\":\n            return this.num(dt.hour);\n          case \"HH\":\n            return this.num(dt.hour, 2);\n          // offset\n          case \"Z\":\n            // like +6\n            return formatOffset({ format: \"narrow\", allowZ: this.opts.allowZ });\n          case \"ZZ\":\n            // like +06:00\n            return formatOffset({ format: \"short\", allowZ: this.opts.allowZ });\n          case \"ZZZ\":\n            // like +0600\n            return formatOffset({ format: \"techie\", allowZ: this.opts.allowZ });\n          case \"ZZZZ\":\n            // like EST\n            return dt.zone.offsetName(dt.ts, { format: \"short\", locale: this.loc.locale });\n          case \"ZZZZZ\":\n            // like Eastern Standard Time\n            return dt.zone.offsetName(dt.ts, { format: \"long\", locale: this.loc.locale });\n          // zone\n          case \"z\":\n            // like America/New_York\n            return dt.zoneName;\n          // meridiems\n          case \"a\":\n            return meridiem();\n          // dates\n          case \"d\":\n            return useDateTimeFormatter ? string({ day: \"numeric\" }, \"day\") : this.num(dt.day);\n          case \"dd\":\n            return useDateTimeFormatter ? string({ day: \"2-digit\" }, \"day\") : this.num(dt.day, 2);\n          // weekdays - standalone\n          case \"c\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"ccc\":\n            // like 'Tues'\n            return weekday(\"short\", true);\n          case \"cccc\":\n            // like 'Tuesday'\n            return weekday(\"long\", true);\n          case \"ccccc\":\n            // like 'T'\n            return weekday(\"narrow\", true);\n          // weekdays - format\n          case \"E\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"EEE\":\n            // like 'Tues'\n            return weekday(\"short\", false);\n          case \"EEEE\":\n            // like 'Tuesday'\n            return weekday(\"long\", false);\n          case \"EEEEE\":\n            // like 'T'\n            return weekday(\"narrow\", false);\n          // months - standalone\n          case \"L\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"LL\":\n            // like 01, doesn't seem to work\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"LLL\":\n            // like Jan\n            return month(\"short\", true);\n          case \"LLLL\":\n            // like January\n            return month(\"long\", true);\n          case \"LLLLL\":\n            // like J\n            return month(\"narrow\", true);\n          // months - format\n          case \"M\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"MM\":\n            // like 01\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"MMM\":\n            // like Jan\n            return month(\"short\", false);\n          case \"MMMM\":\n            // like January\n            return month(\"long\", false);\n          case \"MMMMM\":\n            // like J\n            return month(\"narrow\", false);\n          // years\n          case \"y\":\n            // like 2014\n            return useDateTimeFormatter ? string({ year: \"numeric\" }, \"year\") : this.num(dt.year);\n          case \"yy\":\n            // like 14\n            return useDateTimeFormatter\n              ? string({ year: \"2-digit\" }, \"year\")\n              : this.num(dt.year.toString().slice(-2), 2);\n          case \"yyyy\":\n            // like 0012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 4);\n          case \"yyyyyy\":\n            // like 000012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 6);\n          // eras\n          case \"G\":\n            // like AD\n            return era(\"short\");\n          case \"GG\":\n            // like Anno Domini\n            return era(\"long\");\n          case \"GGGGG\":\n            return era(\"narrow\");\n          case \"kk\":\n            return this.num(dt.weekYear.toString().slice(-2), 2);\n          case \"kkkk\":\n            return this.num(dt.weekYear, 4);\n          case \"W\":\n            return this.num(dt.weekNumber);\n          case \"WW\":\n            return this.num(dt.weekNumber, 2);\n          case \"n\":\n            return this.num(dt.localWeekNumber);\n          case \"nn\":\n            return this.num(dt.localWeekNumber, 2);\n          case \"ii\":\n            return this.num(dt.localWeekYear.toString().slice(-2), 2);\n          case \"iiii\":\n            return this.num(dt.localWeekYear, 4);\n          case \"o\":\n            return this.num(dt.ordinal);\n          case \"ooo\":\n            return this.num(dt.ordinal, 3);\n          case \"q\":\n            // like 1\n            return this.num(dt.quarter);\n          case \"qq\":\n            // like 01\n            return this.num(dt.quarter, 2);\n          case \"X\":\n            return this.num(Math.floor(dt.ts / 1000));\n          case \"x\":\n            return this.num(dt.ts);\n          default:\n            return maybeMacro(token);\n        }\n      };\n\n    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);\n  }\n\n  formatDurationFromString(dur, fmt) {\n    const invertLargest = this.opts.signMode === \"negativeLargestOnly\" ? -1 : 1;\n    const tokenToField = (token) => {\n        switch (token[0]) {\n          case \"S\":\n            return \"milliseconds\";\n          case \"s\":\n            return \"seconds\";\n          case \"m\":\n            return \"minutes\";\n          case \"h\":\n            return \"hours\";\n          case \"d\":\n            return \"days\";\n          case \"w\":\n            return \"weeks\";\n          case \"M\":\n            return \"months\";\n          case \"y\":\n            return \"years\";\n          default:\n            return null;\n        }\n      },\n      tokenToString = (lildur, info) => (token) => {\n        const mapped = tokenToField(token);\n        if (mapped) {\n          const inversionFactor =\n            info.isNegativeDuration && mapped !== info.largestUnit ? invertLargest : 1;\n          let signDisplay;\n          if (this.opts.signMode === \"negativeLargestOnly\" && mapped !== info.largestUnit) {\n            signDisplay = \"never\";\n          } else if (this.opts.signMode === \"all\") {\n            signDisplay = \"always\";\n          } else {\n            // \"auto\" and \"negative\" are the same, but \"auto\" has better support\n            signDisplay = \"auto\";\n          }\n          return this.num(lildur.get(mapped) * inversionFactor, token.length, signDisplay);\n        } else {\n          return token;\n        }\n      },\n      tokens = Formatter.parseFormat(fmt),\n      realTokens = tokens.reduce(\n        (found, { literal, val }) => (literal ? found : found.concat(val)),\n        []\n      ),\n      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t)),\n      durationInfo = {\n        isNegativeDuration: collapsed < 0,\n        // this relies on \"collapsed\" being based on \"shiftTo\", which builds up the object\n        // in order\n        largestUnit: Object.keys(collapsed.values)[0],\n      };\n    return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNBO0FBQ0g7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssbURBQWtCO0FBQ3ZCLE1BQU0saURBQWdCO0FBQ3RCLE9BQU8sa0RBQWlCO0FBQ3hCLFFBQVEsa0RBQWlCO0FBQ3pCLEtBQUssb0RBQW1CO0FBQ3hCLE1BQU0sMERBQXlCO0FBQy9CLE9BQU8sK0RBQThCO0FBQ3JDLFFBQVEsOERBQTZCO0FBQ3JDLEtBQUssdURBQXNCO0FBQzNCLE1BQU0sNkRBQTRCO0FBQ2xDLE9BQU8sa0VBQWlDO0FBQ3hDLFFBQVEsaUVBQWdDO0FBQ3hDLEtBQUssdURBQXNCO0FBQzNCLE1BQU0scURBQW9CO0FBQzFCLE9BQU8sc0RBQXFCO0FBQzVCLFFBQVEsc0RBQXFCO0FBQzdCLEtBQUssb0VBQW1DO0FBQ3hDLE1BQU0sa0VBQWlDO0FBQ3ZDLE9BQU8sbUVBQWtDO0FBQ3pDLFFBQVEsbUVBQWtDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0Isc0RBQXNEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUVBQW1FO0FBQ3ZGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHNwbGl0cykge1xuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0ge1xuICBEOiBGb3JtYXRzLkRBVEVfU0hPUlQsXG4gIEREOiBGb3JtYXRzLkRBVEVfTUVELFxuICBEREQ6IEZvcm1hdHMuREFURV9GVUxMLFxuICBEREREOiBGb3JtYXRzLkRBVEVfSFVHRSxcbiAgdDogRm9ybWF0cy5USU1FX1NJTVBMRSxcbiAgdHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMsXG4gIHR0dDogRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VULFxuICB0dHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogRm9ybWF0cy5USU1FXzI0X1NJTVBMRSxcbiAgVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMsXG4gIFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCxcbiAgZjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVCxcbiAgZmY6IEZvcm1hdHMuREFURVRJTUVfTUVELFxuICBmZmY6IEZvcm1hdHMuREFURVRJTUVfRlVMTCxcbiAgZmZmZjogRm9ybWF0cy5EQVRFVElNRV9IVUdFLFxuICBGOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyxcbiAgRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTLFxuICBGRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1hdHRlciB7XG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIC8vIHdoaXRlLXNwYWNlIGlzIGFsd2F5cyBjb25zaWRlcmVkIGEgbGl0ZXJhbCBpbiB1c2VyLXByb3ZpZGVkIGZvcm1hdHNcbiAgICAvLyB0aGUgXCIgXCIgdG9rZW4gaGFzIGEgc3BlY2lhbCBtZWFuaW5nIChzZWUgdW5pdEZvclRva2VuKVxuXG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIC8vIHR1cm4gJycgaW50byBhIGxpdGVyYWwgc2lnbmFsIHF1b3RlIGluc3RlYWQgb2YganVzdCBza2lwcGluZyB0aGUgZW1wdHkgbGl0ZXJhbFxuICAgICAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCB8fCBicmFja2V0ZWQpIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBicmFja2V0ZWQgfHwgL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksXG4gICAgICAgICAgICB2YWw6IGN1cnJlbnRGdWxsID09PSBcIlwiID8gXCInXCIgOiBjdXJyZW50RnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkIHx8IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cblxuICBzdGF0aWMgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzW3Rva2VuXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG4gICAgY29uc3QgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZShkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lUGFydHMoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgZm9ybWF0SW50ZXJ2YWwoaW50ZXJ2YWwsIG9wdHMpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoaW50ZXJ2YWwuc3RhcnQsIG9wdHMpO1xuICAgIHJldHVybiBkZi5kdGYuZm9ybWF0UmFuZ2UoaW50ZXJ2YWwuc3RhcnQudG9KU0RhdGUoKSwgaW50ZXJ2YWwuZW5kLnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG5cbiAgbnVtKG4sIHAgPSAwLCBzaWduRGlzcGxheSA9IHVuZGVmaW5lZCkge1xuICAgIC8vIHdlIGdldCBzb21lIHBlcmYgb3V0IG9mIGRvaW5nIHRoaXMgaGVyZSwgYW5ub3lpbmdseVxuICAgIGlmICh0aGlzLm9wdHMuZm9yY2VTaW1wbGUpIHtcbiAgICAgIHJldHVybiBwYWRTdGFydChuLCBwKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfTtcblxuICAgIGlmIChwID4gMCkge1xuICAgICAgb3B0cy5wYWRUbyA9IHA7XG4gICAgfVxuICAgIGlmIChzaWduRGlzcGxheSkge1xuICAgICAgb3B0cy5zaWduRGlzcGxheSA9IHNpZ25EaXNwbGF5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYy5udW1iZXJGb3JtYXR0ZXIob3B0cykuZm9ybWF0KG4pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICBjb25zdCBrbm93bkVuZ2xpc2ggPSB0aGlzLmxvYy5saXN0aW5nTW9kZSgpID09PSBcImVuXCIsXG4gICAgICB1c2VEYXRlVGltZUZvcm1hdHRlciA9IHRoaXMubG9jLm91dHB1dENhbGVuZGFyICYmIHRoaXMubG9jLm91dHB1dENhbGVuZGFyICE9PSBcImdyZWdvcnlcIixcbiAgICAgIHN0cmluZyA9IChvcHRzLCBleHRyYWN0KSA9PiB0aGlzLmxvYy5leHRyYWN0KGR0LCBvcHRzLCBleHRyYWN0KSxcbiAgICAgIGZvcm1hdE9mZnNldCA9IChvcHRzKSA9PiB7XG4gICAgICAgIGlmIChkdC5pc09mZnNldEZpeGVkICYmIGR0Lm9mZnNldCA9PT0gMCAmJiBvcHRzLmFsbG93Wikge1xuICAgICAgICAgIHJldHVybiBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkdC5pc1ZhbGlkID8gZHQuem9uZS5mb3JtYXRPZmZzZXQoZHQudHMsIG9wdHMuZm9ybWF0KSA6IFwiXCI7XG4gICAgICB9LFxuICAgICAgbWVyaWRpZW0gPSAoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZShkdClcbiAgICAgICAgICA6IHN0cmluZyh7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfSwgXCJkYXlwZXJpb2RcIiksXG4gICAgICBtb250aCA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoc3RhbmRhbG9uZSA/IHsgbW9udGg6IGxlbmd0aCB9IDogeyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIiksXG4gICAgICB3ZWVrZGF5ID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKFxuICAgICAgICAgICAgICBzdGFuZGFsb25lID8geyB3ZWVrZGF5OiBsZW5ndGggfSA6IHsgd2Vla2RheTogbGVuZ3RoLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfSxcbiAgICAgICAgICAgICAgXCJ3ZWVrZGF5XCJcbiAgICAgICAgICAgICksXG4gICAgICBtYXliZU1hY3JvID0gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG4gICAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIGZvcm1hdE9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVyYSA9IChsZW5ndGgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaCA/IEVuZ2xpc2guZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkgOiBzdHJpbmcoeyBlcmE6IGxlbmd0aCB9LCBcImVyYVwiKSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAodG9rZW4pID0+IHtcbiAgICAgICAgLy8gV2hlcmUgcG9zc2libGU6IGh0dHBzOi8vY2xkci51bmljb2RlLm9yZy90cmFuc2xhdGlvbi9kYXRlLXRpbWUvZGF0ZS10aW1lLXN5bWJvbHNcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgIC8vIG1zXG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kLCAzKTtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCwgMik7XG4gICAgICAgICAgLy8gZnJhY3Rpb25hbCBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwKSwgMik7XG4gICAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMDApKTtcbiAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUpO1xuICAgICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSwgMik7XG4gICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyKTtcbiAgICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMiwgMik7XG4gICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyKTtcbiAgICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyLCAyKTtcbiAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArNlxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJuYXJyb3dcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDY6MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwic2hvcnRcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwidGVjaGllXCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFU1RcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcInNob3J0XCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcImxvbmdcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgLy8gem9uZVxuICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lTmFtZTtcbiAgICAgICAgICAvLyBtZXJpZGllbXNcbiAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgcmV0dXJuIG1lcmlkaWVtKCk7XG4gICAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIm51bWVyaWNcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSk7XG4gICAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwiMi1kaWdpdFwiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5LCAyKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMSwgZG9lc24ndCBzZWVtIHRvIHdvcmtcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIHllYXJzXG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMjAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpIDogdGhpcy5udW0oZHQueWVhcik7XG4gICAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIjItZGlnaXRcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwieXl5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNik7XG4gICAgICAgICAgLy8gZXJhc1xuICAgICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFEXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwic2hvcnRcIik7XG4gICAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFubm8gRG9taW5pXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibG9uZ1wiKTtcbiAgICAgICAgICBjYXNlIFwiR0dHR0dcIjpcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJuYXJyb3dcIik7XG4gICAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlcik7XG4gICAgICAgICAgY2FzZSBcIldXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlciwgMik7XG4gICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJublwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla051bWJlciwgMik7XG4gICAgICAgICAgY2FzZSBcImlpXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubG9jYWxXZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImlpaWlcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IGludmVydExhcmdlc3QgPSB0aGlzLm9wdHMuc2lnbk1vZGUgPT09IFwibmVnYXRpdmVMYXJnZXN0T25seVwiID8gLTEgOiAxO1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kc1wiO1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzZWNvbmRzXCI7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbnV0ZXNcIjtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG91cnNcIjtcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZGF5c1wiO1xuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ3ZWVrc1wiO1xuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtb250aHNcIjtcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwieWVhcnNcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gKGxpbGR1ciwgaW5mbykgPT4gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICBjb25zdCBpbnZlcnNpb25GYWN0b3IgPVxuICAgICAgICAgICAgaW5mby5pc05lZ2F0aXZlRHVyYXRpb24gJiYgbWFwcGVkICE9PSBpbmZvLmxhcmdlc3RVbml0ID8gaW52ZXJ0TGFyZ2VzdCA6IDE7XG4gICAgICAgICAgbGV0IHNpZ25EaXNwbGF5O1xuICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2lnbk1vZGUgPT09IFwibmVnYXRpdmVMYXJnZXN0T25seVwiICYmIG1hcHBlZCAhPT0gaW5mby5sYXJnZXN0VW5pdCkge1xuICAgICAgICAgICAgc2lnbkRpc3BsYXkgPSBcIm5ldmVyXCI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuc2lnbk1vZGUgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIHNpZ25EaXNwbGF5ID0gXCJhbHdheXNcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gXCJhdXRvXCIgYW5kIFwibmVnYXRpdmVcIiBhcmUgdGhlIHNhbWUsIGJ1dCBcImF1dG9cIiBoYXMgYmV0dGVyIHN1cHBvcnRcbiAgICAgICAgICAgIHNpZ25EaXNwbGF5ID0gXCJhdXRvXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm51bShsaWxkdXIuZ2V0KG1hcHBlZCkgKiBpbnZlcnNpb25GYWN0b3IsIHRva2VuLmxlbmd0aCwgc2lnbkRpc3BsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgcmVhbFRva2VucyA9IHRva2Vucy5yZWR1Y2UoXG4gICAgICAgIChmb3VuZCwgeyBsaXRlcmFsLCB2YWwgfSkgPT4gKGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpKSxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUbyguLi5yZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcigodCkgPT4gdCkpLFxuICAgICAgZHVyYXRpb25JbmZvID0ge1xuICAgICAgICBpc05lZ2F0aXZlRHVyYXRpb246IGNvbGxhcHNlZCA8IDAsXG4gICAgICAgIC8vIHRoaXMgcmVsaWVzIG9uIFwiY29sbGFwc2VkXCIgYmVpbmcgYmFzZWQgb24gXCJzaGlmdFRvXCIsIHdoaWNoIGJ1aWxkcyB1cCB0aGUgb2JqZWN0XG4gICAgICAgIC8vIGluIG9yZGVyXG4gICAgICAgIGxhcmdlc3RVbml0OiBPYmplY3Qua2V5cyhjb2xsYXBzZWQudmFsdWVzKVswXSxcbiAgICAgIH07XG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2Vucyh0b2tlbnMsIHRva2VuVG9TdHJpbmcoY29sbGFwc2VkLCBkdXJhdGlvbkluZm8pKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formatter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/invalid.js":
/*!************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/invalid.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Invalid)\n/* harmony export */ });\nclass Invalid {\n  constructor(reason, explanation) {\n    this.reason = reason;\n    this.explanation = explanation;\n  }\n\n  toMessage() {\n    if (this.explanation) {\n      return `${this.reason}: ${this.explanation}`;\n    } else {\n      return this.reason;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9pbnZhbGlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxJQUFJLGlCQUFpQjtBQUNqRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkIHtcbiAgY29uc3RydWN0b3IocmVhc29uLCBleHBsYW5hdGlvbikge1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgfVxuXG4gIHRvTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5leHBsYW5hdGlvbikge1xuICAgICAgcmV0dXJuIGAke3RoaXMucmVhc29ufTogJHt0aGlzLmV4cGxhbmF0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/invalid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/locale.js":
/*!***********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/locale.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Locale)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nconst intlDTCache = new Map();\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache.get(key);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache.set(key, dtf);\n  }\n  return dtf;\n}\n\nconst intlNumCache = new Map();\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache.set(key, inf);\n  }\n  return inf;\n}\n\nconst intlRelCache = new Map();\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache.set(key, inf);\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nconst intlResolvedOptionsCache = new Map();\nfunction getCachedIntResolvedOptions(locString) {\n  let opts = intlResolvedOptionsCache.get(locString);\n  if (opts === undefined) {\n    opts = new Intl.DateTimeFormat(locString).resolvedOptions();\n    intlResolvedOptionsCache.set(locString, opts);\n  }\n  return opts;\n}\n\nconst weekInfoCache = new Map();\nfunction getCachedWeekInfo(locString) {\n  let data = weekInfoCache.get(locString);\n  if (!data) {\n    const locale = new Intl.Locale(locString);\n    // browsers currently implement this as a property, but spec says it should be a getter function\n    data = \"getWeekInfo\" in locale ? locale.getWeekInfo() : locale.weekInfo;\n    // minimalDays was removed from WeekInfo: https://github.com/tc39/proposal-intl-locale-info/issues/86\n    if (!(\"minimalDays\" in data)) {\n      data = { ...fallbackWeekSettings, ...data };\n    }\n    weekInfoCache.set(locString, data);\n  }\n  return data;\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const { numberingSystem, calendar } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2009, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, englishFn, intlFn) {\n  const mode = loc.listingMode();\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      getCachedIntResolvedOptions(loc.locale).numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roundTo)(i, 3);\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n\n    let z = undefined;\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n      this.originalZone = dt.zone;\n    }\n\n    const intlOpts = { ...this.opts };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts()\n        .map(({ value }) => value)\n        .join(\"\");\n    }\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n    if (this.originalZone) {\n      return parts.map((part) => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName,\n          });\n          return {\n            ...part,\n            value: offsetName,\n          };\n        } else {\n          return part;\n        }\n      });\n    }\n    return parts;\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasRelative)()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return _english_js__WEBPACK_IMPORTED_MODULE_1__.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\nconst fallbackWeekSettings = {\n  firstDay: 1,\n  minimalDays: 4,\n  weekend: [6, 7],\n};\n\n/**\n * @private\n */\nclass Locale {\n  static fromOpts(opts) {\n    return Locale.create(\n      opts.locale,\n      opts.numberingSystem,\n      opts.outputCalendar,\n      opts.weekSettings,\n      opts.defaultToEN\n    );\n  }\n\n  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {\n    const specifiedLocale = locale || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLocale;\n    // the system locale is useful for human-readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultOutputCalendar;\n    const weekSettingsR = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(weekSettings) || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultWeekSettings;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache.clear();\n    intlNumCache.clear();\n    intlRelCache.clear();\n    intlResolvedOptionsCache.clear();\n    weekInfoCache.clear();\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);\n  }\n\n  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.weekSettings = weekSettings;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(alts.weekSettings) || this.weekSettings,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.months, () => {\n      // Workaround for \"ja\" locale: formatToParts does not label all parts of the month\n      // as \"month\" and for this locale there is no difference between \"format\" and \"non-format\".\n      // As such, just use format() instead of formatToParts() and take the whole string\n      const monthSpecialCase = this.intl === \"ja\" || this.intl.startsWith(\"ja-\");\n      format &= !monthSpecialCase;\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        const mapper = !monthSpecialCase\n          ? (dt) => this.extract(dt, intl, \"month\")\n          : (dt) => this.dtFormatter(dt, intl).format();\n        this.monthsCache[formatStr][length] = mapMonths(mapper);\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems() {\n    return listStuff(\n      this,\n      undefined,\n      () => _english_js__WEBPACK_IMPORTED_MODULE_1__.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 9), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(-40, 1, 1), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      getCachedIntResolvedOptions(this.intl).locale.startsWith(\"en-us\")\n    );\n  }\n\n  getWeekSettings() {\n    if (this.weekSettings) {\n      return this.weekSettings;\n    } else if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasLocaleWeekInfo)()) {\n      return fallbackWeekSettings;\n    } else {\n      return getCachedWeekInfo(this.locale);\n    }\n  }\n\n  getStartOfWeek() {\n    return this.getWeekSettings().firstDay;\n  }\n\n  getMinDaysInFirstWeek() {\n    return this.getWeekSettings().minimalDays;\n  }\n\n  getWeekendDays() {\n    return this.getWeekSettings().weekend;\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n\n  toString() {\n    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9HO0FBQzVEO0FBQ0Y7QUFDQTtBQUNNOztBQUU1Qzs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxVQUFVLHdCQUF3QixRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDOztBQUVBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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ZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzTG9jYWxlV2Vla0luZm8sIGhhc1JlbGF0aXZlLCBwYWRTdGFydCwgcm91bmRUbywgdmFsaWRhdGVXZWVrU2V0dGluZ3MgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLy8gdG9kbyAtIHJlbWFwIGNhY2hpbmdcblxubGV0IGludGxMRkNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRMRihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsTEZDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTEZDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmNvbnN0IGludGxEVENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlLmdldChrZXkpO1xuICBpZiAoZHRmID09PSB1bmRlZmluZWQpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxEVENhY2hlLnNldChrZXksIGR0Zik7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxuY29uc3QgaW50bE51bUNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkSU5GKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGluZiA9IGludGxOdW1DYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGluZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5mID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bE51bUNhY2hlLnNldChrZXksIGluZik7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxuY29uc3QgaW50bFJlbENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkUlRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFzZSwgLi4uY2FjaGVLZXlPcHRzIH0gPSBvcHRzOyAvLyBleGNsdWRlIGBiYXNlYCBmcm9tIHRoZSBvcHRpb25zXG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIGNhY2hlS2V5T3B0c10pO1xuICBsZXQgaW5mID0gaW50bFJlbENhY2hlLmdldChrZXkpO1xuICBpZiAoaW5mID09PSB1bmRlZmluZWQpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGUuc2V0KGtleSwgaW5mKTtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH1cbn1cblxuY29uc3QgaW50bFJlc29sdmVkT3B0aW9uc0NhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkSW50UmVzb2x2ZWRPcHRpb25zKGxvY1N0cmluZykge1xuICBsZXQgb3B0cyA9IGludGxSZXNvbHZlZE9wdGlvbnNDYWNoZS5nZXQobG9jU3RyaW5nKTtcbiAgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NTdHJpbmcpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIGludGxSZXNvbHZlZE9wdGlvbnNDYWNoZS5zZXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgfVxuICByZXR1cm4gb3B0cztcbn1cblxuY29uc3Qgd2Vla0luZm9DYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlZFdlZWtJbmZvKGxvY1N0cmluZykge1xuICBsZXQgZGF0YSA9IHdlZWtJbmZvQ2FjaGUuZ2V0KGxvY1N0cmluZyk7XG4gIGlmICghZGF0YSkge1xuICAgIGNvbnN0IGxvY2FsZSA9IG5ldyBJbnRsLkxvY2FsZShsb2NTdHJpbmcpO1xuICAgIC8vIGJyb3dzZXJzIGN1cnJlbnRseSBpbXBsZW1lbnQgdGhpcyBhcyBhIHByb3BlcnR5LCBidXQgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhIGdldHRlciBmdW5jdGlvblxuICAgIGRhdGEgPSBcImdldFdlZWtJbmZvXCIgaW4gbG9jYWxlID8gbG9jYWxlLmdldFdlZWtJbmZvKCkgOiBsb2NhbGUud2Vla0luZm87XG4gICAgLy8gbWluaW1hbERheXMgd2FzIHJlbW92ZWQgZnJvbSBXZWVrSW5mbzogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtaW50bC1sb2NhbGUtaW5mby9pc3N1ZXMvODZcbiAgICBpZiAoIShcIm1pbmltYWxEYXlzXCIgaW4gZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7IC4uLmZhbGxiYWNrV2Vla1NldHRpbmdzLCAuLi5kYXRhIH07XG4gICAgfVxuICAgIHdlZWtJbmZvQ2FjaGUuc2V0KGxvY1N0cmluZywgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZVN0cikge1xuICAvLyBJIHJlYWxseSB3YW50IHRvIGF2b2lkIHdyaXRpbmcgYSBCQ1AgNDcgcGFyc2VyXG4gIC8vIHNlZSwgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL2JjcC00N1xuICAvLyBJbnN0ZWFkLCB3ZSdsbCBkbyB0aGlzOlxuXG4gIC8vIGEpIGlmIHRoZSBzdHJpbmcgaGFzIG5vIC11IGV4dGVuc2lvbnMsIGp1c3QgbGVhdmUgaXQgYWxvbmVcbiAgLy8gYikgaWYgaXQgZG9lcywgdXNlIEludGwgdG8gcmVzb2x2ZSBldmVyeXRoaW5nXG4gIC8vIGMpIGlmIEludGwgZmFpbHMsIHRyeSBhZ2FpbiB3aXRob3V0IHRoZSAtdVxuXG4gIC8vIHByaXZhdGUgc3VidGFncyBhbmQgdW5pY29kZSBzdWJ0YWdzIGhhdmUgb3JkZXJpbmcgcmVxdWlyZW1lbnRzLFxuICAvLyBhbmQgd2UncmUgbm90IHByb3Blcmx5IHBhcnNpbmcgdGhpcywgc28ganVzdCBzdHJpcCBvdXQgdGhlXG4gIC8vIHByaXZhdGUgb25lcyBpZiB0aGV5IGV4aXN0LlxuICBjb25zdCB4SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi14LVwiKTtcbiAgaWYgKHhJbmRleCAhPT0gLTEpIHtcbiAgICBsb2NhbGVTdHIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHhJbmRleCk7XG4gIH1cblxuICBjb25zdCB1SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi11LVwiKTtcbiAgaWYgKHVJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gW2xvY2FsZVN0cl07XG4gIH0gZWxzZSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IHNlbGVjdGVkU3RyO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKGxvY2FsZVN0cikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IGxvY2FsZVN0cjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBzbWFsbGVyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB1SW5kZXgpO1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihzbWFsbGVyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gc21hbGxlcjtcbiAgICB9XG5cbiAgICBjb25zdCB7IG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIFtzZWxlY3RlZFN0ciwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50bENvbmZpZ1N0cmluZyhsb2NhbGVTdHIsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpIHtcbiAgaWYgKG91dHB1dENhbGVuZGFyIHx8IG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGlmICghbG9jYWxlU3RyLmluY2x1ZGVzKFwiLXUtXCIpKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRDYWxlbmRhcikge1xuICAgICAgbG9jYWxlU3RyICs9IGAtY2EtJHtvdXRwdXRDYWxlbmRhcn1gO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLW51LSR7bnVtYmVyaW5nU3lzdGVtfWA7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBNb250aHMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSAxMjsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAwOSwgaSwgMSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBtYXBXZWVrZGF5cyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDc7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMyArIGkpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbGlzdFN0dWZmKGxvYywgbGVuZ3RoLCBlbmdsaXNoRm4sIGludGxGbikge1xuICBjb25zdCBtb2RlID0gbG9jLmxpc3RpbmdNb2RlKCk7XG5cbiAgaWYgKG1vZGUgPT09IFwiZXJyb3JcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiZW5cIikge1xuICAgIHJldHVybiBlbmdsaXNoRm4obGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW50bEZuKGxlbmd0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNGYXN0TnVtYmVycyhsb2MpIHtcbiAgaWYgKGxvYy5udW1iZXJpbmdTeXN0ZW0gJiYgbG9jLm51bWJlcmluZ1N5c3RlbSAhPT0gXCJsYXRuXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvYy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiIHx8XG4gICAgICAhbG9jLmxvY2FsZSB8fFxuICAgICAgbG9jLmxvY2FsZS5zdGFydHNXaXRoKFwiZW5cIikgfHxcbiAgICAgIGdldENhY2hlZEludFJlc29sdmVkT3B0aW9ucyhsb2MubG9jYWxlKS5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seU51bWJlckZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGZvcmNlU2ltcGxlLCBvcHRzKSB7XG4gICAgdGhpcy5wYWRUbyA9IG9wdHMucGFkVG8gfHwgMDtcbiAgICB0aGlzLmZsb29yID0gb3B0cy5mbG9vciB8fCBmYWxzZTtcblxuICAgIGNvbnN0IHsgcGFkVG8sIGZsb29yLCAuLi5vdGhlck9wdHMgfSA9IG9wdHM7XG5cbiAgICBpZiAoIWZvcmNlU2ltcGxlIHx8IE9iamVjdC5rZXlzKG90aGVyT3B0cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaW50bE9wdHMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSwgLi4ub3B0cyB9O1xuICAgICAgaWYgKG9wdHMucGFkVG8gPiAwKSBpbnRsT3B0cy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IG9wdHMucGFkVG87XG4gICAgICB0aGlzLmluZiA9IGdldENhY2hlZElORihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGkpIHtcbiAgICBpZiAodGhpcy5pbmYpIHtcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiBpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mLmZvcm1hdChmaXhlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgbnVtYmVyZm9ybWF0dGVyIGRlZmF1bHRzXG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogcm91bmRUbyhpLCAzKTtcbiAgICAgIHJldHVybiBwYWRTdGFydChmaXhlZCwgdGhpcy5wYWRUbyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5RGF0ZUZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGR0LCBpbnRsLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IHVuZGVmaW5lZDtcblxuICAgIGxldCB6ID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdHMudGltZVpvbmUpIHtcbiAgICAgIC8vIERvbid0IGFwcGx5IGFueSB3b3JrYXJvdW5kcyBpZiBhIHRpbWVab25lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gb3B0c1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImZpeGVkXCIpIHtcbiAgICAgIC8vIFVUQy04IG9yIEV0Yy9VVEMtOCBhcmUgbm90IHBhcnQgb2YgdHpkYXRhLCBvbmx5IEV0Yy9HTVQrOCBhbmQgdGhlIGxpa2UuXG4gICAgICAvLyBUaGF0IGlzIHdoeSBmaXhlZC1vZmZzZXQgVFogaXMgc2V0IHRvIHRoYXQgdW5sZXNzIGl0IGlzOlxuICAgICAgLy8gMS4gUmVwcmVzZW50aW5nIG9mZnNldCAwIHdoZW4gVVRDIGlzIHVzZWQgdG8gbWFpbnRhaW4gcHJldmlvdXMgYmVoYXZpb3IgYW5kIGRvZXMgbm90IGJlY29tZSBHTVQuXG4gICAgICAvLyAyLiBVbnN1cHBvcnRlZCBieSB0aGUgYnJvd3NlcjpcbiAgICAgIC8vICAgIC0gc29tZSBkbyBub3Qgc3VwcG9ydCBFdGMvXG4gICAgICAvLyAgICAtIDwgRXRjL0dNVC0xNCwgPiBFdGMvR01UKzEyLCBhbmQgMzAtbWludXRlIG9yIDQ1LW1pbnV0ZSBvZmZzZXRzIGFyZSBub3QgcGFydCBvZiB0emRhdGFcbiAgICAgIGNvbnN0IGdtdE9mZnNldCA9IC0xICogKGR0Lm9mZnNldCAvIDYwKTtcbiAgICAgIGNvbnN0IG9mZnNldFogPSBnbXRPZmZzZXQgPj0gMCA/IGBFdGMvR01UKyR7Z210T2Zmc2V0fWAgOiBgRXRjL0dNVCR7Z210T2Zmc2V0fWA7XG4gICAgICBpZiAoZHQub2Zmc2V0ICE9PSAwICYmIElBTkFab25lLmNyZWF0ZShvZmZzZXRaKS52YWxpZCkge1xuICAgICAgICB6ID0gb2Zmc2V0WjtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFsbCBmaXhlZC1vZmZzZXQgem9uZXMgbGlrZSBFdGMvKzQ6MzAgYXJlIHByZXNlbnQgaW4gdHpkYXRhIHNvXG4gICAgICAgIC8vIHdlIG1hbnVhbGx5IGFwcGx5IHRoZSBvZmZzZXQgYW5kIHN1YnN0aXR1dGUgdGhlIHpvbmUgYXMgbmVlZGVkLlxuICAgICAgICB6ID0gXCJVVENcIjtcbiAgICAgICAgdGhpcy5kdCA9IGR0Lm9mZnNldCA9PT0gMCA/IGR0IDogZHQuc2V0Wm9uZShcIlVUQ1wiKS5wbHVzKHsgbWludXRlczogZHQub2Zmc2V0IH0pO1xuICAgICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJpYW5hXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1c3RvbSB6b25lcyBjYW4gaGF2ZSBhbnkgb2Zmc2V0IC8gb2Zmc2V0TmFtZSBzbyB3ZSBqdXN0IG1hbnVhbGx5XG4gICAgICAvLyBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgdGhpcy5kdCA9IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgIHRoaXMub3JpZ2luYWxab25lID0gZHQuem9uZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRsT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSBpbnRsT3B0cy50aW1lWm9uZSB8fCB6O1xuICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgdG8gc3Vic3RpdHV0ZSBpbiB0aGUgYWN0dWFsIHpvbmUgbmFtZSwgd2UgaGF2ZSB0byB1c2VcbiAgICAgIC8vIGZvcm1hdFRvUGFydHMgc28gdGhhdCB0aGUgdGltZXpvbmUgY2FuIGJlIHJlcGxhY2VkLlxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VG9QYXJ0cygpXG4gICAgICAgIC5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpXG4gICAgICAgIC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5kdGYuZm9ybWF0VG9QYXJ0cyh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICAgIGlmICh0aGlzLm9yaWdpbmFsWm9uZSkge1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRpbWVab25lTmFtZVwiKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0TmFtZSA9IHRoaXMub3JpZ2luYWxab25lLm9mZnNldE5hbWUodGhpcy5kdC50cywge1xuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmR0LmxvY2FsZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRzLnRpbWVab25lTmFtZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucGFydCxcbiAgICAgICAgICAgIHZhbHVlOiBvZmZzZXROYW1lLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUG9seVJlbEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGlzRW5nbGlzaCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgc3R5bGU6IFwibG9uZ1wiLCAuLi5vcHRzIH07XG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGZhbGxiYWNrV2Vla1NldHRpbmdzID0ge1xuICBmaXJzdERheTogMSxcbiAgbWluaW1hbERheXM6IDQsXG4gIHdlZWtlbmQ6IFs2LCA3XSxcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgIG9wdHMubG9jYWxlLFxuICAgICAgb3B0cy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICBvcHRzLm91dHB1dENhbGVuZGFyLFxuICAgICAgb3B0cy53ZWVrU2V0dGluZ3MsXG4gICAgICBvcHRzLmRlZmF1bHRUb0VOXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZTtcbiAgICAvLyB0aGUgc3lzdGVtIGxvY2FsZSBpcyB1c2VmdWwgZm9yIGh1bWFuLXJlYWRhYmxlIHN0cmluZ3MgYnV0IGFubm95aW5nIGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcga25vd24gZm9ybWF0c1xuICAgIGNvbnN0IGxvY2FsZVIgPSBzcGVjaWZpZWRMb2NhbGUgfHwgKGRlZmF1bHRUb0VOID8gXCJlbi1VU1wiIDogc3lzdGVtTG9jYWxlKCkpO1xuICAgIGNvbnN0IG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICBjb25zdCBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgY29uc3Qgd2Vla1NldHRpbmdzUiA9IHZhbGlkYXRlV2Vla1NldHRpbmdzKHdlZWtTZXR0aW5ncykgfHwgU2V0dGluZ3MuZGVmYXVsdFdlZWtTZXR0aW5ncztcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHdlZWtTZXR0aW5nc1IsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUuY2xlYXIoKTtcbiAgICBpbnRsTnVtQ2FjaGUuY2xlYXIoKTtcbiAgICBpbnRsUmVsQ2FjaGUuY2xlYXIoKTtcbiAgICBpbnRsUmVzb2x2ZWRPcHRpb25zQ2FjaGUuY2xlYXIoKTtcbiAgICB3ZWVrSW5mb0NhY2hlLmNsZWFyKCk7XG4gIH1cblxuICBzdGF0aWMgZnJvbU9iamVjdCh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgbnVtYmVyaW5nLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzLCBzcGVjaWZpZWRMb2NhbGUpIHtcbiAgICBjb25zdCBbcGFyc2VkTG9jYWxlLCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0sIHBhcnNlZE91dHB1dENhbGVuZGFyXSA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLndlZWtTZXR0aW5ncyA9IHdlZWtTZXR0aW5ncztcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG5cbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tb250aHNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGZhc3ROdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkO1xuICB9XG5cbiAgbGlzdGluZ01vZGUoKSB7XG4gICAgY29uc3QgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKTtcbiAgICBjb25zdCBoYXNOb1dlaXJkbmVzcyA9XG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJlxuICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuICAgIHJldHVybiBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MgPyBcImVuXCIgOiBcImludGxcIjtcbiAgfVxuXG4gIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICAgIGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLFxuICAgICAgICBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLFxuICAgICAgICB2YWxpZGF0ZVdlZWtTZXR0aW5ncyhhbHRzLndlZWtTZXR0aW5ncykgfHwgdGhpcy53ZWVrU2V0dGluZ3MsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgXCJqYVwiIGxvY2FsZTogZm9ybWF0VG9QYXJ0cyBkb2VzIG5vdCBsYWJlbCBhbGwgcGFydHMgb2YgdGhlIG1vbnRoXG4gICAgICAvLyBhcyBcIm1vbnRoXCIgYW5kIGZvciB0aGlzIGxvY2FsZSB0aGVyZSBpcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gXCJmb3JtYXRcIiBhbmQgXCJub24tZm9ybWF0XCIuXG4gICAgICAvLyBBcyBzdWNoLCBqdXN0IHVzZSBmb3JtYXQoKSBpbnN0ZWFkIG9mIGZvcm1hdFRvUGFydHMoKSBhbmQgdGFrZSB0aGUgd2hvbGUgc3RyaW5nXG4gICAgICBjb25zdCBtb250aFNwZWNpYWxDYXNlID0gdGhpcy5pbnRsID09PSBcImphXCIgfHwgdGhpcy5pbnRsLnN0YXJ0c1dpdGgoXCJqYS1cIik7XG4gICAgICBmb3JtYXQgJj0gIW1vbnRoU3BlY2lhbENhc2U7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0ID8geyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0gOiB7IG1vbnRoOiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSAhbW9udGhTcGVjaWFsQ2FzZVxuICAgICAgICAgID8gKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIilcbiAgICAgICAgICA6IChkdCkgPT4gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bCkuZm9ybWF0KCk7XG4gICAgICAgIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwTW9udGhzKG1hcHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICB3ZWVrZGF5cyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2gud2Vla2RheXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXRcbiAgICAgICAgICA/IHsgd2Vla2RheTogbGVuZ3RoLCB5ZWFyOiBcIm51bWVyaWNcIiwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH1cbiAgICAgICAgICA6IHsgd2Vla2RheTogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwV2Vla2RheXMoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJ3ZWVrZGF5XCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmlkaWVtcygpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKFxuICAgICAgdGhpcyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgICgpID0+IEVuZ2xpc2gubWVyaWRpZW1zLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBJbiB0aGVvcnkgdGhlcmUgY291bGQgYmUgYXJpYml0cmFyeSBkYXkgcGVyaW9kcy4gV2UncmUgZ29ubmEgYXNzdW1lIHRoZXJlIGFyZSBleGFjdGx5IHR3b1xuICAgICAgICAvLyBmb3IgQU0gYW5kIFBNLiBUaGlzIGlzIHByb2JhYmx5IHdyb25nLCBidXQgaXQncyBtYWtlcyBwYXJzaW5nIHdheSBlYXNpZXIuXG4gICAgICAgIGlmICghdGhpcy5tZXJpZGllbUNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgaW50bCA9IHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9O1xuICAgICAgICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IFtEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCA5KSwgRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgMTkpXS5tYXAoXG4gICAgICAgICAgICAoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJkYXlwZXJpb2RcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyaWRpZW1DYWNoZTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZXJhcyhsZW5ndGgpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC5lcmFzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0geyBlcmE6IGxlbmd0aCB9O1xuXG4gICAgICAvLyBUaGlzIGlzIHByb2JsZW1hdGljLiBEaWZmZXJlbnQgY2FsZW5kYXJzIGFyZSBnb2luZyB0byBkZWZpbmUgZXJhcyB0b3RhbGx5IGRpZmZlcmVudGx5LiBXaGF0IEkgbmVlZCBpcyB0aGUgbWluaW11bSBzZXQgb2YgZGF0ZXNcbiAgICAgIC8vIHRvIGRlZmluaXRlbHkgZW51bWVyYXRlIHRoZW0uXG4gICAgICBpZiAoIXRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLmVyYUNhY2hlW2xlbmd0aF0gPSBbRGF0ZVRpbWUudXRjKC00MCwgMSwgMSksIERhdGVUaW1lLnV0YygyMDE3LCAxLCAxKV0ubWFwKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZXJhXCIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVyYUNhY2hlW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBleHRyYWN0KGR0LCBpbnRsT3B0cywgZmllbGQpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzKSxcbiAgICAgIHJlc3VsdHMgPSBkZi5mb3JtYXRUb1BhcnRzKCksXG4gICAgICBtYXRjaGluZyA9IHJlc3VsdHMuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IGZpZWxkKTtcbiAgICByZXR1cm4gbWF0Y2hpbmcgPyBtYXRjaGluZy52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBudW1iZXJGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgLy8gdGhpcyBmb3JjZXNpbXBsZSBvcHRpb24gaXMgbmV2ZXIgdXNlZCAodGhlIG9ubHkgY2FsbGVyIHNob3J0LWNpcmN1aXRzIG9uIGl0LCBidXQgaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUpXG4gICAgLy8gKGluIGNvbnRyYXN0LCB0aGUgcmVzdCBvZiB0aGUgY29uZGl0aW9uIGlzIHVzZWQgaGVhdmlseSlcbiAgICByZXR1cm4gbmV3IFBvbHlOdW1iZXJGb3JtYXR0ZXIodGhpcy5pbnRsLCBvcHRzLmZvcmNlU2ltcGxlIHx8IHRoaXMuZmFzdE51bWJlcnMsIG9wdHMpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlEYXRlRm9ybWF0dGVyKGR0LCB0aGlzLmludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIHJlbEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlSZWxGb3JtYXR0ZXIodGhpcy5pbnRsLCB0aGlzLmlzRW5nbGlzaCgpLCBvcHRzKTtcbiAgfVxuXG4gIGxpc3RGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIGdldENhY2hlZExGKHRoaXMuaW50bCwgb3B0cyk7XG4gIH1cblxuICBpc0VuZ2xpc2goKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBcImVuXCIgfHxcbiAgICAgIHRoaXMubG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IFwiZW4tdXNcIiB8fFxuICAgICAgZ2V0Q2FjaGVkSW50UmVzb2x2ZWRPcHRpb25zKHRoaXMuaW50bCkubG9jYWxlLnN0YXJ0c1dpdGgoXCJlbi11c1wiKVxuICAgICk7XG4gIH1cblxuICBnZXRXZWVrU2V0dGluZ3MoKSB7XG4gICAgaWYgKHRoaXMud2Vla1NldHRpbmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy53ZWVrU2V0dGluZ3M7XG4gICAgfSBlbHNlIGlmICghaGFzTG9jYWxlV2Vla0luZm8oKSkge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrV2Vla1NldHRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0Q2FjaGVkV2Vla0luZm8odGhpcy5sb2NhbGUpO1xuICAgIH1cbiAgfVxuXG4gIGdldFN0YXJ0T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtTZXR0aW5ncygpLmZpcnN0RGF5O1xuICB9XG5cbiAgZ2V0TWluRGF5c0luRmlyc3RXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtTZXR0aW5ncygpLm1pbmltYWxEYXlzO1xuICB9XG5cbiAgZ2V0V2Vla2VuZERheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1NldHRpbmdzKCkud2Vla2VuZDtcbiAgfVxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gb3RoZXIubG9jYWxlICYmXG4gICAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gb3RoZXIubnVtYmVyaW5nU3lzdGVtICYmXG4gICAgICB0aGlzLm91dHB1dENhbGVuZGFyID09PSBvdGhlci5vdXRwdXRDYWxlbmRhclxuICAgICk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYExvY2FsZSgke3RoaXMubG9jYWxlfSwgJHt0aGlzLm51bWJlcmluZ1N5c3RlbX0sICR7dGhpcy5vdXRwdXRDYWxlbmRhcn0pYDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/regexParser.js":
/*!****************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/regexParser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseHTTPDate: () => (/* binding */ parseHTTPDate),\n/* harmony export */   parseISODate: () => (/* binding */ parseISODate),\n/* harmony export */   parseISODuration: () => (/* binding */ parseISODuration),\n/* harmony export */   parseISOTimeOnly: () => (/* binding */ parseISOTimeOnly),\n/* harmony export */   parseRFC2822Date: () => (/* binding */ parseRFC2822Date),\n/* harmony export */   parseSQL: () => (/* binding */ parseSQL)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */\n\nconst ianaRegex = /[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;\n\nfunction combineRegexes(...regexes) {\n  const full = regexes.reduce((f, r) => f + r.source, \"\");\n  return RegExp(`^${full}$`);\n}\n\nfunction combineExtractors(...extractors) {\n  return (m) =>\n    extractors\n      .reduce(\n        ([mergedVals, mergedZone, cursor], ex) => {\n          const [val, zone, next] = ex(m, cursor);\n          return [{ ...mergedVals, ...val }, zone || mergedZone, next];\n        },\n        [{}, null, 1]\n      )\n      .slice(0, 2);\n}\n\nfunction parse(s, ...patterns) {\n  if (s == null) {\n    return [null, null];\n  }\n\n  for (const [regex, extractor] of patterns) {\n    const m = regex.exec(s);\n    if (m) {\n      return extractor(m);\n    }\n  }\n  return [null, null];\n}\n\nfunction simpleParse(...keys) {\n  return (match, cursor) => {\n    const ret = {};\n    let i;\n\n    for (i = 0; i < keys.length; i++) {\n      ret[keys[i]] = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(match[cursor + i]);\n    }\n    return [ret, null, cursor + i];\n  };\n}\n\n// ISO and SQL parsing\nconst offsetRegex = /(?:([Zz])|([+-]\\d\\d)(?::?(\\d\\d))?)/;\nconst isoExtendedZone = `(?:${offsetRegex.source}?(?:\\\\[(${ianaRegex.source})\\\\])?)?`;\nconst isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/;\nconst isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);\nconst isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);\nconst isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/;\nconst isoWeekRegex = /(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/;\nconst isoOrdinalRegex = /(\\d{4})-?(\\d{3})/;\nconst extractISOWeekData = simpleParse(\"weekYear\", \"weekNumber\", \"weekDay\");\nconst extractISOOrdinalData = simpleParse(\"year\", \"ordinal\");\nconst sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/; // dumbed-down version of the ISO one\nconst sqlTimeRegex = RegExp(\n  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`\n);\nconst sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);\n\nfunction int(match, pos, fallback) {\n  const m = match[pos];\n  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(m) ? fallback : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(m);\n}\n\nfunction extractISOYmd(match, cursor) {\n  const item = {\n    year: int(match, cursor),\n    month: int(match, cursor + 1, 1),\n    day: int(match, cursor + 2, 1),\n  };\n\n  return [item, null, cursor + 3];\n}\n\nfunction extractISOTime(match, cursor) {\n  const item = {\n    hours: int(match, cursor, 0),\n    minutes: int(match, cursor + 1, 0),\n    seconds: int(match, cursor + 2, 0),\n    milliseconds: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(match[cursor + 3]),\n  };\n\n  return [item, null, cursor + 4];\n}\n\nfunction extractISOOffset(match, cursor) {\n  const local = !match[cursor] && !match[cursor + 1],\n    fullOffset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(match[cursor + 1], match[cursor + 2]),\n    zone = local ? null : _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(fullOffset);\n  return [{}, zone, cursor + 3];\n}\n\nfunction extractIANAZone(match, cursor) {\n  const zone = match[cursor] ? _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(match[cursor]) : null;\n  return [{}, zone, cursor + 1];\n}\n\n// ISO time parsing\n\nconst isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);\n\n// ISO duration parsing\n\nconst isoDuration =\n  /^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;\n\nfunction extractISODuration(match) {\n  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =\n    match;\n\n  const hasNegativePrefix = s[0] === \"-\";\n  const negativeSeconds = secondStr && secondStr[0] === \"-\";\n\n  const maybeNegate = (num, force = false) =>\n    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;\n\n  return [\n    {\n      years: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(yearStr)),\n      months: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(monthStr)),\n      weeks: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(weekStr)),\n      days: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(dayStr)),\n      hours: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(hourStr)),\n      minutes: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(minuteStr)),\n      seconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(secondStr), secondStr === \"-0\"),\n      milliseconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(millisecondsStr), negativeSeconds),\n    },\n  ];\n}\n\n// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\nconst obsOffsets = {\n  GMT: 0,\n  EDT: -4 * 60,\n  EST: -5 * 60,\n  CDT: -5 * 60,\n  CST: -6 * 60,\n  MDT: -6 * 60,\n  MST: -7 * 60,\n  PDT: -7 * 60,\n  PST: -8 * 60,\n};\n\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n  const result = {\n    year: yearStr.length === 2 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr)) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr),\n    month: _english_js__WEBPACK_IMPORTED_MODULE_1__.monthsShort.indexOf(monthStr) + 1,\n    day: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(dayStr),\n    hour: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(hourStr),\n    minute: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(minuteStr),\n  };\n\n  if (secondStr) result.second = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(secondStr);\n  if (weekdayStr) {\n    result.weekday =\n      weekdayStr.length > 3\n        ? _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysLong.indexOf(weekdayStr) + 1\n        : _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysShort.indexOf(weekdayStr) + 1;\n  }\n\n  return result;\n}\n\n// RFC 2822/5322\nconst rfc2822 =\n  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\n\nfunction extractRFC2822(match) {\n  const [\n      ,\n      weekdayStr,\n      dayStr,\n      monthStr,\n      yearStr,\n      hourStr,\n      minuteStr,\n      secondStr,\n      obsOffset,\n      milOffset,\n      offHourStr,\n      offMinuteStr,\n    ] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  let offset;\n  if (obsOffset) {\n    offset = obsOffsets[obsOffset];\n  } else if (milOffset) {\n    offset = 0;\n  } else {\n    offset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(offHourStr, offMinuteStr);\n  }\n\n  return [result, new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](offset)];\n}\n\nfunction preprocessRFC2822(s) {\n  // Remove comments and folding whitespace and replace multiple-spaces with a single space\n  return s\n    .replace(/\\([^()]*\\)|[\\n\\t]/g, \" \")\n    .replace(/(\\s\\s+)/g, \" \")\n    .trim();\n}\n\n// http date\n\nconst rfc1123 =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  rfc850 =\n    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  ascii =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\n\nfunction extractRFC1123Or850(match) {\n  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nfunction extractASCII(match) {\n  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nconst isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nconst isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);\nconst isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);\nconst isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\n\nconst extractISOYmdTimeAndOffset = combineExtractors(\n  extractISOYmd,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOWeekTimeAndOffset = combineExtractors(\n  extractISOWeekData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOOrdinalDateAndTime = combineExtractors(\n  extractISOOrdinalData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOTimeAndOffset = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\n/*\n * @private\n */\n\nfunction parseISODate(s) {\n  return parse(\n    s,\n    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],\n    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],\n    [isoTimeCombinedRegex, extractISOTimeAndOffset]\n  );\n}\n\nfunction parseRFC2822Date(s) {\n  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);\n}\n\nfunction parseHTTPDate(s) {\n  return parse(\n    s,\n    [rfc1123, extractRFC1123Or850],\n    [rfc850, extractRFC1123Or850],\n    [ascii, extractASCII]\n  );\n}\n\nfunction parseISODuration(s) {\n  return parse(s, [isoDuration, extractISODuration]);\n}\n\nconst extractISOTimeOnly = combineExtractors(extractISOTime);\n\nfunction parseISOTimeOnly(s) {\n  return parse(s, [isoTimeOnly, extractISOTimeOnly]);\n}\n\nconst sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nconst sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\n\nconst extractISOTimeOffsetAndIANAZone = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\nfunction parseSQL(s) {\n  return parse(\n    s,\n    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBT21CO0FBQ3FCO0FBQ2tCO0FBQ2Q7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRix3QkFBd0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsTUFBTSxzQkFBc0IsTUFBTSxvQkFBb0IsTUFBTTs7QUFFM0Y7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0MsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLHFCQUFxQixzREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQixVQUFVLGlCQUFpQjtBQUM1RSxpRUFBaUUsS0FBSztBQUN0RSwrQkFBK0Isd0JBQXdCLEVBQUUsZ0JBQWdCO0FBQ3pFLCtDQUErQyxvQkFBb0I7QUFDbkUsNkJBQTZCLEVBQUUsSUFBSSxFQUFFO0FBQ3JDLDBCQUEwQixFQUFFO0FBQzVCLDZCQUE2QixFQUFFLE9BQU8sRUFBRTtBQUN4QztBQUNBO0FBQ0EseUJBQXlCLEVBQUUsa0JBQWtCO0FBQzdDO0FBQ0EsS0FBSyx5QkFBeUIsTUFBTSxtQkFBbUIsSUFBSSxpQkFBaUI7QUFDNUU7QUFDQSw0Q0FBNEMsb0JBQW9COztBQUVoRTtBQUNBO0FBQ0EsU0FBUyxxREFBVyxpQkFBaUIsc0RBQVk7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBVztBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVk7QUFDN0IsMEJBQTBCLGlFQUFlO0FBQ3pDLFlBQVk7QUFDWjs7QUFFQTtBQUNBLCtCQUErQiwwREFBUTtBQUN2QyxZQUFZO0FBQ1o7O0FBRUE7O0FBRUEsaUNBQWlDLHdCQUF3Qjs7QUFFekQ7O0FBRUE7QUFDQSxtQkFBbUIsS0FBSyxRQUFRLEtBQUssZUFBZSxLQUFLLFFBQVEsS0FBSyxlQUFlLEtBQUssUUFBUSxLQUFLLGVBQWUsS0FBSyxRQUFRLEtBQUssbUJBQW1CLEtBQUssUUFBUSxLQUFLLGVBQWUsS0FBSyxRQUFRLEtBQUssZUFBZSxLQUFLLGNBQWMsS0FBSzs7QUFFclA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFhO0FBQ3RDLDBCQUEwQix1REFBYTtBQUN2Qyx5QkFBeUIsdURBQWE7QUFDdEMsd0JBQXdCLHVEQUFhO0FBQ3JDLHlCQUF5Qix1REFBYTtBQUN0QywyQkFBMkIsdURBQWE7QUFDeEMsMkJBQTJCLHVEQUFhO0FBQ3hDLGdDQUFnQyxxREFBVztBQUMzQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsd0RBQWMsQ0FBQyxzREFBWSxhQUFhLHNEQUFZO0FBQ3JGLFdBQVcsb0RBQW1CO0FBQzlCLFNBQVMsc0RBQVk7QUFDckIsVUFBVSxzREFBWTtBQUN0QixZQUFZLHNEQUFZO0FBQ3hCOztBQUVBLGlDQUFpQyxzREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFvQjtBQUM5QixVQUFVLHNEQUFxQjtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSSwwREFBMEQsSUFBSTs7QUFFL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGFBQWEsc0RBQVk7QUFDekI7O0FBRUEsc0JBQXNCLGlFQUFlO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0dBQWtHLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILEVBQUU7O0FBRTVIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBZTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3JlZ2V4UGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHVudHJ1bmNhdGVZZWFyLFxuICBzaWduZWRPZmZzZXQsXG4gIHBhcnNlSW50ZWdlcixcbiAgcGFyc2VNaWxsaXMsXG4gIGlzVW5kZWZpbmVkLFxuICBwYXJzZUZsb2F0aW5nLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vKlxuICogVGhpcyBmaWxlIGhhbmRsZXMgcGFyc2luZyBmb3Igd2VsbC1zcGVjaWZpZWQgZm9ybWF0cy4gSGVyZSdzIGhvdyBpdCB3b3JrczpcbiAqIFR3byB0aGluZ3MgZ28gaW50byBwYXJzaW5nOiBhIHJlZ2V4IHRvIG1hdGNoIHdpdGggYW5kIGFuIGV4dHJhY3RvciB0byB0YWtlIGFwYXJ0IHRoZSBncm91cHMgaW4gdGhlIG1hdGNoLlxuICogQW4gZXh0cmFjdG9yIGlzIGp1c3QgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcmVnZXggbWF0Y2ggYXJyYXkgYW5kIHJldHVybnMgYSB7IHllYXI6IC4uLiwgbW9udGg6IC4uLiB9IG9iamVjdFxuICogcGFyc2UoKSBkb2VzIHRoZSB3b3JrIG9mIGV4ZWN1dGluZyB0aGUgcmVnZXggYW5kIGFwcGx5aW5nIHRoZSBleHRyYWN0b3IuIEl0IHRha2VzIG11bHRpcGxlIHJlZ2V4L2V4dHJhY3RvciBwYWlycyB0byB0cnkgaW4gc2VxdWVuY2UuXG4gKiBFeHRyYWN0b3JzIGNhbiB0YWtlIGEgXCJjdXJzb3JcIiByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBpbiB0aGUgbWF0Y2ggdG8gbG9vayBhdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNvbWJpbmUgZXh0cmFjdG9ycy5cbiAqIGNvbWJpbmVFeHRyYWN0b3JzKCkgZG9lcyB0aGUgd29yayBvZiBjb21iaW5pbmcgdGhlbSwga2VlcGluZyB0cmFjayBvZiB0aGUgY3Vyc29yIHRocm91Z2ggbXVsdGlwbGUgZXh0cmFjdGlvbnMuXG4gKiBTb21lIGV4dHJhY3Rpb25zIGFyZSBzdXBlciBkdW1iIGFuZCBzaW1wbGVQYXJzZSBhbmQgZnJvbVN0cmluZ3MgaGVscCBEUlkgdGhlbS5cbiAqL1xuXG5jb25zdCBpYW5hUmVnZXggPSAvW0EtWmEtel8rLV17MSwyNTZ9KD86Oj9cXC9bQS1aYS16MC05XystXXsxLDI1Nn0oPzpcXC9bQS1aYS16MC05XystXXsxLDI1Nn0pPyk/LztcblxuZnVuY3Rpb24gY29tYmluZVJlZ2V4ZXMoLi4ucmVnZXhlcykge1xuICBjb25zdCBmdWxsID0gcmVnZXhlcy5yZWR1Y2UoKGYsIHIpID0+IGYgKyByLnNvdXJjZSwgXCJcIik7XG4gIHJldHVybiBSZWdFeHAoYF4ke2Z1bGx9JGApO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lRXh0cmFjdG9ycyguLi5leHRyYWN0b3JzKSB7XG4gIHJldHVybiAobSkgPT5cbiAgICBleHRyYWN0b3JzXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW21lcmdlZFZhbHMsIG1lcmdlZFpvbmUsIGN1cnNvcl0sIGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3ZhbCwgem9uZSwgbmV4dF0gPSBleChtLCBjdXJzb3IpO1xuICAgICAgICAgIHJldHVybiBbeyAuLi5tZXJnZWRWYWxzLCAuLi52YWwgfSwgem9uZSB8fCBtZXJnZWRab25lLCBuZXh0XTtcbiAgICAgICAgfSxcbiAgICAgICAgW3t9LCBudWxsLCAxXVxuICAgICAgKVxuICAgICAgLnNsaWNlKDAsIDIpO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzLCAuLi5wYXR0ZXJucykge1xuICBpZiAocyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIGZvciAoY29uc3QgW3JlZ2V4LCBleHRyYWN0b3JdIG9mIHBhdHRlcm5zKSB7XG4gICAgY29uc3QgbSA9IHJlZ2V4LmV4ZWMocyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHJldHVybiBleHRyYWN0b3IobSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbnVsbCwgbnVsbF07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVBhcnNlKC4uLmtleXMpIHtcbiAgcmV0dXJuIChtYXRjaCwgY3Vyc29yKSA9PiB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2tleXNbaV1dID0gcGFyc2VJbnRlZ2VyKG1hdGNoW2N1cnNvciArIGldKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXQsIG51bGwsIGN1cnNvciArIGldO1xuICB9O1xufVxuXG4vLyBJU08gYW5kIFNRTCBwYXJzaW5nXG5jb25zdCBvZmZzZXRSZWdleCA9IC8oPzooW1p6XSl8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/KS87XG5jb25zdCBpc29FeHRlbmRlZFpvbmUgPSBgKD86JHtvZmZzZXRSZWdleC5zb3VyY2V9Pyg/OlxcXFxbKCR7aWFuYVJlZ2V4LnNvdXJjZX0pXFxcXF0pPyk/YDtcbmNvbnN0IGlzb1RpbWVCYXNlUmVnZXggPSAvKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlsuLF0oXFxkezEsMzB9KSk/KT8pPy87XG5jb25zdCBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtpc29FeHRlbmRlZFpvbmV9YCk7XG5jb25zdCBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OltUdF0ke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKTtcbmNvbnN0IGlzb1ltZFJlZ2V4ID0gLyhbKy1dXFxkezZ9fFxcZHs0fSkoPzotPyhcXGRcXGQpKD86LT8oXFxkXFxkKSk/KT8vO1xuY29uc3QgaXNvV2Vla1JlZ2V4ID0gLyhcXGR7NH0pLT9XKFxcZFxcZCkoPzotPyhcXGQpKT8vO1xuY29uc3QgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS87XG5jb25zdCBleHRyYWN0SVNPV2Vla0RhdGEgPSBzaW1wbGVQYXJzZShcIndlZWtZZWFyXCIsIFwid2Vla051bWJlclwiLCBcIndlZWtEYXlcIik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGEgPSBzaW1wbGVQYXJzZShcInllYXJcIiwgXCJvcmRpbmFsXCIpO1xuY29uc3Qgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvOyAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG5jb25zdCBzcWxUaW1lUmVnZXggPSBSZWdFeHAoXG4gIGAke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSA/KD86JHtvZmZzZXRSZWdleC5zb3VyY2V9fCgke2lhbmFSZWdleC5zb3VyY2V9KSk/YFxuKTtcbmNvbnN0IHNxbFRpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86ICR7c3FsVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuXG5mdW5jdGlvbiBpbnQobWF0Y2gsIHBvcywgZmFsbGJhY2spIHtcbiAgY29uc3QgbSA9IG1hdGNoW3Bvc107XG4gIHJldHVybiBpc1VuZGVmaW5lZChtKSA/IGZhbGxiYWNrIDogcGFyc2VJbnRlZ2VyKG0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPWW1kKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICB5ZWFyOiBpbnQobWF0Y2gsIGN1cnNvciksXG4gICAgbW9udGg6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMSksXG4gICAgZGF5OiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDEpLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09UaW1lKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICBob3VyczogaW50KG1hdGNoLCBjdXJzb3IsIDApLFxuICAgIG1pbnV0ZXM6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMCksXG4gICAgc2Vjb25kczogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAwKSxcbiAgICBtaWxsaXNlY29uZHM6IHBhcnNlTWlsbGlzKG1hdGNoW2N1cnNvciArIDNdKSxcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDRdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPT2Zmc2V0KG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgbG9jYWwgPSAhbWF0Y2hbY3Vyc29yXSAmJiAhbWF0Y2hbY3Vyc29yICsgMV0sXG4gICAgZnVsbE9mZnNldCA9IHNpZ25lZE9mZnNldChtYXRjaFtjdXJzb3IgKyAxXSwgbWF0Y2hbY3Vyc29yICsgMl0pLFxuICAgIHpvbmUgPSBsb2NhbCA/IG51bGwgOiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoZnVsbE9mZnNldCk7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SUFOQVpvbmUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCB6b25lID0gbWF0Y2hbY3Vyc29yXSA/IElBTkFab25lLmNyZWF0ZShtYXRjaFtjdXJzb3JdKSA6IG51bGw7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDFdO1xufVxuXG4vLyBJU08gdGltZSBwYXJzaW5nXG5cbmNvbnN0IGlzb1RpbWVPbmx5ID0gUmVnRXhwKGBeVD8ke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSRgKTtcblxuLy8gSVNPIGR1cmF0aW9uIHBhcnNpbmdcblxuY29uc3QgaXNvRHVyYXRpb24gPVxuICAvXi0/UCg/Oig/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVkpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVcpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUQpPyg/OlQoPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylIKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylNKT8oPzooLT9cXGR7MSwyMH0pKD86Wy4sXSgtP1xcZHsxLDIwfSkpP1MpPyk/KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0SVNPRHVyYXRpb24obWF0Y2gpIHtcbiAgY29uc3QgW3MsIHllYXJTdHIsIG1vbnRoU3RyLCB3ZWVrU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCBtaWxsaXNlY29uZHNTdHJdID1cbiAgICBtYXRjaDtcblxuICBjb25zdCBoYXNOZWdhdGl2ZVByZWZpeCA9IHNbMF0gPT09IFwiLVwiO1xuICBjb25zdCBuZWdhdGl2ZVNlY29uZHMgPSBzZWNvbmRTdHIgJiYgc2Vjb25kU3RyWzBdID09PSBcIi1cIjtcblxuICBjb25zdCBtYXliZU5lZ2F0ZSA9IChudW0sIGZvcmNlID0gZmFsc2UpID0+XG4gICAgbnVtICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IChudW0gJiYgaGFzTmVnYXRpdmVQcmVmaXgpKSA/IC1udW0gOiBudW07XG5cbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB5ZWFyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh5ZWFyU3RyKSksXG4gICAgICBtb250aHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobW9udGhTdHIpKSxcbiAgICAgIHdlZWtzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHdlZWtTdHIpKSxcbiAgICAgIGRheXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoZGF5U3RyKSksXG4gICAgICBob3VyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhob3VyU3RyKSksXG4gICAgICBtaW51dGVzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1pbnV0ZVN0cikpLFxuICAgICAgc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhzZWNvbmRTdHIpLCBzZWNvbmRTdHIgPT09IFwiLTBcIiksXG4gICAgICBtaWxsaXNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlTWlsbGlzKG1pbGxpc2Vjb25kc1N0ciksIG5lZ2F0aXZlU2Vjb25kcyksXG4gICAgfSxcbiAgXTtcbn1cblxuLy8gVGhlc2UgYXJlIGEgbGl0dGxlIGJyYWluZGVhZC4gRURUICpzaG91bGQqIHRlbGwgdXMgdGhhdCB3ZSdyZSBpbiwgc2F5LCBBbWVyaWNhL05ld19Zb3JrXG4vLyBhbmQgbm90IGp1c3QgdGhhdCB3ZSdyZSBpbiAtMjQwICpyaWdodCBub3cqLiBCdXQgc2luY2UgSSBkb24ndCB0aGluayB0aGVzZSBhcmUgdXNlZCB0aGF0IG9mdGVuXG4vLyBJJ20ganVzdCBnb2luZyB0byBpZ25vcmUgdGhhdFxuY29uc3Qgb2JzT2Zmc2V0cyA9IHtcbiAgR01UOiAwLFxuICBFRFQ6IC00ICogNjAsXG4gIEVTVDogLTUgKiA2MCxcbiAgQ0RUOiAtNSAqIDYwLFxuICBDU1Q6IC02ICogNjAsXG4gIE1EVDogLTYgKiA2MCxcbiAgTVNUOiAtNyAqIDYwLFxuICBQRFQ6IC03ICogNjAsXG4gIFBTVDogLTggKiA2MCxcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB5ZWFyOiB5ZWFyU3RyLmxlbmd0aCA9PT0gMiA/IHVudHJ1bmNhdGVZZWFyKHBhcnNlSW50ZWdlcih5ZWFyU3RyKSkgOiBwYXJzZUludGVnZXIoeWVhclN0ciksXG4gICAgbW9udGg6IEVuZ2xpc2gubW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0cikgKyAxLFxuICAgIGRheTogcGFyc2VJbnRlZ2VyKGRheVN0ciksXG4gICAgaG91cjogcGFyc2VJbnRlZ2VyKGhvdXJTdHIpLFxuICAgIG1pbnV0ZTogcGFyc2VJbnRlZ2VyKG1pbnV0ZVN0ciksXG4gIH07XG5cbiAgaWYgKHNlY29uZFN0cikgcmVzdWx0LnNlY29uZCA9IHBhcnNlSW50ZWdlcihzZWNvbmRTdHIpO1xuICBpZiAod2Vla2RheVN0cikge1xuICAgIHJlc3VsdC53ZWVrZGF5ID1cbiAgICAgIHdlZWtkYXlTdHIubGVuZ3RoID4gM1xuICAgICAgICA/IEVuZ2xpc2gud2Vla2RheXNMb25nLmluZGV4T2Yod2Vla2RheVN0cikgKyAxXG4gICAgICAgIDogRW5nbGlzaC53ZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0cikgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gUkZDIDI4MjIvNTMyMlxuY29uc3QgcmZjMjgyMiA9XG4gIC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksXFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfCg/OihbKy1dXFxkXFxkKShcXGRcXGQpKSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzI4MjIobWF0Y2gpIHtcbiAgY29uc3QgW1xuICAgICAgLFxuICAgICAgd2Vla2RheVN0cixcbiAgICAgIGRheVN0cixcbiAgICAgIG1vbnRoU3RyLFxuICAgICAgeWVhclN0cixcbiAgICAgIGhvdXJTdHIsXG4gICAgICBtaW51dGVTdHIsXG4gICAgICBzZWNvbmRTdHIsXG4gICAgICBvYnNPZmZzZXQsXG4gICAgICBtaWxPZmZzZXQsXG4gICAgICBvZmZIb3VyU3RyLFxuICAgICAgb2ZmTWludXRlU3RyLFxuICAgIF0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG5cbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9ic09mZnNldCkge1xuICAgIG9mZnNldCA9IG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgfSBlbHNlIGlmIChtaWxPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpO1xuICB9XG5cbiAgcmV0dXJuIFtyZXN1bHQsIG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KV07XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKVxuICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cblxuLy8gaHR0cCBkYXRlXG5cbmNvbnN0IHJmYzExMjMgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9XG4gICAgL14oTW9uZGF5fFR1ZXNkYXl8V2VkbmVzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheXxTdW5kYXkpLCAoXFxkXFxkKS0oSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLShcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICBhc2NpaSA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICggXFxkfFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgKFxcZHs0fSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzExMjNPcjg1MChtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBkYXlTdHIsIG1vbnRoU3RyLCB5ZWFyU3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QVNDSUkobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIHllYXJTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuY29uc3QgaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1ltZFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29XZWVrUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb09yZGluYWxSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1RpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1ltZCxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPV2Vla0RhdGEsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09PcmRpbmFsRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbi8qXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWVdLFxuICAgIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW3JmYzg1MCwgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW2FzY2lpLCBleHRyYWN0QVNDSUldXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0R1cmF0aW9uKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29EdXJhdGlvbiwgZXh0cmFjdElTT0R1cmF0aW9uXSk7XG59XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT25seSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPVGltZU9ubHkocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1RpbWVPbmx5LCBleHRyYWN0SVNPVGltZU9ubHldKTtcbn1cblxuY29uc3Qgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3Qgc3FsVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxUaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNRTChzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW3NxbFRpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lXVxuICApO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/regexParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/tokenParser.js":
/*!****************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/tokenParser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TokenParser: () => (/* binding */ TokenParser),\n/* harmony export */   expandMacroTokens: () => (/* binding */ expandMacroTokens),\n/* harmony export */   explainFromTokens: () => (/* binding */ explainFromTokens),\n/* harmony export */   formatOptsToTokens: () => (/* binding */ formatOptsToTokens),\n/* harmony export */   parseFromTokens: () => (/* binding */ parseFromTokens)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _digits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./digits.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/digits.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\");\n\n\n\n\n\n\n\n\nconst MISSING_FTP = \"missing Intl.DateTimeFormat.formatToParts support\";\n\nfunction intUnit(regex, post = (i) => i) {\n  return { regex, deser: ([s]) => post((0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.parseDigits)(s)) };\n}\n\nconst NBSP = String.fromCharCode(160);\nconst spaceOrNBSP = `[ ${NBSP}]`;\nconst spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, \"g\");\n\nfunction fixListRegex(s) {\n  // make dots optional and also make them literal\n  // make space and non breakable space characters interchangeable\n  return s.replace(/\\./g, \"\\\\.?\").replace(spaceOrNBSPRegExp, spaceOrNBSP);\n}\n\nfunction stripInsensitivities(s) {\n  return s\n    .replace(/\\./g, \"\") // ignore dots that were made optional\n    .replace(spaceOrNBSPRegExp, \" \") // interchange space and nbsp\n    .toLowerCase();\n}\n\nfunction oneOf(strings, startIndex) {\n  if (strings === null) {\n    return null;\n  } else {\n    return {\n      regex: RegExp(strings.map(fixListRegex).join(\"|\")),\n      deser: ([s]) =>\n        strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,\n    };\n  }\n}\n\nfunction offset(regex, groups) {\n  return { regex, deser: ([, h, m]) => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(h, m), groups };\n}\n\nfunction simple(regex) {\n  return { regex, deser: ([s]) => s };\n}\n\nfunction escapeToken(value) {\n  return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n\n/**\n * @param token\n * @param {Locale} loc\n */\nfunction unitForToken(token, loc) {\n  const one = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc),\n    two = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2}\"),\n    three = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{3}\"),\n    four = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4}\"),\n    six = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{6}\"),\n    oneOrTwo = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,2}\"),\n    oneToThree = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,3}\"),\n    oneToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,6}\"),\n    oneToNine = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,9}\"),\n    twoToFour = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2,4}\"),\n    fourToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4,6}\"),\n    literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),\n    unitate = (t) => {\n      if (token.literal) {\n        return literal(t);\n      }\n      switch (t.val) {\n        // era\n        case \"G\":\n          return oneOf(loc.eras(\"short\"), 0);\n        case \"GG\":\n          return oneOf(loc.eras(\"long\"), 0);\n        // years\n        case \"y\":\n          return intUnit(oneToSix);\n        case \"yy\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        case \"yyyy\":\n          return intUnit(four);\n        case \"yyyyy\":\n          return intUnit(fourToSix);\n        case \"yyyyyy\":\n          return intUnit(six);\n        // months\n        case \"M\":\n          return intUnit(oneOrTwo);\n        case \"MM\":\n          return intUnit(two);\n        case \"MMM\":\n          return oneOf(loc.months(\"short\", true), 1);\n        case \"MMMM\":\n          return oneOf(loc.months(\"long\", true), 1);\n        case \"L\":\n          return intUnit(oneOrTwo);\n        case \"LL\":\n          return intUnit(two);\n        case \"LLL\":\n          return oneOf(loc.months(\"short\", false), 1);\n        case \"LLLL\":\n          return oneOf(loc.months(\"long\", false), 1);\n        // dates\n        case \"d\":\n          return intUnit(oneOrTwo);\n        case \"dd\":\n          return intUnit(two);\n        // ordinals\n        case \"o\":\n          return intUnit(oneToThree);\n        case \"ooo\":\n          return intUnit(three);\n        // time\n        case \"HH\":\n          return intUnit(two);\n        case \"H\":\n          return intUnit(oneOrTwo);\n        case \"hh\":\n          return intUnit(two);\n        case \"h\":\n          return intUnit(oneOrTwo);\n        case \"mm\":\n          return intUnit(two);\n        case \"m\":\n          return intUnit(oneOrTwo);\n        case \"q\":\n          return intUnit(oneOrTwo);\n        case \"qq\":\n          return intUnit(two);\n        case \"s\":\n          return intUnit(oneOrTwo);\n        case \"ss\":\n          return intUnit(two);\n        case \"S\":\n          return intUnit(oneToThree);\n        case \"SSS\":\n          return intUnit(three);\n        case \"u\":\n          return simple(oneToNine);\n        case \"uu\":\n          return simple(oneOrTwo);\n        case \"uuu\":\n          return intUnit(one);\n        // meridiem\n        case \"a\":\n          return oneOf(loc.meridiems(), 0);\n        // weekYear (k)\n        case \"kkkk\":\n          return intUnit(four);\n        case \"kk\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        // weekNumber (W)\n        case \"W\":\n          return intUnit(oneOrTwo);\n        case \"WW\":\n          return intUnit(two);\n        // weekdays\n        case \"E\":\n        case \"c\":\n          return intUnit(one);\n        case \"EEE\":\n          return oneOf(loc.weekdays(\"short\", false), 1);\n        case \"EEEE\":\n          return oneOf(loc.weekdays(\"long\", false), 1);\n        case \"ccc\":\n          return oneOf(loc.weekdays(\"short\", true), 1);\n        case \"cccc\":\n          return oneOf(loc.weekdays(\"long\", true), 1);\n        // offset/zone\n        case \"Z\":\n        case \"ZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);\n        case \"ZZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);\n        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing\n        // because we don't have any way to figure out what they are\n        case \"z\":\n          return simple(/[a-z_+-/]{1,256}?/i);\n        // this special-case \"token\" represents a place where a macro-token expanded into a white-space literal\n        // in this case we accept any non-newline white-space\n        case \" \":\n          return simple(/[^\\S\\n\\r]/);\n        default:\n          return literal(t);\n      }\n    };\n\n  const unit = unitate(token) || {\n    invalidReason: MISSING_FTP,\n  };\n\n  unit.token = token;\n\n  return unit;\n}\n\nconst partTypeStyleToTokenVal = {\n  year: {\n    \"2-digit\": \"yy\",\n    numeric: \"yyyyy\",\n  },\n  month: {\n    numeric: \"M\",\n    \"2-digit\": \"MM\",\n    short: \"MMM\",\n    long: \"MMMM\",\n  },\n  day: {\n    numeric: \"d\",\n    \"2-digit\": \"dd\",\n  },\n  weekday: {\n    short: \"EEE\",\n    long: \"EEEE\",\n  },\n  dayperiod: \"a\",\n  dayPeriod: \"a\",\n  hour12: {\n    numeric: \"h\",\n    \"2-digit\": \"hh\",\n  },\n  hour24: {\n    numeric: \"H\",\n    \"2-digit\": \"HH\",\n  },\n  minute: {\n    numeric: \"m\",\n    \"2-digit\": \"mm\",\n  },\n  second: {\n    numeric: \"s\",\n    \"2-digit\": \"ss\",\n  },\n  timeZoneName: {\n    long: \"ZZZZZ\",\n    short: \"ZZZ\",\n  },\n};\n\nfunction tokenForPart(part, formatOpts, resolvedOpts) {\n  const { type, value } = part;\n\n  if (type === \"literal\") {\n    const isSpace = /^\\s+$/.test(value);\n    return {\n      literal: !isSpace,\n      val: isSpace ? \" \" : value,\n    };\n  }\n\n  const style = formatOpts[type];\n\n  // The user might have explicitly specified hour12 or hourCycle\n  // if so, respect their decision\n  // if not, refer back to the resolvedOpts, which are based on the locale\n  let actualType = type;\n  if (type === \"hour\") {\n    if (formatOpts.hour12 != null) {\n      actualType = formatOpts.hour12 ? \"hour12\" : \"hour24\";\n    } else if (formatOpts.hourCycle != null) {\n      if (formatOpts.hourCycle === \"h11\" || formatOpts.hourCycle === \"h12\") {\n        actualType = \"hour12\";\n      } else {\n        actualType = \"hour24\";\n      }\n    } else {\n      // tokens only differentiate between 24 hours or not,\n      // so we do not need to check hourCycle here, which is less supported anyways\n      actualType = resolvedOpts.hour12 ? \"hour12\" : \"hour24\";\n    }\n  }\n  let val = partTypeStyleToTokenVal[actualType];\n  if (typeof val === \"object\") {\n    val = val[style];\n  }\n\n  if (val) {\n    return {\n      literal: false,\n      val,\n    };\n  }\n\n  return undefined;\n}\n\nfunction buildRegex(units) {\n  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, \"\");\n  return [`^${re}$`, units];\n}\n\nfunction match(input, regex, handlers) {\n  const matches = input.match(regex);\n\n  if (matches) {\n    const all = {};\n    let matchIndex = 1;\n    for (const i in handlers) {\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(handlers, i)) {\n        const h = handlers[i],\n          groups = h.groups ? h.groups + 1 : 1;\n        if (!h.literal && h.token) {\n          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));\n        }\n        matchIndex += groups;\n      }\n    }\n    return [matches, all];\n  } else {\n    return [matches, {}];\n  }\n}\n\nfunction dateTimeFromMatches(matches) {\n  const toField = (token) => {\n    switch (token) {\n      case \"S\":\n        return \"millisecond\";\n      case \"s\":\n        return \"second\";\n      case \"m\":\n        return \"minute\";\n      case \"h\":\n      case \"H\":\n        return \"hour\";\n      case \"d\":\n        return \"day\";\n      case \"o\":\n        return \"ordinal\";\n      case \"L\":\n      case \"M\":\n        return \"month\";\n      case \"y\":\n        return \"year\";\n      case \"E\":\n      case \"c\":\n        return \"weekday\";\n      case \"W\":\n        return \"weekNumber\";\n      case \"k\":\n        return \"weekYear\";\n      case \"q\":\n        return \"quarter\";\n      default:\n        return null;\n    }\n  };\n\n  let zone = null;\n  let specificOffset;\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.z)) {\n    zone = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(matches.z);\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.Z)) {\n    if (!zone) {\n      zone = new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matches.Z);\n    }\n    specificOffset = matches.Z;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.q)) {\n    matches.M = (matches.q - 1) * 3 + 1;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.h)) {\n    if (matches.h < 12 && matches.a === 1) {\n      matches.h += 12;\n    } else if (matches.h === 12 && matches.a === 0) {\n      matches.h = 0;\n    }\n  }\n\n  if (matches.G === 0 && matches.y) {\n    matches.y = -matches.y;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.u)) {\n    matches.S = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(matches.u);\n  }\n\n  const vals = Object.keys(matches).reduce((r, k) => {\n    const f = toField(k);\n    if (f) {\n      r[f] = matches[k];\n    }\n\n    return r;\n  }, {});\n\n  return [vals, zone, specificOffset];\n}\n\nlet dummyDateTimeCache = null;\n\nfunction getDummyDateTime() {\n  if (!dummyDateTimeCache) {\n    dummyDateTimeCache = _datetime_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromMillis(1555555555555);\n  }\n\n  return dummyDateTimeCache;\n}\n\nfunction maybeExpandMacroToken(token, locale) {\n  if (token.literal) {\n    return token;\n  }\n\n  const formatOpts = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].macroTokenToFormatOpts(token.val);\n  const tokens = formatOptsToTokens(formatOpts, locale);\n\n  if (tokens == null || tokens.includes(undefined)) {\n    return token;\n  }\n\n  return tokens;\n}\n\nfunction expandMacroTokens(tokens, locale) {\n  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));\n}\n\n/**\n * @private\n */\n\nclass TokenParser {\n  constructor(locale, format) {\n    this.locale = locale;\n    this.format = format;\n    this.tokens = expandMacroTokens(_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parseFormat(format), locale);\n    this.units = this.tokens.map((t) => unitForToken(t, locale));\n    this.disqualifyingUnit = this.units.find((t) => t.invalidReason);\n\n    if (!this.disqualifyingUnit) {\n      const [regexString, handlers] = buildRegex(this.units);\n      this.regex = RegExp(regexString, \"i\");\n      this.handlers = handlers;\n    }\n  }\n\n  explainFromTokens(input) {\n    if (!this.isValid) {\n      return { input, tokens: this.tokens, invalidReason: this.invalidReason };\n    } else {\n      const [rawMatches, matches] = match(input, this.regex, this.handlers),\n        [result, zone, specificOffset] = matches\n          ? dateTimeFromMatches(matches)\n          : [null, null, undefined];\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"a\") && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"H\")) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\n          \"Can't include meridiem when specifying 24-hour format\"\n        );\n      }\n      return {\n        input,\n        tokens: this.tokens,\n        regex: this.regex,\n        rawMatches,\n        matches,\n        result,\n        zone,\n        specificOffset,\n      };\n    }\n  }\n\n  get isValid() {\n    return !this.disqualifyingUnit;\n  }\n\n  get invalidReason() {\n    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;\n  }\n}\n\nfunction explainFromTokens(locale, input, format) {\n  const parser = new TokenParser(locale, format);\n  return parser.explainFromTokens(input);\n}\n\nfunction parseFromTokens(locale, input, format) {\n  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);\n  return [result, zone, specificOffset, invalidReason];\n}\n\nfunction formatOptsToTokens(formatOpts, locale) {\n  if (!formatOpts) {\n    return null;\n  }\n\n  const formatter = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(locale, formatOpts);\n  const df = formatter.dtFormatter(getDummyDateTime());\n  const parts = df.formatToParts();\n  const resolvedOpts = df.resolvedOptions();\n  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC90b2tlblBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUc7QUFDNUQ7QUFDbUI7QUFDZDtBQUNOO0FBQ2dCO0FBQ087O0FBRTdEOztBQUVBO0FBQ0EsV0FBVyw0QkFBNEIsdURBQVc7QUFDbEQ7O0FBRUE7QUFDQSx5QkFBeUIsS0FBSztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDRCQUE0QixzREFBWTtBQUNuRDs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxjQUFjLHNEQUFVO0FBQ3hCLFVBQVUsc0RBQVUsUUFBUSxFQUFFO0FBQzlCLFlBQVksc0RBQVUsUUFBUSxFQUFFO0FBQ2hDLFdBQVcsc0RBQVUsUUFBUSxFQUFFO0FBQy9CLFVBQVUsc0RBQVUsUUFBUSxFQUFFO0FBQzlCLGVBQWUsc0RBQVUsUUFBUSxJQUFJO0FBQ3JDLGlCQUFpQixzREFBVSxRQUFRLElBQUk7QUFDdkMsZUFBZSxzREFBVSxRQUFRLElBQUk7QUFDckMsZ0JBQWdCLHNEQUFVLFFBQVEsSUFBSTtBQUN0QyxnQkFBZ0Isc0RBQVUsUUFBUSxJQUFJO0FBQ3RDLGdCQUFnQixzREFBVSxRQUFRLElBQUk7QUFDdEMsd0JBQXdCLHFFQUFxRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9EQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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REFBUTtBQUNqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxREFBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFEQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBYyxrQkFBa0Isd0RBQWM7QUFDeEQsa0JBQWtCLHFFQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSw4Q0FBOEM7QUFDeEQ7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscURBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC90b2tlblBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBwb3N0KHBhcnNlRGlnaXRzKHMpKSB9O1xufVxuXG5jb25zdCBOQlNQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApO1xuY29uc3Qgc3BhY2VPck5CU1AgPSBgWyAke05CU1B9XWA7XG5jb25zdCBzcGFjZU9yTkJTUFJlZ0V4cCA9IG5ldyBSZWdFeHAoc3BhY2VPck5CU1AsIFwiZ1wiKTtcblxuZnVuY3Rpb24gZml4TGlzdFJlZ2V4KHMpIHtcbiAgLy8gbWFrZSBkb3RzIG9wdGlvbmFsIGFuZCBhbHNvIG1ha2UgdGhlbSBsaXRlcmFsXG4gIC8vIG1ha2Ugc3BhY2UgYW5kIG5vbiBicmVha2FibGUgc3BhY2UgY2hhcmFjdGVycyBpbnRlcmNoYW5nZWFibGVcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFwuL2csIFwiXFxcXC4/XCIpLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIHNwYWNlT3JOQlNQKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykge1xuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXC4vZywgXCJcIikgLy8gaWdub3JlIGRvdHMgdGhhdCB3ZXJlIG1hZGUgb3B0aW9uYWxcbiAgICAucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgXCIgXCIpIC8vIGludGVyY2hhbmdlIHNwYWNlIGFuZCBuYnNwXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG9uZU9mKHN0cmluZ3MsIHN0YXJ0SW5kZXgpIHtcbiAgaWYgKHN0cmluZ3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnZXg6IFJlZ0V4cChzdHJpbmdzLm1hcChmaXhMaXN0UmVnZXgpLmpvaW4oXCJ8XCIpKSxcbiAgICAgIGRlc2VyOiAoW3NdKSA9PlxuICAgICAgICBzdHJpbmdzLmZpbmRJbmRleCgoaSkgPT4gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykgPT09IHN0cmlwSW5zZW5zaXRpdml0aWVzKGkpKSArIHN0YXJ0SW5kZXgsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZzZXQocmVnZXgsIGdyb3Vwcykge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbLCBoLCBtXSkgPT4gc2lnbmVkT2Zmc2V0KGgsIG0pLCBncm91cHMgfTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlKHJlZ2V4KSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcyB9O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVUb2tlbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0b2tlblxuICogQHBhcmFtIHtMb2NhbGV9IGxvY1xuICovXG5mdW5jdGlvbiB1bml0Rm9yVG9rZW4odG9rZW4sIGxvYykge1xuICBjb25zdCBvbmUgPSBkaWdpdFJlZ2V4KGxvYyksXG4gICAgdHdvID0gZGlnaXRSZWdleChsb2MsIFwiezJ9XCIpLFxuICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgIGZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NH1cIiksXG4gICAgc2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezZ9XCIpLFxuICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgb25lVG9UaHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDN9XCIpLFxuICAgIG9uZVRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezEsNn1cIiksXG4gICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgdHdvVG9Gb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezIsNH1cIiksXG4gICAgZm91clRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezQsNn1cIiksXG4gICAgbGl0ZXJhbCA9ICh0KSA9PiAoeyByZWdleDogUmVnRXhwKGVzY2FwZVRva2VuKHQudmFsKSksIGRlc2VyOiAoW3NdKSA9PiBzLCBsaXRlcmFsOiB0cnVlIH0pLFxuICAgIHVuaXRhdGUgPSAodCkgPT4ge1xuICAgICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHQudmFsKSB7XG4gICAgICAgIC8vIGVyYVxuICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcInNob3J0XCIpLCAwKTtcbiAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwibG9uZ1wiKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBkYXRlc1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gb3JkaW5hbHNcbiAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgLy8gdGltZVxuICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVUb05pbmUpO1xuICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIC8vIG1lcmlkaWVtXG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tZXJpZGllbXMoKSwgMCk7XG4gICAgICAgIC8vIHdlZWtZZWFyIChrKVxuICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgLy8gd2Vla051bWJlciAoVylcbiAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIHdlZWtkYXlzXG4gICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgLy8gb2Zmc2V0L3pvbmVcbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoPzo6KCR7dHdvLnNvdXJjZX0pKT9gKSwgMik7XG4gICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSgke3R3by5zb3VyY2V9KT9gKSwgMik7XG4gICAgICAgIC8vIHdlIGRvbid0IHN1cHBvcnQgWlpaWiAoUFNUKSBvciBaWlpaWiAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKSBpbiBwYXJzaW5nXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGFyZVxuICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1thLXpfKy0vXXsxLDI1Nn0/L2kpO1xuICAgICAgICAvLyB0aGlzIHNwZWNpYWwtY2FzZSBcInRva2VuXCIgcmVwcmVzZW50cyBhIHBsYWNlIHdoZXJlIGEgbWFjcm8tdG9rZW4gZXhwYW5kZWQgaW50byBhIHdoaXRlLXNwYWNlIGxpdGVyYWxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGFjY2VwdCBhbnkgbm9uLW5ld2xpbmUgd2hpdGUtc3BhY2VcbiAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bXlxcU1xcblxccl0vKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGNvbnN0IHVuaXQgPSB1bml0YXRlKHRva2VuKSB8fCB7XG4gICAgaW52YWxpZFJlYXNvbjogTUlTU0lOR19GVFAsXG4gIH07XG5cbiAgdW5pdC50b2tlbiA9IHRva2VuO1xuXG4gIHJldHVybiB1bml0O1xufVxuXG5jb25zdCBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbCA9IHtcbiAgeWVhcjoge1xuICAgIFwiMi1kaWdpdFwiOiBcInl5XCIsXG4gICAgbnVtZXJpYzogXCJ5eXl5eVwiLFxuICB9LFxuICBtb250aDoge1xuICAgIG51bWVyaWM6IFwiTVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIk1NXCIsXG4gICAgc2hvcnQ6IFwiTU1NXCIsXG4gICAgbG9uZzogXCJNTU1NXCIsXG4gIH0sXG4gIGRheToge1xuICAgIG51bWVyaWM6IFwiZFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImRkXCIsXG4gIH0sXG4gIHdlZWtkYXk6IHtcbiAgICBzaG9ydDogXCJFRUVcIixcbiAgICBsb25nOiBcIkVFRUVcIixcbiAgfSxcbiAgZGF5cGVyaW9kOiBcImFcIixcbiAgZGF5UGVyaW9kOiBcImFcIixcbiAgaG91cjEyOiB7XG4gICAgbnVtZXJpYzogXCJoXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiaGhcIixcbiAgfSxcbiAgaG91cjI0OiB7XG4gICAgbnVtZXJpYzogXCJIXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiSEhcIixcbiAgfSxcbiAgbWludXRlOiB7XG4gICAgbnVtZXJpYzogXCJtXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwibW1cIixcbiAgfSxcbiAgc2Vjb25kOiB7XG4gICAgbnVtZXJpYzogXCJzXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwic3NcIixcbiAgfSxcbiAgdGltZVpvbmVOYW1lOiB7XG4gICAgbG9uZzogXCJaWlpaWlwiLFxuICAgIHNob3J0OiBcIlpaWlwiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvXlxccyskLy50ZXN0KHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogIWlzU3BhY2UsXG4gICAgICB2YWw6IGlzU3BhY2UgPyBcIiBcIiA6IHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IGZvcm1hdE9wdHNbdHlwZV07XG5cbiAgLy8gVGhlIHVzZXIgbWlnaHQgaGF2ZSBleHBsaWNpdGx5IHNwZWNpZmllZCBob3VyMTIgb3IgaG91ckN5Y2xlXG4gIC8vIGlmIHNvLCByZXNwZWN0IHRoZWlyIGRlY2lzaW9uXG4gIC8vIGlmIG5vdCwgcmVmZXIgYmFjayB0byB0aGUgcmVzb2x2ZWRPcHRzLCB3aGljaCBhcmUgYmFzZWQgb24gdGhlIGxvY2FsZVxuICBsZXQgYWN0dWFsVHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlID09PSBcImhvdXJcIikge1xuICAgIGlmIChmb3JtYXRPcHRzLmhvdXIxMiAhPSBudWxsKSB7XG4gICAgICBhY3R1YWxUeXBlID0gZm9ybWF0T3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlICE9IG51bGwpIHtcbiAgICAgIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTFcIiB8fCBmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTJcIikge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMTJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIyNFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b2tlbnMgb25seSBkaWZmZXJlbnRpYXRlIGJldHdlZW4gMjQgaG91cnMgb3Igbm90LFxuICAgICAgLy8gc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaG91ckN5Y2xlIGhlcmUsIHdoaWNoIGlzIGxlc3Mgc3VwcG9ydGVkIGFueXdheXNcbiAgICAgIGFjdHVhbFR5cGUgPSByZXNvbHZlZE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfVxuICB9XG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFthY3R1YWxUeXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpO1xuXG4gIGlmICh0b2tlbnMgPT0gbnVsbCB8fCB0b2tlbnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKCh0KSA9PiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKSkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNsYXNzIFRva2VuUGFyc2VyIHtcbiAgY29uc3RydWN0b3IobG9jYWxlLCBmb3JtYXQpIHtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLnRva2VucyA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmb3JtYXQpLCBsb2NhbGUpO1xuICAgIHRoaXMudW5pdHMgPSB0aGlzLnRva2Vucy5tYXAoKHQpID0+IHVuaXRGb3JUb2tlbih0LCBsb2NhbGUpKTtcbiAgICB0aGlzLmRpc3F1YWxpZnlpbmdVbml0ID0gdGhpcy51bml0cy5maW5kKCh0KSA9PiB0LmludmFsaWRSZWFzb24pO1xuXG4gICAgaWYgKCF0aGlzLmRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgICBjb25zdCBbcmVnZXhTdHJpbmcsIGhhbmRsZXJzXSA9IGJ1aWxkUmVnZXgodGhpcy51bml0cyk7XG4gICAgICB0aGlzLnJlZ2V4ID0gUmVnRXhwKHJlZ2V4U3RyaW5nLCBcImlcIik7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgfVxuICB9XG5cbiAgZXhwbGFpbkZyb21Ub2tlbnMoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHsgaW5wdXQsIHRva2VuczogdGhpcy50b2tlbnMsIGludmFsaWRSZWFzb246IHRoaXMuaW52YWxpZFJlYXNvbiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbcmF3TWF0Y2hlcywgbWF0Y2hlc10gPSBtYXRjaChpbnB1dCwgdGhpcy5yZWdleCwgdGhpcy5oYW5kbGVycyksXG4gICAgICAgIFtyZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XSA9IG1hdGNoZXNcbiAgICAgICAgICA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcylcbiAgICAgICAgICA6IFtudWxsLCBudWxsLCB1bmRlZmluZWRdO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiYVwiKSAmJiBoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcIkhcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHRva2VuczogdGhpcy50b2tlbnMsXG4gICAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4LFxuICAgICAgICByYXdNYXRjaGVzLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHpvbmUsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0LFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZGlzcXVhbGlmeWluZ1VuaXQ7XG4gIH1cblxuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNxdWFsaWZ5aW5nVW5pdCA/IHRoaXMuZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiA6IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgVG9rZW5QYXJzZXIobG9jYWxlLCBmb3JtYXQpO1xuICByZXR1cm4gcGFyc2VyLmV4cGxhaW5Gcm9tVG9rZW5zKGlucHV0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgeyByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uIH0gPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpO1xuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb25dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIGxvY2FsZSkge1xuICBpZiAoIWZvcm1hdE9wdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlciA9IEZvcm1hdHRlci5jcmVhdGUobG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgY29uc3QgZGYgPSBmb3JtYXR0ZXIuZHRGb3JtYXR0ZXIoZ2V0RHVtbXlEYXRlVGltZSgpKTtcbiAgY29uc3QgcGFydHMgPSBkZi5mb3JtYXRUb1BhcnRzKCk7XG4gIGNvbnN0IHJlc29sdmVkT3B0cyA9IGRmLnJlc29sdmVkT3B0aW9ucygpO1xuICByZXR1cm4gcGFydHMubWFwKChwKSA9PiB0b2tlbkZvclBhcnQocCwgZm9ybWF0T3B0cywgcmVzb2x2ZWRPcHRzKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/tokenParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js":
/*!*********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asNumber: () => (/* binding */ asNumber),\n/* harmony export */   bestBy: () => (/* binding */ bestBy),\n/* harmony export */   daysInMonth: () => (/* binding */ daysInMonth),\n/* harmony export */   daysInYear: () => (/* binding */ daysInYear),\n/* harmony export */   floorMod: () => (/* binding */ floorMod),\n/* harmony export */   formatOffset: () => (/* binding */ formatOffset),\n/* harmony export */   hasLocaleWeekInfo: () => (/* binding */ hasLocaleWeekInfo),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasRelative: () => (/* binding */ hasRelative),\n/* harmony export */   integerBetween: () => (/* binding */ integerBetween),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isLeapYear: () => (/* binding */ isLeapYear),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   maybeArray: () => (/* binding */ maybeArray),\n/* harmony export */   normalizeObject: () => (/* binding */ normalizeObject),\n/* harmony export */   objToLocalTS: () => (/* binding */ objToLocalTS),\n/* harmony export */   padStart: () => (/* binding */ padStart),\n/* harmony export */   parseFloating: () => (/* binding */ parseFloating),\n/* harmony export */   parseInteger: () => (/* binding */ parseInteger),\n/* harmony export */   parseMillis: () => (/* binding */ parseMillis),\n/* harmony export */   parseZoneInfo: () => (/* binding */ parseZoneInfo),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   roundTo: () => (/* binding */ roundTo),\n/* harmony export */   signedOffset: () => (/* binding */ signedOffset),\n/* harmony export */   timeObject: () => (/* binding */ timeObject),\n/* harmony export */   untruncateYear: () => (/* binding */ untruncateYear),\n/* harmony export */   validateWeekSettings: () => (/* binding */ validateWeekSettings),\n/* harmony export */   weeksInWeekYear: () => (/* binding */ weeksInWeekYear)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _conversions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conversions.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/conversions.js\");\n/*\n  This is just a junk drawer, containing anything used across multiple classes.\n  Because Luxon is small(ish), this should stay small and we won't worry about splitting\n  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.\n*/\n\n\n\n\n\n/**\n * @private\n */\n\n// TYPES\n\nfunction isUndefined(o) {\n  return typeof o === \"undefined\";\n}\n\nfunction isNumber(o) {\n  return typeof o === \"number\";\n}\n\nfunction isInteger(o) {\n  return typeof o === \"number\" && o % 1 === 0;\n}\n\nfunction isString(o) {\n  return typeof o === \"string\";\n}\n\nfunction isDate(o) {\n  return Object.prototype.toString.call(o) === \"[object Date]\";\n}\n\n// CAPABILITIES\n\nfunction hasRelative() {\n  try {\n    return typeof Intl !== \"undefined\" && !!Intl.RelativeTimeFormat;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction hasLocaleWeekInfo() {\n  try {\n    return (\n      typeof Intl !== \"undefined\" &&\n      !!Intl.Locale &&\n      (\"weekInfo\" in Intl.Locale.prototype || \"getWeekInfo\" in Intl.Locale.prototype)\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\n// OBJECTS AND ARRAYS\n\nfunction maybeArray(thing) {\n  return Array.isArray(thing) ? thing : [thing];\n}\n\nfunction bestBy(arr, by, compare) {\n  if (arr.length === 0) {\n    return undefined;\n  }\n  return arr.reduce((best, next) => {\n    const pair = [by(next), next];\n    if (!best) {\n      return pair;\n    } else if (compare(best[0], pair[0]) === best[0]) {\n      return best;\n    } else {\n      return pair;\n    }\n  }, null)[1];\n}\n\nfunction pick(obj, keys) {\n  return keys.reduce((a, k) => {\n    a[k] = obj[k];\n    return a;\n  }, {});\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction validateWeekSettings(settings) {\n  if (settings == null) {\n    return null;\n  } else if (typeof settings !== \"object\") {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Week settings must be an object\");\n  } else {\n    if (\n      !integerBetween(settings.firstDay, 1, 7) ||\n      !integerBetween(settings.minimalDays, 1, 7) ||\n      !Array.isArray(settings.weekend) ||\n      settings.weekend.some((v) => !integerBetween(v, 1, 7))\n    ) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Invalid week settings\");\n    }\n    return {\n      firstDay: settings.firstDay,\n      minimalDays: settings.minimalDays,\n      weekend: Array.from(settings.weekend),\n    };\n  }\n}\n\n// NUMBERS AND STRINGS\n\nfunction integerBetween(thing, bottom, top) {\n  return isInteger(thing) && thing >= bottom && thing <= top;\n}\n\n// x % n but takes the sign of n instead of x\nfunction floorMod(x, n) {\n  return x - n * Math.floor(x / n);\n}\n\nfunction padStart(input, n = 2) {\n  const isNeg = input < 0;\n  let padded;\n  if (isNeg) {\n    padded = \"-\" + (\"\" + -input).padStart(n, \"0\");\n  } else {\n    padded = (\"\" + input).padStart(n, \"0\");\n  }\n  return padded;\n}\n\nfunction parseInteger(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseInt(string, 10);\n  }\n}\n\nfunction parseFloating(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseFloat(string);\n  }\n}\n\nfunction parseMillis(fraction) {\n  // Return undefined (instead of 0) in these cases, where fraction is not set\n  if (isUndefined(fraction) || fraction === null || fraction === \"\") {\n    return undefined;\n  } else {\n    const f = parseFloat(\"0.\" + fraction) * 1000;\n    return Math.floor(f);\n  }\n}\n\nfunction roundTo(number, digits, rounding = \"round\") {\n  const factor = 10 ** digits;\n  switch (rounding) {\n    case \"expand\":\n      return number > 0\n        ? Math.ceil(number * factor) / factor\n        : Math.floor(number * factor) / factor;\n    case \"trunc\":\n      return Math.trunc(number * factor) / factor;\n    case \"round\":\n      return Math.round(number * factor) / factor;\n    case \"floor\":\n      return Math.floor(number * factor) / factor;\n    case \"ceil\":\n      return Math.ceil(number * factor) / factor;\n    default:\n      throw new RangeError(`Value rounding ${rounding} is out of range`);\n  }\n}\n\n// DATE BASICS\n\nfunction isLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\nfunction daysInYear(year) {\n  return isLeapYear(year) ? 366 : 365;\n}\n\nfunction daysInMonth(year, month) {\n  const modMonth = floorMod(month - 1, 12) + 1,\n    modYear = year + (month - modMonth) / 12;\n\n  if (modMonth === 2) {\n    return isLeapYear(modYear) ? 29 : 28;\n  } else {\n    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];\n  }\n}\n\n// convert a calendar object to a local timestamp (epoch, but with the offset baked in)\nfunction objToLocalTS(obj) {\n  let d = Date.UTC(\n    obj.year,\n    obj.month - 1,\n    obj.day,\n    obj.hour,\n    obj.minute,\n    obj.second,\n    obj.millisecond\n  );\n\n  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that\n  if (obj.year < 100 && obj.year >= 0) {\n    d = new Date(d);\n    // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not\n    // so if obj.year is in 99, but obj.day makes it roll over into year 100,\n    // the calculations done by Date.UTC are using year 2000 - which is incorrect\n    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);\n  }\n  return +d;\n}\n\n// adapted from moment.js: https://github.com/moment/moment/blob/000ac1800e620f770f4eb31b5ae908f6167b0ab2/src/lib/units/week-calendar-utils.js\nfunction firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {\n  const fwdlw = (0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.isoWeekdayToLocal)((0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.dayOfWeek)(year, 1, minDaysInFirstWeek), startOfWeek);\n  return -fwdlw + minDaysInFirstWeek - 1;\n}\n\nfunction weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);\n  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);\n  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;\n}\n\nfunction untruncateYear(year) {\n  if (year > 99) {\n    return year;\n  } else return year > _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].twoDigitCutoffYear ? 1900 + year : 2000 + year;\n}\n\n// PARSING\n\nfunction parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {\n  const date = new Date(ts),\n    intlOpts = {\n      hourCycle: \"h23\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    };\n\n  if (timeZone) {\n    intlOpts.timeZone = timeZone;\n  }\n\n  const modified = { timeZoneName: offsetFormat, ...intlOpts };\n\n  const parsed = new Intl.DateTimeFormat(locale, modified)\n    .formatToParts(date)\n    .find((m) => m.type.toLowerCase() === \"timezonename\");\n  return parsed ? parsed.value : null;\n}\n\n// signedOffset('-5', '30') -> -330\nfunction signedOffset(offHourStr, offMinuteStr) {\n  let offHour = parseInt(offHourStr, 10);\n\n  // don't || this because we want to preserve -0\n  if (Number.isNaN(offHour)) {\n    offHour = 0;\n  }\n\n  const offMin = parseInt(offMinuteStr, 10) || 0,\n    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;\n  return offHour * 60 + offMinSigned;\n}\n\n// COERCION\n\nfunction asNumber(value) {\n  const numericValue = Number(value);\n  if (typeof value === \"boolean\" || value === \"\" || !Number.isFinite(numericValue))\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(`Invalid unit value ${value}`);\n  return numericValue;\n}\n\nfunction normalizeObject(obj, normalizer) {\n  const normalized = {};\n  for (const u in obj) {\n    if (hasOwnProperty(obj, u)) {\n      const v = obj[u];\n      if (v === undefined || v === null) continue;\n      normalized[normalizer(u)] = asNumber(v);\n    }\n  }\n  return normalized;\n}\n\n/**\n * Returns the offset's value as a string\n * @param {number} ts - Epoch milliseconds for which to get the offset\n * @param {string} format - What style of offset to return.\n *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n * @return {string}\n */\nfunction formatOffset(offset, format) {\n  const hours = Math.trunc(Math.abs(offset / 60)),\n    minutes = Math.trunc(Math.abs(offset % 60)),\n    sign = offset >= 0 ? \"+\" : \"-\";\n\n  switch (format) {\n    case \"short\":\n      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;\n    case \"narrow\":\n      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : \"\"}`;\n    case \"techie\":\n      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;\n    default:\n      throw new RangeError(`Value format ${format} is out of range for property format`);\n  }\n}\n\nfunction timeObject(obj) {\n  return pick(obj, [\"hour\", \"minute\", \"second\", \"millisecond\"]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRDtBQUNkO0FBQzBCOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDREQUFvQjtBQUNsQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWlCLENBQUMsMERBQVM7QUFDM0M7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUksbUJBQW1CLG9EQUFRO0FBQy9COztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGNBQWMsNERBQW9CLHVCQUF1QixNQUFNO0FBQy9EO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSyxFQUFFLG1CQUFtQixHQUFHLHFCQUFxQjtBQUNsRTtBQUNBLGdCQUFnQixLQUFLLEVBQUUsTUFBTSxFQUFFLGtCQUFrQixRQUFRLE9BQU87QUFDaEU7QUFDQSxnQkFBZ0IsS0FBSyxFQUFFLG1CQUFtQixFQUFFLHFCQUFxQjtBQUNqRTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGhpcyBpcyBqdXN0IGEganVuayBkcmF3ZXIsIGNvbnRhaW5pbmcgYW55dGhpbmcgdXNlZCBhY3Jvc3MgbXVsdGlwbGUgY2xhc3Nlcy5cbiAgQmVjYXVzZSBMdXhvbiBpcyBzbWFsbChpc2gpLCB0aGlzIHNob3VsZCBzdGF5IHNtYWxsIGFuZCB3ZSB3b24ndCB3b3JyeSBhYm91dCBzcGxpdHRpbmdcbiAgaXQgdXAgaW50bywgc2F5LCBwYXJzaW5nVXRpbC5qcyBhbmQgYmFzaWNVdGlsLmpzIGFuZCBzbyBvbi4gQnV0IHRoZXkgYXJlIGRpdmlkZWQgdXAgYnkgZmVhdHVyZSBhcmVhLlxuKi9cblxuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgeyBkYXlPZldlZWssIGlzb1dlZWtkYXlUb0xvY2FsIH0gZnJvbSBcIi4vY29udmVyc2lvbnMuanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8vIFRZUEVTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiICYmIG8gJSAxID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbn1cblxuLy8gQ0FQQUJJTElUSUVTXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNSZWxhdGl2ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgISFJbnRsLlJlbGF0aXZlVGltZUZvcm1hdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9jYWxlV2Vla0luZm8oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAhIUludGwuTG9jYWxlICYmXG4gICAgICAoXCJ3ZWVrSW5mb1wiIGluIEludGwuTG9jYWxlLnByb3RvdHlwZSB8fCBcImdldFdlZWtJbmZvXCIgaW4gSW50bC5Mb2NhbGUucHJvdG90eXBlKVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gT0JKRUNUUyBBTkQgQVJSQVlTXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IHRoaW5nIDogW3RoaW5nXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlc3RCeShhcnIsIGJ5LCBjb21wYXJlKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyLnJlZHVjZSgoYmVzdCwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBbYnkobmV4dCksIG5leHRdO1xuICAgIGlmICghYmVzdCkge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSBlbHNlIGlmIChjb21wYXJlKGJlc3RbMF0sIHBhaXJbMF0pID09PSBiZXN0WzBdKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfVxuICB9LCBudWxsKVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYSwgaykgPT4ge1xuICAgIGFba10gPSBvYmpba107XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVdlZWtTZXR0aW5ncyhzZXR0aW5ncykge1xuICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIldlZWsgc2V0dGluZ3MgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgIWludGVnZXJCZXR3ZWVuKHNldHRpbmdzLmZpcnN0RGF5LCAxLCA3KSB8fFxuICAgICAgIWludGVnZXJCZXR3ZWVuKHNldHRpbmdzLm1pbmltYWxEYXlzLCAxLCA3KSB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkoc2V0dGluZ3Mud2Vla2VuZCkgfHxcbiAgICAgIHNldHRpbmdzLndlZWtlbmQuc29tZSgodikgPT4gIWludGVnZXJCZXR3ZWVuKHYsIDEsIDcpKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiSW52YWxpZCB3ZWVrIHNldHRpbmdzXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3REYXk6IHNldHRpbmdzLmZpcnN0RGF5LFxuICAgICAgbWluaW1hbERheXM6IHNldHRpbmdzLm1pbmltYWxEYXlzLFxuICAgICAgd2Vla2VuZDogQXJyYXkuZnJvbShzZXR0aW5ncy53ZWVrZW5kKSxcbiAgICB9O1xuICB9XG59XG5cbi8vIE5VTUJFUlMgQU5EIFNUUklOR1NcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVnZXJCZXR3ZWVuKHRoaW5nLCBib3R0b20sIHRvcCkge1xuICByZXR1cm4gaXNJbnRlZ2VyKHRoaW5nKSAmJiB0aGluZyA+PSBib3R0b20gJiYgdGhpbmcgPD0gdG9wO1xufVxuXG4vLyB4ICUgbiBidXQgdGFrZXMgdGhlIHNpZ24gb2YgbiBpbnN0ZWFkIG9mIHhcbmV4cG9ydCBmdW5jdGlvbiBmbG9vck1vZCh4LCBuKSB7XG4gIHJldHVybiB4IC0gbiAqIE1hdGguZmxvb3IoeCAvIG4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RhcnQoaW5wdXQsIG4gPSAyKSB7XG4gIGNvbnN0IGlzTmVnID0gaW5wdXQgPCAwO1xuICBsZXQgcGFkZGVkO1xuICBpZiAoaXNOZWcpIHtcbiAgICBwYWRkZWQgPSBcIi1cIiArIChcIlwiICsgLWlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFkZGVkID0gKFwiXCIgKyBpbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9XG4gIHJldHVybiBwYWRkZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGbG9hdGluZyhzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNaWxsaXMoZnJhY3Rpb24pIHtcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCAoaW5zdGVhZCBvZiAwKSBpbiB0aGVzZSBjYXNlcywgd2hlcmUgZnJhY3Rpb24gaXMgbm90IHNldFxuICBpZiAoaXNVbmRlZmluZWQoZnJhY3Rpb24pIHx8IGZyYWN0aW9uID09PSBudWxsIHx8IGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmID0gcGFyc2VGbG9hdChcIjAuXCIgKyBmcmFjdGlvbikgKiAxMDAwO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGYpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvKG51bWJlciwgZGlnaXRzLCByb3VuZGluZyA9IFwicm91bmRcIikge1xuICBjb25zdCBmYWN0b3IgPSAxMCAqKiBkaWdpdHM7XG4gIHN3aXRjaCAocm91bmRpbmcpIHtcbiAgICBjYXNlIFwiZXhwYW5kXCI6XG4gICAgICByZXR1cm4gbnVtYmVyID4gMFxuICAgICAgICA/IE1hdGguY2VpbChudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yXG4gICAgICAgIDogTWF0aC5mbG9vcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNhc2UgXCJ0cnVuY1wiOlxuICAgICAgcmV0dXJuIE1hdGgudHJ1bmMobnVtYmVyICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgY2FzZSBcImZsb29yXCI6XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNhc2UgXCJjZWlsXCI6XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBWYWx1ZSByb3VuZGluZyAke3JvdW5kaW5nfSBpcyBvdXQgb2YgcmFuZ2VgKTtcbiAgfVxufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBsb2NhbCB0aW1lc3RhbXAgKGVwb2NoLCBidXQgd2l0aCB0aGUgb2Zmc2V0IGJha2VkIGluKVxuZXhwb3J0IGZ1bmN0aW9uIG9ialRvTG9jYWxUUyhvYmopIHtcbiAgbGV0IGQgPSBEYXRlLlVUQyhcbiAgICBvYmoueWVhcixcbiAgICBvYmoubW9udGggLSAxLFxuICAgIG9iai5kYXksXG4gICAgb2JqLmhvdXIsXG4gICAgb2JqLm1pbnV0ZSxcbiAgICBvYmouc2Vjb25kLFxuICAgIG9iai5taWxsaXNlY29uZFxuICApO1xuXG4gIC8vIGZvciBsZWdhY3kgcmVhc29ucywgeWVhcnMgYmV0d2VlbiAwIGFuZCA5OSBhcmUgaW50ZXJwcmV0ZWQgYXMgMTlYWDsgcmV2ZXJ0IHRoYXRcbiAgaWYgKG9iai55ZWFyIDwgMTAwICYmIG9iai55ZWFyID49IDApIHtcbiAgICBkID0gbmV3IERhdGUoZCk7XG4gICAgLy8gc2V0IHRoZSBtb250aCBhbmQgZGF5IGFnYWluLCB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHllYXIgMjAwMCBpcyBhIGxlYXAgeWVhciwgYnV0IHllYXIgMTAwIGlzIG5vdFxuICAgIC8vIHNvIGlmIG9iai55ZWFyIGlzIGluIDk5LCBidXQgb2JqLmRheSBtYWtlcyBpdCByb2xsIG92ZXIgaW50byB5ZWFyIDEwMCxcbiAgICAvLyB0aGUgY2FsY3VsYXRpb25zIGRvbmUgYnkgRGF0ZS5VVEMgYXJlIHVzaW5nIHllYXIgMjAwMCAtIHdoaWNoIGlzIGluY29ycmVjdFxuICAgIGQuc2V0VVRDRnVsbFllYXIob2JqLnllYXIsIG9iai5tb250aCAtIDEsIG9iai5kYXkpO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuLy8gYWRhcHRlZCBmcm9tIG1vbWVudC5qczogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvYmxvYi8wMDBhYzE4MDBlNjIwZjc3MGY0ZWIzMWI1YWU5MDhmNjE2N2IwYWIyL3NyYy9saWIvdW5pdHMvd2Vlay1jYWxlbmRhci11dGlscy5qc1xuZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspIHtcbiAgY29uc3QgZndkbHcgPSBpc29XZWVrZGF5VG9Mb2NhbChkYXlPZldlZWsoeWVhciwgMSwgbWluRGF5c0luRmlyc3RXZWVrKSwgc3RhcnRPZldlZWspO1xuICByZXR1cm4gLWZ3ZGx3ICsgbWluRGF5c0luRmlyc3RXZWVrIC0gMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICBjb25zdCB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh3ZWVrWWVhciArIDEsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICByZXR1cm4gKGRheXNJblllYXIod2Vla1llYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyKSB7XG4gIGlmICh5ZWFyID4gOTkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHJldHVybiB5ZWFyID4gU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID8gMTkwMCArIHllYXIgOiAyMDAwICsgeWVhcjtcbn1cblxuLy8gUEFSU0lOR1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Vab25lSW5mbyh0cywgb2Zmc2V0Rm9ybWF0LCBsb2NhbGUsIHRpbWVab25lID0gbnVsbCkge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpLFxuICAgIGludGxPcHRzID0ge1xuICAgICAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIH07XG5cbiAgaWYgKHRpbWVab25lKSB7XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSB0aW1lWm9uZTtcbiAgfVxuXG4gIGNvbnN0IG1vZGlmaWVkID0geyB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdCwgLi4uaW50bE9wdHMgfTtcblxuICBjb25zdCBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKVxuICAgIC5mb3JtYXRUb1BhcnRzKGRhdGUpXG4gICAgLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInRpbWV6b25lbmFtZVwiKTtcbiAgcmV0dXJuIHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IG51bGw7XG59XG5cbi8vIHNpZ25lZE9mZnNldCgnLTUnLCAnMzAnKSAtPiAtMzMwXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cikge1xuICBsZXQgb2ZmSG91ciA9IHBhcnNlSW50KG9mZkhvdXJTdHIsIDEwKTtcblxuICAvLyBkb24ndCB8fCB0aGlzIGJlY2F1c2Ugd2Ugd2FudCB0byBwcmVzZXJ2ZSAtMFxuICBpZiAoTnVtYmVyLmlzTmFOKG9mZkhvdXIpKSB7XG4gICAgb2ZmSG91ciA9IDA7XG4gIH1cblxuICBjb25zdCBvZmZNaW4gPSBwYXJzZUludChvZmZNaW51dGVTdHIsIDEwKSB8fCAwLFxuICAgIG9mZk1pblNpZ25lZCA9IG9mZkhvdXIgPCAwIHx8IE9iamVjdC5pcyhvZmZIb3VyLCAtMCkgPyAtb2ZmTWluIDogb2ZmTWluO1xuICByZXR1cm4gb2ZmSG91ciAqIDYwICsgb2ZmTWluU2lnbmVkO1xufVxuXG4vLyBDT0VSQ0lPTlxuXG5leHBvcnQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgY29uc3QgbnVtZXJpY1ZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT09IFwiXCIgfHwgIU51bWJlci5pc0Zpbml0ZShudW1lcmljVmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCB1bml0IHZhbHVlICR7dmFsdWV9YCk7XG4gIHJldHVybiBudW1lcmljVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBjb25zdCB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9mZnNldChvZmZzZXQsIGZvcm1hdCkge1xuICBjb25zdCBob3VycyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0IC8gNjApKSxcbiAgICBtaW51dGVzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgJSA2MCkpLFxuICAgIHNpZ24gPSBvZmZzZXQgPj0gMCA/IFwiK1wiIDogXCItXCI7XG5cbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtob3Vyc30ke21pbnV0ZXMgPiAwID8gYDoke21pbnV0ZXN9YCA6IFwiXCJ9YDtcbiAgICBjYXNlIFwidGVjaGllXCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX0ke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBWYWx1ZSBmb3JtYXQgJHtmb3JtYXR9IGlzIG91dCBvZiByYW5nZSBmb3IgcHJvcGVydHkgZm9ybWF0YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVPYmplY3Qob2JqKSB7XG4gIHJldHVybiBwaWNrKG9iaiwgW1wiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/zoneUtil.js":
/*!*************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/impl/zoneUtil.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeZone: () => (/* binding */ normalizeZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/invalidZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../zones/systemZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/systemZone.js\");\n/**\n * @private\n */\n\n\n\n\n\n\n\n\n\nfunction normalizeZone(input, defaultZone) {\n  let offset;\n  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(input) || input === null) {\n    return defaultZone;\n  } else if (input instanceof _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    return input;\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isString)(input)) {\n    const lowered = input.toLowerCase();\n    if (lowered === \"default\") return defaultZone;\n    else if (lowered === \"local\" || lowered === \"system\") return _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance;\n    else if (lowered === \"utc\" || lowered === \"gmt\") return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance;\n    else return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parseSpecifier(lowered) || _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(input);\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(input)) {\n    return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(input);\n  } else if (typeof input === \"object\" && \"offset\" in input && typeof input.offset === \"function\") {\n    // This is dumb, but the instanceof check above doesn't seem to really work\n    // so we're duck checking it\n    return input;\n  } else {\n    return new _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](input);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC96b25lVXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUU4QjtBQUNjO0FBQ2M7QUFDUjs7QUFFVTtBQUNaOztBQUV6QztBQUNQO0FBQ0EsTUFBTSxxREFBVztBQUNqQjtBQUNBLElBQUksMEJBQTBCLGdEQUFJO0FBQ2xDO0FBQ0EsSUFBSSxTQUFTLGtEQUFRO0FBQ3JCO0FBQ0E7QUFDQSxpRUFBaUUsNERBQVU7QUFDM0UsNERBQTRELGlFQUFlO0FBQzNFLGdCQUFnQixpRUFBZSw0QkFBNEIsMERBQVE7QUFDbkUsSUFBSSxTQUFTLGtEQUFRO0FBQ3JCLFdBQVcsaUVBQWU7QUFDMUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlLDZEQUFXO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcblxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVab25lKGlucHV0LCBkZWZhdWx0Wm9uZSkge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRab25lO1xuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgWm9uZSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICBjb25zdCBsb3dlcmVkID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJlZCA9PT0gXCJkZWZhdWx0XCIpIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcImxvY2FsXCIgfHwgbG93ZXJlZCA9PT0gXCJzeXN0ZW1cIikgcmV0dXJuIFN5c3RlbVpvbmUuaW5zdGFuY2U7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJ1dGNcIiB8fCBsb3dlcmVkID09PSBcImdtdFwiKSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIGVsc2UgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihsb3dlcmVkKSB8fCBJQU5BWm9uZS5jcmVhdGUoaW5wdXQpO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgIHJldHVybiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBcIm9mZnNldFwiIGluIGlucHV0ICYmIHR5cGVvZiBpbnB1dC5vZmZzZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIFRoaXMgaXMgZHVtYiwgYnV0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byByZWFsbHkgd29ya1xuICAgIC8vIHNvIHdlJ3JlIGR1Y2sgY2hlY2tpbmcgaXRcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/zoneUtil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/info.js":
/*!****************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/info.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Info)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n\n\n\n\n\n\n\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nclass Info {\n  /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */\n  static hasDST(zone = _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone) {\n    const proto = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].now().setZone(zone).set({ month: 12 });\n\n    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;\n  }\n\n  /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */\n  static isValidIANAZone(zone) {\n    return _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isValidZone(zone);\n  }\n\n  /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone#isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */\n  static normalizeZone(input) {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(input, _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone);\n  }\n\n  /**\n   * Get the weekday on which the week starts according to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday\n   */\n  static getStartOfWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getStartOfWeek();\n  }\n\n  /**\n   * Get the minimum number of days necessary in a week before it is considered part of the next year according\n   * to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number}\n   */\n  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getMinDaysInFirstWeek();\n  }\n\n  /**\n   * Get the weekdays, which are considered the weekend according to the given locale\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday\n   */\n  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {\n    // copy the array, because we cache it internally\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getWeekendDays().slice();\n  }\n\n  /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'\n   * @return {Array}\n   */\n  static months(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length);\n  }\n\n  /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link Info#months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {Array}\n   */\n  static monthsFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length, true);\n  }\n\n  /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''\n   * @return {Array}\n   */\n  static weekdays(length = \"long\", { locale = null, numberingSystem = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length);\n  }\n\n  /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link Info#weekdays}\n   * @param {string} [length='long'] - the length of the month representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @return {Array}\n   */\n  static weekdaysFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length, true);\n  }\n\n  /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]\n   * @return {Array}\n   */\n  static meridiems({ locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale).meridiems();\n  }\n\n  /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\n   * @return {Array}\n   */\n  static eras(length = \"short\", { locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, null, \"gregory\").eras(length);\n  }\n\n  /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `relative`: whether this environment supports relative time formatting\n   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale\n   * @example Info.features() //=> { relative: false, localeWeek: true }\n   * @return {Object}\n   */\n  static features() {\n    return { relative: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasRelative)(), localeWeek: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasLocaleWeekInfo)() };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFDO0FBQ0E7QUFDQztBQUNLO0FBQ1E7O0FBRWE7O0FBRWhFO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQSx1QkFBdUIsb0RBQVE7QUFDL0Isa0JBQWtCLG9EQUFRLDJCQUEyQixXQUFXOztBQUVoRSw2REFBNkQsVUFBVTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVywwREFBUTtBQUNuQjs7QUFFQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVyxnRUFBYSxRQUFRLG9EQUFRO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQSwwQkFBMEIsK0JBQStCLElBQUk7QUFDN0Qsc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBLHFDQUFxQywrQkFBK0IsSUFBSTtBQUN4RSxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLDhCQUE4QiwrQkFBK0IsSUFBSTtBQUNqRTtBQUNBLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZELHVDQUF1QyxjQUFjO0FBQ3JELG9DQUFvQywyQkFBMkI7QUFDL0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUZBQW1GO0FBQ3pGO0FBQ0Esc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1GQUFtRjtBQUN6RjtBQUNBLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hELHVDQUF1QyxjQUFjO0FBQ3JELGNBQWM7QUFDZDtBQUNBLHFDQUFxQyx1REFBdUQsSUFBSTtBQUNoRyxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBdUQ7QUFDN0Q7QUFDQSxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxjQUFjO0FBQ2Q7QUFDQSxxQkFBcUIsZ0JBQWdCLElBQUk7QUFDekMsV0FBVyx1REFBTTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELGNBQWM7QUFDZDtBQUNBLGtDQUFrQyxnQkFBZ0IsSUFBSTtBQUN0RCxXQUFXLHVEQUFNO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsVUFBVSwwREFBVyxnQkFBZ0IsZ0VBQWlCO0FBQ25FO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2luZm8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxuaW1wb3J0IHsgaGFzTG9jYWxlV2Vla0luZm8sIGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFpvbmUoem9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZSNpc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplWm9uZShpbnB1dCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGlucHV0LCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrZGF5IG9uIHdoaWNoIHRoZSB3ZWVrIHN0YXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGxvY2FsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIDEgZm9yIE1vbmRheSB0aHJvdWdoIDcgZm9yIFN1bmRheVxuICAgKi9cbiAgc3RhdGljIGdldFN0YXJ0T2ZXZWVrKHsgbG9jYWxlID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSkpLmdldFN0YXJ0T2ZXZWVrKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBkYXlzIG5lY2Vzc2FyeSBpbiBhIHdlZWsgYmVmb3JlIGl0IGlzIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgbmV4dCB5ZWFyIGFjY29yZGluZ1xuICAgKiB0byB0aGUgZ2l2ZW4gbG9jYWxlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0TWluaW11bURheXNJbkZpcnN0V2Vlayh7IGxvY2FsZSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUpKS5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtkYXlzLCB3aGljaCBhcmUgY29uc2lkZXJlZCB0aGUgd2Vla2VuZCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGxvY2FsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gYW4gYXJyYXkgb2Ygd2Vla2RheXMsIDEgZm9yIE1vbmRheSB0aHJvdWdoIDcgZm9yIFN1bmRheVxuICAgKi9cbiAgc3RhdGljIGdldFdlZWtlbmRXZWVrZGF5cyh7IGxvY2FsZSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgLy8gY29weSB0aGUgYXJyYXksIGJlY2F1c2Ugd2UgY2FjaGUgaXQgaW50ZXJuYWxseVxuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlKSkuZ2V0V2Vla2VuZERheXMoKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIG1vbnRoIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoKVswXSAvLz0+ICdKYW51YXJ5J1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnKVswXSAvLz0+ICdKYW4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJylbMF0gLy89PiAnMSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSApWzBdIC8vPT4gJ2phbnYuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ9mhJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbG9uZycsIHsgb3V0cHV0Q2FsZW5kYXI6ICdpc2xhbWljJyB9KVswXSAvLz0+ICdSYWJpyrsgSSdcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzKFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IG1vbnRoIG5hbWVzLlxuICAgKiBGb3JtYXQgbW9udGhzIGRpZmZlciBmcm9tIHN0YW5kYWxvbmUgbW9udGhzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byB0aGUgZGF5IG9mIHRoZSBtb250aC4gSW4gc29tZSBsYW5ndWFnZXMsIHRoYXRcbiAgICogY2hhbmdlcyB0aGUgc3RyaW5nLlxuICAgKiBTZWUge0BsaW5rIEluZm8jbW9udGhzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRoc0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgd2VlayBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgd2Vla2RheSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKClbMF0gLy89PiAnTW9uZGF5J1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcpWzBdIC8vPT4gJ01vbidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9KVswXSAvLz0+ICdsdW4uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ9in2YTYp9ir2YbZitmGJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5cyhsZW5ndGggPSBcImxvbmdcIiwgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgd2VlayBuYW1lcy5cbiAgICogRm9ybWF0IHdlZWtkYXlzIGRpZmZlciBmcm9tIHN0YW5kYWxvbmUgd2Vla2RheXMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIG1vcmUgZGF0ZSBpbmZvcm1hdGlvbi4gSW4gc29tZSBsYW5ndWFnZXMsIHRoYXRcbiAgICogY2hhbmdlcyB0aGUgc3RyaW5nLlxuICAgKiBTZWUge0BsaW5rIEluZm8jd2Vla2RheXN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT1udWxsXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIG1lcmlkaWVtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKCkgLy89PiBbICdBTScsICdQTScgXVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcyh7IGxvY2FsZTogJ215JyB9KSAvLz0+IFsgJ+GAlOGAtuGAlOGAgOGAuicsICfhgIrhgJThgLEnIF1cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWVyaWRpZW1zKHsgbG9jYWxlID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUpLm1lcmlkaWVtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBlcmFzLCBzdWNoIGFzIFsnQkMnLCAnQUQnXS4gVGhlIGxvY2FsZSBjYW4gYmUgc3BlY2lmaWVkLCBidXQgdGhlIGNhbGVuZGFyIHN5c3RlbSBpcyBhbHdheXMgR3JlZ29yaWFuLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nc2hvcnQnXSAtIHRoZSBsZW5ndGggb2YgdGhlIGVyYSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcInNob3J0XCIgb3IgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoKSAvLz0+IFsgJ0JDJywgJ0FEJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycpIC8vPT4gWyAnQmVmb3JlIENocmlzdCcsICdBbm5vIERvbWluaScgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnLCB7IGxvY2FsZTogJ2ZyJyB9KSAvLz0+IFsgJ2F2YW50IErDqXN1cy1DaHJpc3QnLCAnYXByw6hzIErDqXN1cy1DaHJpc3QnIF1cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgZXJhcyhsZW5ndGggPSBcInNob3J0XCIsIHsgbG9jYWxlID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bGwsIFwiZ3JlZ29yeVwiKS5lcmFzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzZXQgb2YgYXZhaWxhYmxlIGZlYXR1cmVzIGluIHRoaXMgZW52aXJvbm1lbnQuXG4gICAqIFNvbWUgZmVhdHVyZXMgb2YgTHV4b24gYXJlIG5vdCBhdmFpbGFibGUgaW4gYWxsIGVudmlyb25tZW50cy4gRm9yIGV4YW1wbGUsIG9uIG9sZGVyIGJyb3dzZXJzLCByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmcgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLiBVc2UgdGhpcyBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICogS2V5czpcbiAgICogKiBgcmVsYXRpdmVgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nXG4gICAqICogYGxvY2FsZVdlZWtgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgZGlmZmVyZW50IHdlZWtkYXlzIGZvciB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSwgbG9jYWxlV2VlazogdHJ1ZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSwgbG9jYWxlV2VlazogaGFzTG9jYWxlV2Vla0luZm8oKSB9O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/interval.js":
/*!********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/interval.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interval)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/formats.js\");\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Interval\";\n\n// checks if the start is equal to or before the end\nfunction validateStartEnd(start, end) {\n  if (!start || !start.isValid) {\n    return Interval.invalid(\"missing or invalid start\");\n  } else if (!end || !end.isValid) {\n    return Interval.invalid(\"missing or invalid end\");\n  } else if (end < start) {\n    return Interval.invalid(\n      \"end before start\",\n      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`\n    );\n  } else {\n    return null;\n  }\n}\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.\n * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.\n * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}\n * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.\n */\nclass Interval {\n  /**\n   * @private\n   */\n  constructor(config) {\n    /**\n     * @access private\n     */\n    this.s = config.start;\n    /**\n     * @access private\n     */\n    this.e = config.end;\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.isLuxonInterval = true;\n  }\n\n  /**\n   * Create an invalid Interval.\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Interval}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidIntervalError(invalid);\n    } else {\n      return new Interval({ invalid });\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n   * @param {DateTime|Date|Object} start\n   * @param {DateTime|Date|Object} end\n   * @return {Interval}\n   */\n  static fromDateTimes(start, end) {\n    const builtStart = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start),\n      builtEnd = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n\n    const validateError = validateStartEnd(builtStart, builtEnd);\n\n    if (validateError == null) {\n      return new Interval({\n        start: builtStart,\n        end: builtEnd,\n      });\n    } else {\n      return validateError;\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and a Duration to extend to.\n   * @param {DateTime|Date|Object} start\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static after(start, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start);\n    return Interval.fromDateTimes(dt, dt.plus(dur));\n  }\n\n  /**\n   * Create an Interval from an end DateTime and a Duration to extend backwards to.\n   * @param {DateTime|Date|Object} end\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static before(end, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n    return Interval.fromDateTimes(dt.minus(dur), dt);\n  }\n\n  /**\n   * Create an Interval from an ISO 8601 string.\n   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n   * @param {string} text - the ISO string to parse\n   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {Interval}\n   */\n  static fromISO(text, opts) {\n    const [s, e] = (text || \"\").split(\"/\", 2);\n    if (s && e) {\n      let start, startIsValid;\n      try {\n        start = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(s, opts);\n        startIsValid = start.isValid;\n      } catch (e) {\n        startIsValid = false;\n      }\n\n      let end, endIsValid;\n      try {\n        end = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(e, opts);\n        endIsValid = end.isValid;\n      } catch (e) {\n        endIsValid = false;\n      }\n\n      if (startIsValid && endIsValid) {\n        return Interval.fromDateTimes(start, end);\n      }\n\n      if (startIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(e, opts);\n        if (dur.isValid) {\n          return Interval.after(start, dur);\n        }\n      } else if (endIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(s, opts);\n        if (dur.isValid) {\n          return Interval.before(end, dur);\n        }\n      }\n    }\n    return Interval.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n  }\n\n  /**\n   * Check if an object is an Interval. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isInterval(o) {\n    return (o && o.isLuxonInterval) || false;\n  }\n\n  /**\n   * Returns the start of the Interval\n   * @type {DateTime}\n   */\n  get start() {\n    return this.isValid ? this.s : null;\n  }\n\n  /**\n   * Returns the end of the Interval. This is the first instant which is not part of the interval\n   * (Interval is half-open).\n   * @type {DateTime}\n   */\n  get end() {\n    return this.isValid ? this.e : null;\n  }\n\n  /**\n   * Returns the last DateTime included in the interval (since end is not part of the interval)\n   * @type {DateTime}\n   */\n  get lastDateTime() {\n    return this.isValid ? (this.e ? this.e.minus(1) : null) : null;\n  }\n\n  /**\n   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalidReason === null;\n  }\n\n  /**\n   * Returns an error code if this Interval is invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Returns the length of the Interval in the specified unit.\n   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\n   * @return {number}\n   */\n  length(unit = \"milliseconds\") {\n    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;\n  }\n\n  /**\n   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n   * @param {string} [unit='milliseconds'] - the unit of time to count.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime\n   * @return {number}\n   */\n  count(unit = \"milliseconds\", opts) {\n    if (!this.isValid) return NaN;\n    const start = this.start.startOf(unit, opts);\n    let end;\n    if (opts?.useLocaleWeeks) {\n      end = this.end.reconfigure({ locale: start.locale });\n    } else {\n      end = this.end;\n    }\n    end = end.startOf(unit, opts);\n    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());\n  }\n\n  /**\n   * Returns whether this Interval's start and end are both in the same unit of time\n   * @param {string} unit - the unit of time to check sameness on\n   * @return {boolean}\n   */\n  hasSame(unit) {\n    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end DateTimes.\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.s.valueOf() === this.e.valueOf();\n  }\n\n  /**\n   * Return whether this Interval's start is after the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isAfter(dateTime) {\n    if (!this.isValid) return false;\n    return this.s > dateTime;\n  }\n\n  /**\n   * Return whether this Interval's end is before the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isBefore(dateTime) {\n    if (!this.isValid) return false;\n    return this.e <= dateTime;\n  }\n\n  /**\n   * Return whether this Interval contains the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  contains(dateTime) {\n    if (!this.isValid) return false;\n    return this.s <= dateTime && this.e > dateTime;\n  }\n\n  /**\n   * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n   * @param {Object} values - the values to set\n   * @param {DateTime} values.start - the starting DateTime\n   * @param {DateTime} values.end - the ending DateTime\n   * @return {Interval}\n   */\n  set({ start, end } = {}) {\n    if (!this.isValid) return this;\n    return Interval.fromDateTimes(start || this.s, end || this.e);\n  }\n\n  /**\n   * Split this Interval at each of the specified DateTimes\n   * @param {...DateTime} dateTimes - the unit of time to count.\n   * @return {Array}\n   */\n  splitAt(...dateTimes) {\n    if (!this.isValid) return [];\n    const sorted = dateTimes\n        .map(_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)\n        .filter((d) => this.contains(d))\n        .sort((a, b) => a.toMillis() - b.toMillis()),\n      results = [];\n    let { s } = this,\n      i = 0;\n\n    while (s < this.e) {\n      const added = sorted[i] || this.e,\n        next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      i += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into smaller Intervals, each of the specified length.\n   * Left over time is grouped into a smaller interval\n   * @param {Duration|Object|number} duration - The length of each resulting interval.\n   * @return {Array}\n   */\n  splitBy(duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration);\n\n    if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\n      return [];\n    }\n\n    let { s } = this,\n      idx = 1,\n      next;\n\n    const results = [];\n    while (s < this.e) {\n      const added = this.start.plus(dur.mapUnits((x) => x * idx));\n      next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      idx += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into the specified number of smaller intervals.\n   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\n   * @return {Array}\n   */\n  divideEqually(numberOfParts) {\n    if (!this.isValid) return [];\n    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\n  }\n\n  /**\n   * Return whether this Interval overlaps with the specified Interval\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  overlaps(other) {\n    return this.e > other.s && this.s < other.e;\n  }\n\n  /**\n   * Return whether this Interval's end is adjacent to the specified Interval's start.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsStart(other) {\n    if (!this.isValid) return false;\n    return +this.e === +other.s;\n  }\n\n  /**\n   * Return whether this Interval's start is adjacent to the specified Interval's end.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsEnd(other) {\n    if (!this.isValid) return false;\n    return +other.e === +this.s;\n  }\n\n  /**\n   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  engulfs(other) {\n    if (!this.isValid) return false;\n    return this.s <= other.s && this.e >= other.e;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end as the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    return this.s.equals(other.s) && this.e.equals(other.e);\n  }\n\n  /**\n   * Return an Interval representing the intersection of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n   * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  intersection(other) {\n    if (!this.isValid) return this;\n    const s = this.s > other.s ? this.s : other.s,\n      e = this.e < other.e ? this.e : other.e;\n\n    if (s >= e) {\n      return null;\n    } else {\n      return Interval.fromDateTimes(s, e);\n    }\n  }\n\n  /**\n   * Return an Interval representing the union of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  union(other) {\n    if (!this.isValid) return this;\n    const s = this.s < other.s ? this.s : other.s,\n      e = this.e > other.e ? this.e : other.e;\n    return Interval.fromDateTimes(s, e);\n  }\n\n  /**\n   * Merge an array of Intervals into an equivalent minimal set of Intervals.\n   * Combines overlapping and adjacent Intervals.\n   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval\n   * and ending with the latest.\n   *\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static merge(intervals) {\n    const [found, final] = intervals\n      .sort((a, b) => a.s - b.s)\n      .reduce(\n        ([sofar, current], item) => {\n          if (!current) {\n            return [sofar, item];\n          } else if (current.overlaps(item) || current.abutsStart(item)) {\n            return [sofar, current.union(item)];\n          } else {\n            return [sofar.concat([current]), item];\n          }\n        },\n        [[], null]\n      );\n    if (final) {\n      found.push(final);\n    }\n    return found;\n  }\n\n  /**\n   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static xor(intervals) {\n    let start = null,\n      currentCount = 0;\n    const results = [],\n      ends = intervals.map((i) => [\n        { time: i.s, type: \"s\" },\n        { time: i.e, type: \"e\" },\n      ]),\n      flattened = Array.prototype.concat(...ends),\n      arr = flattened.sort((a, b) => a.time - b.time);\n\n    for (const i of arr) {\n      currentCount += i.type === \"s\" ? 1 : -1;\n\n      if (currentCount === 1) {\n        start = i.time;\n      } else {\n        if (start && +start !== +i.time) {\n          results.push(Interval.fromDateTimes(start, i.time));\n        }\n\n        start = null;\n      }\n    }\n\n    return Interval.merge(results);\n  }\n\n  /**\n   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n   * @param {...Interval} intervals\n   * @return {Array}\n   */\n  difference(...intervals) {\n    return Interval.xor([this].concat(intervals))\n      .map((i) => this.intersection(i))\n      .filter((i) => i && !i.isEmpty());\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for debugging.\n   * @return {string}\n   */\n  toString() {\n    if (!this.isValid) return INVALID;\n    return `[${this.s.toISO()}  ${this.e.toISO()})`;\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;\n    } else {\n      return `Interval { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns a localized string representing this Interval. Accepts the same options as the\n   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as\n   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method\n   * is browser-specific, but in general it will return an appropriate representation of the\n   * Interval in the assigned locale. Defaults to the system's locale if no locale has been\n   * specified.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or\n   * Intl.DateTimeFormat constructor options.\n   * @param {Object} opts - Options to override the configuration of the start DateTime.\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create(this.s.loc.clone(opts), formatOpts).formatInterval(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Interval.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISO(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of date of this Interval.\n   * The time components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {string}\n   */\n  toISODate() {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISODate()}/${this.e.toISODate()}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of time of this Interval.\n   * The date components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISOTime(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this Interval formatted according to the specified format\n   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible\n   * formatting tool.\n   * @param {string} dateFormat - The format string. This string formats the start and end time.\n   * See {@link DateTime#toFormat} for details.\n   * @param {Object} opts - Options.\n   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end\n   * representations.\n   * @return {string}\n   */\n  toFormat(dateFormat, { separator = \"  \" } = {}) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;\n  }\n\n  /**\n   * Return a Duration representing the time spanned by this interval.\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n   * @return {Duration}\n   */\n  toDuration(unit, opts) {\n    if (!this.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].invalid(this.invalidReason);\n    }\n    return this.e.diff(this.s, unit, opts);\n  }\n\n  /**\n   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n   * @param {function} mapFn\n   * @return {Interval}\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n   */\n  mapEndpoints(mapFn) {\n    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW50ZXJ2YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMkQ7QUFDdEI7QUFDQTtBQUNvQztBQUNqQztBQUNJO0FBQ0M7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZSxVQUFVLFlBQVk7QUFDaEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUZBQXlGLGVBQWU7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDZCQUE2QixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixNQUFNLHVCQUF1QjtBQUN6Six3QkFBd0Isc0JBQXNCLEtBQUssb0JBQW9CO0FBQ3ZFLHFEQUFxRCxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsTUFBTSx3QkFBd0I7QUFDaE4sd0VBQXdFLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLDZCQUE2QixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLDRCQUE0QixNQUFNLDBCQUEwQjtBQUNwVCxrRUFBa0Usc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUc7QUFDOUsseUVBQXlFLHdCQUF3QixHQUFHLDhCQUE4QixHQUFHLHFCQUFxQixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHdCQUF3QixPQUFPLDBCQUEwQjtBQUM5UTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFB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QUFDM0Q7QUFDQSxRQUFRLDBEQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLDRCQUE0QjtBQUNqRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsNEJBQTRCO0FBQ2pELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QixHQUFHLHVCQUF1QjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLHlCQUF5QjtBQUNuQyxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0EseUJBQXlCLG9CQUFvQixJQUFJO0FBQ2pEO0FBQ0EsY0FBYyw0QkFBNEIsRUFBRSxVQUFVLEVBQUUsNEJBQTRCO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLDhFQUE4RTtBQUM5RSxvRkFBb0Y7QUFDcEYsa0dBQWtHO0FBQ2xHLDZHQUE2RztBQUM3Ryx1RkFBdUY7QUFDdkYsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsY0FBYztBQUNkO0FBQ0Esd0ZBQXdGLFVBQVU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW50ZXJ2YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERhdGVUaW1lLCB7IGZyaWVuZGx5RGF0ZVRpbWUgfSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkSW50ZXJ2YWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIEludGVydmFsXCI7XG5cbi8vIGNoZWNrcyBpZiB0aGUgc3RhcnQgaXMgZXF1YWwgdG8gb3IgYmVmb3JlIHRoZSBlbmRcbmZ1bmN0aW9uIHZhbGlkYXRlU3RhcnRFbmQoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0IHx8ICFzdGFydC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgc3RhcnRcIik7XG4gIH0gZWxzZSBpZiAoIWVuZCB8fCAhZW5kLmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRcIik7XG4gIH0gZWxzZSBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcbiAgICAgIFwiZW5kIGJlZm9yZSBzdGFydFwiLFxuICAgICAgYFRoZSBlbmQgb2YgYW4gaW50ZXJ2YWwgbXVzdCBiZSBhZnRlciBpdHMgc3RhcnQsIGJ1dCB5b3UgaGFkIHN0YXJ0PSR7c3RhcnQudG9JU08oKX0gYW5kIGVuZD0ke2VuZC50b0lTTygpfWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQW4gSW50ZXJ2YWwgb2JqZWN0IHJlcHJlc2VudHMgYSBoYWxmLW9wZW4gaW50ZXJ2YWwgb2YgdGltZSwgd2hlcmUgZWFjaCBlbmRwb2ludCBpcyBhIHtAbGluayBEYXRlVGltZX0uIENvbmNlcHR1YWxseSwgaXQncyBhIGNvbnRhaW5lciBmb3IgdGhvc2UgdHdvIGVuZHBvaW50cywgYWNjb21wYW5pZWQgYnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIGNvbXBhcmluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gSW50ZXJ2YWw6XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGFuIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsLmZyb21EYXRlVGltZXN9LCB7QGxpbmsgSW50ZXJ2YWwuYWZ0ZXJ9LCB7QGxpbmsgSW50ZXJ2YWwuYmVmb3JlfSwgb3Ige0BsaW5rIEludGVydmFsLmZyb21JU099LlxuICogKiAqKkFjY2Vzc29ycyoqIFVzZSB7QGxpbmsgSW50ZXJ2YWwjc3RhcnR9IGFuZCB7QGxpbmsgSW50ZXJ2YWwjZW5kfSB0byBnZXQgdGhlIHN0YXJ0IGFuZCBlbmQuXG4gKiAqICoqSW50ZXJyb2dhdGlvbioqIFRvIGFuYWx5emUgdGhlIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsI2NvdW50fSwge0BsaW5rIEludGVydmFsI2xlbmd0aH0sIHtAbGluayBJbnRlcnZhbCNoYXNTYW1lfSwge0BsaW5rIEludGVydmFsI2NvbnRhaW5zfSwge0BsaW5rIEludGVydmFsI2lzQWZ0ZXJ9LCBvciB7QGxpbmsgSW50ZXJ2YWwjaXNCZWZvcmV9LlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG90aGVyIEludGVydmFscyBvdXQgb2YgdGhpcyBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjc2V0fSwge0BsaW5rIEludGVydmFsI3NwbGl0QXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRCeX0sIHtAbGluayBJbnRlcnZhbCNkaXZpZGVFcXVhbGx5fSwge0BsaW5rIEludGVydmFsLm1lcmdlfSwge0BsaW5rIEludGVydmFsLnhvcn0sIHtAbGluayBJbnRlcnZhbCN1bmlvbn0sIHtAbGluayBJbnRlcnZhbCNpbnRlcnNlY3Rpb259LCBvciB7QGxpbmsgSW50ZXJ2YWwjZGlmZmVyZW5jZX0uXG4gKiAqICoqQ29tcGFyaXNvbioqIFRvIGNvbXBhcmUgdGhpcyBJbnRlcnZhbCB0byBhbm90aGVyIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNlcXVhbHN9LCB7QGxpbmsgSW50ZXJ2YWwjb3ZlcmxhcHN9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNTdGFydH0sIHtAbGluayBJbnRlcnZhbCNhYnV0c0VuZH0sIHtAbGluayBJbnRlcnZhbCNlbmd1bGZzfVxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIEludGVydmFsIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIEludGVydmFsI3RvU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvSVNPfSwge0BsaW5rIEludGVydmFsI3RvSVNPRGF0ZX0sIHtAbGluayBJbnRlcnZhbCN0b0lTT1RpbWV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Gb3JtYXR9LCBhbmQge0BsaW5rIEludGVydmFsI3RvRHVyYXRpb259LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnZhbCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zID0gY29uZmlnLnN0YXJ0O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZSA9IGNvbmZpZy5lbmQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25JbnRlcnZhbCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIEludGVydmFsIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgSW50ZXJ2YWwgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEludGVydmFsRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhbiBlbmQgRGF0ZVRpbWUuIEluY2x1c2l2ZSBvZiB0aGUgc3RhcnQgYnV0IG5vdCB0aGUgZW5kLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVpbHRTdGFydCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpLFxuICAgICAgYnVpbHRFbmQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG5cbiAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gdmFsaWRhdGVTdGFydEVuZChidWlsdFN0YXJ0LCBidWlsdEVuZCk7XG5cbiAgICBpZiAodmFsaWRhdGVFcnJvciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHtcbiAgICAgICAgc3RhcnQ6IGJ1aWx0U3RhcnQsXG4gICAgICAgIGVuZDogYnVpbHRFbmQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGFmdGVyKHN0YXJ0LCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdCwgZHQucGx1cyhkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBlbmQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIGJhY2t3YXJkcyB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYmVmb3JlKGVuZCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0Lm1pbnVzKGR1ciksIGR0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBJU08gODYwMSBzdHJpbmcuXG4gICAqIEFjY2VwdHMgYDxzdGFydD4vPGVuZD5gLCBgPHN0YXJ0Pi88ZHVyYXRpb24+YCwgYW5kIGA8ZHVyYXRpb24+LzxlbmQ+YCBmb3JtYXRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25zIHRvIHBhc3Mge0BsaW5rIERhdGVUaW1lI2Zyb21JU099IGFuZCBvcHRpb25hbGx5IHtAbGluayBEdXJhdGlvbiNmcm9tSVNPfVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtzLCBlXSA9ICh0ZXh0IHx8IFwiXCIpLnNwbGl0KFwiL1wiLCAyKTtcbiAgICBpZiAocyAmJiBlKSB7XG4gICAgICBsZXQgc3RhcnQsIHN0YXJ0SXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gc3RhcnQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbmQsIGVuZElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBlbmQgPSBEYXRlVGltZS5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBlbmRJc1ZhbGlkID0gZW5kLmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVuZElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCAmJiBlbmRJc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5hZnRlcihzdGFydCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5iZWZvcmUoZW5kLCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBJbnRlcnZhbC4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzSW50ZXJ2YWwobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25JbnRlcnZhbCkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmQgb2YgdGhlIEludGVydmFsLiBUaGlzIGlzIHRoZSBmaXJzdCBpbnN0YW50IHdoaWNoIGlzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcnZhbFxuICAgKiAoSW50ZXJ2YWwgaXMgaGFsZi1vcGVuKS5cbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IERhdGVUaW1lIGluY2x1ZGVkIGluIHRoZSBpbnRlcnZhbCAoc2luY2UgZW5kIGlzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcnZhbClcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGxhc3REYXRlVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gKHRoaXMuZSA/IHRoaXMuZS5taW51cygxKSA6IG51bGwpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZFJlYXNvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoKHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbiguLi5bdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBtaW51dGVzLCBob3VycywgZGF5cywgbW9udGhzLCBvciB5ZWFycyBpbmNsdWRlZCBpbiB0aGUgSW50ZXJ2YWwsIGV2ZW4gaW4gcGFydC5cbiAgICogVW5saWtlIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9IHRoaXMgY291bnRzIHNlY3Rpb25zIG9mIHRoZSBjYWxlbmRhciwgbm90IHBlcmlvZHMgb2YgdGltZSwgZS5nLiBzcGVjaWZ5aW5nICdkYXknXG4gICAqIGFza3MgJ3doYXQgZGF0ZXMgYXJlIGluY2x1ZGVkIGluIHRoaXMgaW50ZXJ2YWw/Jywgbm90ICdob3cgbWFueSBkYXlzIGxvbmcgaXMgdGhpcyBpbnRlcnZhbD8nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdD0nbWlsbGlzZWNvbmRzJ10gLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy51c2VMb2NhbGVXZWVrcz1mYWxzZV0gLSBJZiB0cnVlLCB1c2Ugd2Vla3MgYmFzZWQgb24gdGhlIGxvY2FsZSwgaS5lLiB1c2UgdGhlIGxvY2FsZS1kZXBlbmRlbnQgc3RhcnQgb2YgdGhlIHdlZWs7IHRoaXMgb3BlcmF0aW9uIHdpbGwgYWx3YXlzIHVzZSB0aGUgbG9jYWxlIG9mIHRoZSBzdGFydCBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb3VudCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQsIG9wdHMpO1xuICAgIGxldCBlbmQ7XG4gICAgaWYgKG9wdHM/LnVzZUxvY2FsZVdlZWtzKSB7XG4gICAgICBlbmQgPSB0aGlzLmVuZC5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogc3RhcnQubG9jYWxlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0aGlzLmVuZDtcbiAgICB9XG4gICAgZW5kID0gZW5kLnN0YXJ0T2YodW5pdCwgb3B0cyk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KSkgKyAoZW5kLnZhbHVlT2YoKSAhPT0gdGhpcy5lbmQudmFsdWVPZigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGFuZCBlbmQgYXJlIGJvdGggaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZSh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuaXNFbXB0eSgpIHx8IHRoaXMuZS5taW51cygxKS5oYXNTYW1lKHRoaXMucywgdW5pdCkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIERhdGVUaW1lcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucy52YWx1ZU9mKCkgPT09IHRoaXMuZS52YWx1ZU9mKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FmdGVyKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQmVmb3JlKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5lIDw9IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgY29udGFpbnMgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IGRhdGVUaW1lICYmIHRoaXMuZSA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0c1wiIHRoZSBzdGFydCBhbmQvb3IgZW5kIGRhdGVzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgdmFsdWVzIHRvIHNldFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuc3RhcnQgLSB0aGUgc3RhcnRpbmcgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLmVuZCAtIHRoZSBlbmRpbmcgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzZXQoeyBzdGFydCwgZW5kIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCB8fCB0aGlzLnMsIGVuZCB8fCB0aGlzLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgYXQgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIERhdGVUaW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QXQoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICBjb25zdCBzb3J0ZWQgPSBkYXRlVGltZXNcbiAgICAgICAgLm1hcChmcmllbmRseURhdGVUaW1lKVxuICAgICAgICAuZmlsdGVyKChkKSA9PiB0aGlzLmNvbnRhaW5zKGQpKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS50b01pbGxpcygpIC0gYi50b01pbGxpcygpKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIEludGVydmFsIGZ1bGx5IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwsIHNwZWNpZmljYWxseSBpZiB0aGUgaW50ZXJzZWN0IChvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgb3RoZXIgSW50ZXJ2YWwpIGlzIGVxdWFsIHRvIHRoZSBvdGhlciBJbnRlcnZhbDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGFuIGVxdWl2YWxlbnQgbWluaW1hbCBzZXQgb2YgSW50ZXJ2YWxzLlxuICAgKiBDb21iaW5lcyBvdmVybGFwcGluZyBhbmQgYWRqYWNlbnQgSW50ZXJ2YWxzLlxuICAgKiBUaGUgcmVzdWx0aW5nIGFycmF5IHdpbGwgY29udGFpbiB0aGUgSW50ZXJ2YWxzIGluIGFzY2VuZGluZyBvcmRlciwgdGhhdCBpcywgc3RhcnRpbmcgd2l0aCB0aGUgZWFybGllc3QgSW50ZXJ2YWxcbiAgICogYW5kIGVuZGluZyB3aXRoIHRoZSBsYXRlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IOKAkyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgSW50ZXJ2YWwgeyBzdGFydDogJHt0aGlzLnMudG9JU08oKX0sIGVuZDogJHt0aGlzLmUudG9JU08oKX0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgSW50ZXJ2YWwgeyBJbnZhbGlkLCByZWFzb246ICR7dGhpcy5pbnZhbGlkUmVhc29ufSB9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgSW50ZXJ2YWwuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGVcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhc1xuICAgKiB7QGxpbmsgRGF0ZVRpbWUuREFURV9GVUxMfSBvciB7QGxpbmsgRGF0ZVRpbWUuVElNRV9TSU1QTEV9LiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2RcbiAgICogaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAqIEludGVydmFsIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuXG4gICAqIHNwZWNpZmllZC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Zvcm1hdE9wdHM9RGF0ZVRpbWUuREFURV9TSE9SVF0gLSBFaXRoZXIgYSBEYXRlVGltZSBwcmVzZXQgb3JcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHN0YXJ0IERhdGVUaW1lLlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gMTEvNy8yMDIyIOKAkyAxMS84LzIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+IE5vdmVtYmVyIDcg4oCTIDgsIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnItRlInIH0pOyAvLz0+IDfigJM4IG5vdmVtYnJlIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gNjowMCDigJMgODowMCBQTVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+IE1vbiwgTm92IDA3LCA2OjAwIOKAkyA4OjAwIHBcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMucy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdEludGVydmFsKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08ob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPKG9wdHMpfS8ke3RoaXMuZS50b0lTTyhvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBkYXRlIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSB0aW1lIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPRGF0ZSgpfS8ke3RoaXMuZS50b0lTT0RhdGUoKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aW1lIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSBkYXRlIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT1RpbWUob3B0cyl9LyR7dGhpcy5lLnRvSVNPVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0XG4gICAqIHN0cmluZy4gKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZVxuICAgKiBmb3JtYXR0aW5nIHRvb2wuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnNlcGFyYXRvciA9ICAnIOKAkyAnXSAtIEEgc2VwYXJhdG9yIHRvIHBsYWNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICogcmVwcmVzZW50YXRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChkYXRlRm9ybWF0LCB7IHNlcGFyYXRvciA9IFwiIOKAkyBcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0Zvcm1hdChkYXRlRm9ybWF0KX0ke3NlcGFyYXRvcn0ke3RoaXMuZS50b0Zvcm1hdChkYXRlRm9ybWF0KX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIER1cmF0aW9uIHJlcHJlc2VudGluZyB0aGUgdGltZSBzcGFubmVkIGJ5IHRoaXMgaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDg4NDg5MjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignZGF5cycpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDEuMDI0MTgxMjE1Mjc3Nzc3OCB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQuODIwOTUgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQsIHNlY29uZHM6IDQ5LjI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ3NlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBzZWNvbmRzOiA4ODQ4OS4yNTcgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHRvRHVyYXRpb24odW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZCh0aGlzLmludmFsaWRSZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lLmRpZmYodGhpcy5zLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gbWFwRm4gb24gdGhlIGludGVydmFsIHN0YXJ0IGFuZCBlbmQsIHJldHVybmluZyBhIG5ldyBJbnRlcnZhbCBmcm9tIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQudG9VVEMoKSlcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnBsdXMoeyBob3VyczogMiB9KSlcbiAgICovXG4gIG1hcEVuZHBvaW50cyhtYXBGbikge1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKG1hcEZuKHRoaXMucyksIG1hcEZuKHRoaXMuZSkpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/interval.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/luxon.js":
/*!*****************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/luxon.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* reexport safe */ _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Duration: () => (/* reexport safe */ _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   FixedOffsetZone: () => (/* reexport safe */ _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   IANAZone: () => (/* reexport safe */ _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   Info: () => (/* reexport safe */ _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   Interval: () => (/* reexport safe */ _interval_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   InvalidZone: () => (/* reexport safe */ _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   Settings: () => (/* reexport safe */ _settings_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   SystemZone: () => (/* reexport safe */ _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Zone: () => (/* reexport safe */ _zone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/info.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zones/invalidZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"3.7.1\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvbHV4b24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0E7QUFDQTtBQUNSO0FBQ0E7QUFDNEI7QUFDZDtBQUNNO0FBQ0Y7QUFDVjs7QUFFckM7O0FBY0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2x1eG9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuL3pvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjMuNy4xXCI7XG5cbmV4cG9ydCB7XG4gIFZFUlNJT04sXG4gIERhdGVUaW1lLFxuICBEdXJhdGlvbixcbiAgSW50ZXJ2YWwsXG4gIEluZm8sXG4gIFpvbmUsXG4gIEZpeGVkT2Zmc2V0Wm9uZSxcbiAgSUFOQVpvbmUsXG4gIEludmFsaWRab25lLFxuICBTeXN0ZW1ab25lLFxuICBTZXR0aW5ncyxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/luxon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js":
/*!********************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/settings.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Settings)\n/* harmony export */ });\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_digits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/digits.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/digits.js\");\n\n\n\n\n\n\n\n\n\nlet now = () => Date.now(),\n  defaultZone = \"system\",\n  defaultLocale = null,\n  defaultNumberingSystem = null,\n  defaultOutputCalendar = null,\n  twoDigitCutoffYear = 60,\n  throwOnInvalid,\n  defaultWeekSettings = null;\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.\n */\nclass Settings {\n  /**\n   * Get the callback for returning the current timestamp.\n   * @type {function}\n   */\n  static get now() {\n    return now;\n  }\n\n  /**\n   * Set the callback for returning the current timestamp.\n   * The function should return a number, which will be interpreted as an Epoch millisecond count\n   * @type {function}\n   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n   */\n  static set now(n) {\n    now = n;\n  }\n\n  /**\n   * Set the default time zone to create DateTimes in. Does not affect existing instances.\n   * Use the value \"system\" to reset this value to the system's time zone.\n   * @type {string}\n   */\n  static set defaultZone(zone) {\n    defaultZone = zone;\n  }\n\n  /**\n   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.\n   * The default value is the system's time zone (the one set on the machine that runs this code).\n   * @type {Zone}\n   */\n  static get defaultZone() {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(defaultZone, _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance);\n  }\n\n  /**\n   * Get the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultLocale() {\n    return defaultLocale;\n  }\n\n  /**\n   * Set the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultLocale(locale) {\n    defaultLocale = locale;\n  }\n\n  /**\n   * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultNumberingSystem() {\n    return defaultNumberingSystem;\n  }\n\n  /**\n   * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultNumberingSystem(numberingSystem) {\n    defaultNumberingSystem = numberingSystem;\n  }\n\n  /**\n   * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultOutputCalendar() {\n    return defaultOutputCalendar;\n  }\n\n  /**\n   * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultOutputCalendar(outputCalendar) {\n    defaultOutputCalendar = outputCalendar;\n  }\n\n  /**\n   * @typedef {Object} WeekSettings\n   * @property {number} firstDay\n   * @property {number} minimalDays\n   * @property {number[]} weekend\n   */\n\n  /**\n   * @return {WeekSettings|null}\n   */\n  static get defaultWeekSettings() {\n    return defaultWeekSettings;\n  }\n\n  /**\n   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and\n   * how many days are required in the first week of a year.\n   * Does not affect existing instances.\n   *\n   * @param {WeekSettings|null} weekSettings\n   */\n  static set defaultWeekSettings(weekSettings) {\n    defaultWeekSettings = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.validateWeekSettings)(weekSettings);\n  }\n\n  /**\n   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   */\n  static get twoDigitCutoffYear() {\n    return twoDigitCutoffYear;\n  }\n\n  /**\n   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century\n   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century\n   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950\n   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50\n   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50\n   */\n  static set twoDigitCutoffYear(cutoffYear) {\n    twoDigitCutoffYear = cutoffYear % 100;\n  }\n\n  /**\n   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static get throwOnInvalid() {\n    return throwOnInvalid;\n  }\n\n  /**\n   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static set throwOnInvalid(t) {\n    throwOnInvalid = t;\n  }\n\n  /**\n   * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCaches() {\n    _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resetCache();\n    _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resetCache();\n    _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].resetCache();\n    (0,_impl_digits_js__WEBPACK_IMPORTED_MODULE_6__.resetDigitRegexCache)();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBK0M7QUFDSjtBQUNMO0FBQ0Q7O0FBRWM7QUFDRztBQUNFOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsZ0VBQWEsY0FBYyw0REFBVTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsVUFBVTtBQUMxQjs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBLDBCQUEwQixtRUFBb0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxJQUFJLHVEQUFNO0FBQ1YsSUFBSSwwREFBUTtBQUNaLElBQUksb0RBQVE7QUFDWixJQUFJLHFFQUFvQjtBQUN4QjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9zZXR0aW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuXG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVXZWVrU2V0dGluZ3MgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IHJlc2V0RGlnaXRSZWdleENhY2hlIH0gZnJvbSBcIi4vaW1wbC9kaWdpdHMuanNcIjtcblxubGV0IG5vdyA9ICgpID0+IERhdGUubm93KCksXG4gIGRlZmF1bHRab25lID0gXCJzeXN0ZW1cIixcbiAgZGVmYXVsdExvY2FsZSA9IG51bGwsXG4gIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudWxsLFxuICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBudWxsLFxuICB0d29EaWdpdEN1dG9mZlllYXIgPSA2MCxcbiAgdGhyb3dPbkludmFsaWQsXG4gIGRlZmF1bHRXZWVrU2V0dGluZ3MgPSBudWxsO1xuXG4vKipcbiAqIFNldHRpbmdzIGNvbnRhaW5zIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgY29udHJvbCBMdXhvbidzIG92ZXJhbGwgYmVoYXZpb3IuIEx1eG9uIGlzIGEgc2ltcGxlIGxpYnJhcnkgd2l0aCBmZXcgb3B0aW9ucywgYnV0IHRoZSBvbmVzIGl0IGRvZXMgaGF2ZSBsaXZlIGhlcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgbm93KCkge1xuICAgIHJldHVybiBub3c7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXIsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gRXBvY2ggbWlsbGlzZWNvbmQgY291bnRcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiBEYXRlLm5vdygpICsgMzAwMCAvLyBwcmV0ZW5kIGl0IGlzIDMgc2Vjb25kcyBpbiB0aGUgZnV0dXJlXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IDAgLy8gYWx3YXlzIHByZXRlbmQgaXQncyBKYW4gMSwgMTk3MCBhdCBtaWRuaWdodCBpbiBVVEMgdGltZVxuICAgKi9cbiAgc3RhdGljIHNldCBub3cobikge1xuICAgIG5vdyA9IG47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSB0byBjcmVhdGUgRGF0ZVRpbWVzIGluLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBVc2UgdGhlIHZhbHVlIFwic3lzdGVtXCIgdG8gcmVzZXQgdGhpcyB2YWx1ZSB0byB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0Wm9uZSh6b25lKSB7XG4gICAgZGVmYXVsdFpvbmUgPSB6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgb2JqZWN0IGN1cnJlbnRseSB1c2VkIHRvIGNyZWF0ZSBEYXRlVGltZXMuIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUgKHRoZSBvbmUgc2V0IG9uIHRoZSBtYWNoaW5lIHRoYXQgcnVucyB0aGlzIGNvZGUpLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFpvbmUoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoZGVmYXVsdFpvbmUsIFN5c3RlbVpvbmUuaW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TG9jYWxlKCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TG9jYWxlKGxvY2FsZSkge1xuICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbShudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKG91dHB1dENhbGVuZGFyKSB7XG4gICAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gV2Vla1NldHRpbmdzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXJzdERheVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluaW1hbERheXNcbiAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gd2Vla2VuZFxuICAgKi9cblxuICAvKipcbiAgICogQHJldHVybiB7V2Vla1NldHRpbmdzfG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRXZWVrU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXZWVrU2V0dGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgbG9jYWxlIHdlZWsgc2V0dGluZ3MsIGkuZS4gdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCB0aGUgd2Vla2VuZCBhbmRcbiAgICogaG93IG1hbnkgZGF5cyBhcmUgcmVxdWlyZWQgaW4gdGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyLlxuICAgKiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlZWtTZXR0aW5nc3xudWxsfSB3ZWVrU2V0dGluZ3NcbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFdlZWtTZXR0aW5ncyh3ZWVrU2V0dGluZ3MpIHtcbiAgICBkZWZhdWx0V2Vla1NldHRpbmdzID0gdmFsaWRhdGVXZWVrU2V0dGluZ3Mod2Vla1NldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1dG9mZiB5ZWFyIGZvciB3aGV0aGVyIGEgMi1kaWdpdCB5ZWFyIHN0cmluZyBpcyBpbnRlcnByZXRlZCBpbiB0aGUgY3VycmVudCBvciBwcmV2aW91cyBjZW50dXJ5LiBOdW1iZXJzIGhpZ2hlciB0aGFuIHRoZSBjdXRvZmYgd2lsbCBiZSBjb25zaWRlcmVkIHRvIG1lYW4gMTl4eCBhbmQgbnVtYmVycyBsb3dlciBvciBlcXVhbCB0byB0aGUgY3V0b2ZmIHdpbGwgYmUgY29uc2lkZXJlZCAyMHh4LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldCB0d29EaWdpdEN1dG9mZlllYXIoKSB7XG4gICAgcmV0dXJuIHR3b0RpZ2l0Q3V0b2ZmWWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1dG9mZiB5ZWFyIGZvciB3aGV0aGVyIGEgMi1kaWdpdCB5ZWFyIHN0cmluZyBpcyBpbnRlcnByZXRlZCBpbiB0aGUgY3VycmVudCBvciBwcmV2aW91cyBjZW50dXJ5LiBOdW1iZXJzIGhpZ2hlciB0aGFuIHRoZSBjdXRvZmYgd2lsbCBiZSBjb25zaWRlcmVkIHRvIG1lYW4gMTl4eCBhbmQgbnVtYmVycyBsb3dlciBvciBlcXVhbCB0byB0aGUgY3V0b2ZmIHdpbGwgYmUgY29uc2lkZXJlZCAyMHh4LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAwIC8vIGFsbCAneXknIGFyZSBpbnRlcnByZXRlZCBhcyAyMHRoIGNlbnR1cnlcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gOTkgLy8gYWxsICd5eScgYXJlIGludGVycHJldGVkIGFzIDIxc3QgY2VudHVyeVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSA1MCAvLyAnNDknIC0+IDIwNDk7ICc1MCcgLT4gMTk1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAxOTUwIC8vIGludGVycHJldGVkIGFzIDUwXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDIwNTAgLy8gQUxTTyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKi9cbiAgc3RhdGljIHNldCB0d29EaWdpdEN1dG9mZlllYXIoY3V0b2ZmWWVhcikge1xuICAgIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IGN1dG9mZlllYXIgJSAxMDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCB0aHJvd09uSW52YWxpZCgpIHtcbiAgICByZXR1cm4gdGhyb3dPbkludmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldCB0aHJvd09uSW52YWxpZCh0KSB7XG4gICAgdGhyb3dPbkludmFsaWQgPSB0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IEx1eG9uJ3MgZ2xvYmFsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGVzKCkge1xuICAgIExvY2FsZS5yZXNldENhY2hlKCk7XG4gICAgSUFOQVpvbmUucmVzZXRDYWNoZSgpO1xuICAgIERhdGVUaW1lLnJlc2V0Q2FjaGUoKTtcbiAgICByZXNldERpZ2l0UmVnZXhDYWNoZSgpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/settings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js":
/*!****************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/zone.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Zone)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/errors.js\");\n\n\n/**\n * @interface\n */\nclass Zone {\n  /**\n   * The type of zone\n   * @abstract\n   * @type {string}\n   */\n  get type() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The name of this zone.\n   * @abstract\n   * @type {string}\n   */\n  get name() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The IANA name of this zone.\n   * Defaults to `name` if not overwritten by a subclass.\n   * @abstract\n   * @type {string}\n   */\n  get ianaName() {\n    return this.name;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year.\n   * @abstract\n   * @type {boolean}\n   */\n  get isUniversal() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, opts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @abstract\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @abstract\n   * @type {boolean}\n   */\n  get isValid() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWm9uZUlzQWJzdHJhY3RFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9uZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUFOQSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogRGVmYXVsdHMgdG8gYG5hbWVgIGlmIG5vdCBvdmVyd3JpdHRlbiBieSBhIHN1YmNsYXNzLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js":
/*!**************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/zones/IANAZone.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ IANAZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js\");\n\n\n\nconst dtfCache = new Map();\nfunction makeDTF(zoneName) {\n  let dtf = dtfCache.get(zoneName);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zoneName,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n    dtfCache.set(zoneName, dtf);\n  }\n  return dtf;\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nconst ianaZoneCache = new Map();\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nclass IANAZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    let zone = ianaZoneCache.get(name);\n    if (zone === undefined) {\n      ianaZoneCache.set(name, (zone = new IANAZone(name)));\n    }\n    return zone;\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache.clear();\n    dtfCache.clear();\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /**\n   * The type of zone. `iana` for all instances of `IANAZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"iana\";\n  }\n\n  /**\n   * The name of this zone (i.e. the IANA zone name).\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.zoneName;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns false for all IANA zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return false;\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale, this.name);\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    if (!this.valid) return NaN;\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.objToLocalTS)({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.valid;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlGO0FBQzNEOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QyxZQUFZLGNBQWM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLE1BQU0sVUFBVSwwREFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNlLHVCQUF1QixnREFBSTtBQUMxQztBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxSkFBcUo7QUFDckosYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLFdBQVcsNERBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVywyREFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiwyREFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9JQU5BWm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8sIGlzVW5kZWZpbmVkLCBvYmpUb0xvY2FsVFMgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5jb25zdCBkdGZDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIG1ha2VEVEYoem9uZU5hbWUpIHtcbiAgbGV0IGR0ZiA9IGR0ZkNhY2hlLmdldCh6b25lTmFtZSk7XG4gIGlmIChkdGYgPT09IHVuZGVmaW5lZCkge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIHRpbWVab25lOiB6b25lTmFtZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgICBlcmE6IFwic2hvcnRcIixcbiAgICB9KTtcbiAgICBkdGZDYWNoZS5zZXQoem9uZU5hbWUsIGR0Zik7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxuY29uc3QgdHlwZVRvUG9zID0ge1xuICB5ZWFyOiAwLFxuICBtb250aDogMSxcbiAgZGF5OiAyLFxuICBlcmE6IDMsXG4gIGhvdXI6IDQsXG4gIG1pbnV0ZTogNSxcbiAgc2Vjb25kOiA2LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspIChBRHxCQyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZDtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldO1xuICAgIGNvbnN0IHBvcyA9IHR5cGVUb1Bvc1t0eXBlXTtcblxuICAgIGlmICh0eXBlID09PSBcImVyYVwiKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHBvcykpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxuY29uc3QgaWFuYVpvbmVDYWNoZSA9IG5ldyBNYXAoKTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJQU5BWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG5hbWUpIHtcbiAgICBsZXQgem9uZSA9IGlhbmFab25lQ2FjaGUuZ2V0KG5hbWUpO1xuICAgIGlmICh6b25lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlhbmFab25lQ2FjaGUuc2V0KG5hbWUsICh6b25lID0gbmV3IElBTkFab25lKG5hbWUpKSk7XG4gICAgfVxuICAgIHJldHVybiB6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZS5jbGVhcigpO1xuICAgIGR0ZkNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzcGVjaWZpZXIuIFRoaXMgb25seSBjaGVja3MgdGhlIHN0cmluZydzIGZvcm1hdCwgbm90IHRoYXQgdGhlIHNwZWNpZmllciBpZGVudGlmaWVzIGEga25vd24gem9uZTsgc2VlIGlzVmFsaWRab25lIGZvciB0aGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gY2hlY2sgdmFsaWRpdHkgb25cbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAZGVwcmVjYXRlZCBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmb3J3YXJkcyB0byBpc1ZhbGlkWm9uZSwgYmV0dGVyIHVzZSBgaXNWYWxpZFpvbmUoKWAgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU3BlY2lmaWVyKHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkWm9uZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRab25lKHpvbmUpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogem9uZSB9KS5mb3JtYXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lLiBgaWFuYWAgZm9yIGFsbCBpbnN0YW5jZXMgb2YgYElBTkFab25lYC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpYW5hXCI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyB6b25lIChpLmUuIHRoZSBJQU5BIHpvbmUgbmFtZSkuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyOlxuICAgKiBBbHdheXMgcmV0dXJucyBmYWxzZSBmb3IgYWxsIElBTkEgem9uZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlLCB0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCh0cykge1xuICAgIGlmICghdGhpcy52YWxpZCkgcmV0dXJuIE5hTjtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSByZXR1cm4gTmFOO1xuXG4gICAgY29uc3QgZHRmID0gbWFrZURURih0aGlzLm5hbWUpO1xuICAgIGxldCBbeWVhciwgbW9udGgsIGRheSwgYWRPckJjLCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBkdGYuZm9ybWF0VG9QYXJ0c1xuICAgICAgPyBwYXJ0c09mZnNldChkdGYsIGRhdGUpXG4gICAgICA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSk7XG5cbiAgICBpZiAoYWRPckJjID09PSBcIkJDXCIpIHtcbiAgICAgIHllYXIgPSAtTWF0aC5hYnMoeWVhcikgKyAxO1xuICAgIH1cblxuICAgIC8vIGJlY2F1c2Ugd2UncmUgdXNpbmcgaG91cjEyIGFuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDI1NTY0JmNhbj0yJnE9JTIyMjQlM0EwMCUyMiUyMGRhdGV0aW1lZm9ybWF0XG4gICAgY29uc3QgYWRqdXN0ZWRIb3VyID0gaG91ciA9PT0gMjQgPyAwIDogaG91cjtcblxuICAgIGNvbnN0IGFzVVRDID0gb2JqVG9Mb2NhbFRTKHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICAgIGhvdXI6IGFkanVzdGVkSG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IGFzVFMgPSArZGF0ZTtcbiAgICBjb25zdCBvdmVyID0gYXNUUyAlIDEwMDA7XG4gICAgYXNUUyAtPSBvdmVyID49IDAgPyBvdmVyIDogMTAwMCArIG92ZXI7XG4gICAgcmV0dXJuIChhc1VUQyAtIGFzVFMpIC8gKDYwICogMTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImlhbmFcIiAmJiBvdGhlclpvbmUubmFtZSA9PT0gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/IANAZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js":
/*!*********************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FixedOffsetZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * A zone with a fixed offset (meaning no DST)\n * @implements {Zone}\n */\nclass FixedOffsetZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of UTC\n   * @return {FixedOffsetZone}\n   */\n  static get utcInstance() {\n    if (singleton === null) {\n      singleton = new FixedOffsetZone(0);\n    }\n    return singleton;\n  }\n\n  /**\n   * Get an instance with a specified offset\n   * @param {number} offset - The offset in minutes\n   * @return {FixedOffsetZone}\n   */\n  static instance(offset) {\n    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);\n  }\n\n  /**\n   * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n   * @param {string} s - The offset string to parse\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+6\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+06\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n   * @return {FixedOffsetZone}\n   */\n  static parseSpecifier(s) {\n    if (s) {\n      const r = s.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\n      if (r) {\n        return new FixedOffsetZone((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(r[1], r[2]));\n      }\n    }\n    return null;\n  }\n\n  constructor(offset) {\n    super();\n    /** @private **/\n    this.fixed = offset;\n  }\n\n  /**\n   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"fixed\";\n  }\n\n  /**\n   * The name of this zone.\n   * All fixed zones' names always start with \"UTC\" (plus optional offset)\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.fixed === 0 ? \"UTC\" : `UTC${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, \"narrow\")}`;\n  }\n\n  /**\n   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`\n   *\n   * @override\n   * @type {string}\n   */\n  get ianaName() {\n    if (this.fixed === 0) {\n      return \"Etc/UTC\";\n    } else {\n      return `Etc/GMT${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(-this.fixed, \"narrow\")}`;\n    }\n  }\n\n  /**\n   * Returns the offset's common name at the specified timestamp.\n   *\n   * For fixed offset zones this equals to the zone name.\n   * @override\n   */\n  offsetName() {\n    return this.name;\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, format);\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns true for all fixed offset zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return true;\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   *\n   * For fixed offset zones, this is constant and does not depend on a timestamp.\n   * @override\n   * @return {number}\n   */\n  offset() {\n    return this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"fixed\" && otherZone.fixed === this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is valid:\n   * All fixed offset zones are valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RDtBQUMvQjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNlLDhCQUE4QixnREFBSTtBQUNqRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJLFNBQVMsRUFBRTtBQUN2RDtBQUNBLG1DQUFtQywyREFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNENBQTRDLDJEQUFZLHVCQUF1QjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1QkFBdUIsMkRBQVksd0JBQXdCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVcsMkRBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtY29yZS9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHNpZ25lZE9mZnNldCB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIEEgem9uZSB3aXRoIGEgZml4ZWQgb2Zmc2V0IChtZWFuaW5nIG5vIERTVClcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZE9mZnNldFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBVVENcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCB1dGNJbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgRml4ZWRPZmZzZXRab25lKDApO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWVkIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBpbiBtaW51dGVzXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBpbnN0YW5jZShvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlIDogbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBGaXhlZE9mZnNldFpvbmUgZnJvbSBhIFVUQyBvZmZzZXQgc3RyaW5nLCBsaWtlIFwiVVRDKzZcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBvZmZzZXQgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQys2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQyswNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMtNjowMFwiKVxuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VTcGVjaWZpZXIocykge1xuICAgIGlmIChzKSB7XG4gICAgICBjb25zdCByID0gcy5tYXRjaCgvXnV0Yyg/OihbKy1dXFxkezEsMn0pKD86OihcXGR7Mn0pKT8pPyQvaSk7XG4gICAgICBpZiAocikge1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkT2Zmc2V0Wm9uZShzaWduZWRPZmZzZXQoclsxXSwgclsyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9mZnNldCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMuZml4ZWQgPSBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygem9uZS4gYGZpeGVkYCBmb3IgYWxsIGluc3RhbmNlcyBvZiBgRml4ZWRPZmZzZXRab25lYC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJmaXhlZFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQWxsIGZpeGVkIHpvbmVzJyBuYW1lcyBhbHdheXMgc3RhcnQgd2l0aCBcIlVUQ1wiIChwbHVzIG9wdGlvbmFsIG9mZnNldClcbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZCA9PT0gMCA/IFwiVVRDXCIgOiBgVVRDJHtmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUFOQSBuYW1lIG9mIHRoaXMgem9uZSwgaS5lLiBgRXRjL1VUQ2Agb3IgYEV0Yy9HTVQrLy1ubmBcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaWFuYU5hbWUoKSB7XG4gICAgaWYgKHRoaXMuZml4ZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBcIkV0Yy9VVENcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBFdGMvR01UJHtmb3JtYXRPZmZzZXQoLXRoaXMuZml4ZWQsIFwibmFycm93XCIpfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIGNvbW1vbiBuYW1lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKlxuICAgKiBGb3IgZml4ZWQgb2Zmc2V0IHpvbmVzIHRoaXMgZXF1YWxzIHRvIHRoZSB6b25lIG5hbWUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG9mZnNldCBpcyBrbm93biB0byBiZSBmaXhlZCBmb3IgdGhlIHdob2xlIHllYXI6XG4gICAqIEFsd2F5cyByZXR1cm5zIHRydWUgZm9yIGFsbCBmaXhlZCBvZmZzZXQgem9uZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEZvciBmaXhlZCBvZmZzZXQgem9uZXMsIHRoaXMgaXMgY29uc3RhbnQgYW5kIGRvZXMgbm90IGRlcGVuZCBvbiBhIHRpbWVzdGFtcC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgZXF1YWwgdG8gYW5vdGhlciB6b25lIChpLmUuIGFsc28gZml4ZWQgYW5kIHNhbWUgb2Zmc2V0KVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImZpeGVkXCIgJiYgb3RoZXJab25lLmZpeGVkID09PSB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZDpcbiAgICogQWxsIGZpeGVkIG9mZnNldCB6b25lcyBhcmUgdmFsaWQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/fixedOffsetZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/invalidZone.js":
/*!*****************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/zones/invalidZone.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InvalidZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js\");\n\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n * @implements {Zone}\n */\nclass InvalidZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(zoneName) {\n    super();\n    /**  @private */\n    this.zoneName = zoneName;\n  }\n\n  /** @override **/\n  get type() {\n    return \"invalid\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName() {\n    return null;\n  }\n\n  /** @override **/\n  formatOffset() {\n    return \"\";\n  }\n\n  /** @override **/\n  offset() {\n    return NaN;\n  }\n\n  /** @override **/\n  equals() {\n    return false;\n  }\n\n  /** @override **/\n  get isValid() {\n    return false;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvaW52YWxpZFpvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEI7O0FBRTlCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDZSwwQkFBMEIsZ0RBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9pbnZhbGlkWm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgY29uc3RydWN0b3Ioem9uZU5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/invalidZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/systemZone.js":
/*!****************************************************************!*\
  !*** ../fjell-core/node_modules/luxon/src/zones/systemZone.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SystemZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-core/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * Represents the local zone for this JavaScript environment.\n * @implements {Zone}\n */\nclass SystemZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of the local zone\n   * @return {SystemZone}\n   */\n  static get instance() {\n    if (singleton === null) {\n      singleton = new SystemZone();\n    }\n    return singleton;\n  }\n\n  /** @override **/\n  get type() {\n    return \"system\";\n  }\n\n  /** @override **/\n  get name() {\n    return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    return -new Date(ts).getTimezoneOffset();\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"system\";\n  }\n\n  /** @override **/\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1jb3JlL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvc3lzdGVtWm9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFDaEM7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDZSx5QkFBeUIsZ0RBQUk7QUFDNUM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkMsV0FBVyw0REFBYTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyREFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLWNvcmUvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9zeXN0ZW1ab25lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGxvY2FsIHpvbmUgZm9yIHRoaXMgSmF2YVNjcmlwdCBlbnZpcm9ubWVudC5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeXN0ZW1ab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGxvY2FsIHpvbmVcbiAgICogQHJldHVybiB7U3lzdGVtWm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgaW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IFN5c3RlbVpvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICByZXR1cm4gLW5ldyBEYXRlKHRzKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-core/node_modules/luxon/src/zones/systemZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/dist/index.js":
/*!****************************************!*\
  !*** ../fjell-providers/dist/index.js ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItem: () => (/* binding */ AItem_exports),\n/* harmony export */   AItemAdapter: () => (/* binding */ AItemAdapter_exports),\n/* harmony export */   AItems: () => (/* binding */ AItems_exports),\n/* harmony export */   CItem: () => (/* binding */ CItem_exports),\n/* harmony export */   CItemAdapter: () => (/* binding */ CItemAdapter_exports),\n/* harmony export */   CItemFacet: () => (/* binding */ CItemFacet),\n/* harmony export */   CItemLoad: () => (/* binding */ CItemLoad),\n/* harmony export */   CItemQuery: () => (/* binding */ CItemQuery),\n/* harmony export */   CItems: () => (/* binding */ CItems_exports),\n/* harmony export */   CItemsFacet: () => (/* binding */ CItemsFacet),\n/* harmony export */   CItemsFind: () => (/* binding */ CItemsFind),\n/* harmony export */   CItemsProvider: () => (/* binding */ CItemsProvider),\n/* harmony export */   CItemsQuery: () => (/* binding */ CItemsQuery),\n/* harmony export */   Faceted: () => (/* binding */ Faceted_exports),\n/* harmony export */   PItem: () => (/* binding */ PItem_exports),\n/* harmony export */   PItemAdapter: () => (/* binding */ PItemAdapter_exports),\n/* harmony export */   PItemFacet: () => (/* binding */ PItemFacet),\n/* harmony export */   PItemLoad: () => (/* binding */ PItemLoad),\n/* harmony export */   PItemQuery: () => (/* binding */ PItemQuery),\n/* harmony export */   PItems: () => (/* binding */ PItems_exports),\n/* harmony export */   PItemsFacet: () => (/* binding */ PItemsFacet),\n/* harmony export */   PItemsFind: () => (/* binding */ PItemsFind),\n/* harmony export */   PItemsProvider: () => (/* binding */ PItemsProvider),\n/* harmony export */   PItemsQuery: () => (/* binding */ PItemsQuery),\n/* harmony export */   createStableHash: () => (/* binding */ createStableHash),\n/* harmony export */   createStableMemo: () => (/* binding */ createStableMemo),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useCacheItem: () => (/* binding */ useCacheItem),\n/* harmony export */   useCacheQuery: () => (/* binding */ useCacheQuery),\n/* harmony export */   useCacheSubscription: () => (/* binding */ useCacheSubscription),\n/* harmony export */   withAsyncErrorHandling: () => (/* binding */ withAsyncErrorHandling)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var _fjell_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fjell/cache */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/cache/dist/index.js\");\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fjell/core */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/core/dist/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$();\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/AItemAdapter.tsx\nvar AItemAdapter_exports = {};\n__export(AItemAdapter_exports, {\n    useAItemAdapter: ()=>useAItemAdapter\n});\n\nvar useAItemAdapter = (context, contextName)=>{\n    _s();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s(useAItemAdapter, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\n// src/AItem.tsx\nvar AItem_exports = {};\n__export(AItem_exports, {\n    useAItem: ()=>useAItem\n});\n\nvar useAItem = (context, contextName)=>{\n    _s1();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s1(useAItem, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\n// src/AItems.tsx\nvar AItems_exports = {};\n__export(AItems_exports, {\n    useAItems: ()=>useAItems\n});\n\nvar useAItems = (context, contextName)=>{\n    _s2();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s2(useAItems, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\n// src/contained/CItemAdapter.tsx\nvar CItemAdapter_exports = {};\n__export(CItemAdapter_exports, {\n    Adapter: ()=>Adapter,\n    useCItemAdapter: ()=>useCItemAdapter\n});\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLogger(\"@fjell/providers\");\nvar logger_default = LibLogger;\n// src/contained/CItemAdapter.tsx\n\n\n\nvar logger = logger_default.get(\"CItemAdapter\");\nvar useCItemAdapter = (context, contextName)=>{\n    _s3();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s3(useCItemAdapter, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\nvar Adapter = (param)=>{\n    let { name, cache, context, aggregates = {}, events = {}, addActions, addFacets, addAllActions, addAllFacets, children } = param;\n    _s4();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Adapter.useEffect\": ()=>{\n            if (!cache) {\n                logger.error(\"Cache is undefined in %s. This will cause all operations to fail.\", name);\n            }\n        }\n    }[\"Adapter.useEffect\"], [\n        cache,\n        name\n    ]);\n    const pkTypes = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"Adapter.useMemo[pkTypes]\": ()=>cache === null || cache === void 0 ? void 0 : cache.coordinate.kta\n    }[\"Adapter.useMemo[pkTypes]\"], [\n        cache\n    ]);\n    const sourceCache = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"Adapter.useMemo[sourceCache]\": ()=>{\n            if (!cache) {\n                logger.error(\"No cache provided to %s, operations will fail\", name);\n                return null;\n            }\n            if (aggregates && Object.keys(aggregates).length > 0 || events && Object.keys(events).length > 0) {\n                return (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_2__.createAggregator)(cache, {\n                    aggregates,\n                    events\n                });\n            } else {\n                return cache;\n            }\n        }\n    }[\"Adapter.useMemo[sourceCache]\"], [\n        cache,\n        aggregates,\n        events,\n        name\n    ]);\n    const [resolvedSourceCache, setResolvedSourceCache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [, setCacheVersion] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Adapter.useEffect\": ()=>{\n            if (sourceCache) {\n                if (\"then\" in sourceCache && typeof sourceCache.then === \"function\") {\n                    sourceCache.then({\n                        \"Adapter.useEffect\": (c)=>{\n                            setResolvedSourceCache(c);\n                        }\n                    }[\"Adapter.useEffect\"]).catch({\n                        \"Adapter.useEffect\": (error)=>{\n                            logger.error(\"Failed to initialize source cache in %s: %s\", name, error);\n                        }\n                    }[\"Adapter.useEffect\"]);\n                } else {\n                    setResolvedSourceCache(sourceCache);\n                }\n            }\n        }\n    }[\"Adapter.useEffect\"], [\n        sourceCache,\n        name\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Adapter.useEffect\": ()=>{\n            if (!resolvedSourceCache || typeof resolvedSourceCache.subscribe !== \"function\") {\n                return;\n            }\n            try {\n                const subscription = resolvedSourceCache.subscribe({\n                    \"Adapter.useEffect.subscription\": (event)=>{\n                        setCacheVersion({\n                            \"Adapter.useEffect.subscription\": (prev)=>prev + 1\n                        }[\"Adapter.useEffect.subscription\"]);\n                        logger.debug(\"Cache event in \".concat(name, \":\"), event.type, event);\n                    }\n                }[\"Adapter.useEffect.subscription\"], {\n                    // Subscribe to all cache events for this adapter\n                    eventTypes: [\n                        \"item_created\",\n                        \"item_updated\",\n                        \"item_removed\",\n                        \"item_retrieved\",\n                        \"item_set\",\n                        \"items_queried\",\n                        \"cache_cleared\",\n                        \"location_invalidated\",\n                        \"query_invalidated\"\n                    ],\n                    debounceMs: 50\n                });\n                return ({\n                    \"Adapter.useEffect\": ()=>{\n                        if (subscription && typeof subscription.unsubscribe === \"function\") {\n                            subscription.unsubscribe();\n                        }\n                    }\n                })[\"Adapter.useEffect\"];\n            } catch (error) {\n                logger.debug(\"Cache subscription not available in \".concat(name, \":\"), error);\n                return ({\n                    \"Adapter.useEffect\": ()=>{}\n                })[\"Adapter.useEffect\"];\n            }\n        }\n    }[\"Adapter.useEffect\"], [\n        resolvedSourceCache,\n        name\n    ]);\n    const handleCacheError = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[handleCacheError]\": (operation)=>{\n            logger.error('Cache not initialized in %s. Operation \"%s\" failed.', name, operation);\n            throw new Error(\"Cache not initialized in \".concat(name, '. Operation \"').concat(operation, '\" failed.'));\n        }\n    }[\"Adapter.useCallback[handleCacheError]\"], [\n        name\n    ]);\n    const all = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[all]\": async (query, locations)=>{\n            logger.trace(\"all\", {\n                query: query && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query),\n                cache: cache === null || cache === void 0 ? void 0 : cache.coordinate.kta,\n                locations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(locations)\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"all\");\n            }\n            logger.debug(\"Fetching Items from sourceCache.all\");\n            const items = await resolvedSourceCache.operations.all(query, locations);\n            return items;\n        }\n    }[\"Adapter.useCallback[all]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const one = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[one]\": async (query, locations)=>{\n            logger.trace(\"one\", {\n                query: query && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query),\n                locations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(locations)\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"one\");\n            }\n            const item = await resolvedSourceCache.operations.one(query, locations);\n            return item;\n        }\n    }[\"Adapter.useCallback[one]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const create = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[create]\": async (item, locations)=>{\n            logger.trace(\"create\", {\n                item,\n                locations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(locations)\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"create\");\n            }\n            const newItem = await resolvedSourceCache.operations.create(item, locations);\n            return newItem;\n        }\n    }[\"Adapter.useCallback[create]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const get = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[get]\": async (key)=>{\n            logger.trace(\"get\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key)\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"get\");\n            }\n            const item = await resolvedSourceCache.operations.get(key);\n            return item;\n        }\n    }[\"Adapter.useCallback[get]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const remove = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[remove]\": async (key)=>{\n            logger.trace(\"remove\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key)\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"remove\");\n            }\n            await resolvedSourceCache.operations.remove(key);\n        }\n    }[\"Adapter.useCallback[remove]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const retrieve = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[retrieve]\": async (key)=>{\n            logger.trace(\"retrieve\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key)\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"retrieve\");\n            }\n            const item = await resolvedSourceCache.operations.retrieve(key);\n            return item;\n        }\n    }[\"Adapter.useCallback[retrieve]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const update = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[update]\": async (key, item)=>{\n            logger.trace(\"update\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                item\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"update\");\n            }\n            const newItem = await resolvedSourceCache.operations.update(key, item);\n            return newItem;\n        }\n    }[\"Adapter.useCallback[update]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const action = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[action]\": async (key, action2, body)=>{\n            logger.trace(\"action\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                action: action2,\n                body\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"action\");\n            }\n            const newItem = await resolvedSourceCache.operations.action(key, action2, body);\n            return newItem;\n        }\n    }[\"Adapter.useCallback[action]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const allAction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[allAction]\": async (action2, body, locations)=>{\n            logger.trace(\"allAction\", {\n                locations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(locations),\n                action: action2,\n                body\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"allAction\");\n            }\n            const newItems = await resolvedSourceCache.operations.allAction(action2, body, locations);\n            return newItems;\n        }\n    }[\"Adapter.useCallback[allAction]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const facet = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[facet]\": async (key, facet2)=>{\n            logger.trace(\"facet\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                facet: facet2\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"facet\");\n            }\n            const response = await resolvedSourceCache.operations.facet(key, facet2);\n            return response;\n        }\n    }[\"Adapter.useCallback[facet]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const allFacet = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[allFacet]\": async (facet2, params)=>{\n            logger.trace(\"allFacet\", {\n                facet: facet2,\n                params\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"allFacet\");\n            }\n            const response = await resolvedSourceCache.operations.allFacet(facet2, params);\n            return response;\n        }\n    }[\"Adapter.useCallback[allFacet]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const find = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[find]\": async (finder, finderParams, locations)=>{\n            logger.trace(\"find\", {\n                finder,\n                finderParams,\n                locations\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"find\");\n            }\n            const newItems = await resolvedSourceCache.operations.find(finder, finderParams, locations);\n            return newItems;\n        }\n    }[\"Adapter.useCallback[find]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const findOne = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[findOne]\": async (finder, finderParams, locations)=>{\n            logger.trace(\"findOne\", {\n                finder,\n                finderParams,\n                locations\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"findOne\");\n            }\n            const newItems = await resolvedSourceCache.operations.findOne(finder, finderParams, locations);\n            return newItems;\n        }\n    }[\"Adapter.useCallback[findOne]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const set = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Adapter.useCallback[set]\": async (key, item)=>{\n            logger.trace(\"set\", {\n                key,\n                item\n            });\n            if (!resolvedSourceCache) {\n                return handleCacheError(\"set\");\n            }\n            const newItem = await resolvedSourceCache.operations.set(key, item);\n            return newItem;\n        }\n    }[\"Adapter.useCallback[set]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"Adapter.useMemo[contextValue]\": ()=>({\n                name,\n                pkTypes: pkTypes || [],\n                all,\n                one,\n                create,\n                get,\n                remove,\n                retrieve,\n                update,\n                action,\n                allAction,\n                facet,\n                allFacet,\n                find,\n                findOne,\n                set,\n                addActions,\n                addFacets,\n                addAllActions,\n                addAllFacets\n            })\n    }[\"Adapter.useMemo[contextValue]\"], [\n        name,\n        pkTypes,\n        all,\n        one,\n        create,\n        get,\n        remove,\n        retrieve,\n        update,\n        action,\n        allAction,\n        facet,\n        allFacet,\n        find,\n        findOne,\n        set,\n        addActions,\n        addFacets,\n        addAllActions,\n        addAllFacets\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: contextValue\n    }, children);\n};\n_s4(Adapter, \"VUV/dsy4BCrvXJefGvYlgW/0mEo=\");\n_c = Adapter;\n// src/contained/CItem.tsx\nvar CItem_exports = {};\n__export(CItem_exports, {\n    useCItem: ()=>useCItem\n});\n\nvar useCItem = (context, contextName)=>{\n    _s5();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s5(useCItem, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\n// src/contained/CItems.tsx\nvar CItems_exports = {};\n__export(CItems_exports, {\n    useCItems: ()=>useCItems\n});\n\nvar useCItems = (context, contextName)=>{\n    _s6();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s6(useCItems, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\n// src/contained/CItemFacet.tsx\n\n// src/utils.ts\nfunction createStableHash(obj) {\n    if (obj === null) return \"null\";\n    if (obj === void 0) return \"undefined\";\n    if (typeof obj !== \"object\") return String(obj);\n    const seen = /* @__PURE__ */ new WeakSet();\n    function serialize(value) {\n        if (value === null) return \"null\";\n        if (value === void 0) return \"undefined\";\n        if (typeof value !== \"object\") {\n            return typeof value === \"string\" ? '\"'.concat(value, '\"') : String(value);\n        }\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n        if (Array.isArray(value)) {\n            const result2 = \"[\" + value.map(serialize).join(\",\") + \"]\";\n            seen.delete(value);\n            return result2;\n        }\n        if (value instanceof Date) {\n            const result2 = \"Date(\".concat(value.getTime(), \")\");\n            seen.delete(value);\n            return result2;\n        }\n        const keys = Object.keys(value).sort();\n        const result = \"{\" + keys.map((key)=>'\"'.concat(key, '\":').concat(serialize(value[key]))).join(\",\") + \"}\";\n        seen.delete(value);\n        return result;\n    }\n    return serialize(obj);\n}\nfunction createStableMemo(obj) {\n    return createStableHash(obj);\n}\nfunction isPromise(value) {\n    return value !== null && value !== void 0 && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\" && \"catch\" in value && typeof value.catch === \"function\";\n}\nfunction deepEqual(a, b) {\n    let visitedPairs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new WeakMap();\n    if (a === b) return true;\n    if (a === null || b === null || a === void 0 || b === void 0) {\n        return a === b;\n    }\n    if (typeof a !== typeof b) return false;\n    if (typeof a !== \"object\") return a === b;\n    if (visitedPairs.has(a)) {\n        const visitedB = visitedPairs.get(a);\n        if (visitedB === b) return true;\n        if (visitedB !== void 0) return false;\n    }\n    visitedPairs.set(a, b);\n    if (Array.isArray(a) !== Array.isArray(b)) return false;\n    if (Array.isArray(a)) {\n        if (a.length !== b.length) return false;\n        for(let i = 0; i < a.length; i++){\n            if (!deepEqual(a[i], b[i], visitedPairs)) return false;\n        }\n        return true;\n    }\n    if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n    }\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n    if (keysA.length !== keysB.length) return false;\n    const keysBSet = new Set(keysB);\n    for (const key of keysA){\n        if (!keysBSet.has(key)) return false;\n        if (!deepEqual(a[key], b[key], visitedPairs)) return false;\n    }\n    return true;\n}\n// src/contained/CItemFacet.tsx\nvar CItemFacet = (param)=>{\n    let { adapter, children, context: itemContext, contextName, adapterContext, facet, facetParams = {} } = param;\n    _s7();\n    const [result, setResult] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const adapterContextName = adapterContext || \"\".concat(contextName, \"Adapter\");\n    const adapterContextInstance = useCItemAdapter(adapter, adapterContextName);\n    const itemContextValue = useCItem(itemContext, contextName);\n    const facetParamsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemFacet.useMemo2[facetParamsString]\": ()=>createStableHash(facetParams)\n    }[\"CItemFacet.useMemo2[facetParamsString]\"], [\n        facetParams\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemFacet.useEffect2\": ()=>{\n            if (facet && facetParams && itemContextValue && itemContextValue.key && adapterContextInstance) {\n                ({\n                    \"CItemFacet.useEffect2\": async ()=>{\n                        try {\n                            const result2 = await adapterContextInstance.facet(itemContextValue.key, facet, facetParams);\n                            setResult(result2);\n                            setIsLoading(false);\n                        } catch (e) {\n                            setResult(null);\n                            setIsLoading(false);\n                        }\n                    }\n                })[\"CItemFacet.useEffect2\"]();\n            }\n        }\n    }[\"CItemFacet.useEffect2\"], [\n        facet,\n        facetParamsString,\n        itemContextValue === null || itemContextValue === void 0 ? void 0 : itemContextValue.key,\n        itemContextValue === null || itemContextValue === void 0 ? void 0 : itemContextValue.locations\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemFacet.useMemo2[contextValue]\": ()=>{\n            if (!itemContextValue) return itemContextValue;\n            const updatedFacetResults = {\n                ...itemContextValue.facetResults\n            };\n            if (result) {\n                if (!updatedFacetResults[facet]) {\n                    updatedFacetResults[facet] = {};\n                }\n                updatedFacetResults[facet] = {\n                    ...updatedFacetResults[facet],\n                    [facetParamsString]: result\n                };\n            }\n            return {\n                ...itemContextValue,\n                facetResults: updatedFacetResults,\n                isLoading: isLoading || itemContextValue.isLoading\n            };\n        }\n    }[\"CItemFacet.useMemo2[contextValue]\"], [\n        itemContextValue,\n        result,\n        isLoading,\n        facet,\n        facetParamsString\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(itemContext.Provider, {\n        value: contextValue\n    }, children);\n};\n_s7(CItemFacet, \"qtXD6q5Ydq1CvLzwaLFNeGTqeaA=\", false, function() {\n    return [\n        useCItemAdapter,\n        useCItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo\n    ];\n});\n_c1 = CItemFacet;\n// src/contained/CItemLoad.tsx\n\n\n// src/useAsyncError.ts\n\nvar useAsyncError = ()=>{\n    _s8();\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    if (error) {\n        throw error;\n    }\n    const throwAsyncError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAsyncError.useCallback2[throwAsyncError]\": (error2)=>{\n            setError(error2);\n        }\n    }[\"useAsyncError.useCallback2[throwAsyncError]\"], []);\n    const clearError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAsyncError.useCallback2[clearError]\": ()=>{\n            setError(null);\n        }\n    }[\"useAsyncError.useCallback2[clearError]\"], []);\n    return {\n        throwAsyncError,\n        clearError\n    };\n};\n_s8(useAsyncError, \"rtfRitmPq328GLwGh24fKM+w7Sw=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n    ];\n});\nvar withAsyncErrorHandling = function(asyncFn, throwAsyncError) {\n    let optional = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    return async function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        try {\n            return await asyncFn(...args);\n        } catch (error) {\n            if (!optional) {\n                const errorInstance = error instanceof Error ? error : new Error(String(error));\n                throwAsyncError(errorInstance);\n            }\n            return null;\n        }\n    };\n};\n// src/contained/CItemLoad.tsx\nvar logger2 = logger_default.get(\"CItemLoad\");\nvar CItemLoad = (param)=>{\n    let { name, adapter, children, context, contextName, ik, item: providedItem, parent, parentContextName } = param;\n    _s9();\n    const { throwAsyncError } = useAsyncError();\n    if (ik !== void 0 && providedItem !== void 0) {\n        const errorMessage = \"\".concat(name, \": Cannot provide both 'ik' and 'item' parameters. Please provide only one.\");\n        logger2.error(errorMessage);\n        throw new Error(errorMessage);\n    }\n    const [itemKey, setItemKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(providedItem !== void 0 ? false : true);\n    const [isUpdating, setIsUpdating] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isRemoving, setIsRemoving] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const cItemAdapter = useCItemAdapter(adapter, contextName);\n    const { pkTypes, retrieve: retrieveItem, remove: removeItem, update: updateItem, action: actionItem, facet: facetItem, set: setCacheItem, addActions, addFacets } = cItemAdapter;\n    const parentItemAdapter = useAItem(parent, parentContextName);\n    const { item: parentItem } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemLoad.useMemo3\": ()=>parentItemAdapter\n    }[\"CItemLoad.useMemo3\"], [\n        parentItemAdapter\n    ]);\n    const [item, setItemState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const locations = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemLoad.useMemo3[locations]\": ()=>{\n            if (item) {\n                return (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.ikToLKA)(item.key);\n            } else {\n                return null;\n            }\n        }\n    }[\"CItemLoad.useMemo3[locations]\"], [\n        item\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemLoad.useEffect3\": ()=>{\n            logger2.trace(\"useEffect[ik]\", {\n                ik,\n                providedItem\n            });\n            if (providedItem !== void 0) {\n                if (providedItem && providedItem.key) {\n                    logger2.debug(\"Using key from provided item\", {\n                        itemKey: providedItem.key\n                    });\n                    setItemKey(providedItem.key);\n                } else {\n                    logger2.debug(\"Provided item is null or has no key\");\n                    setItemKey(void 0);\n                }\n                return;\n            }\n            if (ik) {\n                if ((0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isComKey)(ik)) {\n                    logger2.debug(\"Key has been provided\", {\n                        ik\n                    });\n                    setItemKey(ik);\n                } else {\n                    const errorMessage = \"\".concat(name, \": Key is not a ComKey\");\n                    logger2.error(errorMessage, {\n                        ik\n                    });\n                    setIsLoading(false);\n                    throwAsyncError(new Error(errorMessage));\n                }\n            } else {\n                logger2.debug(\"No item key was provided, no item will be retrieved\", {\n                    ik\n                });\n                setIsLoading(false);\n                setItemKey(void 0);\n            }\n        }\n    }[\"CItemLoad.useEffect3\"], [\n        ik,\n        providedItem\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemLoad.useEffect3\": ()=>{\n            if (providedItem !== void 0) {\n                logger2.debug(\"Using provided item directly\", {\n                    providedItem\n                });\n                setItemState(providedItem);\n                setIsLoading(false);\n                setIsUpdating(false);\n                setIsRemoving(false);\n                return;\n            }\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidComKey)(itemKey)) {\n                ({\n                    \"CItemLoad.useEffect3\": async ()=>{\n                        try {\n                            logger2.trace(\"useEffect[itemKey]\", {\n                                itemKey: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(itemKey)\n                            });\n                            setIsLoading(true);\n                            const retrievedItem = await retrieveItem(itemKey);\n                            setItemState(retrievedItem);\n                            setIsLoading(false);\n                            setIsUpdating(false);\n                            setIsRemoving(false);\n                        } catch (error) {\n                            logger2.error(\"\".concat(name, \": Error retrieving item\"), error);\n                            setItemState(null);\n                            setIsLoading(false);\n                            setIsUpdating(false);\n                            setIsRemoving(false);\n                            throwAsyncError(error);\n                        }\n                    }\n                })[\"CItemLoad.useEffect3\"]();\n            } else {\n                setItemState(null);\n                setIsLoading(false);\n                setIsUpdating(false);\n                setIsRemoving(false);\n            }\n        }\n    }[\"CItemLoad.useEffect3\"], [\n        itemKey,\n        providedItem,\n        retrieveItem,\n        name\n    ]);\n    const remove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemLoad.useCallback3[remove]\": async ()=>{\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidComKey)(itemKey)) {\n                setIsRemoving(true);\n                try {\n                    logger2.trace(\"remove\", {\n                        ik: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(itemKey)\n                    });\n                    await removeItem(itemKey);\n                } catch (error) {\n                    logger2.error(\"\".concat(name, \": Error removing item\"), error);\n                    throw error;\n                } finally{\n                    setIsRemoving(false);\n                }\n            } else {\n                const errorMessage = itemKey ? \"\".concat(name, \": Invalid item key provided for remove\") : \"\".concat(name, \": No item key provided for remove\");\n                logger2.error(errorMessage, {\n                    itemKey\n                });\n                throw new Error(errorMessage);\n            }\n        }\n    }[\"CItemLoad.useCallback3[remove]\"], [\n        removeItem,\n        itemKey,\n        name\n    ]);\n    const update = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemLoad.useCallback3[update]\": async (item2)=>{\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidComKey)(itemKey)) {\n                if (item2) {\n                    setIsUpdating(true);\n                    try {\n                        logger2.trace(\"update\", {\n                            itemKey: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(itemKey),\n                            item: item2\n                        });\n                        const retItem = await updateItem(itemKey, item2);\n                        return retItem;\n                    } catch (error) {\n                        logger2.error(\"\".concat(name, \": Error updating item\"), error);\n                        throw error;\n                    } finally{\n                        setIsUpdating(false);\n                    }\n                } else {\n                    const errorMessage = \"\".concat(name, \": No item provided for update\");\n                    throw new Error(errorMessage);\n                }\n            } else {\n                const errorMessage = itemKey ? \"\".concat(name, \": Invalid item key provided for update\") : \"\".concat(name, \": No item key provided for update\");\n                logger2.error(errorMessage, {\n                    itemKey\n                });\n                throw new Error(errorMessage);\n            }\n        }\n    }[\"CItemLoad.useCallback3[update]\"], [\n        updateItem,\n        itemKey,\n        name\n    ]);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemLoad.useCallback3[set]\": async (item2)=>{\n            logger2.trace(\"set\", {\n                item: item2\n            });\n            if (item2 && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidComKey)(item2.key)) {\n                const retItem = await setCacheItem(item2.key, item2);\n                return retItem;\n            } else {\n                const errorMessage = !item2 ? \"\".concat(name, \": No item provided to set\") : \"\".concat(name, \": Invalid or missing key in item provided to set\");\n                logger2.error(errorMessage, {\n                    item: item2\n                });\n                throw new Error(errorMessage);\n            }\n        }\n    }[\"CItemLoad.useCallback3[set]\"], [\n        setCacheItem,\n        name\n    ]);\n    const action = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemLoad.useCallback3[action]\": async (actionName, body)=>{\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidComKey)(itemKey)) {\n                setIsUpdating(true);\n                try {\n                    logger2.trace(\"action\", {\n                        itemKey: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(itemKey),\n                        actionName,\n                        body\n                    });\n                    const retItem = await actionItem(itemKey, actionName, body);\n                    return retItem;\n                } catch (error) {\n                    logger2.error(\"\".concat(name, \": Error executing action '\").concat(actionName, \"'\"), error);\n                    throw error;\n                } finally{\n                    setIsUpdating(false);\n                }\n            } else {\n                const errorMessage = itemKey ? \"\".concat(name, \": Invalid item key provided for action '\").concat(actionName, \"'\") : \"\".concat(name, \": No item key provided for action '\").concat(actionName, \"'\");\n                logger2.error(errorMessage, {\n                    itemKey,\n                    actionName\n                });\n                throw new Error(errorMessage);\n            }\n        }\n    }[\"CItemLoad.useCallback3[action]\"], [\n        actionItem,\n        itemKey,\n        name\n    ]);\n    const facet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemLoad.useCallback3[facet]\": async (facetName, params)=>{\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidComKey)(itemKey)) {\n                setIsUpdating(true);\n                try {\n                    logger2.trace(\"facet\", {\n                        itemKey: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(itemKey),\n                        facetName\n                    });\n                    const response = await facetItem(itemKey, facetName, params);\n                    return response;\n                } catch (error) {\n                    logger2.error(\"\".concat(name, \": Error executing facet '\").concat(facetName, \"'\"), error);\n                    throw error;\n                } finally{\n                    setIsUpdating(false);\n                }\n            } else {\n                const errorMessage = itemKey ? \"\".concat(name, \": Invalid item key provided for facet '\").concat(facetName, \"'\") : \"\".concat(name, \": No item key provided for facet '\").concat(facetName, \"'\");\n                logger2.error(errorMessage, {\n                    itemKey,\n                    facetName\n                });\n                throw new Error(errorMessage);\n            }\n        }\n    }[\"CItemLoad.useCallback3[facet]\"], [\n        facetItem,\n        itemKey,\n        name\n    ]);\n    const contextValue = {\n        name,\n        key: itemKey,\n        item,\n        parentItem,\n        isLoading,\n        isUpdating,\n        isRemoving,\n        pkTypes,\n        remove,\n        update,\n        action,\n        facet,\n        set,\n        locations,\n        facetResults: {}\n    };\n    logger2.debug(\"\".concat(name, \": Context value created\"), {\n        name: contextValue.name,\n        hasKey: !!contextValue.key,\n        hasItem: !!contextValue.item,\n        isLoading: contextValue.isLoading,\n        isUpdating: contextValue.isUpdating,\n        isRemoving: contextValue.isRemoving,\n        pkTypes: contextValue.pkTypes,\n        hasLocations: !!contextValue.locations\n    });\n    contextValue.actions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemLoad.useMemo3\": ()=>addActions && addActions(contextValue.action)\n    }[\"CItemLoad.useMemo3\"], [\n        addActions,\n        contextValue.action\n    ]);\n    contextValue.facets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemLoad.useMemo3\": ()=>addFacets && addFacets(contextValue.facet)\n    }[\"CItemLoad.useMemo3\"], [\n        addFacets,\n        contextValue.facet\n    ]);\n    logger2.debug(\"\".concat(name, \": Creating context provider element\"), {\n        hasContext: !!context,\n        hasChildren: !!children\n    });\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(context.Provider, {\n        value: contextValue\n    }, children);\n};\n_s9(CItemLoad, \"Ag+oAdmuAdANQMe60p1uRu8rI00=\", false, function() {\n    return [\n        useAsyncError,\n        useCItemAdapter,\n        useAItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo\n    ];\n});\n_c2 = CItemLoad;\n// src/contained/CItemQuery.tsx\n\n\nvar logger3 = logger_default.get(\"CItemQueryProvider\");\nvar CItemQuery = (param)=>{\n    let { name, adapter, children, context, contextName, create, loading, notFound, optional = false, parent, parentContextName, query } = param;\n    _s10();\n    const [itemKey, setItemKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0);\n    const [queryRunning, setQueryRunning] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const { throwAsyncError } = useAsyncError();\n    const cItemAdapter = useCItemAdapter(adapter, contextName);\n    const { one: oneItem, create: createItem } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemQuery.useMemo4\": ()=>cItemAdapter\n    }[\"CItemQuery.useMemo4\"], [\n        cItemAdapter\n    ]);\n    const parentItemContext = useAItem(parent, parentContextName);\n    const { locations: parentLocations } = parentItemContext;\n    const queryString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemQuery.useMemo4[queryString]\": ()=>createStableHash(query)\n    }[\"CItemQuery.useMemo4[queryString]\"], [\n        query\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemQuery.useEffect4\": ()=>{\n            if (!query) {\n                setQueryRunning(false);\n                return;\n            } else {\n                ({\n                    \"CItemQuery.useEffect4\": async ()=>{\n                        logger3.default(\"\".concat(name, \": Running CItemProvder Query\"), {\n                            query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query),\n                            parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                        });\n                        if (parentLocations) {\n                            try {\n                                const item = await oneItem(query, parentLocations);\n                                if (item) {\n                                    logger3.default(\"\".concat(name, \": Setting Item Key After oneItem\"), {\n                                        itemKey: item.key\n                                    });\n                                    setItemKey(item.key);\n                                    setQueryRunning(false);\n                                } else if (create) {\n                                    logger3.default(\"Creating new item\", {\n                                        create,\n                                        parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                                    });\n                                    const newItem = await createItem(create, parentLocations);\n                                    logger3.default(\"\".concat(name, \": Setting Item Key After createItem\"), {\n                                        itemKey: newItem.key\n                                    });\n                                    setItemKey(newItem.key);\n                                    setQueryRunning(false);\n                                } else {\n                                    if (!optional) {\n                                        setQueryRunning(false);\n                                        logger3.error(\"\".concat(name, \": Required Item not found, and no create provided\"), {\n                                            query,\n                                            optional\n                                        });\n                                        throwAsyncError(new Error(\"Required Item not found, and no create provided in \".concat(name)));\n                                    } else {\n                                        setQueryRunning(false);\n                                        logger3.default(\"Optional item not found, item will be null\", {\n                                            query,\n                                            optional\n                                        });\n                                    }\n                                }\n                            } catch (err) {\n                                if (create && parentLocations) {\n                                    logger3.default(\"Creating new item after exception throw for NotFound\", {\n                                        err,\n                                        create,\n                                        parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                                    });\n                                    const newItem = await createItem(create, parentLocations);\n                                    logger3.default(\"\".concat(name, \": Setting Item Key After createItem during Exception\"), {\n                                        itemKey: newItem.key\n                                    });\n                                    setItemKey(newItem.key);\n                                    setQueryRunning(false);\n                                } else {\n                                    if (!optional) {\n                                        setQueryRunning(false);\n                                        throwAsyncError(err);\n                                    } else {\n                                        setQueryRunning(false);\n                                        logger3.default(\"Optional item not found, item will be null\");\n                                    }\n                                }\n                            }\n                        } else {\n                            logger3.warning(\"\".concat(name, \": No parent locations provided\"), {\n                                query,\n                                optional\n                            });\n                        }\n                    }\n                })[\"CItemQuery.useEffect4\"]();\n            }\n        }\n    }[\"CItemQuery.useEffect4\"], [\n        queryString,\n        parentLocations\n    ]);\n    const returnContext = CItemLoad({\n        name,\n        ik: itemKey,\n        parent,\n        parentContextName,\n        adapter,\n        context,\n        contextName,\n        children\n    });\n    if (queryRunning) {\n        return loading;\n    } else if (itemKey || optional) {\n        return returnContext;\n    } else {\n        return notFound;\n    }\n};\n_s10(CItemQuery, \"bIz5+hg/crKa6W7NacQ+qMfY5JY=\", false, function() {\n    return [\n        useAsyncError,\n        useCItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        useAItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n_c3 = CItemQuery;\n// src/contained/CItemsFacet.tsx\n\n// src/contained/CItemsProvider.tsx\n\n\nvar logger4 = logger_default.get(\"CItemsProvider\");\nvar CItemsProvider = (param)=>{\n    let { name, adapter, children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null), context, contextName, parent, parentContextName, renderEach, items = [], facetResults = {}, isLoadingParam = false, overrides } = param;\n    _s11();\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const [isCreating, setIsCreating] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isUpdating, setIsUpdating] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isRemoving, setIsRemoving] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const adapterContext = useCItemAdapter(adapter, contextName);\n    const { pkTypes, all: allItems, one: oneItem, create: createItem, update: updateItem, remove: removeItem, allAction: allActionItem, allFacet: allFacetItem, action: actionItem, facet: facetItem, set: setItem, find: findItem, findOne: findOneItem, addAllActions, addAllFacets } = adapterContext;\n    const parentContext = useAItem(parent, parentContextName);\n    const parentLocations = parentContext.locations;\n    const parentItem = parentContext.item;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemsProvider.useEffect5\": ()=>{\n            setIsLoading(isLoadingParam);\n        }\n    }[\"CItemsProvider.useEffect5\"], [\n        isLoadingParam\n    ]);\n    const create = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[create]\": async (item)=>{\n            if (parentLocations) {\n                logger4.debug(\"\".concat(name, \": create\"), {\n                    item,\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsCreating(true);\n                try {\n                    const result = await createItem(item, parentLocations);\n                    return result;\n                } catch (error) {\n                    logger4.error(\"\".concat(name, \": Error creating item\"), error);\n                    throw error;\n                } finally{\n                    setIsCreating(false);\n                }\n            } else {\n                logger4.error(\"\".concat(name, \": No parent locations present to create containeditem\"), {\n                    item\n                });\n                throw new Error(\"No parent locations present to create containeditem in \".concat(name));\n            }\n        }\n    }[\"CItemsProvider.useCallback4[create]\"], [\n        createItem,\n        parentLocations\n    ]);\n    const update = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[update]\": async (key, item)=>{\n            logger4.debug(\"\".concat(name, \": update\"), {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                item\n            });\n            setIsUpdating(true);\n            try {\n                const result = await updateItem(key, item);\n                return result;\n            } catch (error) {\n                logger4.error(\"\".concat(name, \": Error updating item\"), error);\n                throw error;\n            } finally{\n                setIsUpdating(false);\n            }\n        }\n    }[\"CItemsProvider.useCallback4[update]\"], [\n        updateItem,\n        parentLocations\n    ]);\n    const remove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[remove]\": async (key)=>{\n            logger4.debug(\"\".concat(name, \": remove\"), {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key)\n            });\n            setIsRemoving(true);\n            try {\n                const result = await removeItem(key);\n                return result;\n            } catch (error) {\n                logger4.error(\"\".concat(name, \": Error removing item\"), error);\n                throw error;\n            } finally{\n                setIsRemoving(false);\n            }\n        }\n    }[\"CItemsProvider.useCallback4[remove]\"], [\n        removeItem,\n        parentLocations\n    ]);\n    const all = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[all]\": async ()=>{\n            if (parentLocations) {\n                logger4.debug(\"\".concat(name, \": all\"), {\n                    query: {},\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsLoading(true);\n                try {\n                    const result = await allItems({}, parentLocations);\n                    return result;\n                } catch (error) {\n                    logger4.error(\"\".concat(name, \": Error getting all items\"), error);\n                    throw error;\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                logger4.error(\"\".concat(name, \": No parent locations present to query for all containeditems\"));\n                throw new Error(\"No parent locations present to query for all containeditems in \".concat(name));\n            }\n        }\n    }[\"CItemsProvider.useCallback4[all]\"], [\n        allItems,\n        parentLocations\n    ]);\n    const one = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[one]\": async ()=>{\n            if (parentLocations) {\n                logger4.trace(\"one\", {\n                    query: {},\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsLoading(true);\n                try {\n                    const result = await oneItem({}, parentLocations);\n                    return result;\n                } catch (error) {\n                    logger4.error(\"\".concat(name, \": Error getting one item\"), error);\n                    throw error;\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                logger4.error(\"\".concat(name, \": No parent locations present to query for one containeditem\"));\n                throw new Error(\"No parent locations present to query for one containeditem in \".concat(name));\n            }\n        }\n    }[\"CItemsProvider.useCallback4[one]\"], [\n        oneItem,\n        parentLocations\n    ]);\n    const allAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[allAction]\": async function(action2) {\n            let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (parentLocations) {\n                logger4.info(\"allAction\", {\n                    action: action2,\n                    body,\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsUpdating(true);\n                try {\n                    const result = await allActionItem(action2, body, parentLocations);\n                    return result;\n                } catch (error) {\n                    logger4.error(\"\".concat(name, \": Error in allAction\"), error);\n                    throw error;\n                } finally{\n                    setIsUpdating(false);\n                }\n            } else {\n                logger4.error(\"\".concat(name, \": No parent locations present to query for allAction containeditems\"), {\n                    action: action2,\n                    body\n                });\n                throw new Error(\"No parent locations present to query for allAction containeditems in \".concat(name));\n            }\n        }\n    }[\"CItemsProvider.useCallback4[allAction]\"], [\n        allActionItem,\n        parentLocations\n    ]);\n    const allFacet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[allFacet]\": async function(facet2) {\n            let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (parentLocations) {\n                logger4.info(\"allFacet\", {\n                    facet: facet2,\n                    params,\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsUpdating(true);\n                try {\n                    const result = await allFacetItem(facet2, params, parentLocations);\n                    return result;\n                } finally{\n                    setIsUpdating(false);\n                }\n            }\n            const errorMessage = \"\".concat(name, \": No parent locations present to query for allFacet containeditems\");\n            logger4.error(errorMessage, {\n                facet: facet2,\n                params\n            });\n            throw new Error(errorMessage);\n        }\n    }[\"CItemsProvider.useCallback4[allFacet]\"], [\n        allFacetItem,\n        parentLocations\n    ]);\n    const action = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[action]\": async function(key, action2) {\n            let body = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (parentLocations) {\n                logger4.info(\"action\", {\n                    key,\n                    action: action2,\n                    body,\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsUpdating(true);\n                try {\n                    const result = await actionItem(key, action2, body, parentLocations);\n                    return result;\n                } finally{\n                    setIsUpdating(false);\n                }\n            } else {\n                throw new Error(\"No parent locations present to query for action \".concat(action2, \" in \").concat(name));\n            }\n        }\n    }[\"CItemsProvider.useCallback4[action]\"], [\n        actionItem,\n        parentLocations\n    ]);\n    const facet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[facet]\": async function(key, facet2) {\n            let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (parentLocations) {\n                logger4.info(\"facet\", {\n                    key,\n                    facet: facet2,\n                    params,\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsUpdating(true);\n                try {\n                    const result = await facetItem(key, facet2, params, parentLocations);\n                    return result;\n                } finally{\n                    setIsUpdating(false);\n                }\n            } else {\n                const errorMessage = \"\".concat(name, \": No parent locations present to query for facet \").concat(facet2);\n                logger4.error(errorMessage, {\n                    key,\n                    facet: facet2,\n                    params\n                });\n                throw new Error(errorMessage);\n            }\n        }\n    }[\"CItemsProvider.useCallback4[facet]\"], [\n        facetItem,\n        parentLocations\n    ]);\n    const findOne = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[findOne]\": async (finder, finderParams)=>{\n            if (parentLocations) {\n                return findOneItem(finder, finderParams, parentLocations);\n            } else {\n                throw new Error(\"No parent locations present to query for findOne containeditem in \".concat(name));\n            }\n        }\n    }[\"CItemsProvider.useCallback4[findOne]\"], [\n        findOneItem,\n        parentLocations\n    ]);\n    const find = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[find]\": async (finder, finderParams)=>{\n            if (parentLocations) {\n                return findItem(finder, finderParams, parentLocations);\n            } else {\n                logger4.error(\"\".concat(name, \": No parent locations present to query for find containeditems\"), {\n                    finder,\n                    finderParams\n                });\n                throw new Error(\"No parent locations present to query for find containeditems in \".concat(name));\n            }\n        }\n    }[\"CItemsProvider.useCallback4[find]\"], [\n        findItem,\n        parentLocations\n    ]);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsProvider.useCallback4[set]\": async (key, item)=>{\n            return setItem(key, item);\n        }\n    }[\"CItemsProvider.useCallback4[set]\"], [\n        setItem,\n        parentLocations\n    ]);\n    const contextValue = {\n        name,\n        items: items || [],\n        facetResults: facetResults || {},\n        parentItem,\n        isLoading,\n        isCreating,\n        isUpdating,\n        isRemoving,\n        pkTypes,\n        locations: parentLocations,\n        create,\n        update,\n        remove,\n        all: (overrides === null || overrides === void 0 ? void 0 : overrides.all) || all,\n        one: (overrides === null || overrides === void 0 ? void 0 : overrides.one) || one,\n        allAction,\n        allFacet,\n        action,\n        facet,\n        find,\n        findOne,\n        set\n    };\n    contextValue.allActions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsProvider.useMemo5\": ()=>addAllActions && addAllActions(contextValue.allAction)\n    }[\"CItemsProvider.useMemo5\"], [\n        addAllActions,\n        contextValue.allAction\n    ]);\n    contextValue.allFacets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsProvider.useMemo5\": ()=>addAllFacets && addAllFacets(contextValue.allFacet)\n    }[\"CItemsProvider.useMemo5\"], [\n        addAllFacets,\n        contextValue.allFacet\n    ]);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(context.Provider, {\n        value: contextValue\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, renderEach && items && items.map((item)=>renderEach(item)), children));\n};\n_s11(CItemsProvider, \"oJg0J/wXFjNp42ReGzdofxv/NxU=\", false, function() {\n    return [\n        useCItemAdapter,\n        useAItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo\n    ];\n});\n_c4 = CItemsProvider;\n// src/contained/CItemsFacet.tsx\nvar CItemsFacet = (param)=>{\n    let { name, adapter, children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null), context: itemsContext, contextName, adapterContext, parent, parentContextName, renderEach, facet, facetParams = {} } = param;\n    _s12();\n    const [result, setResult] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const adapterContextName = adapterContext || \"\".concat(contextName, \"Adapter\");\n    let existingContext;\n    try {\n        existingContext = useCItems(itemsContext, contextName);\n    } catch (e) {}\n    const adapterContextInstance = useCItemAdapter(adapter, adapterContextName);\n    const parentContext = useAItem(parent, parentContextName);\n    const { locations: parentLocations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsFacet.useMemo6\": ()=>parentContext\n    }[\"CItemsFacet.useMemo6\"], [\n        parentContext\n    ]);\n    const facetParamsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsFacet.useMemo6[facetParamsString]\": ()=>createStableHash(facetParams)\n    }[\"CItemsFacet.useMemo6[facetParamsString]\"], [\n        facetParams\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemsFacet.useEffect6\": ()=>{\n            if (facet && facetParams && parentLocations && adapterContextInstance) {\n                ({\n                    \"CItemsFacet.useEffect6\": async ()=>{\n                        try {\n                            const result2 = await adapterContextInstance.allFacet(facet, facetParams, parentLocations);\n                            setResult(result2);\n                            setIsLoading(false);\n                        } catch (error) {\n                            console.error('[@fjell/providers] [CItemsFacet] Failed to execute facet \"'.concat(facet, '\" with params'), facetParams, \":\", error);\n                            setResult(null);\n                        }\n                    }\n                })[\"CItemsFacet.useEffect6\"]();\n            }\n        }\n    }[\"CItemsFacet.useEffect6\"], [\n        facet,\n        facetParamsString,\n        parentLocations\n    ]);\n    if (existingContext) {\n        const enhancedFacetResults = {\n            ...existingContext.facetResults\n        };\n        if (result) {\n            if (!enhancedFacetResults[facet]) {\n                enhancedFacetResults[facet] = {};\n            }\n            enhancedFacetResults[facet] = {\n                ...enhancedFacetResults[facet],\n                [facetParamsString]: result\n            };\n        }\n        const enhancedContextValue = {\n            ...existingContext,\n            facetResults: enhancedFacetResults\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(itemsContext.Provider, {\n            value: enhancedContextValue\n        }, children);\n    }\n    const initialFacetResults = {};\n    if (result) {\n        initialFacetResults[facet] = {\n            [facetParamsString]: result\n        };\n    }\n    return CItemsProvider({\n        name,\n        adapter,\n        children,\n        context: itemsContext,\n        contextName,\n        renderEach,\n        facetResults: initialFacetResults,\n        isLoadingParam: isLoading,\n        parent,\n        parentContextName\n    });\n};\n_s12(CItemsFacet, \"PCRqhNkS1sttJYdthlw8mEiKPlQ=\", false, function() {\n    return [\n        useCItemAdapter,\n        useAItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n_c5 = CItemsFacet;\n// src/contained/CItemsFind.tsx\n\nvar CItemsFind = (param)=>{\n    let { name, adapter, children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null), context, contextName, parent, parentContextName, renderEach, finder, finderParams = {} } = param;\n    _s13();\n    const [items, setItems] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const adapterContext = useCItemAdapter(adapter, contextName);\n    const parentContext = useAItem(parent, parentContextName);\n    const { locations: parentLocations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsFind.useMemo7\": ()=>parentContext\n    }[\"CItemsFind.useMemo7\"], [\n        parentContext\n    ]);\n    const finderParamsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsFind.useMemo7[finderParamsString]\": ()=>createStableHash(finderParams)\n    }[\"CItemsFind.useMemo7[finderParamsString]\"], [\n        finderParams\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemsFind.useEffect7\": ()=>{\n            if (finder && finderParams && parentLocations && adapterContext) {\n                ({\n                    \"CItemsFind.useEffect7\": async ()=>{\n                        try {\n                            const result = await adapterContext.find(finder, finderParams, parentLocations);\n                            setItems(result);\n                            setIsLoading(false);\n                        } catch (error) {\n                            console.error(\"Find operation failed:\", error);\n                            setItems(null);\n                            setIsLoading(false);\n                        }\n                    }\n                })[\"CItemsFind.useEffect7\"]();\n            }\n        }\n    }[\"CItemsFind.useEffect7\"], [\n        finder,\n        finderParamsString,\n        parentLocations\n    ]);\n    return CItemsProvider({\n        name,\n        adapter,\n        children,\n        context,\n        contextName,\n        renderEach,\n        items,\n        isLoadingParam: isLoading,\n        parent,\n        parentContextName\n    });\n};\n_s13(CItemsFind, \"vZeUkq2Vzu09kArelpicrb62k6k=\", false, function() {\n    return [\n        useCItemAdapter,\n        useAItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n_c6 = CItemsFind;\n// src/contained/CItemsQuery.tsx\n\n\nvar logger5 = logger_default.get(\"CItemsQuery\");\nvar CItemsQuery = (param)=>{\n    let { name, adapter, children = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null), context, contextName, parent, parentContextName, query = {}, renderEach } = param;\n    _s14();\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const adapterContext = useCItemAdapter(adapter, contextName);\n    const { all: allItems, one: oneItem } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsQuery.useMemo8\": ()=>adapterContext\n    }[\"CItemsQuery.useMemo8\"], [\n        adapterContext\n    ]);\n    const parentContext = useAItem(parent, parentContextName);\n    const { name: parentName, locations: parentLocations, item: parentItem } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsQuery.useMemo8\": ()=>parentContext\n    }[\"CItemsQuery.useMemo8\"], [\n        parentContext\n    ]);\n    const queryString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CItemsQuery.useMemo8[queryString]\": ()=>createStableHash(query)\n    }[\"CItemsQuery.useMemo8[queryString]\"], [\n        query\n    ]);\n    const all = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsQuery.useCallback5[all]\": async ()=>{\n            if (parentLocations) {\n                logger5.debug(\"\".concat(name, \": all\"), {\n                    query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query),\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsLoading(true);\n                try {\n                    const result = await allItems(query, parentLocations);\n                    return result;\n                } catch (error) {\n                    logger5.error(\"\".concat(name, \": Error getting all items\"), error);\n                    throw error;\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                logger5.default(\"\".concat(name, \": No parent locations present to query for all containeditems\"), {\n                    query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query)\n                });\n                throw new Error(\"No parent locations present to query for all containeditems in \".concat(name));\n            }\n        }\n    }[\"CItemsQuery.useCallback5[all]\"], [\n        allItems,\n        parentLocations,\n        queryString\n    ]);\n    const one = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CItemsQuery.useCallback5[one]\": async ()=>{\n            if (parentLocations) {\n                logger5.trace(\"one\", {\n                    query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query),\n                    parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                });\n                setIsLoading(true);\n                try {\n                    const result = await oneItem(query, parentLocations);\n                    return result;\n                } catch (error) {\n                    logger5.error(\"\".concat(name, \": Error getting one item\"), error);\n                    throw error;\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                logger5.default(\"\".concat(name, \": No parent locations present to query for one containeditem\"), {\n                    query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query)\n                });\n                throw new Error(\"No parent locations present to query for one containeditem in \".concat(name));\n            }\n        }\n    }[\"CItemsQuery.useCallback5[one]\"], [\n        oneItem,\n        parentLocations,\n        queryString\n    ]);\n    const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"CItemsQuery.useEffect8\": ()=>{\n            logger5.trace(\"useEffect[queryString, parentLocations, parentName, item]\", {\n                queryString,\n                parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations),\n                parentName,\n                parentItem\n            });\n            ({\n                \"CItemsQuery.useEffect8\": async ()=>{\n                    try {\n                        if (parentLocations) {\n                            logger5.trace(\"useEffect[queryString]\", {\n                                query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query),\n                                parentLocations: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevLKA)(parentLocations)\n                            });\n                            setIsLoading(true);\n                            const results = await allItems(query, parentLocations);\n                            setItems(results);\n                            setIsLoading(false);\n                        } else {\n                            logger5.warning(\"\".concat(name, \": useEffect[queryString, parentLocations] without parent locations\"), {\n                                query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query)\n                            });\n                            setItems(null);\n                            setIsLoading(false);\n                        }\n                    } catch (error) {\n                        logger5.error(\"\".concat(name, \": Error in useEffect\"), error);\n                        setItems(null);\n                        setIsLoading(false);\n                    }\n                }\n            })[\"CItemsQuery.useEffect8\"]();\n        }\n    }[\"CItemsQuery.useEffect8\"], [\n        queryString,\n        parentLocations,\n        parentName,\n        parentItem,\n        allItems,\n        name\n    ]);\n    return CItemsProvider({\n        name,\n        adapter,\n        children,\n        context,\n        contextName,\n        renderEach,\n        items,\n        isLoadingParam: isLoading,\n        parent,\n        parentContextName,\n        overrides: {\n            all,\n            one\n        }\n    });\n};\n_s14(CItemsQuery, \"31Fhm0k/beZtT0eNcwYuJhXr/JQ=\", false, function() {\n    return [\n        useCItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        useAItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n_c7 = CItemsQuery;\n// src/Faceted.tsx\nvar Faceted_exports = {};\n__export(Faceted_exports, {\n    useFacetResult: ()=>useFacetResult\n});\n\nvar useFacetResult = function(context, contextName, facet) {\n    let params = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    _s15();\n    const contextInstance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    const facetParamsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useFacetResult.useMemo9[facetParamsString]\": ()=>createStableHash(params)\n    }[\"useFacetResult.useMemo9[facetParamsString]\"], [\n        params\n    ]);\n    const [result, setResult] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFacetResult.useEffect9\": ()=>{\n            if (facet && contextInstance) {\n                var _contextInstance_facetResults_facet, _contextInstance_facetResults;\n                const facetResult = (_contextInstance_facetResults = contextInstance.facetResults) === null || _contextInstance_facetResults === void 0 ? void 0 : (_contextInstance_facetResults_facet = _contextInstance_facetResults[facet]) === null || _contextInstance_facetResults_facet === void 0 ? void 0 : _contextInstance_facetResults_facet[facetParamsString];\n                setResult(facetResult !== null && facetResult !== void 0 ? facetResult : null);\n            }\n        }\n    }[\"useFacetResult.useEffect9\"], [\n        facet,\n        facetParamsString,\n        contextInstance\n    ]);\n    return result;\n};\n_s15(useFacetResult, \"sP7XUFkd6zQ3+C28evWVFUd4/zg=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useContext,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n// src/primary/PItemAdapter.tsx\nvar PItemAdapter_exports = {};\n__export(PItemAdapter_exports, {\n    Adapter: ()=>Adapter2,\n    usePItemAdapter: ()=>usePItemAdapter\n});\n\n\n\nvar logger6 = logger_default.get(\"PItemAdapter\");\nvar usePItemAdapter = (context, contextName)=>{\n    _s16();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"usePItemAdapter hook must be used within a \".concat(contextName, \" provider. Make sure to wrap your component with <\").concat(contextName, \".Provider value={...}> or use the corresponding Provider component.\"));\n    }\n    return contextInstance;\n};\n_s16(usePItemAdapter, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\nvar Adapter2 = (param)=>{\n    let { name, cache, context, aggregates = {}, events = {}, addActions, addFacets, addAllActions, addAllFacets, children } = param;\n    _s17();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Adapter2.useEffect10\": ()=>{\n            if (!cache) {\n                logger6.error(\"Cache is undefined in %s. This will cause all operations to fail.\", name);\n            }\n        }\n    }[\"Adapter2.useEffect10\"], [\n        cache,\n        name\n    ]);\n    const pkTypes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Adapter2.useMemo10[pkTypes]\": ()=>{\n            var _cache_coordinate;\n            if (!cache || typeof cache.then === \"function\") {\n                return void 0;\n            }\n            return (_cache_coordinate = cache.coordinate) === null || _cache_coordinate === void 0 ? void 0 : _cache_coordinate.kta;\n        }\n    }[\"Adapter2.useMemo10[pkTypes]\"], [\n        cache\n    ]);\n    const sourceCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Adapter2.useMemo10[sourceCache]\": ()=>{\n            if (!cache) {\n                logger6.error(\"No cache provided to %s, operations will fail\", name);\n                return null;\n            }\n            if (aggregates && Object.keys(aggregates).length > 0) {\n                return (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_2__.createAggregator)(cache, {\n                    aggregates,\n                    events\n                });\n            } else {\n                return cache;\n            }\n        }\n    }[\"Adapter2.useMemo10[sourceCache]\"], [\n        cache,\n        aggregates,\n        events,\n        name\n    ]);\n    const [resolvedSourceCache, setResolvedSourceCache] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"Adapter2.useState\": ()=>{\n            if (sourceCache && !isPromise(sourceCache)) {\n                return sourceCache;\n            }\n            return null;\n        }\n    }[\"Adapter2.useState\"]);\n    const [, setCacheVersion] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Adapter2.useEffect\": ()=>{\n            if (sourceCache) {\n                if (isPromise(sourceCache)) {\n                    sourceCache.then({\n                        \"Adapter2.useEffect\": (c)=>{\n                            setResolvedSourceCache(c);\n                        }\n                    }[\"Adapter2.useEffect\"]).catch({\n                        \"Adapter2.useEffect\": (error)=>{\n                            logger6.error(\"Failed to initialize source cache in %s: %s\", name, error);\n                        }\n                    }[\"Adapter2.useEffect\"]);\n                } else {\n                    setResolvedSourceCache(sourceCache);\n                }\n            } else {\n                setResolvedSourceCache(null);\n            }\n        }\n    }[\"Adapter2.useEffect\"], [\n        sourceCache,\n        name\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Adapter2.useEffect\": ()=>{\n            if (!resolvedSourceCache || typeof resolvedSourceCache.subscribe !== \"function\") {\n                return;\n            }\n            try {\n                const subscription = resolvedSourceCache.subscribe({\n                    \"Adapter2.useEffect.subscription\": (event)=>{\n                        setCacheVersion({\n                            \"Adapter2.useEffect.subscription\": (prev)=>prev + 1\n                        }[\"Adapter2.useEffect.subscription\"]);\n                        logger6.debug(\"Cache event in \".concat(name, \":\"), event.type, event);\n                    }\n                }[\"Adapter2.useEffect.subscription\"], {\n                    // Subscribe to all cache events for this adapter\n                    eventTypes: [\n                        \"item_created\",\n                        \"item_updated\",\n                        \"item_removed\",\n                        \"item_retrieved\",\n                        \"item_set\",\n                        \"items_queried\",\n                        \"cache_cleared\",\n                        \"location_invalidated\",\n                        \"query_invalidated\"\n                    ],\n                    debounceMs: 50\n                });\n                return ({\n                    \"Adapter2.useEffect\": ()=>{\n                        if (subscription && typeof subscription.unsubscribe === \"function\") {\n                            subscription.unsubscribe();\n                        }\n                    }\n                })[\"Adapter2.useEffect\"];\n            } catch (error) {\n                logger6.debug(\"Cache subscription not available in \".concat(name, \":\"), error);\n                return ({\n                    \"Adapter2.useEffect\": ()=>{}\n                })[\"Adapter2.useEffect\"];\n            }\n        }\n    }[\"Adapter2.useEffect\"], [\n        resolvedSourceCache,\n        name\n    ]);\n    const handleCacheError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[handleCacheError]\": (operation)=>{\n            logger6.error('Cache not initialized in %s. Operation \"%s\" failed.', name, operation);\n            throw new Error(\"Cache not initialized in \".concat(name, '. Operation \"').concat(operation, '\" failed. This usually means the cache prop was not provided to the adapter or the cache Promise has not resolved yet. Check your adapter configuration.'));\n        }\n    }[\"Adapter2.useCallback6[handleCacheError]\"], [\n        name\n    ]);\n    const ensureCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[ensureCache]\": (operation)=>{\n            if (!resolvedSourceCache) {\n                handleCacheError(operation);\n            }\n            return resolvedSourceCache;\n        }\n    }[\"Adapter2.useCallback6[ensureCache]\"], [\n        resolvedSourceCache,\n        handleCacheError\n    ]);\n    const all = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[all]\": async (query)=>{\n            logger6.trace(\"all\", {\n                query: query && query.toString()\n            });\n            const cache2 = ensureCache(\"all\");\n            const result = await cache2.operations.all(query);\n            if (result === null || result === void 0) {\n                return null;\n            }\n            if (!Array.isArray(result)) {\n                logger6.debug(\"Invalid result from cache.operations.all: expected array or null, got %s\", typeof result);\n                return null;\n            }\n            return result;\n        }\n    }[\"Adapter2.useCallback6[all]\"], [\n        ensureCache,\n        name\n    ]);\n    const one = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[one]\": async (query)=>{\n            logger6.trace(\"one\", {\n                query: query && query.toString()\n            });\n            const cache2 = ensureCache(\"one\");\n            const item = await cache2.operations.one(query);\n            return item;\n        }\n    }[\"Adapter2.useCallback6[one]\"], [\n        ensureCache,\n        name\n    ]);\n    const create = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[create]\": async (item)=>{\n            logger6.trace(\"create\", {\n                item\n            });\n            const cache2 = ensureCache(\"create\");\n            const newItem = await cache2.operations.create(item);\n            return newItem;\n        }\n    }[\"Adapter2.useCallback6[create]\"], [\n        ensureCache\n    ]);\n    const get = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[get]\": async (key)=>{\n            logger6.trace(\"get\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key)\n            });\n            const cache2 = ensureCache(\"get\");\n            const item = await cache2.operations.get(key);\n            return item;\n        }\n    }[\"Adapter2.useCallback6[get]\"], [\n        ensureCache\n    ]);\n    const remove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[remove]\": async (key)=>{\n            logger6.trace(\"remove\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key)\n            });\n            const cache2 = ensureCache(\"remove\");\n            await cache2.operations.remove(key);\n        }\n    }[\"Adapter2.useCallback6[remove]\"], [\n        ensureCache\n    ]);\n    const retrieve = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[retrieve]\": async (key)=>{\n            logger6.trace(\"retrieve\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key)\n            });\n            const cache2 = ensureCache(\"retrieve\");\n            const item = await cache2.operations.retrieve(key);\n            return item;\n        }\n    }[\"Adapter2.useCallback6[retrieve]\"], [\n        ensureCache\n    ]);\n    const update = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[update]\": async (key, item)=>{\n            logger6.trace(\"update\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                item\n            });\n            const cache2 = ensureCache(\"update\");\n            const newItem = await cache2.operations.update(key, item);\n            return newItem;\n        }\n    }[\"Adapter2.useCallback6[update]\"], [\n        ensureCache\n    ]);\n    const action = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[action]\": async (key, action2, body)=>{\n            logger6.trace(\"action\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                action: action2,\n                body\n            });\n            const cache2 = ensureCache(\"action\");\n            const newItem = await cache2.operations.action(key, action2, body);\n            return newItem;\n        }\n    }[\"Adapter2.useCallback6[action]\"], [\n        ensureCache\n    ]);\n    const allAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[allAction]\": async (action2, body)=>{\n            logger6.trace(\"allAction\", {\n                action: action2,\n                body\n            });\n            const cache2 = ensureCache(\"allAction\");\n            const newItems = await cache2.operations.allAction(action2, body);\n            return newItems;\n        }\n    }[\"Adapter2.useCallback6[allAction]\"], [\n        ensureCache\n    ]);\n    const facet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[facet]\": async (key, facet2, params)=>{\n            logger6.trace(\"facet\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                facet: facet2,\n                params\n            });\n            const cache2 = ensureCache(\"facet\");\n            const response = params !== void 0 ? await cache2.operations.facet(key, facet2, params) : await cache2.operations.facet(key, facet2);\n            return response;\n        }\n    }[\"Adapter2.useCallback6[facet]\"], [\n        ensureCache\n    ]);\n    const allFacet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[allFacet]\": async (facet2, params)=>{\n            logger6.trace(\"allFacet\", {\n                facet: facet2,\n                params\n            });\n            const cache2 = ensureCache(\"allFacet\");\n            const response = await cache2.operations.allFacet(facet2, params);\n            return response;\n        }\n    }[\"Adapter2.useCallback6[allFacet]\"], [\n        ensureCache\n    ]);\n    const find = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[find]\": async (finder, finderParams)=>{\n            logger6.trace(\"find\", {\n                finder,\n                finderParams\n            });\n            const cache2 = ensureCache(\"find\");\n            const newItems = await cache2.operations.find(finder, finderParams);\n            return newItems;\n        }\n    }[\"Adapter2.useCallback6[find]\"], [\n        ensureCache\n    ]);\n    const findOne = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[findOne]\": async (finder, finderParams)=>{\n            logger6.trace(\"findOne\", {\n                finder,\n                finderParams\n            });\n            const cache2 = ensureCache(\"findOne\");\n            const newItems = await cache2.operations.find(finder, finderParams);\n            if (!Array.isArray(newItems) || newItems.length === 0) {\n                return null;\n            }\n            return newItems[0];\n        }\n    }[\"Adapter2.useCallback6[findOne]\"], [\n        ensureCache\n    ]);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"Adapter2.useCallback6[set]\": async (key, item)=>{\n            logger6.trace(\"set\", {\n                key: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevIK)(key),\n                item\n            });\n            const cache2 = ensureCache(\"set\");\n            const newItem = await cache2.operations.set(key, item);\n            return newItem;\n        }\n    }[\"Adapter2.useCallback6[set]\"], [\n        ensureCache\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Adapter2.useMemo10[contextValue]\": ()=>({\n                name,\n                pkTypes: pkTypes || [\n                    \"placeholder\"\n                ],\n                all,\n                one,\n                create,\n                get,\n                remove,\n                retrieve,\n                update,\n                action,\n                allAction,\n                facet,\n                allFacet,\n                find,\n                findOne,\n                set,\n                addActions,\n                addFacets,\n                addAllActions,\n                addAllFacets\n            })\n    }[\"Adapter2.useMemo10[contextValue]\"], [\n        name,\n        pkTypes,\n        all,\n        one,\n        create,\n        get,\n        remove,\n        retrieve,\n        update,\n        action,\n        allAction,\n        facet,\n        allFacet,\n        find,\n        findOne,\n        set,\n        addActions,\n        addFacets,\n        addAllActions,\n        addAllFacets\n    ]);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(context.Provider, {\n        value: contextValue\n    }, children);\n};\n_s17(Adapter2, \"W0LgwqubFEQQJqmaT4itarJrmX0=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo\n    ];\n});\n_c8 = Adapter2;\n// src/primary/PItem.tsx\nvar PItem_exports = {};\n__export(PItem_exports, {\n    usePItem: ()=>usePItem\n});\n\nvar usePItem = (context, contextName)=>{\n    _s18();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s18(usePItem, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\n// src/primary/PItems.tsx\nvar PItems_exports = {};\n__export(PItems_exports, {\n    usePItems: ()=>usePItems\n});\n\nvar usePItems = (context, contextName)=>{\n    _s19();\n    const contextInstance = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (contextInstance === void 0) {\n        throw new Error(\"This hook must be used within a \".concat(contextName));\n    }\n    return contextInstance;\n};\n_s19(usePItems, \"b+JVaM/BahJHRp62A1epknxg1qk=\");\n// src/primary/PItemFacet.tsx\n\nvar PItemFacet = (param)=>{\n    let { adapter, children, context: itemContext, contextName, adapterContext, facet, facetParams = {} } = param;\n    _s20();\n    const [result, setResult] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const logger10 = logger_default.get(\"PItemFacet\");\n    const adapterContextName = adapterContext || \"\".concat(contextName, \"Adapter\");\n    const adapterContextInstance = usePItemAdapter(adapter, adapterContextName);\n    const itemContextValue = usePItem(itemContext, contextName);\n    const facetParamsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemFacet.useMemo11[facetParamsString]\": ()=>createStableHash(facetParams)\n    }[\"PItemFacet.useMemo11[facetParamsString]\"], [\n        facetParams\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemFacet.useEffect11\": ()=>{\n            if (facet && facetParams && itemContextValue && itemContextValue.key && adapterContextInstance) {\n                ({\n                    \"PItemFacet.useEffect11\": async ()=>{\n                        try {\n                            const result2 = await adapterContextInstance.facet(itemContextValue.key, facet, facetParams);\n                            setResult(result2);\n                            setIsLoading(false);\n                        } catch (error) {\n                            logger10.error('Failed to execute facet \"%s\" with params %O: %s', facet, facetParams, error);\n                            setResult(null);\n                            setIsLoading(false);\n                        }\n                    }\n                })[\"PItemFacet.useEffect11\"]();\n            }\n        }\n    }[\"PItemFacet.useEffect11\"], [\n        facet,\n        facetParamsString,\n        itemContextValue === null || itemContextValue === void 0 ? void 0 : itemContextValue.key,\n        itemContextValue === null || itemContextValue === void 0 ? void 0 : itemContextValue.locations\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemFacet.useMemo11[contextValue]\": ()=>{\n            if (!itemContextValue) return itemContextValue;\n            const updatedFacetResults = {\n                ...itemContextValue.facetResults\n            };\n            if (result) {\n                if (!updatedFacetResults[facet]) {\n                    updatedFacetResults[facet] = {};\n                }\n                updatedFacetResults[facet] = {\n                    ...updatedFacetResults[facet],\n                    [facetParamsString]: result\n                };\n            }\n            return {\n                ...itemContextValue,\n                facetResults: updatedFacetResults,\n                isLoading: isLoading || itemContextValue.isLoading\n            };\n        }\n    }[\"PItemFacet.useMemo11[contextValue]\"], [\n        itemContextValue,\n        result,\n        isLoading,\n        facet,\n        facetParamsString\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(itemContext.Provider, {\n        value: contextValue\n    }, children);\n};\n_s20(PItemFacet, \"DMqt6p+MX1vLoxeFt/4/KSN82Eo=\", false, function() {\n    return [\n        usePItemAdapter,\n        usePItem,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo\n    ];\n});\n_c9 = PItemFacet;\n// src/primary/PItemLoad.tsx\n\n\nvar logger7 = logger_default.get(\"PItemLoad\");\nvar PItemLoad = (param)=>{\n    let { name, adapter, children, context, contextName, ik, item: providedItem } = param;\n    _s21();\n    logger7.debug(\"\".concat(name, \": Component initialized with props\"), {\n        name,\n        hasAdapter: !!adapter,\n        hasChildren: !!children,\n        hasContext: !!context,\n        ik,\n        providedItem\n    });\n    const { throwAsyncError } = useAsyncError();\n    if (ik !== void 0 && providedItem !== void 0) {\n        const errorMessage = \"\".concat(name, \": Cannot provide both 'ik' and 'item' parameters. Please provide only one.\");\n        logger7.error(errorMessage);\n        throw new Error(errorMessage);\n    }\n    const [itemKey, setItemKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(ik !== null && ik !== void 0 ? ik : void 0);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isUpdating, setIsUpdating] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isRemoving, setIsRemoving] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    logger7.debug(\"\".concat(name, \": Initial state set\"), {\n        itemKey,\n        isLoading,\n        isUpdating,\n        isRemoving\n    });\n    const PItemAdapter = usePItemAdapter(adapter, contextName);\n    logger7.debug(\"\".concat(name, \": PItemAdapter initialized\"), {\n        hasAdapter: !!PItemAdapter\n    });\n    const { pkTypes, retrieve: retrieveItem, remove: removeItem, update: updateItem, action: actionItem, facet: facetItem, set: setItem, addActions } = PItemAdapter;\n    const itemLogger = logger_default.get(\"PItemLoad\", ...pkTypes || []);\n    logger7.debug(\"\".concat(name, \": Item logger created with pkTypes\"), {\n        pkTypes\n    });\n    const [item, setItemState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemLoad.useEffect12\": ()=>{\n            if (providedItem) {\n                setItemState(providedItem);\n                return;\n            }\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(itemKey)) {\n                retrieveItem(itemKey).then({\n                    \"PItemLoad.useEffect12\": (retrievedItem)=>{\n                        setItemState(retrievedItem);\n                    }\n                }[\"PItemLoad.useEffect12\"]).catch({\n                    \"PItemLoad.useEffect12\": (error)=>{\n                        logger7.error(\"Error retrieving item:\", error);\n                        setItemState(null);\n                    }\n                }[\"PItemLoad.useEffect12\"]);\n            } else {\n                setItemState(null);\n            }\n        }\n    }[\"PItemLoad.useEffect12\"], [\n        itemKey,\n        providedItem,\n        retrieveItem\n    ]);\n    const locations = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemLoad.useMemo12[locations]\": ()=>{\n            logger7.debug(\"\".concat(name, \": Computing locations memoization\"), {\n                hasItem: !!item\n            });\n            if (item) {\n                logger7.debug(\"\".concat(name, \": Item exists, converting key to location array\"), {\n                    itemKey: item.key\n                });\n                const result = (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.ikToLKA)(item.key);\n                logger7.debug(\"\".concat(name, \": Location array computed\"), {\n                    locations: result\n                });\n                return result;\n            } else {\n                logger7.debug(\"\".concat(name, \": No item, returning null locations\"));\n                return null;\n            }\n        }\n    }[\"PItemLoad.useMemo12[locations]\"], [\n        item\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemLoad.useEffect12\": ()=>{\n            logger7.debug(\"\".concat(name, \": useEffect[ik] triggered\"), {\n                ik,\n                providedItem\n            });\n            if (providedItem) {\n                setItemKey(providedItem.key);\n                setIsLoading(false);\n                return;\n            }\n            if (ik && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(ik)) {\n                setItemKey(ik);\n                setIsLoading(true);\n                retrieveItem(ik).catch({\n                    \"PItemLoad.useEffect12\": (error)=>{\n                        logger7.error(\"\".concat(name, \": Error retrieving item\"), error);\n                        throwAsyncError(error);\n                    }\n                }[\"PItemLoad.useEffect12\"]).finally({\n                    \"PItemLoad.useEffect12\": ()=>{\n                        setIsLoading(false);\n                    }\n                }[\"PItemLoad.useEffect12\"]);\n            } else {\n                setItemKey(void 0);\n                setIsLoading(false);\n            }\n        }\n    }[\"PItemLoad.useEffect12\"], [\n        ik,\n        providedItem,\n        retrieveItem\n    ]);\n    const remove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemLoad.useCallback7[remove]\": async ()=>{\n            logger7.debug(\"\".concat(name, \": remove() called\"), {\n                itemKey,\n                isValidKey: itemKey ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(itemKey) : false\n            });\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(itemKey)) {\n                logger7.debug(\"\".concat(name, \": Valid key for remove, setting isRemoving to true\"), {\n                    itemKey\n                });\n                setIsRemoving(true);\n                try {\n                    await removeItem(itemKey);\n                    logger7.debug(\"\".concat(name, \": removeItem completed successfully\"), {\n                        itemKey\n                    });\n                } catch (error) {\n                    logger7.error(\"\".concat(name, \": Error during item removal\"), {\n                        itemKey,\n                        error\n                    });\n                    throw error;\n                } finally{\n                    setIsRemoving(false);\n                    logger7.debug(\"\".concat(name, \": isRemoving set to false after successful removal\"));\n                }\n            } else {\n                logger7.debug(\"\".concat(name, \": Invalid itemKey for remove\"), {\n                    itemKey\n                });\n                logger7.error(\"\".concat(name, \": Item key is required to remove an item\"));\n                throw new Error(\"Item key is required to remove an item in \".concat(name));\n            }\n        }\n    }[\"PItemLoad.useCallback7[remove]\"], [\n        removeItem,\n        itemKey\n    ]);\n    const update = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemLoad.useCallback7[update]\": async (updateData)=>{\n            logger7.debug(\"\".concat(name, \": update() called\"), {\n                itemKey,\n                isValidKey: itemKey ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(itemKey) : false,\n                hasUpdateData: !!updateData\n            });\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(itemKey)) {\n                logger7.debug(\"\".concat(name, \": Valid key for update, setting isUpdating to true\"), {\n                    itemKey\n                });\n                setIsUpdating(true);\n                try {\n                    const retItem = await updateItem(itemKey, updateData);\n                    logger7.debug(\"\".concat(name, \": updateItem completed successfully\"), {\n                        itemKey,\n                        hasResult: !!retItem,\n                        resultType: retItem ? typeof retItem : \"undefined\"\n                    });\n                    return retItem;\n                } catch (error) {\n                    logger7.error(\"\".concat(name, \": Error during item update\"), {\n                        itemKey,\n                        updateData,\n                        error\n                    });\n                    throw error;\n                } finally{\n                    setIsUpdating(false);\n                    logger7.debug(\"\".concat(name, \": isUpdating set to false after successful update\"));\n                }\n            } else {\n                logger7.debug(\"\".concat(name, \": Invalid itemKey for update\"), {\n                    itemKey\n                });\n                itemLogger.error(\"\".concat(name, \": Item key is required to update an item\"));\n                throw new Error(\"Item key is required to update an item in \".concat(name));\n            }\n        }\n    }[\"PItemLoad.useCallback7[update]\"], [\n        updateItem,\n        itemKey\n    ]);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemLoad.useCallback7[set]\": async (item2)=>{\n            logger7.debug(\"\".concat(name, \": set() called\"), {\n                itemKey: item2.key\n            });\n            if (item2 && item2.key) {\n                setIsUpdating(true);\n                try {\n                    const retItem = await setItem(item2.key, item2);\n                    return retItem;\n                } finally{\n                    setIsUpdating(false);\n                }\n            } else {\n                itemLogger.error(\"\".concat(name, \": Item key is required to set an item\"));\n                throw new Error(\"Item key is required to set an item in \".concat(name));\n            }\n        }\n    }[\"PItemLoad.useCallback7[set]\"], [\n        setItem\n    ]);\n    const action = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemLoad.useCallback7[action]\": async (actionName, body)=>{\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(itemKey)) {\n                setIsUpdating(true);\n                try {\n                    return await actionItem(itemKey, actionName, body);\n                } finally{\n                    setIsUpdating(false);\n                }\n            } else {\n                itemLogger.error(\"\".concat(name, \": Item key is required to perform an action\"));\n                throw new Error(\"Item key is required to perform an action in \".concat(name));\n            }\n        }\n    }[\"PItemLoad.useCallback7[action]\"], [\n        actionItem,\n        itemKey\n    ]);\n    const facet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemLoad.useCallback7[facet]\": async function(facetName) {\n            let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (itemKey && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.isValidPriKey)(itemKey)) {\n                try {\n                    return await facetItem(itemKey, facetName, params);\n                } catch (error) {\n                    logger7.error(\"\".concat(name, \": Error during facet retrieval\"), {\n                        itemKey,\n                        facetName,\n                        error\n                    });\n                    throw error;\n                }\n            } else {\n                itemLogger.error(\"\".concat(name, \": Item key is required to retrieve a facet\"));\n                throw new Error(\"Item key is required to retrieve a facet in \".concat(name));\n            }\n        }\n    }[\"PItemLoad.useCallback7[facet]\"], [\n        facetItem,\n        itemKey\n    ]);\n    const contextValue = {\n        name,\n        key: itemKey,\n        item,\n        isLoading,\n        isUpdating,\n        isRemoving,\n        parentItem: null,\n        pkTypes,\n        remove,\n        update,\n        action,\n        facet,\n        set,\n        locations,\n        facetResults: {}\n    };\n    contextValue.actions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemLoad.useMemo12\": ()=>addActions && addActions(contextValue.action)\n    }[\"PItemLoad.useMemo12\"], [\n        addActions,\n        contextValue.action\n    ]);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(context.Provider, {\n        value: contextValue\n    }, children);\n};\n_s21(PItemLoad, \"L2/YC/nHpm6Al5iar3zoxuO8Xx4=\", false, function() {\n    return [\n        useAsyncError,\n        usePItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo\n    ];\n});\n_c10 = PItemLoad;\n// src/primary/PItemQuery.tsx\n\n\nvar logger8 = logger_default.get(\"PItemQuery\");\nvar PItemQuery = (param)=>{\n    let { name, adapter, children, context, contextName, create, loading, notFound, optional = false, query } = param;\n    _s22();\n    const [itemKey, setItemKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [queryRunning, setQueryRunning] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const { throwAsyncError } = useAsyncError();\n    const PItemAdapter = usePItemAdapter(adapter, contextName);\n    const { one: oneItem, create: createItem } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemQuery.useMemo13\": ()=>PItemAdapter\n    }[\"PItemQuery.useMemo13\"], [\n        PItemAdapter\n    ]);\n    const queryString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemQuery.useMemo13[queryString]\": ()=>createStableHash(query)\n    }[\"PItemQuery.useMemo13[queryString]\"], [\n        query\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemQuery.useEffect13\": ()=>{\n            logger8.default(\"\".concat(name, \": useEffect[query]\"), {\n                query\n            });\n            if (!query) {\n                setQueryRunning(false);\n                return;\n            } else {\n                ({\n                    \"PItemQuery.useEffect13\": async ()=>{\n                        logger8.default(\"\".concat(name, \": Running PItemProvder Query\"), {\n                            query: (0,_fjell_core__WEBPACK_IMPORTED_MODULE_3__.abbrevQuery)(query)\n                        });\n                        try {\n                            const item = await oneItem(query);\n                            if (item) {\n                                logger8.default(\"\".concat(name, \": Setting Item Key After oneItem\"), {\n                                    itemKey: item.key\n                                });\n                                setItemKey(item.key);\n                                setQueryRunning(false);\n                            } else if (create) {\n                                logger8.default(\"\".concat(name, \": Creating new item\"), {\n                                    create\n                                });\n                                const newItem = await createItem(create);\n                                logger8.default(\"\".concat(name, \": Setting Item Key After createItem\"), {\n                                    itemKey: newItem.key\n                                });\n                                setItemKey(newItem.key);\n                                setQueryRunning(false);\n                            } else {\n                                if (!optional) {\n                                    setQueryRunning(false);\n                                    logger8.error(\"\".concat(name, \": Required Item not found, and no create provided\"), {\n                                        query,\n                                        optional\n                                    });\n                                    throwAsyncError(new Error(\"Required Item not found, and no create provided in \".concat(name)));\n                                } else {\n                                    setQueryRunning(false);\n                                    logger8.default(\"\".concat(name, \": Optional item not found, item will be null\"), {\n                                        query,\n                                        optional\n                                    });\n                                }\n                            }\n                        } catch (err) {\n                            if (create) {\n                                logger8.default(\"\".concat(name, \": Creating new item after exception throw for NotFound\"), {\n                                    err,\n                                    create\n                                });\n                                const newItem = await createItem(create);\n                                logger8.default(\"\".concat(name, \": Setting Item Key After createItem during Exception\"), {\n                                    itemKey: newItem.key\n                                });\n                                setItemKey(newItem.key);\n                                setQueryRunning(false);\n                            } else {\n                                if (!optional) {\n                                    setQueryRunning(false);\n                                    throwAsyncError(err);\n                                } else {\n                                    setQueryRunning(false);\n                                    logger8.default(\"\".concat(name, \": Optional item not found, item will be null\"));\n                                    setItemKey(null);\n                                }\n                            }\n                        }\n                    }\n                })[\"PItemQuery.useEffect13\"]();\n            }\n        }\n    }[\"PItemQuery.useEffect13\"], [\n        queryString\n    ]);\n    const returnContext = PItemLoad({\n        name,\n        ik: itemKey,\n        adapter,\n        context,\n        contextName,\n        children\n    });\n    if (queryRunning) {\n        return loading;\n    } else if (itemKey || optional) {\n        return returnContext;\n    } else {\n        return notFound;\n    }\n};\n_s22(PItemQuery, \"Em8gjLk8MqCquN3timclWovcf5I=\", false, function() {\n    return [\n        useAsyncError,\n        usePItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n_c11 = PItemQuery;\n// src/primary/PItemsFacet.tsx\n\n// src/primary/PItemsProvider.tsx\n\nvar PItemsProvider = (param)=>{\n    let { name, items = [], facetResults = {}, adapter, children, context, contextName, renderEach, isLoadingParam = false, overrides } = param;\n    _s23();\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const [isCreating, setIsCreating] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isUpdating, setIsUpdating] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isRemoving, setIsRemoving] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const adapterContext = usePItemAdapter(adapter, contextName);\n    const { pkTypes, all: allItems, one: oneItem, create: createItem, update: updateItem, remove: removeItem, allAction: allItemAction, allFacet: allItemFacet, set: setItem, action: actionItem, facet: facetItem, find: findItem, findOne: findOneItem, addAllActions, addAllFacets } = adapterContext;\n    const logger10 = logger_default.get(\"PItemsProvider\", createStableHash(pkTypes));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemsProvider.useEffect14\": ()=>{\n            setIsLoading(isLoadingParam);\n        }\n    }[\"PItemsProvider.useEffect14\"], [\n        isLoadingParam\n    ]);\n    const all = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[all]\": async ()=>{\n            logger10.trace(\"all\");\n            setIsLoading(true);\n            const items2 = await allItems({});\n            setIsLoading(false);\n            logger10.debug(\"Items Returned for All\", {\n                items: items2\n            });\n            return items2;\n        }\n    }[\"PItemsProvider.useCallback8[all]\"], [\n        allItems\n    ]);\n    const one = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[one]\": async ()=>{\n            logger10.trace(\"one\");\n            setIsLoading(true);\n            const item = await oneItem({});\n            setIsLoading(false);\n            return item;\n        }\n    }[\"PItemsProvider.useCallback8[one]\"], [\n        oneItem\n    ]);\n    const create = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[create]\": async (item)=>{\n            logger10.trace(\"create\", {\n                item\n            });\n            setIsCreating(true);\n            const result = await createItem(item);\n            setIsCreating(false);\n            return result;\n        }\n    }[\"PItemsProvider.useCallback8[create]\"], [\n        createItem\n    ]);\n    const update = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[update]\": async (key, item)=>{\n            logger10.trace(\"update\", {\n                key,\n                item\n            });\n            setIsUpdating(true);\n            const result = await updateItem(key, item);\n            setIsUpdating(false);\n            return result;\n        }\n    }[\"PItemsProvider.useCallback8[update]\"], [\n        updateItem\n    ]);\n    const remove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[remove]\": async (key)=>{\n            logger10.trace(\"remove\", {\n                key\n            });\n            setIsRemoving(true);\n            const result = await removeItem(key);\n            setIsRemoving(false);\n            return result;\n        }\n    }[\"PItemsProvider.useCallback8[remove]\"], [\n        removeItem\n    ]);\n    const allAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[allAction]\": async function(action2) {\n            let body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            logger10.trace(\"allAction\", {\n                action: action2,\n                body\n            });\n            setIsUpdating(true);\n            try {\n                const result = await allItemAction(action2, body);\n                return result;\n            } finally{\n                setIsUpdating(false);\n            }\n        }\n    }[\"PItemsProvider.useCallback8[allAction]\"], [\n        allItemAction\n    ]);\n    const allFacet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[allFacet]\": async function(facet2) {\n            let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            logger10.trace(\"allFacet\", {\n                facet: facet2,\n                params\n            });\n            setIsUpdating(true);\n            try {\n                const result = await allItemFacet(facet2, params);\n                return result;\n            } finally{\n                setIsUpdating(false);\n            }\n        }\n    }[\"PItemsProvider.useCallback8[allFacet]\"], [\n        allItemFacet\n    ]);\n    const action = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[action]\": async (key, action2, body)=>{\n            logger10.trace(\"action\", {\n                key,\n                action: action2,\n                body\n            });\n            setIsUpdating(true);\n            try {\n                const result = await actionItem(key, action2, body);\n                return result;\n            } finally{\n                setIsUpdating(false);\n            }\n        }\n    }[\"PItemsProvider.useCallback8[action]\"], [\n        actionItem\n    ]);\n    const facet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[facet]\": async function(key, facet2) {\n            let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            logger10.trace(\"facet\", {\n                key,\n                facet: facet2,\n                params\n            });\n            setIsUpdating(true);\n            try {\n                const result = await facetItem(key, facet2, params);\n                return result;\n            } finally{\n                setIsUpdating(false);\n            }\n        }\n    }[\"PItemsProvider.useCallback8[facet]\"], [\n        facetItem\n    ]);\n    const find = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[find]\": async (finder, finderParams)=>{\n            return findItem(finder, finderParams);\n        }\n    }[\"PItemsProvider.useCallback8[find]\"], [\n        findItem\n    ]);\n    const findOne = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[findOne]\": async (finder, finderParams)=>{\n            return findOneItem && findOneItem(finder, finderParams);\n        }\n    }[\"PItemsProvider.useCallback8[findOne]\"], [\n        findOneItem\n    ]);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsProvider.useCallback8[set]\": async (key, item)=>{\n            logger10.trace(\"set\", {\n                key,\n                item\n            });\n            const result = await setItem(key, item);\n            return result;\n        }\n    }[\"PItemsProvider.useCallback8[set]\"], [\n        setItem\n    ]);\n    const contextValue = {\n        name,\n        pkTypes,\n        items,\n        isLoading,\n        isCreating,\n        isUpdating,\n        isRemoving,\n        facetResults: facetResults || {},\n        create,\n        update,\n        remove,\n        all: (overrides === null || overrides === void 0 ? void 0 : overrides.all) || all,\n        one: (overrides === null || overrides === void 0 ? void 0 : overrides.one) || one,\n        allAction,\n        allFacet,\n        find,\n        findOne,\n        set,\n        action,\n        facet\n    };\n    contextValue.allActions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemsProvider.useMemo14\": ()=>addAllActions && addAllActions(contextValue.allAction)\n    }[\"PItemsProvider.useMemo14\"], [\n        addAllActions,\n        contextValue.allAction\n    ]);\n    contextValue.allFacets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemsProvider.useMemo14\": ()=>addAllFacets && addAllFacets(contextValue.allFacet)\n    }[\"PItemsProvider.useMemo14\"], [\n        addAllFacets,\n        contextValue.allFacet\n    ]);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(context.Provider, {\n        value: contextValue\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, renderEach && items && items.map((item)=>renderEach(item)), children));\n};\n_s23(PItemsProvider, \"Tic50x1mCVarDOQvWHYyGJFpzw0=\", false, function() {\n    return [\n        usePItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo\n    ];\n});\n_c12 = PItemsProvider;\n// src/primary/PItemsFacet.tsx\nvar PItemsFacet = (param)=>{\n    let { name, adapter, children, context: itemsContext, contextName, adapterContext, facet, facetParams = {}, renderEach } = param;\n    _s24();\n    const [result, setResult] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const adapterContextName = adapterContext || \"\".concat(contextName, \"Adapter\");\n    let existingContext;\n    try {\n        existingContext = usePItems(itemsContext, contextName);\n    } catch (e) {}\n    const adapterContextInstance = usePItemAdapter(adapter, adapterContextName);\n    const facetParamsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemsFacet.useMemo15[facetParamsString]\": ()=>createStableHash(facetParams)\n    }[\"PItemsFacet.useMemo15[facetParamsString]\"], [\n        facetParams\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemsFacet.useEffect15\": ()=>{\n            if (facet && facetParams && adapterContextInstance) {\n                ({\n                    \"PItemsFacet.useEffect15\": async ()=>{\n                        if (adapterContextInstance.allFacet) {\n                            const result2 = await adapterContextInstance.allFacet(facet, facetParams);\n                            setResult(result2);\n                            setIsLoading(false);\n                        } else {\n                            setResult(null);\n                            setIsLoading(false);\n                        }\n                    }\n                })[\"PItemsFacet.useEffect15\"]();\n            }\n        }\n    }[\"PItemsFacet.useEffect15\"], [\n        facet,\n        facetParamsString\n    ]);\n    if (existingContext) {\n        const enhancedFacetResults = {\n            ...existingContext.facetResults\n        };\n        if (result) {\n            if (!enhancedFacetResults[facet]) {\n                enhancedFacetResults[facet] = {};\n            }\n            enhancedFacetResults[facet] = {\n                ...enhancedFacetResults[facet],\n                [facetParamsString]: result\n            };\n        }\n        const enhancedContextValue = {\n            ...existingContext,\n            facetResults: enhancedFacetResults\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(itemsContext.Provider, {\n            value: enhancedContextValue\n        }, children);\n    }\n    const initialFacetResults = {};\n    if (result) {\n        initialFacetResults[facet] = {\n            [facetParamsString]: result\n        };\n    }\n    return PItemsProvider({\n        name,\n        adapter,\n        children,\n        context: itemsContext,\n        contextName,\n        renderEach,\n        facetResults: initialFacetResults,\n        isLoadingParam: isLoading\n    });\n};\n_s24(PItemsFacet, \"xTgqxTJ6Z+GGxDFVaujf5xaAzWU=\", false, function() {\n    return [\n        usePItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n_c13 = PItemsFacet;\n// src/primary/PItemsFind.tsx\n\nvar PItemsFind = (param)=>{\n    let { name, adapter, children, context, contextName, finder, finderParams = {}, renderEach } = param;\n    _s25();\n    const [items, setItems] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const adapterContext = usePItemAdapter(adapter, contextName);\n    const finderParamsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemsFind.useMemo16[finderParamsString]\": ()=>createStableHash(finderParams)\n    }[\"PItemsFind.useMemo16[finderParamsString]\"], [\n        finderParams\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemsFind.useEffect16\": ()=>{\n            if (finder && finderParams && adapterContext) {\n                ({\n                    \"PItemsFind.useEffect16\": async ()=>{\n                        if (adapterContext.find) {\n                            const result = await adapterContext.find(finder, finderParams);\n                            setItems(result);\n                            setIsLoading(false);\n                        } else {\n                            setItems(null);\n                            setIsLoading(false);\n                        }\n                    }\n                })[\"PItemsFind.useEffect16\"]();\n            }\n        }\n    }[\"PItemsFind.useEffect16\"], [\n        finder,\n        finderParamsString\n    ]);\n    return PItemsProvider({\n        name,\n        adapter,\n        children,\n        context,\n        contextName,\n        renderEach,\n        items: items || [],\n        isLoadingParam: isLoading\n    });\n};\n_s25(PItemsFind, \"TJD6aTvgEsWW7Nvkg8EwCmYrm0o=\", false, function() {\n    return [\n        usePItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n_c14 = PItemsFind;\n// src/primary/PItemsQuery.tsx\n\nvar logger9 = logger_default.get(\"PItemsQuery\");\nvar PItemsQuery = (param)=>{\n    let { name, adapter, children, context, contextName, query = {}, renderEach } = param;\n    _s26();\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const adapterContext = usePItemAdapter(adapter, contextName);\n    const { all: allItems, one: oneItem } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemsQuery.useMemo17\": ()=>adapterContext\n    }[\"PItemsQuery.useMemo17\"], [\n        adapterContext\n    ]);\n    const queryString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PItemsQuery.useMemo17[queryString]\": ()=>createStableHash(query)\n    }[\"PItemsQuery.useMemo17[queryString]\"], [\n        query\n    ]);\n    const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PItemsQuery.useEffect17\": ()=>{\n            ({\n                \"PItemsQuery.useEffect17\": async ()=>{\n                    try {\n                        logger9.trace(\"useEffect[queryString] %s\", createStableHash(query));\n                        setIsLoading(true);\n                        const results = await allItems(query, []);\n                        setItems(results || []);\n                        setIsLoading(false);\n                    } catch (error) {\n                        logger9.error(\"\".concat(name, \": Error loading items:\"), error);\n                        setItems([]);\n                        setIsLoading(false);\n                    }\n                }\n            })[\"PItemsQuery.useEffect17\"]();\n        }\n    }[\"PItemsQuery.useEffect17\"], [\n        queryString,\n        allItems,\n        name\n    ]);\n    const all = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsQuery.useCallback9[all]\": async ()=>{\n            try {\n                logger9.trace(\"all\", {\n                    query\n                });\n                setIsLoading(true);\n                const items2 = await allItems(query, []);\n                setIsLoading(false);\n                logger9.debug(\"Items Returned for All\", {\n                    items: items2\n                });\n                return items2;\n            } catch (error) {\n                logger9.error(\"Error in all:\", error);\n                setIsLoading(false);\n                throw error;\n            }\n        }\n    }[\"PItemsQuery.useCallback9[all]\"], [\n        allItems\n    ]);\n    const one = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"PItemsQuery.useCallback9[one]\": async ()=>{\n            try {\n                logger9.trace(\"one\", {\n                    query\n                });\n                setIsLoading(true);\n                const item = await oneItem(query);\n                setIsLoading(false);\n                return item;\n            } catch (error) {\n                logger9.error(\"Error in one:\", error);\n                setIsLoading(false);\n                throw error;\n            }\n        }\n    }[\"PItemsQuery.useCallback9[one]\"], [\n        oneItem\n    ]);\n    return PItemsProvider({\n        name,\n        adapter,\n        children,\n        context,\n        contextName,\n        renderEach,\n        items,\n        isLoadingParam: isLoading,\n        overrides: {\n            all,\n            one\n        }\n    });\n};\n_s26(PItemsQuery, \"iHgqxB6ofiwfUAbcbS/5g2orFUA=\", false, function() {\n    return [\n        usePItemAdapter,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n    ];\n});\n_c15 = PItemsQuery;\n// src/hooks/useCacheSubscription.ts\n\nfunction useCacheSubscription(cache, listener, options) {\n    _s27();\n    const subscriptionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const listenerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(listener);\n    const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    listenerRef.current = listener;\n    optionsRef.current = options;\n    const stableListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheSubscription.useCallback10[stableListener]\": (event)=>{\n            listenerRef.current(event);\n        }\n    }[\"useCacheSubscription.useCallback10[stableListener]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCacheSubscription.useEffect18\": ()=>{\n            if (!cache) {\n                if (subscriptionRef.current) {\n                    subscriptionRef.current.unsubscribe();\n                    subscriptionRef.current = null;\n                }\n                return;\n            }\n            const subscriptionOptions = optionsRef.current ? {\n                ...optionsRef.current,\n                // eslint-disable-next-line no-undefined\n                eventTypes: optionsRef.current.eventTypes ? [\n                    ...optionsRef.current.eventTypes\n                ] : void 0\n            } : {};\n            subscriptionRef.current = cache.subscribe(stableListener, subscriptionOptions);\n            return ({\n                \"useCacheSubscription.useEffect18\": ()=>{\n                    if (subscriptionRef.current) {\n                        subscriptionRef.current.unsubscribe();\n                        subscriptionRef.current = null;\n                    }\n                }\n            })[\"useCacheSubscription.useEffect18\"];\n        }\n    }[\"useCacheSubscription.useEffect18\"], [\n        cache,\n        stableListener,\n        options\n    ]);\n    return subscriptionRef.current;\n}\n_s27(useCacheSubscription, \"X8+FuYlCrc7mKRNZTwK+tCODHAo=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n// src/hooks/useCacheItem.ts\n\n\nfunction useCacheItem(cache, key) {\n    _s28();\n    const [item, setItem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCacheItem.useEffect19\": ()=>{\n            if (!cache || !key) {\n                setItem(null);\n                setIsLoading(false);\n                return;\n            }\n            const cachedItem = cache.cacheMap.get(key);\n            setItem(cachedItem);\n            setIsLoading(false);\n        }\n    }[\"useCacheItem.useEffect19\"], [\n        cache,\n        key\n    ]);\n    const normalizeKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheItem.useCallback11[normalizeKey]\": (key2)=>{\n            const normalized = ({\n                \"useCacheItem.useCallback11[normalizeKey].normalized\": ()=>{\n                    const replacer = {\n                        \"useCacheItem.useCallback11[normalizeKey].normalized.replacer\": (value)=>{\n                            if (typeof value === \"string\" || typeof value === \"number\") {\n                                return (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_2__.normalizeKeyValue)(value);\n                            }\n                            if (Array.isArray(value)) return value.map(replacer);\n                            if (value && typeof value === \"object\") {\n                                const out = {};\n                                for (const k of Object.keys(value))out[k] = replacer(value[k]);\n                                return out;\n                            }\n                            return value;\n                        }\n                    }[\"useCacheItem.useCallback11[normalizeKey].normalized.replacer\"];\n                    return replacer(key2);\n                }\n            })[\"useCacheItem.useCallback11[normalizeKey].normalized\"]();\n            return createStableHash(normalized);\n        }\n    }[\"useCacheItem.useCallback11[normalizeKey]\"], []);\n    const eventListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheItem.useCallback11[eventListener]\": (event)=>{\n            if (!key) return;\n            const keyString = normalizeKey(key);\n            switch(event.type){\n                case \"item_created\":\n                case \"item_updated\":\n                case \"item_retrieved\":\n                case \"item_set\":\n                    if (normalizeKey(event.key) === keyString) {\n                        setItem(event.item);\n                    }\n                    break;\n                case \"item_removed\":\n                    if (normalizeKey(event.key) === keyString) {\n                        setItem(null);\n                    }\n                    break;\n                case \"cache_cleared\":\n                    setItem(null);\n                    break;\n            }\n        }\n    }[\"useCacheItem.useCallback11[eventListener]\"], [\n        key,\n        normalizeKey\n    ]);\n    const subscriptionOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useCacheItem.useMemo18[subscriptionOptions]\": ()=>{\n            if (!key) return void 0;\n            return {\n                keys: [\n                    key\n                ],\n                eventTypes: [\n                    \"item_created\",\n                    \"item_updated\",\n                    \"item_removed\",\n                    \"item_retrieved\",\n                    \"item_set\",\n                    \"cache_cleared\"\n                ]\n            };\n        }\n    }[\"useCacheItem.useMemo18[subscriptionOptions]\"], [\n        key\n    ]);\n    useCacheSubscription(cache, eventListener, subscriptionOptions);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheItem.useCallback11[refetch]\": async ()=>{\n            if (!cache || !key) {\n                return null;\n            }\n            setIsLoading(true);\n            try {\n                const [, result] = await cache.operations.get(key);\n                setItem(result);\n                return result;\n            } catch (error) {\n                console.error(\"Error refetching item:\", error);\n                return null;\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useCacheItem.useCallback11[refetch]\"], [\n        cache,\n        key\n    ]);\n    return {\n        item,\n        isLoading,\n        refetch\n    };\n}\n_s28(useCacheItem, \"YWHTiHXS9dp9WZ1PYgPXyo3nMOQ=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        useCacheSubscription,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n    ];\n});\n// src/hooks/useCacheQuery.ts\n\n\nfunction useCacheQuery(cache) {\n    let query = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, locations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    _s29();\n    const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const queryString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useCacheQuery.useMemo19[queryString]\": ()=>createStableHash(query)\n    }[\"useCacheQuery.useMemo19[queryString]\"], [\n        query\n    ]);\n    const locationsString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useCacheQuery.useMemo19[locationsString]\": ()=>createStableHash(locations)\n    }[\"useCacheQuery.useMemo19[locationsString]\"], [\n        locations\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCacheQuery.useEffect20\": ()=>{\n            if (!cache) {\n                setItems([]);\n                setIsLoading(false);\n                return;\n            }\n            cache.operations.all(query, locations).then({\n                \"useCacheQuery.useEffect20\": (cachedItems)=>{\n                    setItems(cachedItems || []);\n                    setIsLoading(false);\n                }\n            }[\"useCacheQuery.useEffect20\"]).catch({\n                \"useCacheQuery.useEffect20\": (error)=>{\n                    console.error(\"Error querying items from cache:\", error);\n                    setItems([]);\n                    setIsLoading(false);\n                }\n            }[\"useCacheQuery.useEffect20\"]);\n        }\n    }[\"useCacheQuery.useEffect20\"], [\n        cache,\n        queryString,\n        locationsString\n    ]);\n    const normalizeKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheQuery.useCallback12[normalizeKey]\": (key)=>{\n            const normalized = ({\n                \"useCacheQuery.useCallback12[normalizeKey].normalized\": ()=>{\n                    const replacer = {\n                        \"useCacheQuery.useCallback12[normalizeKey].normalized.replacer\": (value)=>{\n                            if (typeof value === \"string\" || typeof value === \"number\") {\n                                return (0,_fjell_cache__WEBPACK_IMPORTED_MODULE_2__.normalizeKeyValue)(value);\n                            }\n                            if (Array.isArray(value)) return value.map(replacer);\n                            if (value && typeof value === \"object\") {\n                                const out = {};\n                                for (const k of Object.keys(value))out[k] = replacer(value[k]);\n                                return out;\n                            }\n                            return value;\n                        }\n                    }[\"useCacheQuery.useCallback12[normalizeKey].normalized.replacer\"];\n                    return replacer(key);\n                }\n            })[\"useCacheQuery.useCallback12[normalizeKey].normalized\"]();\n            return createStableHash(normalized);\n        }\n    }[\"useCacheQuery.useCallback12[normalizeKey]\"], []);\n    const queriesMatch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheQuery.useCallback12[queriesMatch]\": (q1, q2)=>{\n            return deepEqual(q1, q2);\n        }\n    }[\"useCacheQuery.useCallback12[queriesMatch]\"], []);\n    const eventListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheQuery.useCallback12[eventListener]\": (event)=>{\n            switch(event.type){\n                case \"items_queried\":\n                    if (queriesMatch(event.query, query) && createStableHash(event.locations) === locationsString) {\n                        setItems(event.items);\n                    }\n                    break;\n                case \"item_created\":\n                case \"item_updated\":\n                case \"item_retrieved\":\n                case \"item_set\":\n                    if (cache) {\n                        cache.operations.all(query, locations).then({\n                            \"useCacheQuery.useCallback12[eventListener]\": (updatedItems)=>{\n                                setItems(updatedItems || []);\n                            }\n                        }[\"useCacheQuery.useCallback12[eventListener]\"]).catch({\n                            \"useCacheQuery.useCallback12[eventListener]\": (error)=>{\n                                console.error(\"Error re-querying items from cache after item change:\", error);\n                            }\n                        }[\"useCacheQuery.useCallback12[eventListener]\"]);\n                    }\n                    break;\n                case \"item_removed\":\n                    setItems({\n                        \"useCacheQuery.useCallback12[eventListener]\": (prevItems)=>prevItems.filter({\n                                \"useCacheQuery.useCallback12[eventListener]\": (item)=>normalizeKey(item.key) !== normalizeKey(event.key)\n                            }[\"useCacheQuery.useCallback12[eventListener]\"])\n                    }[\"useCacheQuery.useCallback12[eventListener]\"]);\n                    break;\n                case \"cache_cleared\":\n                    setItems([]);\n                    break;\n            }\n        }\n    }[\"useCacheQuery.useCallback12[eventListener]\"], [\n        cache,\n        queryString,\n        locationsString,\n        normalizeKey,\n        queriesMatch\n    ]);\n    const subscriptionOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useCacheQuery.useMemo19[subscriptionOptions]\": ()=>({\n                eventTypes: [\n                    \"items_queried\",\n                    \"item_created\",\n                    \"item_updated\",\n                    \"item_removed\",\n                    \"item_retrieved\",\n                    \"item_set\",\n                    \"cache_cleared\"\n                ],\n                debounceMs: 50\n            })\n    }[\"useCacheQuery.useMemo19[subscriptionOptions]\"], []);\n    useCacheSubscription(cache, eventListener, subscriptionOptions);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCacheQuery.useCallback12[refetch]\": async ()=>{\n            if (!cache) {\n                return [];\n            }\n            setIsLoading(true);\n            try {\n                const results = await cache.operations.all(query, locations);\n                setItems(results || []);\n                return results || [];\n            } catch (error) {\n                console.error(\"Error refetching query:\", error);\n                return [];\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useCacheQuery.useCallback12[refetch]\"], [\n        cache,\n        queryString,\n        locationsString\n    ]);\n    return {\n        items,\n        isLoading,\n        refetch\n    };\n}\n_s29(useCacheQuery, \"M8012gB+g4UFl6FYVE0dmYk5Kms=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        useCacheSubscription,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n    ];\n});\n //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15;\n$RefreshReg$(_c, \"Adapter\");\n$RefreshReg$(_c1, \"CItemFacet\");\n$RefreshReg$(_c2, \"CItemLoad\");\n$RefreshReg$(_c3, \"CItemQuery\");\n$RefreshReg$(_c4, \"CItemsProvider\");\n$RefreshReg$(_c5, \"CItemsFacet\");\n$RefreshReg$(_c6, \"CItemsFind\");\n$RefreshReg$(_c7, \"CItemsQuery\");\n$RefreshReg$(_c8, \"Adapter2\");\n$RefreshReg$(_c9, \"PItemFacet\");\n$RefreshReg$(_c10, \"PItemLoad\");\n$RefreshReg$(_c11, \"PItemQuery\");\n$RefreshReg$(_c12, \"PItemsProvider\");\n$RefreshReg$(_c13, \"PItemsFacet\");\n$RefreshReg$(_c14, \"PItemsFind\");\n$RefreshReg$(_c15, \"PItemsQuery\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtJQUFBO0FBQUE7QUFJa0I7QUF1T1gsSUFBTSxrQkFBa0IsQ0FVN0IsU0FFQTs7SUFHQSxNQUFNLGtCQUFrQiw2Q0FBTSxDQUFXLE9BQU87SUFFaEQsSUFBSSxvQkFBb0IsUUFBVztRQUNqQyxNQUFNLElBQUksTUFDUixtQ0FBOEMsT0FBWCxXQUFXO0lBRWxEO0lBQ0EsT0FBTztBQUNUOzs7QUNsUUE7QUFBQTtJQUFBO0FBQUE7QUFFdUI7QUEyRmhCLElBQU0sV0FBVyxDQVF0QixTQUE0Qzs7SUFDNUMsTUFBTSxrQkFBd0IsOENBQVcsT0FBTztJQUVoRCxJQUFJLG9CQUFvQixRQUFXO1FBQ2pDLE1BQU0sSUFBSSxNQUNSLG1DQUE4QyxPQUFYLFdBQVc7SUFFbEQ7SUFDQSxPQUFPO0FBQ1Q7OztBQzlHQTtBQUFBO0lBQUE7QUFBQTtBQUN1QjtBQTZHaEIsSUFBTSxZQUFZLENBUXZCLFNBQTRDOztJQUU1QyxNQUFNLGtCQUF3Qiw4Q0FBVyxPQUFPO0lBRWhELElBQUksb0JBQW9CLFFBQVc7UUFDakMsTUFBTSxJQUFJLE1BQ1IsbUNBQThDLE9BQVgsV0FBVztJQUVsRDtJQUNBLE9BQU87QUFDVDs7O0FDaElBO0FBQUE7SUFBQTtJQUFBO0FBQUE7O0FDQW9CO0FBRXBCLElBQU0sWUFBWSxnRUFBUSxDQUFVLGtCQUFrQjtBQUV0RCxJQUFPLGlCQUFROztBREQwQztBQU1sRDtBQUNnQjtBQU12QixJQUFNLFNBQVMsZUFBVSxJQUFJLGNBQWM7QUFzQnBDLHNCQUF3QixDQVE3QixTQUE0Qzs7SUFFNUMsTUFBTSxrQkFBd0IsOENBQVcsT0FBTztJQUNoRCxJQUFJLG9CQUFvQixRQUFXO1FBQ2pDLE1BQU0sSUFBSSxNQUNSLG1DQUE4QyxPQUFYLFdBQVc7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O2dCQUN6QyxZQUFZO29CQUNWO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO2lCQUNGO2dCQUNBLFlBQVk7YUFDZDt1REFBSSxDQUFDLENBQUM7SUFHTixxQkFBcUIsT0FBTyxlQUFlLG1CQUFtQjtJQUc5RCxNQUFNLFVBQVU7Z0RBQVk7WUFDMUIsSUFBSSxDQUFDLE9BQU87Z0JBQ1YsT0FBTyxDQUFDO1lBQ1Y7WUFFQSxhQUFhLElBQUk7WUFDakIsSUFBSTtnQkFDRixNQUFNLFVBQVUsTUFBTSxNQUFNLFdBQVcsSUFBSSxPQUFPLFNBQVM7Z0JBQzNELFNBQVMsV0FBVyxDQUFDLENBQUM7Z0JBQ3RCLE9BQU8sV0FBVyxDQUFDO1lBQ3JCLFNBQVMsT0FBTztnQkFDZCxRQUFRLE1BQU0sMkJBQTJCLEtBQUs7Z0JBQzlDLE9BQU8sQ0FBQztZQUNWLFNBQUU7Z0JBQ0EsYUFBYSxLQUFLO1lBQ3BCO1FBQ0Y7K0NBQUc7UUFBQztRQUFPO1FBQWEsZUFBZTtLQUFDO0lBRXhDLE9BQU87UUFDTDtRQUNBO1FBQ0E7SUFDRjtBQUNGO0tBdkpnQjs7UUFpQlksMkNBQUFiO1FBQ1EsMkNBQUFBO1FBR2QsMENBQUFMO1FBQ0ksMENBQUFBOztRQXNCSCw4Q0FBQUk7UUFxQkEsOENBQUFBO1FBS0MsOENBQUFBO1FBeUNNLDBDQUFBSjtRQWM1QjtRQUdnQiw4Q0FBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0FJdGVtQWRhcHRlci50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9BSXRlbS50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9BSXRlbXMudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvY29udGFpbmVkL0NJdGVtQWRhcHRlci50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9sb2dnZXIudHMiLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9jb250YWluZWQvQ0l0ZW0udHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvY29udGFpbmVkL0NJdGVtcy50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9jb250YWluZWQvQ0l0ZW1GYWNldC50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy91dGlscy50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2NvbnRhaW5lZC9DSXRlbUxvYWQudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvdXNlQXN5bmNFcnJvci50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2NvbnRhaW5lZC9DSXRlbVF1ZXJ5LnRzeCIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2NvbnRhaW5lZC9DSXRlbXNGYWNldC50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9jb250YWluZWQvQ0l0ZW1zUHJvdmlkZXIudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvY29udGFpbmVkL0NJdGVtc0ZpbmQudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvY29udGFpbmVkL0NJdGVtc1F1ZXJ5LnRzeCIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL0ZhY2V0ZWQudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvcHJpbWFyeS9QSXRlbUFkYXB0ZXIudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvcHJpbWFyeS9QSXRlbS50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9wcmltYXJ5L1BJdGVtcy50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9wcmltYXJ5L1BJdGVtRmFjZXQudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvcHJpbWFyeS9QSXRlbUxvYWQudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvcHJpbWFyeS9QSXRlbVF1ZXJ5LnRzeCIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL3ByaW1hcnkvUEl0ZW1zRmFjZXQudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvcHJpbWFyeS9QSXRlbXNQcm92aWRlci50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9wcmltYXJ5L1BJdGVtc0ZpbmQudHN4IiwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9zcmMvcHJpbWFyeS9QSXRlbXNRdWVyeS50c3giLCIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL3NyYy9ob29rcy91c2VDYWNoZVN1YnNjcmlwdGlvbi50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2hvb2tzL3VzZUNhY2hlSXRlbS50cyIsIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvc3JjL2hvb2tzL3VzZUNhY2hlUXVlcnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWxsSXRlbVR5cGVBcnJheXMsIENvbUtleSwgUHJpS2V5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgeyBMb2NLZXlBcnJheSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgSXRlbVF1ZXJ5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBBSXRlbSBmcm9tIFwiLi9BSXRlbVwiO1xuaW1wb3J0ICogYXMgQUl0ZW1zIGZyb20gXCIuL0FJdGVtc1wiO1xuaW1wb3J0ICogYXMgRmFjZXRlZCBmcm9tIFwiLi9GYWNldGVkXCI7XG5cbmV4cG9ydCB0eXBlIEZpbmRNZXRob2Q8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4gPSAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApID0+IFByb21pc2U8VltdIHwgbnVsbD47XG5cbmV4cG9ydCB0eXBlIEZpbmRPbmVNZXRob2Q8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4gPSAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApID0+IFByb21pc2U8ViB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBBbGxBY3Rpb25NZXRob2Q8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4gPSAoXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICkgPT4gUHJvbWlzZTxWW10gfCBudWxsPjtcblxuZXhwb3J0IHR5cGUgQWxsRmFjZXRNZXRob2Q8XG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPiA9IChcbiAgICBmYWNldDogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICkgPT4gUHJvbWlzZTxhbnkgfCBudWxsPjtcblxuZXhwb3J0IHR5cGUgQWN0aW9uTWV0aG9kPFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+ID0gKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbmV4cG9ydCB0eXBlIEZhY2V0TWV0aG9kPFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPiA9IChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKSA9PiBQcm9taXNlPGFueSB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBBbGxNZXRob2Q8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4gPSAoXG4gICAgcXVlcnk/OiBJdGVtUXVlcnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApID0+IFByb21pc2U8VltdIHwgbnVsbD47XG5cbmV4cG9ydCB0eXBlIE9uZU1ldGhvZDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPiA9IChcbiAgICBxdWVyeT86IEl0ZW1RdWVyeSxcbiAgICBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+XG4gICkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbmV4cG9ydCB0eXBlIENyZWF0ZU1ldGhvZDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPiA9IChcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApID0+IFByb21pc2U8Vj47XG5cbmV4cG9ydCB0eXBlIEdldE1ldGhvZDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPiA9IChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApID0+IFByb21pc2U8ViB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBSZW1vdmVNZXRob2Q8XG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+ID0gKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuZXhwb3J0IHR5cGUgUmV0cmlldmVNZXRob2Q8XG4gICAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBTIGV4dGVuZHMgc3RyaW5nLFxuICAgIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4gPSAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgKSA9PiBQcm9taXNlPFYgfCBudWxsPjtcblxuZXhwb3J0IHR5cGUgVXBkYXRlTWV0aG9kPFxuICAgIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgUyBleHRlbmRzIHN0cmluZyxcbiAgICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+ID0gKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+LFxuICApID0+IFByb21pc2U8Vj47XG5cbmV4cG9ydCB0eXBlIFNldE1ldGhvZDxcbiAgICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgIFMgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICAgIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gICAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyPiA9IChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IFYsXG4gICkgPT4gUHJvbWlzZTxWPjtcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZXh0VHlwZTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbj4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBrVHlwZXM6IEFsbEl0ZW1UeXBlQXJyYXlzPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgYWxsOiBBbGxNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICBvbmU6IE9uZU1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIGNyZWF0ZTogQ3JlYXRlTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgZ2V0OiBHZXRNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICByZW1vdmU6IFJlbW92ZU1ldGhvZDxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIHJldHJpZXZlOiBSZXRyaWV2ZU1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIHVwZGF0ZTogVXBkYXRlTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgYWxsQWN0aW9uOiBBbGxBY3Rpb25NZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICBhbGxGYWNldDogQWxsRmFjZXRNZXRob2Q8TDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICBhY3Rpb246IEFjdGlvbk1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIGZhY2V0OiBGYWNldE1ldGhvZDxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuXG4gIGZpbmQ6IEZpbmRNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICBmaW5kT25lOiBGaW5kT25lTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG5cbiAgc2V0OiBTZXRNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICBhZGRBY3Rpb25zPzogKGFjdGlvbjogQUl0ZW0uQWN0aW9uTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pID0+IFJlY29yZDxzdHJpbmcsIEFJdGVtLkFkZGVkQWN0aW9uTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+O1xuICBhZGRGYWNldHM/OiAoZmFjZXQ6IEZhY2V0ZWQuRmFjZXRNZXRob2Q8TDEsIEwyLCBMMywgTDQsIEw1PikgPT4gUmVjb3JkPHN0cmluZywgRmFjZXRlZC5BZGRlZEZhY2V0TWV0aG9kPEwxLCBMMiwgTDMsIEw0LCBMNT4+O1xuICBhZGRBbGxBY3Rpb25zPzogKGFsbEFjdGlvbjogQUl0ZW1zLkFsbEFjdGlvbk1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KSA9PiBSZWNvcmQ8c3RyaW5nLCBBSXRlbXMuQWRkZWRBbGxBY3Rpb25NZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj47XG4gIGFkZEFsbEZhY2V0cz86IChhbGxGYWNldDogQWxsRmFjZXRNZXRob2Q8TDEsIEwyLCBMMywgTDQsIEw1PikgPT4gUmVjb3JkPHN0cmluZywgRmFjZXRlZC5BZGRlZEZhY2V0TWV0aG9kPEwxLCBMMiwgTDMsIEw0LCBMNT4+O1xuXG59XG5cbmV4cG9ydCB0eXBlIENvbnRleHQ8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4+ID0gUmVhY3QuQ29udGV4dDxDb250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGNvbnN0IHVzZUFJdGVtQWRhcHRlciA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGluZGVudFxuICBjb250ZXh0OiBDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbmRlbnRcbiAgY29udGV4dE5hbWU6IHN0cmluZ1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW5kZW50XG4pOiBDb250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgY29uc3QgY29udGV4dEluc3RhbmNlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICBpZiAoY29udGV4dEluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhpcyBob29rIG11c3QgYmUgdXNlZCB3aXRoaW4gYSAke2NvbnRleHROYW1lfWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dEluc3RhbmNlO1xufTtcbiIsImltcG9ydCB7IEFsbEl0ZW1UeXBlQXJyYXlzLCBDb21LZXksIEl0ZW0sIExvY0tleUFycmF5LCBQcmlLZXkgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCAqIGFzIEZhY2V0ZWQgZnJvbSBcIi4vRmFjZXRlZFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCB0eXBlIEFjdGlvbk1ldGhvZDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiA9IChcbiAgYWN0aW9uOiBzdHJpbmcsXG4gIGJvZHk/OiBhbnksXG4gIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT5cbikgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG5cbmV4cG9ydCB0eXBlIEFkZGVkQWN0aW9uTWV0aG9kPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gKGJvZHk/OiBhbnksIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT4pID0+IFByb21pc2U8ViB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBVcGRhdGVNZXRob2Q8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gPSAoXG4gIGl0ZW06IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PixcbikgPT4gUHJvbWlzZTxWPjtcblxuZXhwb3J0IHR5cGUgU2V0TWV0aG9kPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gKFxuICBpdGVtOiBWLFxuKSA9PiBQcm9taXNlPFY+O1xuXG5leHBvcnQgdHlwZSBSZW1vdmVNZXRob2QgPSAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRleHRUeXBlPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+IGV4dGVuZHMgRmFjZXRlZC5Db250ZXh0VHlwZSB7XG4gIG5hbWU6IHN0cmluZztcbiAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPjtcbiAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8UywgTDEsIEwyLCBMMywgTDQ+IHwgbnVsbDtcbiAgcGtUeXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgcGFyZW50SXRlbTogSXRlbTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbDtcblxuICBpdGVtOiBWIHwgbnVsbDtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBpc1VwZGF0aW5nOiBib29sZWFuO1xuICBpc1JlbW92aW5nOiBib29sZWFuO1xuXG4gIGFjdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBBZGRlZEFjdGlvbk1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PjtcblxuICByZW1vdmU6IFJlbW92ZU1ldGhvZDtcbiAgdXBkYXRlOiBVcGRhdGVNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgc2V0OiBTZXRNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICBhY3Rpb246IEFjdGlvbk1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xufVxuXG5leHBvcnQgdHlwZSBDb250ZXh0PFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gUmVhY3QuQ29udGV4dDxDb250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGNvbnN0IHVzZUFJdGVtID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGNvbnRleHQ6IENvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgY29udGV4dE5hbWU6IHN0cmluZyk6IENvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBjb25zdCBjb250ZXh0SW5zdGFuY2UgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gIGlmIChjb250ZXh0SW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGlzIGhvb2sgbXVzdCBiZSB1c2VkIHdpdGhpbiBhICR7Y29udGV4dE5hbWV9YCxcbiAgICApO1xuICB9XG4gIHJldHVybiBjb250ZXh0SW5zdGFuY2U7XG59O1xuIiwiaW1wb3J0IHsgQWxsSXRlbVR5cGVBcnJheXMsIEl0ZW0sIExvY0tleUFycmF5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIEFJdGVtQWRhcHRlciBmcm9tIFwiLi9BSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIEZhY2V0ZWQgZnJvbSBcIi4vRmFjZXRlZFwiO1xuXG5leHBvcnQgdHlwZSBDcmVhdGVNZXRob2Q8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPiA9IChcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICkgPT4gUHJvbWlzZTxWPjtcblxuZXhwb3J0IHR5cGUgQWxsTWV0aG9kPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4gPSAoKSA9PiBQcm9taXNlPFZbXSB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBPbmVNZXRob2Q8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPiA9ICgpID0+IFByb21pc2U8ViB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBBbGxBY3Rpb25NZXRob2Q8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPiA9IChcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5PzogYW55LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKSA9PiBQcm9taXNlPFZbXSB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBBZGRlZEFsbEFjdGlvbk1ldGhvZDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+ID0gKFxuICAgIGJvZHk/OiBhbnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApID0+IFByb21pc2U8VltdIHwgbnVsbD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGV4dFR5cGU8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbiAgPiBleHRlbmRzIE9taXQ8RmFjZXRlZC5Db250ZXh0VHlwZTxMMSwgTDIsIEwzLCBMNCwgTDU+LCAnZmFjZXQnPiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGl0ZW1zOiBWW107XG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8UywgTDEsIEwyLCBMMywgTDQ+IHwgbnVsbDtcbiAgICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gICAgaXNDcmVhdGluZzogYm9vbGVhbjtcbiAgICBpc1VwZGF0aW5nOiBib29sZWFuO1xuICAgIGlzUmVtb3Zpbmc6IGJvb2xlYW47XG4gICAgcGtUeXBlczogQWxsSXRlbVR5cGVBcnJheXM8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuICAgICAgYWxsQWN0aW9ucz86IFJlY29yZDxzdHJpbmcsIEFkZGVkQWxsQWN0aW9uTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+O1xuICBhbGxGYWNldHM/OiBSZWNvcmQ8c3RyaW5nLCBGYWNldGVkLkFkZGVkRmFjZXRNZXRob2Q8TDEsIEwyLCBMMywgTDQsIEw1Pj47XG4gIGZpbmRlcnM/OiBSZWNvcmQ8c3RyaW5nLCAoLi4ucGFyYW1zOiBhbnlbXSkgPT4gUHJvbWlzZTxWW10gfCBWIHwgbnVsbD4+O1xuXG4gICAgY3JlYXRlOiBDcmVhdGVNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBhbGw6IEFsbE1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIG9uZTogT25lTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgICBhbGxBY3Rpb246IEFsbEFjdGlvbk1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICBhbGxGYWNldDogRmFjZXRlZC5BbGxGYWNldE1ldGhvZDxMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICBmYWNldDogQUl0ZW1BZGFwdGVyLkZhY2V0TWV0aG9kPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gIHNldDogQUl0ZW1BZGFwdGVyLlNldE1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIGZpbmQ6IEFJdGVtQWRhcHRlci5GaW5kTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgZmluZE9uZTogQUl0ZW1BZGFwdGVyLkZpbmRPbmVNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICB1cGRhdGU6IEFJdGVtQWRhcHRlci5VcGRhdGVNZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICByZW1vdmU6IEFJdGVtQWRhcHRlci5SZW1vdmVNZXRob2Q8UywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBhY3Rpb246IEFJdGVtQWRhcHRlci5BY3Rpb25NZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgfVxuXG5leHBvcnQgdHlwZSBDb250ZXh0PFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4gID4gPSBSZWFjdC5Db250ZXh0PENvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCB1bmRlZmluZWQ+O1xuXG5leHBvcnQgY29uc3QgdXNlQUl0ZW1zID0gPFxuViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcblMgZXh0ZW5kcyBzdHJpbmcsXG5MMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbkwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG5MNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihjb250ZXh0OiBDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIGNvbnRleHROYW1lOiBzdHJpbmcpOlxuQ29udGV4dFR5cGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9PiB7XG4gIGNvbnN0IGNvbnRleHRJbnN0YW5jZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKGNvbnRleHRJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoaXMgaG9vayBtdXN0IGJlIHVzZWQgd2l0aGluIGEgJHtjb250ZXh0TmFtZX1gLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRJbnN0YW5jZTtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgeyBBZ2dyZWdhdGVDb25maWcsIENhY2hlLCBjcmVhdGVBZ2dyZWdhdG9yIH0gZnJvbSBcIkBmamVsbC9jYWNoZVwiO1xuaW1wb3J0IHtcbiAgYWJicmV2SUssIGFiYnJldkxLQSwgYWJicmV2UXVlcnksXG4gIENvbUtleSxcbiAgSXRlbSxcbiAgSXRlbVF1ZXJ5LCBMb2NLZXksIExvY0tleUFycmF5LCBQcmlLZXlcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIEFJdGVtIGZyb20gXCIuLi9BSXRlbVwiO1xuaW1wb3J0ICogYXMgQUl0ZW1BZGFwdGVyIGZyb20gXCIuLi9BSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIEFJdGVtcyBmcm9tIFwiLi4vQUl0ZW1zXCI7XG5pbXBvcnQgKiBhcyBGYWNldGVkIGZyb20gXCIuLi9GYWNldGVkXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ0NJdGVtQWRhcHRlcicpO1xuXG5leHBvcnQgdHlwZSBDb250ZXh0VHlwZTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gPSBBSXRlbUFkYXB0ZXIuQ29udGV4dFR5cGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcblxuZXhwb3J0IHR5cGUgQ29udGV4dDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gPSBSZWFjdC5Db250ZXh0PENvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCB1bmRlZmluZWQ+O1xuXG5leHBvcnQgY29uc3QgdXNlQ0l0ZW1BZGFwdGVyID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihjb250ZXh0OiBDb250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sIGNvbnRleHROYW1lOiBzdHJpbmcpOlxuICBDb250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+ID0+IHtcbiAgY29uc3QgY29udGV4dEluc3RhbmNlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKGNvbnRleHRJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoaXMgaG9vayBtdXN0IGJlIHVzZWQgd2l0aGluIGEgJHtjb250ZXh0TmFtZX1gLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRJbnN0YW5jZTtcbn07XG5cbmV4cG9ydCBjb25zdCBBZGFwdGVyID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPih7XG4gIG5hbWUsXG4gIGNhY2hlLFxuICBjb250ZXh0LFxuICBhZ2dyZWdhdGVzID0ge30sXG4gIGV2ZW50cyA9IHt9LFxuICBhZGRBY3Rpb25zLFxuICBhZGRGYWNldHMsXG4gIGFkZEFsbEFjdGlvbnMsXG4gIGFkZEFsbEZhY2V0cyxcbiAgY2hpbGRyZW5cbn06IHtcbiAgbmFtZTogc3RyaW5nO1xuICBjYWNoZTogQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgY29udGV4dDogQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICBhZ2dyZWdhdGVzPzogQWdncmVnYXRlQ29uZmlnO1xuICBldmVudHM/OiBBZ2dyZWdhdGVDb25maWc7XG4gIGFkZEFjdGlvbnM/OiAoYWN0aW9uOiBBSXRlbS5BY3Rpb25NZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PikgPT4gUmVjb3JkPHN0cmluZywgQUl0ZW0uQWRkZWRBY3Rpb25NZXRob2Q8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj47XG4gIGFkZEZhY2V0cz86IChmYWNldDogRmFjZXRlZC5GYWNldE1ldGhvZDxMMSwgTDIsIEwzLCBMNCwgTDU+KSA9PiBSZWNvcmQ8c3RyaW5nLCBGYWNldGVkLkFkZGVkRmFjZXRNZXRob2Q8TDEsIEwyLCBMMywgTDQsIEw1Pj47XG4gIGFkZEFsbEFjdGlvbnM/OiAoYWxsQWN0aW9uOiBBSXRlbXMuQWxsQWN0aW9uTWV0aG9kPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pID0+IFJlY29yZDxzdHJpbmcsIEFJdGVtcy5BZGRlZEFsbEFjdGlvbk1ldGhvZDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PjtcbiAgYWRkQWxsRmFjZXRzPzogKGFsbEZhY2V0OiBGYWNldGVkLkFsbEZhY2V0TWV0aG9kPEwxLCBMMiwgTDMsIEw0LCBMNT4pID0+IFJlY29yZDxzdHJpbmcsIEZhY2V0ZWQuQWRkZWRGYWNldE1ldGhvZDxMMSwgTDIsIEwzLCBMNCwgTDU+PjtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn0pID0+IHtcblxuICAvLyBWYWxpZGF0ZSBjYWNoZSBhdCBpbml0aWFsaXphdGlvblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FjaGUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignQ2FjaGUgaXMgdW5kZWZpbmVkIGluICVzLiBUaGlzIHdpbGwgY2F1c2UgYWxsIG9wZXJhdGlvbnMgdG8gZmFpbC4nLCBuYW1lKTtcbiAgICB9XG4gIH0sIFtjYWNoZSwgbmFtZV0pO1xuXG4gIGNvbnN0IHBrVHlwZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNhY2hlPy5jb29yZGluYXRlLmt0YSwgW2NhY2hlXSk7XG5cbiAgY29uc3Qgc291cmNlQ2FjaGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ05vIGNhY2hlIHByb3ZpZGVkIHRvICVzLCBvcGVyYXRpb25zIHdpbGwgZmFpbCcsIG5hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgoYWdncmVnYXRlcyAmJiBPYmplY3Qua2V5cyhhZ2dyZWdhdGVzKS5sZW5ndGggPiAwKSB8fCAoZXZlbnRzICYmIE9iamVjdC5rZXlzKGV2ZW50cykubGVuZ3RoID4gMCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVBZ2dyZWdhdG9yPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oXG4gICAgICAgIGNhY2hlLCB7IGFnZ3JlZ2F0ZXMsIGV2ZW50cyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwgW2NhY2hlLCBhZ2dyZWdhdGVzLCBldmVudHMsIG5hbWVdKTtcblxuICBjb25zdCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgc2V0UmVzb2x2ZWRTb3VyY2VDYWNoZV0gPSBSZWFjdC51c2VTdGF0ZTxDYWNoZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gU3RhdGUgdG8gdHJpZ2dlciByZS1yZW5kZXJzIHdoZW4gY2FjaGUgZXZlbnRzIG9jY3VyXG4gIGNvbnN0IFssIHNldENhY2hlVmVyc2lvbl0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzb3VyY2VDYWNoZSkge1xuICAgICAgaWYgKCd0aGVuJyBpbiBzb3VyY2VDYWNoZSAmJiB0eXBlb2Ygc291cmNlQ2FjaGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAoc291cmNlQ2FjaGUgYXMgUHJvbWlzZTxDYWNoZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PikudGhlbihjID0+IHtcbiAgICAgICAgICBzZXRSZXNvbHZlZFNvdXJjZUNhY2hlKGMpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzb3VyY2UgY2FjaGUgaW4gJXM6ICVzJywgbmFtZSwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFJlc29sdmVkU291cmNlQ2FjaGUoc291cmNlQ2FjaGUgYXMgQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pik7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc291cmNlQ2FjaGUsIG5hbWVdKTtcblxuICAvLyBTdWJzY3JpYmUgdG8gY2FjaGUgZXZlbnRzIHRvIHRyaWdnZXIgcmUtcmVuZGVyc1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSB8fCB0eXBlb2YgcmVzb2x2ZWRTb3VyY2VDYWNoZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcmVzb2x2ZWRTb3VyY2VDYWNoZS5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIEluY3JlbWVudCB2ZXJzaW9uIHRvIHRyaWdnZXIgcmUtcmVuZGVycyBmb3IgYW55IGNhY2hlIGNoYW5nZVxuICAgICAgICBzZXRDYWNoZVZlcnNpb24ocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGUgZXZlbnQgaW4gJHtuYW1lfTpgLCBldmVudC50eXBlLCBldmVudCk7XG4gICAgICB9LCB7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBhbGwgY2FjaGUgZXZlbnRzIGZvciB0aGlzIGFkYXB0ZXJcbiAgICAgICAgZXZlbnRUeXBlczogW1xuICAgICAgICAgICdpdGVtX2NyZWF0ZWQnLFxuICAgICAgICAgICdpdGVtX3VwZGF0ZWQnLFxuICAgICAgICAgICdpdGVtX3JlbW92ZWQnLFxuICAgICAgICAgICdpdGVtX3JldHJpZXZlZCcsXG4gICAgICAgICAgJ2l0ZW1fc2V0JyxcbiAgICAgICAgICAnaXRlbXNfcXVlcmllZCcsXG4gICAgICAgICAgJ2NhY2hlX2NsZWFyZWQnLFxuICAgICAgICAgICdsb2NhdGlvbl9pbnZhbGlkYXRlZCcsXG4gICAgICAgICAgJ3F1ZXJ5X2ludmFsaWRhdGVkJ1xuICAgICAgICBdLFxuICAgICAgICBkZWJvdW5jZU1zOiA1MCAvLyBTbWFsbCBkZWJvdW5jZSB0byBiYXRjaCByYXBpZCB1cGRhdGVzXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGUgc3Vic2NyaXB0aW9uIG5vdCBhdmFpbGFibGUgaW4gJHtuYW1lfTpgLCBlcnJvcik7XG4gICAgICAvLyBSZXR1cm4gYSBuby1vcCBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgbmFtZV0pO1xuXG4gIGNvbnN0IGhhbmRsZUNhY2hlRXJyb3IgPSBSZWFjdC51c2VDYWxsYmFjaygob3BlcmF0aW9uOiBzdHJpbmcpID0+IHtcbiAgICBsb2dnZXIuZXJyb3IoJ0NhY2hlIG5vdCBpbml0aWFsaXplZCBpbiAlcy4gT3BlcmF0aW9uIFwiJXNcIiBmYWlsZWQuJywgbmFtZSwgb3BlcmF0aW9uKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhY2hlIG5vdCBpbml0aWFsaXplZCBpbiAke25hbWV9LiBPcGVyYXRpb24gXCIke29wZXJhdGlvbn1cIiBmYWlsZWQuYCk7XG4gIH0sIFtuYW1lXSk7XG5cbiAgY29uc3QgYWxsID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogUHJvbWlzZTxWW10+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2FsbCcsIHtcbiAgICAgIHF1ZXJ5OiBxdWVyeSAmJiBhYmJyZXZRdWVyeShxdWVyeSksXG4gICAgICBjYWNoZTogY2FjaGU/LmNvb3JkaW5hdGUua3RhLFxuICAgICAgbG9jYXRpb25zOiBhYmJyZXZMS0EobG9jYXRpb25zIGFzIHVua25vd24gYXMgQXJyYXk8TG9jS2V5PFMgfCBMMSB8IEwyIHwgTDMgfCBMNCB8IEw1Pj4pLFxuICAgIH0pO1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZUNhY2hlRXJyb3IoJ2FsbCcpO1xuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoJ0ZldGNoaW5nIEl0ZW1zIGZyb20gc291cmNlQ2FjaGUuYWxsJyk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXNvbHZlZFNvdXJjZUNhY2hlLm9wZXJhdGlvbnMuYWxsKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcyBhcyBWW107XG4gIH0sIFtyZXNvbHZlZFNvdXJjZUNhY2hlLCBoYW5kbGVDYWNoZUVycm9yXSk7XG5cbiAgY29uc3Qgb25lID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdvbmUnLCB7XG4gICAgICBxdWVyeTogcXVlcnkgJiYgYWJicmV2UXVlcnkocXVlcnkpLFxuICAgICAgbG9jYXRpb25zOiBhYmJyZXZMS0EobG9jYXRpb25zIGFzIHVua25vd24gYXMgQXJyYXk8TG9jS2V5PFMgfCBMMSB8IEwyIHwgTDMgfCBMNCB8IEw1Pj4pLFxuICAgIH0pO1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZUNhY2hlRXJyb3IoJ29uZScpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gYXdhaXQgcmVzb2x2ZWRTb3VyY2VDYWNoZS5vcGVyYXRpb25zLm9uZShxdWVyeSwgbG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbSBhcyBWO1xuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgaGFuZGxlQ2FjaGVFcnJvcl0pO1xuXG4gIGNvbnN0IGNyZWF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2NyZWF0ZScsIHtcbiAgICAgIGl0ZW0sXG4gICAgICBsb2NhdGlvbnM6IGFiYnJldkxLQShsb2NhdGlvbnMgYXMgdW5rbm93biBhcyBBcnJheTxMb2NLZXk8UyB8IEwxIHwgTDIgfCBMMyB8IEw0IHwgTDU+PiksXG4gICAgfSk7XG4gICAgaWYgKCFyZXNvbHZlZFNvdXJjZUNhY2hlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlQ2FjaGVFcnJvcignY3JlYXRlJyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCByZXNvbHZlZFNvdXJjZUNhY2hlLm9wZXJhdGlvbnMuY3JlYXRlKGl0ZW0sIGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIG5ld0l0ZW0gYXMgVjtcbiAgfSwgW3Jlc29sdmVkU291cmNlQ2FjaGUsIGhhbmRsZUNhY2hlRXJyb3JdKTtcblxuICBjb25zdCBnZXQgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdnZXQnLCB7IGtleTogYWJicmV2SUsoa2V5KSB9KTtcbiAgICBpZiAoIXJlc29sdmVkU291cmNlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVDYWNoZUVycm9yKCdnZXQnKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IHJlc29sdmVkU291cmNlQ2FjaGUub3BlcmF0aW9ucy5nZXQoa2V5KTtcbiAgICByZXR1cm4gaXRlbSBhcyBWO1xuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgaGFuZGxlQ2FjaGVFcnJvcl0pO1xuXG4gIGNvbnN0IHJlbW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3JlbW92ZScsIHsga2V5OiBhYmJyZXZJSyhrZXkpIH0pO1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZUNhY2hlRXJyb3IoJ3JlbW92ZScpO1xuICAgIH1cbiAgICBhd2FpdCByZXNvbHZlZFNvdXJjZUNhY2hlLm9wZXJhdGlvbnMucmVtb3ZlKGtleSk7XG4gIH0sIFtyZXNvbHZlZFNvdXJjZUNhY2hlLCBoYW5kbGVDYWNoZUVycm9yXSk7XG5cbiAgY29uc3QgcmV0cmlldmUgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoXG4gICAga2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdyZXRyaWV2ZScsIHsga2V5OiBhYmJyZXZJSyhrZXkpIH0pO1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZUNhY2hlRXJyb3IoJ3JldHJpZXZlJyk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCByZXNvbHZlZFNvdXJjZUNhY2hlLm9wZXJhdGlvbnMucmV0cmlldmUoa2V5KTtcbiAgICByZXR1cm4gaXRlbSBhcyBWO1xuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgaGFuZGxlQ2FjaGVFcnJvcl0pO1xuXG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PixcbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCd1cGRhdGUnLCB7IGtleTogYWJicmV2SUsoa2V5KSwgaXRlbSB9KTtcbiAgICBpZiAoIXJlc29sdmVkU291cmNlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVDYWNoZUVycm9yKCd1cGRhdGUnKTtcbiAgICB9XG4gICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IHJlc29sdmVkU291cmNlQ2FjaGUub3BlcmF0aW9ucy51cGRhdGUoa2V5LCBpdGVtKTtcbiAgICByZXR1cm4gbmV3SXRlbSBhcyBWO1xuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgaGFuZGxlQ2FjaGVFcnJvcl0pO1xuXG4gIGNvbnN0IGFjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk/OiBhbnksXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnYWN0aW9uJywgeyBrZXk6IGFiYnJldklLKGtleSksIGFjdGlvbiwgYm9keSB9KTtcbiAgICBpZiAoIXJlc29sdmVkU291cmNlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVDYWNoZUVycm9yKCdhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IHJlc29sdmVkU291cmNlQ2FjaGUub3BlcmF0aW9ucy5hY3Rpb24oa2V5LCBhY3Rpb24sIGJvZHkpO1xuICAgIHJldHVybiBuZXdJdGVtIGFzIFY7XG4gIH0sIFtyZXNvbHZlZFNvdXJjZUNhY2hlLCBoYW5kbGVDYWNoZUVycm9yXSk7XG5cbiAgY29uc3QgYWxsQWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk/OiBhbnksXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBQcm9taXNlPFZbXT4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnYWxsQWN0aW9uJywge1xuICAgICAgbG9jYXRpb25zOiBhYmJyZXZMS0EobG9jYXRpb25zIGFzIHVua25vd24gYXMgQXJyYXk8TG9jS2V5PFMgfCBMMSB8IEwyIHwgTDMgfCBMNCB8IEw1Pj4pLFxuICAgICAgYWN0aW9uLFxuICAgICAgYm9keSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc29sdmVkU291cmNlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVDYWNoZUVycm9yKCdhbGxBY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgbmV3SXRlbXMgPSBhd2FpdCByZXNvbHZlZFNvdXJjZUNhY2hlLm9wZXJhdGlvbnMuYWxsQWN0aW9uKGFjdGlvbiwgYm9keSwgbG9jYXRpb25zKTtcbiAgICByZXR1cm4gbmV3SXRlbXMgYXMgVltdO1xuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgaGFuZGxlQ2FjaGVFcnJvcl0pO1xuXG4gIGNvbnN0IGZhY2V0ID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2ZhY2V0JywgeyBrZXk6IGFiYnJldklLKGtleSksIGZhY2V0IH0pO1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZUNhY2hlRXJyb3IoJ2ZhY2V0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb2x2ZWRTb3VyY2VDYWNoZS5vcGVyYXRpb25zLmZhY2V0KGtleSwgZmFjZXQpO1xuICAgIHJldHVybiByZXNwb25zZSBhcyBhbnk7XG4gIH0sIFtyZXNvbHZlZFNvdXJjZUNhY2hlLCBoYW5kbGVDYWNoZUVycm9yXSk7XG5cbiAgY29uc3QgYWxsRmFjZXQgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdhbGxGYWNldCcsIHsgZmFjZXQsIHBhcmFtcyB9KTtcbiAgICBpZiAoIXJlc29sdmVkU291cmNlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVDYWNoZUVycm9yKCdhbGxGYWNldCcpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc29sdmVkU291cmNlQ2FjaGUub3BlcmF0aW9ucy5hbGxGYWNldChmYWNldCwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgYW55O1xuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgaGFuZGxlQ2FjaGVFcnJvcl0pO1xuXG4gIGNvbnN0IGZpbmQgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApOiBQcm9taXNlPFZbXT4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnZmluZCcsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgICBpZiAoIXJlc29sdmVkU291cmNlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVDYWNoZUVycm9yKCdmaW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0l0ZW1zID0gYXdhaXQgcmVzb2x2ZWRTb3VyY2VDYWNoZS5vcGVyYXRpb25zLmZpbmQoZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zIGFzIFZbXTtcbiAgfSwgW3Jlc29sdmVkU291cmNlQ2FjaGUsIGhhbmRsZUNhY2hlRXJyb3JdKTtcblxuICBjb25zdCBmaW5kT25lID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIGxvY2F0aW9ucz86IExvY0tleUFycmF5PEwxLCBMMiwgTDMsIEw0LCBMNT5cbiAgKTogUHJvbWlzZTxWIHwgbnVsbD4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnZmluZE9uZScsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgICBpZiAoIXJlc29sdmVkU291cmNlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVDYWNoZUVycm9yKCdmaW5kT25lJyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0l0ZW1zID0gYXdhaXQgcmVzb2x2ZWRTb3VyY2VDYWNoZS5vcGVyYXRpb25zLmZpbmRPbmUoZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zIGFzIFYgfCBudWxsO1xuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgaGFuZGxlQ2FjaGVFcnJvcl0pO1xuXG4gIGNvbnN0IHNldCA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgIGl0ZW06IFYsXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnc2V0JywgeyBrZXksIGl0ZW0gfSk7XG4gICAgaWYgKCFyZXNvbHZlZFNvdXJjZUNhY2hlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlQ2FjaGVFcnJvcignc2V0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCByZXNvbHZlZFNvdXJjZUNhY2hlLm9wZXJhdGlvbnMuc2V0KGtleSwgaXRlbSk7XG4gICAgcmV0dXJuIG5ld0l0ZW0gYXMgVjtcbiAgfSwgW3Jlc29sdmVkU291cmNlQ2FjaGUsIGhhbmRsZUNhY2hlRXJyb3JdKTtcblxuICBjb25zdCBjb250ZXh0VmFsdWU6IENvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgbmFtZSxcbiAgICBwa1R5cGVzOiBwa1R5cGVzIHx8IChbXSBhcyBhbnkpLFxuICAgIGFsbCxcbiAgICBvbmUsXG4gICAgY3JlYXRlLFxuICAgIGdldCxcbiAgICByZW1vdmUsXG4gICAgcmV0cmlldmUsXG4gICAgdXBkYXRlLFxuICAgIGFjdGlvbixcbiAgICBhbGxBY3Rpb24sXG4gICAgZmFjZXQsXG4gICAgYWxsRmFjZXQsXG4gICAgZmluZCxcbiAgICBmaW5kT25lLFxuICAgIHNldCxcbiAgICBhZGRBY3Rpb25zLFxuICAgIGFkZEZhY2V0cyxcbiAgICBhZGRBbGxBY3Rpb25zLFxuICAgIGFkZEFsbEZhY2V0c1xuICB9KSwgW1xuICAgIG5hbWUsXG4gICAgcGtUeXBlcyxcbiAgICBhbGwsXG4gICAgb25lLFxuICAgIGNyZWF0ZSxcbiAgICBnZXQsXG4gICAgcmVtb3ZlLFxuICAgIHJldHJpZXZlLFxuICAgIHVwZGF0ZSxcbiAgICBhY3Rpb24sXG4gICAgYWxsQWN0aW9uLFxuICAgIGZhY2V0LFxuICAgIGFsbEZhY2V0LFxuICAgIGZpbmQsXG4gICAgZmluZE9uZSxcbiAgICBzZXQsXG4gICAgYWRkQWN0aW9ucyxcbiAgICBhZGRGYWNldHMsXG4gICAgYWRkQWxsQWN0aW9ucyxcbiAgICBhZGRBbGxGYWNldHMsXG5cbiAgXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgY29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIH0sXG4gICAgY2hpbGRyZW4sXG4gICk7XG59XG4iLCJpbXBvcnQgTG9nZ2luZyBmcm9tICdAZmplbGwvbG9nZ2luZyc7XG5cbmNvbnN0IExpYkxvZ2dlciA9IExvZ2dpbmcuZ2V0TG9nZ2VyKCdAZmplbGwvcHJvdmlkZXJzJyk7XG5cbmV4cG9ydCBkZWZhdWx0IExpYkxvZ2dlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuaW1wb3J0ICogYXMgQUl0ZW0gZnJvbSBcIi4uL0FJdGVtXCI7XG5cbmltcG9ydCB7IEl0ZW0gfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRleHRUeXBlPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiBleHRlbmRzIEFJdGVtLkNvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4ge1xuICBwYXJlbnRJdGVtOiBJdGVtPEwxLCBMMiwgTDMsIEw0LCBMNT47XG59XG5cbmV4cG9ydCB0eXBlIENvbnRleHQ8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gUmVhY3QuQ29udGV4dDxDb250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGNvbnN0IHVzZUNJdGVtID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICAvLyBUT0RPOiBXb3VsZG4ndCBhIENJdGVtIGFsd2F5cyBoYXZlIGF0IGxlYXN0IEwxP1xuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGNvbnRleHQ6IENvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgY29udGV4dE5hbWU6IHN0cmluZyk6IENvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBjb25zdCBjb250ZXh0SW5zdGFuY2UgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoY29udGV4dEluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhpcyBob29rIG11c3QgYmUgdXNlZCB3aXRoaW4gYSAke2NvbnRleHROYW1lfWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dEluc3RhbmNlO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuaW1wb3J0ICogYXMgQUl0ZW1zIGZyb20gXCIuLi9BSXRlbXNcIjtcbmltcG9ydCB7IEl0ZW0gfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRleHRUeXBlPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyxcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPiBleHRlbmRzIEFJdGVtcy5Db250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHtcbiAgcGFyZW50SXRlbTogSXRlbTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgQ29udGV4dDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4gPSBSZWFjdC5Db250ZXh0PENvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCB1bmRlZmluZWQ+O1xuXG5leHBvcnQgY29uc3QgdXNlQ0l0ZW1zID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KGNvbnRleHQ6IENvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiwgY29udGV4dE5hbWU6IHN0cmluZyk6XG4gIENvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPT4ge1xuICBjb25zdCBjb250ZXh0SW5zdGFuY2UgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoY29udGV4dEluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhpcyBob29rIG11c3QgYmUgdXNlZCB3aXRoaW4gYSAke2NvbnRleHROYW1lfWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dEluc3RhbmNlO1xufTtcbiIsImltcG9ydCB7IEl0ZW0gfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNJdGVtQWRhcHRlciB9IGZyb20gXCIuL0NJdGVtQWRhcHRlclwiO1xuaW1wb3J0IHsgY3JlYXRlU3RhYmxlSGFzaCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIENJdGVtQWRhcHRlciBmcm9tIFwiLi9DSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIENJdGVtIGZyb20gXCIuL0NJdGVtXCI7XG5cbmV4cG9ydCBjb25zdCBDSXRlbUZhY2V0ID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIHtcbiAgICAgIGFkYXB0ZXIsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNvbnRleHQ6IGl0ZW1Db250ZXh0LFxuICAgICAgY29udGV4dE5hbWUsXG4gICAgICBhZGFwdGVyQ29udGV4dCxcbiAgICAgIGZhY2V0LFxuICAgICAgZmFjZXRQYXJhbXMgPSB7fSxcbiAgICB9OiB7XG4gICAgYWRhcHRlcjogQ0l0ZW1BZGFwdGVyLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNvbnRleHQ6IENJdGVtLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIGFkYXB0ZXJDb250ZXh0Pzogc3RyaW5nO1xuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgZmFjZXRQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gIH1cbiAgKSA9PiB7XG5cbiAgY29uc3QgW3Jlc3VsdCwgc2V0UmVzdWx0XSA9IFJlYWN0LnVzZVN0YXRlPGFueT4obnVsbCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcblxuICAvLyBEZWZhdWx0IGFkYXB0ZXJDb250ZXh0IHRvIGNvbnRleHROYW1lICsgXCJBZGFwdGVyXCIgaWYgbm90IHByb3ZpZGVkXG4gIGNvbnN0IGFkYXB0ZXJDb250ZXh0TmFtZSA9IGFkYXB0ZXJDb250ZXh0IHx8IGAke2NvbnRleHROYW1lfUFkYXB0ZXJgO1xuXG4gIC8vIEdldCB0aGUgYWRhcHRlciBjb250ZXh0XG4gIGNvbnN0IGFkYXB0ZXJDb250ZXh0SW5zdGFuY2UgPSB1c2VDSXRlbUFkYXB0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihhZGFwdGVyLCBhZGFwdGVyQ29udGV4dE5hbWUpO1xuXG4gIC8vIEdldCB0aGUgaXRlbSBjb250ZXh0XG4gIGNvbnN0IGl0ZW1Db250ZXh0VmFsdWUgPSBDSXRlbS51c2VDSXRlbTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KGl0ZW1Db250ZXh0LCBjb250ZXh0TmFtZSk7XG5cbiAgY29uc3QgZmFjZXRQYXJhbXNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVN0YWJsZUhhc2goZmFjZXRQYXJhbXMpLCBbZmFjZXRQYXJhbXNdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChmYWNldCAmJiBmYWNldFBhcmFtcyAmJiBpdGVtQ29udGV4dFZhbHVlICYmIGl0ZW1Db250ZXh0VmFsdWUua2V5ICYmIGFkYXB0ZXJDb250ZXh0SW5zdGFuY2UpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRhcHRlckNvbnRleHRJbnN0YW5jZS5mYWNldChpdGVtQ29udGV4dFZhbHVlLmtleSwgZmFjZXQsIGZhY2V0UGFyYW1zKTtcbiAgICAgICAgICBzZXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBzZXRSZXN1bHQobnVsbCk7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG4gIH0sIFtmYWNldCwgZmFjZXRQYXJhbXNTdHJpbmcsIGl0ZW1Db250ZXh0VmFsdWU/LmtleSwgaXRlbUNvbnRleHRWYWx1ZT8ubG9jYXRpb25zXSk7XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGNvbnRleHQgdmFsdWUgd2l0aCB0aGUgZmFjZXQgcmVzdWx0XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghaXRlbUNvbnRleHRWYWx1ZSkgcmV0dXJuIGl0ZW1Db250ZXh0VmFsdWU7XG5cbiAgICBjb25zdCB1cGRhdGVkRmFjZXRSZXN1bHRzID0geyAuLi5pdGVtQ29udGV4dFZhbHVlLmZhY2V0UmVzdWx0cyB9O1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmICghdXBkYXRlZEZhY2V0UmVzdWx0c1tmYWNldF0pIHtcbiAgICAgICAgdXBkYXRlZEZhY2V0UmVzdWx0c1tmYWNldF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRGYWNldFJlc3VsdHNbZmFjZXRdID0ge1xuICAgICAgICAuLi51cGRhdGVkRmFjZXRSZXN1bHRzW2ZhY2V0XSxcbiAgICAgICAgW2ZhY2V0UGFyYW1zU3RyaW5nXTogcmVzdWx0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5pdGVtQ29udGV4dFZhbHVlLFxuICAgICAgZmFjZXRSZXN1bHRzOiB1cGRhdGVkRmFjZXRSZXN1bHRzLFxuICAgICAgaXNMb2FkaW5nOiBpc0xvYWRpbmcgfHwgaXRlbUNvbnRleHRWYWx1ZS5pc0xvYWRpbmcsXG4gICAgfTtcbiAgfSwgW2l0ZW1Db250ZXh0VmFsdWUsIHJlc3VsdCwgaXNMb2FkaW5nLCBmYWNldCwgZmFjZXRQYXJhbXNTdHJpbmddKTtcblxuICByZXR1cm4gKFxuICAgIDxpdGVtQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2l0ZW1Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBzdGFibGUgb2JqZWN0IGNvbXBhcmlzb24gYW5kIG1lbW9pemF0aW9uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhYmxlIGhhc2ggZm9yIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGluIHVzZU1lbW8gZGVwZW5kZW5jaWVzLlxuICogVGhpcyBpcyBtb3JlIHN0YWJsZSBhbmQgcGVyZm9ybWFudCB0aGFuIEpTT04uc3RyaW5naWZ5IGZvciBtZW1vaXphdGlvbiBwdXJwb3Nlcy5cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gSGFuZGxlcyBjb25zaXN0ZW50IGtleSBvcmRlcmluZ1xuICogLSBNb3JlIHBlcmZvcm1hbnQgdGhhbiBKU09OLnN0cmluZ2lmeSBmb3IgbGFyZ2Ugb2JqZWN0c1xuICogLSBIYW5kbGVzIGNpcmN1bGFyIHJlZmVyZW5jZXMgZ3JhY2VmdWxseVxuICogLSBTdGFibGUgYWNyb3NzIHJlLXJlbmRlcnNcbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY3JlYXRlIGEgc3RhYmxlIGhhc2ggZm9yXG4gKiBAcmV0dXJucyBBIHN0YWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gc3VpdGFibGUgZm9yIG1lbW9pemF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGFibGVIYXNoKG9iajogYW55KTogc3RyaW5nIHtcbiAgLy8gSGFuZGxlIG51bGwsIHVuZGVmaW5lZCwgYW5kIHByaW1pdGl2ZSB2YWx1ZXNcbiAgaWYgKG9iaiA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIFN0cmluZyhvYmopO1xuXG4gIC8vIEhhbmRsZSBjaXJjdWxhciByZWZlcmVuY2VzXG4gIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IGBcIiR7dmFsdWV9XCJgIDogU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuICAgIHNlZW4uYWRkKHZhbHVlKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gJ1snICsgdmFsdWUubWFwKHNlcmlhbGl6ZSkuam9pbignLCcpICsgJ10nO1xuICAgICAgc2Vlbi5kZWxldGUodmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgRGF0ZSBvYmplY3RzXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYERhdGUoJHt2YWx1ZS5nZXRUaW1lKCl9KWA7XG4gICAgICBzZWVuLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSByZWd1bGFyIG9iamVjdHNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKTsgLy8gU29ydCBrZXlzIGZvciBjb25zaXN0ZW50IG9yZGVyaW5nXG4gICAgY29uc3QgcmVzdWx0ID0gJ3snICsga2V5cy5tYXAoa2V5ID0+IGBcIiR7a2V5fVwiOiR7c2VyaWFsaXplKHZhbHVlW2tleV0pfWApLmpvaW4oJywnKSArICd9JztcbiAgICBzZWVuLmRlbGV0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemUob2JqKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhYmxlIG1lbW9pemVkIHZhbHVlIGJhc2VkIG9uIG9iamVjdCBjb250ZW50IHJhdGhlciB0aGFuIHJlZmVyZW5jZS5cbiAqIFVzZSB0aGlzIGluc3RlYWQgb2YgSlNPTi5zdHJpbmdpZnkgaW4gdXNlTWVtbyBkZXBlbmRlbmNpZXMuXG4gKiBOb3RlOiBUaGlzIGlzIE5PVCBhIFJlYWN0IGhvb2sgZGVzcGl0ZSB0aGUgc2ltaWxhciBuYW1pbmcgcGF0dGVybi5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY3JlYXRlIGEgc3RhYmxlIHJlcHJlc2VudGF0aW9uIGZvclxuICogQHJldHVybnMgQSBzdGFibGUgc3RyaW5nIHRoYXQgY2hhbmdlcyBvbmx5IHdoZW4gdGhlIG9iamVjdCBjb250ZW50IGNoYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YWJsZU1lbW88VD4ob2JqOiBUKTogc3RyaW5nIHtcbiAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGZyb20gd2l0aGluIHVzZU1lbW8gaW4gdGhlIGNvbXBvbmVudHNcbiAgcmV0dXJuIGNyZWF0ZVN0YWJsZUhhc2gob2JqKTtcbn1cblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIHNhZmVseSBjaGVjayBpZiBhIHZhbHVlIGlzIGEgUHJvbWlzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlPFQ+KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgUHJvbWlzZTxUPiB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICd0aGVuJyBpbiB2YWx1ZSAmJlxuICAgIHR5cGVvZiAodmFsdWUgYXMgYW55KS50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgJ2NhdGNoJyBpbiB2YWx1ZSAmJlxuICAgIHR5cGVvZiAodmFsdWUgYXMgYW55KS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWVwIGNvbXBhcmlzb24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHVzZU1lbW9cbiAqIGZvciBtb3JlIGNvbXBsZXggc2NlbmFyaW9zIHdoZXJlIHlvdSBuZWVkIGN1c3RvbSBjb21wYXJpc29uIGxvZ2ljLlxuICpcbiAqIEBwYXJhbSBhIEZpcnN0IG9iamVjdCB0byBjb21wYXJlXG4gKiBAcGFyYW0gYiBTZWNvbmQgb2JqZWN0IHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIFRydWUgaWYgb2JqZWN0cyBhcmUgZGVlcGx5IGVxdWFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXF1YWwoYTogYW55LCBiOiBhbnksIHZpc2l0ZWRQYWlycyA9IG5ldyBXZWFrTWFwKCkpOiBib29sZWFuIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIHJldHVybiBhID09PSBiO1xuXG4gIC8vIEhhbmRsZSBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IHRyYWNraW5nIHBhaXJzIG9mIG9iamVjdHNcbiAgaWYgKHZpc2l0ZWRQYWlycy5oYXMoYSkpIHtcbiAgICBjb25zdCB2aXNpdGVkQiA9IHZpc2l0ZWRQYWlycy5nZXQoYSk7XG4gICAgaWYgKHZpc2l0ZWRCID09PSBiKSByZXR1cm4gdHJ1ZTsgLy8gV2UndmUgc2VlbiB0aGlzIGV4YWN0IHBhaXIgYmVmb3JlXG4gICAgaWYgKHZpc2l0ZWRCICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTsgLy8gYSBpcyBhbHJlYWR5IHBhaXJlZCB3aXRoIGEgZGlmZmVyZW50IG9iamVjdFxuICB9XG5cbiAgdmlzaXRlZFBhaXJzLnNldChhLCBiKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSAhPT0gQXJyYXkuaXNBcnJheShiKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSwgdmlzaXRlZFBhaXJzKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gIH1cblxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIENvbnZlcnQga2V5c0IgdG8gU2V0IGZvciBPKDEpIGxvb2t1cCBpbnN0ZWFkIG9mIE8obikgaW5jbHVkZXMoKVxuICBjb25zdCBrZXlzQlNldCA9IG5ldyBTZXQoa2V5c0IpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXNBKSB7XG4gICAgaWYgKCFrZXlzQlNldC5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCB2aXNpdGVkUGFpcnMpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuaW1wb3J0ICogYXMgQUl0ZW0gZnJvbSBcIi4uL0FJdGVtXCI7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7XG4gIGFiYnJldklLLFxuICBDb21LZXksXG4gIGlrVG9MS0EsXG4gIGlzQ29tS2V5LFxuICBpc1ZhbGlkQ29tS2V5LFxuICBJdGVtLFxuICBMb2NLZXlBcnJheSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlRWxlbWVudCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ0l0ZW1BZGFwdGVyIH0gZnJvbSBcIi4vQ0l0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBDSXRlbUFkYXB0ZXIgZnJvbSBcIi4vQ0l0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBDSXRlbSBmcm9tIFwiLi9DSXRlbVwiO1xuaW1wb3J0ICogYXMgRmFjZXRlZCBmcm9tIFwiLi4vRmFjZXRlZFwiO1xuaW1wb3J0IHsgdXNlQXN5bmNFcnJvciB9IGZyb20gXCIuLi91c2VBc3luY0Vycm9yXCI7XG5cbi8vIFRPRE86IEFMaWduIHRoZSBudWxsIGlrcyBhbmQgZGVidWdnaW5nIHN0YXRlbWVudCBjaGFuZ2VzIG1hZGUgb24gOS8xMiBpbiBQSXRlbVByb3ZpZGVyIHdpdGggdGhpcy5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ0NJdGVtTG9hZCcpO1xuXG5leHBvcnQgY29uc3QgQ0l0ZW1Mb2FkID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIHtcbiAgICAgIG5hbWUsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBjb250ZXh0LFxuICAgICAgY29udGV4dE5hbWUsXG4gICAgICBpayxcbiAgICAgIGl0ZW06IHByb3ZpZGVkSXRlbSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudENvbnRleHROYW1lLFxuICAgIH06IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgYWRhcHRlcjogQ0l0ZW1BZGFwdGVyLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNvbnRleHQ6IENJdGVtLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIGlrPzogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBudWxsO1xuICAgIGl0ZW0/OiBWIHwgbnVsbDtcbiAgICBwYXJlbnQ6IEFJdGVtLkNvbnRleHQ8SXRlbTxMMSwgTDIsIEwzLCBMNCwgTDU+LCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIHBhcmVudENvbnRleHROYW1lOiBzdHJpbmc7XG4gIH1cbiAgKSA9PiB7XG5cbiAgY29uc3QgeyB0aHJvd0FzeW5jRXJyb3IgfSA9IHVzZUFzeW5jRXJyb3IoKTtcblxuICAvLyBWYWxpZGF0ZSB0aGF0IGJvdGggaWsgYW5kIGl0ZW0gYXJlIG5vdCBwcm92aWRlZCBhdCB0aGUgc2FtZSB0aW1lXG4gIGlmIChpayAhPT0gdW5kZWZpbmVkICYmIHByb3ZpZGVkSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYCR7bmFtZX06IENhbm5vdCBwcm92aWRlIGJvdGggJ2lrJyBhbmQgJ2l0ZW0nIHBhcmFtZXRlcnMuIFBsZWFzZSBwcm92aWRlIG9ubHkgb25lLmA7XG4gICAgbG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBjb25zdCBbaXRlbUtleSwgc2V0SXRlbUtleV0gPSBSZWFjdC51c2VTdGF0ZTxDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHByb3ZpZGVkSXRlbSAhPT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0cnVlKTtcbiAgY29uc3QgW2lzVXBkYXRpbmcsIHNldElzVXBkYXRpbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbaXNSZW1vdmluZywgc2V0SXNSZW1vdmluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG5cbiAgLy8gU2luY2Ugd2UgcGFzcyB0aGlzIHRvIHRoZSBhY3Rpb25zIGNvbnN0cnVjdG9yLCBkb24ndCBkZXN0cnVjdHVyZSBpdCB5ZXRcbiAgY29uc3QgY0l0ZW1BZGFwdGVyID0gdXNlQ0l0ZW1BZGFwdGVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oYWRhcHRlciwgY29udGV4dE5hbWUpO1xuXG4gIC8vIERlc3RydWN0dXJlIHRoZSB2YWx1ZXMgd2UgbmVlZCB0byBkZWZpbmUgZnVuY3Rpb25zLlxuICBjb25zdCB7XG4gICAgcGtUeXBlcyxcbiAgICByZXRyaWV2ZTogcmV0cmlldmVJdGVtLFxuICAgIHJlbW92ZTogcmVtb3ZlSXRlbSxcbiAgICB1cGRhdGU6IHVwZGF0ZUl0ZW0sXG4gICAgYWN0aW9uOiBhY3Rpb25JdGVtLFxuICAgIGZhY2V0OiBmYWNldEl0ZW0sXG4gICAgc2V0OiBzZXRDYWNoZUl0ZW0sXG4gICAgYWRkQWN0aW9ucyxcbiAgICBhZGRGYWNldHMsXG4gIH0gPSBjSXRlbUFkYXB0ZXI7XG5cbiAgY29uc3QgcGFyZW50SXRlbUFkYXB0ZXIgPSBBSXRlbS51c2VBSXRlbTxJdGVtPEwxLCBMMiwgTDMsIEw0LCBMNT4sIEwxLCBMMiwgTDMsIEw0LCBMNT4ocGFyZW50LCBwYXJlbnRDb250ZXh0TmFtZSk7XG5cbiAgY29uc3Qge1xuICAgIGl0ZW06IHBhcmVudEl0ZW0sXG4gIH0gPSB1c2VNZW1vKCgpID0+IHBhcmVudEl0ZW1BZGFwdGVyLCBbcGFyZW50SXRlbUFkYXB0ZXJdKTtcblxuICBjb25zdCBbaXRlbSwgc2V0SXRlbVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlPFYgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBsb2NhdGlvbnM6IExvY0tleUFycmF5PFMsIEwxLCBMMiwgTDMsIEw0PiB8IG51bGwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGlrVG9MS0EoaXRlbS5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIFtpdGVtXSlcblxuICAvLyBTZXQgaXRlbSBrZXkgZnJvbSBpayBvciBwcm92aWRlZCBpdGVtXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCd1c2VFZmZlY3RbaWtdJywgeyBpaywgcHJvdmlkZWRJdGVtIH0pO1xuXG4gICAgLy8gSWYgYSBwcm92aWRlZEl0ZW0gaXMgc3VwcGxpZWQsIGV4dHJhY3QgdGhlIGtleSBmcm9tIGl0XG4gICAgaWYgKHByb3ZpZGVkSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocHJvdmlkZWRJdGVtICYmIHByb3ZpZGVkSXRlbS5rZXkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdVc2luZyBrZXkgZnJvbSBwcm92aWRlZCBpdGVtJywgeyBpdGVtS2V5OiBwcm92aWRlZEl0ZW0ua2V5IH0pO1xuICAgICAgICBzZXRJdGVtS2V5KHByb3ZpZGVkSXRlbS5rZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdQcm92aWRlZCBpdGVtIGlzIG51bGwgb3IgaGFzIG5vIGtleScpO1xuICAgICAgICBzZXRJdGVtS2V5KHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlrKSB7XG4gICAgICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnS2V5IGhhcyBiZWVuIHByb3ZpZGVkJywgeyBpayB9KTtcbiAgICAgICAgc2V0SXRlbUtleShpayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgJHtuYW1lfTogS2V5IGlzIG5vdCBhIENvbUtleWA7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UsIHsgaWsgfSk7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHRocm93QXN5bmNFcnJvcihuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnTm8gaXRlbSBrZXkgd2FzIHByb3ZpZGVkLCBubyBpdGVtIHdpbGwgYmUgcmV0cmlldmVkJywgeyBpayB9KTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICBzZXRJdGVtS2V5KHVuZGVmaW5lZCk7XG4gICAgfVxuICB9LCBbaWssIHByb3ZpZGVkSXRlbV0pO1xuXG4gIC8vIExvYWQgaXRlbSBmcm9tIGNhY2hlIG9yIHVzZSBwcm92aWRlZCBpdGVtIChjb25zb2xpZGF0ZWQgZWZmZWN0KVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIGEgcHJvdmlkZWRJdGVtIGlzIHN1cHBsaWVkLCB1c2UgaXQgZGlyZWN0bHkgYW5kIHNraXAgY2FjaGUgcmV0cmlldmFsXG4gICAgaWYgKHByb3ZpZGVkSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1VzaW5nIHByb3ZpZGVkIGl0ZW0gZGlyZWN0bHknLCB7IHByb3ZpZGVkSXRlbSB9KTtcbiAgICAgIHNldEl0ZW1TdGF0ZShwcm92aWRlZEl0ZW0pO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgICAgc2V0SXNSZW1vdmluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2Ugb25seSBjYWxsIHRoZSBjYWNoZSBpZiB0aGUga2V5IGlzIHZhbGlkLiAgSWYgd2UgZG9uJ3QgZG8gdGhpcyB3ZSBlbmQgdXAgZHJpdmluZyB1cCBlcnJvcnNcbiAgICAvLyBBbmQgaGVyZSdzIHRoZSBleHBsYW5hdGlvbiwgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHlvdSBkb24ndCBoYXZlIGEgdmFsaWQga2V5LCBhbmQgYSBudWxsIHJlc3VsdCBpcyBleHBlY3RlZFxuICAgIC8vIGlmIHdlIGRvbid0IGRvIHRoaXMgd2UgZW5kIHVwIHdpdGggbWFraW5nIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHdlIGtub3cgd2lsbCBmYWlsLlxuICAgIGlmIChpdGVtS2V5ICYmIGlzVmFsaWRDb21LZXkoaXRlbUtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PikpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKCd1c2VFZmZlY3RbaXRlbUtleV0nLCB7IGl0ZW1LZXk6IGFiYnJldklLKGl0ZW1LZXkpIH0pO1xuICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCByZXRyaWV2ZWRJdGVtID0gYXdhaXQgcmV0cmlldmVJdGVtKGl0ZW1LZXkpO1xuICAgICAgICAgIHNldEl0ZW1TdGF0ZShyZXRyaWV2ZWRJdGVtIGFzIFYgfCBudWxsKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgICAgICAgIHNldElzUmVtb3ZpbmcoZmFsc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgcmV0cmlldmluZyBpdGVtYCwgZXJyb3IpO1xuICAgICAgICAgIHNldEl0ZW1TdGF0ZShudWxsKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgICAgICAgIHNldElzUmVtb3ZpbmcoZmFsc2UpO1xuICAgICAgICAgIHRocm93QXN5bmNFcnJvcihlcnJvciBhcyBFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEl0ZW1TdGF0ZShudWxsKTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICBzZXRJc1VwZGF0aW5nKGZhbHNlKTtcbiAgICAgIHNldElzUmVtb3ZpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2l0ZW1LZXksIHByb3ZpZGVkSXRlbSwgcmV0cmlldmVJdGVtLCBuYW1lXSk7XG5cbiAgY29uc3QgcmVtb3ZlID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpdGVtS2V5ICYmIGlzVmFsaWRDb21LZXkoaXRlbUtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PikpIHtcbiAgICAgIHNldElzUmVtb3ZpbmcodHJ1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIudHJhY2UoJ3JlbW92ZScsIHsgaWs6IGFiYnJldklLKGl0ZW1LZXkpIH0pO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtKGl0ZW1LZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBFcnJvciByZW1vdmluZyBpdGVtYCwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzUmVtb3ZpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBpdGVtS2V5ID8gYCR7bmFtZX06IEludmFsaWQgaXRlbSBrZXkgcHJvdmlkZWQgZm9yIHJlbW92ZWAgOiBgJHtuYW1lfTogTm8gaXRlbSBrZXkgcHJvdmlkZWQgZm9yIHJlbW92ZWA7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3JNZXNzYWdlLCB7IGl0ZW1LZXkgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gIH0sIFtyZW1vdmVJdGVtLCBpdGVtS2V5LCBuYW1lXSk7XG5cbiAgY29uc3QgdXBkYXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKGl0ZW06IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+Pik6IFByb21pc2U8Vj4gPT4ge1xuICAgIGlmIChpdGVtS2V5ICYmIGlzVmFsaWRDb21LZXkoaXRlbUtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PikpIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHNldElzVXBkYXRpbmcodHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKCd1cGRhdGUnLCB7IGl0ZW1LZXk6IGFiYnJldklLKGl0ZW1LZXkpLCBpdGVtIH0pO1xuICAgICAgICAgIGNvbnN0IHJldEl0ZW0gPSBhd2FpdCB1cGRhdGVJdGVtKGl0ZW1LZXksIGl0ZW0pIGFzIFY7XG4gICAgICAgICAgcmV0dXJuIHJldEl0ZW07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBFcnJvciB1cGRhdGluZyBpdGVtYCwgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgJHtuYW1lfTogTm8gaXRlbSBwcm92aWRlZCBmb3IgdXBkYXRlYDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGl0ZW1LZXkgPyBgJHtuYW1lfTogSW52YWxpZCBpdGVtIGtleSBwcm92aWRlZCBmb3IgdXBkYXRlYCA6IGAke25hbWV9OiBObyBpdGVtIGtleSBwcm92aWRlZCBmb3IgdXBkYXRlYDtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UsIHsgaXRlbUtleSB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgfSwgW3VwZGF0ZUl0ZW0sIGl0ZW1LZXksIG5hbWVdKTtcblxuICBjb25zdCBzZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoaXRlbTogVik6IFByb21pc2U8Vj4gPT4ge1xuICAgIGxvZ2dlci50cmFjZShcInNldFwiLCB7IGl0ZW0gfSk7XG4gICAgaWYgKGl0ZW0gJiYgaXNWYWxpZENvbUtleShpdGVtLmtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PikpIHtcbiAgICAgIGNvbnN0IHJldEl0ZW0gPSBhd2FpdCBzZXRDYWNoZUl0ZW0oaXRlbS5rZXksIGl0ZW0pO1xuICAgICAgcmV0dXJuIHJldEl0ZW0gYXMgVjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gIWl0ZW0gPyBgJHtuYW1lfTogTm8gaXRlbSBwcm92aWRlZCB0byBzZXRgIDogYCR7bmFtZX06IEludmFsaWQgb3IgbWlzc2luZyBrZXkgaW4gaXRlbSBwcm92aWRlZCB0byBzZXRgO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSwgeyBpdGVtIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICB9LCBbc2V0Q2FjaGVJdGVtLCBuYW1lXSk7XG5cbiAgY29uc3QgYWN0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGFjdGlvbk5hbWU6IHN0cmluZyxcbiAgICBib2R5PzogYW55LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBpZiAoaXRlbUtleSAmJiBpc1ZhbGlkQ29tS2V5KGl0ZW1LZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4pKSB7XG4gICAgICBzZXRJc1VwZGF0aW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKCdhY3Rpb24nLCB7IGl0ZW1LZXk6IGFiYnJldklLKGl0ZW1LZXkpLCBhY3Rpb25OYW1lLCBib2R5IH0pO1xuICAgICAgICBjb25zdCByZXRJdGVtID0gYXdhaXQgYWN0aW9uSXRlbShpdGVtS2V5LCBhY3Rpb25OYW1lLCBib2R5KSBhcyBWO1xuICAgICAgICByZXR1cm4gcmV0SXRlbTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgZXhlY3V0aW5nIGFjdGlvbiAnJHthY3Rpb25OYW1lfSdgLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNVcGRhdGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGl0ZW1LZXkgPyBgJHtuYW1lfTogSW52YWxpZCBpdGVtIGtleSBwcm92aWRlZCBmb3IgYWN0aW9uICcke2FjdGlvbk5hbWV9J2AgOiBgJHtuYW1lfTogTm8gaXRlbSBrZXkgcHJvdmlkZWQgZm9yIGFjdGlvbiAnJHthY3Rpb25OYW1lfSdgO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSwgeyBpdGVtS2V5LCBhY3Rpb25OYW1lIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICB9LCBbYWN0aW9uSXRlbSwgaXRlbUtleSwgbmFtZV0pO1xuXG4gIGNvbnN0IGZhY2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGZhY2V0TmFtZTogc3RyaW5nLFxuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgKTogUHJvbWlzZTxhbnkgfCBudWxsPiA9PiB7XG4gICAgaWYgKGl0ZW1LZXkgJiYgaXNWYWxpZENvbUtleShpdGVtS2V5IGFzIENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KSkge1xuICAgICAgc2V0SXNVcGRhdGluZyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ2dlci50cmFjZSgnZmFjZXQnLCB7IGl0ZW1LZXk6IGFiYnJldklLKGl0ZW1LZXkpLCBmYWNldE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmFjZXRJdGVtKGl0ZW1LZXksIGZhY2V0TmFtZSwgcGFyYW1zKSBhcyBhbnk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgZXhlY3V0aW5nIGZhY2V0ICcke2ZhY2V0TmFtZX0nYCwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBpdGVtS2V5ID8gYCR7bmFtZX06IEludmFsaWQgaXRlbSBrZXkgcHJvdmlkZWQgZm9yIGZhY2V0ICcke2ZhY2V0TmFtZX0nYCA6IGAke25hbWV9OiBObyBpdGVtIGtleSBwcm92aWRlZCBmb3IgZmFjZXQgJyR7ZmFjZXROYW1lfSdgO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSwgeyBpdGVtS2V5LCBmYWNldE5hbWUgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gIH0sIFtmYWNldEl0ZW0sIGl0ZW1LZXksIG5hbWVdKTtcblxuICBjb25zdCBjb250ZXh0VmFsdWU6IENJdGVtLkNvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPSB7XG4gICAgbmFtZSxcbiAgICBrZXk6IGl0ZW1LZXkgYXMgQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgaXRlbSxcbiAgICBwYXJlbnRJdGVtOiBwYXJlbnRJdGVtIGFzIEl0ZW08TDEsIEwyLCBMMywgTDQsIEw1PixcbiAgICBpc0xvYWRpbmcsXG4gICAgaXNVcGRhdGluZyxcbiAgICBpc1JlbW92aW5nLFxuICAgIHBrVHlwZXMsXG4gICAgcmVtb3ZlLFxuICAgIHVwZGF0ZSxcbiAgICBhY3Rpb24sXG4gICAgZmFjZXQsXG4gICAgc2V0LFxuICAgIGxvY2F0aW9ucyxcbiAgICBmYWNldFJlc3VsdHM6IHt9LFxuICB9O1xuXG4gIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogQ29udGV4dCB2YWx1ZSBjcmVhdGVkYCwge1xuICAgIG5hbWU6IGNvbnRleHRWYWx1ZS5uYW1lLFxuICAgIGhhc0tleTogISFjb250ZXh0VmFsdWUua2V5LFxuICAgIGhhc0l0ZW06ICEhY29udGV4dFZhbHVlLml0ZW0sXG4gICAgaXNMb2FkaW5nOiBjb250ZXh0VmFsdWUuaXNMb2FkaW5nLFxuICAgIGlzVXBkYXRpbmc6IGNvbnRleHRWYWx1ZS5pc1VwZGF0aW5nLFxuICAgIGlzUmVtb3Zpbmc6IGNvbnRleHRWYWx1ZS5pc1JlbW92aW5nLFxuICAgIHBrVHlwZXM6IGNvbnRleHRWYWx1ZS5wa1R5cGVzLFxuICAgIGhhc0xvY2F0aW9uczogISFjb250ZXh0VmFsdWUubG9jYXRpb25zXG4gIH0pO1xuXG4gIGNvbnRleHRWYWx1ZS5hY3Rpb25zID0gdXNlTWVtbygoKSA9PiBhZGRBY3Rpb25zICYmIGFkZEFjdGlvbnMoY29udGV4dFZhbHVlLmFjdGlvbiksIFthZGRBY3Rpb25zLCBjb250ZXh0VmFsdWUuYWN0aW9uXSk7XG4gIGNvbnRleHRWYWx1ZS5mYWNldHMgPSB1c2VNZW1vKCgpID0+IGFkZEZhY2V0cyAmJiBhZGRGYWNldHMoY29udGV4dFZhbHVlLmZhY2V0IGFzIEZhY2V0ZWQuRmFjZXRNZXRob2Q8TDEsIEwyLCBMMywgTDQsIEw1PiksIFthZGRGYWNldHMsIGNvbnRleHRWYWx1ZS5mYWNldF0pO1xuXG4gIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogQ3JlYXRpbmcgY29udGV4dCBwcm92aWRlciBlbGVtZW50YCwge1xuICAgIGhhc0NvbnRleHQ6ICEhY29udGV4dCxcbiAgICBoYXNDaGlsZHJlbjogISFjaGlsZHJlblxuICB9KTtcblxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICBjb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgfSxcbiAgICBjaGlsZHJlbixcbiAgKTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDdXN0b20gaG9vayBmb3IgaGFuZGxpbmcgYXN5bmMgZXJyb3JzIGluIFJlYWN0IGNvbXBvbmVudHMuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCBhc3luYyBlcnJvcnMgYXJlIHByb3Blcmx5IGNhdWdodCBieSBSZWFjdCBFcnJvciBCb3VuZGFyaWVzXG4gKiBieSBzZXR0aW5nIHRoZW0gdG8gc3RhdGUgYW5kIHRocm93aW5nIGR1cmluZyByZW5kZXIuXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VBc3luY0Vycm9yID0gKCkgPT4ge1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPEVycm9yIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gVGhyb3cgZXJyb3IgZHVyaW5nIHJlbmRlciBzbyBSZWFjdCBFcnJvciBCb3VuZGFyaWVzIGNhbiBjYXRjaCBpdFxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGNvbnN0IHRocm93QXN5bmNFcnJvciA9IHVzZUNhbGxiYWNrKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICBzZXRFcnJvcihlcnJvcik7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjbGVhckVycm9yID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEVycm9yKG51bGwpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHsgdGhyb3dBc3luY0Vycm9yLCBjbGVhckVycm9yIH07XG59O1xuXG4vKipcbiAqIFdyYXBwZXIgZnVuY3Rpb24gdGhhdCBjYXRjaGVzIGVycm9ycyBpbiBhc3luYyBvcGVyYXRpb25zIGFuZFxuICogY29udmVydHMgdGhlbSB0byBzeW5jIGVycm9ycyB2aWEgc3RhdGUgbWFuYWdlbWVudFxuICovXG5leHBvcnQgY29uc3Qgd2l0aEFzeW5jRXJyb3JIYW5kbGluZyA9IDxUIGV4dGVuZHMgYW55W10sIFI+KFxuICBhc3luY0ZuOiAoLi4uYXJnczogVCkgPT4gUHJvbWlzZTxSPixcbiAgdGhyb3dBc3luY0Vycm9yOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkLFxuICBvcHRpb25hbDogYm9vbGVhbiA9IGZhbHNlXG4pID0+IHtcbiAgcmV0dXJuIGFzeW5jICguLi5hcmdzOiBUKTogUHJvbWlzZTxSIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXN5bmNGbiguLi5hcmdzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFvcHRpb25hbCkge1xuICAgICAgICAvLyBTYWZlbHkgY29udmVydCB1bmtub3duIGVycm9yIHRvIEVycm9yIGluc3RhbmNlXG4gICAgICAgIGNvbnN0IGVycm9ySW5zdGFuY2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSk7XG4gICAgICAgIHRocm93QXN5bmNFcnJvcihlcnJvckluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbmltcG9ydCAqIGFzIEFJdGVtIGZyb20gXCIuLi9BSXRlbVwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQge1xuICBhYmJyZXZMS0EsXG4gIGFiYnJldlF1ZXJ5LFxuICBDb21LZXksXG4gIEl0ZW0sXG4gIEl0ZW1RdWVyeSxcbiAgUHJpS2V5LFxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNJdGVtQWRhcHRlciB9IGZyb20gXCIuL0NJdGVtQWRhcHRlclwiO1xuaW1wb3J0IHsgY3JlYXRlU3RhYmxlSGFzaCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIENJdGVtQWRhcHRlciBmcm9tIFwiLi9DSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIENJdGVtIGZyb20gXCIuL0NJdGVtXCI7XG5pbXBvcnQgeyBDSXRlbUxvYWQgfSBmcm9tIFwiLi9DSXRlbUxvYWRcIjtcbmltcG9ydCB7IHVzZUFzeW5jRXJyb3IgfSBmcm9tIFwiLi4vdXNlQXN5bmNFcnJvclwiO1xuXG4vLyBUT0RPOiBBTGlnbiB0aGUgbnVsbCBpa3MgYW5kIGRlYnVnZ2luZyBzdGF0ZW1lbnQgY2hhbmdlcyBtYWRlIG9uIDkvMTIgaW4gUEl0ZW1Qcm92aWRlciB3aXRoIHRoaXMuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdDSXRlbVF1ZXJ5UHJvdmlkZXInKTtcblxuZXhwb3J0IGNvbnN0IENJdGVtUXVlcnkgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gICAge1xuICAgICAgbmFtZSxcbiAgICAgIGFkYXB0ZXIsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNvbnRleHQsXG4gICAgICBjb250ZXh0TmFtZSxcbiAgICAgIGNyZWF0ZSxcbiAgICAgIGxvYWRpbmcsXG4gICAgICBub3RGb3VuZCxcbiAgICAgIG9wdGlvbmFsID0gZmFsc2UsXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRDb250ZXh0TmFtZSxcbiAgICAgIHF1ZXJ5LFxuICAgIH06IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgYWRhcHRlcjogQ0l0ZW1BZGFwdGVyLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNvbnRleHQ6IENJdGVtLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIGNyZWF0ZT86IFBhcnRpYWw8SXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+PjtcbiAgICBsb2FkaW5nPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG5vdEZvdW5kPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgICBwYXJlbnQ6IEFJdGVtLkNvbnRleHQ8SXRlbTxMMSwgTDIsIEwzLCBMNCwgTDU+LCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIHBhcmVudENvbnRleHROYW1lOiBzdHJpbmc7XG4gICAgcXVlcnk/OiBJdGVtUXVlcnk7XG4gIH1cbiAgKSA9PiB7XG5cbiAgY29uc3QgW2l0ZW1LZXksIHNldEl0ZW1LZXldID0gUmVhY3QudXNlU3RhdGU8Q29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4gfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IFtxdWVyeVJ1bm5pbmcsIHNldFF1ZXJ5UnVubmluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcbiAgY29uc3QgeyB0aHJvd0FzeW5jRXJyb3IgfSA9IHVzZUFzeW5jRXJyb3IoKTtcblxuICAvLyBTaW5jZSB3ZSBwYXNzIHRoaXMgdG8gdGhlIGFjdGlvbnMgY29uc3RydWN0b3IsIGRvbid0IGRlc3RydWN0dXJlIGl0IHlldFxuICBjb25zdCBjSXRlbUFkYXB0ZXIgPSB1c2VDSXRlbUFkYXB0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihhZGFwdGVyLCBjb250ZXh0TmFtZSk7XG5cbiAgLy8gRGVzdHJ1Y3R1cmUgdGhlIHZhbHVlcyB3ZSBuZWVkIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gIGNvbnN0IHtcbiAgICBvbmU6IG9uZUl0ZW0sXG4gICAgY3JlYXRlOiBjcmVhdGVJdGVtLFxuICB9ID0gdXNlTWVtbygoKSA9PiBjSXRlbUFkYXB0ZXIsIFtjSXRlbUFkYXB0ZXJdKTtcblxuICBjb25zdCBwYXJlbnRJdGVtQ29udGV4dCA9IEFJdGVtLnVzZUFJdGVtPEl0ZW08TDEsIEwyLCBMMywgTDQsIEw1PiwgTDEsIEwyLCBMMywgTDQsIEw1PihwYXJlbnQsIHBhcmVudENvbnRleHROYW1lKTtcblxuICBjb25zdCB7XG4gICAgbG9jYXRpb25zOiBwYXJlbnRMb2NhdGlvbnMsXG4gIH0gPSBwYXJlbnRJdGVtQ29udGV4dDtcblxuICBjb25zdCBxdWVyeVN0cmluZyA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RhYmxlSGFzaChxdWVyeSksIFtxdWVyeV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgc2V0UXVlcnlSdW5uaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgbG9nZ2VyLmRlZmF1bHQoYCR7bmFtZX06IFJ1bm5pbmcgQ0l0ZW1Qcm92ZGVyIFF1ZXJ5YCwge1xuICAgICAgICAgIHF1ZXJ5OiBhYmJyZXZRdWVyeShxdWVyeSksXG4gICAgICAgICAgcGFyZW50TG9jYXRpb25zOiBhYmJyZXZMS0EocGFyZW50TG9jYXRpb25zIGFzIGFueSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyZW50TG9jYXRpb25zKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW06IFYgfCBudWxsID0gYXdhaXQgb25lSXRlbShxdWVyeSwgcGFyZW50TG9jYXRpb25zKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KGAke25hbWV9OiBTZXR0aW5nIEl0ZW0gS2V5IEFmdGVyIG9uZUl0ZW1gLCB7IGl0ZW1LZXk6IGl0ZW0ua2V5IH0pO1xuICAgICAgICAgICAgICBzZXRJdGVtS2V5KGl0ZW0ua2V5KTtcbiAgICAgICAgICAgICAgc2V0UXVlcnlSdW5uaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KCdDcmVhdGluZyBuZXcgaXRlbScsIHsgY3JlYXRlLCBwYXJlbnRMb2NhdGlvbnM6IGFiYnJldkxLQShwYXJlbnRMb2NhdGlvbnMgYXMgYW55KSB9KTtcbiAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNyZWF0ZUl0ZW0oY3JlYXRlLCBwYXJlbnRMb2NhdGlvbnMpO1xuICAgICAgICAgICAgICBsb2dnZXIuZGVmYXVsdChgJHtuYW1lfTogU2V0dGluZyBJdGVtIEtleSBBZnRlciBjcmVhdGVJdGVtYCwgeyBpdGVtS2V5OiBuZXdJdGVtLmtleSB9KTtcbiAgICAgICAgICAgICAgc2V0SXRlbUtleShuZXdJdGVtLmtleSk7XG4gICAgICAgICAgICAgIHNldFF1ZXJ5UnVubmluZyhmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIW9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UXVlcnlSdW5uaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IFJlcXVpcmVkIEl0ZW0gbm90IGZvdW5kLCBhbmQgbm8gY3JlYXRlIHByb3ZpZGVkYCwgeyBxdWVyeSwgb3B0aW9uYWwgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3dBc3luY0Vycm9yKG5ldyBFcnJvcihgUmVxdWlyZWQgSXRlbSBub3QgZm91bmQsIGFuZCBubyBjcmVhdGUgcHJvdmlkZWQgaW4gJHtuYW1lfWApKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRRdWVyeVJ1bm5pbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KCdPcHRpb25hbCBpdGVtIG5vdCBmb3VuZCwgaXRlbSB3aWxsIGJlIG51bGwnLCB7IHF1ZXJ5LCBvcHRpb25hbCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZSAmJiBwYXJlbnRMb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmRlZmF1bHQoJ0NyZWF0aW5nIG5ldyBpdGVtIGFmdGVyIGV4Y2VwdGlvbiB0aHJvdyBmb3IgTm90Rm91bmQnLFxuICAgICAgICAgICAgICAgIHsgZXJyLCBjcmVhdGUsIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgY3JlYXRlSXRlbShjcmVhdGUsIHBhcmVudExvY2F0aW9ucyk7XG4gICAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KGAke25hbWV9OiBTZXR0aW5nIEl0ZW0gS2V5IEFmdGVyIGNyZWF0ZUl0ZW0gZHVyaW5nIEV4Y2VwdGlvbmAsIHsgaXRlbUtleTogbmV3SXRlbS5rZXkgfSk7XG4gICAgICAgICAgICAgIHNldEl0ZW1LZXkobmV3SXRlbS5rZXkpO1xuICAgICAgICAgICAgICBzZXRRdWVyeVJ1bm5pbmcoZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHNldFF1ZXJ5UnVubmluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhyb3dBc3luY0Vycm9yKGVyciBhcyBFcnJvcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0UXVlcnlSdW5uaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVmYXVsdCgnT3B0aW9uYWwgaXRlbSBub3QgZm91bmQsIGl0ZW0gd2lsbCBiZSBudWxsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBsb2dnZXIud2FybmluZyhgJHtuYW1lfTogTm8gcGFyZW50IGxvY2F0aW9ucyBwcm92aWRlZGAsIHsgcXVlcnksIG9wdGlvbmFsIH0pO1xuICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgTm8gcGFyZW50IGxvY2F0aW9ucyBwcm92aWRlZCBpbiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9LCBbcXVlcnlTdHJpbmcsIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIGNvbnN0IHJldHVybkNvbnRleHQgPSBDSXRlbUxvYWQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pih7XG4gICAgbmFtZSxcbiAgICBpazogaXRlbUtleSBhcyBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IG51bGwsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudENvbnRleHROYW1lLFxuICAgIGFkYXB0ZXIsXG4gICAgY29udGV4dCxcbiAgICBjb250ZXh0TmFtZSxcbiAgICBjaGlsZHJlbixcbiAgfSk7XG5cbiAgaWYgKHF1ZXJ5UnVubmluZykge1xuICAgIHJldHVybiBsb2FkaW5nO1xuICB9IGVsc2UgaWYgKGl0ZW1LZXkgfHwgb3B0aW9uYWwpIHtcbiAgICByZXR1cm4gcmV0dXJuQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm90Rm91bmQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IEl0ZW0sIEl0ZW1RdWVyeSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgQUl0ZW0gZnJvbSBcIi4uL0FJdGVtXCI7XG5pbXBvcnQgeyB1c2VDSXRlbUFkYXB0ZXIgfSBmcm9tIFwiLi9DSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVN0YWJsZUhhc2ggfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCAqIGFzIENJdGVtQWRhcHRlciBmcm9tIFwiLi9DSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIENJdGVtcyBmcm9tIFwiLi9DSXRlbXNcIjtcbmltcG9ydCB7IENJdGVtc1Byb3ZpZGVyIH0gZnJvbSBcIi4vQ0l0ZW1zUHJvdmlkZXJcIjtcblxuZXhwb3J0IGNvbnN0IENJdGVtc0ZhY2V0ID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIHtcbiAgICAgIG5hbWUsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY2hpbGRyZW4gPSAoPD48Lz4pLFxuICAgICAgY29udGV4dDogaXRlbXNDb250ZXh0LFxuICAgICAgY29udGV4dE5hbWUsXG4gICAgICBhZGFwdGVyQ29udGV4dCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudENvbnRleHROYW1lLFxuICAgICAgcmVuZGVyRWFjaCxcbiAgICAgIGZhY2V0LFxuICAgICAgZmFjZXRQYXJhbXMgPSB7fSxcbiAgICB9OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGFkYXB0ZXI6IENJdGVtQWRhcHRlci5Db250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgY29udGV4dDogQ0l0ZW1zLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIGFkYXB0ZXJDb250ZXh0Pzogc3RyaW5nO1xuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5O1xuICAgIHBhcmVudDogQUl0ZW0uQ29udGV4dDxJdGVtPEwxLCBMMiwgTDMsIEw0LCBMNSwgbmV2ZXI+LCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIHBhcmVudENvbnRleHROYW1lOiBzdHJpbmc7XG4gICAgcmVuZGVyRWFjaD86IChpdGVtOiBWKSA9PiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBmYWNldFBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgfVxuICApID0+IHtcblxuICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHRdID0gUmVhY3QudXNlU3RhdGU8YW55PihudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuXG4gIC8vIERlZmF1bHQgYWRhcHRlckNvbnRleHQgdG8gY29udGV4dE5hbWUgKyBcIkFkYXB0ZXJcIiBpZiBub3QgcHJvdmlkZWRcbiAgY29uc3QgYWRhcHRlckNvbnRleHROYW1lID0gYWRhcHRlckNvbnRleHQgfHwgYCR7Y29udGV4dE5hbWV9QWRhcHRlcmA7XG5cbiAgLy8gVHJ5IHRvIGdldCBleGlzdGluZyBjb250ZXh0IGZpcnN0XG4gIGxldCBleGlzdGluZ0NvbnRleHQ6IENJdGVtcy5Db250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgdW5kZWZpbmVkO1xuICB0cnkge1xuICAgIGV4aXN0aW5nQ29udGV4dCA9IENJdGVtcy51c2VDSXRlbXMoaXRlbXNDb250ZXh0LCBjb250ZXh0TmFtZSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIE5vIGV4aXN0aW5nIGNvbnRleHQsIHdlJ2xsIGNyZWF0ZSBhIG5ldyBwcm92aWRlclxuICB9XG5cbiAgLy8gU2luY2Ugd2UgcGFzcyB0aGlzIHRvIHRoZSBhY3Rpb25zIGNvbnN0cnVjdG9yLCBkb24ndCBkZXN0cnVjdHVyZSBpdCB5ZXRcbiAgY29uc3QgYWRhcHRlckNvbnRleHRJbnN0YW5jZSA9IHVzZUNJdGVtQWRhcHRlcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KGFkYXB0ZXIsIGFkYXB0ZXJDb250ZXh0TmFtZSk7XG5cbiAgY29uc3QgcGFyZW50Q29udGV4dCA9IEFJdGVtLnVzZUFJdGVtPEl0ZW08TDEsIEwyLCBMMywgTDQsIEw1PiwgTDEsIEwyLCBMMywgTDQsIEw1PihwYXJlbnQsIHBhcmVudENvbnRleHROYW1lKTtcblxuICBjb25zdCB7XG4gICAgbG9jYXRpb25zOiBwYXJlbnRMb2NhdGlvbnMsXG4gIH0gPSB1c2VNZW1vKCgpID0+IHBhcmVudENvbnRleHQsIFtwYXJlbnRDb250ZXh0XSk7XG5cbiAgY29uc3QgZmFjZXRQYXJhbXNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVN0YWJsZUhhc2goZmFjZXRQYXJhbXMpLCBbZmFjZXRQYXJhbXNdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChmYWNldCAmJiBmYWNldFBhcmFtcyAmJiBwYXJlbnRMb2NhdGlvbnMgJiYgYWRhcHRlckNvbnRleHRJbnN0YW5jZSkge1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGFwdGVyQ29udGV4dEluc3RhbmNlLmFsbEZhY2V0KGZhY2V0LCBmYWNldFBhcmFtcywgcGFyZW50TG9jYXRpb25zKTtcbiAgICAgICAgICBzZXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIEhhbmRsZSBmYWNldCBlcnJvcnMgZ3JhY2VmdWxseVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtAZmplbGwvcHJvdmlkZXJzXSBbQ0l0ZW1zRmFjZXRdIEZhaWxlZCB0byBleGVjdXRlIGZhY2V0IFwiJHtmYWNldH1cIiB3aXRoIHBhcmFtc2AsIGZhY2V0UGFyYW1zLCAnOicsIGVycm9yKTtcbiAgICAgICAgICBzZXRSZXN1bHQobnVsbCk7XG4gICAgICAgICAgLy8gS2VlcCBsb2FkaW5nIHN0YXRlIGFzIHRydWUgd2hlbiB0aGVyZSdzIGFuIGVycm9yIC0gdGhlIG9wZXJhdGlvbiBpcyBpbmNvbXBsZXRlXG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9LCBbZmFjZXQsIGZhY2V0UGFyYW1zU3RyaW5nLCBwYXJlbnRMb2NhdGlvbnNdKTtcblxuICAvLyBJZiB3ZSBoYXZlIGFuIGV4aXN0aW5nIGNvbnRleHQsIGVuaGFuY2UgaXQgYnkgYWRkaW5nIG91ciBmYWNldCByZXN1bHRzXG4gIGlmIChleGlzdGluZ0NvbnRleHQpIHtcbiAgICBjb25zdCBlbmhhbmNlZEZhY2V0UmVzdWx0cyA9IHsgLi4uZXhpc3RpbmdDb250ZXh0LmZhY2V0UmVzdWx0cyB9O1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmICghZW5oYW5jZWRGYWNldFJlc3VsdHNbZmFjZXRdKSB7XG4gICAgICAgIGVuaGFuY2VkRmFjZXRSZXN1bHRzW2ZhY2V0XSA9IHt9O1xuICAgICAgfVxuICAgICAgZW5oYW5jZWRGYWNldFJlc3VsdHNbZmFjZXRdID0ge1xuICAgICAgICAuLi5lbmhhbmNlZEZhY2V0UmVzdWx0c1tmYWNldF0sXG4gICAgICAgIFtmYWNldFBhcmFtc1N0cmluZ106IHJlc3VsdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgZW5oYW5jZWQgY29udGV4dCB2YWx1ZVxuICAgIGNvbnN0IGVuaGFuY2VkQ29udGV4dFZhbHVlOiBDSXRlbXMuQ29udGV4dFR5cGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiA9IHtcbiAgICAgIC4uLmV4aXN0aW5nQ29udGV4dCxcbiAgICAgIGZhY2V0UmVzdWx0czogZW5oYW5jZWRGYWNldFJlc3VsdHMsXG4gICAgfTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgaXRlbXNDb250ZXh0LlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogZW5oYW5jZWRDb250ZXh0VmFsdWUsXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9XG5cbiAgLy8gTm8gZXhpc3RpbmcgY29udGV4dCwgY3JlYXRlIGEgbmV3IHByb3ZpZGVyXG4gIGNvbnN0IGluaXRpYWxGYWNldFJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIGFueT4+ID0ge307XG4gIGlmIChyZXN1bHQpIHtcbiAgICBpbml0aWFsRmFjZXRSZXN1bHRzW2ZhY2V0XSA9IHsgW2ZhY2V0UGFyYW1zU3RyaW5nXTogcmVzdWx0IH07XG4gIH1cblxuICByZXR1cm4gQ0l0ZW1zUHJvdmlkZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pih7XG4gICAgbmFtZSxcbiAgICBhZGFwdGVyLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHQ6IGl0ZW1zQ29udGV4dCxcbiAgICBjb250ZXh0TmFtZTogY29udGV4dE5hbWUsXG4gICAgcmVuZGVyRWFjaCxcbiAgICBmYWNldFJlc3VsdHM6IGluaXRpYWxGYWNldFJlc3VsdHMsXG4gICAgaXNMb2FkaW5nUGFyYW06IGlzTG9hZGluZyxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50Q29udGV4dE5hbWUsXG4gIH0pO1xufVxuIiwiaW1wb3J0ICogYXMgQUl0ZW0gZnJvbSBcIi4uL0FJdGVtXCI7XG5pbXBvcnQgeyBhYmJyZXZJSywgYWJicmV2TEtBLCBDb21LZXksIEl0ZW0sIExvY0tleUFycmF5LCBQcmlLZXkgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVFbGVtZW50LCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDSXRlbUFkYXB0ZXIgfSBmcm9tIFwiLi9DSXRlbUFkYXB0ZXJcIjtcblxuaW1wb3J0IExpYkxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyXCI7XG5pbXBvcnQgKiBhcyBDSXRlbUFkYXB0ZXIgZnJvbSBcIi4vQ0l0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBDSXRlbXMgZnJvbSBcIi4vQ0l0ZW1zXCI7XG5cbmNvbnN0IGxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ0NJdGVtc1Byb3ZpZGVyJyk7XG5cbmV4cG9ydCBjb25zdCBDSXRlbXNQcm92aWRlciA9IDxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgICB7XG4gICAgICBuYW1lLFxuICAgICAgYWRhcHRlcixcbiAgICAgIGNoaWxkcmVuID0gKDw+PC8+KSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjb250ZXh0TmFtZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudENvbnRleHROYW1lLFxuICAgICAgcmVuZGVyRWFjaCxcbiAgICAgIGl0ZW1zID0gW10sXG4gICAgICBmYWNldFJlc3VsdHMgPSB7fSxcbiAgICAgIGlzTG9hZGluZ1BhcmFtID0gZmFsc2UsXG4gICAgICBvdmVycmlkZXMsXG4gICAgfToge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBhZGFwdGVyOiBDSXRlbUFkYXB0ZXIuQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIC8vIFRPRE86IE9rLCBsZXQncyBhZGQgYSBmdW5jdGlvbiBjYWxsZWQgXCJBZGQgUXVlcmllc1wiIHRoYXQgd2lsbCBhbGxvdyB1cyB0byBydW4gYSBxdWVyeSB0aGF0IHJldHVybnNcbiAgICAvLyBjb3VudHMsIGJvb2xlYW5zLCBvciBkYXRhXG4gICAgYWRkUXVlcmllcz86IChcbiAgICAgIGFkYXB0ZXI6IENJdGVtQWRhcHRlci5Db250ZXh0VHlwZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgICAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICAgICAgcGFyZW50SXRlbTogSXRlbTxMMSwgTDIsIEwzLCBMNCwgTDUsIG5ldmVyPlxuICAgICkgPT5cbiAgICAgIFJlY29yZDxzdHJpbmcsICguLi5wYXJhbXM6IGFueSkgPT4gUHJvbWlzZTxzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyIHwgbnVsbD4+O1xuICAgIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNvbnRleHQ6IENJdGVtcy5Db250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgY29udGV4dE5hbWU6IHN0cmluZztcbiAgICBwYXJlbnQ6IEFJdGVtLkNvbnRleHQ8SXRlbTxMMSwgTDIsIEwzLCBMNCwgTDUsIG5ldmVyPiwgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBwYXJlbnRDb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIHJlbmRlckVhY2g/OiAoaXRlbTogVikgPT4gUmVhY3QuUmVhY3ROb2RlO1xuICAgIGl0ZW1zPzogVltdIHwgbnVsbDtcbiAgICBmYWNldFJlc3VsdHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIGlzTG9hZGluZ1BhcmFtPzogYm9vbGVhbjtcbiAgICBvdmVycmlkZXM/OiB7XG4gICAgICBhbGw/OiAoKSA9PiBQcm9taXNlPFZbXSB8IG51bGw+O1xuICAgICAgb25lPzogKCkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG4gICAgfTtcbiAgfVxuICApID0+IHtcblxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7XG4gIGNvbnN0IFtpc0NyZWF0aW5nLCBzZXRJc0NyZWF0aW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2lzVXBkYXRpbmcsIHNldElzVXBkYXRpbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbaXNSZW1vdmluZywgc2V0SXNSZW1vdmluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG5cbiAgLy8gU2luY2Ugd2UgcGFzcyB0aGlzIHRvIHRoZSBhY3Rpb25zIGNvbnN0cnVjdG9yLCBkb24ndCBkZXN0cnVjdHVyZSBpdCB5ZXRcbiAgY29uc3QgYWRhcHRlckNvbnRleHQgPSB1c2VDSXRlbUFkYXB0ZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PihhZGFwdGVyLCBjb250ZXh0TmFtZSk7XG5cbiAgLy8gRGVzdHJ1Y3R1cmUgdGhlIHZhbHVlcyB3ZSBuZWVkIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gIGNvbnN0IHtcbiAgICBwa1R5cGVzLFxuICAgIGFsbDogYWxsSXRlbXMsXG4gICAgb25lOiBvbmVJdGVtLFxuICAgIGNyZWF0ZTogY3JlYXRlSXRlbSxcbiAgICB1cGRhdGU6IHVwZGF0ZUl0ZW0sXG4gICAgcmVtb3ZlOiByZW1vdmVJdGVtLFxuICAgIGFsbEFjdGlvbjogYWxsQWN0aW9uSXRlbSxcbiAgICBhbGxGYWNldDogYWxsRmFjZXRJdGVtLFxuICAgIGFjdGlvbjogYWN0aW9uSXRlbSxcbiAgICBmYWNldDogZmFjZXRJdGVtLFxuICAgIHNldDogc2V0SXRlbSxcbiAgICBmaW5kOiBmaW5kSXRlbSxcbiAgICBmaW5kT25lOiBmaW5kT25lSXRlbSxcbiAgICBhZGRBbGxBY3Rpb25zLFxuICAgIGFkZEFsbEZhY2V0cyxcbiAgfSA9IGFkYXB0ZXJDb250ZXh0O1xuXG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBBSXRlbS51c2VBSXRlbTxJdGVtPEwxLCBMMiwgTDMsIEw0LCBMNT4sIEwxLCBMMiwgTDMsIEw0LCBMNT4ocGFyZW50LCBwYXJlbnRDb250ZXh0TmFtZSk7XG5cbiAgY29uc3QgcGFyZW50TG9jYXRpb25zID0gcGFyZW50Q29udGV4dC5sb2NhdGlvbnM7XG4gIGNvbnN0IHBhcmVudEl0ZW0gPSBwYXJlbnRDb250ZXh0Lml0ZW07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcoaXNMb2FkaW5nUGFyYW0pO1xuICB9LCBbaXNMb2FkaW5nUGFyYW1dKTtcblxuICBjb25zdCBjcmVhdGUgPSB1c2VDYWxsYmFjayhhc3luYyAoaXRlbTogUGFydGlhbDxJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4+KSA9PiB7XG4gICAgaWYgKHBhcmVudExvY2F0aW9ucykge1xuICAgICAgbG9nZ2VyLmRlYnVnKGAke25hbWV9OiBjcmVhdGVgLCB7IGl0ZW0sIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgc2V0SXNDcmVhdGluZyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZUl0ZW0oaXRlbSwgcGFyZW50TG9jYXRpb25zKSBhcyBWO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBFcnJvciBjcmVhdGluZyBpdGVtYCwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzQ3JlYXRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IE5vIHBhcmVudCBsb2NhdGlvbnMgcHJlc2VudCB0byBjcmVhdGUgY29udGFpbmVkaXRlbWAsIHsgaXRlbSB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcGFyZW50IGxvY2F0aW9ucyBwcmVzZW50IHRvIGNyZWF0ZSBjb250YWluZWRpdGVtIGluICR7bmFtZX1gKTtcbiAgICB9XG4gIH0sIFtjcmVhdGVJdGVtLCBwYXJlbnRMb2NhdGlvbnNdKTtcblxuICBjb25zdCB1cGRhdGUgPSB1c2VDYWxsYmFjayhhc3luYyAoa2V5OiBDb21LZXk8UywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IFByaUtleTxTPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1Pj4pID0+IHtcbiAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IHVwZGF0ZWAsIHsga2V5OiBhYmJyZXZJSyhrZXkpLCBpdGVtIH0pO1xuICAgIHNldElzVXBkYXRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZUl0ZW0oa2V5LCBpdGVtKSBhcyBWO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBFcnJvciB1cGRhdGluZyBpdGVtYCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3VwZGF0ZUl0ZW0sIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIGNvbnN0IHJlbW92ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKGAke25hbWV9OiByZW1vdmVgLCB7IGtleTogYWJicmV2SUsoa2V5KSB9KTtcbiAgICBzZXRJc1JlbW92aW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZW1vdmVJdGVtKGtleSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IEVycm9yIHJlbW92aW5nIGl0ZW1gLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNSZW1vdmluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbcmVtb3ZlSXRlbSwgcGFyZW50TG9jYXRpb25zXSk7XG5cbiAgY29uc3QgYWxsID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmIChwYXJlbnRMb2NhdGlvbnMpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogYWxsYCwgeyBxdWVyeToge30sIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWxsSXRlbXMoe30sIHBhcmVudExvY2F0aW9ucykgYXMgVltdIHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgZ2V0dGluZyBhbGwgaXRlbXNgLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGFsbCBjb250YWluZWRpdGVtc2ApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGFsbCBjb250YWluZWRpdGVtcyBpbiAke25hbWV9YCk7XG4gICAgfVxuICB9LCBbYWxsSXRlbXMsIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIGNvbnN0IG9uZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAocGFyZW50TG9jYXRpb25zKSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ29uZScsIHsgcXVlcnk6IHt9LCBwYXJlbnRMb2NhdGlvbnM6IGFiYnJldkxLQShwYXJlbnRMb2NhdGlvbnMgYXMgYW55KSB9KTtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9uZUl0ZW0oe30sIHBhcmVudExvY2F0aW9ucykgYXMgViB8IG51bGw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IEVycm9yIGdldHRpbmcgb25lIGl0ZW1gLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIG9uZSBjb250YWluZWRpdGVtYCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHBhcmVudCBsb2NhdGlvbnMgcHJlc2VudCB0byBxdWVyeSBmb3Igb25lIGNvbnRhaW5lZGl0ZW0gaW4gJHtuYW1lfWApO1xuICAgIH1cbiAgfSwgW29uZUl0ZW0sIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIGNvbnN0IGFsbEFjdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChhY3Rpb246IHN0cmluZywgYm9keTogYW55ID0ge30pID0+IHtcbiAgICBpZiAocGFyZW50TG9jYXRpb25zKSB7XG4gICAgICBsb2dnZXIuaW5mbygnYWxsQWN0aW9uJywgeyBhY3Rpb24sIGJvZHksIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgc2V0SXNVcGRhdGluZyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFsbEFjdGlvbkl0ZW0oYWN0aW9uLCBib2R5LCBwYXJlbnRMb2NhdGlvbnMpIGFzIFZbXSB8IG51bGw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IEVycm9yIGluIGFsbEFjdGlvbmAsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1VwZGF0aW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGFsbEFjdGlvbiBjb250YWluZWRpdGVtc2AsXG4gICAgICAgIHsgYWN0aW9uLCBib2R5IH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGFsbEFjdGlvbiBjb250YWluZWRpdGVtcyBpbiAke25hbWV9YCk7XG4gICAgfVxuICB9LCBbYWxsQWN0aW9uSXRlbSwgcGFyZW50TG9jYXRpb25zXSk7XG5cbiAgY29uc3QgYWxsRmFjZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoZmFjZXQ6IHN0cmluZywgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSkgPT4ge1xuICAgIGlmIChwYXJlbnRMb2NhdGlvbnMpIHtcbiAgICAgIGxvZ2dlci5pbmZvKCdhbGxGYWNldCcsIHsgZmFjZXQsIHBhcmFtcywgcGFyZW50TG9jYXRpb25zOiBhYmJyZXZMS0EocGFyZW50TG9jYXRpb25zIGFzIGFueSkgfSk7XG4gICAgICBzZXRJc1VwZGF0aW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWxsRmFjZXRJdGVtKGZhY2V0LCBwYXJhbXMsIHBhcmVudExvY2F0aW9ucykgYXMgYW55O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNVcGRhdGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGAke25hbWV9OiBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGFsbEZhY2V0IGNvbnRhaW5lZGl0ZW1zYDtcbiAgICBsb2dnZXIuZXJyb3IoZXJyb3JNZXNzYWdlLCB7IGZhY2V0LCBwYXJhbXMgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH0sIFthbGxGYWNldEl0ZW0sIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIGNvbnN0IGFjdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChcbiAgICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgICBhY3Rpb246IHN0cmluZyxcbiAgICAgIGJvZHk6IGFueSA9IHt9LFxuICAgICk6IFByb21pc2U8Vj4gPT4ge1xuICAgICAgaWYgKHBhcmVudExvY2F0aW9ucykge1xuICAgICAgICBsb2dnZXIuaW5mbygnYWN0aW9uJywgeyBrZXksIGFjdGlvbiwgYm9keSwgcGFyZW50TG9jYXRpb25zOiBhYmJyZXZMS0EocGFyZW50TG9jYXRpb25zIGFzIGFueSkgfSk7XG4gICAgICAgIHNldElzVXBkYXRpbmcodHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uSXRlbShrZXksIGFjdGlvbiwgYm9keSwgcGFyZW50TG9jYXRpb25zKSBhcyBWO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNVcGRhdGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcGFyZW50IGxvY2F0aW9ucyBwcmVzZW50IHRvIHF1ZXJ5IGZvciBhY3Rpb24gJHthY3Rpb259IGluICR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9LCBbYWN0aW9uSXRlbSwgcGFyZW50TG9jYXRpb25zXSk7XG5cbiAgY29uc3QgZmFjZXQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoXG4gICAgICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+LFxuICAgICAgZmFjZXQ6IHN0cmluZyxcbiAgICAgIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+ID0ge30sXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIGlmIChwYXJlbnRMb2NhdGlvbnMpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oJ2ZhY2V0JywgeyBrZXksIGZhY2V0LCBwYXJhbXMsIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgICBzZXRJc1VwZGF0aW5nKHRydWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZhY2V0SXRlbShrZXksIGZhY2V0LCBwYXJhbXMsIHBhcmVudExvY2F0aW9ucykgYXMgYW55O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNVcGRhdGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGAke25hbWV9OiBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGZhY2V0ICR7ZmFjZXR9YDtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSwgeyBrZXksIGZhY2V0LCBwYXJhbXMgfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIFtmYWNldEl0ZW0sIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIGNvbnN0IGZpbmRPbmUgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoXG4gICAgICBmaW5kZXI6IHN0cmluZyxcbiAgICAgIGZpbmRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgICk6IFByb21pc2U8ViB8IG51bGw+ID0+IHtcbiAgICAgIGlmIChwYXJlbnRMb2NhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRPbmVJdGVtKGZpbmRlciwgZmluZGVyUGFyYW1zLCBwYXJlbnRMb2NhdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGZpbmRPbmUgY29udGFpbmVkaXRlbSBpbiAke25hbWV9YCk7XG4gICAgICB9XG4gICAgfSwgW2ZpbmRPbmVJdGVtLCBwYXJlbnRMb2NhdGlvbnNdKTtcblxuICBjb25zdCBmaW5kID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICApID0+IHtcbiAgICBpZiAocGFyZW50TG9jYXRpb25zKSB7XG4gICAgICByZXR1cm4gZmluZEl0ZW0oZmluZGVyLCBmaW5kZXJQYXJhbXMsIHBhcmVudExvY2F0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogTm8gcGFyZW50IGxvY2F0aW9ucyBwcmVzZW50IHRvIHF1ZXJ5IGZvciBmaW5kIGNvbnRhaW5lZGl0ZW1zYCwgeyBmaW5kZXIsIGZpbmRlclBhcmFtcyB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcGFyZW50IGxvY2F0aW9ucyBwcmVzZW50IHRvIHF1ZXJ5IGZvciBmaW5kIGNvbnRhaW5lZGl0ZW1zIGluICR7bmFtZX1gKTtcbiAgICB9XG4gIH0sIFtmaW5kSXRlbSwgcGFyZW50TG9jYXRpb25zXSk7XG5cbiAgY29uc3Qgc2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4sXG4gICAgaXRlbTogVixcbiAgKSA9PiB7XG4gICAgcmV0dXJuIHNldEl0ZW0oa2V5LCBpdGVtKTtcbiAgfSwgW3NldEl0ZW0sIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZTogQ0l0ZW1zLkNvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gPSB7XG4gICAgbmFtZSxcbiAgICBpdGVtczogaXRlbXMgfHwgW10sXG4gICAgZmFjZXRSZXN1bHRzOiBmYWNldFJlc3VsdHMgfHwge30sXG4gICAgcGFyZW50SXRlbTogcGFyZW50SXRlbSBhcyBJdGVtPEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBudWxsLFxuICAgIGlzTG9hZGluZyxcbiAgICBpc0NyZWF0aW5nLFxuICAgIGlzVXBkYXRpbmcsXG4gICAgaXNSZW1vdmluZyxcbiAgICBwa1R5cGVzLFxuICAgIGxvY2F0aW9uczogcGFyZW50TG9jYXRpb25zIGFzIGFueSxcbiAgICBjcmVhdGUsXG4gICAgdXBkYXRlLFxuICAgIHJlbW92ZSxcbiAgICBhbGw6IG92ZXJyaWRlcz8uYWxsIHx8IGFsbCxcbiAgICBvbmU6IG92ZXJyaWRlcz8ub25lIHx8IG9uZSxcbiAgICBhbGxBY3Rpb24sXG4gICAgYWxsRmFjZXQsXG4gICAgYWN0aW9uLFxuICAgIGZhY2V0LFxuICAgIGZpbmQsXG4gICAgZmluZE9uZSxcbiAgICBzZXQsXG4gIH07XG5cbiAgY29udGV4dFZhbHVlLmFsbEFjdGlvbnMgPSB1c2VNZW1vKCgpID0+IGFkZEFsbEFjdGlvbnMgJiYgYWRkQWxsQWN0aW9ucyhjb250ZXh0VmFsdWUuYWxsQWN0aW9uKSwgW2FkZEFsbEFjdGlvbnMsIGNvbnRleHRWYWx1ZS5hbGxBY3Rpb25dKTtcbiAgY29udGV4dFZhbHVlLmFsbEZhY2V0cyA9IHVzZU1lbW8oKCkgPT4gYWRkQWxsRmFjZXRzICYmIGFkZEFsbEZhY2V0cyhjb250ZXh0VmFsdWUuYWxsRmFjZXQpLCBbYWRkQWxsRmFjZXRzLCBjb250ZXh0VmFsdWUuYWxsRmFjZXRdKTtcblxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICBjb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWUgYXMgQ0l0ZW1zLkNvbnRleHRUeXBlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gICAgfSxcbiAgICAoXG4gICAgICA8PlxuICAgICAgICB7cmVuZGVyRWFjaCAmJiBpdGVtcyAmJiBpdGVtcy5tYXAoKGl0ZW0pID0+IHJlbmRlckVhY2goaXRlbSkpfVxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8Lz5cbiAgICApXG4gICk7XG59XG4iLCJpbXBvcnQgeyBJdGVtLCBJdGVtUXVlcnkgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIEFJdGVtIGZyb20gXCIuLi9BSXRlbVwiO1xuaW1wb3J0IHsgdXNlQ0l0ZW1BZGFwdGVyIH0gZnJvbSBcIi4vQ0l0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVTdGFibGVIYXNoIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgKiBhcyBDSXRlbUFkYXB0ZXIgZnJvbSBcIi4vQ0l0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBDSXRlbXMgZnJvbSBcIi4vQ0l0ZW1zXCI7XG5pbXBvcnQgeyBDSXRlbXNQcm92aWRlciB9IGZyb20gXCIuL0NJdGVtc1Byb3ZpZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBDSXRlbXNGaW5kID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIHtcbiAgICAgIG5hbWUsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY2hpbGRyZW4gPSAoPD48Lz4pLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNvbnRleHROYW1lLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50Q29udGV4dE5hbWUsXG4gICAgICByZW5kZXJFYWNoLFxuICAgICAgZmluZGVyLFxuICAgICAgZmluZGVyUGFyYW1zID0ge30sXG4gICAgfToge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBhZGFwdGVyOiBDSXRlbUFkYXB0ZXIuQ29udGV4dDxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNvbnRleHQ6IENJdGVtcy5Db250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgY29udGV4dE5hbWU6IHN0cmluZztcbiAgICBxdWVyeT86IEl0ZW1RdWVyeTtcbiAgICBwYXJlbnQ6IEFJdGVtLkNvbnRleHQ8SXRlbTxMMSwgTDIsIEwzLCBMNCwgTDUsIG5ldmVyPiwgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBwYXJlbnRDb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIHJlbmRlckVhY2g/OiAoaXRlbTogVikgPT4gUmVhY3QuUmVhY3ROb2RlO1xuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgfVxuICApID0+IHtcblxuICBjb25zdCBbaXRlbXMsIHNldEl0ZW1zXSA9IFJlYWN0LnVzZVN0YXRlPFZbXSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7XG4gIC8vIFNpbmNlIHdlIHBhc3MgdGhpcyB0byB0aGUgYWN0aW9ucyBjb25zdHJ1Y3RvciwgZG9uJ3QgZGVzdHJ1Y3R1cmUgaXQgeWV0XG4gIGNvbnN0IGFkYXB0ZXJDb250ZXh0ID0gdXNlQ0l0ZW1BZGFwdGVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oYWRhcHRlciwgY29udGV4dE5hbWUpO1xuXG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBBSXRlbS51c2VBSXRlbTxJdGVtPEwxLCBMMiwgTDMsIEw0LCBMNT4sIEwxLCBMMiwgTDMsIEw0LCBMNT4ocGFyZW50LCBwYXJlbnRDb250ZXh0TmFtZSk7XG5cbiAgY29uc3Qge1xuICAgIGxvY2F0aW9uczogcGFyZW50TG9jYXRpb25zLFxuICB9ID0gdXNlTWVtbygoKSA9PiBwYXJlbnRDb250ZXh0LCBbcGFyZW50Q29udGV4dF0pO1xuXG4gIGNvbnN0IGZpbmRlclBhcmFtc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RhYmxlSGFzaChmaW5kZXJQYXJhbXMpLCBbZmluZGVyUGFyYW1zXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZmluZGVyICYmIGZpbmRlclBhcmFtcyAmJiBwYXJlbnRMb2NhdGlvbnMgJiYgYWRhcHRlckNvbnRleHQpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRhcHRlckNvbnRleHQuZmluZChmaW5kZXIsIGZpbmRlclBhcmFtcywgcGFyZW50TG9jYXRpb25zKTtcbiAgICAgICAgICBzZXRJdGVtcyhyZXN1bHQgYXMgVltdIHwgbnVsbCk7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGaW5kIG9wZXJhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgIHNldEl0ZW1zKG51bGwpO1xuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9LCBbZmluZGVyLCBmaW5kZXJQYXJhbXNTdHJpbmcsIHBhcmVudExvY2F0aW9uc10pO1xuXG4gIHJldHVybiBDSXRlbXNQcm92aWRlcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+KHtcbiAgICBuYW1lLFxuICAgIGFkYXB0ZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjb250ZXh0TmFtZSxcbiAgICByZW5kZXJFYWNoLFxuICAgIGl0ZW1zLFxuICAgIGlzTG9hZGluZ1BhcmFtOiBpc0xvYWRpbmcsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudENvbnRleHROYW1lLFxuICB9KTtcbn1cbiIsIlxuaW1wb3J0IHsgYWJicmV2TEtBLCBhYmJyZXZRdWVyeSwgSXRlbSwgSXRlbVF1ZXJ5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNJdGVtQWRhcHRlciB9IGZyb20gXCIuL0NJdGVtQWRhcHRlclwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVN0YWJsZUhhc2ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBSXRlbSBmcm9tIFwiLi4vQUl0ZW1cIjtcbmltcG9ydCAqIGFzIENJdGVtQWRhcHRlciBmcm9tIFwiLi9DSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIENJdGVtcyBmcm9tIFwiLi9DSXRlbXNcIjtcbmltcG9ydCB7IENJdGVtc1Byb3ZpZGVyIH0gZnJvbSBcIi4vQ0l0ZW1zUHJvdmlkZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnQ0l0ZW1zUXVlcnknKTtcblxuZXhwb3J0IGNvbnN0IENJdGVtc1F1ZXJ5ID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICAgIHtcbiAgICAgIG5hbWUsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY2hpbGRyZW4gPSAoPD48Lz4pLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNvbnRleHROYW1lLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50Q29udGV4dE5hbWUsXG4gICAgICBxdWVyeSA9IHt9LFxuICAgICAgcmVuZGVyRWFjaCxcbiAgICB9OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGFkYXB0ZXI6IENJdGVtQWRhcHRlci5Db250ZXh0PFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gICAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgY29udGV4dDogQ0l0ZW1zLkNvbnRleHQ8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PjtcbiAgICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5O1xuICAgIHBhcmVudDogQUl0ZW0uQ29udGV4dDxJdGVtPEwxLCBMMiwgTDMsIEw0LCBMNSwgbmV2ZXI+LCBMMSwgTDIsIEwzLCBMNCwgTDU+O1xuICAgIHBhcmVudENvbnRleHROYW1lOiBzdHJpbmc7XG4gICAgcmVuZGVyRWFjaD86IChpdGVtOiBWKSA9PiBSZWFjdC5SZWFjdE5vZGU7XG4gIH1cbiAgKSA9PiB7XG5cbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuXG4gIC8vIFNpbmNlIHdlIHBhc3MgdGhpcyB0byB0aGUgYWN0aW9ucyBjb25zdHJ1Y3RvciwgZG9uJ3QgZGVzdHJ1Y3R1cmUgaXQgeWV0XG4gIGNvbnN0IGFkYXB0ZXJDb250ZXh0ID0gdXNlQ0l0ZW1BZGFwdGVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oYWRhcHRlciwgY29udGV4dE5hbWUpO1xuXG4gIC8vIERlc3RydWN0dXJlIHRoZSB2YWx1ZXMgd2UgbmVlZCB0byBkZWZpbmUgZnVuY3Rpb25zLlxuICBjb25zdCB7XG4gICAgYWxsOiBhbGxJdGVtcyxcbiAgICBvbmU6IG9uZUl0ZW0sXG4gIH0gPSB1c2VNZW1vKCgpID0+IGFkYXB0ZXJDb250ZXh0LCBbYWRhcHRlckNvbnRleHRdKTtcblxuICBjb25zdCBwYXJlbnRDb250ZXh0ID0gQUl0ZW0udXNlQUl0ZW08SXRlbTxMMSwgTDIsIEwzLCBMNCwgTDU+LCBMMSwgTDIsIEwzLCBMNCwgTDU+KHBhcmVudCwgcGFyZW50Q29udGV4dE5hbWUpO1xuXG4gIGNvbnN0IHtcbiAgICBuYW1lOiBwYXJlbnROYW1lLFxuICAgIGxvY2F0aW9uczogcGFyZW50TG9jYXRpb25zLFxuICAgIGl0ZW06IHBhcmVudEl0ZW0sXG4gIH0gPSB1c2VNZW1vKCgpID0+IHBhcmVudENvbnRleHQsIFtwYXJlbnRDb250ZXh0XSk7XG5cbiAgY29uc3QgcXVlcnlTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVN0YWJsZUhhc2gocXVlcnkpLCBbcXVlcnldKTtcblxuICBjb25zdCBhbGwgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKHBhcmVudExvY2F0aW9ucykge1xuICAgICAgbG9nZ2VyLmRlYnVnKGAke25hbWV9OiBhbGxgLCB7IHF1ZXJ5OiBhYmJyZXZRdWVyeShxdWVyeSksIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWxsSXRlbXMocXVlcnksIHBhcmVudExvY2F0aW9ucykgYXMgVltdIHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgZ2V0dGluZyBhbGwgaXRlbXNgLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlZmF1bHQoYCR7bmFtZX06IE5vIHBhcmVudCBsb2NhdGlvbnMgcHJlc2VudCB0byBxdWVyeSBmb3IgYWxsIGNvbnRhaW5lZGl0ZW1zYCxcbiAgICAgICAgeyBxdWVyeTogYWJicmV2UXVlcnkocXVlcnkpIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBwYXJlbnQgbG9jYXRpb25zIHByZXNlbnQgdG8gcXVlcnkgZm9yIGFsbCBjb250YWluZWRpdGVtcyBpbiAke25hbWV9YCk7XG4gICAgfVxuICB9LCBbYWxsSXRlbXMsIHBhcmVudExvY2F0aW9ucywgcXVlcnlTdHJpbmddKTtcblxuICBjb25zdCBvbmUgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKHBhcmVudExvY2F0aW9ucykge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdvbmUnLCB7IHF1ZXJ5OiBhYmJyZXZRdWVyeShxdWVyeSksIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb25lSXRlbShxdWVyeSwgcGFyZW50TG9jYXRpb25zKSBhcyBWIHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgZ2V0dGluZyBvbmUgaXRlbWAsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVmYXVsdChgJHtuYW1lfTogTm8gcGFyZW50IGxvY2F0aW9ucyBwcmVzZW50IHRvIHF1ZXJ5IGZvciBvbmUgY29udGFpbmVkaXRlbWAsXG4gICAgICAgIHsgcXVlcnk6IGFiYnJldlF1ZXJ5KHF1ZXJ5KSB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcGFyZW50IGxvY2F0aW9ucyBwcmVzZW50IHRvIHF1ZXJ5IGZvciBvbmUgY29udGFpbmVkaXRlbSBpbiAke25hbWV9YCk7XG4gICAgfVxuICB9LCBbb25lSXRlbSwgcGFyZW50TG9jYXRpb25zLCBxdWVyeVN0cmluZ10pO1xuXG4gIGNvbnN0IFtpdGVtcywgc2V0SXRlbXNdID0gdXNlU3RhdGU8VltdIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gTG9hZCBpdGVtcyB3aGVuIHF1ZXJ5IG9yIHBhcmVudCBjb250ZXh0IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3VzZUVmZmVjdFtxdWVyeVN0cmluZywgcGFyZW50TG9jYXRpb25zLCBwYXJlbnROYW1lLCBpdGVtXScsXG4gICAgICB7IHF1ZXJ5U3RyaW5nLCBwYXJlbnRMb2NhdGlvbnM6IGFiYnJldkxLQShwYXJlbnRMb2NhdGlvbnMgYXMgYW55KSwgcGFyZW50TmFtZSwgcGFyZW50SXRlbSB9KTtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhcmVudExvY2F0aW9ucykge1xuICAgICAgICAgIGxvZ2dlci50cmFjZSgndXNlRWZmZWN0W3F1ZXJ5U3RyaW5nXScsXG4gICAgICAgICAgICB7IHF1ZXJ5OiBhYmJyZXZRdWVyeShxdWVyeSksIHBhcmVudExvY2F0aW9uczogYWJicmV2TEtBKHBhcmVudExvY2F0aW9ucyBhcyBhbnkpIH0pO1xuICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgYWxsSXRlbXMocXVlcnksIHBhcmVudExvY2F0aW9ucyk7XG4gICAgICAgICAgc2V0SXRlbXMocmVzdWx0cyBhcyBWW10gfCBudWxsKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuaW5nKGAke25hbWV9OiB1c2VFZmZlY3RbcXVlcnlTdHJpbmcsIHBhcmVudExvY2F0aW9uc10gd2l0aG91dCBwYXJlbnQgbG9jYXRpb25zYCxcbiAgICAgICAgICAgIHsgcXVlcnk6IGFiYnJldlF1ZXJ5KHF1ZXJ5KSB9KTtcbiAgICAgICAgICBzZXRJdGVtcyhudWxsKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IEVycm9yIGluIHVzZUVmZmVjdGAsIGVycm9yKTtcbiAgICAgICAgc2V0SXRlbXMobnVsbCk7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIC8vIERvbid0IHRocm93IGhlcmUgYXMgdGhpcyB3b3VsZCBiZSBsb3N0IGluIHRoZSBhc3luYyBjb250ZXh0XG4gICAgICAgIC8vIExldCB0aGUgYWxsL29uZSBvdmVycmlkZSBmdW5jdGlvbnMgaGFuZGxlIGVycm9yIHRocm93aW5nXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSwgW3F1ZXJ5U3RyaW5nLCBwYXJlbnRMb2NhdGlvbnMsIHBhcmVudE5hbWUsIHBhcmVudEl0ZW0sIGFsbEl0ZW1zLCBuYW1lXSk7XG5cbiAgcmV0dXJuIENJdGVtc1Byb3ZpZGVyPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4oe1xuICAgIG5hbWUsXG4gICAgYWRhcHRlcixcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHROYW1lLFxuICAgIHJlbmRlckVhY2gsXG4gICAgaXRlbXMsXG4gICAgaXNMb2FkaW5nUGFyYW06IGlzTG9hZGluZyxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50Q29udGV4dE5hbWUsXG4gICAgb3ZlcnJpZGVzOiB7XG4gICAgICBhbGw6IGFsbCxcbiAgICAgIG9uZTogb25lLFxuICAgIH0sXG4gIH0pO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBGYWNldFBhcmFtcyB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBjcmVhdGVTdGFibGVIYXNoIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IExvY0tleUFycmF5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5cbmV4cG9ydCB0eXBlIEZhY2V0TWV0aG9kPFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gKFxuICBmYWNldDogc3RyaW5nLFxuICBwYXJhbXM/OiBGYWNldFBhcmFtcyxcbiAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuKSA9PiBQcm9taXNlPGFueSB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBBZGRlZEZhY2V0TWV0aG9kPFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+ID0gKHBhcmFtcz86IEZhY2V0UGFyYW1zLCBsb2NhdGlvbnM/OiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+KSA9PiBQcm9taXNlPGFueSB8IG51bGw+O1xuXG5leHBvcnQgdHlwZSBBbGxGYWNldE1ldGhvZDxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuICA+ID0gKFxuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgcGFyYW1zPzogRmFjZXRQYXJhbXMsXG4gICAgbG9jYXRpb25zPzogTG9jS2V5QXJyYXk8TDEsIEwyLCBMMywgTDQsIEw1PlxuICApID0+IFByb21pc2U8YW55IHwgbnVsbD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGV4dFR5cGU8XG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4ge1xuICBmYWNldHM/OiBSZWNvcmQ8c3RyaW5nLCBBZGRlZEZhY2V0TWV0aG9kPEwxLCBMMiwgTDMsIEw0LCBMNT4+O1xuICBmYWNldDogRmFjZXRNZXRob2Q8TDEsIEwyLCBMMywgTDQsIEw1PiB8IEFsbEZhY2V0TWV0aG9kPEwxLCBMMiwgTDMsIEw0LCBMNT47XG4gIGZhY2V0UmVzdWx0czogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgYW55Pj47XG59XG5cbmV4cG9ydCB0eXBlIENvbnRleHQgPSBSZWFjdC5Db250ZXh0PENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGNvbnN0IHVzZUZhY2V0UmVzdWx0ID0gKFxuICBjb250ZXh0OiBDb250ZXh0LFxuICBjb250ZXh0TmFtZTogc3RyaW5nLFxuICBmYWNldDogc3RyaW5nLFxuICBwYXJhbXM6IEZhY2V0UGFyYW1zID0ge31cbik6IGFueSA9PiB7XG4gIGNvbnN0IGNvbnRleHRJbnN0YW5jZTogQ29udGV4dFR5cGUgfCB1bmRlZmluZWQgPSB1c2VDb250ZXh0KGNvbnRleHQpO1xuXG4gIGlmIChjb250ZXh0SW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBob29rIG11c3QgYmUgdXNlZCB3aXRoaW4gYSAke2NvbnRleHROYW1lfWApO1xuICB9XG5cbiAgY29uc3QgZmFjZXRQYXJhbXNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVN0YWJsZUhhc2gocGFyYW1zKSwgW3BhcmFtc10pO1xuICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHRdID0gdXNlU3RhdGU8YW55PihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChmYWNldCAmJiBjb250ZXh0SW5zdGFuY2UpIHtcbiAgICAgIC8vIFJlbW92ZSB1bm5lY2Vzc2FyeSBhc3luYyB3cmFwcGVyXG4gICAgICBjb25zdCBmYWNldFJlc3VsdCA9IGNvbnRleHRJbnN0YW5jZS5mYWNldFJlc3VsdHM/LltmYWNldF0/LltmYWNldFBhcmFtc1N0cmluZ107XG4gICAgICBzZXRSZXN1bHQoZmFjZXRSZXN1bHQgPz8gbnVsbCk7XG4gICAgfVxuICB9LCBbZmFjZXQsIGZhY2V0UGFyYW1zU3RyaW5nLCBjb250ZXh0SW5zdGFuY2VdKTsgLy8gQWRkIG1pc3NpbmcgZGVwZW5kZW5jeVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5pbXBvcnQgeyBhYmJyZXZJSywgQWxsSXRlbVR5cGVBcnJheXMsIEl0ZW0sIEl0ZW1RdWVyeSwgUHJpS2V5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlRWxlbWVudCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyBBZ2dyZWdhdGVDb25maWcsIENhY2hlLCBjcmVhdGVBZ2dyZWdhdG9yIH0gZnJvbSBcIkBmamVsbC9jYWNoZVwiO1xuaW1wb3J0IHsgRmFjZXRQYXJhbXMgfSBmcm9tIFwic3JjL3R5cGVzXCI7XG5pbXBvcnQgKiBhcyBBSXRlbSBmcm9tIFwiLi4vQUl0ZW1cIjtcbmltcG9ydCAqIGFzIEFJdGVtQWRhcHRlciBmcm9tIFwiLi4vQUl0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBBSXRlbXMgZnJvbSBcIi4uL0FJdGVtc1wiO1xuaW1wb3J0ICogYXMgRmFjZXRlZCBmcm9tIFwiLi4vRmFjZXRlZFwiO1xuaW1wb3J0IExpYkxvZ2dlciBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdQSXRlbUFkYXB0ZXInKTtcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZXh0VHlwZTxcbiAgICBWIGV4dGVuZHMgSXRlbTxTPixcbiAgICBTIGV4dGVuZHMgc3RyaW5nXG4gID4gZXh0ZW5kcyBBSXRlbUFkYXB0ZXIuQ29udGV4dFR5cGU8ViwgUz4ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBwa1R5cGVzOiBBbGxJdGVtVHlwZUFycmF5czxTPjtcbiAgICBhZGRGYWNldHM/OiAoZmFjZXQ6IEZhY2V0ZWQuRmFjZXRNZXRob2QpID0+IFJlY29yZDxzdHJpbmcsIEZhY2V0ZWQuQWRkZWRGYWNldE1ldGhvZD47XG4gICAgYWRkQWxsRmFjZXRzPzogKGFsbEZhY2V0OiBGYWNldGVkLkFsbEZhY2V0TWV0aG9kKSA9PiBSZWNvcmQ8c3RyaW5nLCBGYWNldGVkLkFkZGVkRmFjZXRNZXRob2Q+O1xuICB9XG5cbmV4cG9ydCB0eXBlIENvbnRleHQ8ViBleHRlbmRzIEl0ZW08Uz4sIFMgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgICBSZWFjdC5Db250ZXh0PENvbnRleHRUeXBlPFYsIFM+IHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGNvbnN0IHVzZVBJdGVtQWRhcHRlciA9IDxcbiAgViBleHRlbmRzIEl0ZW08Uz4sXG4gIFMgZXh0ZW5kcyBzdHJpbmdcbj4oY29udGV4dDogQ29udGV4dDxWLCBTPiwgY29udGV4dE5hbWU6IHN0cmluZyk6IENvbnRleHRUeXBlPFYsIFM+ID0+IHtcbiAgY29uc3QgY29udGV4dEluc3RhbmNlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcblxuICBpZiAoY29udGV4dEluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgdXNlUEl0ZW1BZGFwdGVyIGhvb2sgbXVzdCBiZSB1c2VkIHdpdGhpbiBhICR7Y29udGV4dE5hbWV9IHByb3ZpZGVyLiBgICtcbiAgICAgIGBNYWtlIHN1cmUgdG8gd3JhcCB5b3VyIGNvbXBvbmVudCB3aXRoIDwke2NvbnRleHROYW1lfS5Qcm92aWRlciB2YWx1ZT17Li4ufT4gYCArXG4gICAgICBgb3IgdXNlIHRoZSBjb3JyZXNwb25kaW5nIFByb3ZpZGVyIGNvbXBvbmVudC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dEluc3RhbmNlO1xufTtcblxuZXhwb3J0IGNvbnN0IEFkYXB0ZXIgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFM+LFxuICBTIGV4dGVuZHMgc3RyaW5nXG4+KHtcbiAgICBuYW1lLFxuICAgIGNhY2hlLFxuICAgIGNvbnRleHQsXG4gICAgYWdncmVnYXRlcyA9IHt9LFxuICAgIGV2ZW50cyA9IHt9LFxuICAgIGFkZEFjdGlvbnMsXG4gICAgYWRkRmFjZXRzLFxuICAgIGFkZEFsbEFjdGlvbnMsXG4gICAgYWRkQWxsRmFjZXRzLFxuICAgIGNoaWxkcmVuXG4gIH06IHtcbiAgbmFtZTogc3RyaW5nO1xuICBjYWNoZTogQ2FjaGU8ViwgUz47XG4gIGNvbnRleHQ6IENvbnRleHQ8ViwgUz47XG4gIGFnZ3JlZ2F0ZXM/OiBBZ2dyZWdhdGVDb25maWc7XG4gIGV2ZW50cz86IEFnZ3JlZ2F0ZUNvbmZpZztcbiAgYWRkQWN0aW9ucz86IChhY3Rpb246IEFJdGVtLkFjdGlvbk1ldGhvZDxWLCBTPikgPT4gUmVjb3JkPHN0cmluZywgQUl0ZW0uQWRkZWRBY3Rpb25NZXRob2Q8ViwgUz4+O1xuICBhZGRGYWNldHM/OiAoZmFjZXQ6IEZhY2V0ZWQuRmFjZXRNZXRob2QpID0+IFJlY29yZDxzdHJpbmcsIEZhY2V0ZWQuQWRkZWRGYWNldE1ldGhvZD47XG4gIGFkZEFsbEFjdGlvbnM/OiAoYWxsQWN0aW9uOiBBSXRlbXMuQWxsQWN0aW9uTWV0aG9kPFYsIFM+KSA9PiBSZWNvcmQ8c3RyaW5nLCBBSXRlbXMuQWRkZWRBbGxBY3Rpb25NZXRob2Q8ViwgUz4+O1xuICBhZGRBbGxGYWNldHM/OiAoYWxsRmFjZXQ6IEZhY2V0ZWQuQWxsRmFjZXRNZXRob2QpID0+IFJlY29yZDxzdHJpbmcsIEZhY2V0ZWQuQWRkZWRGYWNldE1ldGhvZD47XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59KSA9PiB7XG5cbiAgLy8gVmFsaWRhdGUgY2FjaGUgYXQgaW5pdGlhbGl6YXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0NhY2hlIGlzIHVuZGVmaW5lZCBpbiAlcy4gVGhpcyB3aWxsIGNhdXNlIGFsbCBvcGVyYXRpb25zIHRvIGZhaWwuJywgbmFtZSk7XG4gICAgfVxuICB9LCBbY2FjaGUsIG5hbWVdKTtcblxuICBjb25zdCBwa1R5cGVzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGNhY2hlIG1pZ2h0IGJlIGEgUHJvbWlzZSAoYXN5bmMgaW5pdGlhbGl6YXRpb24pXG4gICAgaWYgKCFjYWNoZSB8fCB0eXBlb2YgKGNhY2hlIGFzIGFueSkudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmNvb3JkaW5hdGU/Lmt0YTtcbiAgfSwgW2NhY2hlXSk7XG5cbiAgY29uc3Qgc291cmNlQ2FjaGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ05vIGNhY2hlIHByb3ZpZGVkIHRvICVzLCBvcGVyYXRpb25zIHdpbGwgZmFpbCcsIG5hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChhZ2dyZWdhdGVzICYmIE9iamVjdC5rZXlzKGFnZ3JlZ2F0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBjcmVhdGVBZ2dyZWdhdG9yPFYsIFM+KGNhY2hlLCB7IGFnZ3JlZ2F0ZXMsIGV2ZW50cyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwgW2NhY2hlLCBhZ2dyZWdhdGVzLCBldmVudHMsIG5hbWVdKTtcblxuICBjb25zdCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgc2V0UmVzb2x2ZWRTb3VyY2VDYWNoZV0gPSBSZWFjdC51c2VTdGF0ZTxDYWNoZTxWLCBTPiB8IG51bGw+KCgpID0+IHtcbiAgICBpZiAoc291cmNlQ2FjaGUgJiYgIWlzUHJvbWlzZShzb3VyY2VDYWNoZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2VDYWNoZSBhcyBDYWNoZTxWLCBTPjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuXG4gIC8vIFN0YXRlIHRvIHRyaWdnZXIgcmUtcmVuZGVycyB3aGVuIGNhY2hlIGV2ZW50cyBvY2N1clxuICBjb25zdCBbLCBzZXRDYWNoZVZlcnNpb25dID0gUmVhY3QudXNlU3RhdGUoMCk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc291cmNlQ2FjaGUpIHtcbiAgICAgIGlmIChpc1Byb21pc2U8Q2FjaGU8ViwgUz4+KHNvdXJjZUNhY2hlKSkge1xuICAgICAgICBzb3VyY2VDYWNoZS50aGVuKGMgPT4ge1xuICAgICAgICAgIHNldFJlc29sdmVkU291cmNlQ2FjaGUoYyk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHNvdXJjZSBjYWNoZSBpbiAlczogJXMnLCBuYW1lLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UmVzb2x2ZWRTb3VyY2VDYWNoZShzb3VyY2VDYWNoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFJlc29sdmVkU291cmNlQ2FjaGUobnVsbCk7XG4gICAgfVxuICB9LCBbc291cmNlQ2FjaGUsIG5hbWVdKTtcblxuICAvLyBTdWJzY3JpYmUgdG8gY2FjaGUgZXZlbnRzIHRvIHRyaWdnZXIgcmUtcmVuZGVyc1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSB8fCB0eXBlb2YgcmVzb2x2ZWRTb3VyY2VDYWNoZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcmVzb2x2ZWRTb3VyY2VDYWNoZS5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIEluY3JlbWVudCB2ZXJzaW9uIHRvIHRyaWdnZXIgcmUtcmVuZGVycyBmb3IgYW55IGNhY2hlIGNoYW5nZVxuICAgICAgICBzZXRDYWNoZVZlcnNpb24ocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGUgZXZlbnQgaW4gJHtuYW1lfTpgLCBldmVudC50eXBlLCBldmVudCk7XG4gICAgICB9LCB7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBhbGwgY2FjaGUgZXZlbnRzIGZvciB0aGlzIGFkYXB0ZXJcbiAgICAgICAgZXZlbnRUeXBlczogW1xuICAgICAgICAgICdpdGVtX2NyZWF0ZWQnLFxuICAgICAgICAgICdpdGVtX3VwZGF0ZWQnLFxuICAgICAgICAgICdpdGVtX3JlbW92ZWQnLFxuICAgICAgICAgICdpdGVtX3JldHJpZXZlZCcsXG4gICAgICAgICAgJ2l0ZW1fc2V0JyxcbiAgICAgICAgICAnaXRlbXNfcXVlcmllZCcsXG4gICAgICAgICAgJ2NhY2hlX2NsZWFyZWQnLFxuICAgICAgICAgICdsb2NhdGlvbl9pbnZhbGlkYXRlZCcsXG4gICAgICAgICAgJ3F1ZXJ5X2ludmFsaWRhdGVkJ1xuICAgICAgICBdLFxuICAgICAgICBkZWJvdW5jZU1zOiA1MCAvLyBTbWFsbCBkZWJvdW5jZSB0byBiYXRjaCByYXBpZCB1cGRhdGVzXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGUgc3Vic2NyaXB0aW9uIG5vdCBhdmFpbGFibGUgaW4gJHtuYW1lfTpgLCBlcnJvcik7XG4gICAgICAvLyBSZXR1cm4gYSBuby1vcCBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICB9LCBbcmVzb2x2ZWRTb3VyY2VDYWNoZSwgbmFtZV0pO1xuXG4gIGNvbnN0IGhhbmRsZUNhY2hlRXJyb3IgPSB1c2VDYWxsYmFjaygob3BlcmF0aW9uOiBzdHJpbmcpOiBuZXZlciA9PiB7XG4gICAgbG9nZ2VyLmVycm9yKCdDYWNoZSBub3QgaW5pdGlhbGl6ZWQgaW4gJXMuIE9wZXJhdGlvbiBcIiVzXCIgZmFpbGVkLicsIG5hbWUsIG9wZXJhdGlvbik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhY2hlIG5vdCBpbml0aWFsaXplZCBpbiAke25hbWV9LiBPcGVyYXRpb24gXCIke29wZXJhdGlvbn1cIiBmYWlsZWQuIGAgK1xuICAgICAgYFRoaXMgdXN1YWxseSBtZWFucyB0aGUgY2FjaGUgcHJvcCB3YXMgbm90IHByb3ZpZGVkIHRvIHRoZSBhZGFwdGVyIG9yIGAgK1xuICAgICAgYHRoZSBjYWNoZSBQcm9taXNlIGhhcyBub3QgcmVzb2x2ZWQgeWV0LiBDaGVjayB5b3VyIGFkYXB0ZXIgY29uZmlndXJhdGlvbi5gXG4gICAgKTtcbiAgfSwgW25hbWVdKTtcblxuICBjb25zdCBlbnN1cmVDYWNoZSA9IHVzZUNhbGxiYWNrKChvcGVyYXRpb246IHN0cmluZykgPT4ge1xuICAgIGlmICghcmVzb2x2ZWRTb3VyY2VDYWNoZSkge1xuICAgICAgaGFuZGxlQ2FjaGVFcnJvcihvcGVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRTb3VyY2VDYWNoZSE7XG4gIH0sIFtyZXNvbHZlZFNvdXJjZUNhY2hlLCBoYW5kbGVDYWNoZUVycm9yXSk7XG5cbiAgY29uc3QgYWxsID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5LFxuICApOiBQcm9taXNlPFZbXSB8IG51bGw+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2FsbCcsIHsgcXVlcnk6IHF1ZXJ5ICYmIHF1ZXJ5LnRvU3RyaW5nKCkgfSk7XG4gICAgY29uc3QgY2FjaGUgPSBlbnN1cmVDYWNoZSgnYWxsJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5hbGwocXVlcnkpO1xuICAgIC8vIFZhbGlkYXRlIHRoYXQgcmVzdWx0IGlzIGFuIGFycmF5IG9yIG51bGwsIHJldHVybiBudWxsIGZvciBpbnZhbGlkIHJlc3VsdHNcbiAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnSW52YWxpZCByZXN1bHQgZnJvbSBjYWNoZS5vcGVyYXRpb25zLmFsbDogZXhwZWN0ZWQgYXJyYXkgb3IgbnVsbCwgZ290ICVzJywgdHlwZW9mIHJlc3VsdCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCBhcyBWW107XG4gIH0sIFtlbnN1cmVDYWNoZSwgbmFtZV0pO1xuXG4gIGNvbnN0IG9uZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBxdWVyeT86IEl0ZW1RdWVyeSxcbiAgKTogUHJvbWlzZTxWIHwgbnVsbD4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnb25lJywgeyBxdWVyeTogcXVlcnkgJiYgcXVlcnkudG9TdHJpbmcoKSB9KTtcbiAgICBjb25zdCBjYWNoZSA9IGVuc3VyZUNhY2hlKCdvbmUnKTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5vbmUocXVlcnkpO1xuICAgIHJldHVybiBpdGVtIGFzIFYgfCBudWxsO1xuICB9LCBbZW5zdXJlQ2FjaGUsIG5hbWVdKTtcblxuICBjb25zdCBjcmVhdGUgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgaXRlbTogUGFydGlhbDxJdGVtPFM+PixcbiAgKTogUHJvbWlzZTxWPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdjcmVhdGUnLCB7IGl0ZW0gfSk7XG4gICAgY29uc3QgY2FjaGUgPSBlbnN1cmVDYWNoZSgnY3JlYXRlJyk7XG4gICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuY3JlYXRlKGl0ZW0pO1xuICAgIHJldHVybiBuZXdJdGVtIGFzIFY7XG4gIH0sIFtlbnN1cmVDYWNoZV0pO1xuXG4gIGNvbnN0IGdldCA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IFByaUtleTxTPixcbiAgKTogUHJvbWlzZTxWIHwgbnVsbD4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnZ2V0JywgeyBrZXk6IGFiYnJldklLKGtleSkgfSk7XG4gICAgY29uc3QgY2FjaGUgPSBlbnN1cmVDYWNoZSgnZ2V0Jyk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZ2V0KGtleSk7XG4gICAgcmV0dXJuIGl0ZW0gYXMgViB8IG51bGw7XG4gIH0sIFtlbnN1cmVDYWNoZV0pO1xuXG4gIGNvbnN0IHJlbW92ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IFByaUtleTxTPixcbiAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdyZW1vdmUnLCB7IGtleTogYWJicmV2SUsoa2V5KSB9KTtcbiAgICBjb25zdCBjYWNoZSA9IGVuc3VyZUNhY2hlKCdyZW1vdmUnKTtcbiAgICBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJlbW92ZShrZXkpO1xuICB9LCBbZW5zdXJlQ2FjaGVdKTtcblxuICBjb25zdCByZXRyaWV2ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IFByaUtleTxTPixcbiAgKTogUHJvbWlzZTxWIHwgbnVsbD4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgncmV0cmlldmUnLCB7IGtleTogYWJicmV2SUsoa2V5KSB9KTtcbiAgICBjb25zdCBjYWNoZSA9IGVuc3VyZUNhY2hlKCdyZXRyaWV2ZScpO1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJldHJpZXZlKGtleSk7XG4gICAgcmV0dXJuIGl0ZW0gYXMgViB8IG51bGw7XG4gIH0sIFtlbnN1cmVDYWNoZV0pO1xuXG4gIGNvbnN0IHVwZGF0ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IFByaUtleTxTPixcbiAgICBpdGVtOiBQYXJ0aWFsPEl0ZW08Uz4+LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3VwZGF0ZScsIHsga2V5OiBhYmJyZXZJSyhrZXkpLCBpdGVtIH0pO1xuICAgIGNvbnN0IGNhY2hlID0gZW5zdXJlQ2FjaGUoJ3VwZGF0ZScpO1xuICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnVwZGF0ZShrZXksIGl0ZW0pO1xuICAgIHJldHVybiBuZXdJdGVtIGFzIFY7XG4gIH0sIFtlbnN1cmVDYWNoZV0pO1xuXG4gIGNvbnN0IGFjdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBrZXk6IFByaUtleTxTPixcbiAgICBhY3Rpb246IHN0cmluZyxcbiAgICBib2R5PzogYW55LFxuICApOiBQcm9taXNlPFY+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2FjdGlvbicsIHsga2V5OiBhYmJyZXZJSyhrZXkpLCBhY3Rpb24sIGJvZHkgfSk7XG4gICAgY29uc3QgY2FjaGUgPSBlbnN1cmVDYWNoZSgnYWN0aW9uJyk7XG4gICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWN0aW9uKGtleSwgYWN0aW9uLCBib2R5KTtcbiAgICByZXR1cm4gbmV3SXRlbSBhcyBWO1xuICB9LCBbZW5zdXJlQ2FjaGVdKTtcblxuICBjb25zdCBhbGxBY3Rpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgYm9keT86IGFueSxcbiAgKTogUHJvbWlzZTxWW10gfCBudWxsPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdhbGxBY3Rpb24nLCB7IGFjdGlvbiwgYm9keSB9KTtcbiAgICBjb25zdCBjYWNoZSA9IGVuc3VyZUNhY2hlKCdhbGxBY3Rpb24nKTtcbiAgICBjb25zdCBuZXdJdGVtcyA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWxsQWN0aW9uKGFjdGlvbiwgYm9keSk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zIGFzIFZbXTtcbiAgfSwgW2Vuc3VyZUNhY2hlXSk7XG5cbiAgY29uc3QgZmFjZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAga2V5OiBQcmlLZXk8Uz4sXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBGYWNldFBhcmFtcyxcbiAgKTogUHJvbWlzZTxhbnkgfCBudWxsPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdmYWNldCcsIHsga2V5OiBhYmJyZXZJSyhrZXkpLCBmYWNldCwgcGFyYW1zIH0pO1xuICAgIGNvbnN0IGNhY2hlID0gZW5zdXJlQ2FjaGUoJ2ZhY2V0Jyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBwYXJhbXMgIT09IHVuZGVmaW5lZFxuICAgICAgPyBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmZhY2V0KGtleSwgZmFjZXQsIHBhcmFtcylcbiAgICAgIDogYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5mYWNldChrZXksIGZhY2V0KTtcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgYW55IHwgbnVsbDtcbiAgfSwgW2Vuc3VyZUNhY2hlXSk7XG5cbiAgY29uc3QgYWxsRmFjZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBGYWNldFBhcmFtcyxcbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2FsbEZhY2V0JywgeyBmYWNldCwgcGFyYW1zIH0pO1xuICAgIGNvbnN0IGNhY2hlID0gZW5zdXJlQ2FjaGUoJ2FsbEZhY2V0Jyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmFsbEZhY2V0KGZhY2V0LCBwYXJhbXMpO1xuICAgIHJldHVybiByZXNwb25zZSBhcyBhbnk7XG4gIH0sIFtlbnN1cmVDYWNoZV0pO1xuXG4gIGNvbnN0IGZpbmQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICk6IFByb21pc2U8VltdIHwgbnVsbD4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnZmluZCcsIHsgZmluZGVyLCBmaW5kZXJQYXJhbXMgfSk7XG4gICAgY29uc3QgY2FjaGUgPSBlbnN1cmVDYWNoZSgnZmluZCcpO1xuICAgIGNvbnN0IG5ld0l0ZW1zID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5maW5kKGZpbmRlciwgZmluZGVyUGFyYW1zKTtcbiAgICByZXR1cm4gbmV3SXRlbXMgYXMgVltdO1xuICB9LCBbZW5zdXJlQ2FjaGVdKTtcblxuICBjb25zdCBmaW5kT25lID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGZpbmRlcjogc3RyaW5nLFxuICAgIGZpbmRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICApOiBQcm9taXNlPFYgfCBudWxsPiA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdmaW5kT25lJywgeyBmaW5kZXIsIGZpbmRlclBhcmFtcyB9KTtcbiAgICBjb25zdCBjYWNoZSA9IGVuc3VyZUNhY2hlKCdmaW5kT25lJyk7XG4gICAgY29uc3QgbmV3SXRlbXMgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmZpbmQoZmluZGVyLCBmaW5kZXJQYXJhbXMpO1xuICAgIC8vIGZpbmRPbmUgc2hvdWxkIHJldHVybiB0aGUgZmlyc3QgaXRlbSBmcm9tIGZpbmQgcmVzdWx0cywgb3IgbnVsbCBpZiBubyByZXN1bHRzXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld0l0ZW1zKSB8fCBuZXdJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3SXRlbXNbMF0gYXMgVjtcbiAgfSwgW2Vuc3VyZUNhY2hlXSk7XG5cbiAgY29uc3Qgc2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIGtleTogUHJpS2V5PFM+LFxuICAgIGl0ZW06IFYsXG4gICk6IFByb21pc2U8Vj4gPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnc2V0JywgeyBrZXk6IGFiYnJldklLKGtleSksIGl0ZW0gfSk7XG4gICAgY29uc3QgY2FjaGUgPSBlbnN1cmVDYWNoZSgnc2V0Jyk7XG4gICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuc2V0KGtleSwgaXRlbSk7XG4gICAgcmV0dXJuIG5ld0l0ZW0gYXMgVjtcbiAgfSwgW2Vuc3VyZUNhY2hlXSk7XG5cbiAgY29uc3QgY29udGV4dFZhbHVlOiBDb250ZXh0VHlwZTxWLCBTPiA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBuYW1lLFxuICAgIHBrVHlwZXM6IHBrVHlwZXMgfHwgKFsncGxhY2Vob2xkZXInIGFzIFNdIGFzIEFsbEl0ZW1UeXBlQXJyYXlzPFM+KSxcbiAgICBhbGwsXG4gICAgb25lLFxuICAgIGNyZWF0ZSxcbiAgICBnZXQsXG4gICAgcmVtb3ZlLFxuICAgIHJldHJpZXZlLFxuICAgIHVwZGF0ZSxcbiAgICBhY3Rpb24sXG4gICAgYWxsQWN0aW9uLFxuICAgIGZhY2V0LFxuICAgIGFsbEZhY2V0LFxuICAgIGZpbmQsXG4gICAgZmluZE9uZSxcbiAgICBzZXQsXG4gICAgYWRkQWN0aW9ucyxcbiAgICBhZGRGYWNldHMsXG4gICAgYWRkQWxsQWN0aW9ucyxcbiAgICBhZGRBbGxGYWNldHMsXG4gIH0pLCBbXG4gICAgbmFtZSxcbiAgICBwa1R5cGVzLFxuICAgIGFsbCxcbiAgICBvbmUsXG4gICAgY3JlYXRlLFxuICAgIGdldCxcbiAgICByZW1vdmUsXG4gICAgcmV0cmlldmUsXG4gICAgdXBkYXRlLFxuICAgIGFjdGlvbixcbiAgICBhbGxBY3Rpb24sXG4gICAgZmFjZXQsXG4gICAgYWxsRmFjZXQsXG4gICAgZmluZCxcbiAgICBmaW5kT25lLFxuICAgIHNldCxcbiAgICBhZGRBY3Rpb25zLFxuICAgIGFkZEZhY2V0cyxcbiAgICBhZGRBbGxBY3Rpb25zLFxuICAgIGFkZEFsbEZhY2V0cyxcblxuICBdKTtcblxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICBjb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgfSxcbiAgICBjaGlsZHJlbixcbiAgKTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuaW1wb3J0IHsgSXRlbSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBBSXRlbSBmcm9tIFwiLi4vQUl0ZW1cIjtcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZXh0VHlwZTxcbiAgViBleHRlbmRzIEl0ZW08Uz4sXG4gIFMgZXh0ZW5kcyBzdHJpbmdcbj4gZXh0ZW5kcyBBSXRlbS5Db250ZXh0VHlwZTxWLCBTPiB7XG4gIHBhcmVudEl0ZW06IG51bGw7XG59XG5leHBvcnQgdHlwZSBDb250ZXh0PFxuICBWIGV4dGVuZHMgSXRlbTxTPixcbiAgUyBleHRlbmRzIHN0cmluZ1xuPiA9IFJlYWN0LkNvbnRleHQ8Q29udGV4dFR5cGU8ViwgUz4gfCB1bmRlZmluZWQ+O1xuXG4vLyBUT0RPOiBXaHkgZG9lc24ndCB0aGlzIGp1c3QgY2FsbCBBSXRlbS51c2VDb250ZXh0P1xuZXhwb3J0IGNvbnN0IHVzZVBJdGVtID0gPFxuICBWIGV4dGVuZHMgSXRlbTxTPixcbiAgUyBleHRlbmRzIHN0cmluZ1xuPihjb250ZXh0OiBDb250ZXh0PFYsIFM+LCBjb250ZXh0TmFtZTogc3RyaW5nKTogQ29udGV4dFR5cGU8ViwgUz4gPT4ge1xuICBjb25zdCBjb250ZXh0SW5zdGFuY2UgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuXG4gIGlmIChjb250ZXh0SW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGlzIGhvb2sgbXVzdCBiZSB1c2VkIHdpdGhpbiBhICR7Y29udGV4dE5hbWV9YCxcbiAgICApO1xuICB9XG4gIHJldHVybiBjb250ZXh0SW5zdGFuY2U7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIEFJdGVtcyBmcm9tIFwiLi4vQUl0ZW1zXCI7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5cbmV4cG9ydCB0eXBlIENvbnRleHRUeXBlPFxuICBWIGV4dGVuZHMgSXRlbTxTPixcbiAgUyBleHRlbmRzIHN0cmluZ1xuPiA9IEFJdGVtcy5Db250ZXh0VHlwZTxWLCBTPjtcblxuZXhwb3J0IHR5cGUgQ29udGV4dDxcbiAgViBleHRlbmRzIEl0ZW08Uz4sXG4gIFMgZXh0ZW5kcyBzdHJpbmdcbj4gPSBSZWFjdC5Db250ZXh0PENvbnRleHRUeXBlPFYsIFM+IHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGNvbnN0IHVzZVBJdGVtcyA9IDxcbiAgViBleHRlbmRzIEl0ZW08Uz4sXG4gIFMgZXh0ZW5kcyBzdHJpbmdcbj4oY29udGV4dDogQ29udGV4dDxWLCBTPiwgY29udGV4dE5hbWU6IHN0cmluZyk6IENvbnRleHRUeXBlPFYsIFM+ID0+IHtcbiAgY29uc3QgY29udGV4dEluc3RhbmNlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKGNvbnRleHRJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoaXMgaG9vayBtdXN0IGJlIHVzZWQgd2l0aGluIGEgJHtjb250ZXh0TmFtZX1gLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRJbnN0YW5jZTtcbn07XG4iLCJpbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VQSXRlbUFkYXB0ZXIgfSBmcm9tIFwiLi9QSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVN0YWJsZUhhc2ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBGYWNldFBhcmFtcyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIFBJdGVtQWRhcHRlciBmcm9tIFwiLi9QSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIFBJdGVtIGZyb20gXCIuL1BJdGVtXCI7XG5cbmV4cG9ydCBjb25zdCBQSXRlbUZhY2V0ID0gPFYgZXh0ZW5kcyBJdGVtPFM+LCBTIGV4dGVuZHMgc3RyaW5nPihcbiAge1xuICAgIGFkYXB0ZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dDogaXRlbUNvbnRleHQsXG4gICAgY29udGV4dE5hbWUsXG4gICAgYWRhcHRlckNvbnRleHQsXG4gICAgZmFjZXQsXG4gICAgZmFjZXRQYXJhbXMgPSB7fSxcbiAgfToge1xuICAgIGFkYXB0ZXI6IFBJdGVtQWRhcHRlci5Db250ZXh0PFYsIFM+O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgY29udGV4dDogUEl0ZW0uQ29udGV4dDxWLCBTPjtcbiAgICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIGFkYXB0ZXJDb250ZXh0Pzogc3RyaW5nO1xuICAgIGZhY2V0OiBzdHJpbmcsXG4gICAgZmFjZXRQYXJhbXM/OiBGYWNldFBhcmFtcyxcbiAgfVxuKSA9PiB7XG5cbiAgY29uc3QgW3Jlc3VsdCwgc2V0UmVzdWx0XSA9IFJlYWN0LnVzZVN0YXRlPGFueT4obnVsbCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcblxuICBjb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdQSXRlbUZhY2V0Jyk7XG5cbiAgLy8gRGVmYXVsdCBhZGFwdGVyQ29udGV4dCB0byBjb250ZXh0TmFtZSArIFwiQWRhcHRlclwiIGlmIG5vdCBwcm92aWRlZFxuICBjb25zdCBhZGFwdGVyQ29udGV4dE5hbWUgPSBhZGFwdGVyQ29udGV4dCB8fCBgJHtjb250ZXh0TmFtZX1BZGFwdGVyYDtcblxuICAvLyBHZXQgdGhlIGFkYXB0ZXIgY29udGV4dFxuICBjb25zdCBhZGFwdGVyQ29udGV4dEluc3RhbmNlID0gdXNlUEl0ZW1BZGFwdGVyPFYsIFM+KGFkYXB0ZXIsIGFkYXB0ZXJDb250ZXh0TmFtZSk7XG5cbiAgLy8gR2V0IHRoZSBpdGVtIGNvbnRleHRcbiAgY29uc3QgaXRlbUNvbnRleHRWYWx1ZSA9IFBJdGVtLnVzZVBJdGVtPFYsIFM+KGl0ZW1Db250ZXh0LCBjb250ZXh0TmFtZSk7XG5cbiAgY29uc3QgZmFjZXRQYXJhbXNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVN0YWJsZUhhc2goZmFjZXRQYXJhbXMpLCBbZmFjZXRQYXJhbXNdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChmYWNldCAmJiBmYWNldFBhcmFtcyAmJiBpdGVtQ29udGV4dFZhbHVlICYmIGl0ZW1Db250ZXh0VmFsdWUua2V5ICYmIGFkYXB0ZXJDb250ZXh0SW5zdGFuY2UpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRhcHRlckNvbnRleHRJbnN0YW5jZS5mYWNldChpdGVtQ29udGV4dFZhbHVlLmtleSwgZmFjZXQsIGZhY2V0UGFyYW1zKTtcbiAgICAgICAgICBzZXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGV4ZWN1dGUgZmFjZXQgXCIlc1wiIHdpdGggcGFyYW1zICVPOiAlcycsIGZhY2V0LCBmYWNldFBhcmFtcywgZXJyb3IpO1xuICAgICAgICAgIHNldFJlc3VsdChudWxsKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfSwgW2ZhY2V0LCBmYWNldFBhcmFtc1N0cmluZywgaXRlbUNvbnRleHRWYWx1ZT8ua2V5LCBpdGVtQ29udGV4dFZhbHVlPy5sb2NhdGlvbnNdKTtcblxuICAvLyBDcmVhdGUgYSBuZXcgY29udGV4dCB2YWx1ZSB3aXRoIHRoZSBmYWNldCByZXN1bHRcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFpdGVtQ29udGV4dFZhbHVlKSByZXR1cm4gaXRlbUNvbnRleHRWYWx1ZTtcblxuICAgIGNvbnN0IHVwZGF0ZWRGYWNldFJlc3VsdHMgPSB7IC4uLml0ZW1Db250ZXh0VmFsdWUuZmFjZXRSZXN1bHRzIH07XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKCF1cGRhdGVkRmFjZXRSZXN1bHRzW2ZhY2V0XSkge1xuICAgICAgICB1cGRhdGVkRmFjZXRSZXN1bHRzW2ZhY2V0XSA9IHt9O1xuICAgICAgfVxuICAgICAgdXBkYXRlZEZhY2V0UmVzdWx0c1tmYWNldF0gPSB7XG4gICAgICAgIC4uLnVwZGF0ZWRGYWNldFJlc3VsdHNbZmFjZXRdLFxuICAgICAgICBbZmFjZXRQYXJhbXNTdHJpbmddOiByZXN1bHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLml0ZW1Db250ZXh0VmFsdWUsXG4gICAgICBmYWNldFJlc3VsdHM6IHVwZGF0ZWRGYWNldFJlc3VsdHMsXG4gICAgICBpc0xvYWRpbmc6IGlzTG9hZGluZyB8fCBpdGVtQ29udGV4dFZhbHVlLmlzTG9hZGluZyxcbiAgICB9O1xuICB9LCBbaXRlbUNvbnRleHRWYWx1ZSwgcmVzdWx0LCBpc0xvYWRpbmcsIGZhY2V0LCBmYWNldFBhcmFtc1N0cmluZ10pO1xuXG4gIHJldHVybiAoXG4gICAgPGl0ZW1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvaXRlbUNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbmltcG9ydCBMaWJMb2dnZXIgZnJvbSBcIi4uL2xvZ2dlclwiO1xuaW1wb3J0IHtcbiAgQWxsSXRlbVR5cGVBcnJheXMsXG4gIGlrVG9MS0EsXG4gIGlzVmFsaWRQcmlLZXksXG4gIEl0ZW0sXG4gIExvY0tleUFycmF5LFxuICBQcmlLZXksXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUVsZW1lbnQsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VQSXRlbUFkYXB0ZXIgfSBmcm9tIFwiLi9QSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIFBJdGVtIGZyb20gXCIuL1BJdGVtXCI7XG5pbXBvcnQgKiBhcyBQSXRlbUFkYXB0ZXIgZnJvbSBcIi4vUEl0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgeyB1c2VBc3luY0Vycm9yIH0gZnJvbSBcIi4uL3VzZUFzeW5jRXJyb3JcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnUEl0ZW1Mb2FkJyk7XG5cbmV4cG9ydCBjb25zdCBQSXRlbUxvYWQgPSA8XG4gIFYgZXh0ZW5kcyBJdGVtPFM+LFxuICBTIGV4dGVuZHMgc3RyaW5nXG4+KHtcbiAgICBuYW1lLFxuICAgIGFkYXB0ZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjb250ZXh0TmFtZSxcbiAgICBpayxcbiAgICBpdGVtOiBwcm92aWRlZEl0ZW1cbiAgfToge1xuICBuYW1lOiBzdHJpbmc7XG4gIGFkYXB0ZXI6IFBJdGVtQWRhcHRlci5Db250ZXh0PFYsIFM+O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBjb250ZXh0OiBQSXRlbS5Db250ZXh0PFYsIFM+O1xuICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICBpaz86IFByaUtleTxTPiB8IG51bGw7XG4gIGl0ZW0/OiBWIHwgbnVsbDtcbn0pID0+IHtcbiAgbG9nZ2VyLmRlYnVnKGAke25hbWV9OiBDb21wb25lbnQgaW5pdGlhbGl6ZWQgd2l0aCBwcm9wc2AsIHtcbiAgICBuYW1lLFxuICAgIGhhc0FkYXB0ZXI6ICEhYWRhcHRlcixcbiAgICBoYXNDaGlsZHJlbjogISFjaGlsZHJlbixcbiAgICBoYXNDb250ZXh0OiAhIWNvbnRleHQsXG4gICAgaWssXG4gICAgcHJvdmlkZWRJdGVtXG4gIH0pO1xuXG4gIGNvbnN0IHsgdGhyb3dBc3luY0Vycm9yIH0gPSB1c2VBc3luY0Vycm9yKCk7XG5cbiAgLy8gVmFsaWRhdGUgdGhhdCBib3RoIGlrIGFuZCBpdGVtIGFyZSBub3QgcHJvdmlkZWQgYXQgdGhlIHNhbWUgdGltZVxuICBpZiAoaWsgIT09IHVuZGVmaW5lZCAmJiBwcm92aWRlZEl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGAke25hbWV9OiBDYW5ub3QgcHJvdmlkZSBib3RoICdpaycgYW5kICdpdGVtJyBwYXJhbWV0ZXJzLiBQbGVhc2UgcHJvdmlkZSBvbmx5IG9uZS5gO1xuICAgIGxvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgY29uc3QgW2l0ZW1LZXksIHNldEl0ZW1LZXldID0gUmVhY3QudXNlU3RhdGU8UHJpS2V5PFM+IHwgdW5kZWZpbmVkPihpayA/PyB1bmRlZmluZWQpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbaXNVcGRhdGluZywgc2V0SXNVcGRhdGluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtpc1JlbW92aW5nLCBzZXRJc1JlbW92aW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcblxuICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IEluaXRpYWwgc3RhdGUgc2V0YCwge1xuICAgIGl0ZW1LZXksXG4gICAgaXNMb2FkaW5nLFxuICAgIGlzVXBkYXRpbmcsXG4gICAgaXNSZW1vdmluZ1xuICB9KTtcblxuICAvLyBTaW5jZSB3ZSBwYXNzIHRoaXMgdG8gdGhlIGFjdGlvbnMgY29uc3RydWN0b3IsIGRvbid0IGRlc3RydWN0dXJlIGl0IHlldFxuICBjb25zdCBQSXRlbUFkYXB0ZXIgPSB1c2VQSXRlbUFkYXB0ZXI8ViwgUz4oYWRhcHRlciwgY29udGV4dE5hbWUpO1xuICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IFBJdGVtQWRhcHRlciBpbml0aWFsaXplZGAsIHsgaGFzQWRhcHRlcjogISFQSXRlbUFkYXB0ZXIgfSk7XG5cbiAgLy8gRGVzdHJ1Y3R1cmUgdGhlIHZhbHVlcyB3ZSBuZWVkIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gIGNvbnN0IHtcbiAgICBwa1R5cGVzLFxuICAgIHJldHJpZXZlOiByZXRyaWV2ZUl0ZW0sXG4gICAgcmVtb3ZlOiByZW1vdmVJdGVtLFxuICAgIHVwZGF0ZTogdXBkYXRlSXRlbSxcbiAgICBhY3Rpb246IGFjdGlvbkl0ZW0sXG4gICAgZmFjZXQ6IGZhY2V0SXRlbSxcbiAgICBzZXQ6IHNldEl0ZW0sXG4gICAgYWRkQWN0aW9ucyxcbiAgICAvLyBhZGRGYWNldHMsXG4gIH0gPSBQSXRlbUFkYXB0ZXI7XG5cbiAgY29uc3QgaXRlbUxvZ2dlciA9IExpYkxvZ2dlci5nZXQoJ1BJdGVtTG9hZCcsIC4uLihwa1R5cGVzIHx8IFtdKSk7XG4gIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogSXRlbSBsb2dnZXIgY3JlYXRlZCB3aXRoIHBrVHlwZXNgLCB7IHBrVHlwZXMgfSk7XG5cbiAgY29uc3QgW2l0ZW0sIHNldEl0ZW1TdGF0ZV0gPSB1c2VTdGF0ZTxWIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gTG9hZCBpdGVtIGZyb20gY2FjaGUgb3IgdXNlIHByb3ZpZGVkIGl0ZW1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvdmlkZWRJdGVtKSB7XG4gICAgICBzZXRJdGVtU3RhdGUocHJvdmlkZWRJdGVtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGl0ZW1LZXkgJiYgaXNWYWxpZFByaUtleShpdGVtS2V5KSkge1xuICAgICAgLy8gVXNlIHJldHJpZXZlIHRvIGdldCB0aGUgaXRlbSBmcm9tIGNhY2hlIChjYWNoZS1maXJzdClcbiAgICAgIHJldHJpZXZlSXRlbShpdGVtS2V5IGFzIFByaUtleTxTPikudGhlbihyZXRyaWV2ZWRJdGVtID0+IHtcbiAgICAgICAgc2V0SXRlbVN0YXRlKHJldHJpZXZlZEl0ZW0gYXMgViB8IG51bGwpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgaXRlbTonLCBlcnJvcik7XG4gICAgICAgIHNldEl0ZW1TdGF0ZShudWxsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJdGVtU3RhdGUobnVsbCk7XG4gICAgfVxuICB9LCBbaXRlbUtleSwgcHJvdmlkZWRJdGVtLCByZXRyaWV2ZUl0ZW1dKTtcblxuICBjb25zdCBsb2NhdGlvbnM6IExvY0tleUFycmF5PFM+IHwgbnVsbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogQ29tcHV0aW5nIGxvY2F0aW9ucyBtZW1vaXphdGlvbmAsIHsgaGFzSXRlbTogISFpdGVtIH0pO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogSXRlbSBleGlzdHMsIGNvbnZlcnRpbmcga2V5IHRvIGxvY2F0aW9uIGFycmF5YCwgeyBpdGVtS2V5OiBpdGVtLmtleSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGlrVG9MS0EoaXRlbS5rZXkpIGFzIHVua25vd24gYXMgTG9jS2V5QXJyYXk8Uz47XG4gICAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IExvY2F0aW9uIGFycmF5IGNvbXB1dGVkYCwgeyBsb2NhdGlvbnM6IHJlc3VsdCB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogTm8gaXRlbSwgcmV0dXJuaW5nIG51bGwgbG9jYXRpb25zYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIFtpdGVtXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogdXNlRWZmZWN0W2lrXSB0cmlnZ2VyZWRgLCB7IGlrLCBwcm92aWRlZEl0ZW0gfSk7XG5cbiAgICBpZiAocHJvdmlkZWRJdGVtKSB7XG4gICAgICBzZXRJdGVtS2V5KHByb3ZpZGVkSXRlbS5rZXkgYXMgUHJpS2V5PFM+KTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlrICYmIGlzVmFsaWRQcmlLZXkoaWspKSB7XG4gICAgICBzZXRJdGVtS2V5KGlrKTtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTsgLy8gU2V0IGxvYWRpbmcgdG8gdHJ1ZSB3aGVuIHdlIGFyZSBhYm91dCB0byBmZXRjaFxuICAgICAgcmV0cmlldmVJdGVtKGlrKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBFcnJvciByZXRyaWV2aW5nIGl0ZW1gLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3dBc3luY0Vycm9yKGVycm9yIGFzIEVycm9yKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJdGVtS2V5KHVuZGVmaW5lZCk7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2lrLCBwcm92aWRlZEl0ZW0sIHJldHJpZXZlSXRlbV0pO1xuXG4gIGNvbnN0IHJlbW92ZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IHJlbW92ZSgpIGNhbGxlZGAsIHtcbiAgICAgIGl0ZW1LZXksXG4gICAgICBpc1ZhbGlkS2V5OiBpdGVtS2V5ID8gaXNWYWxpZFByaUtleShpdGVtS2V5KSA6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpZiAoaXRlbUtleSAmJiBpc1ZhbGlkUHJpS2V5KGl0ZW1LZXkpKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IFZhbGlkIGtleSBmb3IgcmVtb3ZlLCBzZXR0aW5nIGlzUmVtb3ZpbmcgdG8gdHJ1ZWAsIHsgaXRlbUtleSB9KTtcbiAgICAgIHNldElzUmVtb3ZpbmcodHJ1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtKGl0ZW1LZXkpO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IHJlbW92ZUl0ZW0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseWAsIHsgaXRlbUtleSB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgZHVyaW5nIGl0ZW0gcmVtb3ZhbGAsIHsgaXRlbUtleSwgZXJyb3IgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNSZW1vdmluZyhmYWxzZSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogaXNSZW1vdmluZyBzZXQgdG8gZmFsc2UgYWZ0ZXIgc3VjY2Vzc2Z1bCByZW1vdmFsYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogSW52YWxpZCBpdGVtS2V5IGZvciByZW1vdmVgLCB7IGl0ZW1LZXkgfSk7XG4gICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IEl0ZW0ga2V5IGlzIHJlcXVpcmVkIHRvIHJlbW92ZSBhbiBpdGVtYCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0ga2V5IGlzIHJlcXVpcmVkIHRvIHJlbW92ZSBhbiBpdGVtIGluICR7bmFtZX1gKTtcbiAgICB9XG4gIH0sIFtyZW1vdmVJdGVtLCBpdGVtS2V5XSk7XG5cbiAgY29uc3QgdXBkYXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHVwZGF0ZURhdGE6IFBhcnRpYWw8SXRlbTxTPj4sXG4gICkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogdXBkYXRlKCkgY2FsbGVkYCwge1xuICAgICAgaXRlbUtleSxcbiAgICAgIGlzVmFsaWRLZXk6IGl0ZW1LZXkgPyBpc1ZhbGlkUHJpS2V5KGl0ZW1LZXkpIDogZmFsc2UsXG4gICAgICBoYXNVcGRhdGVEYXRhOiAhIXVwZGF0ZURhdGFcbiAgICB9KTtcblxuICAgIGlmIChpdGVtS2V5ICYmIGlzVmFsaWRQcmlLZXkoaXRlbUtleSkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtuYW1lfTogVmFsaWQga2V5IGZvciB1cGRhdGUsIHNldHRpbmcgaXNVcGRhdGluZyB0byB0cnVlYCwgeyBpdGVtS2V5IH0pO1xuICAgICAgc2V0SXNVcGRhdGluZyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldEl0ZW0gPSBhd2FpdCB1cGRhdGVJdGVtKGl0ZW1LZXksIHVwZGF0ZURhdGEpO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IHVwZGF0ZUl0ZW0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseWAsIHtcbiAgICAgICAgICBpdGVtS2V5LFxuICAgICAgICAgIGhhc1Jlc3VsdDogISFyZXRJdGVtLFxuICAgICAgICAgIHJlc3VsdFR5cGU6IHJldEl0ZW0gPyB0eXBlb2YgcmV0SXRlbSA6ICd1bmRlZmluZWQnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0SXRlbTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogRXJyb3IgZHVyaW5nIGl0ZW0gdXBkYXRlYCwgeyBpdGVtS2V5LCB1cGRhdGVEYXRhLCBlcnJvciB9KTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1VwZGF0aW5nKGZhbHNlKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAke25hbWV9OiBpc1VwZGF0aW5nIHNldCB0byBmYWxzZSBhZnRlciBzdWNjZXNzZnVsIHVwZGF0ZWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IEludmFsaWQgaXRlbUtleSBmb3IgdXBkYXRlYCwgeyBpdGVtS2V5IH0pO1xuICAgICAgaXRlbUxvZ2dlci5lcnJvcihgJHtuYW1lfTogSXRlbSBrZXkgaXMgcmVxdWlyZWQgdG8gdXBkYXRlIGFuIGl0ZW1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBrZXkgaXMgcmVxdWlyZWQgdG8gdXBkYXRlIGFuIGl0ZW0gaW4gJHtuYW1lfWApO1xuICAgIH1cbiAgfSwgW3VwZGF0ZUl0ZW0sIGl0ZW1LZXldKTtcblxuICBjb25zdCBzZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgaXRlbTogVlxuICApID0+IHtcbiAgICBsb2dnZXIuZGVidWcoYCR7bmFtZX06IHNldCgpIGNhbGxlZGAsIHtcbiAgICAgIGl0ZW1LZXk6IGl0ZW0ua2V5LFxuICAgIH0pO1xuICAgIGlmIChpdGVtICYmIGl0ZW0ua2V5KSB7XG4gICAgICBzZXRJc1VwZGF0aW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0SXRlbSA9IGF3YWl0IHNldEl0ZW0oaXRlbS5rZXkgYXMgUHJpS2V5PFM+LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIHJldEl0ZW07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1VwZGF0aW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbUxvZ2dlci5lcnJvcihgJHtuYW1lfTogSXRlbSBrZXkgaXMgcmVxdWlyZWQgdG8gc2V0IGFuIGl0ZW1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBrZXkgaXMgcmVxdWlyZWQgdG8gc2V0IGFuIGl0ZW0gaW4gJHtuYW1lfWApO1xuICAgIH1cbiAgfSwgW3NldEl0ZW1dKTtcblxuICBjb25zdCBhY3Rpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgYWN0aW9uTmFtZTogc3RyaW5nLFxuICAgIGJvZHk/OiBhbnksXG4gICkgPT4ge1xuICAgIGlmIChpdGVtS2V5ICYmIGlzVmFsaWRQcmlLZXkoaXRlbUtleSkpIHtcbiAgICAgIHNldElzVXBkYXRpbmcodHJ1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYWN0aW9uSXRlbShpdGVtS2V5LCBhY3Rpb25OYW1lLCBib2R5KSBhcyBWO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNVcGRhdGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1Mb2dnZXIuZXJyb3IoYCR7bmFtZX06IEl0ZW0ga2V5IGlzIHJlcXVpcmVkIHRvIHBlcmZvcm0gYW4gYWN0aW9uYCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0ga2V5IGlzIHJlcXVpcmVkIHRvIHBlcmZvcm0gYW4gYWN0aW9uIGluICR7bmFtZX1gKTtcbiAgICB9XG4gIH0sIFthY3Rpb25JdGVtLCBpdGVtS2V5XSk7XG5cbiAgY29uc3QgZmFjZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgZmFjZXROYW1lOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSxcbiAgKSA9PiB7XG4gICAgaWYgKGl0ZW1LZXkgJiYgaXNWYWxpZFByaUtleShpdGVtS2V5KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZhY2V0SXRlbShpdGVtS2V5LCBmYWNldE5hbWUsIHBhcmFtcykgYXMgYW55O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGAke25hbWV9OiBFcnJvciBkdXJpbmcgZmFjZXQgcmV0cmlldmFsYCwgeyBpdGVtS2V5LCBmYWNldE5hbWUsIGVycm9yIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbUxvZ2dlci5lcnJvcihgJHtuYW1lfTogSXRlbSBrZXkgaXMgcmVxdWlyZWQgdG8gcmV0cmlldmUgYSBmYWNldGApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJdGVtIGtleSBpcyByZXF1aXJlZCB0byByZXRyaWV2ZSBhIGZhY2V0IGluICR7bmFtZX1gKTtcbiAgICB9XG4gIH0sIFtmYWNldEl0ZW0sIGl0ZW1LZXldKTtcblxuICBjb25zdCBjb250ZXh0VmFsdWU6IFBJdGVtLkNvbnRleHRUeXBlPFYsIFM+ID0ge1xuICAgIG5hbWUsXG4gICAga2V5OiBpdGVtS2V5IGFzIFByaUtleTxTPixcbiAgICBpdGVtLFxuICAgIGlzTG9hZGluZyxcbiAgICBpc1VwZGF0aW5nLFxuICAgIGlzUmVtb3ZpbmcsXG4gICAgcGFyZW50SXRlbTogbnVsbCxcbiAgICBwa1R5cGVzOiBwa1R5cGVzIGFzIEFsbEl0ZW1UeXBlQXJyYXlzPFM+LFxuICAgIHJlbW92ZSxcbiAgICB1cGRhdGUsXG4gICAgYWN0aW9uLFxuICAgIGZhY2V0LFxuICAgIHNldCxcbiAgICBsb2NhdGlvbnMsXG4gICAgZmFjZXRSZXN1bHRzOiB7fSxcbiAgfTtcblxuICBjb250ZXh0VmFsdWUuYWN0aW9ucyA9IHVzZU1lbW8oKCkgPT4gYWRkQWN0aW9ucyAmJiBhZGRBY3Rpb25zKGNvbnRleHRWYWx1ZS5hY3Rpb24pLCBbYWRkQWN0aW9ucywgY29udGV4dFZhbHVlLmFjdGlvbl0pO1xuICAvLyBjb250ZXh0VmFsdWUuZmFjZXRzID0gdXNlTWVtbygoKSA9PiBhZGRGYWNldHMgJiYgYWRkRmFjZXRzKGNvbnRleHRWYWx1ZS5mYWNldCksIFthZGRGYWNldHMsIGNvbnRleHRWYWx1ZS5mYWNldF0pO1xuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIGNvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IGNvbnRleHRWYWx1ZSxcbiAgICB9LFxuICAgIGNoaWxkcmVuLFxuICApO1xufVxuIiwiXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gXCIuLi9sb2dnZXJcIjtcbmltcG9ydCB7XG4gIGFiYnJldlF1ZXJ5LFxuICBJdGVtLFxuICBJdGVtUXVlcnksXG4gIFByaUtleSxcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VQSXRlbUFkYXB0ZXIgfSBmcm9tIFwiLi9QSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVN0YWJsZUhhc2ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBQSXRlbUxvYWQgfSBmcm9tIFwiLi9QSXRlbUxvYWRcIjtcbmltcG9ydCAqIGFzIFBJdGVtQWRhcHRlciBmcm9tIFwiLi9QSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCAqIGFzIFBJdGVtIGZyb20gXCIuL1BJdGVtXCI7XG5pbXBvcnQgeyB1c2VBc3luY0Vycm9yIH0gZnJvbSBcIi4uL3VzZUFzeW5jRXJyb3JcIjtcblxuY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnUEl0ZW1RdWVyeScpO1xuXG5leHBvcnQgY29uc3QgUEl0ZW1RdWVyeSA9IDxWIGV4dGVuZHMgSXRlbTxTPiwgUyBleHRlbmRzIHN0cmluZz4oe1xuICBuYW1lLFxuICBhZGFwdGVyLFxuICBjaGlsZHJlbixcbiAgY29udGV4dCxcbiAgY29udGV4dE5hbWUsXG4gIGNyZWF0ZSxcbiAgbG9hZGluZyxcbiAgbm90Rm91bmQsXG4gIG9wdGlvbmFsID0gZmFsc2UsXG4gIHF1ZXJ5LFxufToge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBhZGFwdGVyOiBQSXRlbUFkYXB0ZXIuQ29udGV4dDxWLCBTPjtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNvbnRleHQ6IFBJdGVtLkNvbnRleHQ8ViwgUz47XG4gICAgY29udGV4dE5hbWU6IHN0cmluZyxcbiAgICBjcmVhdGU/OiBQYXJ0aWFsPEl0ZW08Uz4+IHwgbnVsbDtcbiAgICBsb2FkaW5nPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG5vdEZvdW5kPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgICBxdWVyeT86IEl0ZW1RdWVyeTtcbiAgfVxuKSA9PiB7XG4gIGNvbnN0IFtpdGVtS2V5LCBzZXRJdGVtS2V5XSA9IFJlYWN0LnVzZVN0YXRlPFByaUtleTxTPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcXVlcnlSdW5uaW5nLCBzZXRRdWVyeVJ1bm5pbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7XG4gIGNvbnN0IHsgdGhyb3dBc3luY0Vycm9yIH0gPSB1c2VBc3luY0Vycm9yKCk7XG5cbiAgLy8gU2luY2Ugd2UgcGFzcyB0aGlzIHRvIHRoZSBhY3Rpb25zIGNvbnN0cnVjdG9yLCBkb24ndCBkZXN0cnVjdHVyZSBpdCB5ZXRcbiAgY29uc3QgUEl0ZW1BZGFwdGVyID0gdXNlUEl0ZW1BZGFwdGVyPFYsIFM+KGFkYXB0ZXIsIGNvbnRleHROYW1lKTtcblxuICAvLyBEZXN0cnVjdHVyZSB0aGUgdmFsdWVzIHdlIG5lZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgY29uc3Qge1xuICAgIG9uZTogb25lSXRlbSxcbiAgICBjcmVhdGU6IGNyZWF0ZUl0ZW0sXG4gIH0gPSB1c2VNZW1vKCgpID0+IFBJdGVtQWRhcHRlciwgW1BJdGVtQWRhcHRlcl0pO1xuXG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdXNlTWVtbygoKSA9PiBjcmVhdGVTdGFibGVIYXNoKHF1ZXJ5KSwgW3F1ZXJ5XSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2dnZXIuZGVmYXVsdChgJHtuYW1lfTogdXNlRWZmZWN0W3F1ZXJ5XWAsIHsgcXVlcnkgfSk7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgc2V0UXVlcnlSdW5uaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgbG9nZ2VyLmRlZmF1bHQoYCR7bmFtZX06IFJ1bm5pbmcgUEl0ZW1Qcm92ZGVyIFF1ZXJ5YCwgeyBxdWVyeTogYWJicmV2UXVlcnkocXVlcnkpIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBvbmVJdGVtKHF1ZXJ5KTtcbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlZmF1bHQoYCR7bmFtZX06IFNldHRpbmcgSXRlbSBLZXkgQWZ0ZXIgb25lSXRlbWAsIHsgaXRlbUtleTogaXRlbS5rZXkgfSk7XG4gICAgICAgICAgICBzZXRJdGVtS2V5KGl0ZW0ua2V5KTtcbiAgICAgICAgICAgIHNldFF1ZXJ5UnVubmluZyhmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KGAke25hbWV9OiBDcmVhdGluZyBuZXcgaXRlbWAsIHsgY3JlYXRlIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IGF3YWl0IGNyZWF0ZUl0ZW0oY3JlYXRlKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KGAke25hbWV9OiBTZXR0aW5nIEl0ZW0gS2V5IEFmdGVyIGNyZWF0ZUl0ZW1gLCB7IGl0ZW1LZXk6IG5ld0l0ZW0ua2V5IH0pO1xuICAgICAgICAgICAgc2V0SXRlbUtleShuZXdJdGVtLmtleSk7XG4gICAgICAgICAgICBzZXRRdWVyeVJ1bm5pbmcoZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgIHNldFF1ZXJ5UnVubmluZyhmYWxzZSk7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgJHtuYW1lfTogUmVxdWlyZWQgSXRlbSBub3QgZm91bmQsIGFuZCBubyBjcmVhdGUgcHJvdmlkZWRgLCB7IHF1ZXJ5LCBvcHRpb25hbCB9KTtcbiAgICAgICAgICAgICAgdGhyb3dBc3luY0Vycm9yKG5ldyBFcnJvcihgUmVxdWlyZWQgSXRlbSBub3QgZm91bmQsIGFuZCBubyBjcmVhdGUgcHJvdmlkZWQgaW4gJHtuYW1lfWApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldFF1ZXJ5UnVubmluZyhmYWxzZSk7XG4gICAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KGAke25hbWV9OiBPcHRpb25hbCBpdGVtIG5vdCBmb3VuZCwgaXRlbSB3aWxsIGJlIG51bGxgLCB7IHF1ZXJ5LCBvcHRpb25hbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWZhdWx0KGAke25hbWV9OiBDcmVhdGluZyBuZXcgaXRlbSBhZnRlciBleGNlcHRpb24gdGhyb3cgZm9yIE5vdEZvdW5kYCwgeyBlcnIsIGNyZWF0ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCBjcmVhdGVJdGVtKGNyZWF0ZSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVmYXVsdChgJHtuYW1lfTogU2V0dGluZyBJdGVtIEtleSBBZnRlciBjcmVhdGVJdGVtIGR1cmluZyBFeGNlcHRpb25gLCB7IGl0ZW1LZXk6IG5ld0l0ZW0ua2V5IH0pO1xuICAgICAgICAgICAgc2V0SXRlbUtleShuZXdJdGVtLmtleSk7XG4gICAgICAgICAgICBzZXRRdWVyeVJ1bm5pbmcoZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgIHNldFF1ZXJ5UnVubmluZyhmYWxzZSk7XG4gICAgICAgICAgICAgIHRocm93QXN5bmNFcnJvcihlcnIgYXMgRXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0UXVlcnlSdW5uaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmRlZmF1bHQoYCR7bmFtZX06IE9wdGlvbmFsIGl0ZW0gbm90IGZvdW5kLCBpdGVtIHdpbGwgYmUgbnVsbGApO1xuICAgICAgICAgICAgICBzZXRJdGVtS2V5KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG4gIH0sIFtxdWVyeVN0cmluZ10pO1xuXG4gIGNvbnN0IHJldHVybkNvbnRleHQgPSBQSXRlbUxvYWQ8ViwgUz4oe1xuICAgIG5hbWUsXG4gICAgaWs6IGl0ZW1LZXksXG4gICAgYWRhcHRlcixcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHROYW1lLFxuICAgIGNoaWxkcmVuLFxuICB9KTtcblxuICBpZiAocXVlcnlSdW5uaW5nKSB7XG4gICAgcmV0dXJuIGxvYWRpbmc7XG4gIH0gZWxzZSBpZiAoaXRlbUtleSB8fCBvcHRpb25hbCkge1xuICAgIHJldHVybiByZXR1cm5Db250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub3RGb3VuZDtcbiAgfVxufVxuIiwiXG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VQSXRlbUFkYXB0ZXIgfSBmcm9tIFwiLi9QSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVN0YWJsZUhhc2ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBQSXRlbUFkYXB0ZXIgZnJvbSBcIi4vUEl0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBQSXRlbXMgZnJvbSBcIi4vUEl0ZW1zXCI7XG5pbXBvcnQgeyBQSXRlbXNQcm92aWRlciB9IGZyb20gXCIuL1BJdGVtc1Byb3ZpZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBQSXRlbXNGYWNldCA9IDxWIGV4dGVuZHMgSXRlbTxTPiwgUyBleHRlbmRzIHN0cmluZz4oXG4gIHtcbiAgICBuYW1lLFxuICAgIGFkYXB0ZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dDogaXRlbXNDb250ZXh0LFxuICAgIGNvbnRleHROYW1lLFxuICAgIGFkYXB0ZXJDb250ZXh0LFxuICAgIGZhY2V0LFxuICAgIGZhY2V0UGFyYW1zID0ge30sXG4gICAgcmVuZGVyRWFjaCxcbiAgfToge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBhZGFwdGVyOiBQSXRlbUFkYXB0ZXIuQ29udGV4dDxWLCBTPjtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNvbnRleHQ6IFBJdGVtcy5Db250ZXh0PFYsIFM+O1xuICAgIGNvbnRleHROYW1lOiBzdHJpbmc7XG4gICAgYWRhcHRlckNvbnRleHQ/OiBzdHJpbmc7XG4gICAgZmFjZXQ6IHN0cmluZyxcbiAgICBmYWNldFBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZT4+LFxuICAgIHJlbmRlckVhY2g/OiAoaXRlbTogVikgPT4gUmVhY3QuUmVhY3ROb2RlO1xuICB9XG4pID0+IHtcblxuICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHRdID0gUmVhY3QudXNlU3RhdGU8YW55PihudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuXG4gIC8vIERlZmF1bHQgYWRhcHRlckNvbnRleHQgdG8gY29udGV4dE5hbWUgKyBcIkFkYXB0ZXJcIiBpZiBub3QgcHJvdmlkZWRcbiAgY29uc3QgYWRhcHRlckNvbnRleHROYW1lID0gYWRhcHRlckNvbnRleHQgfHwgYCR7Y29udGV4dE5hbWV9QWRhcHRlcmA7XG5cbiAgLy8gVHJ5IHRvIGdldCBleGlzdGluZyBjb250ZXh0IGZpcnN0XG4gIGxldCBleGlzdGluZ0NvbnRleHQ6IFBJdGVtcy5Db250ZXh0VHlwZTxWLCBTPiB8IHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICBleGlzdGluZ0NvbnRleHQgPSBQSXRlbXMudXNlUEl0ZW1zKGl0ZW1zQ29udGV4dCwgY29udGV4dE5hbWUpO1xuICB9IGNhdGNoIHtcbiAgICAvLyBObyBleGlzdGluZyBjb250ZXh0LCB3ZSdsbCBjcmVhdGUgYSBuZXcgcHJvdmlkZXJcbiAgfVxuXG4gIC8vIFNpbmNlIHdlIHBhc3MgdGhpcyB0byB0aGUgYWN0aW9ucyBjb25zdHJ1Y3RvciwgZG9uJ3QgZGVzdHJ1Y3R1cmUgaXQgeWV0XG4gIGNvbnN0IGFkYXB0ZXJDb250ZXh0SW5zdGFuY2UgPSB1c2VQSXRlbUFkYXB0ZXI8ViwgUz4oYWRhcHRlciwgYWRhcHRlckNvbnRleHROYW1lKTtcblxuICBjb25zdCBmYWNldFBhcmFtc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RhYmxlSGFzaChmYWNldFBhcmFtcyksIFtmYWNldFBhcmFtc10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGZhY2V0ICYmIGZhY2V0UGFyYW1zICYmIGFkYXB0ZXJDb250ZXh0SW5zdGFuY2UpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmKCBhZGFwdGVyQ29udGV4dEluc3RhbmNlLmFsbEZhY2V0ICkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkYXB0ZXJDb250ZXh0SW5zdGFuY2UuYWxsRmFjZXQoZmFjZXQsIGZhY2V0UGFyYW1zKTtcbiAgICAgICAgICBzZXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFJlc3VsdChudWxsKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfSwgW2ZhY2V0LCBmYWNldFBhcmFtc1N0cmluZ10pO1xuXG4gIC8vIElmIHdlIGhhdmUgYW4gZXhpc3RpbmcgY29udGV4dCwgZW5oYW5jZSBpdCBieSBhZGRpbmcgb3VyIGZhY2V0IHJlc3VsdHNcbiAgaWYgKGV4aXN0aW5nQ29udGV4dCkge1xuICAgIGNvbnN0IGVuaGFuY2VkRmFjZXRSZXN1bHRzID0geyAuLi5leGlzdGluZ0NvbnRleHQuZmFjZXRSZXN1bHRzIH07XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKCFlbmhhbmNlZEZhY2V0UmVzdWx0c1tmYWNldF0pIHtcbiAgICAgICAgZW5oYW5jZWRGYWNldFJlc3VsdHNbZmFjZXRdID0ge307XG4gICAgICB9XG4gICAgICBlbmhhbmNlZEZhY2V0UmVzdWx0c1tmYWNldF0gPSB7XG4gICAgICAgIC4uLmVuaGFuY2VkRmFjZXRSZXN1bHRzW2ZhY2V0XSxcbiAgICAgICAgW2ZhY2V0UGFyYW1zU3RyaW5nXTogcmVzdWx0XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBlbmhhbmNlZCBjb250ZXh0IHZhbHVlXG4gICAgY29uc3QgZW5oYW5jZWRDb250ZXh0VmFsdWU6IFBJdGVtcy5Db250ZXh0VHlwZTxWLCBTPiA9IHtcbiAgICAgIC4uLmV4aXN0aW5nQ29udGV4dCxcbiAgICAgIGZhY2V0UmVzdWx0czogZW5oYW5jZWRGYWNldFJlc3VsdHMsXG4gICAgfTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgaXRlbXNDb250ZXh0LlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogZW5oYW5jZWRDb250ZXh0VmFsdWUsXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9XG5cbiAgLy8gTm8gZXhpc3RpbmcgY29udGV4dCwgY3JlYXRlIGEgbmV3IHByb3ZpZGVyXG4gIGNvbnN0IGluaXRpYWxGYWNldFJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIGFueT4+ID0ge307XG4gIGlmIChyZXN1bHQpIHtcbiAgICBpbml0aWFsRmFjZXRSZXN1bHRzW2ZhY2V0XSA9IHsgW2ZhY2V0UGFyYW1zU3RyaW5nXTogcmVzdWx0IH07XG4gIH1cblxuICByZXR1cm4gUEl0ZW1zUHJvdmlkZXI8ViwgUz4oe1xuICAgIG5hbWUsXG4gICAgYWRhcHRlcixcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0OiBpdGVtc0NvbnRleHQsXG4gICAgY29udGV4dE5hbWU6IGNvbnRleHROYW1lLFxuICAgIHJlbmRlckVhY2gsXG4gICAgZmFjZXRSZXN1bHRzOiBpbml0aWFsRmFjZXRSZXN1bHRzLFxuICAgIGlzTG9hZGluZ1BhcmFtOiBpc0xvYWRpbmcsXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgQWxsSXRlbVR5cGVBcnJheXMsIEl0ZW0sIFByaUtleSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUVsZW1lbnQsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVBJdGVtQWRhcHRlciB9IGZyb20gXCIuL1BJdGVtQWRhcHRlclwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBjcmVhdGVTdGFibGVIYXNoIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgUEl0ZW1BZGFwdGVyIGZyb20gXCIuL1BJdGVtQWRhcHRlclwiO1xuaW1wb3J0ICogYXMgUEl0ZW1zIGZyb20gXCIuL1BJdGVtc1wiO1xuXG5leHBvcnQgY29uc3QgUEl0ZW1zUHJvdmlkZXIgPSA8ViBleHRlbmRzIEl0ZW08Uz4sIFMgZXh0ZW5kcyBzdHJpbmc+KFxuICB7XG4gICAgbmFtZSxcbiAgICBpdGVtcyA9IFtdLFxuICAgIGZhY2V0UmVzdWx0cyA9IHt9LFxuICAgIGFkYXB0ZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjb250ZXh0TmFtZSxcbiAgICByZW5kZXJFYWNoLFxuICAgIGlzTG9hZGluZ1BhcmFtID0gZmFsc2UsXG4gICAgb3ZlcnJpZGVzLFxuICB9OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGl0ZW1zPzogVltdO1xuICAgIGZhY2V0UmVzdWx0cz86IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIGFueT4+O1xuICAgIGFkYXB0ZXI6IFBJdGVtQWRhcHRlci5Db250ZXh0PFYsIFM+O1xuICAgIGFkZFF1ZXJpZXM/OiAoY29udGV4dFZhbHVlczogUEl0ZW1zLkNvbnRleHRUeXBlPFYsIFM+KSA9PlxuICAgICAgUmVjb3JkPHN0cmluZywgKC4uLnBhcmFtczogYW55KSA9PiBQcm9taXNlPHN0cmluZyB8IGJvb2xlYW4gfCBudW1iZXIgfCBudWxsPj47XG4gICAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBjb250ZXh0OiBQSXRlbXMuQ29udGV4dDxWLCBTPjtcbiAgICBjb250ZXh0TmFtZTogc3RyaW5nO1xuICAgIHJlbmRlckVhY2g/OiAoaXRlbTogVikgPT4gUmVhY3QuUmVhY3ROb2RlO1xuICAgIGlzTG9hZGluZ1BhcmFtPzogYm9vbGVhbjtcbiAgICBvdmVycmlkZXM/OiB7XG4gICAgICBhbGw/OiAoKSA9PiBQcm9taXNlPFZbXSB8IG51bGw+O1xuICAgICAgb25lPzogKCkgPT4gUHJvbWlzZTxWIHwgbnVsbD47XG4gICAgfTtcbiAgfVxuKSA9PiB7XG5cbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuICBjb25zdCBbaXNDcmVhdGluZywgc2V0SXNDcmVhdGluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtpc1VwZGF0aW5nLCBzZXRJc1VwZGF0aW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2lzUmVtb3ZpbmcsIHNldElzUmVtb3ZpbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8vIFNpbmNlIHdlIHBhc3MgdGhpcyB0byB0aGUgYWN0aW9ucyBjb25zdHJ1Y3RvciwgZG9uJ3QgZGVzdHJ1Y3R1cmUgaXQgeWV0XG4gIGNvbnN0IGFkYXB0ZXJDb250ZXh0ID0gdXNlUEl0ZW1BZGFwdGVyPFYsIFM+KGFkYXB0ZXIsIGNvbnRleHROYW1lKTtcblxuICAvLyBEZXN0cnVjdHVyZSB0aGUgdmFsdWVzIHdlIG5lZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgY29uc3Qge1xuICAgIHBrVHlwZXMsXG4gICAgYWxsOiBhbGxJdGVtcyxcbiAgICBvbmU6IG9uZUl0ZW0sXG4gICAgY3JlYXRlOiBjcmVhdGVJdGVtLFxuICAgIHVwZGF0ZTogdXBkYXRlSXRlbSxcbiAgICByZW1vdmU6IHJlbW92ZUl0ZW0sXG4gICAgYWxsQWN0aW9uOiBhbGxJdGVtQWN0aW9uLFxuICAgIGFsbEZhY2V0OiBhbGxJdGVtRmFjZXQsXG4gICAgc2V0OiBzZXRJdGVtLFxuICAgIGFjdGlvbjogYWN0aW9uSXRlbSxcbiAgICBmYWNldDogZmFjZXRJdGVtLFxuICAgIGZpbmQ6IGZpbmRJdGVtLFxuICAgIGZpbmRPbmU6IGZpbmRPbmVJdGVtLFxuICAgIGFkZEFsbEFjdGlvbnMsXG4gICAgYWRkQWxsRmFjZXRzLFxuICB9ID0gYWRhcHRlckNvbnRleHQ7XG5cbiAgY29uc3QgbG9nZ2VyID0gTGliTG9nZ2VyLmdldCgnUEl0ZW1zUHJvdmlkZXInLCBjcmVhdGVTdGFibGVIYXNoKHBrVHlwZXMpKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzTG9hZGluZyhpc0xvYWRpbmdQYXJhbSk7XG4gIH0sIFtpc0xvYWRpbmdQYXJhbV0pO1xuXG4gIGNvbnN0IGFsbCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ2FsbCcpO1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGFsbEl0ZW1zKHt9KSBhcyBWW10gfCBudWxsO1xuICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgbG9nZ2VyLmRlYnVnKCdJdGVtcyBSZXR1cm5lZCBmb3IgQWxsJywgeyBpdGVtcyB9KTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH0sIFthbGxJdGVtc10pO1xuXG4gIGNvbnN0IG9uZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ29uZScpO1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgb25lSXRlbSh7fSkgYXMgViB8IG51bGw7XG4gICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSwgW29uZUl0ZW1dKTtcblxuICBjb25zdCBjcmVhdGUgPSB1c2VDYWxsYmFjayhhc3luYyAoaXRlbTogUGFydGlhbDxJdGVtPFM+PikgPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnY3JlYXRlJywgeyBpdGVtIH0pO1xuICAgIHNldElzQ3JlYXRpbmcodHJ1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlSXRlbShpdGVtKSBhcyBWO1xuICAgIHNldElzQ3JlYXRpbmcoZmFsc2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtjcmVhdGVJdGVtXSk7XG5cbiAgY29uc3QgdXBkYXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKGtleTogUHJpS2V5PFM+LFxuICAgIGl0ZW06IFBhcnRpYWw8SXRlbTxTPj4pID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3VwZGF0ZScsIHsga2V5LCBpdGVtIH0pO1xuICAgIHNldElzVXBkYXRpbmcodHJ1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBkYXRlSXRlbShrZXksIGl0ZW0pIGFzIFY7XG4gICAgc2V0SXNVcGRhdGluZyhmYWxzZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW3VwZGF0ZUl0ZW1dKTtcblxuICBjb25zdCByZW1vdmUgPSB1c2VDYWxsYmFjayhhc3luYyAoa2V5OiBQcmlLZXk8Uz4pID0+IHtcbiAgICBsb2dnZXIudHJhY2UoJ3JlbW92ZScsIHsga2V5IH0pO1xuICAgIHNldElzUmVtb3ZpbmcodHJ1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVtb3ZlSXRlbShrZXkpO1xuICAgIHNldElzUmVtb3ZpbmcoZmFsc2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtyZW1vdmVJdGVtXSk7XG5cbiAgY29uc3QgYWxsQWN0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFjdGlvbjogc3RyaW5nLCBib2R5OiBhbnkgPSB7fSkgPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnYWxsQWN0aW9uJywgeyBhY3Rpb24sIGJvZHkgfSk7XG4gICAgc2V0SXNVcGRhdGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWxsSXRlbUFjdGlvbihhY3Rpb24sIGJvZHkpIGFzIFZbXSB8IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1VwZGF0aW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFthbGxJdGVtQWN0aW9uXSk7XG5cbiAgY29uc3QgYWxsRmFjZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoZmFjZXQ6IHN0cmluZywgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4gPSB7fSkgPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnYWxsRmFjZXQnLCB7IGZhY2V0LCBwYXJhbXMgfSk7XG4gICAgc2V0SXNVcGRhdGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWxsSXRlbUZhY2V0KGZhY2V0LCBwYXJhbXMpIGFzIGFueTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2FsbEl0ZW1GYWNldF0pO1xuXG4gIGNvbnN0IGFjdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChrZXk6IFByaUtleTxTPiwgYWN0aW9uOiBzdHJpbmcsIGJvZHk6IGFueSkgPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnYWN0aW9uJywgeyBrZXksIGFjdGlvbiwgYm9keSB9KTtcbiAgICBzZXRJc1VwZGF0aW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb25JdGVtKGtleSwgYWN0aW9uLCBib2R5KSBhcyBWO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNVcGRhdGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbYWN0aW9uSXRlbV0pO1xuXG4gIGNvbnN0IGZhY2V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGtleTogUHJpS2V5PFM+LCBmYWNldDogc3RyaW5nLCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PiA9IHt9KSA9PiB7XG4gICAgbG9nZ2VyLnRyYWNlKCdmYWNldCcsIHsga2V5LCBmYWNldCwgcGFyYW1zIH0pO1xuICAgIHNldElzVXBkYXRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZhY2V0SXRlbShrZXksIGZhY2V0LCBwYXJhbXMpIGFzIGFueTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzVXBkYXRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2ZhY2V0SXRlbV0pO1xuXG4gIGNvbnN0IGZpbmQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4ge1xuICAgIHJldHVybiBmaW5kSXRlbShmaW5kZXIsIGZpbmRlclBhcmFtcyk7XG4gIH0sIFtmaW5kSXRlbV0pO1xuXG4gIGNvbnN0IGZpbmRPbmUgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgZmluZGVyOiBzdHJpbmcsXG4gICAgZmluZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IEFycmF5PHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlPj4sXG4gICkgPT4ge1xuICAgIHJldHVybiBmaW5kT25lSXRlbSAmJiBmaW5kT25lSXRlbShmaW5kZXIsIGZpbmRlclBhcmFtcyk7XG4gIH0sIFtmaW5kT25lSXRlbV0pO1xuXG4gIGNvbnN0IHNldCA9IHVzZUNhbGxiYWNrKGFzeW5jIChrZXk6IFByaUtleTxTPiwgaXRlbTogVikgPT4ge1xuICAgIGxvZ2dlci50cmFjZSgnc2V0JywgeyBrZXksIGl0ZW0gfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0SXRlbShrZXksIGl0ZW0pIGFzIFY7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW3NldEl0ZW1dKTtcblxuICBjb25zdCBjb250ZXh0VmFsdWU6IFBJdGVtcy5Db250ZXh0VHlwZTxWLCBTPiA9IHtcbiAgICBuYW1lLFxuICAgIHBrVHlwZXM6IHBrVHlwZXMgYXMgQWxsSXRlbVR5cGVBcnJheXM8Uz4sXG4gICAgaXRlbXMsXG4gICAgaXNMb2FkaW5nLFxuICAgIGlzQ3JlYXRpbmcsXG4gICAgaXNVcGRhdGluZyxcbiAgICBpc1JlbW92aW5nLFxuICAgIGZhY2V0UmVzdWx0czogZmFjZXRSZXN1bHRzIHx8IHt9LFxuICAgIGNyZWF0ZSxcbiAgICB1cGRhdGUsXG4gICAgcmVtb3ZlLFxuICAgIGFsbDogb3ZlcnJpZGVzPy5hbGwgfHwgYWxsLFxuICAgIG9uZTogb3ZlcnJpZGVzPy5vbmUgfHwgb25lLFxuICAgIGFsbEFjdGlvbixcbiAgICBhbGxGYWNldCxcbiAgICBmaW5kLFxuICAgIGZpbmRPbmUsXG4gICAgc2V0LFxuICAgIGFjdGlvbixcbiAgICBmYWNldCxcbiAgfTtcblxuICBjb250ZXh0VmFsdWUuYWxsQWN0aW9ucyA9IHVzZU1lbW8oKCkgPT4gYWRkQWxsQWN0aW9ucyAmJiBhZGRBbGxBY3Rpb25zKGNvbnRleHRWYWx1ZS5hbGxBY3Rpb24pLCBbYWRkQWxsQWN0aW9ucywgY29udGV4dFZhbHVlLmFsbEFjdGlvbl0pO1xuICBjb250ZXh0VmFsdWUuYWxsRmFjZXRzID0gdXNlTWVtbygoKSA9PiBhZGRBbGxGYWNldHMgJiYgYWRkQWxsRmFjZXRzKGNvbnRleHRWYWx1ZS5hbGxGYWNldCksIFthZGRBbGxGYWNldHMsIGNvbnRleHRWYWx1ZS5hbGxGYWNldF0pO1xuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIGNvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IGNvbnRleHRWYWx1ZSxcbiAgICB9LFxuICAgIChcbiAgICAgIDw+XG4gICAgICAgIHtyZW5kZXJFYWNoICYmIGl0ZW1zICYmIGl0ZW1zLm1hcCgoaXRlbSkgPT4gcmVuZGVyRWFjaChpdGVtKSl9XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvPlxuICAgICkpO1xufVxuIiwiXG5pbXBvcnQgeyBJdGVtIH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VQSXRlbUFkYXB0ZXIgfSBmcm9tIFwiLi9QSXRlbUFkYXB0ZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVN0YWJsZUhhc2ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBQSXRlbUFkYXB0ZXIgZnJvbSBcIi4vUEl0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBQSXRlbXMgZnJvbSBcIi4vUEl0ZW1zXCI7XG5pbXBvcnQgeyBQSXRlbXNQcm92aWRlciB9IGZyb20gXCIuL1BJdGVtc1Byb3ZpZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBQSXRlbXNGaW5kID0gPFYgZXh0ZW5kcyBJdGVtPFM+LCBTIGV4dGVuZHMgc3RyaW5nPihcbiAge1xuICAgIG5hbWUsXG4gICAgYWRhcHRlcixcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHROYW1lLFxuICAgIGZpbmRlcixcbiAgICBmaW5kZXJQYXJhbXMgPSB7fSxcbiAgICByZW5kZXJFYWNoLFxuICB9OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGFkYXB0ZXI6IFBJdGVtQWRhcHRlci5Db250ZXh0PFYsIFM+O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgY29udGV4dDogUEl0ZW1zLkNvbnRleHQ8ViwgUz47XG4gICAgY29udGV4dE5hbWU6IHN0cmluZztcbiAgICBmaW5kZXI6IHN0cmluZyxcbiAgICBmaW5kZXJQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGU+PixcbiAgICByZW5kZXJFYWNoPzogKGl0ZW06IFYpID0+IFJlYWN0LlJlYWN0Tm9kZTtcbiAgfVxuKSA9PiB7XG5cbiAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSBSZWFjdC51c2VTdGF0ZTxWW10gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuICAvLyBTaW5jZSB3ZSBwYXNzIHRoaXMgdG8gdGhlIGFjdGlvbnMgY29uc3RydWN0b3IsIGRvbid0IGRlc3RydWN0dXJlIGl0IHlldFxuICBjb25zdCBhZGFwdGVyQ29udGV4dCA9IHVzZVBJdGVtQWRhcHRlcjxWLCBTPihhZGFwdGVyLCBjb250ZXh0TmFtZSk7XG5cbiAgY29uc3QgZmluZGVyUGFyYW1zU3RyaW5nID0gdXNlTWVtbygoKSA9PiBjcmVhdGVTdGFibGVIYXNoKGZpbmRlclBhcmFtcyksIFtmaW5kZXJQYXJhbXNdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChmaW5kZXIgJiYgZmluZGVyUGFyYW1zICYmIGFkYXB0ZXJDb250ZXh0KSB7XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiggYWRhcHRlckNvbnRleHQuZmluZCApIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGFwdGVyQ29udGV4dC5maW5kKGZpbmRlciwgZmluZGVyUGFyYW1zKTtcbiAgICAgICAgICBzZXRJdGVtcyhyZXN1bHQgYXMgVltdIHwgbnVsbCk7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRJdGVtcyhudWxsKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfSwgW2ZpbmRlciwgZmluZGVyUGFyYW1zU3RyaW5nXSk7XG5cbiAgcmV0dXJuIFBJdGVtc1Byb3ZpZGVyPFYsIFM+KHtcbiAgICBuYW1lLFxuICAgIGFkYXB0ZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjb250ZXh0TmFtZSxcbiAgICByZW5kZXJFYWNoLFxuICAgIGl0ZW1zOiBpdGVtcyB8fCBbXSxcbiAgICBpc0xvYWRpbmdQYXJhbTogaXNMb2FkaW5nLFxuICB9KTtcbn1cbiIsIlxuaW1wb3J0IHsgSXRlbSwgSXRlbVF1ZXJ5IH0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVBJdGVtQWRhcHRlciB9IGZyb20gXCIuL1BJdGVtQWRhcHRlclwiO1xuXG5pbXBvcnQgTGliTG9nZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgKiBhcyBQSXRlbUFkYXB0ZXIgZnJvbSBcIi4vUEl0ZW1BZGFwdGVyXCI7XG5pbXBvcnQgKiBhcyBQSXRlbXMgZnJvbSBcIi4vUEl0ZW1zXCI7XG5pbXBvcnQgeyBQSXRlbXNQcm92aWRlciB9IGZyb20gXCIuL1BJdGVtc1Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVTdGFibGVIYXNoIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBsb2dnZXIgPSBMaWJMb2dnZXIuZ2V0KCdQSXRlbXNRdWVyeScpO1xuXG5leHBvcnQgY29uc3QgUEl0ZW1zUXVlcnkgPSA8ViBleHRlbmRzIEl0ZW08Uz4sIFMgZXh0ZW5kcyBzdHJpbmc+KFxuICB7XG4gICAgbmFtZSxcbiAgICBhZGFwdGVyLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHQsXG4gICAgY29udGV4dE5hbWUsXG4gICAgcXVlcnkgPSB7fSxcbiAgICByZW5kZXJFYWNoLFxuICB9OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGFkYXB0ZXI6IFBJdGVtQWRhcHRlci5Db250ZXh0PFYsIFM+O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgY29udGV4dDogUEl0ZW1zLkNvbnRleHQ8ViwgUz47XG4gICAgY29udGV4dE5hbWU6IHN0cmluZztcbiAgICBxdWVyeT86IEl0ZW1RdWVyeTtcbiAgICByZW5kZXJFYWNoPzogKGl0ZW06IFYpID0+IFJlYWN0LlJlYWN0Tm9kZTtcbiAgfVxuKSA9PiB7XG5cbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuICAvLyBTaW5jZSB3ZSBwYXNzIHRoaXMgdG8gdGhlIGFjdGlvbnMgY29uc3RydWN0b3IsIGRvbid0IGRlc3RydWN0dXJlIGl0IHlldFxuICBjb25zdCBhZGFwdGVyQ29udGV4dCA9IHVzZVBJdGVtQWRhcHRlcjxWLCBTPihhZGFwdGVyLCBjb250ZXh0TmFtZSk7XG5cbiAgLy8gRGVzdHJ1Y3R1cmUgdGhlIHZhbHVlcyB3ZSBuZWVkIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gIGNvbnN0IHtcbiAgICBhbGw6IGFsbEl0ZW1zLFxuICAgIG9uZTogb25lSXRlbSxcbiAgfSA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlckNvbnRleHQsIFthZGFwdGVyQ29udGV4dF0pO1xuXG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdXNlTWVtbygoKSA9PiBjcmVhdGVTdGFibGVIYXNoKHF1ZXJ5KSwgW3F1ZXJ5XSk7XG4gIGNvbnN0IFtpdGVtcywgc2V0SXRlbXNdID0gdXNlU3RhdGU8VltdPihbXSk7XG5cbiAgLy8gTG9hZCBpdGVtcyB3aGVuIHF1ZXJ5IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKCd1c2VFZmZlY3RbcXVlcnlTdHJpbmddICVzJywgY3JlYXRlU3RhYmxlSGFzaChxdWVyeSkpO1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBhbGxJdGVtcyhxdWVyeSwgW10pO1xuICAgICAgICBzZXRJdGVtcyhyZXN1bHRzIGFzIFZbXSB8fCBbXSk7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYCR7bmFtZX06IEVycm9yIGxvYWRpbmcgaXRlbXM6YCwgZXJyb3IpO1xuICAgICAgICBzZXRJdGVtcyhbXSk7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIC8vIERvbid0IHRocm93IGhlcmUgYXMgdGhpcyB3b3VsZCBiZSBsb3N0IGluIHRoZSBhc3luYyBjb250ZXh0XG4gICAgICAgIC8vIExldCB0aGUgYWxsL29uZSBvdmVycmlkZSBmdW5jdGlvbnMgaGFuZGxlIGVycm9yIHRocm93aW5nXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSwgW3F1ZXJ5U3RyaW5nLCBhbGxJdGVtcywgbmFtZV0pO1xuXG4gIGNvbnN0IGFsbCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdhbGwnLCB7IHF1ZXJ5IH0pO1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBhbGxJdGVtcyhxdWVyeSwgW10pIGFzIFZbXSB8IG51bGw7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdJdGVtcyBSZXR1cm5lZCBmb3IgQWxsJywgeyBpdGVtcyB9KTtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBpbiBhbGw6JywgZXJyb3IpO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSwgW2FsbEl0ZW1zXSk7XG5cbiAgY29uc3Qgb25lID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ29uZScsIHsgcXVlcnkgfSk7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgb25lSXRlbShxdWVyeSkgYXMgViB8IG51bGw7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gb25lOicsIGVycm9yKTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sIFtvbmVJdGVtXSk7XG5cbiAgcmV0dXJuIFBJdGVtc1Byb3ZpZGVyPFYsIFM+KHtcbiAgICBuYW1lLFxuICAgIGFkYXB0ZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjb250ZXh0TmFtZSxcbiAgICByZW5kZXJFYWNoLFxuICAgIGl0ZW1zLFxuICAgIGlzTG9hZGluZ1BhcmFtOiBpc0xvYWRpbmcsXG4gICAgb3ZlcnJpZGVzOiB7XG4gICAgICBhbGwsXG4gICAgICBvbmUsXG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gJ0BmamVsbC9jYWNoZSc7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSAnQGZqZWxsL2NvcmUnO1xuaW1wb3J0IHsgQ2FjaGVFdmVudExpc3RlbmVyLCBDYWNoZVN1YnNjcmlwdGlvbiwgQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zIH0gZnJvbSAnQGZqZWxsL2NhY2hlJztcblxuLyoqXG4gKiBSZWFjdCBob29rIGZvciBzdWJzY3JpYmluZyB0byBjYWNoZSBldmVudHNcbiAqXG4gKiBAcGFyYW0gY2FjaGUgVGhlIGNhY2hlIGluc3RhbmNlIHRvIHN1YnNjcmliZSB0b1xuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBldmVudCBsaXN0ZW5lciBmdW5jdGlvblxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgc3Vic2NyaXB0aW9uIG9wdGlvbnMgZm9yIGZpbHRlcmluZyBldmVudHNcbiAqIEByZXR1cm5zIFRoZSBhY3RpdmUgc3Vic2NyaXB0aW9uIChmb3IgbWFudWFsIG1hbmFnZW1lbnQgaWYgbmVlZGVkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FjaGVTdWJzY3JpcHRpb248XG4gIFYgZXh0ZW5kcyBJdGVtPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4sXG4gIFMgZXh0ZW5kcyBzdHJpbmcsXG4gIEwxIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwyIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEwzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw0IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsXG4gIEw1IGV4dGVuZHMgc3RyaW5nID0gbmV2ZXJcbj4oXG4gIGNhY2hlOiBDYWNoZTxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgbnVsbCxcbiAgbGlzdGVuZXI6IENhY2hlRXZlbnRMaXN0ZW5lcjxWLCBTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBvcHRpb25zPzogQ2FjaGVTdWJzY3JpcHRpb25PcHRpb25zPFMsIEwxLCBMMiwgTDMsIEw0LCBMNT5cbik6IENhY2hlU3Vic2NyaXB0aW9uIHwgbnVsbCB7XG4gIGNvbnN0IHN1YnNjcmlwdGlvblJlZiA9IHVzZVJlZjxDYWNoZVN1YnNjcmlwdGlvbiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsaXN0ZW5lclJlZiA9IHVzZVJlZjxDYWNoZUV2ZW50TGlzdGVuZXI8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1Pj4obGlzdGVuZXIpO1xuICBjb25zdCBvcHRpb25zUmVmID0gdXNlUmVmKG9wdGlvbnMpO1xuXG4gIC8vIFVwZGF0ZSByZWZzIHdoZW4gcHJvcHMgY2hhbmdlIGJ1dCBkb24ndCByZWNyZWF0ZSBzdWJzY3JpcHRpb25cbiAgbGlzdGVuZXJSZWYuY3VycmVudCA9IGxpc3RlbmVyO1xuICBvcHRpb25zUmVmLmN1cnJlbnQgPSBvcHRpb25zO1xuXG4gIC8vIFN0YWJsZSB3cmFwcGVyIHRoYXQgY2FsbHMgdGhlIGN1cnJlbnQgbGlzdGVuZXJcbiAgY29uc3Qgc3RhYmxlTGlzdGVuZXIgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IGFueSkgPT4ge1xuICAgIGxpc3RlbmVyUmVmLmN1cnJlbnQoZXZlbnQpO1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uIGlmIGNhY2hlIGJlY29tZXMgbnVsbFxuICAgICAgaWYgKHN1YnNjcmlwdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN1YnNjcmlwdGlvblJlZi5jdXJyZW50LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvblJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gY2FjaGUgZXZlbnRzIHdpdGggc3RhYmxlIG9wdGlvbnNcbiAgICBjb25zdCBzdWJzY3JpcHRpb25PcHRpb25zID0gb3B0aW9uc1JlZi5jdXJyZW50ID8ge1xuICAgICAgLi4ub3B0aW9uc1JlZi5jdXJyZW50LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgICAgZXZlbnRUeXBlczogb3B0aW9uc1JlZi5jdXJyZW50LmV2ZW50VHlwZXMgPyBbLi4ub3B0aW9uc1JlZi5jdXJyZW50LmV2ZW50VHlwZXNdIDogdW5kZWZpbmVkXG4gICAgfSA6IHt9O1xuXG4gICAgc3Vic2NyaXB0aW9uUmVmLmN1cnJlbnQgPSBjYWNoZS5zdWJzY3JpYmUoc3RhYmxlTGlzdGVuZXIsIHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuXG4gICAgLy8gQ2xlYW51cCBzdWJzY3JpcHRpb24gb24gdW5tb3VudCBvciBjYWNoZSBjaGFuZ2VcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN1YnNjcmlwdGlvblJlZi5jdXJyZW50LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvblJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY2FjaGUsIHN0YWJsZUxpc3RlbmVyLCBvcHRpb25zXSk7IC8vIFJlY3JlYXRlIHdoZW4gY2FjaGUgb3Igb3B0aW9ucyBjaGFuZ2VcblxuICByZXR1cm4gc3Vic2NyaXB0aW9uUmVmLmN1cnJlbnQ7XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENhY2hlLCBDYWNoZUV2ZW50VHlwZSwgbm9ybWFsaXplS2V5VmFsdWUgfSBmcm9tICdAZmplbGwvY2FjaGUnO1xuaW1wb3J0IHsgQ29tS2V5LCBJdGVtLCBQcmlLZXkgfSBmcm9tICdAZmplbGwvY29yZSc7XG5pbXBvcnQgeyB1c2VDYWNoZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4vdXNlQ2FjaGVTdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgY3JlYXRlU3RhYmxlSGFzaCB9IGZyb20gJy4uL3V0aWxzJztcblxuLyoqXG4gKiBSZWFjdCBob29rIGZvciBzdWJzY3JpYmluZyB0byBhIHNwZWNpZmljIGNhY2hlIGl0ZW1cbiAqXG4gKiBAcGFyYW0gY2FjaGUgVGhlIGNhY2hlIGluc3RhbmNlXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gdHJhY2tcbiAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGl0ZW0gdmFsdWUgYW5kIGxvYWRpbmcgc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhY2hlSXRlbTxcbiAgViBleHRlbmRzIEl0ZW08UywgTDEsIEwyLCBMMywgTDQsIEw1PixcbiAgUyBleHRlbmRzIHN0cmluZyxcbiAgTDEgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDIgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDQgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgTDUgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlclxuPihcbiAgY2FjaGU6IENhY2hlPFYsIFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBudWxsLFxuICBrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+IHwgbnVsbFxuKToge1xuICBpdGVtOiBWIHwgbnVsbDtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICByZWZldGNoOiAoKSA9PiBQcm9taXNlPFYgfCBudWxsPjtcbn0ge1xuICBjb25zdCBbaXRlbSwgc2V0SXRlbV0gPSB1c2VTdGF0ZTxWIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcblxuICAvLyBMb2FkIGluaXRpYWwgaXRlbSBmcm9tIGNhY2hlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYWNoZSB8fCAha2V5KSB7XG4gICAgICBzZXRJdGVtKG51bGwpO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCBpdGVtIGZyb20gY2FjaGVcbiAgICBjb25zdCBjYWNoZWRJdGVtID0gY2FjaGUuY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgc2V0SXRlbShjYWNoZWRJdGVtKTtcbiAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICB9LCBbY2FjaGUsIGtleV0pO1xuXG4gIC8vIE5vcm1hbGl6ZSBhIGtleSBmb3IgY29tcGFyaXNvbiAoc2FtZSBsb2dpYyBhcyBDYWNoZUV2ZW50RW1pdHRlcilcbiAgY29uc3Qgbm9ybWFsaXplS2V5ID0gdXNlQ2FsbGJhY2soKGtleTogQ29tS2V5PFMsIEwxLCBMMiwgTDMsIEw0LCBMNT4gfCBQcmlLZXk8Uz4pOiBzdHJpbmcgPT4ge1xuICAgIC8vIE5vcm1hbGl6ZSBzdHJpbmcvbnVtYmVyIHZhbHVlcyBpbiB0aGUga2V5IChzYW1lIGxvZ2ljIGFzIENhY2hlRXZlbnRFbWl0dGVyKSBmaXJzdCxcbiAgICAvLyB0aGVuIHByb2R1Y2UgYSBzdGFibGUsIGNpcmN1bGFyLXNhZmUgc3RyaW5nIHVzaW5nIGNyZWF0ZVN0YWJsZUhhc2hcbiAgICBjb25zdCBub3JtYWxpemVkID0gKCgpOiBhbnkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZXIgPSAodmFsdWU6IGFueSk6IGFueSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplS2V5VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLm1hcChyZXBsYWNlcik7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY29uc3Qgb3V0OiBhbnkgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModmFsdWUpKSBvdXRba10gPSByZXBsYWNlcigodmFsdWUgYXMgYW55KVtrXSk7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlcGxhY2VyKGtleSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gY3JlYXRlU3RhYmxlSGFzaChub3JtYWxpemVkKTtcbiAgfSwgW10pO1xuXG4gIC8vIENyZWF0ZSBldmVudCBsaXN0ZW5lciB0byB1cGRhdGUgaXRlbSB3aGVuIGl0IGNoYW5nZXNcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHVzZUNhbGxiYWNrKChldmVudDogYW55KSA9PiB7XG4gICAgaWYgKCFrZXkpIHJldHVybjtcblxuICAgIGNvbnN0IGtleVN0cmluZyA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdpdGVtX2NyZWF0ZWQnOlxuICAgICAgY2FzZSAnaXRlbV91cGRhdGVkJzpcbiAgICAgIGNhc2UgJ2l0ZW1fcmV0cmlldmVkJzpcbiAgICAgIGNhc2UgJ2l0ZW1fc2V0JzpcbiAgICAgICAgaWYgKG5vcm1hbGl6ZUtleShldmVudC5rZXkpID09PSBrZXlTdHJpbmcpIHtcbiAgICAgICAgICBzZXRJdGVtKGV2ZW50Lml0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpdGVtX3JlbW92ZWQnOlxuICAgICAgICBpZiAobm9ybWFsaXplS2V5KGV2ZW50LmtleSkgPT09IGtleVN0cmluZykge1xuICAgICAgICAgIHNldEl0ZW0obnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NhY2hlX2NsZWFyZWQnOlxuICAgICAgICBzZXRJdGVtKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sIFtrZXksIG5vcm1hbGl6ZUtleV0pO1xuXG4gIC8vIFN1YnNjcmlwdGlvbiBvcHRpb25zIHRvIGZpbHRlciBldmVudHMgZm9yIHRoaXMgc3BlY2lmaWMga2V5XG4gIGNvbnN0IHN1YnNjcmlwdGlvbk9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgaWYgKCFrZXkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2V5czogW2tleV0sXG4gICAgICBldmVudFR5cGVzOiBbJ2l0ZW1fY3JlYXRlZCcsICdpdGVtX3VwZGF0ZWQnLCAnaXRlbV9yZW1vdmVkJywgJ2l0ZW1fcmV0cmlldmVkJywgJ2l0ZW1fc2V0JywgJ2NhY2hlX2NsZWFyZWQnXSBhcyBDYWNoZUV2ZW50VHlwZVtdXG4gICAgfTtcbiAgfSwgW2tleV0pO1xuXG4gIC8vIFN1YnNjcmliZSB0byBjYWNoZSBldmVudHNcbiAgdXNlQ2FjaGVTdWJzY3JpcHRpb24oY2FjaGUsIGV2ZW50TGlzdGVuZXIsIHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuXG4gIC8vIFJlZmV0Y2ggZnVuY3Rpb24gdG8gbWFudWFsbHkgcmVsb2FkIHRoZSBpdGVtXG4gIGNvbnN0IHJlZmV0Y2ggPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxWIHwgbnVsbD4gPT4ge1xuICAgIGlmICghY2FjaGUgfHwgIWtleSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBbLCByZXN1bHRdID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5nZXQoa2V5KTtcbiAgICAgIHNldEl0ZW0ocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZmV0Y2hpbmcgaXRlbTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtjYWNoZSwga2V5XSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpdGVtLFxuICAgIGlzTG9hZGluZyxcbiAgICByZWZldGNoXG4gIH07XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENhY2hlLCBDYWNoZUV2ZW50VHlwZSwgbm9ybWFsaXplS2V5VmFsdWUgfSBmcm9tICdAZmplbGwvY2FjaGUnO1xuaW1wb3J0IHsgQ29tS2V5LCBJdGVtLCBJdGVtUXVlcnksIExvY0tleUFycmF5LCBQcmlLZXkgfSBmcm9tICdAZmplbGwvY29yZSc7XG5pbXBvcnQgeyB1c2VDYWNoZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4vdXNlQ2FjaGVTdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgY3JlYXRlU3RhYmxlSGFzaCwgZGVlcEVxdWFsIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vKipcbiAqIFJlYWN0IGhvb2sgZm9yIHN1YnNjcmliaW5nIHRvIGNhY2hlIHF1ZXJ5IHJlc3VsdHNcbiAqXG4gKiBAcGFyYW0gY2FjaGUgVGhlIGNhY2hlIGluc3RhbmNlXG4gKiBAcGFyYW0gcXVlcnkgVGhlIHF1ZXJ5IHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSBsb2NhdGlvbnMgT3B0aW9uYWwgbG9jYXRpb25zIHRvIHF1ZXJ5IGluXG4gKiBAcmV0dXJucyBUaGUgY3VycmVudCBxdWVyeSByZXN1bHRzIGFuZCBsb2FkaW5nIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWNoZVF1ZXJ5PFxuICBWIGV4dGVuZHMgSXRlbTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+LFxuICBTIGV4dGVuZHMgc3RyaW5nLFxuICBMMSBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMiBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMMyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNCBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuICBMNSBleHRlbmRzIHN0cmluZyA9IG5ldmVyXG4+KFxuICBjYWNoZTogQ2FjaGU8ViwgUywgTDEsIEwyLCBMMywgTDQsIEw1PiB8IG51bGwsXG4gIHF1ZXJ5OiBJdGVtUXVlcnkgPSB7fSxcbiAgbG9jYXRpb25zOiBMb2NLZXlBcnJheTxMMSwgTDIsIEwzLCBMNCwgTDU+IHwgW10gPSBbXVxuKToge1xuICBpdGVtczogVltdO1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIHJlZmV0Y2g6ICgpID0+IFByb21pc2U8VltdPjtcbn0ge1xuICBjb25zdCBbaXRlbXMsIHNldEl0ZW1zXSA9IHVzZVN0YXRlPFZbXT4oW10pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7XG5cbiAgLy8gU3RhYmxlIHF1ZXJ5IGFuZCBsb2NhdGlvbnMgc3RyaW5ncyBmb3IgZGVwZW5kZW5jeSB0cmFja2luZ1xuICBjb25zdCBxdWVyeVN0cmluZyA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RhYmxlSGFzaChxdWVyeSksIFtxdWVyeV0pO1xuICBjb25zdCBsb2NhdGlvbnNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVN0YWJsZUhhc2gobG9jYXRpb25zKSwgW2xvY2F0aW9uc10pO1xuXG4gIC8vIExvYWQgaW5pdGlhbCBpdGVtcyBmcm9tIGNhY2hlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYWNoZSkge1xuICAgICAgc2V0SXRlbXMoW10pO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCBpdGVtcyBmcm9tIGNhY2hlIHVzaW5nIGFsbCBvcGVyYXRpb25cbiAgICBjYWNoZS5vcGVyYXRpb25zLmFsbChxdWVyeSwgbG9jYXRpb25zKS50aGVuKGNhY2hlZEl0ZW1zID0+IHtcbiAgICAgIHNldEl0ZW1zKGNhY2hlZEl0ZW1zIHx8IFtdKTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcXVlcnlpbmcgaXRlbXMgZnJvbSBjYWNoZTonLCBlcnJvcik7XG4gICAgICBzZXRJdGVtcyhbXSk7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH0pO1xuICB9LCBbY2FjaGUsIHF1ZXJ5U3RyaW5nLCBsb2NhdGlvbnNTdHJpbmddKTtcblxuICAvLyBOb3JtYWxpemUgYSBrZXkgZm9yIGNvbXBhcmlzb24gKHNhbWUgbG9naWMgYXMgQ2FjaGVFdmVudEVtaXR0ZXIpXG4gIGNvbnN0IG5vcm1hbGl6ZUtleSA9IHVzZUNhbGxiYWNrKChrZXk6IENvbUtleTxTLCBMMSwgTDIsIEwzLCBMNCwgTDU+IHwgUHJpS2V5PFM+KTogc3RyaW5nID0+IHtcbiAgICAvLyBOb3JtYWxpemUgdGhlbiBjcmVhdGUgc3RhYmxlIHN0cmluZ1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAoKCk6IGFueSA9PiB7XG4gICAgICBjb25zdCByZXBsYWNlciA9ICh2YWx1ZTogYW55KTogYW55ID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBub3JtYWxpemVLZXlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUubWFwKHJlcGxhY2VyKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjb25zdCBvdXQ6IGFueSA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIG91dFtrXSA9IHJlcGxhY2VyKCh2YWx1ZSBhcyBhbnkpW2tdKTtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVwbGFjZXIoa2V5KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBjcmVhdGVTdGFibGVIYXNoKG5vcm1hbGl6ZWQpO1xuICB9LCBbXSk7XG5cbiAgLy8gSW1wcm92ZWQgcXVlcnkgY29tcGFyaXNvbiB0aGF0IGhhbmRsZXMgb2JqZWN0IG9yZGVyaW5nXG4gIGNvbnN0IHF1ZXJpZXNNYXRjaCA9IHVzZUNhbGxiYWNrKChxMTogSXRlbVF1ZXJ5LCBxMjogSXRlbVF1ZXJ5KTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChxMSwgcTIpO1xuICB9LCBbXSk7XG5cbiAgLy8gQ3JlYXRlIGV2ZW50IGxpc3RlbmVyIHRvIHVwZGF0ZSBpdGVtcyB3aGVuIHRoZXkgY2hhbmdlXG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IGFueSkgPT4ge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnaXRlbXNfcXVlcmllZCc6XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXZlbnQgbWF0Y2hlcyBvdXIgcXVlcnkgd2l0aCBpbXByb3ZlZCBjb21wYXJpc29uXG4gICAgICAgIGlmIChxdWVyaWVzTWF0Y2goZXZlbnQucXVlcnksIHF1ZXJ5KSAmJlxuICAgICAgICAgICAgY3JlYXRlU3RhYmxlSGFzaChldmVudC5sb2NhdGlvbnMpID09PSBsb2NhdGlvbnNTdHJpbmcpIHtcbiAgICAgICAgICBzZXRJdGVtcyhldmVudC5pdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2l0ZW1fY3JlYXRlZCc6XG4gICAgICBjYXNlICdpdGVtX3VwZGF0ZWQnOlxuICAgICAgY2FzZSAnaXRlbV9yZXRyaWV2ZWQnOlxuICAgICAgY2FzZSAnaXRlbV9zZXQnOlxuICAgICAgICAvLyBGb3IgaW5kaXZpZHVhbCBpdGVtIGNoYW5nZXMsIHdlIG5lZWQgdG8gcmUtcXVlcnkgdG8gc2VlIGlmIHRoZSBpdGVtXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBvdXIgcmVzdWx0IHNldFxuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBjYWNoZS5vcGVyYXRpb25zLmFsbChxdWVyeSwgbG9jYXRpb25zKS50aGVuKHVwZGF0ZWRJdGVtcyA9PiB7XG4gICAgICAgICAgICBzZXRJdGVtcyh1cGRhdGVkSXRlbXMgfHwgW10pO1xuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlLXF1ZXJ5aW5nIGl0ZW1zIGZyb20gY2FjaGUgYWZ0ZXIgaXRlbSBjaGFuZ2U6JywgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpdGVtX3JlbW92ZWQnOlxuICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gZnJvbSBvdXIgY3VycmVudCByZXN1bHRzIGlmIGl0IHdhcyB0aGVyZVxuICAgICAgICBzZXRJdGVtcyhwcmV2SXRlbXMgPT5cbiAgICAgICAgICBwcmV2SXRlbXMuZmlsdGVyKGl0ZW0gPT5cbiAgICAgICAgICAgIG5vcm1hbGl6ZUtleShpdGVtLmtleSkgIT09IG5vcm1hbGl6ZUtleShldmVudC5rZXkpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY2FjaGVfY2xlYXJlZCc6XG4gICAgICAgIHNldEl0ZW1zKFtdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LCBbY2FjaGUsIHF1ZXJ5U3RyaW5nLCBsb2NhdGlvbnNTdHJpbmcsIG5vcm1hbGl6ZUtleSwgcXVlcmllc01hdGNoXSk7XG5cbiAgLy8gU3Vic2NyaXB0aW9uIG9wdGlvbnMgd2l0aCBkZWJvdW5jaW5nIGZvciBxdWVyeSB1cGRhdGVzXG4gIGNvbnN0IHN1YnNjcmlwdGlvbk9wdGlvbnMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnRUeXBlczogW1xuICAgICAgJ2l0ZW1zX3F1ZXJpZWQnLFxuICAgICAgJ2l0ZW1fY3JlYXRlZCcsXG4gICAgICAnaXRlbV91cGRhdGVkJyxcbiAgICAgICdpdGVtX3JlbW92ZWQnLFxuICAgICAgJ2l0ZW1fcmV0cmlldmVkJyxcbiAgICAgICdpdGVtX3NldCcsXG4gICAgICAnY2FjaGVfY2xlYXJlZCdcbiAgICBdIGFzIENhY2hlRXZlbnRUeXBlW10sXG4gICAgZGVib3VuY2VNczogNTAgLy8gU21hbGwgZGVib3VuY2UgdG8gYmF0Y2ggcmFwaWQgdXBkYXRlc1xuICB9KSwgW10pO1xuXG4gIC8vIFN1YnNjcmliZSB0byBjYWNoZSBldmVudHNcbiAgdXNlQ2FjaGVTdWJzY3JpcHRpb24oY2FjaGUsIGV2ZW50TGlzdGVuZXIsIHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuXG4gIC8vIFJlZmV0Y2ggZnVuY3Rpb24gdG8gbWFudWFsbHkgcmVsb2FkIHRoZSBxdWVyeVxuICBjb25zdCByZWZldGNoID0gdXNlQ2FsbGJhY2soYXN5bmMgKCk6IFByb21pc2U8VltdPiA9PiB7XG4gICAgaWYgKCFjYWNoZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWxsKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgICAgc2V0SXRlbXMocmVzdWx0cyB8fCBbXSk7XG4gICAgICByZXR1cm4gcmVzdWx0cyB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmZXRjaGluZyBxdWVyeTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbY2FjaGUsIHF1ZXJ5U3RyaW5nLCBsb2NhdGlvbnNTdHJpbmddKTtcblxuICByZXR1cm4ge1xuICAgIGl0ZW1zLFxuICAgIGlzTG9hZGluZyxcbiAgICByZWZldGNoXG4gIH07XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJhY3Rpb24iLCJmYWNldCIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJyZXN1bHQiLCJhYmJyZXZJSyIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsInVzZVN0YXRlIiwiZXJyb3IiLCJsb2dnZXIiLCJpdGVtIiwiYWJicmV2TEtBIiwiYWJicmV2UXVlcnkiLCJ1c2VDb250ZXh0IiwiQWRhcHRlciIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJjYWNoZSIsImlrVG9MS0EiLCJpdGVtcyIsImtleSIsIm5vcm1hbGl6ZUtleVZhbHVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/@fjell/cache/dist/index.js":
/*!******************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/cache/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncIndexDBCacheMap: () => (/* binding */ AsyncIndexDBCacheMap),\n/* harmony export */   CacheEventEmitter: () => (/* binding */ CacheEventEmitter),\n/* harmony export */   CacheEventFactory: () => (/* binding */ CacheEventFactory),\n/* harmony export */   CacheMap: () => (/* binding */ CacheMap),\n/* harmony export */   CacheStatsManager: () => (/* binding */ CacheStatsManager),\n/* harmony export */   EnhancedMemoryCacheMap: () => (/* binding */ EnhancedMemoryCacheMap),\n/* harmony export */   EvictionManager: () => (/* binding */ EvictionManager),\n/* harmony export */   IndexDBCacheMap: () => (/* binding */ IndexDBCacheMap),\n/* harmony export */   LocalStorageCacheMap: () => (/* binding */ LocalStorageCacheMap),\n/* harmony export */   MemoryCacheMap: () => (/* binding */ MemoryCacheMap),\n/* harmony export */   SessionStorageCacheMap: () => (/* binding */ SessionStorageCacheMap),\n/* harmony export */   TTLManager: () => (/* binding */ TTLManager),\n/* harmony export */   createAggregator: () => (/* binding */ createAggregator),\n/* harmony export */   createCache: () => (/* binding */ createCache),\n/* harmony export */   createCacheMap: () => (/* binding */ createCacheMap),\n/* harmony export */   createEvictionStrategy: () => (/* binding */ createEvictionStrategy),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createInstanceFactory: () => (/* binding */ createInstanceFactory),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   createOperations: () => (/* binding */ createOperations),\n/* harmony export */   createOptions: () => (/* binding */ createOptions),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryFactory: () => (/* binding */ createRegistryFactory),\n/* harmony export */   createValidatedConfig: () => (/* binding */ createValidatedConfig),\n/* harmony export */   estimateValueSize: () => (/* binding */ estimateValueSize),\n/* harmony export */   formatBytes: () => (/* binding */ formatBytes),\n/* harmony export */   isCache: () => (/* binding */ isCache),\n/* harmony export */   isInstance: () => (/* binding */ isInstance),\n/* harmony export */   isLocKeyArrayEqual: () => (/* binding */ isLocKeyArrayEqual),\n/* harmony export */   normalizeKeyValue: () => (/* binding */ normalizeKeyValue),\n/* harmony export */   normalizeLocKeyItem: () => (/* binding */ normalizeLocKeyItem),\n/* harmony export */   parseSizeString: () => (/* binding */ parseSizeString),\n/* harmony export */   toCacheConfig: () => (/* binding */ toCacheConfig),\n/* harmony export */   validateARCConfig: () => (/* binding */ validateARCConfig),\n/* harmony export */   validateEvictionStrategyConfig: () => (/* binding */ validateEvictionStrategyConfig),\n/* harmony export */   validateLFUConfig: () => (/* binding */ validateLFUConfig),\n/* harmony export */   validateOptions: () => (/* binding */ validateOptions),\n/* harmony export */   validateSizeConfig: () => (/* binding */ validateSizeConfig),\n/* harmony export */   validateTwoQueueConfig: () => (/* binding */ validateTwoQueueConfig)\n/* harmony export */ });\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/core */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/core/dist/index.js\");\n/* harmony import */ var _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fjell/http-api */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/http-api/dist/index.js\");\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fast-safe-stringify */ \"(app-pages-browser)/../fjell-providers/node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var _fjell_registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fjell/registry */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/registry/dist/index.js\");\n// src/CacheContext.ts\nvar createCacheContext = (api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager) => {\n  return {\n    api,\n    cacheMap,\n    pkType,\n    options,\n    eventEmitter,\n    ttlManager,\n    evictionManager,\n    statsManager\n  };\n};\n\n// src/ops/all.ts\n\n\n\n// src/normalization.ts\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar deterministicStringify = (obj) => {\n  if (obj === null || typeof obj !== \"object\") {\n    return JSON.stringify(obj);\n  }\n  if (Array.isArray(obj)) {\n    return \"[\" + obj.map(deterministicStringify).join(\",\") + \"]\";\n  }\n  const sortedKeys = Object.keys(obj).sort();\n  const keyValuePairs = sortedKeys.map((key) => {\n    return JSON.stringify(key) + \":\" + deterministicStringify(obj[key]);\n  });\n  return \"{\" + keyValuePairs.join(\",\") + \"}\";\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (typeof locItem === \"object\" && locItem !== null && \"lk\" in locItem && locItem.lk !== null) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return deterministicStringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isLocKeyArrayEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    const normalizedA = normalizeLocKeyItem(a[i]);\n    const normalizedB = normalizeLocKeyItem(b[i]);\n    if (deterministicStringify(normalizedA) !== deterministicStringify(normalizedB)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar normalizeLocKeyItem = (item) => {\n  if (typeof item === \"object\" && item !== null) {\n    const normalized = { ...item };\n    if (\"lk\" in normalized && normalized.lk !== null) {\n      normalized.lk = normalizeKeyValue(normalized.lk);\n    }\n    return normalized;\n  }\n  return item;\n};\nvar createQueryHash = (pkType, query, locations) => {\n  const normalizedQuery = JSON.parse(JSON.stringify(query || {}));\n  const sortedQueryKeys = Object.keys(normalizedQuery).sort();\n  const sortedQuery = {};\n  sortedQueryKeys.forEach((key) => {\n    sortedQuery[key] = normalizedQuery[key];\n  });\n  const locationsArray = Array.isArray(locations) ? locations : [];\n  const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n  const hashInput = {\n    type: \"query\",\n    pkType,\n    query: sortedQuery,\n    locations: normalizedLocations\n  };\n  return deterministicStringify(hashInput);\n};\nvar createFinderHash = (finder, params, locations) => {\n  const normalizedParams = JSON.parse(JSON.stringify(params || {}));\n  const sortedParamKeys = Object.keys(normalizedParams).sort();\n  const sortedParams = {};\n  sortedParamKeys.forEach((key) => {\n    sortedParams[key] = normalizedParams[key];\n  });\n  const locationsArray = Array.isArray(locations) ? locations : [];\n  const normalizedLocations = locationsArray.map(normalizeLocKeyItem);\n  const hashInput = {\n    type: \"finder\",\n    finder,\n    params: sortedParams,\n    locations: normalizedLocations\n  };\n  return deterministicStringify(hashInput);\n};\n\n// src/events/CacheEventFactory.ts\nvar CacheEventFactory = class {\n  static lastTimestamp = 0;\n  static cleanupInterval = null;\n  static instanceCount = 0;\n  static CLEANUP_INTERVAL_MS = 6e4;\n  // 1 minute\n  static MAX_TIMESTAMP_AGE_MS = 3e5;\n  // 5 minutes\n  /**\n   * Initialize cleanup mechanism when first instance is created\n   */\n  static initializeCleanup() {\n    if (this.cleanupInterval === null && this.instanceCount === 0) {\n      this.startCleanupTimer();\n    }\n    this.instanceCount++;\n  }\n  /**\n   * Cleanup mechanism when instance is destroyed\n   */\n  static destroyInstance() {\n    this.instanceCount = Math.max(0, this.instanceCount - 1);\n    if (this.instanceCount === 0) {\n      this.stopCleanupTimer();\n      this.resetTimestamp();\n    }\n  }\n  /**\n   * Start automatic cleanup timer\n   */\n  static startCleanupTimer() {\n    this.cleanupInterval = setInterval(() => {\n      this.performCleanup();\n    }, this.CLEANUP_INTERVAL_MS);\n    if (this.cleanupInterval.unref) {\n      this.cleanupInterval.unref();\n    }\n  }\n  /**\n   * Stop automatic cleanup timer\n   */\n  static stopCleanupTimer() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n  /**\n   * Perform periodic cleanup of stale timestamp state\n   */\n  static performCleanup() {\n    const now = Date.now();\n    if (now - this.lastTimestamp > this.MAX_TIMESTAMP_AGE_MS) {\n      this.lastTimestamp = 0;\n    }\n  }\n  /**\n   * Reset the timestamp state (useful for testing)\n   */\n  static resetTimestamp() {\n    this.lastTimestamp = 0;\n  }\n  /**\n   * Generate a unique timestamp that is always greater than the previous one\n   */\n  static generateTimestamp() {\n    this.initializeCleanup();\n    const now = Date.now();\n    if (now > this.lastTimestamp) {\n      this.lastTimestamp = now;\n    } else {\n      this.lastTimestamp = this.lastTimestamp + 1;\n    }\n    return this.lastTimestamp;\n  }\n  /**\n   * Extract affected locations from an item key\n   */\n  static extractAffectedLocations(key) {\n    if (\"loc\" in key && key.loc) {\n      return key.loc;\n    }\n    return [];\n  }\n  /**\n   * Create an item-related event\n   */\n  static createItemEvent(type, key, item, options = {}) {\n    const affectedLocations = options.affectedLocations !== void 0 ? options.affectedLocations : this.extractAffectedLocations(key);\n    return {\n      type,\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      key,\n      item,\n      previousItem: options.previousItem,\n      affectedLocations\n    };\n  }\n  /**\n   * Create a query event\n   */\n  static createQueryEvent(query, locations, items, options = {}) {\n    const affectedKeys = items.map((item) => item.key);\n    return {\n      type: \"items_queried\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      query,\n      locations,\n      items,\n      affectedKeys\n    };\n  }\n  /**\n   * Create a cache cleared event\n   */\n  static createCacheClearedEvent(itemsCleared, queryCacheCleared = true, options = {}) {\n    return {\n      type: \"cache_cleared\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      itemsCleared,\n      queryCacheCleared\n    };\n  }\n  /**\n   * Create a location invalidated event\n   */\n  static createLocationInvalidatedEvent(locations, affectedKeys, options = {}) {\n    return {\n      type: \"location_invalidated\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      locations,\n      affectedKeys\n    };\n  }\n  /**\n   * Create a query invalidated event\n   */\n  static createQueryInvalidatedEvent(invalidatedQueries, reason, options = {}) {\n    return {\n      type: \"query_invalidated\",\n      timestamp: this.generateTimestamp(),\n      source: options.source || \"operation\",\n      context: options.context,\n      invalidatedQueries,\n      reason\n    };\n  }\n  /**\n   * Create an item created event\n   */\n  static itemCreated(key, item, source = \"api\") {\n    return this.createItemEvent(\"item_created\", key, item, { source });\n  }\n  /**\n   * Create an item updated event\n   */\n  static itemUpdated(key, item, previousItem, source = \"api\") {\n    return this.createItemEvent(\"item_updated\", key, item, { previousItem, source });\n  }\n  /**\n   * Create an item removed event\n   */\n  static itemRemoved(key, previousItem, source = \"api\") {\n    return this.createItemEvent(\"item_removed\", key, null, { previousItem, source });\n  }\n  /**\n   * Create an item retrieved event\n   */\n  static itemRetrieved(key, item, source = \"api\") {\n    return this.createItemEvent(\"item_retrieved\", key, item, { source });\n  }\n  /**\n   * Create an item set event (direct cache operation)\n   */\n  static itemSet(key, item, previousItem) {\n    return this.createItemEvent(\"item_set\", key, item, {\n      previousItem,\n      source: \"cache\"\n    });\n  }\n};\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLogger(\"@fjell/cache\");\nvar logger_default = LibLogger;\n\n// src/ops/all.ts\nvar logger = logger_default.get(\"all\");\nvar all = async (query = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger.default(\"all\", { query, locations });\n  const queryHash = createQueryHash(pkType, query, locations);\n  logger.debug(\"Generated query hash for all\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys) {\n    logger.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    const cachedItems = [];\n    let allItemsAvailable = true;\n    for (const itemKey of cachedItemKeys) {\n      const item = await cacheMap.get(itemKey);\n      if (item) {\n        cachedItems.push(item);\n      } else {\n        allItemsAvailable = false;\n        break;\n      }\n    }\n    if (allItemsAvailable) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)];\n    } else {\n      logger.debug(\"Some cached items missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  let ret = [];\n  try {\n    ret = await api.all(query, locations);\n    ret.forEach((v) => {\n      cacheMap.set(v.key, v);\n      const keyStr = JSON.stringify(v.key);\n      ttlManager.onItemAdded(keyStr, cacheMap);\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n    });\n    const itemKeys = ret.map((item) => item.key);\n    cacheMap.setQueryResult(queryHash, itemKeys);\n    logger.debug(\"Cached query result\", { queryHash, itemKeyCount: itemKeys.length });\n    const event = CacheEventFactory.createQueryEvent(query, locations, ret);\n    context.eventEmitter.emit(event);\n  } catch (e) {\n    if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n      cacheMap.setQueryResult(queryHash, []);\n      logger.debug(\"Cached empty query result for not found\", { queryHash });\n    } else {\n      throw e;\n    }\n  }\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/one.ts\n\n\nvar logger2 = logger_default.get(\"one\");\nvar one = async (query = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger2.default(\"one\", { query, locations });\n  const queryHash = createQueryHash(pkType, query, locations);\n  logger2.debug(\"Generated query hash for one\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys) {\n    logger2.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    if (cachedItemKeys.length === 0) {\n      return [context, null];\n    }\n    const item = await cacheMap.get(cachedItemKeys[0]);\n    if (item) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)];\n    } else {\n      logger2.debug(\"Cached item missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  let retItem = null;\n  try {\n    retItem = await api.one(query, locations);\n    if (retItem) {\n      cacheMap.set(retItem.key, retItem);\n      const keyStr = JSON.stringify(retItem.key);\n      ttlManager.onItemAdded(keyStr, cacheMap);\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr, retItem, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n      cacheMap.setQueryResult(queryHash, [retItem.key]);\n      logger2.debug(\"Cached query result\", { queryHash, itemKey: retItem.key });\n    } else {\n      cacheMap.setQueryResult(queryHash, []);\n      logger2.debug(\"Cached empty query result\", { queryHash });\n    }\n  } catch (e) {\n    if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n      cacheMap.setQueryResult(queryHash, []);\n      logger2.debug(\"Cached empty query result for not found\", { queryHash });\n    } else {\n      throw e;\n    }\n  }\n  return [\n    context,\n    retItem ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retItem, pkType) : null\n  ];\n};\n\n// src/ops/create.ts\n\nvar logger3 = logger_default.get(\"create\");\nvar create = async (v, locations = [], context) => {\n  const { api, cacheMap, pkType, eventEmitter, ttlManager, evictionManager } = context;\n  logger3.default(\"create\", { v, locations });\n  const created = await api.create(v, locations);\n  cacheMap.set(created.key, created);\n  const keyStr = JSON.stringify(created.key);\n  ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = evictionManager.onItemAdded(keyStr, created, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    const parsedKey = JSON.parse(evictedKey);\n    cacheMap.delete(parsedKey);\n  });\n  const event = CacheEventFactory.itemCreated(created.key, created, \"api\");\n  eventEmitter.emit(event);\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(created, pkType)];\n};\n\n// src/ops/get.ts\n\n\n// src/utils/CacheSize.ts\n\nvar SIZE_UNITS = {\n  // Decimal units (powers of 1000)\n  \"b\": 1,\n  \"byte\": 1,\n  \"bytes\": 1,\n  \"kb\": 1e3,\n  \"kilobyte\": 1e3,\n  \"kilobytes\": 1e3,\n  \"mb\": 1e3 * 1e3,\n  \"megabyte\": 1e3 * 1e3,\n  \"megabytes\": 1e3 * 1e3,\n  \"gb\": 1e3 * 1e3 * 1e3,\n  \"gigabyte\": 1e3 * 1e3 * 1e3,\n  \"gigabytes\": 1e3 * 1e3 * 1e3,\n  \"tb\": 1e3 * 1e3 * 1e3 * 1e3,\n  \"terabyte\": 1e3 * 1e3 * 1e3 * 1e3,\n  \"terabytes\": 1e3 * 1e3 * 1e3 * 1e3,\n  // Binary units (powers of 1024)\n  \"kib\": 1024,\n  \"kibibyte\": 1024,\n  \"kibibytes\": 1024,\n  \"mib\": 1024 * 1024,\n  \"mebibyte\": 1024 * 1024,\n  \"mebibytes\": 1024 * 1024,\n  \"gib\": 1024 * 1024 * 1024,\n  \"gibibyte\": 1024 * 1024 * 1024,\n  \"gibibytes\": 1024 * 1024 * 1024,\n  \"tib\": 1024 * 1024 * 1024 * 1024,\n  \"tebibyte\": 1024 * 1024 * 1024 * 1024,\n  \"tebibytes\": 1024 * 1024 * 1024 * 1024\n};\nfunction parseSizeString(sizeStr) {\n  if (!sizeStr || typeof sizeStr !== \"string\") {\n    throw new Error(\"Size string must be a non-empty string\");\n  }\n  const trimmed = sizeStr.trim();\n  if (/^\\d+(\\.\\d+)?$/.test(trimmed)) {\n    const bytes = parseFloat(trimmed);\n    if (isNaN(bytes) || bytes < 0) {\n      throw new Error(`Invalid size value: ${sizeStr}`);\n    }\n    return Math.floor(bytes);\n  }\n  const match = trimmed.match(/^(\\d+(?:\\.\\d+)?)\\s*([a-zA-Z]+)$/);\n  if (!match) {\n    throw new Error(`Invalid size format: ${sizeStr}. Expected format: '100', '5KB', '10MB', etc.`);\n  }\n  const [, valueStr, unitStr] = match;\n  const value = parseFloat(valueStr);\n  const unit = unitStr.toLowerCase();\n  if (isNaN(value) || value < 0) {\n    throw new Error(`Invalid size value: ${valueStr}`);\n  }\n  const multiplier = SIZE_UNITS[unit];\n  if (!(unit in SIZE_UNITS)) {\n    const supportedUnits = Object.keys(SIZE_UNITS).filter((u) => u.length <= 3).join(\", \");\n    throw new Error(`Unsupported size unit: ${unitStr}. Supported units: ${supportedUnits}`);\n  }\n  return Math.floor(value * multiplier);\n}\nfunction formatBytes(bytes, binary = false) {\n  if (bytes === 0) return \"0 B\";\n  if (bytes < 0) return `${bytes} B`;\n  const k = binary ? 1024 : 1e3;\n  const sizes = binary ? [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\"] : [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  const size = bytes / Math.pow(k, i);\n  const formatted = size % 1 === 0 ? size.toString() : size.toFixed(1);\n  return `${formatted} ${sizes[i]}`;\n}\nfunction estimateValueSize(value) {\n  if (value === null || typeof value === \"undefined\") {\n    return 8;\n  }\n  switch (typeof value) {\n    case \"boolean\":\n      return 4;\n    case \"number\":\n      return 8;\n    case \"string\":\n      return value.length * 2;\n    case \"object\":\n      if (Array.isArray(value)) {\n        return value.reduce((total, item) => total + estimateValueSize(item), 24);\n      }\n      const hasCircularReference = (obj, ancestors = /* @__PURE__ */ new WeakSet(), checked = /* @__PURE__ */ new WeakSet()) => {\n        if (obj === null || typeof obj !== \"object\") {\n          return false;\n        }\n        const asObject = obj;\n        if (checked.has(asObject)) {\n          return false;\n        }\n        if (ancestors.has(asObject)) {\n          return true;\n        }\n        ancestors.add(asObject);\n        try {\n          if (Array.isArray(asObject)) {\n            for (const item of asObject) {\n              if (hasCircularReference(item, ancestors, checked)) {\n                return true;\n              }\n            }\n          } else {\n            for (const key of Object.keys(asObject)) {\n              let child;\n              try {\n                child = asObject[key];\n              } catch {\n                continue;\n              }\n              if (hasCircularReference(child, ancestors, checked)) {\n                return true;\n              }\n            }\n          }\n        } finally {\n          ancestors.delete(asObject);\n          checked.add(asObject);\n        }\n        return false;\n      };\n      try {\n        if (hasCircularReference(value)) {\n          return 64;\n        }\n      } catch {\n        return 64;\n      }\n      try {\n        const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(value);\n        return jsonString.length * 2 + 16;\n      } catch {\n        return 64;\n      }\n    default:\n      return 32;\n  }\n}\nfunction validateSizeConfig(config) {\n  if (typeof config.maxSizeBytes !== \"undefined\") {\n    try {\n      const bytes = parseSizeString(config.maxSizeBytes);\n      if (bytes <= 0) {\n        throw new Error(\"maxSizeBytes must be positive\");\n      }\n    } catch (error) {\n      throw new Error(`Invalid maxSizeBytes: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  if (typeof config.maxItems !== \"undefined\") {\n    if (!Number.isInteger(config.maxItems) || config.maxItems <= 0) {\n      throw new Error(\"maxItems must be a positive integer\");\n    }\n  }\n}\n\n// src/ops/get.ts\nvar logger4 = logger_default.get(\"get\");\nvar inFlightRequests = /* @__PURE__ */ new Map();\nvar CLEANUP_TIMEOUT = 5 * 60 * 1e3;\nvar cleanupStaleRequests = () => {\n  const now = Date.now();\n  const keysToDelete = [];\n  inFlightRequests.forEach((request, key) => {\n    if (now - request.timestamp > CLEANUP_TIMEOUT) {\n      keysToDelete.push(key);\n    }\n  });\n  keysToDelete.forEach((key) => {\n    logger4.debug(\"Cleaning up stale in-flight request\", { key });\n    inFlightRequests.delete(key);\n  });\n};\nvar cleanupInterval = setInterval(cleanupStaleRequests, 60 * 1e3);\nvar keyToString = createNormalizedHashFunction();\nvar get = async (key, context) => {\n  const { api, cacheMap, pkType, ttlManager, statsManager } = context;\n  logger4.default(\"get\", { key, defaultTTL: ttlManager.getDefaultTTL() });\n  statsManager.incrementRequests();\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger4.error(\"Key for Get is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Get is not a valid ItemKey\");\n  }\n  if (ttlManager.isTTLEnabled()) {\n    const keyStr2 = JSON.stringify(key);\n    const cachedItem = await cacheMap.get(key);\n    if (cachedItem) {\n      const isValid = ttlManager.validateItem(keyStr2, cacheMap);\n      if (isValid) {\n        logger4.debug(\"Cache hit with valid TTL\", { key, defaultTTL: ttlManager.getDefaultTTL() });\n        statsManager.incrementHits();\n        return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)];\n      } else {\n        logger4.debug(\"Cache item expired, removing\", { key });\n        cacheMap.delete(key);\n        statsManager.incrementMisses();\n      }\n    } else {\n      statsManager.incrementMisses();\n    }\n    logger4.debug(\"Cache miss or expired\", { key, defaultTTL: ttlManager.getDefaultTTL() });\n  } else {\n    const cachedItem = await cacheMap.get(key);\n    if (cachedItem) {\n      logger4.debug(\"Cache hit (TTL disabled)\", { key });\n      statsManager.incrementHits();\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItem, pkType)];\n    } else {\n      statsManager.incrementMisses();\n    }\n  }\n  let ret;\n  const keyStr = keyToString(key);\n  try {\n    const requestEntry = inFlightRequests.get(keyStr);\n    let apiRequest;\n    if (!requestEntry) {\n      apiRequest = api.get(key);\n      if (apiRequest && typeof apiRequest.then === \"function\") {\n        const timestamp = Date.now();\n        inFlightRequests.set(keyStr, { promise: apiRequest, timestamp });\n        const cleanup = () => inFlightRequests.delete(keyStr);\n        if (typeof apiRequest.finally === \"function\") {\n          apiRequest.finally(cleanup);\n        } else {\n          apiRequest.then(cleanup, cleanup);\n        }\n      }\n    } else {\n      logger4.debug(\"Using in-flight request for key\", { key });\n      apiRequest = requestEntry.promise;\n    }\n    ret = await apiRequest;\n    if (ret) {\n      cacheMap.set(ret.key, ret);\n      const keyStr2 = JSON.stringify(ret.key);\n      const metadata = cacheMap.getMetadata?.(keyStr2);\n      if (!metadata) {\n        const now = Date.now();\n        const baseMetadata = {\n          key: keyStr2,\n          addedAt: now,\n          lastAccessedAt: now,\n          accessCount: 1,\n          estimatedSize: estimateValueSize(ret)\n        };\n        cacheMap.setMetadata?.(keyStr2, baseMetadata);\n      }\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr2, ret, cacheMap);\n      ttlManager.onItemAdded(keyStr2, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n      const event = CacheEventFactory.itemRetrieved(ret.key, ret, \"api\");\n      context.eventEmitter.emit(event);\n    }\n  } catch (e) {\n    inFlightRequests.delete(keyStr);\n    logger4.error(\"Error getting item for key\", { key, message: e.message, stack: e.stack });\n    throw e;\n  }\n  return [\n    context,\n    ret ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType) : null\n  ];\n};\n\n// src/ops/retrieve.ts\n\nvar logger5 = logger_default.get(\"retrieve\");\nvar retrieve = async (key, context) => {\n  const { cacheMap, pkType, statsManager } = context;\n  logger5.default(\"retrieve\", { key });\n  statsManager.incrementRequests();\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger5.error(\"Key for Retrieve is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Retrieve is not a valid ItemKey\");\n  }\n  const containsItemKey = await cacheMap.includesKey(key);\n  let retrieved;\n  let contextToReturn;\n  if (containsItemKey) {\n    logger5.default(\"Looking for Object in Cache\", key);\n    retrieved = await cacheMap.get(key);\n    contextToReturn = null;\n    statsManager.incrementHits();\n  } else {\n    logger5.default(\"Object Not Found in Cache, Retrieving from Server API\", { key });\n    statsManager.incrementMisses();\n    [contextToReturn, retrieved] = await get(key, context);\n  }\n  const retValue = [\n    contextToReturn,\n    retrieved ? (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(retrieved, pkType) : null\n  ];\n  return retValue;\n};\n\n// src/ops/remove.ts\n\nvar logger6 = logger_default.get(\"remove\");\nvar remove = async (key, context) => {\n  const { api, cacheMap } = context;\n  logger6.default(\"remove\", { key });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger6.error(\"Key for Remove is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Remove is not a valid ItemKey\");\n  }\n  try {\n    const previousItem = await cacheMap.get(key);\n    await api.remove(key);\n    cacheMap.delete(key);\n    if (previousItem) {\n      const event = CacheEventFactory.itemRemoved(key, previousItem, \"api\");\n      context.eventEmitter.emit(event);\n    }\n    logger6.debug(\"Successfully removed item from API and cache\", { key });\n  } catch (e) {\n    logger6.error(\"Error deleting item\", { error: e });\n    throw e;\n  }\n  return context;\n};\n\n// src/ops/update.ts\n\nvar logger7 = logger_default.get(\"update\");\nvar update = async (key, v, context) => {\n  const { api, cacheMap, pkType } = context;\n  logger7.default(\"update\", { key, v });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger7.error(\"Key for Update is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Update is not a valid ItemKey\");\n  }\n  logger7.debug(\"Invalidating item key before update\", { key });\n  cacheMap.invalidateItemKeys([key]);\n  try {\n    const previousItem = await cacheMap.get(key);\n    const updated = await api.update(key, v);\n    logger7.debug(\"Caching update result\", { updatedKey: updated.key });\n    cacheMap.set(updated.key, updated);\n    const keyStr = JSON.stringify(updated.key);\n    context.ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n    evictedKeys.forEach((evictedKey) => {\n      const parsedKey = JSON.parse(evictedKey);\n      cacheMap.delete(parsedKey);\n    });\n    const event = CacheEventFactory.itemUpdated(updated.key, updated, previousItem, \"api\");\n    context.eventEmitter.emit(event);\n    return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)];\n  } catch (e) {\n    logger7.error(\"Error updating item\", { error: e });\n    throw e;\n  }\n};\n\n// src/ops/action.ts\n\nvar logger8 = logger_default.get(\"action\");\nvar action = async (key, action2, body = {}, context) => {\n  const { api, cacheMap, pkType } = context;\n  logger8.default(\"action\", { key, action: action2, body });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger8.error(\"Key for Action is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Action is not a valid ItemKey\");\n  }\n  logger8.debug(\"Invalidating item key before action\", { key });\n  cacheMap.invalidateItemKeys([key]);\n  const updated = await api.action(key, action2, body);\n  logger8.debug(\"Caching action result\", { updatedKey: updated.key });\n  cacheMap.set(updated.key, updated);\n  const keyStr = JSON.stringify(updated.key);\n  context.ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = context.evictionManager.onItemAdded(keyStr, updated, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    try {\n      const parsedKey = JSON.parse(evictedKey);\n      cacheMap.delete(parsedKey);\n    } catch (error) {\n      logger8.error(\"Failed to parse evicted key during deletion\", {\n        evictedKey,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  });\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(updated, pkType)];\n};\n\n// src/ops/allAction.ts\n\n\nvar logger9 = logger_default.get(\"allAction\");\nvar allAction = async (action2, body = {}, locations = [], context) => {\n  const { api, cacheMap, pkType } = context;\n  logger9.default(\"allAction\", { action: action2, body, locations });\n  logger9.debug(\"Invalidating location before allAction\", { locations });\n  cacheMap.invalidateLocation(locations);\n  let ret = [];\n  try {\n    ret = await api.allAction(action2, body, locations);\n    logger9.debug(\"Caching allAction results\", { resultCount: ret.length });\n    ret.forEach((v) => {\n      cacheMap.set(v.key, v);\n      const keyStr = JSON.stringify(v.key);\n      context.ttlManager.onItemAdded(keyStr, cacheMap);\n      const evictedKeys = context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n      evictedKeys.forEach((evictedKey) => {\n        const parsedKey = JSON.parse(evictedKey);\n        cacheMap.delete(parsedKey);\n      });\n    });\n  } catch (e) {\n    if (e instanceof _fjell_http_api__WEBPACK_IMPORTED_MODULE_1__.NotFoundError) {\n    } else {\n      throw e;\n    }\n  }\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/facet.ts\nvar logger10 = logger_default.get(\"facet\");\nvar facet = async (key, facet2, params = {}, context) => {\n  const { api } = context;\n  logger10.default(\"facet\", { key, facet: facet2 });\n  const ret = await api.facet(key, facet2, params);\n  return ret;\n};\n\n// src/ops/allFacet.ts\nvar logger11 = logger_default.get(\"allFacet\");\nvar allFacet = async (facet2, params = {}, locations = [], context) => {\n  const { api } = context;\n  logger11.default(\"allFacet\", { facet: facet2, params, locations });\n  const ret = await api.allFacet(facet2, params, locations);\n  return ret;\n};\n\n// src/ops/find.ts\n\nvar logger12 = logger_default.get(\"find\");\nvar find = async (finder, params = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger12.default(\"find\", { finder, params, locations });\n  const queryHash = createFinderHash(finder, params, locations);\n  logger12.debug(\"Generated query hash for find\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys) {\n    logger12.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    const cachedItems = [];\n    let allItemsAvailable = true;\n    for (const itemKey of cachedItemKeys) {\n      const item = await cacheMap.get(itemKey);\n      if (item) {\n        cachedItems.push(item);\n      } else {\n        allItemsAvailable = false;\n        break;\n      }\n    }\n    if (allItemsAvailable) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(cachedItems, pkType)];\n    } else {\n      logger12.debug(\"Some cached items missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  const ret = await api.find(finder, params, locations);\n  ret.forEach((v) => {\n    cacheMap.set(v.key, v);\n    const keyStr = JSON.stringify(v.key);\n    ttlManager.onItemAdded(keyStr, cacheMap);\n    const evictedKeys = context.evictionManager.onItemAdded(keyStr, v, cacheMap);\n    evictedKeys.forEach((evictedKey) => {\n      const parsedKey = JSON.parse(evictedKey);\n      cacheMap.delete(parsedKey);\n    });\n  });\n  const itemKeys = ret.map((item) => item.key);\n  cacheMap.setQueryResult(queryHash, itemKeys);\n  logger12.debug(\"Cached query result\", { queryHash, itemKeyCount: itemKeys.length });\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/findOne.ts\n\nvar logger13 = logger_default.get(\"findOne\");\nvar findOne = async (finder, finderParams = {}, locations = [], context) => {\n  const { api, cacheMap, pkType, ttlManager } = context;\n  logger13.default(\"findOne\", { finder, finderParams, locations });\n  const queryHash = createFinderHash(finder, finderParams, locations);\n  logger13.debug(\"Generated query hash for findOne\", { queryHash });\n  const cachedItemKeys = await cacheMap.getQueryResult(queryHash);\n  if (cachedItemKeys && cachedItemKeys.length > 0) {\n    logger13.debug(\"Using cached query results\", { cachedKeyCount: cachedItemKeys.length });\n    const item = await cacheMap.get(cachedItemKeys[0]);\n    if (item) {\n      return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(item, pkType)];\n    } else {\n      logger13.debug(\"Cached item missing, invalidating query cache\");\n      cacheMap.deleteQueryResult(queryHash);\n    }\n  }\n  const ret = await api.findOne(finder, finderParams, locations);\n  cacheMap.set(ret.key, ret);\n  const keyStr = JSON.stringify(ret.key);\n  ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = context.evictionManager.onItemAdded(keyStr, ret, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    const parsedKey = JSON.parse(evictedKey);\n    cacheMap.delete(parsedKey);\n  });\n  cacheMap.setQueryResult(queryHash, [ret.key]);\n  logger13.debug(\"Cached query result\", { queryHash, itemKey: ret.key });\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(ret, pkType)];\n};\n\n// src/ops/set.ts\n\nvar logger14 = logger_default.get(\"set\");\nvar normalizeKeyValue2 = (value) => {\n  return String(value);\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  const normalizedA = normalizeKey(a);\n  const normalizedB = normalizeKey(b);\n  return (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isItemKeyEqual)(normalizedA, normalizedB);\n};\nvar normalizeKey = (key) => {\n  if (typeof key === \"object\" && key !== null) {\n    let needsNormalization = false;\n    let normalizedKey = key;\n    if (\"pk\" in key && key.pk !== null && typeof key.pk !== \"string\") {\n      needsNormalization = true;\n    }\n    if (\"lk\" in key && key.lk !== null && typeof key.lk !== \"string\") {\n      needsNormalization = true;\n    }\n    if (\"loc\" in key && Array.isArray(key.loc)) {\n      for (const locItem of key.loc) {\n        if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n          needsNormalization = true;\n          break;\n        }\n      }\n    }\n    if (needsNormalization) {\n      normalizedKey = { ...key };\n      if (\"pk\" in normalizedKey && normalizedKey.pk !== null) {\n        normalizedKey.pk = normalizeKeyValue2(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && normalizedKey.lk !== null) {\n        normalizedKey.lk = normalizeKeyValue2(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && locItem.lk !== null && typeof locItem.lk !== \"string\") {\n            return { ...locItem, lk: normalizeKeyValue2(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n    }\n    return normalizedKey;\n  }\n  return key;\n};\nvar set = async (key, v, context) => {\n  const { cacheMap, pkType, ttlManager, evictionManager, eventEmitter } = context;\n  logger14.default(\"set\", { key, v });\n  if (!(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isValidItemKey)(key)) {\n    logger14.error(\"Key for Set is not a valid ItemKey: %j\", key);\n    throw new Error(\"Key for Set is not a valid ItemKey\");\n  }\n  (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType);\n  if (!isItemKeyEqualNormalized(key, v.key)) {\n    logger14.error(\"Key does not match item key: %j != %j\", key, v.key);\n    throw new Error(\"Key does not match item key\");\n  }\n  const previousItem = await cacheMap.get(key);\n  cacheMap.set(key, v);\n  const keyStr = JSON.stringify(key);\n  ttlManager.onItemAdded(keyStr, cacheMap);\n  const evictedKeys = evictionManager.onItemAdded(keyStr, v, cacheMap);\n  evictedKeys.forEach((evictedKey) => {\n    const parsedKey = JSON.parse(evictedKey);\n    cacheMap.delete(parsedKey);\n  });\n  const event = CacheEventFactory.itemSet(key, v, previousItem);\n  eventEmitter.emit(event);\n  return [context, (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.validatePK)(v, pkType)];\n};\n\n// src/memory/MemoryCacheMap.ts\n\n\n// src/CacheMap.ts\nvar CacheMap = class {\n  types;\n  constructor(types) {\n    this.types = types;\n  }\n};\n\n// src/memory/MemoryCacheMap.ts\nvar logger15 = logger_default.get(\"MemoryCacheMap\");\nvar MemoryCacheMap = class _MemoryCacheMap extends CacheMap {\n  implementationType = \"memory/memory\";\n  map = {};\n  normalizedHashFunction;\n  // Query result cache: maps query hash to cache entry\n  queryResultCache = {};\n  // Metadata storage for eviction strategies\n  metadataMap = /* @__PURE__ */ new Map();\n  constructor(types, initialData) {\n    super(types);\n    this.normalizedHashFunction = createNormalizedHashFunction();\n    if (initialData) {\n      for (const [keyStr, value] of Object.entries(initialData)) {\n        try {\n          const key = JSON.parse(keyStr);\n          this.set(key, value);\n        } catch (error) {\n          logger15.error(\"Failed to parse initial data key\", { keyStr, error });\n        }\n      }\n    }\n  }\n  async get(key) {\n    logger15.trace(\"get\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n      const keyStr = JSON.stringify(key);\n      const metadata = this.metadataMap.get(keyStr);\n      if (metadata) {\n        metadata.lastAccessedAt = Date.now();\n        metadata.accessCount++;\n      }\n      return entry.value;\n    }\n    return null;\n  }\n  set(key, value) {\n    logger15.trace(\"set\", { key, value });\n    const hashedKey = this.normalizedHashFunction(key);\n    const keyStr = JSON.stringify(key);\n    this.map[hashedKey] = { originalKey: key, value };\n    if (!this.metadataMap.has(keyStr)) {\n      const now = Date.now();\n      const metadata = {\n        key: keyStr,\n        addedAt: now,\n        lastAccessedAt: now,\n        accessCount: 1,\n        estimatedSize: estimateValueSize(value)\n      };\n      this.metadataMap.set(keyStr, metadata);\n    } else {\n      const metadata = this.metadataMap.get(keyStr);\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadata.estimatedSize = estimateValueSize(value);\n    }\n  }\n  async includesKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey;\n  }\n  delete(key) {\n    logger15.trace(\"delete\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n      const keyStr = JSON.stringify(entry.originalKey);\n      this.metadataMap.delete(keyStr);\n      delete this.map[hashedKey];\n      for (const [queryHash, cacheEntry] of Object.entries(this.queryResultCache)) {\n        cacheEntry.itemKeys = cacheEntry.itemKeys.filter((k) => this.normalizedHashFunction(k) !== hashedKey);\n        if (cacheEntry.itemKeys.length === 0) {\n          delete this.queryResultCache[queryHash];\n        }\n      }\n    }\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  async values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  clear() {\n    this.map = {};\n    this.metadataMap.clear();\n    this.queryResultCache = {};\n  }\n  async allIn(locations) {\n    const allValues = await this.values();\n    if (locations.length === 0) {\n      logger15.debug(\"Returning all items, LocKeys is empty\");\n      return allValues;\n    } else {\n      logger15.debug(\"allIn\", { locations, count: allValues.length });\n      return allValues.filter((item) => {\n        const key = item.key;\n        if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n          const comKey = key;\n          return isLocKeyArrayEqual(locations, comKey.loc);\n        }\n        return false;\n      });\n    }\n  }\n  async contains(query, locations) {\n    logger15.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger15.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    const clone = new _MemoryCacheMap(this.types);\n    for (const key of this.keys()) {\n      const value = await this.get(key);\n      if (value) {\n        clone.set(key, value);\n      }\n    }\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      clone.queryResultCache[queryHash] = {\n        itemKeys: [...entry.itemKeys]\n        // Shallow copy of the array\n      };\n    }\n    return clone;\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    logger15.trace(\"setQueryResult\", { queryHash, itemKeys });\n    const entry = {\n      itemKeys: [...itemKeys]\n      // Create a copy to avoid external mutations\n    };\n    this.queryResultCache[queryHash] = entry;\n  }\n  async getQueryResult(queryHash) {\n    logger15.trace(\"getQueryResult\", { queryHash });\n    const entry = this.queryResultCache[queryHash];\n    if (!entry) {\n      return null;\n    }\n    return [...entry.itemKeys];\n  }\n  hasQueryResult(queryHash) {\n    const entry = this.queryResultCache[queryHash];\n    return !!entry;\n  }\n  deleteQueryResult(queryHash) {\n    logger15.trace(\"deleteQueryResult\", { queryHash });\n    delete this.queryResultCache[queryHash];\n  }\n  invalidateItemKeys(keys) {\n    logger15.debug(\"invalidateItemKeys\", { keys });\n    keys.forEach((key) => {\n      this.delete(key);\n    });\n  }\n  async invalidateLocation(locations) {\n    logger15.debug(\"invalidateLocation\", { locations });\n    if (locations.length === 0) {\n      const allKeys = this.keys();\n      const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n      this.invalidateItemKeys(primaryKeys);\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      const keysToInvalidate = itemsInLocation.map((item) => item.key);\n      this.invalidateItemKeys(keysToInvalidate);\n    }\n    this.clearQueryResults();\n  }\n  clearQueryResults() {\n    logger15.trace(\"clearQueryResults\");\n    this.queryResultCache = {};\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    return this.metadataMap.get(key) || null;\n  }\n  setMetadata(key, metadata) {\n    this.metadataMap.set(key, metadata);\n  }\n  deleteMetadata(key) {\n    this.metadataMap.delete(key);\n  }\n  getAllMetadata() {\n    return new Map(this.metadataMap);\n  }\n  clearMetadata() {\n    this.metadataMap.clear();\n  }\n  getCurrentSize() {\n    let sizeBytes = 0;\n    for (const entry of Object.values(this.map)) {\n      sizeBytes += estimateValueSize(entry.value);\n    }\n    return {\n      itemCount: Object.keys(this.map).length,\n      sizeBytes\n    };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: null,\n      maxSizeBytes: null\n    };\n  }\n};\n\n// src/memory/EnhancedMemoryCacheMap.ts\n\nvar logger16 = logger_default.get(\"EnhancedMemoryCacheMap\");\nvar EnhancedMemoryCacheMap = class _EnhancedMemoryCacheMap extends CacheMap {\n  implementationType = \"memory/enhanced\";\n  map = {};\n  normalizedHashFunction;\n  // Query result cache: maps query hash to cache entry\n  queryResultCache = {};\n  // Size tracking\n  currentSizeBytes = 0;\n  currentItemCount = 0;\n  queryResultsCacheSize = 0;\n  // Size limits\n  maxSizeBytes;\n  maxItems;\n  constructor(types, sizeConfig, initialData) {\n    super(types);\n    this.normalizedHashFunction = createNormalizedHashFunction();\n    if (sizeConfig?.maxSizeBytes) {\n      this.maxSizeBytes = parseSizeString(sizeConfig.maxSizeBytes);\n      logger16.debug(\"Cache size limit set\", { maxSizeBytes: this.maxSizeBytes });\n    }\n    if (sizeConfig?.maxItems) {\n      this.maxItems = sizeConfig.maxItems;\n      logger16.debug(\"Cache item limit set\", { maxItems: this.maxItems });\n    }\n    if (initialData) {\n      for (const [keyStr, value] of Object.entries(initialData)) {\n        try {\n          const key = JSON.parse(keyStr);\n          this.set(key, value);\n        } catch (error) {\n          logger16.error(\"Failed to parse initial data key\", { keyStr, error });\n        }\n      }\n    }\n  }\n  async get(key) {\n    logger16.trace(\"get\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null) {\n      return entry.value;\n    }\n    return null;\n  }\n  set(key, value) {\n    logger16.trace(\"set\", { key, value });\n    const hashedKey = this.normalizedHashFunction(key);\n    const estimatedSize = estimateValueSize(value);\n    const existingEntry = this.map[hashedKey];\n    const isUpdate = existingEntry && this.normalizedHashFunction(existingEntry.originalKey) === hashedKey;\n    if (isUpdate) {\n      const sizeDiff = estimatedSize - existingEntry.metadata.estimatedSize;\n      this.currentSizeBytes += sizeDiff;\n      const oldValue = existingEntry.value;\n      existingEntry.value = value;\n      existingEntry.metadata.estimatedSize = estimatedSize;\n      logger16.trace(\"Updated existing cache entry\", {\n        key: hashedKey,\n        sizeDiff,\n        currentSize: this.currentSizeBytes,\n        oldValue: oldValue !== value\n      });\n    } else {\n      const metadata = {\n        addedAt: Date.now(),\n        lastAccessedAt: Date.now(),\n        accessCount: 0,\n        estimatedSize,\n        key: hashedKey\n      };\n      this.map[hashedKey] = {\n        originalKey: key,\n        value,\n        metadata\n      };\n      this.currentSizeBytes += estimatedSize;\n      this.currentItemCount++;\n      logger16.trace(\"Added new cache entry\", {\n        key: hashedKey,\n        size: estimatedSize,\n        currentSize: this.currentSizeBytes,\n        currentCount: this.currentItemCount\n      });\n    }\n  }\n  async includesKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    return !!entry && this.normalizedHashFunction(entry.originalKey) === hashedKey && entry.value !== null;\n  }\n  delete(key) {\n    this.deleteInternal(key, true, \"filter\");\n  }\n  deleteInternal(key, invalidateQueries = false, invalidationMode = \"remove\") {\n    logger16.trace(\"delete\", { key });\n    const hashedKey = this.normalizedHashFunction(key);\n    const entry = this.map[hashedKey];\n    if (entry && this.normalizedHashFunction(entry.originalKey) === hashedKey) {\n      this.currentSizeBytes -= entry.metadata.estimatedSize;\n      this.currentItemCount--;\n      delete this.map[hashedKey];\n      logger16.trace(\"Deleted cache entry\", {\n        key: hashedKey,\n        freedSize: entry.metadata.estimatedSize,\n        currentSize: this.currentSizeBytes,\n        currentCount: this.currentItemCount\n      });\n      if (invalidateQueries) {\n        if (invalidationMode === \"filter\") {\n          this.filterQueriesReferencingKeys([key]);\n        } else {\n          this.invalidateQueriesReferencingKeys([key]);\n        }\n      }\n    }\n  }\n  keys() {\n    return Object.values(this.map).filter((entry) => entry.value !== null).map((entry) => entry.originalKey);\n  }\n  async values() {\n    return Object.values(this.map).filter((entry) => entry.value !== null).map((entry) => entry.value);\n  }\n  clear() {\n    logger16.debug(\"Clearing cache\", {\n      itemsCleared: this.currentItemCount,\n      bytesFreed: this.currentSizeBytes\n    });\n    this.map = {};\n    this.currentSizeBytes = 0;\n    this.currentItemCount = 0;\n  }\n  async allIn(locations) {\n    const allValues = await this.values();\n    if (locations.length === 0) {\n      logger16.debug(\"Returning all items, LocKeys is empty\");\n      return allValues;\n    } else {\n      logger16.debug(\"allIn\", { locations, count: allValues.length });\n      return allValues.filter((item) => {\n        const key = item.key;\n        if (key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)) {\n          return isLocKeyArrayEqual(locations, key.loc);\n        }\n        return false;\n      });\n    }\n  }\n  async contains(query, locations) {\n    logger16.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger16.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    const sizeConfig = {};\n    if (this.maxSizeBytes) {\n      sizeConfig.maxSizeBytes = this.maxSizeBytes.toString();\n    }\n    if (this.maxItems) {\n      sizeConfig.maxItems = this.maxItems;\n    }\n    const clone = new _EnhancedMemoryCacheMap(this.types, sizeConfig);\n    for (const key of this.keys()) {\n      const value = await this.get(key);\n      if (value) {\n        clone.set(key, value);\n      }\n    }\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      clone.setQueryResult(queryHash, entry.itemKeys);\n    }\n    return clone;\n  }\n  /**\n   * Get current cache statistics\n   */\n  getStats() {\n    const stats = {\n      currentSizeBytes: this.currentSizeBytes,\n      currentItemCount: this.currentItemCount,\n      maxSizeBytes: this.maxSizeBytes,\n      maxItems: this.maxItems,\n      utilizationPercent: {}\n    };\n    if (this.maxSizeBytes) {\n      stats.utilizationPercent.bytes = this.currentSizeBytes / this.maxSizeBytes * 100;\n    }\n    if (this.maxItems) {\n      stats.utilizationPercent.items = this.currentItemCount / this.maxItems * 100;\n    }\n    return stats;\n  }\n  // Query result caching methods\n  setQueryResult(queryHash, itemKeys) {\n    logger16.trace(\"setQueryResult\", { queryHash, itemKeys });\n    if (queryHash in this.queryResultCache) {\n      this.removeQueryResultFromSizeTracking(queryHash);\n    }\n    const entry = {\n      itemKeys: [...itemKeys]\n      // Create a copy to avoid external mutations\n    };\n    this.queryResultCache[queryHash] = entry;\n    this.addQueryResultToSizeTracking(queryHash, entry);\n  }\n  async getQueryResult(queryHash) {\n    logger16.trace(\"getQueryResult\", { queryHash });\n    const entry = this.queryResultCache[queryHash];\n    if (!entry) {\n      return null;\n    }\n    return [...entry.itemKeys];\n  }\n  hasQueryResult(queryHash) {\n    const entry = this.queryResultCache[queryHash];\n    return !!entry;\n  }\n  deleteQueryResult(queryHash) {\n    if (queryHash in this.queryResultCache) {\n      this.removeQueryResultFromSizeTracking(queryHash);\n      delete this.queryResultCache[queryHash];\n    }\n  }\n  clearQueryResults() {\n    this.queryResultCache = {};\n    this.queryResultsCacheSize = 0;\n  }\n  invalidateItemKeys(keys) {\n    logger16.debug(\"invalidateItemKeys\", { keys });\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach((key) => {\n      this.deleteInternal(key, false);\n    });\n    this.invalidateQueriesReferencingKeys(keys);\n  }\n  filterQueriesReferencingKeys(keys) {\n    if (keys.length === 0) {\n      return;\n    }\n    const hashedKeysToInvalidate = new Set(keys.map((key) => this.normalizedHashFunction(key)));\n    const queriesToRemove = [];\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      const filteredKeys = entry.itemKeys.filter((itemKey) => {\n        const hashedItemKey = this.normalizedHashFunction(itemKey);\n        return !hashedKeysToInvalidate.has(hashedItemKey);\n      });\n      if (filteredKeys.length === 0) {\n        queriesToRemove.push(queryHash);\n      } else if (filteredKeys.length !== entry.itemKeys.length) {\n        this.setQueryResult(queryHash, filteredKeys);\n      }\n    }\n    queriesToRemove.forEach((queryHash) => {\n      this.deleteQueryResult(queryHash);\n    });\n  }\n  invalidateQueriesReferencingKeys(keys) {\n    if (keys.length === 0) {\n      return;\n    }\n    const hashedKeysToInvalidate = new Set(keys.map((key) => this.normalizedHashFunction(key)));\n    const queriesToRemove = [];\n    for (const [queryHash, entry] of Object.entries(this.queryResultCache)) {\n      const queryReferencesInvalidatedKey = entry.itemKeys.some((itemKey) => {\n        const hashedItemKey = this.normalizedHashFunction(itemKey);\n        return hashedKeysToInvalidate.has(hashedItemKey);\n      });\n      if (queryReferencesInvalidatedKey) {\n        queriesToRemove.push(queryHash);\n      }\n    }\n    queriesToRemove.forEach((queryHash) => {\n      this.deleteQueryResult(queryHash);\n    });\n  }\n  async invalidateLocation(locations) {\n    logger16.debug(\"invalidateLocation\", { locations });\n    let keysToInvalidate = [];\n    if (locations.length === 0) {\n      const allKeys = this.keys();\n      const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n      keysToInvalidate = primaryKeys;\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      keysToInvalidate = itemsInLocation.map((item) => item.key);\n    }\n    this.invalidateItemKeys(keysToInvalidate);\n  }\n  /**\n   * Add query result to size tracking\n   */\n  addQueryResultToSizeTracking(queryHash, entry) {\n    const hashSize = estimateValueSize(queryHash);\n    const itemKeysSize = estimateValueSize(entry.itemKeys);\n    const totalSize = hashSize + itemKeysSize;\n    this.queryResultsCacheSize += totalSize;\n    logger16.trace(\"Added query result to size tracking\", {\n      queryHash,\n      estimatedSize: totalSize,\n      totalQueryCacheSize: this.queryResultsCacheSize\n    });\n  }\n  /**\n   * Remove query result from size tracking\n   */\n  removeQueryResultFromSizeTracking(queryHash) {\n    const entry = this.queryResultCache[queryHash];\n    if (entry) {\n      const hashSize = estimateValueSize(queryHash);\n      const itemKeysSize = estimateValueSize(entry.itemKeys);\n      const totalSize = hashSize + itemKeysSize;\n      this.queryResultsCacheSize = Math.max(0, this.queryResultsCacheSize - totalSize);\n      logger16.trace(\"Removed query result from size tracking\", {\n        queryHash,\n        estimatedSize: totalSize,\n        totalQueryCacheSize: this.queryResultsCacheSize\n      });\n    }\n  }\n  /**\n   * Get total cache size including query results\n   */\n  getTotalSizeBytes() {\n    return this.currentSizeBytes + this.queryResultsCacheSize;\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    const entry = this.map[key];\n    if (entry && !entry.metadataCleared) {\n      return entry.metadata;\n    }\n    return null;\n  }\n  setMetadata(key, metadata) {\n    const entry = this.map[key];\n    if (entry) {\n      entry.metadata = metadata;\n      entry.metadataCleared = false;\n    } else {\n      let originalKey;\n      try {\n        originalKey = JSON.parse(key);\n      } catch {\n        originalKey = { kt: \"metadata-only\", pk: key };\n      }\n      this.map[key] = {\n        originalKey,\n        value: null,\n        // Placeholder value\n        metadata,\n        metadataCleared: false\n      };\n    }\n  }\n  deleteMetadata(_key) {\n  }\n  getAllMetadata() {\n    const metadata = /* @__PURE__ */ new Map();\n    for (const [hashedKey, entry] of Object.entries(this.map)) {\n      if (!entry.metadataCleared) {\n        metadata.set(hashedKey, entry.metadata);\n      }\n    }\n    return metadata;\n  }\n  clearMetadata() {\n    const keysToRemove = [];\n    for (const [hashedKey, entry] of Object.entries(this.map)) {\n      if (entry.value === null) {\n        keysToRemove.push(hashedKey);\n      } else {\n        entry.metadataCleared = true;\n      }\n    }\n    for (const key of keysToRemove) {\n      delete this.map[key];\n    }\n  }\n  getCurrentSize() {\n    return {\n      itemCount: this.currentItemCount,\n      sizeBytes: this.currentSizeBytes\n    };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: this.maxItems ?? null,\n      maxSizeBytes: this.maxSizeBytes ?? null\n    };\n  }\n};\n\n// src/browser/LocalStorageCacheMap.ts\n\nvar logger17 = logger_default.get(\"LocalStorageCacheMap\");\nvar LocalStorageCacheMap = class _LocalStorageCacheMap extends CacheMap {\n  implementationType = \"browser/localStorage\";\n  keyPrefix;\n  normalizedHashFunction;\n  MAX_RETRY_ATTEMPTS = 3;\n  AGGRESSIVE_CLEANUP_PERCENTAGE = 0.5;\n  // Remove 50% of entries when quota exceeded\n  constructor(types, keyPrefix = \"fjell-cache\") {\n    super(types);\n    this.keyPrefix = keyPrefix;\n    this.normalizedHashFunction = createNormalizedHashFunction();\n  }\n  getStorageKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    return `${this.keyPrefix}:${hashedKey}`;\n  }\n  isQuotaExceededError(error) {\n    return error && (error.name === \"QuotaExceededError\" || error.name === \"NS_ERROR_DOM_QUOTA_REACHED\" || error.code === 22 || error.code === 1014);\n  }\n  getAllKeysStartingWith(prefix) {\n    const keys = [];\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(prefix)) {\n          keys.push(key);\n        }\n      }\n      return keys;\n    } catch (error) {\n      logger17.error(\"Error getting keys by prefix from localStorage\", { prefix, error });\n      throw error;\n    }\n  }\n  tryCleanupOldEntries(aggressive = false) {\n    try {\n      const allEntries = this.collectCacheEntries();\n      if (allEntries.length === 0) {\n        logger17.debug(\"No entries to clean up\");\n        return false;\n      }\n      return this.removeOldestEntries(allEntries, aggressive);\n    } catch (error) {\n      logger17.error(\"Failed to cleanup old localStorage entries\", { error });\n      return false;\n    }\n  }\n  collectCacheEntries() {\n    const allEntries = [];\n    const keys = this.getAllStorageKeys();\n    for (const key of keys) {\n      if (key.includes(\":metadata:\") || key.includes(\":query:\")) {\n        continue;\n      }\n      try {\n        const stored = localStorage.getItem(key);\n        if (stored) {\n          const parsed = JSON.parse(stored);\n          if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed) {\n            allEntries.push({\n              key,\n              timestamp: parsed.timestamp || Date.now(),\n              size: stored.length\n            });\n          } else {\n            allEntries.push({ key, timestamp: 0, size: stored.length });\n          }\n        }\n      } catch (error) {\n        logger17.debug(\"Found corrupted entry during cleanup\", { key, error });\n        allEntries.push({ key, timestamp: 0, size: 0 });\n      }\n    }\n    return allEntries;\n  }\n  removeOldestEntries(allEntries, aggressive = false) {\n    allEntries.sort((a, b) => a.timestamp - b.timestamp);\n    const cleanupPercentage = aggressive ? this.AGGRESSIVE_CLEANUP_PERCENTAGE : 0.25;\n    const toRemove = Math.max(1, Math.ceil(allEntries.length * cleanupPercentage));\n    let removedCount = 0;\n    let removedSize = 0;\n    for (let i = 0; i < toRemove && i < allEntries.length; i++) {\n      try {\n        const key = allEntries[i].key;\n        localStorage.removeItem(key);\n        removedCount++;\n        removedSize += allEntries[i].size;\n      } catch (error) {\n        logger17.error(\"Failed to remove entry during cleanup\", { key: allEntries[i].key, error });\n      }\n    }\n    if (removedCount > 0) {\n      const cleanupType = aggressive ? \"aggressive\" : \"normal\";\n      logger17.info(`Cleaned up ${removedCount} old localStorage entries (${removedSize} bytes) using ${cleanupType} cleanup to free space`);\n    }\n    return removedCount > 0;\n  }\n  getAllStorageKeys() {\n    return this.getAllKeysStartingWith(`${this.keyPrefix}:`);\n  }\n  async get(key) {\n    logger17.trace(\"get\", { key });\n    try {\n      const storageKey = this.getStorageKey(key);\n      let stored = localStorage.getItem(storageKey);\n      if (!stored && typeof key?.kt === \"string\" && key?.pk) {\n        const legacyKey = `${this.keyPrefix}:${key.kt}:${key.pk}`;\n        stored = localStorage.getItem(legacyKey);\n      }\n      if (stored) {\n        try {\n          const parsed = JSON.parse(stored);\n          if (this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key)) {\n            return parsed.value;\n          }\n        } catch (parseError) {\n          logger17.debug(\"Failed to parse stored value\", { key, error: parseError });\n          return null;\n        }\n      }\n      return null;\n    } catch (error) {\n      logger17.error(\"Error retrieving from localStorage\", { key, error });\n      return null;\n    }\n  }\n  set(key, value) {\n    logger17.trace(\"set\", { key, value });\n    for (let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++) {\n      try {\n        const storageKey = this.getStorageKey(key);\n        const toStore = {\n          originalKey: key,\n          value,\n          timestamp: Date.now()\n        };\n        localStorage.setItem(storageKey, JSON.stringify(toStore));\n        if (attempt > 0) {\n          logger17.info(`Successfully stored item after ${attempt} retries`);\n        }\n        return;\n      } catch (error) {\n        const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n        logger17.error(`Error storing to localStorage (attempt ${attempt + 1}/${this.MAX_RETRY_ATTEMPTS})`, {\n          key,\n          value,\n          error,\n          isLastAttempt\n        });\n        if (this.isQuotaExceededError(error)) {\n          const useAggressiveCleanup = attempt > 0;\n          this.tryCleanupOldEntries(useAggressiveCleanup);\n          if (isLastAttempt) {\n            throw new Error(\"Failed to store item in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n          }\n          continue;\n        }\n        throw new Error(`Failed to store item in localStorage: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  async includesKey(key) {\n    try {\n      const storageKey = this.getStorageKey(key);\n      const stored = localStorage.getItem(storageKey);\n      if (stored) {\n        try {\n          const parsed = JSON.parse(stored);\n          return this.normalizedHashFunction(parsed.originalKey) === this.normalizedHashFunction(key);\n        } catch (parseError) {\n          logger17.debug(\"Failed to parse stored value in includesKey\", { key, error: parseError });\n          return false;\n        }\n      }\n      return false;\n    } catch (error) {\n      logger17.error(\"Error checking key in localStorage\", { key, error });\n      return false;\n    }\n  }\n  delete(key) {\n    logger17.trace(\"delete\", { key });\n    try {\n      const storageKey = this.getStorageKey(key);\n      localStorage.removeItem(storageKey);\n    } catch (error) {\n      logger17.error(\"Error deleting from localStorage\", { key, error });\n      throw error;\n    }\n  }\n  async allIn(locations) {\n    const allKeys = this.keys();\n    if (locations.length === 0) {\n      logger17.debug(\"Returning all items, LocKeys is empty\");\n      const items = [];\n      for (const key of allKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    } else {\n      const locKeys = locations;\n      logger17.debug(\"allIn\", { locKeys, keys: allKeys.length });\n      const filteredKeys = allKeys.filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n        const ComKey12 = key;\n        logger17.debug(\"Comparing Location Keys\", {\n          locKeys,\n          ComKey: ComKey12\n        });\n        return isLocKeyArrayEqual(locKeys, ComKey12.loc);\n      });\n      const items = [];\n      for (const key of filteredKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    }\n  }\n  async contains(query, locations) {\n    logger17.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger17.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    return new _LocalStorageCacheMap(this.types, this.keyPrefix);\n  }\n  parseStorageEntry(storageKey) {\n    try {\n      const stored = localStorage.getItem(storageKey);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n    } catch (parseError) {\n      logger17.debug(\"Skipping corrupted localStorage entry\", { storageKey, error: parseError });\n    }\n    return null;\n  }\n  keys() {\n    const keys = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const parsed = this.parseStorageEntry(storageKey);\n        if (parsed?.originalKey) {\n          keys.push(parsed.originalKey);\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error getting keys from localStorage\", { error });\n    }\n    return keys;\n  }\n  async values() {\n    const values = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const parsed = this.parseStorageEntry(storageKey);\n        if (parsed?.value) {\n          values.push(parsed.value);\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error getting values from localStorage\", { error });\n    }\n    return values;\n  }\n  clear() {\n    logger17.debug(\"Clearing localStorage cache\");\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        localStorage.removeItem(storageKey);\n      }\n    } catch (error) {\n      logger17.error(\"Error clearing localStorage cache\", { error });\n      throw error;\n    }\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    logger17.trace(\"setQueryResult\", { queryHash, itemKeys });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    const entry = {\n      itemKeys\n    };\n    try {\n      localStorage.setItem(queryKey, JSON.stringify(entry));\n    } catch (error) {\n      logger17.error(\"Failed to store query result in localStorage\", { queryHash, error });\n    }\n  }\n  async getQueryResult(queryHash) {\n    logger17.trace(\"getQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      const data = localStorage.getItem(queryKey);\n      if (!data) {\n        return null;\n      }\n      const entry = JSON.parse(data);\n      if (Array.isArray(entry)) {\n        return entry;\n      }\n      return entry.itemKeys || null;\n    } catch (error) {\n      logger17.error(\"Failed to retrieve query result from localStorage\", { queryHash, error });\n      return null;\n    }\n  }\n  hasQueryResult(queryHash) {\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      return localStorage.getItem(queryKey) !== null;\n    } catch (error) {\n      logger17.error(\"Failed to check query result in localStorage\", { queryHash, error });\n      return false;\n    }\n  }\n  deleteQueryResult(queryHash) {\n    logger17.trace(\"deleteQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      localStorage.removeItem(queryKey);\n    } catch (error) {\n      logger17.error(\"Failed to delete query result from localStorage\", { queryHash, error });\n    }\n  }\n  invalidateItemKeys(keys) {\n    logger17.debug(\"invalidateItemKeys\", { keys });\n    keys.forEach((key) => {\n      try {\n        this.delete(key);\n      } catch (error) {\n        logger17.error(\"Failed to delete key during invalidation\", { key, error });\n      }\n    });\n  }\n  async invalidateLocation(locations) {\n    logger17.debug(\"invalidateLocation\", { locations });\n    try {\n      if (locations.length === 0) {\n        const allKeys = this.keys();\n        const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n        this.invalidateItemKeys(primaryKeys);\n      } else {\n        const keysToInvalidate = this.keys().filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n          const compositeKey = key;\n          return isLocKeyArrayEqual(locations, compositeKey.loc);\n        });\n        this.invalidateItemKeys(keysToInvalidate);\n      }\n      this.clearQueryResults();\n    } catch (error) {\n      logger17.error(\"Error in invalidateLocation\", { locations, error });\n    }\n  }\n  clearQueryResults() {\n    logger17.trace(\"clearQueryResults\");\n    const queryPrefix = `${this.keyPrefix}:query:`;\n    try {\n      const keysToRemove = this.getAllKeysStartingWith(queryPrefix);\n      for (const key of keysToRemove) {\n        try {\n          localStorage.removeItem(key);\n        } catch (error) {\n          logger17.error(\"Failed to remove query result from localStorage\", { key, error });\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Failed to clear query results from localStorage\", { error });\n    }\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      const stored = localStorage.getItem(metadataKey);\n      if (stored) {\n        try {\n          return JSON.parse(stored);\n        } catch (e) {\n          logger17.debug(\"Invalid metadata JSON, treating as null\", { key, error: e });\n          return null;\n        }\n      }\n      return null;\n    } catch (error) {\n      logger17.error(\"Error getting metadata from localStorage\", { key, error });\n      throw error;\n    }\n  }\n  setMetadata(key, metadata) {\n    for (let attempt = 0; attempt < this.MAX_RETRY_ATTEMPTS; attempt++) {\n      try {\n        const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n        localStorage.setItem(metadataKey, JSON.stringify(metadata));\n        if (attempt > 0) {\n          logger17.info(`Successfully stored metadata after ${attempt} retries`);\n        }\n        return;\n      } catch (error) {\n        const isLastAttempt = attempt === this.MAX_RETRY_ATTEMPTS - 1;\n        logger17.error(`Error storing metadata to localStorage (attempt ${attempt + 1}/${this.MAX_RETRY_ATTEMPTS})`, {\n          key,\n          error,\n          isLastAttempt\n        });\n        if (this.isQuotaExceededError(error)) {\n          const useAggressiveCleanup = attempt > 0;\n          this.tryCleanupOldEntries(useAggressiveCleanup);\n          if (isLastAttempt) {\n            throw new Error(\"Failed to store metadata in localStorage: storage quota exceeded even after multiple cleanup attempts\");\n          }\n          continue;\n        }\n        throw new Error(`Failed to store metadata in localStorage: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  deleteMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      localStorage.removeItem(metadataKey);\n    } catch (error) {\n      logger17.error(\"Error deleting metadata from localStorage\", { key, error });\n      throw error;\n    }\n  }\n  getAllMetadata() {\n    const metadata = /* @__PURE__ */ new Map();\n    try {\n      const metadataPrefix = `${this.keyPrefix}:metadata:`;\n      const metaKeys = this.getAllKeysStartingWith(metadataPrefix);\n      for (const key of metaKeys) {\n        const metadataKey = key.substring(metadataPrefix.length);\n        const stored = localStorage.getItem(key);\n        if (!stored) continue;\n        try {\n          const parsed = JSON.parse(stored);\n          if (parsed && typeof parsed === \"object\") {\n            metadata.set(metadataKey, parsed);\n          }\n        } catch (error) {\n          logger17.debug(\"Skipping invalid metadata entry\", { key, error });\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error getting metadata from localStorage\", { error });\n      throw error;\n    }\n    return metadata;\n  }\n  clearMetadata() {\n    try {\n      const metadataPrefix = `${this.keyPrefix}:metadata:`;\n      const keysToDelete = this.getAllKeysStartingWith(metadataPrefix);\n      keysToDelete.forEach((key) => localStorage.removeItem(key));\n    } catch (error) {\n      logger17.error(\"Error clearing metadata from localStorage\", { error });\n      throw error;\n    }\n  }\n  getCurrentSize() {\n    let itemCount = 0;\n    let sizeBytes = 0;\n    try {\n      const keys = this.getAllStorageKeys();\n      for (const key of keys) {\n        const value = localStorage.getItem(key);\n        if (!value) continue;\n        try {\n          if (typeof Blob !== \"undefined\") {\n            sizeBytes += new Blob([value]).size;\n          } else if (typeof TextEncoder !== \"undefined\") {\n            sizeBytes += new TextEncoder().encode(value).length;\n          } else if (typeof globalThis.Buffer !== \"undefined\") {\n            sizeBytes += globalThis.Buffer.byteLength(value, \"utf8\");\n          } else {\n            sizeBytes += value.length;\n          }\n          if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n            try {\n              const parsed = JSON.parse(value);\n              if (parsed && typeof parsed === \"object\" && \"originalKey\" in parsed && \"value\" in parsed) {\n                itemCount++;\n              }\n            } catch (error) {\n              logger17.debug(\"Invalid entry in getCurrentSize\", { key, error });\n            }\n          }\n        } catch (error) {\n          logger17.debug(\"Size calculation failed, using string length\", { key, error });\n          sizeBytes += value.length;\n        }\n      }\n    } catch (error) {\n      logger17.error(\"Error calculating size from localStorage\", { error });\n      throw error;\n    }\n    return { itemCount, sizeBytes };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: null,\n      // No specific item limit\n      maxSizeBytes: 5 * 1024 * 1024\n      // 5MB conservative estimate\n    };\n  }\n};\n\n// src/browser/SessionStorageCacheMap.ts\n\n\nvar logger18 = logger_default.get(\"SessionStorageCacheMap\");\nvar SessionStorageCacheMap = class _SessionStorageCacheMap extends CacheMap {\n  implementationType = \"browser/sessionStorage\";\n  keyPrefix;\n  normalizedHashFunction;\n  // Use a separate, private verifier that is not referenced by tests to guard against tampering\n  verificationHashFunction;\n  constructor(types, keyPrefix = \"fjell-session-cache\") {\n    super(types);\n    this.keyPrefix = keyPrefix;\n    this.normalizedHashFunction = createNormalizedHashFunction();\n    this.verificationHashFunction = createNormalizedHashFunction();\n  }\n  getStorageKey(key) {\n    const hashedKey = this.normalizedHashFunction(key);\n    return `${this.keyPrefix}:${hashedKey}`;\n  }\n  // Using flatted for safe circular serialization; no manual replacer needed\n  getAllStorageKeys() {\n    const keys = [];\n    try {\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && key.startsWith(`${this.keyPrefix}:`)) {\n          keys.push(key);\n        }\n      }\n    } catch (error) {\n      logger18.error(\"Error getting keys from sessionStorage\", { error });\n    }\n    return keys;\n  }\n  // Detect if current normalized hash function collapses multiple stored items into the same hash\n  hasCollisionForHash(targetHash) {\n    try {\n      const storageKey = `${this.keyPrefix}:${targetHash}`;\n      const raw = sessionStorage.getItem(storageKey);\n      if (!raw) return false;\n      const parsed = JSON.parse(raw);\n      if (!parsed?.originalKey) return false;\n      const storedVerificationHash = parsed.originalVerificationHash;\n      const currentVerificationHash = this.verificationHashFunction(parsed.originalKey);\n      if (storedVerificationHash === currentVerificationHash) {\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async get(key) {\n    logger18.trace(\"get\", { key });\n    try {\n      const currentHash = this.normalizedHashFunction(key);\n      if (this.hasCollisionForHash(currentHash)) {\n        return null;\n      }\n      const storageKey = this.getStorageKey(key);\n      const stored = sessionStorage.getItem(storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        const storedVerificationHash = parsed.originalVerificationHash;\n        const currentVerificationHash = this.verificationHashFunction(key);\n        const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n        if (storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey) {\n          if (parsed.value == null) return null;\n          return parsed.value;\n        }\n      }\n      return null;\n    } catch (error) {\n      logger18.error(\"Error retrieving from sessionStorage\", { key, error });\n      return null;\n    }\n  }\n  set(key, value) {\n    try {\n      const storageKey = this.getStorageKey(key);\n      logger18.trace(\"set\", { storageKey });\n      const toStore = {\n        originalKey: key,\n        value,\n        timestamp: Date.now(),\n        originalVerificationHash: this.verificationHashFunction(key)\n      };\n      const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(toStore);\n      sessionStorage.setItem(storageKey, jsonString);\n    } catch (error) {\n      logger18.error(\"Error storing to sessionStorage\", { errorMessage: error?.message });\n      throw new Error(`Failed to store item in sessionStorage: ${error}`);\n    }\n  }\n  async includesKey(key) {\n    try {\n      const currentHash = this.normalizedHashFunction(key);\n      if (this.hasCollisionForHash(currentHash)) {\n        return false;\n      }\n      const storageKey = this.getStorageKey(key);\n      const stored = sessionStorage.getItem(storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        const storedVerificationHash = parsed.originalVerificationHash;\n        const currentVerificationHash = this.verificationHashFunction(key);\n        const isSameOriginalKey = this.verificationHashFunction(parsed.originalKey) === currentVerificationHash;\n        return !!storedVerificationHash && storedVerificationHash === currentVerificationHash && isSameOriginalKey;\n      }\n      return false;\n    } catch (error) {\n      logger18.error(\"Error checking key in sessionStorage\", { key, error });\n      return false;\n    }\n  }\n  delete(key) {\n    logger18.trace(\"delete\", { key });\n    try {\n      const storageKey = this.getStorageKey(key);\n      sessionStorage.removeItem(storageKey);\n    } catch (error) {\n      logger18.error(\"Error deleting from sessionStorage\", { key, error });\n    }\n  }\n  async allIn(locations) {\n    const allKeys = this.keys();\n    if (locations.length === 0) {\n      logger18.debug(\"Returning all items, LocKeys is empty\");\n      const items = [];\n      for (const key of allKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    } else {\n      const locKeys = locations;\n      logger18.debug(\"allIn\", { locKeys, keys: allKeys.length });\n      const filteredKeys = allKeys.filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n        const ComKey12 = key;\n        logger18.debug(\"Comparing Location Keys\", {\n          locKeys,\n          ComKey: ComKey12\n        });\n        return isLocKeyArrayEqual(locKeys, ComKey12.loc);\n      });\n      const items = [];\n      for (const key of filteredKeys) {\n        const item = await this.get(key);\n        if (item !== null) {\n          items.push(item);\n        }\n      }\n      return items;\n    }\n  }\n  async contains(query, locations) {\n    logger18.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger18.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async clone() {\n    return new _SessionStorageCacheMap(this.types, this.keyPrefix);\n  }\n  keys() {\n    const keys = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const stored = sessionStorage.getItem(storageKey);\n        if (!stored) continue;\n        try {\n          const parsed = JSON.parse(stored);\n          if (parsed.originalKey) {\n            keys.push(parsed.originalKey);\n          }\n        } catch (itemError) {\n          logger18.trace(\"Skipping invalid storage item\", { storageKey, error: itemError });\n        }\n      }\n    } catch (error) {\n      logger18.error(\"Error getting keys from sessionStorage\", { error });\n    }\n    return keys;\n  }\n  async values() {\n    const values = [];\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        const stored = sessionStorage.getItem(storageKey);\n        if (!stored) continue;\n        try {\n          const parsed = JSON.parse(stored);\n          if (parsed.value != null) {\n            values.push(parsed.value);\n          }\n        } catch (itemError) {\n          logger18.trace(\"Skipping invalid storage item for values\", { storageKey, error: itemError });\n        }\n      }\n    } catch (error) {\n      logger18.error(\"Error getting values from sessionStorage\", { error });\n    }\n    return values;\n  }\n  clear() {\n    logger18.debug(\"Clearing sessionStorage cache\");\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const storageKey of storageKeys) {\n        sessionStorage.removeItem(storageKey);\n      }\n    } catch (error) {\n      logger18.error(\"Error clearing sessionStorage cache\", { error });\n    }\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    logger18.trace(\"setQueryResult\", { queryHash, itemKeys });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    const entry = {\n      itemKeys\n    };\n    try {\n      const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry);\n      sessionStorage.setItem(queryKey, jsonString);\n    } catch (error) {\n      logger18.error(\"Failed to store query result in sessionStorage\", { queryHash, error });\n    }\n  }\n  async getQueryResult(queryHash) {\n    logger18.trace(\"getQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      const data = sessionStorage.getItem(queryKey);\n      if (!data) {\n        return null;\n      }\n      const entry = JSON.parse(data);\n      if (Array.isArray(entry)) {\n        return entry;\n      }\n      return entry.itemKeys || null;\n    } catch (error) {\n      logger18.error(\"Failed to retrieve query result from sessionStorage\", { queryHash, error });\n      return null;\n    }\n  }\n  hasQueryResult(queryHash) {\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      return sessionStorage.getItem(queryKey) !== null;\n    } catch (error) {\n      logger18.error(\"Failed to check query result in sessionStorage\", { queryHash, error });\n      return false;\n    }\n  }\n  deleteQueryResult(queryHash) {\n    logger18.trace(\"deleteQueryResult\", { queryHash });\n    const queryKey = `${this.keyPrefix}:query:${queryHash}`;\n    try {\n      sessionStorage.removeItem(queryKey);\n    } catch (error) {\n      logger18.error(\"Failed to delete query result from sessionStorage\", { queryHash, error });\n    }\n  }\n  invalidateItemKeys(keys) {\n    logger18.debug(\"invalidateItemKeys\", { keys });\n    keys.forEach((key) => {\n      this.delete(key);\n    });\n  }\n  async invalidateLocation(locations) {\n    logger18.debug(\"invalidateLocation\", { locations });\n    if (locations.length === 0) {\n      const allKeys = this.keys();\n      const primaryKeys = allKeys.filter((key) => !(0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key));\n      this.invalidateItemKeys(primaryKeys);\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      const keysToInvalidate = itemsInLocation.map((item) => item.key);\n      this.invalidateItemKeys(keysToInvalidate);\n    }\n    this.clearQueryResults();\n  }\n  clearQueryResults() {\n    logger18.trace(\"clearQueryResults\");\n    const queryPrefix = `${this.keyPrefix}:query:`;\n    try {\n      const keysToRemove = [];\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && key.startsWith(queryPrefix)) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach((key) => sessionStorage.removeItem(key));\n    } catch (error) {\n      logger18.error(\"Failed to clear query results from sessionStorage\", { error });\n    }\n  }\n  // CacheMapMetadataProvider implementation\n  getMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      const stored = sessionStorage.getItem(metadataKey);\n      return stored ? JSON.parse(stored) : null;\n    } catch {\n      return null;\n    }\n  }\n  setMetadata(key, metadata) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      const jsonString = fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(metadata);\n      sessionStorage.setItem(metadataKey, jsonString);\n    } catch {\n    }\n  }\n  deleteMetadata(key) {\n    try {\n      const metadataKey = `${this.keyPrefix}:metadata:${key}`;\n      sessionStorage.removeItem(metadataKey);\n    } catch {\n    }\n  }\n  getAllMetadata() {\n    const metadata = /* @__PURE__ */ new Map();\n    const metadataPrefix = `${this.keyPrefix}:metadata:`;\n    try {\n      let foundAny = false;\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (!key || !key.startsWith(metadataPrefix)) continue;\n        foundAny = true;\n        const metadataKey = key.substring(metadataPrefix.length);\n        const stored = sessionStorage.getItem(key);\n        if (!stored) continue;\n        try {\n          metadata.set(metadataKey, JSON.parse(stored));\n        } catch {\n        }\n      }\n      return metadata;\n    } catch (error) {\n      logger18.error(\"Error getting all metadata from sessionStorage\", { error });\n      return metadata;\n    }\n  }\n  clearMetadata() {\n    try {\n      const metadataPrefix = `${this.keyPrefix}:metadata:`;\n      const keysToDelete = [];\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && key.startsWith(metadataPrefix)) {\n          keysToDelete.push(key);\n        }\n      }\n      keysToDelete.forEach((key) => sessionStorage.removeItem(key));\n    } catch {\n    }\n  }\n  getCurrentSize() {\n    let itemCount = 0;\n    let sizeBytes = 0;\n    try {\n      sessionStorage.key(0);\n    } catch {\n      return { itemCount: 0, sizeBytes: 0 };\n    }\n    try {\n      const storageKeys = this.getAllStorageKeys();\n      for (const key of storageKeys) {\n        if (!key.includes(\":metadata:\") && !key.includes(\":query:\")) {\n          try {\n            const value = sessionStorage.getItem(key);\n            if (value) {\n              const parsed = JSON.parse(value);\n              if (parsed?.originalKey && parsed?.originalVerificationHash === this.verificationHashFunction(parsed.originalKey)) {\n                itemCount++;\n                sizeBytes += new Blob([value]).size;\n              }\n            }\n          } catch {\n          }\n        }\n      }\n    } catch {\n      return { itemCount: 0, sizeBytes: 0 };\n    }\n    return { itemCount, sizeBytes };\n  }\n  getSizeLimits() {\n    return {\n      maxItems: null,\n      // No specific item limit\n      maxSizeBytes: 5 * 1024 * 1024\n      // 5MB conservative estimate\n    };\n  }\n};\n\n// src/browser/AsyncIndexDBCacheMap.ts\n\n\nvar logger19 = logger_default.get(\"AsyncIndexDBCacheMap\");\nvar AsyncIndexDBCacheMap = class _AsyncIndexDBCacheMap {\n  types;\n  dbName;\n  storeName;\n  version;\n  normalizedHashFunction;\n  dbPromise = null;\n  constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1) {\n    this.types = types;\n    this.dbName = dbName;\n    this.storeName = storeName;\n    this.version = version;\n    this.normalizedHashFunction = createNormalizedHashFunction();\n  }\n  async getDB() {\n    if (!this.dbPromise) {\n      this.dbPromise = new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Error opening IndexedDB\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          logger19.debug(\"IndexedDB opened successfully\");\n          resolve(request.result);\n        };\n        request.onupgradeneeded = (event) => {\n          logger19.debug(\"IndexedDB upgrade needed\");\n          const db = event.target.result;\n          if (!db.objectStoreNames.contains(this.storeName)) {\n            db.createObjectStore(this.storeName);\n            logger19.debug(\"Created object store\", { storeName: this.storeName });\n          }\n        };\n      });\n    }\n    return this.dbPromise;\n  }\n  getStorageKey(key) {\n    return this.normalizedHashFunction(key);\n  }\n  async get(key) {\n    logger19.trace(\"get\", { key });\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      return new Promise((resolve, reject) => {\n        const request = store.get(storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error getting from IndexedDB\", { key, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const stored = request.result;\n          if (stored && this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key)) {\n            resolve(stored.value);\n          } else {\n            resolve(null);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB get operation\", { key, error });\n      return null;\n    }\n  }\n  async set(key, value) {\n    logger19.trace(\"set\", { key, value });\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      const storedItem = {\n        originalKey: key,\n        value\n      };\n      return new Promise((resolve, reject) => {\n        const request = store.put(storedItem, storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error setting in IndexedDB\", { key, value, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          resolve();\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB set operation\", { key, value, error });\n      throw new Error(`Failed to store item in IndexedDB: ${error}`);\n    }\n  }\n  async includesKey(key) {\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      return new Promise((resolve, reject) => {\n        const request = store.get(storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error checking key in IndexedDB\", { key, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const stored = request.result;\n          if (stored) {\n            const matches = this.normalizedHashFunction(stored.originalKey) === this.normalizedHashFunction(key);\n            resolve(matches);\n          } else {\n            resolve(false);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB includesKey operation\", { key, error });\n      return false;\n    }\n  }\n  async delete(key) {\n    logger19.trace(\"delete\", { key });\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const storageKey = this.getStorageKey(key);\n      return new Promise((resolve, reject) => {\n        const request = store.delete(storageKey);\n        request.onerror = () => {\n          logger19.error(\"Error deleting from IndexedDB\", { key, error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          resolve();\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB delete operation\", { key, error });\n    }\n  }\n  async allIn(locations) {\n    const allKeys = await this.keys();\n    if (locations.length === 0) {\n      logger19.debug(\"Returning all items, LocKeys is empty\");\n      const promises = allKeys.map((key) => this.get(key));\n      const results = await Promise.all(promises);\n      return results.filter((item) => item !== null);\n    } else {\n      const locKeys = locations;\n      logger19.debug(\"allIn\", { locKeys, keys: allKeys.length });\n      const filteredKeys = allKeys.filter((key) => key && (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isComKey)(key)).filter((key) => {\n        const ComKey12 = key;\n        logger19.debug(\"Comparing Location Keys\", {\n          locKeys,\n          ComKey: ComKey12\n        });\n        return isLocKeyArrayEqual(locKeys, ComKey12.loc);\n      });\n      const promises = filteredKeys.map((key) => this.get(key));\n      const results = await Promise.all(promises);\n      return results.filter((item) => item !== null);\n    }\n  }\n  async contains(query, locations) {\n    logger19.debug(\"contains\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.some((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  async queryIn(query, locations = []) {\n    logger19.debug(\"queryIn\", { query, locations });\n    const items = await this.allIn(locations);\n    return items.filter((item) => (0,_fjell_core__WEBPACK_IMPORTED_MODULE_0__.isQueryMatch)(item, query));\n  }\n  clone() {\n    return new _AsyncIndexDBCacheMap(this.types, this.dbName, this.storeName, this.version);\n  }\n  async keys() {\n    const keys = [];\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      return new Promise((resolve, reject) => {\n        const request = store.openCursor();\n        request.onerror = () => {\n          logger19.error(\"Error getting keys from IndexedDB\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            const stored = cursor.value;\n            keys.push(stored.originalKey);\n            cursor.continue();\n          } else {\n            resolve(keys);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB keys operation\", { error });\n      return [];\n    }\n  }\n  async values() {\n    const values = [];\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      return new Promise((resolve, reject) => {\n        const request = store.openCursor();\n        request.onerror = () => {\n          logger19.error(\"Error getting values from IndexedDB\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = (event) => {\n          const cursor = event.target.result;\n          if (cursor) {\n            const stored = cursor.value;\n            values.push(stored.value);\n            cursor.continue();\n          } else {\n            resolve(values);\n          }\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB values operation\", { error });\n      return [];\n    }\n  }\n  async clear() {\n    logger19.debug(\"Clearing IndexedDB cache\");\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      return new Promise((resolve, reject) => {\n        const request = store.clear();\n        request.onerror = () => {\n          logger19.error(\"Error clearing IndexedDB cache\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          resolve();\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in IndexedDB clear operation\", { error });\n    }\n  }\n  // Async Query result caching methods\n  async setQueryResult(queryHash, itemKeys) {\n    logger19.trace(\"setQueryResult\", { queryHash, itemKeys });\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for setQueryResult\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readwrite\");\n          const store = transaction.objectStore(this.storeName);\n          const entry = {\n            itemKeys\n          };\n          const queryKey = `query:${queryHash}`;\n          const putRequest = store.put(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__(entry), queryKey);\n          putRequest.onerror = () => {\n            logger19.error(\"Failed to store query result\", { queryHash, error: putRequest.error });\n            reject(putRequest.error);\n          };\n          putRequest.onsuccess = () => {\n            resolve();\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in setQueryResult\", { queryHash, error });\n      throw error;\n    }\n  }\n  async getQueryResult(queryHash) {\n    logger19.trace(\"getQueryResult\", { queryHash });\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for getQueryResult\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readonly\");\n          const store = transaction.objectStore(this.storeName);\n          const queryKey = `query:${queryHash}`;\n          const getRequest = store.get(queryKey);\n          getRequest.onerror = () => {\n            logger19.error(\"Failed to retrieve query result\", { queryHash, error: getRequest.error });\n            reject(getRequest.error);\n          };\n          getRequest.onsuccess = () => {\n            try {\n              const result = getRequest.result;\n              if (!result) {\n                resolve(null);\n                return;\n              }\n              const entry = JSON.parse(result);\n              if (Array.isArray(entry)) {\n                resolve(entry);\n                return;\n              }\n              resolve(entry.itemKeys || null);\n            } catch (parseError) {\n              logger19.error(\"Failed to parse query result\", { queryHash, error: parseError });\n              resolve(null);\n            }\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in getQueryResult\", { queryHash, error });\n      return null;\n    }\n  }\n  async hasQueryResult(queryHash) {\n    logger19.trace(\"hasQueryResult\", { queryHash });\n    try {\n      const result = await this.getQueryResult(queryHash);\n      return result !== null;\n    } catch (error) {\n      logger19.error(\"Error in hasQueryResult\", { queryHash, error });\n      return false;\n    }\n  }\n  async deleteQueryResult(queryHash) {\n    logger19.trace(\"deleteQueryResult\", { queryHash });\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for deleteQueryResult\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readwrite\");\n          const store = transaction.objectStore(this.storeName);\n          const queryKey = `query:${queryHash}`;\n          const deleteRequest = store.delete(queryKey);\n          deleteRequest.onerror = () => {\n            logger19.error(\"Failed to delete query result\", { queryHash, error: deleteRequest.error });\n            reject(deleteRequest.error);\n          };\n          deleteRequest.onsuccess = () => {\n            resolve();\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in deleteQueryResult\", { queryHash, error });\n      throw error;\n    }\n  }\n  async invalidateItemKeys(keys) {\n    logger19.debug(\"invalidateItemKeys\", { keys });\n    for (const key of keys) {\n      await this.delete(key);\n    }\n  }\n  async invalidateLocation(locations) {\n    logger19.debug(\"invalidateLocation\", { locations });\n    if (locations.length === 0) {\n      await this.clearQueryResults();\n    } else {\n      const itemsInLocation = await this.allIn(locations);\n      const keysToInvalidate = itemsInLocation.map((item) => item.key);\n      await this.invalidateItemKeys(keysToInvalidate);\n    }\n    await this.clearQueryResults();\n  }\n  async clearQueryResults() {\n    logger19.trace(\"clearQueryResults\");\n    try {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          logger19.error(\"Failed to open database for clearQueryResults\", { error: request.error });\n          reject(request.error);\n        };\n        request.onsuccess = () => {\n          const db = request.result;\n          const transaction = db.transaction([this.storeName], \"readwrite\");\n          const store = transaction.objectStore(this.storeName);\n          const cursorRequest = store.openCursor();\n          const keysToDelete = [];\n          cursorRequest.onerror = () => {\n            logger19.error(\"Failed to open cursor for clearQueryResults\", { error: cursorRequest.error });\n            reject(cursorRequest.error);\n          };\n          cursorRequest.onsuccess = () => {\n            const cursor = cursorRequest.result;\n            if (cursor) {\n              const key = cursor.key;\n              if (typeof key === \"string\" && key.startsWith(\"query:\")) {\n                keysToDelete.push(key);\n              }\n              cursor.continue();\n            } else {\n              if (keysToDelete.length === 0) {\n                resolve();\n                return;\n              }\n              let deletedCount = 0;\n              const totalToDelete = keysToDelete.length;\n              keysToDelete.forEach((queryKey) => {\n                const deleteRequest = store.delete(queryKey);\n                deleteRequest.onerror = () => {\n                  logger19.error(\"Failed to delete query key\", { queryKey, error: deleteRequest.error });\n                  deletedCount++;\n                  if (deletedCount === totalToDelete) {\n                    resolve();\n                  }\n                };\n                deleteRequest.onsuccess = () => {\n                  deletedCount++;\n                  if (deletedCount === totalToDelete) {\n                    resolve();\n                  }\n                };\n              });\n            }\n          };\n        };\n      });\n    } catch (error) {\n      logger19.error(\"Error in clearQueryResults\", { error });\n      throw error;\n    }\n  }\n};\n\n// src/browser/IndexDBCacheMap.ts\nvar IndexDBCacheMap = class _IndexDBCacheMap extends CacheMap {\n  implementationType = \"browser/indexedDB\";\n  asyncCache;\n  memoryCache;\n  syncInterval = null;\n  SYNC_INTERVAL_MS = 5e3;\n  // Sync every 5 seconds\n  pendingSyncOperations = /* @__PURE__ */ new Map();\n  initializationPromise = null;\n  isInitialized = false;\n  MAX_RETRY_ATTEMPTS = 3;\n  operationSequence = 0;\n  constructor(types, dbName = \"fjell-indexdb-cache\", storeName = \"cache\", version = 1) {\n    super(types);\n    this.asyncCache = new AsyncIndexDBCacheMap(types, dbName, storeName, version);\n    this.memoryCache = new MemoryCacheMap(types);\n    this.initializeFromIndexedDB();\n    this.startPeriodicSync();\n  }\n  async initializeFromIndexedDB() {\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n    this.initializationPromise = (async () => {\n      try {\n        const keys = await this.asyncCache.keys();\n        for (const key of keys) {\n          if (!this.memoryCache.includesKey(key)) {\n            const value = await this.asyncCache.get(key);\n            if (value) {\n              this.memoryCache.set(key, value);\n            }\n          }\n        }\n        this.isInitialized = true;\n      } catch (error) {\n        console.warn(\"Failed to initialize from IndexedDB:\", error);\n        this.isInitialized = true;\n      }\n    })();\n    return this.initializationPromise;\n  }\n  startPeriodicSync() {\n    this.syncInterval = setInterval(() => {\n      this.syncToIndexedDB();\n    }, this.SYNC_INTERVAL_MS);\n  }\n  async syncToIndexedDB() {\n    try {\n      await this.processPendingOperations();\n      const memoryKeys = this.memoryCache.keys();\n      for (const key of memoryKeys) {\n        const value = await this.memoryCache.get(key);\n        if (value) {\n          await this.asyncCache.set(key, value);\n        }\n      }\n    } catch (error) {\n      console.warn(\"Failed to sync to IndexedDB:\", error);\n    }\n  }\n  async processPendingOperations() {\n    const pendingOps = Array.from(this.pendingSyncOperations.entries());\n    for (const [keyStr, operation] of pendingOps) {\n      if (operation.cancelled) {\n        this.pendingSyncOperations.delete(keyStr);\n        continue;\n      }\n      try {\n        await operation.promise;\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (currentOp && currentOp.sequenceId === operation.sequenceId) {\n          this.pendingSyncOperations.delete(keyStr);\n        }\n      } catch (error) {\n        console.warn(`Failed to process pending ${operation.type} operation:`, error);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (!currentOp || currentOp.sequenceId !== operation.sequenceId || currentOp.cancelled) {\n          if (currentOp && currentOp.sequenceId === operation.sequenceId) {\n            this.pendingSyncOperations.delete(keyStr);\n          }\n        }\n      }\n    }\n  }\n  queueForSync(key, value) {\n    const keyStr = JSON.stringify(key);\n    const sequenceId = ++this.operationSequence;\n    const existingOp = this.pendingSyncOperations.get(keyStr);\n    if (existingOp) {\n      existingOp.cancelled = true;\n    }\n    const syncPromise = (async () => {\n      try {\n        await this.asyncCache.set(key, value);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (currentOp && currentOp.sequenceId === sequenceId && !currentOp.cancelled) {\n          this.pendingSyncOperations.delete(keyStr);\n        }\n      } catch (error) {\n        console.warn(\"Failed to sync single operation to IndexedDB:\", error);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (!currentOp || currentOp.sequenceId !== sequenceId || currentOp.cancelled) {\n          if (currentOp && currentOp.sequenceId === sequenceId) {\n            this.pendingSyncOperations.delete(keyStr);\n          }\n        }\n      }\n    })();\n    this.pendingSyncOperations.set(keyStr, {\n      type: \"set\",\n      key,\n      value,\n      sequenceId,\n      promise: syncPromise,\n      cancelled: false\n    });\n  }\n  queueDeleteForSync(key) {\n    const keyStr = JSON.stringify(key);\n    const sequenceId = ++this.operationSequence;\n    const existingOp = this.pendingSyncOperations.get(keyStr);\n    if (existingOp) {\n      existingOp.cancelled = true;\n    }\n    const syncPromise = (async () => {\n      try {\n        await this.asyncCache.delete(key);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (currentOp && currentOp.sequenceId === sequenceId && !currentOp.cancelled) {\n          this.pendingSyncOperations.delete(keyStr);\n        }\n      } catch (error) {\n        console.warn(\"Failed to sync delete operation to IndexedDB:\", error);\n        const currentOp = this.pendingSyncOperations.get(keyStr);\n        if (!currentOp || currentOp.sequenceId !== sequenceId || currentOp.cancelled) {\n          if (currentOp && currentOp.sequenceId === sequenceId) {\n            this.pendingSyncOperations.delete(keyStr);\n          }\n        }\n      }\n    })();\n    this.pendingSyncOperations.set(keyStr, {\n      type: \"delete\",\n      key,\n      sequenceId,\n      promise: syncPromise,\n      cancelled: false\n    });\n  }\n  queueClearForSync() {\n    for (const operation of this.pendingSyncOperations.values()) {\n      operation.cancelled = true;\n    }\n    this.pendingSyncOperations.clear();\n    Promise.resolve().then(async () => {\n      try {\n        await this.asyncCache.clear();\n      } catch (error) {\n        console.warn(\"Failed to sync clear operation to IndexedDB:\", error);\n      }\n    });\n  }\n  async get(key) {\n    if (!this.isInitialized && this.initializationPromise) {\n      try {\n        await this.initializationPromise;\n      } catch (error) {\n        console.warn(\"IndexedDB initialization failed, using memory cache only:\", error);\n      }\n    }\n    return this.memoryCache.get(key);\n  }\n  set(key, value) {\n    this.memoryCache.set(key, value);\n    this.queueForSync(key, value);\n  }\n  async includesKey(key) {\n    if (!this.isInitialized && this.initializationPromise) {\n      try {\n        await this.initializationPromise;\n      } catch (error) {\n        console.warn(\"IndexedDB initialization failed, using memory cache only:\", error);\n      }\n    }\n    return this.memoryCache.includesKey(key);\n  }\n  delete(key) {\n    this.memoryCache.delete(key);\n    this.queueDeleteForSync(key);\n  }\n  async allIn(locations) {\n    return this.memoryCache.allIn(locations);\n  }\n  async contains(query, locations) {\n    return this.memoryCache.contains(query, locations);\n  }\n  async queryIn(query, locations) {\n    return this.memoryCache.queryIn(query, locations);\n  }\n  async clone() {\n    return new _IndexDBCacheMap(this.types);\n  }\n  keys() {\n    return this.memoryCache.keys();\n  }\n  async values() {\n    return this.memoryCache.values();\n  }\n  clear() {\n    this.memoryCache.clear();\n    this.queueClearForSync();\n  }\n  // Query result caching methods implementation\n  setQueryResult(queryHash, itemKeys) {\n    return this.memoryCache.setQueryResult(queryHash, itemKeys);\n  }\n  async getQueryResult(queryHash) {\n    if (!this.isInitialized && this.initializationPromise) {\n      try {\n        await this.initializationPromise;\n      } catch (error) {\n        console.warn(\"IndexedDB initialization failed, using memory cache only:\", error);\n      }\n    }\n    return this.memoryCache.getQueryResult(queryHash);\n  }\n  hasQueryResult(queryHash) {\n    return this.memoryCache.hasQueryResult(queryHash);\n  }\n  deleteQueryResult(queryHash) {\n    return this.memoryCache.deleteQueryResult(queryHash);\n  }\n  invalidateItemKeys(keys) {\n    return this.memoryCache.invalidateItemKeys(keys);\n  }\n  async invalidateLocation(locations) {\n    return await this.memoryCache.invalidateLocation(locations);\n  }\n  clearQueryResults() {\n    return this.memoryCache.clearQueryResults();\n  }\n  /**\n   * Clean up resources when the cache is no longer needed\n   */\n  destroy() {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n    }\n  }\n  // CacheMapMetadataProvider implementation\n  // Delegate to the memory cache for metadata operations for consistency\n  getMetadata(key) {\n    return this.memoryCache.getMetadata(key);\n  }\n  setMetadata(key, metadata) {\n    this.memoryCache.setMetadata(key, metadata);\n  }\n  deleteMetadata(key) {\n    this.memoryCache.deleteMetadata(key);\n  }\n  getAllMetadata() {\n    return this.memoryCache.getAllMetadata();\n  }\n  clearMetadata() {\n    this.memoryCache.clearMetadata();\n  }\n  getCurrentSize() {\n    return this.memoryCache.getCurrentSize();\n  }\n  getSizeLimits() {\n    return this.memoryCache.getSizeLimits();\n  }\n};\n\n// src/Options.ts\nvar DEFAULT_CACHE_OPTIONS = {\n  cacheType: \"memory\",\n  enableDebugLogging: false,\n  autoSync: true,\n  maxRetries: 3,\n  retryDelay: 1e3,\n  indexedDBConfig: {\n    dbName: \"fjell-cache\",\n    version: 1,\n    storeName: \"cache\",\n    size: {\n      evictionPolicy: \"lru\"\n    }\n  },\n  webStorageConfig: {\n    keyPrefix: \"fjell-cache:\",\n    compress: false,\n    size: {\n      evictionPolicy: \"lru\"\n    }\n  },\n  memoryConfig: {\n    // No limits by default\n    size: {\n      evictionPolicy: \"lru\"\n    }\n  }\n};\nvar createOptions = (cacheOptions) => {\n  const indexedDBConfig = cacheOptions?.indexedDBConfig ? {\n    ...DEFAULT_CACHE_OPTIONS.indexedDBConfig,\n    ...cacheOptions.indexedDBConfig,\n    size: cacheOptions.indexedDBConfig.size ? {\n      ...DEFAULT_CACHE_OPTIONS.indexedDBConfig?.size,\n      ...cacheOptions.indexedDBConfig.size\n    } : DEFAULT_CACHE_OPTIONS.indexedDBConfig?.size\n  } : { ...DEFAULT_CACHE_OPTIONS.indexedDBConfig };\n  const webStorageConfig = cacheOptions?.webStorageConfig ? {\n    ...DEFAULT_CACHE_OPTIONS.webStorageConfig,\n    ...cacheOptions.webStorageConfig,\n    size: cacheOptions.webStorageConfig.size ? {\n      ...DEFAULT_CACHE_OPTIONS.webStorageConfig?.size,\n      ...cacheOptions.webStorageConfig.size\n    } : DEFAULT_CACHE_OPTIONS.webStorageConfig?.size\n  } : { ...DEFAULT_CACHE_OPTIONS.webStorageConfig };\n  const memoryConfig = cacheOptions?.memoryConfig ? {\n    ...DEFAULT_CACHE_OPTIONS.memoryConfig,\n    ...cacheOptions.memoryConfig,\n    size: cacheOptions.memoryConfig.size ? {\n      ...DEFAULT_CACHE_OPTIONS.memoryConfig?.size,\n      ...cacheOptions.memoryConfig.size\n    } : DEFAULT_CACHE_OPTIONS.memoryConfig?.size\n  } : { ...DEFAULT_CACHE_OPTIONS.memoryConfig };\n  return {\n    ...DEFAULT_CACHE_OPTIONS,\n    ...cacheOptions,\n    indexedDBConfig,\n    webStorageConfig,\n    memoryConfig\n  };\n};\nvar createCacheMap = (kta, options) => {\n  switch (options.cacheType) {\n    case \"memory\":\n      if (options.memoryConfig?.size && (options.memoryConfig.size.maxSizeBytes || options.memoryConfig.size.maxItems)) {\n        const sizeConfig = {\n          maxSizeBytes: options.memoryConfig.size.maxSizeBytes,\n          maxItems: options.memoryConfig.size.maxItems\n        };\n        return new EnhancedMemoryCacheMap(\n          kta,\n          sizeConfig\n        );\n      }\n      return new MemoryCacheMap(kta);\n    case \"localStorage\":\n      return new LocalStorageCacheMap(\n        kta,\n        options.webStorageConfig?.keyPrefix\n      );\n    case \"sessionStorage\":\n      return new SessionStorageCacheMap(\n        kta,\n        options.webStorageConfig?.keyPrefix\n      );\n    case \"indexedDB\":\n      return new IndexDBCacheMap(\n        kta,\n        options.indexedDBConfig?.dbName,\n        options.indexedDBConfig?.storeName,\n        options.indexedDBConfig?.version\n      );\n    case \"custom\":\n      if (!options.customCacheMapFactory) {\n        throw new Error('Custom cache map factory is required when cacheType is \"custom\"');\n      }\n      return options.customCacheMapFactory(kta);\n    default:\n      throw new Error(`Unsupported cache type: ${options.cacheType}`);\n  }\n};\nvar validateOptions = (options) => {\n  if (options.cacheType === \"custom\" && !options.customCacheMapFactory) {\n    throw new Error('customCacheMapFactory is required when cacheType is \"custom\"');\n  }\n  if (typeof options.maxRetries === \"number\" && options.maxRetries < 0) {\n    throw new Error(\"maxRetries must be non-negative\");\n  }\n  if (typeof options.retryDelay === \"number\" && options.retryDelay < 0) {\n    throw new Error(\"retryDelay must be non-negative\");\n  }\n  if (typeof options.ttl === \"number\" && options.ttl <= 0) {\n    throw new Error(\"ttl must be positive\");\n  }\n  if (typeof options.memoryConfig?.maxItems === \"number\" && options.memoryConfig.maxItems <= 0) {\n    throw new Error(\"memoryConfig.maxItems must be positive\");\n  }\n  if (options.memoryConfig?.size) {\n    validateSizeConfig(options.memoryConfig.size);\n  }\n  if (options.webStorageConfig?.size) {\n    validateSizeConfig(options.webStorageConfig.size);\n  }\n  if (options.indexedDBConfig?.size) {\n    validateSizeConfig(options.indexedDBConfig.size);\n  }\n  if ([\"localStorage\", \"sessionStorage\"].includes(options.cacheType)) {\n    const isRealBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement === \"function\";\n    if (!isRealBrowser) {\n      throw new Error(`${options.cacheType} is not available in non-browser environments`);\n    }\n  }\n  if (options.cacheType === \"indexedDB\") {\n    if (typeof window === \"undefined\" || !window.indexedDB) {\n      throw new Error(`${options.cacheType} is not available in this environment`);\n    }\n  }\n  if (options.cacheType === \"asyncIndexedDB\") {\n    throw new Error(\"asyncIndexedDB cannot be used with synchronous cache factory. Use AsyncIndexDBCacheMap directly for async operations.\");\n  }\n};\n\n// src/ops/reset.ts\nvar reset = async (coordinate, options) => {\n  try {\n    validateOptions(options);\n    const cacheMap = createCacheMap(coordinate.kta, options);\n    return [cacheMap];\n  } catch (error) {\n    throw error;\n  }\n};\n\n// src/Operations.ts\nvar createOperations = (api, coordinate, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager) => {\n  const context = createCacheContext(api, cacheMap, pkType, options, eventEmitter, ttlManager, evictionManager, statsManager);\n  return {\n    all: (query, locations) => all(query, locations, context).then(([ctx, result]) => result),\n    one: (query, locations) => one(query, locations, context).then(([ctx, result]) => result),\n    create: (item, locations) => create(item, locations, context).then(([ctx, result]) => result),\n    get: (key) => get(key, context).then(([ctx, result]) => result),\n    retrieve: (key) => retrieve(key, context).then(([ctx, result]) => result),\n    remove: (key) => remove(key, context).then((ctx) => void 0),\n    update: (key, item) => update(key, item, context).then(([ctx, result]) => result),\n    action: (key, actionName, body) => action(key, actionName, body, context).then(([ctx, result]) => result),\n    allAction: (actionName, body, locations) => allAction(actionName, body, locations, context).then(([ctx, result]) => result),\n    facet: (key, facetName, params) => facet(key, facetName, params, context).then((result) => result),\n    allFacet: (facetName, params, locations) => allFacet(facetName, params, locations, context).then((result) => result),\n    find: (finder, params, locations) => find(finder, params, locations, context).then(([ctx, result]) => result),\n    findOne: (finder, params, locations) => findOne(finder, params, locations, context).then(([ctx, result]) => result),\n    set: (key, item) => set(key, item, context).then(([ctx, result]) => result),\n    reset: () => reset(coordinate, options).then(() => void 0)\n  };\n};\n\n// src/eviction/EvictionManager.ts\nvar logger20 = logger_default.get(\"EvictionManager\");\nvar EvictionManager = class {\n  evictionStrategy;\n  constructor(evictionStrategy) {\n    this.evictionStrategy = evictionStrategy || null;\n  }\n  /**\n   * Set or update the eviction strategy\n   * @param strategy - The eviction strategy to use\n   */\n  setEvictionStrategy(strategy) {\n    this.evictionStrategy = strategy;\n    logger20.debug(\"Eviction strategy updated\", {\n      strategy: strategy?.getStrategyName() || \"none\"\n    });\n  }\n  /**\n   * Get the current eviction strategy name\n   * @returns Strategy name or null if no eviction\n   */\n  getEvictionStrategyName() {\n    return this.evictionStrategy?.getStrategyName() || null;\n  }\n  /**\n   * Handle item access - update metadata for eviction strategy\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */\n  onItemAccessed(key, metadataProvider) {\n    if (!this.evictionStrategy) {\n      return;\n    }\n    try {\n      this.evictionStrategy.onItemAccessed(key, metadataProvider);\n    } catch (error) {\n      logger20.error(\"Error in eviction strategy onItemAccessed\", { key, error });\n    }\n  }\n  /**\n   * Handle item addition - update metadata and perform eviction if needed\n   * @param key - Item key\n   * @param value - Item value (for size estimation)\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */\n  onItemAdded(key, value, metadataProvider) {\n    const evictedKeys = [];\n    if (!this.evictionStrategy) {\n      return evictedKeys;\n    }\n    try {\n      const estimatedSize = estimateValueSize(value);\n      const context = this.createEvictionContext(metadataProvider, estimatedSize);\n      const keysToEvict = this.evictionStrategy.selectForEviction(metadataProvider, context);\n      for (const evictKey of keysToEvict) {\n        this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n        evictedKeys.push(evictKey);\n      }\n      this.evictionStrategy.onItemAdded(key, estimatedSize, metadataProvider);\n      if (evictedKeys.length > 0) {\n        logger20.debug(\"Items evicted during addition\", {\n          newKey: key,\n          evictedKeys,\n          strategy: this.evictionStrategy.getStrategyName()\n        });\n      }\n    } catch (error) {\n      logger20.error(\"Error in eviction strategy onItemAdded\", { key, error });\n    }\n    return evictedKeys;\n  }\n  /**\n   * Handle item removal - clean up metadata\n   * @param key - Item key\n   * @param metadataProvider - Cache metadata provider\n   */\n  onItemRemoved(key, metadataProvider) {\n    if (!this.evictionStrategy) {\n      return;\n    }\n    try {\n      this.evictionStrategy.onItemRemoved(key, metadataProvider);\n    } catch (error) {\n      logger20.error(\"Error in eviction strategy onItemRemoved\", { key, error });\n    }\n  }\n  /**\n   * Perform manual eviction check\n   * @param metadataProvider - Cache metadata provider\n   * @returns Array of keys that were evicted\n   */\n  performEviction(metadataProvider) {\n    const evictedKeys = [];\n    if (!this.evictionStrategy) {\n      return evictedKeys;\n    }\n    try {\n      const context = this.createEvictionContext(metadataProvider);\n      const keysToEvict = this.evictionStrategy.selectForEviction(metadataProvider, context);\n      for (const evictKey of keysToEvict) {\n        this.evictionStrategy.onItemRemoved(evictKey, metadataProvider);\n        evictedKeys.push(evictKey);\n      }\n      if (evictedKeys.length > 0) {\n        logger20.debug(\"Manual eviction performed\", {\n          evictedKeys,\n          strategy: this.evictionStrategy.getStrategyName()\n        });\n      }\n    } catch (error) {\n      logger20.error(\"Error in manual eviction\", { error });\n    }\n    return evictedKeys;\n  }\n  /**\n   * Check if eviction is supported (i.e., strategy is set)\n   * @returns True if eviction is supported\n   */\n  isEvictionSupported() {\n    return this.evictionStrategy !== null;\n  }\n  /**\n   * Create eviction context from current cache state\n   * @param metadataProvider - Cache metadata provider\n   * @param newItemSize - Size of item being added (optional)\n   * @returns Eviction context\n   */\n  createEvictionContext(metadataProvider, newItemSize) {\n    const currentSize = metadataProvider.getCurrentSize();\n    const limits = metadataProvider.getSizeLimits();\n    return {\n      currentSize,\n      limits,\n      newItemSize\n    };\n  }\n};\n\n// src/eviction/EvictionStrategyConfig.ts\nvar DEFAULT_LFU_CONFIG = {\n  type: \"lfu\",\n  decayFactor: 0.1,\n  decayInterval: 6e4,\n  // 1 minute\n  sketchWidth: 1024,\n  sketchDepth: 4,\n  useProbabilisticCounting: true,\n  minFrequencyThreshold: 1\n};\nvar DEFAULT_ARC_CONFIG = {\n  type: \"arc\",\n  maxCacheSize: 1e3,\n  frequencyThreshold: 2,\n  useEnhancedFrequency: true,\n  frequencyDecayFactor: 0.05,\n  frequencyDecayInterval: 6e5,\n  // 10 minutes\n  useFrequencyWeightedSelection: true,\n  adaptiveLearningRate: 1\n};\nvar DEFAULT_TWO_QUEUE_CONFIG = {\n  type: \"2q\",\n  maxCacheSize: 1e3,\n  useFrequencyPromotion: true,\n  promotionThreshold: 2,\n  hotQueueDecayFactor: 0.05,\n  hotQueueDecayInterval: 3e5,\n  // 5 minutes\n  useFrequencyWeightedLRU: true\n};\n\n// src/eviction/EvictionStrategy.ts\nvar EvictionStrategy = class {\n  /**\n   * Determine if eviction is needed based on current context\n   * @param context - Current cache state and limits\n   * @returns True if eviction should occur\n   */\n  isEvictionNeeded(context) {\n    const { currentSize, limits, newItemSize = 0 } = context;\n    if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n      return true;\n    }\n    if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Calculate how many items need to be evicted\n   * @param context - Current cache state and limits\n   * @returns Number of items that should be evicted\n   */\n  calculateEvictionCount(context) {\n    const { currentSize, limits, newItemSize = 0 } = context;\n    let evictionCount = 0;\n    if (limits.maxItems !== null && currentSize.itemCount >= limits.maxItems) {\n      evictionCount = Math.max(evictionCount, currentSize.itemCount - limits.maxItems + 1);\n    }\n    if (limits.maxSizeBytes !== null && currentSize.sizeBytes + newItemSize > limits.maxSizeBytes) {\n      const excessBytes = currentSize.sizeBytes + newItemSize - limits.maxSizeBytes;\n      const avgItemSize = currentSize.itemCount > 0 ? currentSize.sizeBytes / currentSize.itemCount : 1024;\n      const estimatedEvictionCount = Math.ceil(excessBytes / avgItemSize);\n      evictionCount = Math.max(evictionCount, estimatedEvictionCount);\n    }\n    return evictionCount;\n  }\n};\n\n// src/eviction/strategies/LRUEvictionStrategy.ts\nvar LRUEvictionStrategy = class extends EvictionStrategy {\n  selectForEviction(metadataProvider, context) {\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    const keysToEvict = [];\n    const sortedEntries = Array.from(allMetadata.entries()).sort(([, a], [, b]) => a.lastAccessedAt - b.lastAccessedAt);\n    for (let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++) {\n      keysToEvict.push(sortedEntries[i][0]);\n    }\n    return keysToEvict;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata) {\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadataProvider.setMetadata(key, metadata);\n    }\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  getStrategyName() {\n    return \"lru\";\n  }\n};\n\n// src/eviction/EvictionStrategyValidation.ts\nfunction validateNumberRange(value, min, max, fieldName) {\n  if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n    throw new Error(`${fieldName} must be a finite number`);\n  }\n  if (value < min || value > max) {\n    throw new Error(`${fieldName} must be between ${min} and ${max}, got ${value}`);\n  }\n}\nfunction validatePositiveInteger(value, fieldName) {\n  if (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\n    throw new Error(`${fieldName} must be a finite number`);\n  }\n  if (!Number.isInteger(value) || value <= 0) {\n    throw new Error(`${fieldName} must be a positive integer, got ${value}`);\n  }\n}\nfunction sanitizeLFUConfig(config) {\n  const sanitized = { ...config };\n  if (typeof sanitized.decayFactor === \"number\") {\n    if (sanitized.decayFactor < 0) {\n      console.warn(`decayFactor must be between 0 and 1, got ${sanitized.decayFactor}. Correcting to 0.`);\n      sanitized.decayFactor = 0;\n    } else if (sanitized.decayFactor > 1) {\n      console.warn(`decayFactor must be between 0 and 1, got ${sanitized.decayFactor}. Correcting to 1.`);\n      sanitized.decayFactor = 1;\n    }\n  }\n  if (typeof sanitized.decayInterval === \"number\" && sanitized.decayInterval <= 0) {\n    console.warn(`decayInterval must be positive, got ${sanitized.decayInterval}. Correcting to 300000.`);\n    sanitized.decayInterval = 3e5;\n  }\n  if (typeof sanitized.sketchWidth === \"number\") {\n    if (sanitized.sketchWidth <= 0) {\n      console.warn(`sketchWidth must be positive, got ${sanitized.sketchWidth}. Correcting to 1024.`);\n      sanitized.sketchWidth = 1024;\n    } else if (sanitized.sketchWidth < 16) {\n      console.warn(`sketchWidth should be at least 16 for optimal performance, got ${sanitized.sketchWidth}. Correcting to 16.`);\n      sanitized.sketchWidth = 16;\n    } else if (sanitized.sketchWidth > 65536) {\n      console.warn(`sketchWidth should not exceed 65536 for optimal performance, got ${sanitized.sketchWidth}. Correcting to 65536.`);\n      sanitized.sketchWidth = 65536;\n    }\n  }\n  if (typeof sanitized.sketchDepth === \"number\") {\n    if (sanitized.sketchDepth <= 0) {\n      console.warn(`sketchDepth must be positive, got ${sanitized.sketchDepth}. Correcting to 4.`);\n      sanitized.sketchDepth = 4;\n    } else if (sanitized.sketchDepth < 1) {\n      console.warn(`sketchDepth should be at least 1 for optimal accuracy, got ${sanitized.sketchDepth}. Correcting to 1.`);\n      sanitized.sketchDepth = 1;\n    } else if (sanitized.sketchDepth > 16) {\n      console.warn(`sketchDepth should not exceed 16 for optimal accuracy, got ${sanitized.sketchDepth}. Correcting to 16.`);\n      sanitized.sketchDepth = 16;\n    }\n  }\n  if (typeof sanitized.minFrequencyThreshold === \"number\" && sanitized.minFrequencyThreshold <= 0) {\n    console.warn(`minFrequencyThreshold must be positive, got ${sanitized.minFrequencyThreshold}. Correcting to 1.`);\n    sanitized.minFrequencyThreshold = 1;\n  }\n  return sanitized;\n}\nfunction validateLFUConfig(config) {\n  if (typeof config.decayFactor === \"number\") {\n    validateNumberRange(config.decayFactor, 0, 1, \"decayFactor\");\n  }\n  if (typeof config.decayInterval === \"number\") {\n    validatePositiveInteger(config.decayInterval, \"decayInterval\");\n  }\n  if (typeof config.sketchWidth === \"number\") {\n    validatePositiveInteger(config.sketchWidth, \"sketchWidth\");\n    if (config.sketchWidth < 16 || config.sketchWidth > 65536) {\n      throw new Error(`sketchWidth must be between 16 and 65536, got ${config.sketchWidth}`);\n    }\n  }\n  if (typeof config.sketchDepth === \"number\") {\n    validatePositiveInteger(config.sketchDepth, \"sketchDepth\");\n    if (config.sketchDepth < 1 || config.sketchDepth > 16) {\n      throw new Error(`sketchDepth must be between 1 and 16, got ${config.sketchDepth}`);\n    }\n  }\n  if (typeof config.minFrequencyThreshold === \"number\") {\n    validatePositiveInteger(config.minFrequencyThreshold, \"minFrequencyThreshold\");\n  }\n}\nfunction sanitizeARCConfig(config) {\n  const sanitized = { ...config };\n  if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n    console.warn(`maxCacheSize must be positive, got ${sanitized.maxCacheSize}. Correcting to 1000.`);\n    sanitized.maxCacheSize = 1e3;\n  }\n  if (typeof sanitized.frequencyThreshold === \"number\" && sanitized.frequencyThreshold <= 0) {\n    console.warn(`frequencyThreshold must be positive, got ${sanitized.frequencyThreshold}. Correcting to 2.`);\n    sanitized.frequencyThreshold = 2;\n  }\n  if (typeof sanitized.frequencyDecayFactor === \"number\") {\n    if (sanitized.frequencyDecayFactor < 0) {\n      console.warn(`frequencyDecayFactor must be between 0 and 1, got ${sanitized.frequencyDecayFactor}. Correcting to 0.`);\n      sanitized.frequencyDecayFactor = 0;\n    } else if (sanitized.frequencyDecayFactor > 1) {\n      console.warn(`frequencyDecayFactor must be between 0 and 1, got ${sanitized.frequencyDecayFactor}. Correcting to 1.`);\n      sanitized.frequencyDecayFactor = 1;\n    }\n  }\n  if (typeof sanitized.frequencyDecayInterval === \"number\" && sanitized.frequencyDecayInterval <= 0) {\n    console.warn(`frequencyDecayInterval must be positive, got ${sanitized.frequencyDecayInterval}. Correcting to 60000.`);\n    sanitized.frequencyDecayInterval = 6e4;\n  }\n  if (typeof sanitized.adaptiveLearningRate === \"number\") {\n    if (sanitized.adaptiveLearningRate < 0) {\n      console.warn(`adaptiveLearningRate must be between 0 and 10, got ${sanitized.adaptiveLearningRate}. Correcting to 0.`);\n      sanitized.adaptiveLearningRate = 0;\n    } else if (sanitized.adaptiveLearningRate > 10) {\n      console.warn(`adaptiveLearningRate must be between 0 and 10, got ${sanitized.adaptiveLearningRate}. Correcting to 10.`);\n      sanitized.adaptiveLearningRate = 10;\n    }\n  }\n  return sanitized;\n}\nfunction validateARCConfig(config) {\n  if (typeof config.maxCacheSize === \"number\") {\n    validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n  }\n  if (typeof config.frequencyThreshold === \"number\") {\n    validatePositiveInteger(config.frequencyThreshold, \"frequencyThreshold\");\n  }\n  if (typeof config.frequencyDecayFactor === \"number\") {\n    validateNumberRange(config.frequencyDecayFactor, 0, 1, \"frequencyDecayFactor\");\n  }\n  if (typeof config.frequencyDecayInterval === \"number\") {\n    validatePositiveInteger(config.frequencyDecayInterval, \"frequencyDecayInterval\");\n  }\n  if (typeof config.adaptiveLearningRate === \"number\") {\n    validateNumberRange(config.adaptiveLearningRate, 0, 10, \"adaptiveLearningRate\");\n  }\n}\nfunction sanitizeTwoQueueConfig(config) {\n  const sanitized = { ...config };\n  if (typeof sanitized.maxCacheSize === \"number\" && sanitized.maxCacheSize <= 0) {\n    console.warn(`maxCacheSize must be positive, got ${sanitized.maxCacheSize}. Correcting to 1000.`);\n    sanitized.maxCacheSize = 1e3;\n  }\n  if (typeof sanitized.promotionThreshold === \"number\" && sanitized.promotionThreshold <= 0) {\n    console.warn(`promotionThreshold must be positive, got ${sanitized.promotionThreshold}. Correcting to 2.`);\n    sanitized.promotionThreshold = 2;\n  }\n  if (typeof sanitized.hotQueueDecayFactor === \"number\") {\n    if (sanitized.hotQueueDecayFactor < 0) {\n      console.warn(`hotQueueDecayFactor must be between 0 and 1, got ${sanitized.hotQueueDecayFactor}. Correcting to 0.`);\n      sanitized.hotQueueDecayFactor = 0;\n    } else if (sanitized.hotQueueDecayFactor > 1) {\n      console.warn(`hotQueueDecayFactor must be between 0 and 1, got ${sanitized.hotQueueDecayFactor}. Correcting to 1.`);\n      sanitized.hotQueueDecayFactor = 1;\n    }\n  }\n  if (typeof sanitized.hotQueueDecayInterval === \"number\" && sanitized.hotQueueDecayInterval <= 0) {\n    console.warn(`hotQueueDecayInterval must be positive, got ${sanitized.hotQueueDecayInterval}. Correcting to 300000.`);\n    sanitized.hotQueueDecayInterval = 3e5;\n  }\n  return sanitized;\n}\nfunction validateTwoQueueConfig(config) {\n  if (typeof config.maxCacheSize === \"number\") {\n    validatePositiveInteger(config.maxCacheSize, \"maxCacheSize\");\n  }\n  if (typeof config.promotionThreshold === \"number\") {\n    validatePositiveInteger(config.promotionThreshold, \"promotionThreshold\");\n  }\n  if (typeof config.hotQueueDecayFactor === \"number\") {\n    validateNumberRange(config.hotQueueDecayFactor, 0, 1, \"hotQueueDecayFactor\");\n  }\n  if (typeof config.hotQueueDecayInterval === \"number\") {\n    validatePositiveInteger(config.hotQueueDecayInterval, \"hotQueueDecayInterval\");\n  }\n}\nfunction validateEvictionStrategyConfig(config) {\n  if (!config || typeof config !== \"object\") {\n    throw new Error(\"Configuration must be a non-null object\");\n  }\n  if (!config.type) {\n    throw new Error(\"Configuration must specify a type\");\n  }\n  const validTypes = [\"lfu\", \"lru\", \"fifo\", \"mru\", \"random\", \"arc\", \"2q\"];\n  if (!validTypes.includes(config.type)) {\n    throw new Error(`Invalid eviction strategy type: ${config.type}. Must be one of: ${validTypes.join(\", \")}`);\n  }\n  switch (config.type) {\n    case \"lfu\":\n      validateLFUConfig(config);\n      break;\n    case \"arc\":\n      validateARCConfig(config);\n      break;\n    case \"2q\":\n      validateTwoQueueConfig(config);\n      break;\n    case \"lru\":\n    case \"fifo\":\n    case \"mru\":\n    case \"random\":\n      break;\n    default:\n      throw new Error(`Unsupported eviction strategy type: ${config.type}`);\n  }\n}\nfunction sanitizeConfigByType(config) {\n  if (!config.type) {\n    return config;\n  }\n  switch (config.type) {\n    case \"lfu\":\n      return sanitizeLFUConfig(config);\n    case \"arc\":\n      return sanitizeARCConfig(config);\n    case \"2q\":\n      return sanitizeTwoQueueConfig(config);\n    case \"lru\":\n    case \"fifo\":\n    case \"mru\":\n    case \"random\":\n      return config;\n    default:\n      return config;\n  }\n}\nfunction createValidatedConfig(baseConfig, userConfig) {\n  const mergedConfig = { ...baseConfig, ...userConfig };\n  const sanitizedConfig = sanitizeConfigByType(mergedConfig);\n  validateEvictionStrategyConfig(sanitizedConfig);\n  return sanitizedConfig;\n}\n\n// src/eviction/strategies/LFUEvictionStrategy.ts\nfunction fnv1aHash(key, seed) {\n  const FNV_OFFSET_BASIS = 2166136261;\n  const FNV_PRIME = 16777619;\n  let hash = (FNV_OFFSET_BASIS ^ seed) >>> 0;\n  for (let i = 0; i < key.length; i++) {\n    hash ^= key.charCodeAt(i);\n    hash = hash * FNV_PRIME >>> 0;\n  }\n  hash ^= hash >>> 16;\n  hash = hash * 2246822507 >>> 0;\n  hash ^= hash >>> 13;\n  hash = hash * 3266489909 >>> 0;\n  hash ^= hash >>> 16;\n  return hash >>> 0;\n}\nvar CountMinSketch = class {\n  sketches;\n  width;\n  depth;\n  seeds;\n  constructor(width = 1024, depth = 4) {\n    this.width = width;\n    this.depth = depth;\n    this.sketches = Array(depth).fill(null).map(() => new Array(width).fill(0));\n    this.seeds = Array(depth).fill(null).map(() => Math.floor(Math.random() * 1e6));\n  }\n  /**\n   * Check if a number is a power of 2 for optimized bit masking\n   */\n  isPowerOfTwo(n) {\n    return n > 0 && (n & n - 1) === 0;\n  }\n  /**\n   * Increment the frequency count for a key\n   */\n  increment(key) {\n    for (let i = 0; i < this.depth; i++) {\n      const hash = fnv1aHash(key, this.seeds[i]);\n      const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n      this.sketches[i][index]++;\n    }\n  }\n  /**\n   * Estimate the frequency count for a key\n   */\n  estimate(key) {\n    let minCount = Infinity;\n    for (let i = 0; i < this.depth; i++) {\n      const hash = fnv1aHash(key, this.seeds[i]);\n      const index = this.isPowerOfTwo(this.width) ? hash & this.width - 1 : hash % this.width;\n      minCount = Math.min(minCount, this.sketches[i][index]);\n    }\n    return minCount === Infinity ? 0 : minCount;\n  }\n  /**\n   * Apply decay to all frequencies\n   */\n  decay(factor) {\n    for (let i = 0; i < this.depth; i++) {\n      for (let j = 0; j < this.width; j++) {\n        this.sketches[i][j] = Math.floor(this.sketches[i][j] * (1 - factor));\n      }\n    }\n  }\n  /**\n   * Reset all frequencies to zero\n   */\n  reset() {\n    for (let i = 0; i < this.depth; i++) {\n      for (let j = 0; j < this.width; j++) {\n        this.sketches[i][j] = 0;\n      }\n    }\n  }\n};\nvar LFUEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"lfu\";\n  }\n  config;\n  sketch;\n  lastDecayTime;\n  constructor(config = {}) {\n    super();\n    const defaultBackwardsCompatible = {\n      useProbabilisticCounting: false,\n      decayFactor: 0,\n      decayInterval: Number.MAX_SAFE_INTEGER\n    };\n    const baseConfig = { ...DEFAULT_LFU_CONFIG, ...defaultBackwardsCompatible };\n    this.config = createValidatedConfig(baseConfig, config);\n    this.sketch = this.config.useProbabilisticCounting ? new CountMinSketch(this.config.sketchWidth, this.config.sketchDepth) : null;\n    this.lastDecayTime = Date.now();\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    this.applyPeriodicDecay();\n    const sortedEntries = Array.from(allMetadata.entries()).sort((a, b) => {\n      const freqA = this.getEffectiveFrequency(a[0], a[1]);\n      const freqB = this.getEffectiveFrequency(b[0], b[1]);\n      if (freqA !== freqB) {\n        return freqA - freqB;\n      }\n      return a[1].lastAccessedAt - b[1].lastAccessedAt;\n    });\n    return sortedEntries.slice(0, evictionCount).map(([key]) => key);\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    const now = Date.now();\n    metadata.lastAccessedAt = now;\n    metadata.accessCount++;\n    if (this.sketch) {\n      this.sketch.increment(key);\n      metadata.rawFrequency = this.sketch.estimate(key);\n    } else {\n      metadata.rawFrequency = metadata.accessCount;\n    }\n    metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n    metadata.lastFrequencyUpdate = now;\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize,\n      rawFrequency: 1\n    };\n    metadata.frequencyScore = 1;\n    metadata.lastFrequencyUpdate = now;\n    if (this.sketch) {\n      this.sketch.increment(key);\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  /**\n   * Get the effective frequency for an item, applying real-time decay if needed\n   */\n  getEffectiveFrequency(_key, metadata) {\n    if ((this.config.decayFactor ?? 0) === 0) {\n      return metadata.rawFrequency || metadata.accessCount;\n    }\n    const now = Date.now();\n    if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n      const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n      const decayAmount = timeSinceUpdate / (this.config.decayInterval ?? 6e4) * (this.config.decayFactor ?? 0.1);\n      return Math.max(this.config.minFrequencyThreshold ?? 1, metadata.frequencyScore * (1 - decayAmount));\n    }\n    return metadata.rawFrequency || metadata.accessCount;\n  }\n  /**\n   * Calculate frequency score with decay applied\n   */\n  calculateFrequencyScore(metadata, currentTime) {\n    const rawFreq = metadata.rawFrequency || metadata.accessCount;\n    if ((this.config.decayFactor ?? 0) === 0) {\n      return rawFreq;\n    }\n    if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n      return rawFreq;\n    }\n    const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n    const decayAmount = timeSinceUpdate / (this.config.decayInterval ?? 6e4) * (this.config.decayFactor ?? 0.1);\n    const previousScore = metadata.frequencyScore || rawFreq;\n    const decayedScore = previousScore * (1 - decayAmount);\n    return Math.max(this.config.minFrequencyThreshold ?? 1, decayedScore + 1);\n  }\n  /**\n   * Apply periodic decay to the frequency sketch and metadata\n   */\n  applyPeriodicDecay() {\n    if ((this.config.decayFactor ?? 0) === 0) return;\n    const now = Date.now();\n    const timeSinceDecay = now - this.lastDecayTime;\n    if (timeSinceDecay >= (this.config.decayInterval ?? 6e4)) {\n      if (this.sketch) {\n        this.sketch.decay(this.config.decayFactor ?? 0.1);\n      }\n      this.lastDecayTime = now;\n    }\n  }\n  /**\n   * Get configuration for this strategy\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n  /**\n   * Reset frequency tracking (useful for testing or cache clearing)\n   */\n  reset() {\n    if (this.sketch) {\n      this.sketch.reset();\n    }\n    this.lastDecayTime = Date.now();\n  }\n};\n\n// src/eviction/strategies/FIFOEvictionStrategy.ts\nvar FIFOEvictionStrategy = class extends EvictionStrategy {\n  selectForEviction(metadataProvider, context) {\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    const keysToEvict = [];\n    const sortedEntries = Array.from(allMetadata.entries()).sort(([, a], [, b]) => a.addedAt - b.addedAt);\n    for (let i = 0; i < Math.min(evictionCount, sortedEntries.length); i++) {\n      keysToEvict.push(sortedEntries[i][0]);\n    }\n    return keysToEvict;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata) {\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadataProvider.setMetadata(key, metadata);\n    }\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  getStrategyName() {\n    return \"fifo\";\n  }\n};\n\n// src/eviction/strategies/MRUEvictionStrategy.ts\nvar MRUEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"MRU\";\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    const sortedEntries = Array.from(allMetadata.entries()).sort((a, b) => {\n      return b[1].lastAccessedAt - a[1].lastAccessedAt;\n    });\n    return sortedEntries.slice(0, evictionCount).map(([key]) => key);\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    metadata.lastAccessedAt = Date.now();\n    metadata.accessCount++;\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n};\n\n// src/eviction/strategies/RandomEvictionStrategy.ts\nvar RandomEvictionStrategy = class extends EvictionStrategy {\n  selectForEviction(metadataProvider, context) {\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    const keys = Array.from(allMetadata.keys());\n    const keysToEvict = [];\n    const availableKeys = [...keys];\n    for (let i = 0; i < Math.min(evictionCount, availableKeys.length); i++) {\n      const randomIndex = Math.floor(Math.random() * availableKeys.length);\n      keysToEvict.push(availableKeys.splice(randomIndex, 1)[0]);\n    }\n    return keysToEvict;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata) {\n      metadata.lastAccessedAt = Date.now();\n      metadata.accessCount++;\n      metadataProvider.setMetadata(key, metadata);\n    }\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize\n    };\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    metadataProvider.deleteMetadata(key);\n  }\n  getStrategyName() {\n    return \"random\";\n  }\n};\n\n// src/eviction/strategies/ARCEvictionStrategy.ts\nvar ARCEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"ARC\";\n  }\n  recentGhosts = /* @__PURE__ */ new Set();\n  // T1 ghost entries\n  frequentGhosts = /* @__PURE__ */ new Set();\n  // T2 ghost entries\n  targetRecentSize = 0;\n  // Target size for T1 (recent entries)\n  config;\n  maxGhostSize;\n  lastDecayTime;\n  constructor(maxCacheSize = 1e3, config = {}) {\n    super();\n    const baseConfig = { ...DEFAULT_ARC_CONFIG, maxCacheSize };\n    this.config = createValidatedConfig(baseConfig, config);\n    this.maxGhostSize = this.config.maxCacheSize;\n    this.lastDecayTime = Date.now();\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    this.applyPeriodicDecay(allMetadata);\n    const recentItems = /* @__PURE__ */ new Map();\n    const frequentItems = /* @__PURE__ */ new Map();\n    for (const [key, metadata] of allMetadata) {\n      if (this.isFrequentItem(metadata)) {\n        frequentItems.set(key, metadata);\n      } else {\n        recentItems.set(key, metadata);\n      }\n    }\n    const keysToEvict = [];\n    const totalItems = recentItems.size + frequentItems.size;\n    const maxIterations = Math.min(evictionCount, totalItems);\n    for (let i = 0; i < maxIterations; i++) {\n      let keyToEvict = null;\n      let sourceList = null;\n      if (recentItems.size > this.targetRecentSize && recentItems.size > 0) {\n        keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n        sourceList = recentItems;\n      } else if (frequentItems.size > 0) {\n        keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(frequentItems, \"frequent\") : this.selectLRUFromItems(frequentItems);\n        sourceList = frequentItems;\n      } else if (recentItems.size > 0) {\n        keyToEvict = this.config.useFrequencyWeightedSelection ? this.selectFrequencyWeightedFromItems(recentItems, \"recent\") : this.selectLRUFromItems(recentItems);\n        sourceList = recentItems;\n      }\n      if (keyToEvict && sourceList) {\n        keysToEvict.push(keyToEvict);\n        sourceList.delete(keyToEvict);\n      } else {\n        break;\n      }\n      if (recentItems.size === 0 && frequentItems.size === 0) {\n        break;\n      }\n    }\n    return keysToEvict;\n  }\n  selectLRUFromItems(items) {\n    if (items.size === 0) {\n      return null;\n    }\n    let oldestKey = null;\n    let oldestTime = Infinity;\n    const now = Date.now();\n    for (const [key, metadata] of items) {\n      if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n        continue;\n      }\n      if (metadata.lastAccessedAt < oldestTime) {\n        oldestTime = metadata.lastAccessedAt;\n        oldestKey = key;\n      }\n    }\n    if (oldestKey !== null) {\n      return oldestKey;\n    }\n    if (items.size > 0) {\n      const firstKey = items.keys().next().value;\n      return firstKey ?? null;\n    }\n    return null;\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    const now = Date.now();\n    const updatedMetadata = {\n      ...metadata,\n      lastAccessedAt: now,\n      accessCount: metadata.accessCount + 1\n    };\n    updatedMetadata.rawFrequency = updatedMetadata.accessCount;\n    if (this.config.useEnhancedFrequency && (this.config.frequencyDecayFactor ?? 0) > 0) {\n      updatedMetadata.frequencyScore = this.calculateFrequencyScore(updatedMetadata, now);\n      updatedMetadata.lastFrequencyUpdate = now;\n    }\n    const learningRate = this.config.adaptiveLearningRate ?? 1;\n    let targetAdjusted = false;\n    if (learningRate > 0) {\n      if (this.recentGhosts.has(key)) {\n        const adjustment = Math.max(1, Math.ceil(learningRate));\n        this.targetRecentSize = Math.min(this.targetRecentSize + adjustment, this.maxGhostSize);\n        this.recentGhosts.delete(key);\n        targetAdjusted = true;\n      } else if (this.frequentGhosts.has(key)) {\n        const adjustment = Math.max(1, Math.ceil(learningRate));\n        this.targetRecentSize = Math.max(this.targetRecentSize - adjustment, 0);\n        this.frequentGhosts.delete(key);\n        targetAdjusted = true;\n      }\n    } else {\n      if (this.recentGhosts.has(key)) {\n        this.recentGhosts.delete(key);\n      } else if (this.frequentGhosts.has(key)) {\n        this.frequentGhosts.delete(key);\n      }\n    }\n    if (targetAdjusted) {\n      this.cleanupGhostLists();\n    }\n    metadataProvider.setMetadata(key, updatedMetadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    const metadata = {\n      key,\n      addedAt: now,\n      lastAccessedAt: now,\n      accessCount: 1,\n      estimatedSize,\n      rawFrequency: 1\n    };\n    if (this.config.useEnhancedFrequency && (this.config.frequencyDecayFactor ?? 0) > 0) {\n      metadata.frequencyScore = 1;\n      metadata.lastFrequencyUpdate = now;\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (metadata && this.isFrequentItem(metadata)) {\n      this.addToFrequentGhosts(key);\n    } else {\n      this.addToRecentGhosts(key);\n    }\n    metadataProvider.deleteMetadata(key);\n    this.cleanupGhostLists();\n  }\n  /**\n   * Add key to recent ghost list with proper size management\n   */\n  addToRecentGhosts(key) {\n    this.frequentGhosts.delete(key);\n    this.recentGhosts.add(key);\n    this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n  }\n  /**\n   * Add key to frequent ghost list with proper size management\n   */\n  addToFrequentGhosts(key) {\n    this.recentGhosts.delete(key);\n    this.frequentGhosts.add(key);\n    this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n  }\n  /**\n   * Cleanup ghost lists to prevent memory leaks\n   */\n  cleanupGhostLists() {\n    this.enforceGhostListSizeLimit(this.recentGhosts, this.maxGhostSize);\n    this.enforceGhostListSizeLimit(this.frequentGhosts, this.maxGhostSize);\n  }\n  /**\n   * Enforce size limit on a ghost list by removing oldest entries\n   */\n  enforceGhostListSizeLimit(ghostList, maxSize) {\n    if (maxSize <= 0) {\n      ghostList.clear();\n      return;\n    }\n    const iterator = ghostList.values();\n    while (ghostList.size > maxSize) {\n      const next = iterator.next();\n      if (next.done) {\n        break;\n      }\n      ghostList.delete(next.value);\n    }\n  }\n  /**\n   * Determine if an item should be classified as frequent vs recent\n   */\n  isFrequentItem(metadata) {\n    if (!this.config.useEnhancedFrequency) {\n      return metadata.accessCount > 1;\n    }\n    const frequency = this.getEffectiveFrequency(metadata);\n    return frequency >= (this.config.frequencyThreshold ?? 2);\n  }\n  /**\n   * Get effective frequency for an item, applying decay if enabled\n   */\n  getEffectiveFrequency(metadata) {\n    if (!this.config.useEnhancedFrequency || (this.config.frequencyDecayFactor ?? 0) === 0) {\n      return metadata.rawFrequency || metadata.accessCount;\n    }\n    const now = Date.now();\n    if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n      const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n      const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n      if (timeSinceUpdate > decayInterval / 10) {\n        const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * (this.config.frequencyDecayFactor ?? 0.05));\n        return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n      }\n      return metadata.frequencyScore;\n    }\n    return metadata.rawFrequency || metadata.accessCount;\n  }\n  /**\n   * Calculate frequency score with decay applied\n   */\n  calculateFrequencyScore(metadata, currentTime) {\n    const rawFreq = metadata.rawFrequency || metadata.accessCount;\n    if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n      return rawFreq;\n    }\n    const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n    const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n    const decayFactor = this.config.frequencyDecayFactor ?? 0.05;\n    const decayAmount = Math.min(0.9, timeSinceUpdate / decayInterval * decayFactor);\n    const previousScore = metadata.frequencyScore || rawFreq;\n    const decayedScore = Math.max(1, previousScore * (1 - decayAmount));\n    return Math.max(1, decayedScore + 1);\n  }\n  /**\n   * Select eviction candidate using frequency-weighted approach\n   */\n  selectFrequencyWeightedFromItems(items, context) {\n    if (items.size === 0) {\n      return null;\n    }\n    let bestKey = null;\n    let bestScore = Infinity;\n    const now = Date.now();\n    for (const [key, metadata] of items) {\n      if (!metadata || typeof metadata.lastAccessedAt !== \"number\" || metadata.lastAccessedAt > now) {\n        continue;\n      }\n      const frequency = this.getEffectiveFrequency(metadata);\n      const timeFactor = Math.max(0, now - metadata.lastAccessedAt);\n      let score;\n      if (context === \"recent\") {\n        score = timeFactor + 1e3 / Math.max(1, frequency);\n      } else if (context === \"frequent\") {\n        score = timeFactor / 1e3 + 10 / Math.max(1, frequency);\n      } else {\n        score = timeFactor / 1e3 / Math.max(1, frequency);\n      }\n      if (score < bestScore) {\n        bestScore = score;\n        bestKey = key;\n      }\n    }\n    if (bestKey !== null) {\n      return bestKey;\n    }\n    if (items.size > 0) {\n      const firstKey = items.keys().next().value;\n      return firstKey ?? null;\n    }\n    return null;\n  }\n  /**\n   * Apply periodic decay to frequency scores\n   */\n  applyPeriodicDecay(items) {\n    if (!this.config.useEnhancedFrequency || (this.config.frequencyDecayFactor ?? 0) === 0) return;\n    const now = Date.now();\n    const timeSinceDecay = now - this.lastDecayTime;\n    const decayInterval = this.config.frequencyDecayInterval ?? 6e5;\n    if (timeSinceDecay >= decayInterval && items.size > 0) {\n      const decayFactor = this.config.frequencyDecayFactor ?? 0.05;\n      for (const metadata of items.values()) {\n        if (typeof metadata.frequencyScore === \"number\") {\n          const intervalsPassed = timeSinceDecay / decayInterval;\n          const totalDecay = Math.min(0.9, decayFactor * intervalsPassed);\n          const newScore = metadata.frequencyScore * (1 - totalDecay);\n          metadata.frequencyScore = Math.max(1, newScore);\n          metadata.lastFrequencyUpdate = now;\n        }\n      }\n      this.lastDecayTime = now;\n    }\n  }\n  /**\n   * Get configuration for this strategy\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n  /**\n   * Reset internal state (useful for testing)\n   */\n  reset() {\n    this.recentGhosts.clear();\n    this.frequentGhosts.clear();\n    this.targetRecentSize = 0;\n    this.lastDecayTime = Date.now();\n  }\n  /**\n   * Get current adaptive state for monitoring/debugging\n   */\n  getAdaptiveState() {\n    return {\n      targetRecentSize: this.targetRecentSize,\n      recentGhostSize: this.recentGhosts.size,\n      frequentGhostSize: this.frequentGhosts.size\n    };\n  }\n};\n\n// src/eviction/strategies/TwoQueueEvictionStrategy.ts\nvar TwoQueueEvictionStrategy = class extends EvictionStrategy {\n  getStrategyName() {\n    return \"2Q\";\n  }\n  recentQueue = [];\n  // A1 queue for recent items\n  hotQueue = [];\n  // Am queue for hot items\n  ghostQueue = /* @__PURE__ */ new Set();\n  // A1out ghost queue\n  config;\n  maxRecentSize;\n  maxGhostSize;\n  lastDecayTime;\n  constructor(maxCacheSize = 1e3, config = {}) {\n    super();\n    const baseConfig = { ...DEFAULT_TWO_QUEUE_CONFIG, maxCacheSize };\n    this.config = createValidatedConfig(baseConfig, config);\n    this.maxRecentSize = Math.max(1, Math.floor(this.config.maxCacheSize * 0.25));\n    this.maxGhostSize = this.config.maxCacheSize;\n    this.lastDecayTime = Date.now();\n  }\n  selectForEviction(metadataProvider, context) {\n    const allMetadata = metadataProvider.getAllMetadata();\n    if (allMetadata.size === 0) return [];\n    if (!this.isEvictionNeeded(context)) {\n      return [];\n    }\n    const evictionCount = this.calculateEvictionCount(context);\n    if (evictionCount <= 0) return [];\n    this.applyPeriodicDecay(allMetadata);\n    const keysToEvict = [];\n    for (let i = 0; i < evictionCount; i++) {\n      let keyToEvict = null;\n      for (let j = this.recentQueue.length - 1; j >= 0; j--) {\n        const key = this.recentQueue[j];\n        if (allMetadata.has(key) && !keysToEvict.includes(key)) {\n          keyToEvict = key;\n          break;\n        }\n      }\n      if (!keyToEvict) {\n        if (this.config.useFrequencyWeightedLRU) {\n          keyToEvict = this.selectFromHotQueueFrequencyWeighted(allMetadata, keysToEvict);\n        } else {\n          keyToEvict = this.selectFromHotQueueLRU(allMetadata, keysToEvict);\n        }\n      }\n      if (keyToEvict) {\n        keysToEvict.push(keyToEvict);\n      } else {\n        break;\n      }\n    }\n    return keysToEvict;\n  }\n  /**\n   * Select eviction candidate from hot queue using traditional LRU\n   */\n  selectFromHotQueueLRU(items, excludeKeys = []) {\n    let oldestKey = null;\n    let oldestTime = Infinity;\n    for (const key of this.hotQueue) {\n      if (excludeKeys.includes(key)) continue;\n      const metadata = items.get(key);\n      if (metadata && metadata.lastAccessedAt < oldestTime) {\n        oldestTime = metadata.lastAccessedAt;\n        oldestKey = key;\n      }\n    }\n    return oldestKey || (items.size > 0 ? items.keys().next().value ?? null : null);\n  }\n  /**\n   * Select eviction candidate from hot queue using frequency-weighted LRU\n   */\n  selectFromHotQueueFrequencyWeighted(items, excludeKeys = []) {\n    let bestKey = null;\n    let lowestScore = Infinity;\n    for (const key of this.hotQueue) {\n      if (excludeKeys.includes(key)) continue;\n      const metadata = items.get(key);\n      if (!metadata) continue;\n      const frequency = this.getEffectiveFrequency(metadata);\n      const timeFactor = Date.now() - metadata.lastAccessedAt;\n      const normalizedTimeFactor = timeFactor / (1e3 * 60);\n      const score = normalizedTimeFactor / Math.max(1, frequency);\n      if (score < lowestScore) {\n        lowestScore = score;\n        bestKey = key;\n      }\n    }\n    return bestKey || (items.size > 0 ? items.keys().next().value ?? null : null);\n  }\n  onItemAccessed(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) return;\n    const now = Date.now();\n    metadata.lastAccessedAt = now;\n    metadata.accessCount++;\n    metadata.rawFrequency = metadata.accessCount;\n    if ((this.config.hotQueueDecayFactor ?? 0) > 0) {\n      metadata.frequencyScore = this.calculateFrequencyScore(metadata, now);\n      metadata.lastFrequencyUpdate = now;\n    }\n    const recentIndex = this.recentQueue.indexOf(key);\n    if (recentIndex !== -1) {\n      if (this.shouldPromoteToHotQueue(metadata)) {\n        this.recentQueue.splice(recentIndex, 1);\n        this.hotQueue.unshift(key);\n      }\n    } else {\n      const hotIndex = this.hotQueue.indexOf(key);\n      if (hotIndex !== -1) {\n        this.hotQueue.splice(hotIndex, 1);\n        this.hotQueue.unshift(key);\n      }\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemAdded(key, estimatedSize, metadataProvider) {\n    const now = Date.now();\n    let metadata = metadataProvider.getMetadata(key);\n    if (!metadata) {\n      metadata = {\n        key,\n        addedAt: now,\n        lastAccessedAt: now,\n        accessCount: 1,\n        estimatedSize,\n        rawFrequency: 1\n      };\n      if ((this.config.hotQueueDecayFactor ?? 0) > 0) {\n        metadata.frequencyScore = 1;\n        metadata.lastFrequencyUpdate = now;\n      }\n    }\n    if (this.ghostQueue.has(key)) {\n      this.ghostQueue.delete(key);\n      this.hotQueue.unshift(key);\n    } else {\n      this.recentQueue.unshift(key);\n      if (this.recentQueue.length > this.maxRecentSize) {\n        const evicted = this.recentQueue.pop();\n        if (evicted) {\n          this.ghostQueue.add(evicted);\n        }\n      }\n    }\n    if (this.ghostQueue.size > this.maxGhostSize) {\n      const firstKey = this.ghostQueue.values().next().value;\n      if (firstKey) {\n        this.ghostQueue.delete(firstKey);\n      }\n    }\n    metadataProvider.setMetadata(key, metadata);\n  }\n  onItemRemoved(key, metadataProvider) {\n    const recentIndex = this.recentQueue.indexOf(key);\n    if (recentIndex !== -1) {\n      this.recentQueue.splice(recentIndex, 1);\n    }\n    const hotIndex = this.hotQueue.indexOf(key);\n    if (hotIndex !== -1) {\n      this.hotQueue.splice(hotIndex, 1);\n    }\n    metadataProvider.deleteMetadata(key);\n  }\n  /**\n   * Determine if an item should be promoted from recent to hot queue\n   */\n  shouldPromoteToHotQueue(metadata) {\n    if (!this.config.useFrequencyPromotion) {\n      return metadata.accessCount >= 2;\n    }\n    const threshold = this.config.promotionThreshold ?? 2;\n    const frequency = this.getEffectiveFrequency(metadata);\n    return frequency >= threshold;\n  }\n  /**\n   * Get effective frequency for an item, applying decay if enabled\n   */\n  getEffectiveFrequency(metadata) {\n    if ((this.config.hotQueueDecayFactor ?? 0) === 0) {\n      return metadata.rawFrequency || metadata.accessCount;\n    }\n    const now = Date.now();\n    if (typeof metadata.frequencyScore === \"number\" && typeof metadata.lastFrequencyUpdate === \"number\") {\n      const timeSinceUpdate = now - metadata.lastFrequencyUpdate;\n      const decayAmount = timeSinceUpdate / (this.config.hotQueueDecayInterval ?? 3e5) * (this.config.hotQueueDecayFactor ?? 0.05);\n      return Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n    }\n    return metadata.rawFrequency || metadata.accessCount;\n  }\n  /**\n   * Calculate frequency score with decay applied\n   */\n  calculateFrequencyScore(metadata, currentTime) {\n    const rawFreq = metadata.rawFrequency || metadata.accessCount;\n    if (typeof metadata.lastFrequencyUpdate !== \"number\") {\n      return rawFreq;\n    }\n    const timeSinceUpdate = currentTime - metadata.lastFrequencyUpdate;\n    const decayAmount = timeSinceUpdate / (this.config.hotQueueDecayInterval ?? 3e5) * (this.config.hotQueueDecayFactor ?? 0.05);\n    const previousScore = metadata.frequencyScore || rawFreq;\n    const decayedScore = previousScore * (1 - decayAmount);\n    return Math.max(1, decayedScore + 1);\n  }\n  /**\n   * Apply periodic decay to hot queue items\n   */\n  applyPeriodicDecay(items) {\n    if ((this.config.hotQueueDecayFactor ?? 0) === 0) return;\n    const now = Date.now();\n    const timeSinceDecay = now - this.lastDecayTime;\n    if (timeSinceDecay >= (this.config.hotQueueDecayInterval ?? 3e5)) {\n      if (this.hotQueue.length > 0) {\n        for (const key of this.hotQueue) {\n          const metadata = items.get(key);\n          if (metadata && typeof metadata.frequencyScore === \"number\") {\n            const decayAmount = this.config.hotQueueDecayFactor ?? 0.05;\n            metadata.frequencyScore = Math.max(1, metadata.frequencyScore * (1 - decayAmount));\n          }\n        }\n        this.lastDecayTime = now;\n      }\n    }\n  }\n  /**\n   * Get configuration for this strategy\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n  /**\n   * Reset internal state (useful for testing)\n   */\n  reset() {\n    this.recentQueue = [];\n    this.hotQueue = [];\n    this.ghostQueue.clear();\n    this.lastDecayTime = Date.now();\n  }\n};\n\n// src/eviction/EvictionStrategyFactory.ts\nfunction createEvictionStrategy(policy, maxCacheSize, config) {\n  const safeMaxCacheSize = typeof maxCacheSize === \"number\" && maxCacheSize > 0 ? maxCacheSize : 1e3;\n  switch (policy) {\n    case \"lru\":\n      return new LRUEvictionStrategy();\n    case \"lfu\": {\n      try {\n        const lfuConfig = config?.type === \"lfu\" ? config : { type: \"lfu\" };\n        return new LFUEvictionStrategy(lfuConfig);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.warn(`Failed to create lfu strategy with provided configuration, falling back to LRU:`, errorMessage);\n        return new LRUEvictionStrategy();\n      }\n    }\n    case \"fifo\":\n      return new FIFOEvictionStrategy();\n    case \"mru\":\n      return new MRUEvictionStrategy();\n    case \"random\":\n      return new RandomEvictionStrategy();\n    case \"arc\": {\n      try {\n        const arcConfig = config?.type === \"arc\" ? config : { ...DEFAULT_ARC_CONFIG, maxCacheSize: safeMaxCacheSize };\n        const finalMaxSize = arcConfig.maxCacheSize && arcConfig.maxCacheSize > 0 ? arcConfig.maxCacheSize : safeMaxCacheSize;\n        return new ARCEvictionStrategy(finalMaxSize, { ...arcConfig, maxCacheSize: finalMaxSize });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.warn(`Failed to create arc strategy with provided configuration, falling back to LRU:`, errorMessage);\n        return new LRUEvictionStrategy();\n      }\n    }\n    case \"2q\": {\n      try {\n        const twoQConfig = config?.type === \"2q\" ? config : { ...DEFAULT_TWO_QUEUE_CONFIG, maxCacheSize: safeMaxCacheSize };\n        const finalMaxSize = twoQConfig.maxCacheSize && twoQConfig.maxCacheSize > 0 ? twoQConfig.maxCacheSize : safeMaxCacheSize;\n        return new TwoQueueEvictionStrategy(finalMaxSize, { ...twoQConfig, maxCacheSize: finalMaxSize });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.warn(`Failed to create 2q strategy with provided configuration, falling back to LRU:`, errorMessage);\n        return new LRUEvictionStrategy();\n      }\n    }\n    default:\n      throw new Error(`Unsupported eviction policy: ${policy}`);\n  }\n}\n\n// src/ttl/TTLManager.ts\nvar logger21 = logger_default.get(\"TTLManager\");\nvar TTLManager = class {\n  config;\n  cleanupTimer;\n  constructor(config = {}) {\n    this.config = {\n      autoCleanup: true,\n      cleanupInterval: 6e4,\n      // 1 minute default\n      validateOnAccess: true,\n      ...config\n    };\n    if (this.config.autoCleanup && this.config.cleanupInterval) {\n      this.startAutoCleanup();\n    }\n  }\n  /**\n   * Check if TTL is enabled\n   */\n  isTTLEnabled() {\n    return typeof this.config.defaultTTL === \"number\" && this.config.defaultTTL > 0;\n  }\n  /**\n   * Get the default TTL value\n   */\n  getDefaultTTL() {\n    return this.config.defaultTTL;\n  }\n  /**\n   * Update TTL configuration\n   */\n  updateConfig(config) {\n    const oldConfig = this.config;\n    this.config = { ...this.config, ...config };\n    if (oldConfig.autoCleanup !== this.config.autoCleanup || oldConfig.cleanupInterval !== this.config.cleanupInterval) {\n      this.stopAutoCleanup();\n      if (this.config.autoCleanup && this.config.cleanupInterval) {\n        this.startAutoCleanup();\n      }\n    }\n    logger21.debug(\"TTL configuration updated\", { config: this.config });\n  }\n  /**\n   * Set TTL metadata for an item when it's added\n   */\n  onItemAdded(key, metadataProvider, itemTTL) {\n    if (!this.isTTLEnabled() && !itemTTL) {\n      return;\n    }\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) {\n      logger21.warning(\"No metadata found for item when setting TTL\", { key });\n      return;\n    }\n    const ttl = itemTTL || this.config.defaultTTL;\n    if (ttl && ttl > 0) {\n      const ttlMetadata = {\n        ...metadata,\n        expiresAt: metadata.addedAt + ttl,\n        ttl\n      };\n      metadataProvider.setMetadata(key, ttlMetadata);\n      logger21.trace(\"TTL set for item\", { key, ttl, expiresAt: ttlMetadata.expiresAt });\n    }\n  }\n  /**\n   * Check if an item has expired\n   */\n  isExpired(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata || !metadata.expiresAt) {\n      return false;\n    }\n    const now = Date.now();\n    const expired = now >= metadata.expiresAt;\n    if (expired) {\n      logger21.trace(\"Item expired\", { key, expiresAt: metadata.expiresAt, now });\n    }\n    return expired;\n  }\n  /**\n   * Check if an item is valid (not expired) before returning it\n   * Returns true if item is valid, false if expired\n   */\n  validateItem(key, metadataProvider) {\n    if (!this.config.validateOnAccess) {\n      return true;\n    }\n    return !this.isExpired(key, metadataProvider);\n  }\n  /**\n   * Get TTL information for an item\n   */\n  getItemTTLInfo(key, metadataProvider) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata || !metadata.expiresAt) {\n      return { hasTTL: false, isExpired: false };\n    }\n    const now = Date.now();\n    const isExpired = now >= metadata.expiresAt;\n    const remainingTTL = isExpired ? 0 : metadata.expiresAt - now;\n    return {\n      hasTTL: true,\n      ttl: metadata.ttl,\n      expiresAt: metadata.expiresAt,\n      remainingTTL,\n      isExpired\n    };\n  }\n  /**\n   * Find all expired items\n   */\n  findExpiredItems(metadataProvider) {\n    const expiredKeys = [];\n    const allMetadata = metadataProvider.getAllMetadata();\n    const now = Date.now();\n    for (const [key, metadata] of allMetadata) {\n      const ttlMetadata = metadata;\n      if (ttlMetadata.expiresAt && now >= ttlMetadata.expiresAt) {\n        expiredKeys.push(key);\n      }\n    }\n    if (expiredKeys.length > 0) {\n      logger21.debug(\"Found expired items\", { count: expiredKeys.length, keys: expiredKeys });\n    }\n    return expiredKeys;\n  }\n  /**\n   * Manually clean up expired items\n   * Returns the keys of items that were expired\n   */\n  cleanupExpiredItems(metadataProvider) {\n    return this.findExpiredItems(metadataProvider);\n  }\n  /**\n   * Get remaining TTL for an item in milliseconds\n   */\n  getRemainingTTL(key, metadataProvider) {\n    const info = this.getItemTTLInfo(key, metadataProvider);\n    return info.hasTTL ? info.remainingTTL || 0 : null;\n  }\n  /**\n   * Extend TTL for an item\n   */\n  extendTTL(key, metadataProvider, additionalTTL) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata || !metadata.expiresAt) {\n      return false;\n    }\n    metadata.expiresAt += additionalTTL;\n    metadataProvider.setMetadata(key, metadata);\n    logger21.trace(\"TTL extended for item\", { key, additionalTTL, newExpiresAt: metadata.expiresAt });\n    return true;\n  }\n  /**\n   * Reset TTL for an item (refresh expiration)\n   */\n  refreshTTL(key, metadataProvider, newTTL) {\n    const metadata = metadataProvider.getMetadata(key);\n    if (!metadata) {\n      return false;\n    }\n    const ttl = newTTL || metadata.ttl || this.config.defaultTTL;\n    if (!ttl) {\n      return false;\n    }\n    const now = Date.now();\n    const ttlMetadata = {\n      ...metadata,\n      expiresAt: now + ttl,\n      ttl\n    };\n    metadataProvider.setMetadata(key, ttlMetadata);\n    logger21.trace(\"TTL refreshed for item\", { key, ttl, expiresAt: ttlMetadata.expiresAt });\n    return true;\n  }\n  /**\n   * Start automatic cleanup of expired items\n   */\n  startAutoCleanup() {\n    if (this.cleanupTimer) {\n      this.stopAutoCleanup();\n    }\n    if (this.config.cleanupInterval) {\n      this.cleanupTimer = setInterval(() => {\n        logger21.trace(\"Auto cleanup timer triggered\");\n      }, this.config.cleanupInterval);\n      logger21.debug(\"Auto cleanup started\", { interval: this.config.cleanupInterval });\n    }\n  }\n  /**\n   * Stop automatic cleanup\n   */\n  stopAutoCleanup() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n      logger21.debug(\"Auto cleanup stopped\");\n    }\n  }\n  /**\n   * Cleanup resources\n   */\n  destroy() {\n    this.stopAutoCleanup();\n    logger21.debug(\"TTL manager destroyed\");\n  }\n};\n\n// src/events/CacheEventEmitter.ts\nvar CacheEventEmitter = class {\n  subscriptions = /* @__PURE__ */ new Map();\n  nextSubscriptionId = 1;\n  isDestroyed = false;\n  cleanupInterval = null;\n  CLEANUP_INTERVAL_MS = 3e4;\n  // 30 seconds\n  MAX_INACTIVE_TIME_MS = 3e5;\n  // 5 minutes\n  WEAK_REF_ENABLED = typeof WeakRef !== \"undefined\";\n  constructor() {\n    this.startPeriodicCleanup();\n  }\n  /**\n   * Start periodic cleanup of inactive subscriptions\n   */\n  startPeriodicCleanup() {\n    if (this.cleanupInterval) return;\n    this.cleanupInterval = setInterval(() => {\n      this.performPeriodicCleanup();\n    }, this.CLEANUP_INTERVAL_MS);\n    if (this.cleanupInterval.unref) {\n      this.cleanupInterval.unref();\n    }\n  }\n  /**\n   * Perform periodic cleanup of inactive subscriptions\n   */\n  performPeriodicCleanup() {\n    if (this.isDestroyed) return;\n    const now = Date.now();\n    const toRemove = [];\n    for (const [id, subscription] of this.subscriptions) {\n      if (!subscription.isActive || now - subscription.lastAccessTime > this.MAX_INACTIVE_TIME_MS) {\n        toRemove.push(id);\n        continue;\n      }\n      if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n        const listener = subscription.listenerRef.deref();\n        if (!listener) {\n          toRemove.push(id);\n          continue;\n        }\n      }\n    }\n    toRemove.forEach((id) => this.unsubscribe(id));\n  }\n  /**\n   * Subscribe to cache events\n   */\n  subscribe(listener, options = {}) {\n    if (this.isDestroyed) {\n      throw new Error(\"Cannot subscribe to destroyed event emitter\");\n    }\n    const id = `subscription_${this.nextSubscriptionId++}`;\n    const now = Date.now();\n    const subscription = {\n      id,\n      listener,\n      listenerRef: this.WEAK_REF_ENABLED && options.useWeakRef !== false ? new WeakRef(listener) : void 0,\n      options,\n      isActive: true,\n      createdAt: now,\n      lastAccessTime: now\n    };\n    this.subscriptions.set(id, subscription);\n    return {\n      id,\n      unsubscribe: () => this.unsubscribe(id),\n      isActive: () => {\n        const sub = this.subscriptions.get(id);\n        if (sub) {\n          sub.lastAccessTime = Date.now();\n        }\n        return sub?.isActive ?? false;\n      },\n      getOptions: () => ({ ...options })\n    };\n  }\n  /**\n   * Unsubscribe from events\n   */\n  unsubscribe(subscriptionId) {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) {\n      return false;\n    }\n    if (subscription.debounceTimer) {\n      clearTimeout(subscription.debounceTimer);\n      subscription.debounceTimer = null;\n    }\n    subscription.isActive = false;\n    this.subscriptions.delete(subscriptionId);\n    return true;\n  }\n  /**\n   * Emit an event to all matching subscriptions\n   */\n  emit(event) {\n    if (this.isDestroyed) {\n      return;\n    }\n    for (const subscription of this.subscriptions.values()) {\n      if (!subscription.isActive) {\n        continue;\n      }\n      if (this.shouldEmitToSubscription(event, subscription)) {\n        this.emitToSubscription(event, subscription);\n      }\n    }\n  }\n  /**\n   * Get count of active subscriptions\n   */\n  getSubscriptionCount() {\n    return Array.from(this.subscriptions.values()).filter((s) => s.isActive).length;\n  }\n  /**\n   * Get subscription details (for debugging)\n   */\n  getSubscriptions() {\n    return Array.from(this.subscriptions.values()).filter((s) => s.isActive).map((s) => ({ id: s.id, options: { ...s.options } }));\n  }\n  /**\n   * Destroy the event emitter and clean up all subscriptions\n   */\n  destroy() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    for (const subscription of this.subscriptions.values()) {\n      if (subscription.debounceTimer) {\n        clearTimeout(subscription.debounceTimer);\n        subscription.debounceTimer = null;\n      }\n      subscription.isActive = false;\n    }\n    this.subscriptions.clear();\n    this.isDestroyed = true;\n  }\n  /**\n   * Check if an event should be emitted to a specific subscription\n   */\n  shouldEmitToSubscription(event, subscription) {\n    const { options } = subscription;\n    if (options.eventTypes && !options.eventTypes.includes(event.type)) {\n      return false;\n    }\n    if (options.keys && options.keys.length > 0) {\n      if (\"key\" in event) {\n        const eventKeyStr = this.normalizeKey(event.key);\n        const matchesKey = options.keys.some(\n          (key) => this.normalizeKey(key) === eventKeyStr\n        );\n        if (!matchesKey) {\n          return false;\n        }\n      } else if (\"affectedKeys\" in event) {\n        const eventKeyStrs = event.affectedKeys.map((key) => this.normalizeKey(key));\n        const hasMatchingKey = options.keys.some(\n          (key) => eventKeyStrs.includes(this.normalizeKey(key))\n        );\n        if (!hasMatchingKey) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    if (options.locations && options.locations.length > 0) {\n      if (\"affectedLocations\" in event && event.affectedLocations) {\n        if (!this.locationsMatch(options.locations, event.affectedLocations)) {\n          return false;\n        }\n      } else if (\"locations\" in event) {\n        if (!this.locationsMatch(options.locations, event.locations)) {\n          return false;\n        }\n      } else if (\"key\" in event) {\n        if (!this.keyMatchesLocations(event.key, options.locations)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    if (options.query) {\n      if (\"query\" in event) {\n        if (!this.queriesMatch(options.query, event.query)) {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n    return true;\n  }\n  /**\n   * Emit event to a specific subscription, handling debouncing\n   */\n  emitToSubscription(event, subscription) {\n    subscription.lastAccessTime = Date.now();\n    let listener = subscription.listener;\n    if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n      const weakListener = subscription.listenerRef.deref();\n      if (!weakListener) {\n        subscription.isActive = false;\n        return;\n      }\n      listener = weakListener;\n    }\n    if (!subscription.options.debounceMs) {\n      try {\n        listener(event);\n      } catch (error) {\n        this.handleListenerError(error, event, subscription);\n      }\n      return;\n    }\n    if (subscription.debounceTimer) {\n      clearTimeout(subscription.debounceTimer);\n      subscription.debounceTimer = null;\n    }\n    subscription.debounceTimer = setTimeout(() => {\n      if (subscription.isActive) {\n        let currentListener = subscription.listener;\n        if (this.WEAK_REF_ENABLED && subscription.listenerRef) {\n          const weakListener = subscription.listenerRef.deref();\n          if (!weakListener) {\n            subscription.isActive = false;\n            subscription.debounceTimer = null;\n            return;\n          }\n          currentListener = weakListener;\n        }\n        try {\n          currentListener(event);\n          subscription.lastEmitTime = Date.now();\n        } catch (error) {\n          this.handleListenerError(error, event, subscription);\n        }\n      }\n      subscription.debounceTimer = null;\n    }, subscription.options.debounceMs);\n  }\n  /**\n   * Normalize a key for comparison\n   */\n  normalizeKey(key) {\n    return JSON.stringify(key, (k, v) => {\n      if (typeof v === \"string\" || typeof v === \"number\") {\n        return normalizeKeyValue(v);\n      }\n      return v;\n    });\n  }\n  /**\n   * Normalize a location key for comparison\n   */\n  normalizeLocKey(key) {\n    return JSON.stringify(key, (k, v) => {\n      if (typeof v === \"string\" || typeof v === \"number\") {\n        return normalizeKeyValue(v);\n      }\n      return v;\n    });\n  }\n  /**\n   * Check if two location arrays match\n   */\n  locationsMatch(filter, eventLocations) {\n    if (filter.length === 0 && eventLocations.length === 0) {\n      return true;\n    }\n    if (filter.length !== eventLocations.length) {\n      return false;\n    }\n    return filter.every((filterLoc, index) => {\n      const eventLoc = eventLocations[index];\n      return this.normalizeKey(filterLoc) === this.normalizeKey(eventLoc);\n    });\n  }\n  /**\n   * Check if a key matches location filters\n   */\n  keyMatchesLocations(key, filterLocations) {\n    if (\"loc\" in key && key.loc) {\n      return this.locationsMatch(filterLocations, key.loc);\n    }\n    return filterLocations.length === 0;\n  }\n  /**\n   * Check if two queries match (improved comparison)\n   */\n  queriesMatch(filterQuery, eventQuery) {\n    const normalize = (obj) => {\n      if (obj === null || typeof obj === \"undefined\") return obj;\n      if (typeof obj !== \"object\") return obj;\n      if (Array.isArray(obj)) return obj.map(normalize).sort();\n      const sorted = {};\n      Object.keys(obj).sort().forEach((key) => {\n        sorted[key] = normalize(obj[key]);\n      });\n      return sorted;\n    };\n    return JSON.stringify(normalize(filterQuery)) === JSON.stringify(normalize(eventQuery));\n  }\n  /**\n   * Handle errors that occur in event listeners\n   */\n  handleListenerError(error, event, subscription) {\n    const errorObj = error instanceof Error ? error : new Error(String(error));\n    if (subscription.options.onError) {\n      try {\n        subscription.options.onError(errorObj, event);\n      } catch (handlerError) {\n        console.error(\"Error in cache event listener:\", errorObj);\n        console.error(\"Error in error handler:\", handlerError);\n      }\n    } else {\n      console.error(\"Error in cache event listener:\", errorObj);\n    }\n  }\n};\n\n// src/CacheStats.ts\nvar CacheStatsManager = class {\n  stats = {\n    numRequests: 0,\n    numMisses: 0,\n    numHits: 0,\n    numSubscriptions: 0,\n    numUnsubscriptions: 0,\n    activeSubscriptions: 0\n  };\n  /**\n   * Increment the request counter\n   */\n  incrementRequests() {\n    this.stats.numRequests++;\n  }\n  /**\n   * Increment the cache hit counter\n   */\n  incrementHits() {\n    this.stats.numHits++;\n  }\n  /**\n   * Increment the cache miss counter\n   */\n  incrementMisses() {\n    this.stats.numMisses++;\n  }\n  /**\n   * Increment the subscription counter\n   */\n  incrementSubscriptions() {\n    this.stats.numSubscriptions++;\n    this.stats.activeSubscriptions++;\n  }\n  /**\n   * Increment the unsubscription counter\n   */\n  incrementUnsubscriptions() {\n    this.stats.numUnsubscriptions++;\n    if (this.stats.activeSubscriptions > 0) {\n      this.stats.activeSubscriptions--;\n    }\n  }\n  /**\n   * Get a copy of the current statistics\n   */\n  getStats() {\n    return { ...this.stats };\n  }\n  /**\n   * Reset all statistics to zero\n   */\n  reset() {\n    this.stats = {\n      numRequests: 0,\n      numMisses: 0,\n      numHits: 0,\n      numSubscriptions: 0,\n      numUnsubscriptions: 0,\n      activeSubscriptions: 0\n    };\n  }\n};\n\n// src/Cache.ts\nvar logger22 = logger_default.get(\"Cache\");\nvar createCache = (api, coordinate, registry, options) => {\n  logger22.debug(\"createCache\", { coordinate, registry, options });\n  const completeOptions = createOptions(options);\n  const cacheMap = createCacheMap(coordinate.kta, completeOptions);\n  const pkType = coordinate.kta[0];\n  const eventEmitter = new CacheEventEmitter();\n  const evictionManager = new EvictionManager();\n  const evictionConfig = completeOptions.evictionConfig;\n  if (!evictionConfig && completeOptions.memoryConfig?.size?.evictionPolicy && (completeOptions.memoryConfig.size.maxItems || completeOptions.memoryConfig.size.maxSizeBytes)) {\n  }\n  if (evictionConfig) {\n    const strategy = createEvictionStrategy(\n      evictionConfig.type || \"lru\",\n      completeOptions.memoryConfig?.maxItems,\n      evictionConfig\n    );\n    evictionManager.setEvictionStrategy(strategy);\n  }\n  const ttlManager = new TTLManager({\n    defaultTTL: completeOptions.ttl,\n    autoCleanup: true,\n    validateOnAccess: true\n  });\n  const statsManager = new CacheStatsManager();\n  const operations = createOperations(api, coordinate, cacheMap, pkType, completeOptions, eventEmitter, ttlManager, evictionManager, statsManager);\n  const cache = {\n    coordinate,\n    registry,\n    api,\n    cacheMap,\n    operations,\n    options: completeOptions,\n    eventEmitter,\n    evictionManager,\n    ttlManager,\n    statsManager,\n    getCacheInfo: () => {\n      const evictionStrategyName = evictionManager.getEvictionStrategyName();\n      const cacheInfo = {\n        implementationType: cacheMap.implementationType,\n        defaultTTL: ttlManager.getDefaultTTL(),\n        // Cache supports TTL if the CacheMap supports it OR if TTL is configured\n        supportsTTL: cacheMap.supportsTTL?.() || !!ttlManager.getDefaultTTL(),\n        supportsEviction: evictionManager.isEvictionSupported()\n      };\n      if (evictionStrategyName) {\n        cacheInfo.evictionPolicy = evictionStrategyName;\n      }\n      return cacheInfo;\n    },\n    getStats: () => statsManager.getStats(),\n    subscribe: (listener, options2) => {\n      statsManager.incrementSubscriptions();\n      return eventEmitter.subscribe(listener, options2);\n    },\n    unsubscribe: (subscription) => {\n      const result = eventEmitter.unsubscribe(subscription.id);\n      if (result) {\n        statsManager.incrementUnsubscriptions();\n      }\n      return result;\n    },\n    destroy: () => {\n      eventEmitter.destroy();\n      if (ttlManager && typeof ttlManager.destroy === \"function\") {\n        ttlManager.destroy();\n      }\n      if (cacheMap && typeof cacheMap.destroy === \"function\") {\n        cacheMap.destroy();\n      }\n      CacheEventFactory.destroyInstance();\n    }\n  };\n  return cache;\n};\nvar isCache = (cache) => {\n  return cache !== null && typeof cache === \"object\" && \"coordinate\" in cache && \"registry\" in cache && \"api\" in cache && \"cacheMap\" in cache && \"operations\" in cache;\n};\n\n// src/InstanceFactory.ts\nvar logger23 = logger_default.get(\"InstanceFactory\");\nvar createInstanceFactory = (api, options) => {\n  const templateOptions = createOptions(options);\n  validateOptions(templateOptions);\n  return (coordinate, context) => {\n    const instanceOptions = createOptions(options);\n    logger23.debug(\"Creating cache instance\", {\n      coordinate,\n      registry: context.registry,\n      api,\n      cacheType: instanceOptions.cacheType,\n      options: instanceOptions\n    });\n    const cacheMap = createCacheMap(coordinate.kta, instanceOptions);\n    const pkType = coordinate.kta[0];\n    const eventEmitter = new CacheEventEmitter();\n    const ttlManager = new TTLManager({\n      defaultTTL: instanceOptions.ttl,\n      autoCleanup: true,\n      validateOnAccess: true\n    });\n    const evictionManager = new EvictionManager();\n    const statsManager = new CacheStatsManager();\n    const operations = createOperations(\n      api,\n      coordinate,\n      cacheMap,\n      pkType,\n      instanceOptions,\n      eventEmitter,\n      ttlManager,\n      evictionManager,\n      statsManager\n    );\n    return {\n      coordinate,\n      registry: context.registry,\n      api,\n      cacheMap,\n      operations,\n      options: instanceOptions,\n      eventEmitter,\n      ttlManager,\n      evictionManager,\n      getCacheInfo: () => {\n        const evictionStrategyName = evictionManager.getEvictionStrategyName();\n        const cacheInfo = {\n          implementationType: cacheMap.implementationType,\n          defaultTTL: ttlManager.getDefaultTTL(),\n          supportsTTL: cacheMap.supportsTTL?.() || !!ttlManager.getDefaultTTL(),\n          supportsEviction: evictionManager.isEvictionSupported()\n        };\n        if (evictionStrategyName) {\n          cacheInfo.evictionPolicy = evictionStrategyName;\n        }\n        return cacheInfo;\n      },\n      subscribe: (listener, options2) => eventEmitter.subscribe(listener, options2),\n      unsubscribe: (subscription) => eventEmitter.unsubscribe(subscription.id),\n      destroy: () => {\n        if (typeof ttlManager.destroy === \"function\") {\n          ttlManager.destroy();\n        }\n        eventEmitter.destroy();\n      }\n    };\n  };\n};\n\n// src/Instance.ts\nvar logger24 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate, api, options) => {\n  logger24.debug(\"createInstance\", { coordinate, api, registry, options });\n  return createCache(api, coordinate, registry, options);\n};\nvar isInstance = (instance) => {\n  return instance !== null && typeof instance === \"object\" && \"coordinate\" in instance && \"registry\" in instance && \"api\" in instance && \"cacheMap\" in instance && \"operations\" in instance;\n};\n\n// src/Aggregator.ts\nvar logger25 = logger_default.get(\"ItemAggregator\");\nvar toCacheConfig = (config) => {\n  let cacheConfig;\n  if (config.optional === void 0) {\n    cacheConfig = { cache: config, optional: false };\n  } else {\n    cacheConfig = config;\n  }\n  return cacheConfig;\n};\nvar createAggregator = async (cache, { aggregates = {}, events = {} }) => {\n  const populate = async (item) => {\n    logger25.default(\"populate\", { item });\n    for (const key in aggregates) {\n      await populateAggregate(key, item);\n    }\n    for (const key in events) {\n      await populateEvent(key, item);\n    }\n    logger25.default(\"populate done\", { item });\n    return item;\n  };\n  const populateAggregate = async (key, item) => {\n    logger25.default(\"populate aggregate key\", { key });\n    const cacheConfig = toCacheConfig(aggregates[key]);\n    if (item.refs === void 0) {\n      if (cacheConfig.optional === false) {\n        logger25.error(\"Item does not have refs an is not optional \", { item });\n        throw new Error(\"Item does not have refs an is not optional \" + JSON.stringify(item));\n      } else {\n        if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n          delete item.events[key];\n        }\n      }\n    } else if (item.refs[key] === void 0) {\n      if (cacheConfig.optional === false) {\n        logger25.error(\"Item does not have mandatory ref with key, not optional \", { key, item });\n        throw new Error(\"Item does not have mandatory ref with key, not optional \" + key + \" \" + JSON.stringify(item));\n      } else {\n        if (item.events && Object.prototype.hasOwnProperty.call(item.events, key)) {\n          delete item.events[key];\n        }\n      }\n    } else {\n      const ref = item.refs[key];\n      logger25.default(\"AGG Retrieving Item in Populate\", { key: ref });\n      const newItem = await cacheConfig.cache.operations.retrieve(ref);\n      if (newItem) {\n        if (item.aggs === void 0) {\n          item.aggs = {};\n        }\n        item.aggs[key] = {\n          key: ref,\n          item: newItem\n        };\n      }\n    }\n  };\n  const populateEvent = async (key, item) => {\n    logger25.default(\"populate event key\", { key });\n    const cacheConfig = toCacheConfig(events[key]);\n    if (item.events === void 0) {\n      throw new Error(\"Item does not have events \" + JSON.stringify(item));\n    } else if (item.events[key] === void 0) {\n      if (cacheConfig.optional === false) {\n        logger25.error(\"Item does not have mandatory event with key\", { key, item });\n        throw new Error(\"Item does not have mandatory event with key \" + key + \" \" + JSON.stringify(item));\n      }\n    } else {\n      const event = item.events[key];\n      if (event.by === void 0) {\n        logger25.error(\n          \"populateEvent with an Event that does not have by\",\n          { event, ik: item.key, eventKey: key }\n        );\n        throw new Error(\"populateEvent with an Event that does not have by: \" + JSON.stringify({ key }));\n      }\n      logger25.default(\"EVENT Retrieving Item in Populate\", { key: event.by });\n      const newItem = await cacheConfig.cache.operations.retrieve(event.by);\n      if (newItem) {\n        event.agg = newItem;\n      }\n    }\n  };\n  const all2 = async (query = {}, locations = []) => {\n    logger25.default(\"all\", { query, locations });\n    const items = await cache.operations.all(query, locations);\n    const populatedItems = await Promise.all(items.map(async (item) => populate(item)));\n    return populatedItems;\n  };\n  const one2 = async (query = {}, locations = []) => {\n    logger25.default(\"one\", { query, locations });\n    const item = await cache.operations.one(query, locations);\n    let populatedItem = null;\n    if (item) {\n      populatedItem = await populate(item);\n    }\n    return populatedItem;\n  };\n  const action2 = async (key, action3, body = {}) => {\n    logger25.default(\"action\", { key, action: action3, body });\n    const item = await cache.operations.action(key, action3, body);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const allAction2 = async (action3, body = {}, locations = []) => {\n    logger25.default(\"action\", { action: action3, body, locations });\n    const items = await cache.operations.allAction(action3, body, locations);\n    const populatedItems = await Promise.all(items.map(async (item) => populate(item)));\n    return populatedItems;\n  };\n  const allFacet2 = async (facet3, params = {}, locations = []) => {\n    logger25.default(\"allFacet\", { facet: facet3, params, locations });\n    const response = await cache.operations.allFacet(facet3, params, locations);\n    return response;\n  };\n  const create2 = async (v, locations = []) => {\n    logger25.default(\"create\", { v, locations });\n    const item = await cache.operations.create(v, locations);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const get2 = async (key) => {\n    logger25.default(\"get\", { key });\n    const item = await cache.operations.get(key);\n    let populatedItem = null;\n    if (item) {\n      populatedItem = await populate(item);\n    }\n    return populatedItem;\n  };\n  const retrieve2 = async (key) => {\n    logger25.default(\"retrieve\", { key });\n    const item = await cache.operations.retrieve(key);\n    let populatedItem = null;\n    if (item) {\n      populatedItem = await populate(item);\n    }\n    return populatedItem;\n  };\n  const remove2 = async (key) => {\n    logger25.default(\"remove\", { key });\n    await cache.operations.remove(key);\n  };\n  const update2 = async (key, v) => {\n    logger25.default(\"update\", { key, v });\n    const item = await cache.operations.update(key, v);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const facet2 = async (key, facet3) => {\n    logger25.default(\"facet\", { key, facet: facet3 });\n    const response = await cache.operations.facet(key, facet3);\n    return response;\n  };\n  const find2 = async (finder, finderParams = {}, locations = []) => {\n    logger25.default(\"find\", { finder, finderParams, locations });\n    const items = await cache.operations.find(finder, finderParams, locations);\n    const populatedItems = await Promise.all(items.map(async (item) => populate(item)));\n    return populatedItems;\n  };\n  const findOne2 = async (finder, finderParams = {}, locations = []) => {\n    logger25.default(\"find\", { finder, finderParams, locations });\n    const item = await cache.operations.findOne(finder, finderParams, locations);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const set2 = async (key, v) => {\n    logger25.default(\"set\", { key, v });\n    const item = await cache.operations.set(key, v);\n    const populatedItem = await populate(item);\n    return populatedItem;\n  };\n  const reset2 = async () => {\n    await cache.operations.reset();\n  };\n  return {\n    // Cache properties\n    coordinate: cache.coordinate,\n    registry: cache.registry,\n    api: cache.api,\n    cacheMap: cache.cacheMap,\n    operations: cache.operations,\n    evictionManager: cache.evictionManager,\n    ttlManager: cache.ttlManager,\n    statsManager: cache.statsManager,\n    getStats: cache.getStats.bind(cache),\n    getCacheInfo: cache.getCacheInfo.bind(cache),\n    // Cache operations exposed directly\n    all: all2,\n    one: one2,\n    action: action2,\n    allAction: allAction2,\n    allFacet: allFacet2,\n    create: create2,\n    get: get2,\n    retrieve: retrieve2,\n    remove: remove2,\n    update: update2,\n    facet: facet2,\n    find: find2,\n    findOne: findOne2,\n    reset: reset2,\n    set: set2,\n    // Aggregator-specific operations\n    populate,\n    populateAggregate,\n    populateEvent,\n    // Event system\n    eventEmitter: cache.eventEmitter,\n    subscribe: (listener, options) => cache.subscribe(listener, options),\n    unsubscribe: (subscription) => cache.unsubscribe(subscription),\n    destroy: () => cache.destroy()\n  };\n};\n\n// src/Registry.ts\n\nvar logger26 = logger_default.get(\"Registry\");\nvar createRegistryFactory = () => {\n  return (type, registryHub) => {\n    if (type !== \"cache\") {\n      throw new Error(`Cache registry factory can only create 'cache' type registries, got: ${type}`);\n    }\n    logger26.debug(\"Creating cache registry\", { type, registryHub });\n    const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(type, registryHub);\n    return baseRegistry;\n  };\n};\nvar createRegistry = (registryHub) => {\n  const baseRegistry = (0,_fjell_registry__WEBPACK_IMPORTED_MODULE_4__.createRegistry)(\"cache\", registryHub);\n  return {\n    ...baseRegistry\n  };\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9jYWNoZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHcUI7QUFDMkI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsUUFBUTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHNCQUFzQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHNCQUFzQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RB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QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscURBQVM7QUFDNUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9FQUFvRSxZQUFZO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTixtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQW1EO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQW1EO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsdURBQXVELDBDQUEwQztBQUNqRyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSw0REFBNEQsMkNBQTJDO0FBQ3ZHLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRDQUE0QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5Q0FBeUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4Q0FBOEM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHNEQUFzRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNENBQTRDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwrQ0FBK0MsdUNBQXVDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYscUJBQXFCLGdCQUFnQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0JBQStCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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cm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9jYWNoZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9DYWNoZUNvbnRleHQudHNcbnZhciBjcmVhdGVDYWNoZUNvbnRleHQgPSAoYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCBvcHRpb25zLCBldmVudEVtaXR0ZXIsIHR0bE1hbmFnZXIsIGV2aWN0aW9uTWFuYWdlciwgc3RhdHNNYW5hZ2VyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgYXBpLFxuICAgIGNhY2hlTWFwLFxuICAgIHBrVHlwZSxcbiAgICBvcHRpb25zLFxuICAgIGV2ZW50RW1pdHRlcixcbiAgICB0dGxNYW5hZ2VyLFxuICAgIGV2aWN0aW9uTWFuYWdlcixcbiAgICBzdGF0c01hbmFnZXJcbiAgfTtcbn07XG5cbi8vIHNyYy9vcHMvYWxsLnRzXG5pbXBvcnQge1xuICB2YWxpZGF0ZVBLXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgTm90Rm91bmRFcnJvciB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcblxuLy8gc3JjL25vcm1hbGl6YXRpb24udHNcbnZhciBub3JtYWxpemVLZXlWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn07XG52YXIgZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSA9IChvYmopID0+IHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBcIltcIiArIG9iai5tYXAoZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSkuam9pbihcIixcIikgKyBcIl1cIjtcbiAgfVxuICBjb25zdCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KCk7XG4gIGNvbnN0IGtleVZhbHVlUGFpcnMgPSBzb3J0ZWRLZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjpcIiArIGRldGVybWluaXN0aWNTdHJpbmdpZnkob2JqW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIFwie1wiICsga2V5VmFsdWVQYWlycy5qb2luKFwiLFwiKSArIFwifVwiO1xufTtcbnZhciBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gKCkgPT4ge1xuICByZXR1cm4gKGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG4gICAgICBpZiAoXCJwa1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgbm9ybWFsaXplZEtleS5wayAhPT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkS2V5LnBrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5wayk7XG4gICAgICB9XG4gICAgICBpZiAoXCJsa1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgbm9ybWFsaXplZEtleS5sayAhPT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkS2V5LmxrID0gbm9ybWFsaXplS2V5VmFsdWUobm9ybWFsaXplZEtleS5sayk7XG4gICAgICB9XG4gICAgICBpZiAoXCJsb2NcIiBpbiBub3JtYWxpemVkS2V5ICYmIEFycmF5LmlzQXJyYXkobm9ybWFsaXplZEtleS5sb2MpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubG9jID0gbm9ybWFsaXplZEtleS5sb2MubWFwKChsb2NJdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsb2NJdGVtID09PSBcIm9iamVjdFwiICYmIGxvY0l0ZW0gIT09IG51bGwgJiYgXCJsa1wiIGluIGxvY0l0ZW0gJiYgbG9jSXRlbS5sayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubG9jSXRlbSwgbGs6IG5vcm1hbGl6ZUtleVZhbHVlKGxvY0l0ZW0ubGspIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NJdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG5vcm1hbGl6ZWRLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgfTtcbn07XG52YXIgaXNMb2NLZXlBcnJheUVxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub3JtYWxpemVkQSA9IG5vcm1hbGl6ZUxvY0tleUl0ZW0oYVtpXSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEIgPSBub3JtYWxpemVMb2NLZXlJdGVtKGJbaV0pO1xuICAgIGlmIChkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG5vcm1hbGl6ZWRBKSAhPT0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShub3JtYWxpemVkQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIG5vcm1hbGl6ZUxvY0tleUl0ZW0gPSAoaXRlbSkgPT4ge1xuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgaXRlbSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7IC4uLml0ZW0gfTtcbiAgICBpZiAoXCJsa1wiIGluIG5vcm1hbGl6ZWQgJiYgbm9ybWFsaXplZC5sayAhPT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZC5sayA9IG5vcm1hbGl6ZUtleVZhbHVlKG5vcm1hbGl6ZWQubGspO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG52YXIgY3JlYXRlUXVlcnlIYXNoID0gKHBrVHlwZSwgcXVlcnksIGxvY2F0aW9ucykgPT4ge1xuICBjb25zdCBub3JtYWxpemVkUXVlcnkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHF1ZXJ5IHx8IHt9KSk7XG4gIGNvbnN0IHNvcnRlZFF1ZXJ5S2V5cyA9IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRRdWVyeSkuc29ydCgpO1xuICBjb25zdCBzb3J0ZWRRdWVyeSA9IHt9O1xuICBzb3J0ZWRRdWVyeUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgc29ydGVkUXVlcnlba2V5XSA9IG5vcm1hbGl6ZWRRdWVyeVtrZXldO1xuICB9KTtcbiAgY29uc3QgbG9jYXRpb25zQXJyYXkgPSBBcnJheS5pc0FycmF5KGxvY2F0aW9ucykgPyBsb2NhdGlvbnMgOiBbXTtcbiAgY29uc3Qgbm9ybWFsaXplZExvY2F0aW9ucyA9IGxvY2F0aW9uc0FycmF5Lm1hcChub3JtYWxpemVMb2NLZXlJdGVtKTtcbiAgY29uc3QgaGFzaElucHV0ID0ge1xuICAgIHR5cGU6IFwicXVlcnlcIixcbiAgICBwa1R5cGUsXG4gICAgcXVlcnk6IHNvcnRlZFF1ZXJ5LFxuICAgIGxvY2F0aW9uczogbm9ybWFsaXplZExvY2F0aW9uc1xuICB9O1xuICByZXR1cm4gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShoYXNoSW5wdXQpO1xufTtcbnZhciBjcmVhdGVGaW5kZXJIYXNoID0gKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMpID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZFBhcmFtcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFyYW1zIHx8IHt9KSk7XG4gIGNvbnN0IHNvcnRlZFBhcmFtS2V5cyA9IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRQYXJhbXMpLnNvcnQoKTtcbiAgY29uc3Qgc29ydGVkUGFyYW1zID0ge307XG4gIHNvcnRlZFBhcmFtS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBzb3J0ZWRQYXJhbXNba2V5XSA9IG5vcm1hbGl6ZWRQYXJhbXNba2V5XTtcbiAgfSk7XG4gIGNvbnN0IGxvY2F0aW9uc0FycmF5ID0gQXJyYXkuaXNBcnJheShsb2NhdGlvbnMpID8gbG9jYXRpb25zIDogW107XG4gIGNvbnN0IG5vcm1hbGl6ZWRMb2NhdGlvbnMgPSBsb2NhdGlvbnNBcnJheS5tYXAobm9ybWFsaXplTG9jS2V5SXRlbSk7XG4gIGNvbnN0IGhhc2hJbnB1dCA9IHtcbiAgICB0eXBlOiBcImZpbmRlclwiLFxuICAgIGZpbmRlcixcbiAgICBwYXJhbXM6IHNvcnRlZFBhcmFtcyxcbiAgICBsb2NhdGlvbnM6IG5vcm1hbGl6ZWRMb2NhdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGRldGVybWluaXN0aWNTdHJpbmdpZnkoaGFzaElucHV0KTtcbn07XG5cbi8vIHNyYy9ldmVudHMvQ2FjaGVFdmVudEZhY3RvcnkudHNcbnZhciBDYWNoZUV2ZW50RmFjdG9yeSA9IGNsYXNzIHtcbiAgc3RhdGljIGxhc3RUaW1lc3RhbXAgPSAwO1xuICBzdGF0aWMgY2xlYW51cEludGVydmFsID0gbnVsbDtcbiAgc3RhdGljIGluc3RhbmNlQ291bnQgPSAwO1xuICBzdGF0aWMgQ0xFQU5VUF9JTlRFUlZBTF9NUyA9IDZlNDtcbiAgLy8gMSBtaW51dGVcbiAgc3RhdGljIE1BWF9USU1FU1RBTVBfQUdFX01TID0gM2U1O1xuICAvLyA1IG1pbnV0ZXNcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgY2xlYW51cCBtZWNoYW5pc20gd2hlbiBmaXJzdCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZUNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsID09PSBudWxsICYmIHRoaXMuaW5zdGFuY2VDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGFydENsZWFudXBUaW1lcigpO1xuICAgIH1cbiAgICB0aGlzLmluc3RhbmNlQ291bnQrKztcbiAgfVxuICAvKipcbiAgICogQ2xlYW51cCBtZWNoYW5pc20gd2hlbiBpbnN0YW5jZSBpcyBkZXN0cm95ZWRcbiAgICovXG4gIHN0YXRpYyBkZXN0cm95SW5zdGFuY2UoKSB7XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gTWF0aC5tYXgoMCwgdGhpcy5pbnN0YW5jZUNvdW50IC0gMSk7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2VDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zdG9wQ2xlYW51cFRpbWVyKCk7XG4gICAgICB0aGlzLnJlc2V0VGltZXN0YW1wKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhdXRvbWF0aWMgY2xlYW51cCB0aW1lclxuICAgKi9cbiAgc3RhdGljIHN0YXJ0Q2xlYW51cFRpbWVyKCkge1xuICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5wZXJmb3JtQ2xlYW51cCgpO1xuICAgIH0sIHRoaXMuQ0xFQU5VUF9JTlRFUlZBTF9NUyk7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsLnVucmVmKSB7XG4gICAgICB0aGlzLmNsZWFudXBJbnRlcnZhbC51bnJlZigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RvcCBhdXRvbWF0aWMgY2xlYW51cCB0aW1lclxuICAgKi9cbiAgc3RhdGljIHN0b3BDbGVhbnVwVGltZXIoKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cEludGVydmFsKTtcbiAgICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gcGVyaW9kaWMgY2xlYW51cCBvZiBzdGFsZSB0aW1lc3RhbXAgc3RhdGVcbiAgICovXG4gIHN0YXRpYyBwZXJmb3JtQ2xlYW51cCgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSB0aGlzLmxhc3RUaW1lc3RhbXAgPiB0aGlzLk1BWF9USU1FU1RBTVBfQUdFX01TKSB7XG4gICAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSAwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIHRpbWVzdGFtcCBzdGF0ZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICAgKi9cbiAgc3RhdGljIHJlc2V0VGltZXN0YW1wKCkge1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdW5pcXVlIHRpbWVzdGFtcCB0aGF0IGlzIGFsd2F5cyBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIG9uZVxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVGltZXN0YW1wKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZUNsZWFudXAoKTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgPiB0aGlzLmxhc3RUaW1lc3RhbXApIHtcbiAgICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IG5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0VGltZXN0YW1wID0gdGhpcy5sYXN0VGltZXN0YW1wICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGFzdFRpbWVzdGFtcDtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBhZmZlY3RlZCBsb2NhdGlvbnMgZnJvbSBhbiBpdGVtIGtleVxuICAgKi9cbiAgc3RhdGljIGV4dHJhY3RBZmZlY3RlZExvY2F0aW9ucyhrZXkpIHtcbiAgICBpZiAoXCJsb2NcIiBpbiBrZXkgJiYga2V5LmxvYykge1xuICAgICAgcmV0dXJuIGtleS5sb2M7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0tcmVsYXRlZCBldmVudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUl0ZW1FdmVudCh0eXBlLCBrZXksIGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFmZmVjdGVkTG9jYXRpb25zID0gb3B0aW9ucy5hZmZlY3RlZExvY2F0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucy5hZmZlY3RlZExvY2F0aW9ucyA6IHRoaXMuZXh0cmFjdEFmZmVjdGVkTG9jYXRpb25zKGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMuZ2VuZXJhdGVUaW1lc3RhbXAoKSxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UgfHwgXCJvcGVyYXRpb25cIixcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgIGtleSxcbiAgICAgIGl0ZW0sXG4gICAgICBwcmV2aW91c0l0ZW06IG9wdGlvbnMucHJldmlvdXNJdGVtLFxuICAgICAgYWZmZWN0ZWRMb2NhdGlvbnNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBxdWVyeSBldmVudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVF1ZXJ5RXZlbnQocXVlcnksIGxvY2F0aW9ucywgaXRlbXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFmZmVjdGVkS2V5cyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5rZXkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIml0ZW1zX3F1ZXJpZWRcIixcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZW5lcmF0ZVRpbWVzdGFtcCgpLFxuICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSB8fCBcIm9wZXJhdGlvblwiLFxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgcXVlcnksXG4gICAgICBsb2NhdGlvbnMsXG4gICAgICBpdGVtcyxcbiAgICAgIGFmZmVjdGVkS2V5c1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNhY2hlIGNsZWFyZWQgZXZlbnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVDYWNoZUNsZWFyZWRFdmVudChpdGVtc0NsZWFyZWQsIHF1ZXJ5Q2FjaGVDbGVhcmVkID0gdHJ1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2FjaGVfY2xlYXJlZFwiLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLmdlbmVyYXRlVGltZXN0YW1wKCksXG4gICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlIHx8IFwib3BlcmF0aW9uXCIsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBpdGVtc0NsZWFyZWQsXG4gICAgICBxdWVyeUNhY2hlQ2xlYXJlZFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2F0aW9uIGludmFsaWRhdGVkIGV2ZW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTG9jYXRpb25JbnZhbGlkYXRlZEV2ZW50KGxvY2F0aW9ucywgYWZmZWN0ZWRLZXlzLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsb2NhdGlvbl9pbnZhbGlkYXRlZFwiLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLmdlbmVyYXRlVGltZXN0YW1wKCksXG4gICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlIHx8IFwib3BlcmF0aW9uXCIsXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICBsb2NhdGlvbnMsXG4gICAgICBhZmZlY3RlZEtleXNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBxdWVyeSBpbnZhbGlkYXRlZCBldmVudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVF1ZXJ5SW52YWxpZGF0ZWRFdmVudChpbnZhbGlkYXRlZFF1ZXJpZXMsIHJlYXNvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicXVlcnlfaW52YWxpZGF0ZWRcIixcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZW5lcmF0ZVRpbWVzdGFtcCgpLFxuICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSB8fCBcIm9wZXJhdGlvblwiLFxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgaW52YWxpZGF0ZWRRdWVyaWVzLFxuICAgICAgcmVhc29uXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZW0gY3JlYXRlZCBldmVudFxuICAgKi9cbiAgc3RhdGljIGl0ZW1DcmVhdGVkKGtleSwgaXRlbSwgc291cmNlID0gXCJhcGlcIikge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUl0ZW1FdmVudChcIml0ZW1fY3JlYXRlZFwiLCBrZXksIGl0ZW0sIHsgc291cmNlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbSB1cGRhdGVkIGV2ZW50XG4gICAqL1xuICBzdGF0aWMgaXRlbVVwZGF0ZWQoa2V5LCBpdGVtLCBwcmV2aW91c0l0ZW0sIHNvdXJjZSA9IFwiYXBpXCIpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJdGVtRXZlbnQoXCJpdGVtX3VwZGF0ZWRcIiwga2V5LCBpdGVtLCB7IHByZXZpb3VzSXRlbSwgc291cmNlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbSByZW1vdmVkIGV2ZW50XG4gICAqL1xuICBzdGF0aWMgaXRlbVJlbW92ZWQoa2V5LCBwcmV2aW91c0l0ZW0sIHNvdXJjZSA9IFwiYXBpXCIpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJdGVtRXZlbnQoXCJpdGVtX3JlbW92ZWRcIiwga2V5LCBudWxsLCB7IHByZXZpb3VzSXRlbSwgc291cmNlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlbSByZXRyaWV2ZWQgZXZlbnRcbiAgICovXG4gIHN0YXRpYyBpdGVtUmV0cmlldmVkKGtleSwgaXRlbSwgc291cmNlID0gXCJhcGlcIikge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUl0ZW1FdmVudChcIml0ZW1fcmV0cmlldmVkXCIsIGtleSwgaXRlbSwgeyBzb3VyY2UgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpdGVtIHNldCBldmVudCAoZGlyZWN0IGNhY2hlIG9wZXJhdGlvbilcbiAgICovXG4gIHN0YXRpYyBpdGVtU2V0KGtleSwgaXRlbSwgcHJldmlvdXNJdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlSXRlbUV2ZW50KFwiaXRlbV9zZXRcIiwga2V5LCBpdGVtLCB7XG4gICAgICBwcmV2aW91c0l0ZW0sXG4gICAgICBzb3VyY2U6IFwiY2FjaGVcIlxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbG9nZ2VyLnRzXG5pbXBvcnQgTG9nZ2luZyBmcm9tIFwiQGZqZWxsL2xvZ2dpbmdcIjtcbnZhciBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcihcIkBmamVsbC9jYWNoZVwiKTtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExpYkxvZ2dlcjtcblxuLy8gc3JjL29wcy9hbGwudHNcbnZhciBsb2dnZXIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJhbGxcIik7XG52YXIgYWxsID0gYXN5bmMgKHF1ZXJ5ID0ge30sIGxvY2F0aW9ucyA9IFtdLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIuZGVmYXVsdChcImFsbFwiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gIGNvbnN0IHF1ZXJ5SGFzaCA9IGNyZWF0ZVF1ZXJ5SGFzaChwa1R5cGUsIHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICBsb2dnZXIuZGVidWcoXCJHZW5lcmF0ZWQgcXVlcnkgaGFzaCBmb3IgYWxsXCIsIHsgcXVlcnlIYXNoIH0pO1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cykge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlVzaW5nIGNhY2hlZCBxdWVyeSByZXN1bHRzXCIsIHsgY2FjaGVkS2V5Q291bnQ6IGNhY2hlZEl0ZW1LZXlzLmxlbmd0aCB9KTtcbiAgICBjb25zdCBjYWNoZWRJdGVtcyA9IFtdO1xuICAgIGxldCBhbGxJdGVtc0F2YWlsYWJsZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCBpdGVtS2V5IG9mIGNhY2hlZEl0ZW1LZXlzKSB7XG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGl0ZW1LZXkpO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY2FjaGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbEl0ZW1zQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWxsSXRlbXNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSyhjYWNoZWRJdGVtcywgcGtUeXBlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIlNvbWUgY2FjaGVkIGl0ZW1zIG1pc3NpbmcsIGludmFsaWRhdGluZyBxdWVyeSBjYWNoZVwiKTtcbiAgICAgIGNhY2hlTWFwLmRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gICAgfVxuICB9XG4gIGxldCByZXQgPSBbXTtcbiAgdHJ5IHtcbiAgICByZXQgPSBhd2FpdCBhcGkuYWxsKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIHJldC5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBjYWNoZU1hcC5zZXQodi5rZXksIHYpO1xuICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkodi5rZXkpO1xuICAgICAgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB2LCBjYWNoZU1hcCk7XG4gICAgICBldmljdGVkS2V5cy5mb3JFYWNoKChldmljdGVkS2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgICAgIGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgaXRlbUtleXMgPSByZXQubWFwKChpdGVtKSA9PiBpdGVtLmtleSk7XG4gICAgY2FjaGVNYXAuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cyk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiQ2FjaGVkIHF1ZXJ5IHJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleUNvdW50OiBpdGVtS2V5cy5sZW5ndGggfSk7XG4gICAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5jcmVhdGVRdWVyeUV2ZW50KHF1ZXJ5LCBsb2NhdGlvbnMsIHJldCk7XG4gICAgY29udGV4dC5ldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW10pO1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2FjaGVkIGVtcHR5IHF1ZXJ5IHJlc3VsdCBmb3Igbm90IGZvdW5kXCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsocmV0LCBwa1R5cGUpXTtcbn07XG5cbi8vIHNyYy9vcHMvb25lLnRzXG5pbXBvcnQge1xuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEsyXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgTm90Rm91bmRFcnJvciBhcyBOb3RGb3VuZEVycm9yMiB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcbnZhciBsb2dnZXIyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwib25lXCIpO1xudmFyIG9uZSA9IGFzeW5jIChxdWVyeSA9IHt9LCBsb2NhdGlvbnMgPSBbXSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgdHRsTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyMi5kZWZhdWx0KFwib25lXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgY29uc3QgcXVlcnlIYXNoID0gY3JlYXRlUXVlcnlIYXNoKHBrVHlwZSwgcXVlcnksIGxvY2F0aW9ucyk7XG4gIGxvZ2dlcjIuZGVidWcoXCJHZW5lcmF0ZWQgcXVlcnkgaGFzaCBmb3Igb25lXCIsIHsgcXVlcnlIYXNoIH0pO1xuICBjb25zdCBjYWNoZWRJdGVtS2V5cyA9IGF3YWl0IGNhY2hlTWFwLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIGlmIChjYWNoZWRJdGVtS2V5cykge1xuICAgIGxvZ2dlcjIuZGVidWcoXCJVc2luZyBjYWNoZWQgcXVlcnkgcmVzdWx0c1wiLCB7IGNhY2hlZEtleUNvdW50OiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggfSk7XG4gICAgaWYgKGNhY2hlZEl0ZW1LZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCBudWxsXTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChjYWNoZWRJdGVtS2V5c1swXSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzIoaXRlbSwgcGtUeXBlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJDYWNoZWQgaXRlbSBtaXNzaW5nLCBpbnZhbGlkYXRpbmcgcXVlcnkgY2FjaGVcIik7XG4gICAgICBjYWNoZU1hcC5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH1cbiAgfVxuICBsZXQgcmV0SXRlbSA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0SXRlbSA9IGF3YWl0IGFwaS5vbmUocXVlcnksIGxvY2F0aW9ucyk7XG4gICAgaWYgKHJldEl0ZW0pIHtcbiAgICAgIGNhY2hlTWFwLnNldChyZXRJdGVtLmtleSwgcmV0SXRlbSk7XG4gICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShyZXRJdGVtLmtleSk7XG4gICAgICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHJldEl0ZW0sIGNhY2hlTWFwKTtcbiAgICAgIGV2aWN0ZWRLZXlzLmZvckVhY2goKGV2aWN0ZWRLZXkpID0+IHtcbiAgICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgICAgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgICB9KTtcbiAgICAgIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW3JldEl0ZW0ua2V5XSk7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiQ2FjaGVkIHF1ZXJ5IHJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleTogcmV0SXRlbS5rZXkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW10pO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIkNhY2hlZCBlbXB0eSBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2ggfSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yMikge1xuICAgICAgY2FjaGVNYXAuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBbXSk7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiQ2FjaGVkIGVtcHR5IHF1ZXJ5IHJlc3VsdCBmb3Igbm90IGZvdW5kXCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIGNvbnRleHQsXG4gICAgcmV0SXRlbSA/IHZhbGlkYXRlUEsyKHJldEl0ZW0sIHBrVHlwZSkgOiBudWxsXG4gIF07XG59O1xuXG4vLyBzcmMvb3BzL2NyZWF0ZS50c1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVQSyBhcyB2YWxpZGF0ZVBLM1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXIzID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiY3JlYXRlXCIpO1xudmFyIGNyZWF0ZSA9IGFzeW5jICh2LCBsb2NhdGlvbnMgPSBbXSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlcjMuZGVmYXVsdChcImNyZWF0ZVwiLCB7IHYsIGxvY2F0aW9ucyB9KTtcbiAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IGFwaS5jcmVhdGUodiwgbG9jYXRpb25zKTtcbiAgY2FjaGVNYXAuc2V0KGNyZWF0ZWQua2V5LCBjcmVhdGVkKTtcbiAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoY3JlYXRlZC5rZXkpO1xuICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuICBjb25zdCBldmljdGVkS2V5cyA9IGV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNyZWF0ZWQsIGNhY2hlTWFwKTtcbiAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IEpTT04ucGFyc2UoZXZpY3RlZEtleSk7XG4gICAgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gIH0pO1xuICBjb25zdCBldmVudCA9IENhY2hlRXZlbnRGYWN0b3J5Lml0ZW1DcmVhdGVkKGNyZWF0ZWQua2V5LCBjcmVhdGVkLCBcImFwaVwiKTtcbiAgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQpO1xuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEszKGNyZWF0ZWQsIHBrVHlwZSldO1xufTtcblxuLy8gc3JjL29wcy9nZXQudHNcbmltcG9ydCB7XG4gIGlzVmFsaWRJdGVtS2V5LFxuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEs0XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuXG4vLyBzcmMvdXRpbHMvQ2FjaGVTaXplLnRzXG5pbXBvcnQgc2FmZVN0cmluZ2lmeSBmcm9tIFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiO1xudmFyIFNJWkVfVU5JVFMgPSB7XG4gIC8vIERlY2ltYWwgdW5pdHMgKHBvd2VycyBvZiAxMDAwKVxuICBcImJcIjogMSxcbiAgXCJieXRlXCI6IDEsXG4gIFwiYnl0ZXNcIjogMSxcbiAgXCJrYlwiOiAxZTMsXG4gIFwia2lsb2J5dGVcIjogMWUzLFxuICBcImtpbG9ieXRlc1wiOiAxZTMsXG4gIFwibWJcIjogMWUzICogMWUzLFxuICBcIm1lZ2FieXRlXCI6IDFlMyAqIDFlMyxcbiAgXCJtZWdhYnl0ZXNcIjogMWUzICogMWUzLFxuICBcImdiXCI6IDFlMyAqIDFlMyAqIDFlMyxcbiAgXCJnaWdhYnl0ZVwiOiAxZTMgKiAxZTMgKiAxZTMsXG4gIFwiZ2lnYWJ5dGVzXCI6IDFlMyAqIDFlMyAqIDFlMyxcbiAgXCJ0YlwiOiAxZTMgKiAxZTMgKiAxZTMgKiAxZTMsXG4gIFwidGVyYWJ5dGVcIjogMWUzICogMWUzICogMWUzICogMWUzLFxuICBcInRlcmFieXRlc1wiOiAxZTMgKiAxZTMgKiAxZTMgKiAxZTMsXG4gIC8vIEJpbmFyeSB1bml0cyAocG93ZXJzIG9mIDEwMjQpXG4gIFwia2liXCI6IDEwMjQsXG4gIFwia2liaWJ5dGVcIjogMTAyNCxcbiAgXCJraWJpYnl0ZXNcIjogMTAyNCxcbiAgXCJtaWJcIjogMTAyNCAqIDEwMjQsXG4gIFwibWViaWJ5dGVcIjogMTAyNCAqIDEwMjQsXG4gIFwibWViaWJ5dGVzXCI6IDEwMjQgKiAxMDI0LFxuICBcImdpYlwiOiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gIFwiZ2liaWJ5dGVcIjogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICBcImdpYmlieXRlc1wiOiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gIFwidGliXCI6IDEwMjQgKiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gIFwidGViaWJ5dGVcIjogMTAyNCAqIDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgXCJ0ZWJpYnl0ZXNcIjogMTAyNCAqIDEwMjQgKiAxMDI0ICogMTAyNFxufTtcbmZ1bmN0aW9uIHBhcnNlU2l6ZVN0cmluZyhzaXplU3RyKSB7XG4gIGlmICghc2l6ZVN0ciB8fCB0eXBlb2Ygc2l6ZVN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNpemUgc3RyaW5nIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IHRyaW1tZWQgPSBzaXplU3RyLnRyaW0oKTtcbiAgaWYgKC9eXFxkKyhcXC5cXGQrKT8kLy50ZXN0KHRyaW1tZWQpKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBwYXJzZUZsb2F0KHRyaW1tZWQpO1xuICAgIGlmIChpc05hTihieXRlcykgfHwgYnl0ZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2l6ZSB2YWx1ZTogJHtzaXplU3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihieXRlcyk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC9eKFxcZCsoPzpcXC5cXGQrKT8pXFxzKihbYS16QS1aXSspJC8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemUgZm9ybWF0OiAke3NpemVTdHJ9LiBFeHBlY3RlZCBmb3JtYXQ6ICcxMDAnLCAnNUtCJywgJzEwTUInLCBldGMuYCk7XG4gIH1cbiAgY29uc3QgWywgdmFsdWVTdHIsIHVuaXRTdHJdID0gbWF0Y2g7XG4gIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZVN0cik7XG4gIGNvbnN0IHVuaXQgPSB1bml0U3RyLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemUgdmFsdWU6ICR7dmFsdWVTdHJ9YCk7XG4gIH1cbiAgY29uc3QgbXVsdGlwbGllciA9IFNJWkVfVU5JVFNbdW5pdF07XG4gIGlmICghKHVuaXQgaW4gU0laRV9VTklUUykpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWRVbml0cyA9IE9iamVjdC5rZXlzKFNJWkVfVU5JVFMpLmZpbHRlcigodSkgPT4gdS5sZW5ndGggPD0gMykuam9pbihcIiwgXCIpO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2l6ZSB1bml0OiAke3VuaXRTdHJ9LiBTdXBwb3J0ZWQgdW5pdHM6ICR7c3VwcG9ydGVkVW5pdHN9YCk7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKiBtdWx0aXBsaWVyKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEJ5dGVzKGJ5dGVzLCBiaW5hcnkgPSBmYWxzZSkge1xuICBpZiAoYnl0ZXMgPT09IDApIHJldHVybiBcIjAgQlwiO1xuICBpZiAoYnl0ZXMgPCAwKSByZXR1cm4gYCR7Ynl0ZXN9IEJgO1xuICBjb25zdCBrID0gYmluYXJ5ID8gMTAyNCA6IDFlMztcbiAgY29uc3Qgc2l6ZXMgPSBiaW5hcnkgPyBbXCJCXCIsIFwiS2lCXCIsIFwiTWlCXCIsIFwiR2lCXCIsIFwiVGlCXCIsIFwiUGlCXCJdIDogW1wiQlwiLCBcIktCXCIsIFwiTUJcIiwgXCJHQlwiLCBcIlRCXCIsIFwiUEJcIl07XG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgY29uc3Qgc2l6ZSA9IGJ5dGVzIC8gTWF0aC5wb3coaywgaSk7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IHNpemUgJSAxID09PSAwID8gc2l6ZS50b1N0cmluZygpIDogc2l6ZS50b0ZpeGVkKDEpO1xuICByZXR1cm4gYCR7Zm9ybWF0dGVkfSAke3NpemVzW2ldfWA7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZVZhbHVlU2l6ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIDg7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCAqIDI7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiB0b3RhbCArIGVzdGltYXRlVmFsdWVTaXplKGl0ZW0pLCAyNCk7XG4gICAgICB9XG4gICAgICBjb25zdCBoYXNDaXJjdWxhclJlZmVyZW5jZSA9IChvYmosIGFuY2VzdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpLCBjaGVja2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkpID0+IHtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzT2JqZWN0ID0gb2JqO1xuICAgICAgICBpZiAoY2hlY2tlZC5oYXMoYXNPYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKGFzT2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9ycy5hZGQoYXNPYmplY3QpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzT2JqZWN0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFzT2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmIChoYXNDaXJjdWxhclJlZmVyZW5jZShpdGVtLCBhbmNlc3RvcnMsIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXNPYmplY3QpKSB7XG4gICAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGFzT2JqZWN0W2tleV07XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoYXNDaXJjdWxhclJlZmVyZW5jZShjaGlsZCwgYW5jZXN0b3JzLCBjaGVja2VkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFuY2VzdG9ycy5kZWxldGUoYXNPYmplY3QpO1xuICAgICAgICAgIGNoZWNrZWQuYWRkKGFzT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhc0NpcmN1bGFyUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiA2NDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiA2NDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBzYWZlU3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGpzb25TdHJpbmcubGVuZ3RoICogMiArIDE2O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiA2NDtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDMyO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNpemVDb25maWcoY29uZmlnKSB7XG4gIGlmICh0eXBlb2YgY29uZmlnLm1heFNpemVCeXRlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBieXRlcyA9IHBhcnNlU2l6ZVN0cmluZyhjb25maWcubWF4U2l6ZUJ5dGVzKTtcbiAgICAgIGlmIChieXRlcyA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heFNpemVCeXRlcyBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWF4U2l6ZUJ5dGVzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgY29uZmlnLm1heEl0ZW1zICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvbmZpZy5tYXhJdGVtcykgfHwgY29uZmlnLm1heEl0ZW1zIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heEl0ZW1zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvb3BzL2dldC50c1xudmFyIGxvZ2dlcjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJnZXRcIik7XG52YXIgaW5GbGlnaHRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgQ0xFQU5VUF9USU1FT1VUID0gNSAqIDYwICogMWUzO1xudmFyIGNsZWFudXBTdGFsZVJlcXVlc3RzID0gKCkgPT4ge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCBrZXlzVG9EZWxldGUgPSBbXTtcbiAgaW5GbGlnaHRSZXF1ZXN0cy5mb3JFYWNoKChyZXF1ZXN0LCBrZXkpID0+IHtcbiAgICBpZiAobm93IC0gcmVxdWVzdC50aW1lc3RhbXAgPiBDTEVBTlVQX1RJTUVPVVQpIHtcbiAgICAgIGtleXNUb0RlbGV0ZS5wdXNoKGtleSk7XG4gICAgfVxuICB9KTtcbiAga2V5c1RvRGVsZXRlLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGxvZ2dlcjQuZGVidWcoXCJDbGVhbmluZyB1cCBzdGFsZSBpbi1mbGlnaHQgcmVxdWVzdFwiLCB7IGtleSB9KTtcbiAgICBpbkZsaWdodFJlcXVlc3RzLmRlbGV0ZShrZXkpO1xuICB9KTtcbn07XG52YXIgY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWwoY2xlYW51cFN0YWxlUmVxdWVzdHMsIDYwICogMWUzKTtcbnZhciBrZXlUb1N0cmluZyA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oKTtcbnZhciBnZXQgPSBhc3luYyAoa2V5LCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyLCBzdGF0c01hbmFnZXIgfSA9IGNvbnRleHQ7XG4gIGxvZ2dlcjQuZGVmYXVsdChcImdldFwiLCB7IGtleSwgZGVmYXVsdFRUTDogdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCkgfSk7XG4gIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRSZXF1ZXN0cygpO1xuICBpZiAoIWlzVmFsaWRJdGVtS2V5KGtleSkpIHtcbiAgICBsb2dnZXI0LmVycm9yKFwiS2V5IGZvciBHZXQgaXMgbm90IGEgdmFsaWQgSXRlbUtleTogJWpcIiwga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgZm9yIEdldCBpcyBub3QgYSB2YWxpZCBJdGVtS2V5XCIpO1xuICB9XG4gIGlmICh0dGxNYW5hZ2VyLmlzVFRMRW5hYmxlZCgpKSB7XG4gICAgY29uc3Qga2V5U3RyMiA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgY29uc3QgY2FjaGVkSXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuICAgIGlmIChjYWNoZWRJdGVtKSB7XG4gICAgICBjb25zdCBpc1ZhbGlkID0gdHRsTWFuYWdlci52YWxpZGF0ZUl0ZW0oa2V5U3RyMiwgY2FjaGVNYXApO1xuICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgbG9nZ2VyNC5kZWJ1ZyhcIkNhY2hlIGhpdCB3aXRoIHZhbGlkIFRUTFwiLCB7IGtleSwgZGVmYXVsdFRUTDogdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCkgfSk7XG4gICAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRIaXRzKCk7XG4gICAgICAgIHJldHVybiBbY29udGV4dCwgdmFsaWRhdGVQSzQoY2FjaGVkSXRlbSwgcGtUeXBlKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXI0LmRlYnVnKFwiQ2FjaGUgaXRlbSBleHBpcmVkLCByZW1vdmluZ1wiLCB7IGtleSB9KTtcbiAgICAgICAgY2FjaGVNYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRNaXNzZXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudE1pc3NlcygpO1xuICAgIH1cbiAgICBsb2dnZXI0LmRlYnVnKFwiQ2FjaGUgbWlzcyBvciBleHBpcmVkXCIsIHsga2V5LCBkZWZhdWx0VFRMOiB0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYWNoZWRJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgaWYgKGNhY2hlZEl0ZW0pIHtcbiAgICAgIGxvZ2dlcjQuZGVidWcoXCJDYWNoZSBoaXQgKFRUTCBkaXNhYmxlZClcIiwgeyBrZXkgfSk7XG4gICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50SGl0cygpO1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLNChjYWNoZWRJdGVtLCBwa1R5cGUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudE1pc3NlcygpO1xuICAgIH1cbiAgfVxuICBsZXQgcmV0O1xuICBjb25zdCBrZXlTdHIgPSBrZXlUb1N0cmluZyhrZXkpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3RFbnRyeSA9IGluRmxpZ2h0UmVxdWVzdHMuZ2V0KGtleVN0cik7XG4gICAgbGV0IGFwaVJlcXVlc3Q7XG4gICAgaWYgKCFyZXF1ZXN0RW50cnkpIHtcbiAgICAgIGFwaVJlcXVlc3QgPSBhcGkuZ2V0KGtleSk7XG4gICAgICBpZiAoYXBpUmVxdWVzdCAmJiB0eXBlb2YgYXBpUmVxdWVzdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaW5GbGlnaHRSZXF1ZXN0cy5zZXQoa2V5U3RyLCB7IHByb21pc2U6IGFwaVJlcXVlc3QsIHRpbWVzdGFtcCB9KTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IGluRmxpZ2h0UmVxdWVzdHMuZGVsZXRlKGtleVN0cik7XG4gICAgICAgIGlmICh0eXBlb2YgYXBpUmVxdWVzdC5maW5hbGx5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBhcGlSZXF1ZXN0LmZpbmFsbHkoY2xlYW51cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBpUmVxdWVzdC50aGVuKGNsZWFudXAsIGNsZWFudXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjQuZGVidWcoXCJVc2luZyBpbi1mbGlnaHQgcmVxdWVzdCBmb3Iga2V5XCIsIHsga2V5IH0pO1xuICAgICAgYXBpUmVxdWVzdCA9IHJlcXVlc3RFbnRyeS5wcm9taXNlO1xuICAgIH1cbiAgICByZXQgPSBhd2FpdCBhcGlSZXF1ZXN0O1xuICAgIGlmIChyZXQpIHtcbiAgICAgIGNhY2hlTWFwLnNldChyZXQua2V5LCByZXQpO1xuICAgICAgY29uc3Qga2V5U3RyMiA9IEpTT04uc3RyaW5naWZ5KHJldC5rZXkpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBjYWNoZU1hcC5nZXRNZXRhZGF0YT8uKGtleVN0cjIpO1xuICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBiYXNlTWV0YWRhdGEgPSB7XG4gICAgICAgICAga2V5OiBrZXlTdHIyLFxuICAgICAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgICAgIGVzdGltYXRlZFNpemU6IGVzdGltYXRlVmFsdWVTaXplKHJldClcbiAgICAgICAgfTtcbiAgICAgICAgY2FjaGVNYXAuc2V0TWV0YWRhdGE/LihrZXlTdHIyLCBiYXNlTWV0YWRhdGEpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIyLCByZXQsIGNhY2hlTWFwKTtcbiAgICAgIHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyMiwgY2FjaGVNYXApO1xuICAgICAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgICBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZXZlbnQgPSBDYWNoZUV2ZW50RmFjdG9yeS5pdGVtUmV0cmlldmVkKHJldC5rZXksIHJldCwgXCJhcGlcIik7XG4gICAgICBjb250ZXh0LmV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpbkZsaWdodFJlcXVlc3RzLmRlbGV0ZShrZXlTdHIpO1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGl0ZW0gZm9yIGtleVwiLCB7IGtleSwgbWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjayB9KTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiBbXG4gICAgY29udGV4dCxcbiAgICByZXQgPyB2YWxpZGF0ZVBLNChyZXQsIHBrVHlwZSkgOiBudWxsXG4gIF07XG59O1xuXG4vLyBzcmMvb3BzL3JldHJpZXZlLnRzXG5pbXBvcnQge1xuICBpc1ZhbGlkSXRlbUtleSBhcyBpc1ZhbGlkSXRlbUtleTIsXG4gIHZhbGlkYXRlUEsgYXMgdmFsaWRhdGVQSzVcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG52YXIgbG9nZ2VyNSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcInJldHJpZXZlXCIpO1xudmFyIHJldHJpZXZlID0gYXN5bmMgKGtleSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGNhY2hlTWFwLCBwa1R5cGUsIHN0YXRzTWFuYWdlciB9ID0gY29udGV4dDtcbiAgbG9nZ2VyNS5kZWZhdWx0KFwicmV0cmlldmVcIiwgeyBrZXkgfSk7XG4gIHN0YXRzTWFuYWdlci5pbmNyZW1lbnRSZXF1ZXN0cygpO1xuICBpZiAoIWlzVmFsaWRJdGVtS2V5MihrZXkpKSB7XG4gICAgbG9nZ2VyNS5lcnJvcihcIktleSBmb3IgUmV0cmlldmUgaXMgbm90IGEgdmFsaWQgSXRlbUtleTogJWpcIiwga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgZm9yIFJldHJpZXZlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXlcIik7XG4gIH1cbiAgY29uc3QgY29udGFpbnNJdGVtS2V5ID0gYXdhaXQgY2FjaGVNYXAuaW5jbHVkZXNLZXkoa2V5KTtcbiAgbGV0IHJldHJpZXZlZDtcbiAgbGV0IGNvbnRleHRUb1JldHVybjtcbiAgaWYgKGNvbnRhaW5zSXRlbUtleSkge1xuICAgIGxvZ2dlcjUuZGVmYXVsdChcIkxvb2tpbmcgZm9yIE9iamVjdCBpbiBDYWNoZVwiLCBrZXkpO1xuICAgIHJldHJpZXZlZCA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuICAgIGNvbnRleHRUb1JldHVybiA9IG51bGw7XG4gICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudEhpdHMoKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXI1LmRlZmF1bHQoXCJPYmplY3QgTm90IEZvdW5kIGluIENhY2hlLCBSZXRyaWV2aW5nIGZyb20gU2VydmVyIEFQSVwiLCB7IGtleSB9KTtcbiAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50TWlzc2VzKCk7XG4gICAgW2NvbnRleHRUb1JldHVybiwgcmV0cmlldmVkXSA9IGF3YWl0IGdldChrZXksIGNvbnRleHQpO1xuICB9XG4gIGNvbnN0IHJldFZhbHVlID0gW1xuICAgIGNvbnRleHRUb1JldHVybixcbiAgICByZXRyaWV2ZWQgPyB2YWxpZGF0ZVBLNShyZXRyaWV2ZWQsIHBrVHlwZSkgOiBudWxsXG4gIF07XG4gIHJldHVybiByZXRWYWx1ZTtcbn07XG5cbi8vIHNyYy9vcHMvcmVtb3ZlLnRzXG5pbXBvcnQge1xuICBpc1ZhbGlkSXRlbUtleSBhcyBpc1ZhbGlkSXRlbUtleTNcbn0gZnJvbSBcIkBmamVsbC9jb3JlXCI7XG52YXIgbG9nZ2VyNiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcInJlbW92ZVwiKTtcbnZhciByZW1vdmUgPSBhc3luYyAoa2V5LCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCB9ID0gY29udGV4dDtcbiAgbG9nZ2VyNi5kZWZhdWx0KFwicmVtb3ZlXCIsIHsga2V5IH0pO1xuICBpZiAoIWlzVmFsaWRJdGVtS2V5MyhrZXkpKSB7XG4gICAgbG9nZ2VyNi5lcnJvcihcIktleSBmb3IgUmVtb3ZlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqXCIsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGZvciBSZW1vdmUgaXMgbm90IGEgdmFsaWQgSXRlbUtleVwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHByZXZpb3VzSXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChrZXkpO1xuICAgIGF3YWl0IGFwaS5yZW1vdmUoa2V5KTtcbiAgICBjYWNoZU1hcC5kZWxldGUoa2V5KTtcbiAgICBpZiAocHJldmlvdXNJdGVtKSB7XG4gICAgICBjb25zdCBldmVudCA9IENhY2hlRXZlbnRGYWN0b3J5Lml0ZW1SZW1vdmVkKGtleSwgcHJldmlvdXNJdGVtLCBcImFwaVwiKTtcbiAgICAgIGNvbnRleHQuZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQpO1xuICAgIH1cbiAgICBsb2dnZXI2LmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IHJlbW92ZWQgaXRlbSBmcm9tIEFQSSBhbmQgY2FjaGVcIiwgeyBrZXkgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXI2LmVycm9yKFwiRXJyb3IgZGVsZXRpbmcgaXRlbVwiLCB7IGVycm9yOiBlIH0pO1xuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vLyBzcmMvb3BzL3VwZGF0ZS50c1xuaW1wb3J0IHtcbiAgaXNWYWxpZEl0ZW1LZXkgYXMgaXNWYWxpZEl0ZW1LZXk0LFxuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEs2XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xudmFyIGxvZ2dlcjcgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJ1cGRhdGVcIik7XG52YXIgdXBkYXRlID0gYXN5bmMgKGtleSwgdiwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyNy5kZWZhdWx0KFwidXBkYXRlXCIsIHsga2V5LCB2IH0pO1xuICBpZiAoIWlzVmFsaWRJdGVtS2V5NChrZXkpKSB7XG4gICAgbG9nZ2VyNy5lcnJvcihcIktleSBmb3IgVXBkYXRlIGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXk6ICVqXCIsIGtleSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGZvciBVcGRhdGUgaXMgbm90IGEgdmFsaWQgSXRlbUtleVwiKTtcbiAgfVxuICBsb2dnZXI3LmRlYnVnKFwiSW52YWxpZGF0aW5nIGl0ZW0ga2V5IGJlZm9yZSB1cGRhdGVcIiwgeyBrZXkgfSk7XG4gIGNhY2hlTWFwLmludmFsaWRhdGVJdGVtS2V5cyhba2V5XSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJldmlvdXNJdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgY29uc3QgdXBkYXRlZCA9IGF3YWl0IGFwaS51cGRhdGUoa2V5LCB2KTtcbiAgICBsb2dnZXI3LmRlYnVnKFwiQ2FjaGluZyB1cGRhdGUgcmVzdWx0XCIsIHsgdXBkYXRlZEtleTogdXBkYXRlZC5rZXkgfSk7XG4gICAgY2FjaGVNYXAuc2V0KHVwZGF0ZWQua2V5LCB1cGRhdGVkKTtcbiAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeSh1cGRhdGVkLmtleSk7XG4gICAgY29udGV4dC50dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB1cGRhdGVkLCBjYWNoZU1hcCk7XG4gICAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgIGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuaXRlbVVwZGF0ZWQodXBkYXRlZC5rZXksIHVwZGF0ZWQsIHByZXZpb3VzSXRlbSwgXCJhcGlcIik7XG4gICAgY29udGV4dC5ldmVudEVtaXR0ZXIuZW1pdChldmVudCk7XG4gICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLNih1cGRhdGVkLCBwa1R5cGUpXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlcjcuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBpdGVtXCIsIHsgZXJyb3I6IGUgfSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuLy8gc3JjL29wcy9hY3Rpb24udHNcbmltcG9ydCB7XG4gIGlzVmFsaWRJdGVtS2V5IGFzIGlzVmFsaWRJdGVtS2V5NSxcbiAgdmFsaWRhdGVQSyBhcyB2YWxpZGF0ZVBLN1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXI4ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYWN0aW9uXCIpO1xudmFyIGFjdGlvbiA9IGFzeW5jIChrZXksIGFjdGlvbjIsIGJvZHkgPSB7fSwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGFwaSwgY2FjaGVNYXAsIHBrVHlwZSB9ID0gY29udGV4dDtcbiAgbG9nZ2VyOC5kZWZhdWx0KFwiYWN0aW9uXCIsIHsga2V5LCBhY3Rpb246IGFjdGlvbjIsIGJvZHkgfSk7XG4gIGlmICghaXNWYWxpZEl0ZW1LZXk1KGtleSkpIHtcbiAgICBsb2dnZXI4LmVycm9yKFwiS2V5IGZvciBBY3Rpb24gaXMgbm90IGEgdmFsaWQgSXRlbUtleTogJWpcIiwga2V5KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgZm9yIEFjdGlvbiBpcyBub3QgYSB2YWxpZCBJdGVtS2V5XCIpO1xuICB9XG4gIGxvZ2dlcjguZGVidWcoXCJJbnZhbGlkYXRpbmcgaXRlbSBrZXkgYmVmb3JlIGFjdGlvblwiLCB7IGtleSB9KTtcbiAgY2FjaGVNYXAuaW52YWxpZGF0ZUl0ZW1LZXlzKFtrZXldKTtcbiAgY29uc3QgdXBkYXRlZCA9IGF3YWl0IGFwaS5hY3Rpb24oa2V5LCBhY3Rpb24yLCBib2R5KTtcbiAgbG9nZ2VyOC5kZWJ1ZyhcIkNhY2hpbmcgYWN0aW9uIHJlc3VsdFwiLCB7IHVwZGF0ZWRLZXk6IHVwZGF0ZWQua2V5IH0pO1xuICBjYWNoZU1hcC5zZXQodXBkYXRlZC5rZXksIHVwZGF0ZWQpO1xuICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeSh1cGRhdGVkLmtleSk7XG4gIGNvbnRleHQudHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgY29uc3QgZXZpY3RlZEtleXMgPSBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHVwZGF0ZWQsIGNhY2hlTWFwKTtcbiAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWRLZXkgPSBKU09OLnBhcnNlKGV2aWN0ZWRLZXkpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjguZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgZXZpY3RlZCBrZXkgZHVyaW5nIGRlbGV0aW9uXCIsIHtcbiAgICAgICAgZXZpY3RlZEtleSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLNyh1cGRhdGVkLCBwa1R5cGUpXTtcbn07XG5cbi8vIHNyYy9vcHMvYWxsQWN0aW9uLnRzXG5pbXBvcnQge1xuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEs4XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgTm90Rm91bmRFcnJvciBhcyBOb3RGb3VuZEVycm9yMyB9IGZyb20gXCJAZmplbGwvaHR0cC1hcGlcIjtcbnZhciBsb2dnZXI5ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYWxsQWN0aW9uXCIpO1xudmFyIGFsbEFjdGlvbiA9IGFzeW5jIChhY3Rpb24yLCBib2R5ID0ge30sIGxvY2F0aW9ucyA9IFtdLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlIH0gPSBjb250ZXh0O1xuICBsb2dnZXI5LmRlZmF1bHQoXCJhbGxBY3Rpb25cIiwgeyBhY3Rpb246IGFjdGlvbjIsIGJvZHksIGxvY2F0aW9ucyB9KTtcbiAgbG9nZ2VyOS5kZWJ1ZyhcIkludmFsaWRhdGluZyBsb2NhdGlvbiBiZWZvcmUgYWxsQWN0aW9uXCIsIHsgbG9jYXRpb25zIH0pO1xuICBjYWNoZU1hcC5pbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKTtcbiAgbGV0IHJldCA9IFtdO1xuICB0cnkge1xuICAgIHJldCA9IGF3YWl0IGFwaS5hbGxBY3Rpb24oYWN0aW9uMiwgYm9keSwgbG9jYXRpb25zKTtcbiAgICBsb2dnZXI5LmRlYnVnKFwiQ2FjaGluZyBhbGxBY3Rpb24gcmVzdWx0c1wiLCB7IHJlc3VsdENvdW50OiByZXQubGVuZ3RoIH0pO1xuICAgIHJldC5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBjYWNoZU1hcC5zZXQodi5rZXksIHYpO1xuICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkodi5rZXkpO1xuICAgICAgY29udGV4dC50dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHYsIGNhY2hlTWFwKTtcbiAgICAgIGV2aWN0ZWRLZXlzLmZvckVhY2goKGV2aWN0ZWRLZXkpID0+IHtcbiAgICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgICAgY2FjaGVNYXAuZGVsZXRlKHBhcnNlZEtleSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcjMpIHtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLOChyZXQsIHBrVHlwZSldO1xufTtcblxuLy8gc3JjL29wcy9mYWNldC50c1xudmFyIGxvZ2dlcjEwID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiZmFjZXRcIik7XG52YXIgZmFjZXQgPSBhc3luYyAoa2V5LCBmYWNldDIsIHBhcmFtcyA9IHt9LCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpIH0gPSBjb250ZXh0O1xuICBsb2dnZXIxMC5kZWZhdWx0KFwiZmFjZXRcIiwgeyBrZXksIGZhY2V0OiBmYWNldDIgfSk7XG4gIGNvbnN0IHJldCA9IGF3YWl0IGFwaS5mYWNldChrZXksIGZhY2V0MiwgcGFyYW1zKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIHNyYy9vcHMvYWxsRmFjZXQudHNcbnZhciBsb2dnZXIxMSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFsbEZhY2V0XCIpO1xudmFyIGFsbEZhY2V0ID0gYXN5bmMgKGZhY2V0MiwgcGFyYW1zID0ge30sIGxvY2F0aW9ucyA9IFtdLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpIH0gPSBjb250ZXh0O1xuICBsb2dnZXIxMS5kZWZhdWx0KFwiYWxsRmFjZXRcIiwgeyBmYWNldDogZmFjZXQyLCBwYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgY29uc3QgcmV0ID0gYXdhaXQgYXBpLmFsbEZhY2V0KGZhY2V0MiwgcGFyYW1zLCBsb2NhdGlvbnMpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLy8gc3JjL29wcy9maW5kLnRzXG5pbXBvcnQge1xuICB2YWxpZGF0ZVBLIGFzIHZhbGlkYXRlUEs5XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xudmFyIGxvZ2dlcjEyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiZmluZFwiKTtcbnZhciBmaW5kID0gYXN5bmMgKGZpbmRlciwgcGFyYW1zID0ge30sIGxvY2F0aW9ucyA9IFtdLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIxMi5kZWZhdWx0KFwiZmluZFwiLCB7IGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gIGNvbnN0IHF1ZXJ5SGFzaCA9IGNyZWF0ZUZpbmRlckhhc2goZmluZGVyLCBwYXJhbXMsIGxvY2F0aW9ucyk7XG4gIGxvZ2dlcjEyLmRlYnVnKFwiR2VuZXJhdGVkIHF1ZXJ5IGhhc2ggZm9yIGZpbmRcIiwgeyBxdWVyeUhhc2ggfSk7XG4gIGNvbnN0IGNhY2hlZEl0ZW1LZXlzID0gYXdhaXQgY2FjaGVNYXAuZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgaWYgKGNhY2hlZEl0ZW1LZXlzKSB7XG4gICAgbG9nZ2VyMTIuZGVidWcoXCJVc2luZyBjYWNoZWQgcXVlcnkgcmVzdWx0c1wiLCB7IGNhY2hlZEtleUNvdW50OiBjYWNoZWRJdGVtS2V5cy5sZW5ndGggfSk7XG4gICAgY29uc3QgY2FjaGVkSXRlbXMgPSBbXTtcbiAgICBsZXQgYWxsSXRlbXNBdmFpbGFibGUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaXRlbUtleSBvZiBjYWNoZWRJdGVtS2V5cykge1xuICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlTWFwLmdldChpdGVtS2V5KTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNhY2hlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxJdGVtc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbEl0ZW1zQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEs5KGNhY2hlZEl0ZW1zLCBwa1R5cGUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMTIuZGVidWcoXCJTb21lIGNhY2hlZCBpdGVtcyBtaXNzaW5nLCBpbnZhbGlkYXRpbmcgcXVlcnkgY2FjaGVcIik7XG4gICAgICBjYWNoZU1hcC5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXQgPSBhd2FpdCBhcGkuZmluZChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zKTtcbiAgcmV0LmZvckVhY2goKHYpID0+IHtcbiAgICBjYWNoZU1hcC5zZXQodi5rZXksIHYpO1xuICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KHYua2V5KTtcbiAgICB0dGxNYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgY2FjaGVNYXApO1xuICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gY29udGV4dC5ldmljdGlvbk1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCB2LCBjYWNoZU1hcCk7XG4gICAgZXZpY3RlZEtleXMuZm9yRWFjaCgoZXZpY3RlZEtleSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICAgIGNhY2hlTWFwLmRlbGV0ZShwYXJzZWRLZXkpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgaXRlbUtleXMgPSByZXQubWFwKChpdGVtKSA9PiBpdGVtLmtleSk7XG4gIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpO1xuICBsb2dnZXIxMi5kZWJ1ZyhcIkNhY2hlZCBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGl0ZW1LZXlDb3VudDogaXRlbUtleXMubGVuZ3RoIH0pO1xuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEs5KHJldCwgcGtUeXBlKV07XG59O1xuXG4vLyBzcmMvb3BzL2ZpbmRPbmUudHNcbmltcG9ydCB7XG4gIHZhbGlkYXRlUEsgYXMgdmFsaWRhdGVQSzEwXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xudmFyIGxvZ2dlcjEzID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiZmluZE9uZVwiKTtcbnZhciBmaW5kT25lID0gYXN5bmMgKGZpbmRlciwgZmluZGVyUGFyYW1zID0ge30sIGxvY2F0aW9ucyA9IFtdLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgYXBpLCBjYWNoZU1hcCwgcGtUeXBlLCB0dGxNYW5hZ2VyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIxMy5kZWZhdWx0KFwiZmluZE9uZVwiLCB7IGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gIGNvbnN0IHF1ZXJ5SGFzaCA9IGNyZWF0ZUZpbmRlckhhc2goZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyk7XG4gIGxvZ2dlcjEzLmRlYnVnKFwiR2VuZXJhdGVkIHF1ZXJ5IGhhc2ggZm9yIGZpbmRPbmVcIiwgeyBxdWVyeUhhc2ggfSk7XG4gIGNvbnN0IGNhY2hlZEl0ZW1LZXlzID0gYXdhaXQgY2FjaGVNYXAuZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgaWYgKGNhY2hlZEl0ZW1LZXlzICYmIGNhY2hlZEl0ZW1LZXlzLmxlbmd0aCA+IDApIHtcbiAgICBsb2dnZXIxMy5kZWJ1ZyhcIlVzaW5nIGNhY2hlZCBxdWVyeSByZXN1bHRzXCIsIHsgY2FjaGVkS2V5Q291bnQ6IGNhY2hlZEl0ZW1LZXlzLmxlbmd0aCB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGVNYXAuZ2V0KGNhY2hlZEl0ZW1LZXlzWzBdKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLMTAoaXRlbSwgcGtUeXBlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjEzLmRlYnVnKFwiQ2FjaGVkIGl0ZW0gbWlzc2luZywgaW52YWxpZGF0aW5nIHF1ZXJ5IGNhY2hlXCIpO1xuICAgICAgY2FjaGVNYXAuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmV0ID0gYXdhaXQgYXBpLmZpbmRPbmUoZmluZGVyLCBmaW5kZXJQYXJhbXMsIGxvY2F0aW9ucyk7XG4gIGNhY2hlTWFwLnNldChyZXQua2V5LCByZXQpO1xuICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShyZXQua2V5KTtcbiAgdHRsTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIGNhY2hlTWFwKTtcbiAgY29uc3QgZXZpY3RlZEtleXMgPSBjb250ZXh0LmV2aWN0aW9uTWFuYWdlci5vbkl0ZW1BZGRlZChrZXlTdHIsIHJldCwgY2FjaGVNYXApO1xuICBldmljdGVkS2V5cy5mb3JFYWNoKChldmljdGVkS2V5KSA9PiB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgfSk7XG4gIGNhY2hlTWFwLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgW3JldC5rZXldKTtcbiAgbG9nZ2VyMTMuZGVidWcoXCJDYWNoZWQgcXVlcnkgcmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBpdGVtS2V5OiByZXQua2V5IH0pO1xuICByZXR1cm4gW2NvbnRleHQsIHZhbGlkYXRlUEsxMChyZXQsIHBrVHlwZSldO1xufTtcblxuLy8gc3JjL29wcy9zZXQudHNcbmltcG9ydCB7XG4gIGlzSXRlbUtleUVxdWFsLFxuICBpc1ZhbGlkSXRlbUtleSBhcyBpc1ZhbGlkSXRlbUtleTYsXG4gIHZhbGlkYXRlUEsgYXMgdmFsaWRhdGVQSzExXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xudmFyIGxvZ2dlcjE0ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwic2V0XCIpO1xudmFyIG5vcm1hbGl6ZUtleVZhbHVlMiA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn07XG52YXIgaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZEEgPSBub3JtYWxpemVLZXkoYSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRCID0gbm9ybWFsaXplS2V5KGIpO1xuICByZXR1cm4gaXNJdGVtS2V5RXF1YWwobm9ybWFsaXplZEEsIG5vcm1hbGl6ZWRCKTtcbn07XG52YXIgbm9ybWFsaXplS2V5ID0gKGtleSkgPT4ge1xuICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiAmJiBrZXkgIT09IG51bGwpIHtcbiAgICBsZXQgbmVlZHNOb3JtYWxpemF0aW9uID0gZmFsc2U7XG4gICAgbGV0IG5vcm1hbGl6ZWRLZXkgPSBrZXk7XG4gICAgaWYgKFwicGtcIiBpbiBrZXkgJiYga2V5LnBrICE9PSBudWxsICYmIHR5cGVvZiBrZXkucGsgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5lZWRzTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChcImxrXCIgaW4ga2V5ICYmIGtleS5sayAhPT0gbnVsbCAmJiB0eXBlb2Yga2V5LmxrICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBuZWVkc05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoXCJsb2NcIiBpbiBrZXkgJiYgQXJyYXkuaXNBcnJheShrZXkubG9jKSkge1xuICAgICAgZm9yIChjb25zdCBsb2NJdGVtIG9mIGtleS5sb2MpIHtcbiAgICAgICAgaWYgKGxvY0l0ZW0gJiYgXCJsa1wiIGluIGxvY0l0ZW0gJiYgbG9jSXRlbS5sayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9jSXRlbS5sayAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIG5lZWRzTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbikge1xuICAgICAgbm9ybWFsaXplZEtleSA9IHsgLi4ua2V5IH07XG4gICAgICBpZiAoXCJwa1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgbm9ybWFsaXplZEtleS5wayAhPT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkS2V5LnBrID0gbm9ybWFsaXplS2V5VmFsdWUyKG5vcm1hbGl6ZWRLZXkucGspO1xuICAgICAgfVxuICAgICAgaWYgKFwibGtcIiBpbiBub3JtYWxpemVkS2V5ICYmIG5vcm1hbGl6ZWRLZXkubGsgIT09IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5sayA9IG5vcm1hbGl6ZUtleVZhbHVlMihub3JtYWxpemVkS2V5LmxrKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImxvY1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgQXJyYXkuaXNBcnJheShub3JtYWxpemVkS2V5LmxvYykpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5sb2MgPSBub3JtYWxpemVkS2V5LmxvYy5tYXAoKGxvY0l0ZW0pID0+IHtcbiAgICAgICAgICBpZiAobG9jSXRlbSAmJiBcImxrXCIgaW4gbG9jSXRlbSAmJiBsb2NJdGVtLmxrICE9PSBudWxsICYmIHR5cGVvZiBsb2NJdGVtLmxrICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5sb2NJdGVtLCBsazogbm9ybWFsaXplS2V5VmFsdWUyKGxvY0l0ZW0ubGspIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NJdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRLZXk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG52YXIgc2V0ID0gYXN5bmMgKGtleSwgdiwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IGNhY2hlTWFwLCBwa1R5cGUsIHR0bE1hbmFnZXIsIGV2aWN0aW9uTWFuYWdlciwgZXZlbnRFbWl0dGVyIH0gPSBjb250ZXh0O1xuICBsb2dnZXIxNC5kZWZhdWx0KFwic2V0XCIsIHsga2V5LCB2IH0pO1xuICBpZiAoIWlzVmFsaWRJdGVtS2V5NihrZXkpKSB7XG4gICAgbG9nZ2VyMTQuZXJyb3IoXCJLZXkgZm9yIFNldCBpcyBub3QgYSB2YWxpZCBJdGVtS2V5OiAlalwiLCBrZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleSBmb3IgU2V0IGlzIG5vdCBhIHZhbGlkIEl0ZW1LZXlcIik7XG4gIH1cbiAgdmFsaWRhdGVQSzExKHYsIHBrVHlwZSk7XG4gIGlmICghaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkKGtleSwgdi5rZXkpKSB7XG4gICAgbG9nZ2VyMTQuZXJyb3IoXCJLZXkgZG9lcyBub3QgbWF0Y2ggaXRlbSBrZXk6ICVqICE9ICVqXCIsIGtleSwgdi5rZXkpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleSBkb2VzIG5vdCBtYXRjaCBpdGVtIGtleVwiKTtcbiAgfVxuICBjb25zdCBwcmV2aW91c0l0ZW0gPSBhd2FpdCBjYWNoZU1hcC5nZXQoa2V5KTtcbiAgY2FjaGVNYXAuc2V0KGtleSwgdik7XG4gIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIHR0bE1hbmFnZXIub25JdGVtQWRkZWQoa2V5U3RyLCBjYWNoZU1hcCk7XG4gIGNvbnN0IGV2aWN0ZWRLZXlzID0gZXZpY3Rpb25NYW5hZ2VyLm9uSXRlbUFkZGVkKGtleVN0ciwgdiwgY2FjaGVNYXApO1xuICBldmljdGVkS2V5cy5mb3JFYWNoKChldmljdGVkS2V5KSA9PiB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShldmljdGVkS2V5KTtcbiAgICBjYWNoZU1hcC5kZWxldGUocGFyc2VkS2V5KTtcbiAgfSk7XG4gIGNvbnN0IGV2ZW50ID0gQ2FjaGVFdmVudEZhY3RvcnkuaXRlbVNldChrZXksIHYsIHByZXZpb3VzSXRlbSk7XG4gIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgcmV0dXJuIFtjb250ZXh0LCB2YWxpZGF0ZVBLMTEodiwgcGtUeXBlKV07XG59O1xuXG4vLyBzcmMvbWVtb3J5L01lbW9yeUNhY2hlTWFwLnRzXG5pbXBvcnQge1xuICBpc0NvbUtleSxcbiAgaXNRdWVyeU1hdGNoXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuXG4vLyBzcmMvQ2FjaGVNYXAudHNcbnZhciBDYWNoZU1hcCA9IGNsYXNzIHtcbiAgdHlwZXM7XG4gIGNvbnN0cnVjdG9yKHR5cGVzKSB7XG4gICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICB9XG59O1xuXG4vLyBzcmMvbWVtb3J5L01lbW9yeUNhY2hlTWFwLnRzXG52YXIgbG9nZ2VyMTUgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJNZW1vcnlDYWNoZU1hcFwiKTtcbnZhciBNZW1vcnlDYWNoZU1hcCA9IGNsYXNzIF9NZW1vcnlDYWNoZU1hcCBleHRlbmRzIENhY2hlTWFwIHtcbiAgaW1wbGVtZW50YXRpb25UeXBlID0gXCJtZW1vcnkvbWVtb3J5XCI7XG4gIG1hcCA9IHt9O1xuICBub3JtYWxpemVkSGFzaEZ1bmN0aW9uO1xuICAvLyBRdWVyeSByZXN1bHQgY2FjaGU6IG1hcHMgcXVlcnkgaGFzaCB0byBjYWNoZSBlbnRyeVxuICBxdWVyeVJlc3VsdENhY2hlID0ge307XG4gIC8vIE1ldGFkYXRhIHN0b3JhZ2UgZm9yIGV2aWN0aW9uIHN0cmF0ZWdpZXNcbiAgbWV0YWRhdGFNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3Rvcih0eXBlcywgaW5pdGlhbERhdGEpIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbigpO1xuICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgZm9yIChjb25zdCBba2V5U3RyLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdGlhbERhdGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5wYXJzZShrZXlTdHIpO1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE1LmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGluaXRpYWwgZGF0YSBrZXlcIiwgeyBrZXlTdHIsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICBsb2dnZXIxNS50cmFjZShcImdldFwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgaWYgKGVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleSkge1xuICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YU1hcC5nZXQoa2V5U3RyKTtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgbG9nZ2VyMTUudHJhY2UoXCJzZXRcIiwgeyBrZXksIHZhbHVlIH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHsgb3JpZ2luYWxLZXk6IGtleSwgdmFsdWUgfTtcbiAgICBpZiAoIXRoaXMubWV0YWRhdGFNYXAuaGFzKGtleVN0cikpIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAga2V5OiBrZXlTdHIsXG4gICAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICAgIGVzdGltYXRlZFNpemU6IGVzdGltYXRlVmFsdWVTaXplKHZhbHVlKVxuICAgICAgfTtcbiAgICAgIHRoaXMubWV0YWRhdGFNYXAuc2V0KGtleVN0ciwgbWV0YWRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFNYXAuZ2V0KGtleVN0cik7XG4gICAgICBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgICAgbWV0YWRhdGEuZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5jbHVkZXNLZXkoa2V5KSB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIHJldHVybiAhIWVudHJ5ICYmIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihlbnRyeS5vcmlnaW5hbEtleSkgPT09IGhhc2hlZEtleTtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgbG9nZ2VyMTUudHJhY2UoXCJkZWxldGVcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIGlmIChlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXkpIHtcbiAgICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgICAgIHRoaXMubWV0YWRhdGFNYXAuZGVsZXRlKGtleVN0cik7XG4gICAgICBkZWxldGUgdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICAgIGZvciAoY29uc3QgW3F1ZXJ5SGFzaCwgY2FjaGVFbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5xdWVyeVJlc3VsdENhY2hlKSkge1xuICAgICAgICBjYWNoZUVudHJ5Lml0ZW1LZXlzID0gY2FjaGVFbnRyeS5pdGVtS2V5cy5maWx0ZXIoKGspID0+IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrKSAhPT0gaGFzaGVkS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlRW50cnkuaXRlbUtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcCgoZW50cnkpID0+IGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgfVxuICBhc3luYyB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMubWV0YWRhdGFNYXAuY2xlYXIoKTtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUgPSB7fTtcbiAgfVxuICBhc3luYyBhbGxJbihsb2NhdGlvbnMpIHtcbiAgICBjb25zdCBhbGxWYWx1ZXMgPSBhd2FpdCB0aGlzLnZhbHVlcygpO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIxNS5kZWJ1ZyhcIlJldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHlcIik7XG4gICAgICByZXR1cm4gYWxsVmFsdWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIxNS5kZWJ1ZyhcImFsbEluXCIsIHsgbG9jYXRpb25zLCBjb3VudDogYWxsVmFsdWVzLmxlbmd0aCB9KTtcbiAgICAgIHJldHVybiBhbGxWYWx1ZXMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgICBpZiAoa2V5ICYmIGlzQ29tS2V5KGtleSkpIHtcbiAgICAgICAgICBjb25zdCBjb21LZXkgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NhdGlvbnMsIGNvbUtleS5sb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb250YWlucyhxdWVyeSwgbG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTUuZGVidWcoXCJjb250YWluc1wiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaChpdGVtLCBxdWVyeSkpO1xuICB9XG4gIGFzeW5jIHF1ZXJ5SW4ocXVlcnksIGxvY2F0aW9ucyA9IFtdKSB7XG4gICAgbG9nZ2VyMTUuZGVidWcoXCJxdWVyeUluXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2goaXRlbSwgcXVlcnkpKTtcbiAgfVxuICBhc3luYyBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBfTWVtb3J5Q2FjaGVNYXAodGhpcy50eXBlcyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBjbG9uZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3F1ZXJ5SGFzaCwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucXVlcnlSZXN1bHRDYWNoZSkpIHtcbiAgICAgIGNsb25lLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXSA9IHtcbiAgICAgICAgaXRlbUtleXM6IFsuLi5lbnRyeS5pdGVtS2V5c11cbiAgICAgICAgLy8gU2hhbGxvdyBjb3B5IG9mIHRoZSBhcnJheVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbiAgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cykge1xuICAgIGxvZ2dlcjE1LnRyYWNlKFwic2V0UXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgaXRlbUtleXM6IFsuLi5pdGVtS2V5c11cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgdG8gYXZvaWQgZXh0ZXJuYWwgbXV0YXRpb25zXG4gICAgfTtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXSA9IGVudHJ5O1xuICB9XG4gIGFzeW5jIGdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGxvZ2dlcjE1LnRyYWNlKFwiZ2V0UXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5lbnRyeS5pdGVtS2V5c107XG4gIH1cbiAgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgICByZXR1cm4gISFlbnRyeTtcbiAgfVxuICBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxNS50cmFjZShcImRlbGV0ZVF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGVbcXVlcnlIYXNoXTtcbiAgfVxuICBpbnZhbGlkYXRlSXRlbUtleXMoa2V5cykge1xuICAgIGxvZ2dlcjE1LmRlYnVnKFwiaW52YWxpZGF0ZUl0ZW1LZXlzXCIsIHsga2V5cyB9KTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTUuZGVidWcoXCJpbnZhbGlkYXRlTG9jYXRpb25cIiwgeyBsb2NhdGlvbnMgfSk7XG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGFsbEtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgIGNvbnN0IHByaW1hcnlLZXlzID0gYWxsS2V5cy5maWx0ZXIoKGtleSkgPT4gIWlzQ29tS2V5KGtleSkpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMocHJpbWFyeUtleXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVtc0luTG9jYXRpb24gPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgICBjb25zdCBrZXlzVG9JbnZhbGlkYXRlID0gaXRlbXNJbkxvY2F0aW9uLm1hcCgoaXRlbSkgPT4gaXRlbS5rZXkpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlSXRlbUtleXMoa2V5c1RvSW52YWxpZGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJRdWVyeVJlc3VsdHMoKTtcbiAgfVxuICBjbGVhclF1ZXJ5UmVzdWx0cygpIHtcbiAgICBsb2dnZXIxNS50cmFjZShcImNsZWFyUXVlcnlSZXN1bHRzXCIpO1xuICAgIHRoaXMucXVlcnlSZXN1bHRDYWNoZSA9IHt9O1xuICB9XG4gIC8vIENhY2hlTWFwTWV0YWRhdGFQcm92aWRlciBpbXBsZW1lbnRhdGlvblxuICBnZXRNZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YU1hcC5nZXQoa2V5KSB8fCBudWxsO1xuICB9XG4gIHNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpIHtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLnNldChrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBkZWxldGVNZXRhZGF0YShrZXkpIHtcbiAgICB0aGlzLm1ldGFkYXRhTWFwLmRlbGV0ZShrZXkpO1xuICB9XG4gIGdldEFsbE1ldGFkYXRhKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMubWV0YWRhdGFNYXApO1xuICB9XG4gIGNsZWFyTWV0YWRhdGEoKSB7XG4gICAgdGhpcy5tZXRhZGF0YU1hcC5jbGVhcigpO1xuICB9XG4gIGdldEN1cnJlbnRTaXplKCkge1xuICAgIGxldCBzaXplQnl0ZXMgPSAwO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1hcCkpIHtcbiAgICAgIHNpemVCeXRlcyArPSBlc3RpbWF0ZVZhbHVlU2l6ZShlbnRyeS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpdGVtQ291bnQ6IE9iamVjdC5rZXlzKHRoaXMubWFwKS5sZW5ndGgsXG4gICAgICBzaXplQnl0ZXNcbiAgICB9O1xuICB9XG4gIGdldFNpemVMaW1pdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEl0ZW1zOiBudWxsLFxuICAgICAgbWF4U2l6ZUJ5dGVzOiBudWxsXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL21lbW9yeS9FbmhhbmNlZE1lbW9yeUNhY2hlTWFwLnRzXG5pbXBvcnQge1xuICBpc0NvbUtleSBhcyBpc0NvbUtleTIsXG4gIGlzUXVlcnlNYXRjaCBhcyBpc1F1ZXJ5TWF0Y2gyXG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xudmFyIGxvZ2dlcjE2ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiRW5oYW5jZWRNZW1vcnlDYWNoZU1hcFwiKTtcbnZhciBFbmhhbmNlZE1lbW9yeUNhY2hlTWFwID0gY2xhc3MgX0VuaGFuY2VkTWVtb3J5Q2FjaGVNYXAgZXh0ZW5kcyBDYWNoZU1hcCB7XG4gIGltcGxlbWVudGF0aW9uVHlwZSA9IFwibWVtb3J5L2VuaGFuY2VkXCI7XG4gIG1hcCA9IHt9O1xuICBub3JtYWxpemVkSGFzaEZ1bmN0aW9uO1xuICAvLyBRdWVyeSByZXN1bHQgY2FjaGU6IG1hcHMgcXVlcnkgaGFzaCB0byBjYWNoZSBlbnRyeVxuICBxdWVyeVJlc3VsdENhY2hlID0ge307XG4gIC8vIFNpemUgdHJhY2tpbmdcbiAgY3VycmVudFNpemVCeXRlcyA9IDA7XG4gIGN1cnJlbnRJdGVtQ291bnQgPSAwO1xuICBxdWVyeVJlc3VsdHNDYWNoZVNpemUgPSAwO1xuICAvLyBTaXplIGxpbWl0c1xuICBtYXhTaXplQnl0ZXM7XG4gIG1heEl0ZW1zO1xuICBjb25zdHJ1Y3Rvcih0eXBlcywgc2l6ZUNvbmZpZywgaW5pdGlhbERhdGEpIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbigpO1xuICAgIGlmIChzaXplQ29uZmlnPy5tYXhTaXplQnl0ZXMpIHtcbiAgICAgIHRoaXMubWF4U2l6ZUJ5dGVzID0gcGFyc2VTaXplU3RyaW5nKHNpemVDb25maWcubWF4U2l6ZUJ5dGVzKTtcbiAgICAgIGxvZ2dlcjE2LmRlYnVnKFwiQ2FjaGUgc2l6ZSBsaW1pdCBzZXRcIiwgeyBtYXhTaXplQnl0ZXM6IHRoaXMubWF4U2l6ZUJ5dGVzIH0pO1xuICAgIH1cbiAgICBpZiAoc2l6ZUNvbmZpZz8ubWF4SXRlbXMpIHtcbiAgICAgIHRoaXMubWF4SXRlbXMgPSBzaXplQ29uZmlnLm1heEl0ZW1zO1xuICAgICAgbG9nZ2VyMTYuZGVidWcoXCJDYWNoZSBpdGVtIGxpbWl0IHNldFwiLCB7IG1heEl0ZW1zOiB0aGlzLm1heEl0ZW1zIH0pO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleVN0ciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGluaXRpYWxEYXRhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IEpTT04ucGFyc2Uoa2V5U3RyKTtcbiAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIxNi5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBpbml0aWFsIGRhdGEga2V5XCIsIHsga2V5U3RyLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgbG9nZ2VyMTYudHJhY2UoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICAgIGlmIChlbnRyeSAmJiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oZW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXkgJiYgZW50cnkudmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBsb2dnZXIxNi50cmFjZShcInNldFwiLCB7IGtleSwgdmFsdWUgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKHZhbHVlKTtcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICBjb25zdCBpc1VwZGF0ZSA9IGV4aXN0aW5nRW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGV4aXN0aW5nRW50cnkub3JpZ2luYWxLZXkpID09PSBoYXNoZWRLZXk7XG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICBjb25zdCBzaXplRGlmZiA9IGVzdGltYXRlZFNpemUgLSBleGlzdGluZ0VudHJ5Lm1ldGFkYXRhLmVzdGltYXRlZFNpemU7XG4gICAgICB0aGlzLmN1cnJlbnRTaXplQnl0ZXMgKz0gc2l6ZURpZmY7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IGV4aXN0aW5nRW50cnkudmFsdWU7XG4gICAgICBleGlzdGluZ0VudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICBleGlzdGluZ0VudHJ5Lm1ldGFkYXRhLmVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZWRTaXplO1xuICAgICAgbG9nZ2VyMTYudHJhY2UoXCJVcGRhdGVkIGV4aXN0aW5nIGNhY2hlIGVudHJ5XCIsIHtcbiAgICAgICAga2V5OiBoYXNoZWRLZXksXG4gICAgICAgIHNpemVEaWZmLFxuICAgICAgICBjdXJyZW50U2l6ZTogdGhpcy5jdXJyZW50U2l6ZUJ5dGVzLFxuICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUgIT09IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIGFkZGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIGxhc3RBY2Nlc3NlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBhY2Nlc3NDb3VudDogMCxcbiAgICAgICAgZXN0aW1hdGVkU2l6ZSxcbiAgICAgICAga2V5OiBoYXNoZWRLZXlcbiAgICAgIH07XG4gICAgICB0aGlzLm1hcFtoYXNoZWRLZXldID0ge1xuICAgICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH07XG4gICAgICB0aGlzLmN1cnJlbnRTaXplQnl0ZXMgKz0gZXN0aW1hdGVkU2l6ZTtcbiAgICAgIHRoaXMuY3VycmVudEl0ZW1Db3VudCsrO1xuICAgICAgbG9nZ2VyMTYudHJhY2UoXCJBZGRlZCBuZXcgY2FjaGUgZW50cnlcIiwge1xuICAgICAgICBrZXk6IGhhc2hlZEtleSxcbiAgICAgICAgc2l6ZTogZXN0aW1hdGVkU2l6ZSxcbiAgICAgICAgY3VycmVudFNpemU6IHRoaXMuY3VycmVudFNpemVCeXRlcyxcbiAgICAgICAgY3VycmVudENvdW50OiB0aGlzLmN1cnJlbnRJdGVtQ291bnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBpbmNsdWRlc0tleShrZXkpIHtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgcmV0dXJuICEhZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5ICYmIGVudHJ5LnZhbHVlICE9PSBudWxsO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLmRlbGV0ZUludGVybmFsKGtleSwgdHJ1ZSwgXCJmaWx0ZXJcIik7XG4gIH1cbiAgZGVsZXRlSW50ZXJuYWwoa2V5LCBpbnZhbGlkYXRlUXVlcmllcyA9IGZhbHNlLCBpbnZhbGlkYXRpb25Nb2RlID0gXCJyZW1vdmVcIikge1xuICAgIGxvZ2dlcjE2LnRyYWNlKFwiZGVsZXRlXCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGhhc2hlZEtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICBpZiAoZW50cnkgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGVudHJ5Lm9yaWdpbmFsS2V5KSA9PT0gaGFzaGVkS2V5KSB7XG4gICAgICB0aGlzLmN1cnJlbnRTaXplQnl0ZXMgLT0gZW50cnkubWV0YWRhdGEuZXN0aW1hdGVkU2l6ZTtcbiAgICAgIHRoaXMuY3VycmVudEl0ZW1Db3VudC0tO1xuICAgICAgZGVsZXRlIHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgICBsb2dnZXIxNi50cmFjZShcIkRlbGV0ZWQgY2FjaGUgZW50cnlcIiwge1xuICAgICAgICBrZXk6IGhhc2hlZEtleSxcbiAgICAgICAgZnJlZWRTaXplOiBlbnRyeS5tZXRhZGF0YS5lc3RpbWF0ZWRTaXplLFxuICAgICAgICBjdXJyZW50U2l6ZTogdGhpcy5jdXJyZW50U2l6ZUJ5dGVzLFxuICAgICAgICBjdXJyZW50Q291bnQ6IHRoaXMuY3VycmVudEl0ZW1Db3VudFxuICAgICAgfSk7XG4gICAgICBpZiAoaW52YWxpZGF0ZVF1ZXJpZXMpIHtcbiAgICAgICAgaWYgKGludmFsaWRhdGlvbk1vZGUgPT09IFwiZmlsdGVyXCIpIHtcbiAgICAgICAgICB0aGlzLmZpbHRlclF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZVF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLmZpbHRlcigoZW50cnkpID0+IGVudHJ5LnZhbHVlICE9PSBudWxsKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS5vcmlnaW5hbEtleSk7XG4gIH1cbiAgYXN5bmMgdmFsdWVzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSAhPT0gbnVsbCkubWFwKChlbnRyeSkgPT4gZW50cnkudmFsdWUpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGxvZ2dlcjE2LmRlYnVnKFwiQ2xlYXJpbmcgY2FjaGVcIiwge1xuICAgICAgaXRlbXNDbGVhcmVkOiB0aGlzLmN1cnJlbnRJdGVtQ291bnQsXG4gICAgICBieXRlc0ZyZWVkOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXNcbiAgICB9KTtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMuY3VycmVudFNpemVCeXRlcyA9IDA7XG4gICAgdGhpcy5jdXJyZW50SXRlbUNvdW50ID0gMDtcbiAgfVxuICBhc3luYyBhbGxJbihsb2NhdGlvbnMpIHtcbiAgICBjb25zdCBhbGxWYWx1ZXMgPSBhd2FpdCB0aGlzLnZhbHVlcygpO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIxNi5kZWJ1ZyhcIlJldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHlcIik7XG4gICAgICByZXR1cm4gYWxsVmFsdWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIxNi5kZWJ1ZyhcImFsbEluXCIsIHsgbG9jYXRpb25zLCBjb3VudDogYWxsVmFsdWVzLmxlbmd0aCB9KTtcbiAgICAgIHJldHVybiBhbGxWYWx1ZXMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgICBpZiAoa2V5ICYmIGlzQ29tS2V5MihrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NhdGlvbnMsIGtleS5sb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb250YWlucyhxdWVyeSwgbG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTYuZGVidWcoXCJjb250YWluc1wiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaDIoaXRlbSwgcXVlcnkpKTtcbiAgfVxuICBhc3luYyBxdWVyeUluKHF1ZXJ5LCBsb2NhdGlvbnMgPSBbXSkge1xuICAgIGxvZ2dlcjE2LmRlYnVnKFwicXVlcnlJblwiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmFsbEluKGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXNRdWVyeU1hdGNoMihpdGVtLCBxdWVyeSkpO1xuICB9XG4gIGFzeW5jIGNsb25lKCkge1xuICAgIGNvbnN0IHNpemVDb25maWcgPSB7fTtcbiAgICBpZiAodGhpcy5tYXhTaXplQnl0ZXMpIHtcbiAgICAgIHNpemVDb25maWcubWF4U2l6ZUJ5dGVzID0gdGhpcy5tYXhTaXplQnl0ZXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4SXRlbXMpIHtcbiAgICAgIHNpemVDb25maWcubWF4SXRlbXMgPSB0aGlzLm1heEl0ZW1zO1xuICAgIH1cbiAgICBjb25zdCBjbG9uZSA9IG5ldyBfRW5oYW5jZWRNZW1vcnlDYWNoZU1hcCh0aGlzLnR5cGVzLCBzaXplQ29uZmlnKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGNsb25lLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbcXVlcnlIYXNoLCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5xdWVyeVJlc3VsdENhY2hlKSkge1xuICAgICAgY2xvbmUuc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBlbnRyeS5pdGVtS2V5cyk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY2FjaGUgc3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0U3RhdHMoKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICBjdXJyZW50U2l6ZUJ5dGVzOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXMsXG4gICAgICBjdXJyZW50SXRlbUNvdW50OiB0aGlzLmN1cnJlbnRJdGVtQ291bnQsXG4gICAgICBtYXhTaXplQnl0ZXM6IHRoaXMubWF4U2l6ZUJ5dGVzLFxuICAgICAgbWF4SXRlbXM6IHRoaXMubWF4SXRlbXMsXG4gICAgICB1dGlsaXphdGlvblBlcmNlbnQ6IHt9XG4gICAgfTtcbiAgICBpZiAodGhpcy5tYXhTaXplQnl0ZXMpIHtcbiAgICAgIHN0YXRzLnV0aWxpemF0aW9uUGVyY2VudC5ieXRlcyA9IHRoaXMuY3VycmVudFNpemVCeXRlcyAvIHRoaXMubWF4U2l6ZUJ5dGVzICogMTAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhJdGVtcykge1xuICAgICAgc3RhdHMudXRpbGl6YXRpb25QZXJjZW50Lml0ZW1zID0gdGhpcy5jdXJyZW50SXRlbUNvdW50IC8gdGhpcy5tYXhJdGVtcyAqIDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIC8vIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHNcbiAgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cykge1xuICAgIGxvZ2dlcjE2LnRyYWNlKFwic2V0UXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuICAgIGlmIChxdWVyeUhhc2ggaW4gdGhpcy5xdWVyeVJlc3VsdENhY2hlKSB7XG4gICAgICB0aGlzLnJlbW92ZVF1ZXJ5UmVzdWx0RnJvbVNpemVUcmFja2luZyhxdWVyeUhhc2gpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGl0ZW1LZXlzOiBbLi4uaXRlbUtleXNdXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IHRvIGF2b2lkIGV4dGVybmFsIG11dGF0aW9uc1xuICAgIH07XG4gICAgdGhpcy5xdWVyeVJlc3VsdENhY2hlW3F1ZXJ5SGFzaF0gPSBlbnRyeTtcbiAgICB0aGlzLmFkZFF1ZXJ5UmVzdWx0VG9TaXplVHJhY2tpbmcocXVlcnlIYXNoLCBlbnRyeSk7XG4gIH1cbiAgYXN5bmMgZ2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgbG9nZ2VyMTYudHJhY2UoXCJnZXRRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLmVudHJ5Lml0ZW1LZXlzXTtcbiAgfVxuICBoYXNRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIHJldHVybiAhIWVudHJ5O1xuICB9XG4gIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGlmIChxdWVyeUhhc2ggaW4gdGhpcy5xdWVyeVJlc3VsdENhY2hlKSB7XG4gICAgICB0aGlzLnJlbW92ZVF1ZXJ5UmVzdWx0RnJvbVNpemVUcmFja2luZyhxdWVyeUhhc2gpO1xuICAgICAgZGVsZXRlIHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIH1cbiAgfVxuICBjbGVhclF1ZXJ5UmVzdWx0cygpIHtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZSA9IDA7XG4gIH1cbiAgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXMpIHtcbiAgICBsb2dnZXIxNi5kZWJ1ZyhcImludmFsaWRhdGVJdGVtS2V5c1wiLCB7IGtleXMgfSk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLmRlbGV0ZUludGVybmFsKGtleSwgZmFsc2UpO1xuICAgIH0pO1xuICAgIHRoaXMuaW52YWxpZGF0ZVF1ZXJpZXNSZWZlcmVuY2luZ0tleXMoa2V5cyk7XG4gIH1cbiAgZmlsdGVyUXVlcmllc1JlZmVyZW5jaW5nS2V5cyhrZXlzKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZEtleXNUb0ludmFsaWRhdGUgPSBuZXcgU2V0KGtleXMubWFwKChrZXkpID0+IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSk7XG4gICAgY29uc3QgcXVlcmllc1RvUmVtb3ZlID0gW107XG4gICAgZm9yIChjb25zdCBbcXVlcnlIYXNoLCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5xdWVyeVJlc3VsdENhY2hlKSkge1xuICAgICAgY29uc3QgZmlsdGVyZWRLZXlzID0gZW50cnkuaXRlbUtleXMuZmlsdGVyKChpdGVtS2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZEl0ZW1LZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oaXRlbUtleSk7XG4gICAgICAgIHJldHVybiAhaGFzaGVkS2V5c1RvSW52YWxpZGF0ZS5oYXMoaGFzaGVkSXRlbUtleSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmaWx0ZXJlZEtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHF1ZXJpZXNUb1JlbW92ZS5wdXNoKHF1ZXJ5SGFzaCk7XG4gICAgICB9IGVsc2UgaWYgKGZpbHRlcmVkS2V5cy5sZW5ndGggIT09IGVudHJ5Lml0ZW1LZXlzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgZmlsdGVyZWRLZXlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcXVlcmllc1RvUmVtb3ZlLmZvckVhY2goKHF1ZXJ5SGFzaCkgPT4ge1xuICAgICAgdGhpcy5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH0pO1xuICB9XG4gIGludmFsaWRhdGVRdWVyaWVzUmVmZXJlbmNpbmdLZXlzKGtleXMpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkS2V5c1RvSW52YWxpZGF0ZSA9IG5ldyBTZXQoa2V5cy5tYXAoKGtleSkgPT4gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSkpKTtcbiAgICBjb25zdCBxdWVyaWVzVG9SZW1vdmUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtxdWVyeUhhc2gsIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnF1ZXJ5UmVzdWx0Q2FjaGUpKSB7XG4gICAgICBjb25zdCBxdWVyeVJlZmVyZW5jZXNJbnZhbGlkYXRlZEtleSA9IGVudHJ5Lml0ZW1LZXlzLnNvbWUoKGl0ZW1LZXkpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaGVkSXRlbUtleSA9IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihpdGVtS2V5KTtcbiAgICAgICAgcmV0dXJuIGhhc2hlZEtleXNUb0ludmFsaWRhdGUuaGFzKGhhc2hlZEl0ZW1LZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAocXVlcnlSZWZlcmVuY2VzSW52YWxpZGF0ZWRLZXkpIHtcbiAgICAgICAgcXVlcmllc1RvUmVtb3ZlLnB1c2gocXVlcnlIYXNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcXVlcmllc1RvUmVtb3ZlLmZvckVhY2goKHF1ZXJ5SGFzaCkgPT4ge1xuICAgICAgdGhpcy5kZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGludmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbnMpIHtcbiAgICBsb2dnZXIxNi5kZWJ1ZyhcImludmFsaWRhdGVMb2NhdGlvblwiLCB7IGxvY2F0aW9ucyB9KTtcbiAgICBsZXQga2V5c1RvSW52YWxpZGF0ZSA9IFtdO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBhbGxLZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKChrZXkpID0+ICFpc0NvbUtleTIoa2V5KSk7XG4gICAgICBrZXlzVG9JbnZhbGlkYXRlID0gcHJpbWFyeUtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGl0ZW1zSW5Mb2NhdGlvbiA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICAgIGtleXNUb0ludmFsaWRhdGUgPSBpdGVtc0luTG9jYXRpb24ubWFwKChpdGVtKSA9PiBpdGVtLmtleSk7XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXNUb0ludmFsaWRhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgcXVlcnkgcmVzdWx0IHRvIHNpemUgdHJhY2tpbmdcbiAgICovXG4gIGFkZFF1ZXJ5UmVzdWx0VG9TaXplVHJhY2tpbmcocXVlcnlIYXNoLCBlbnRyeSkge1xuICAgIGNvbnN0IGhhc2hTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUocXVlcnlIYXNoKTtcbiAgICBjb25zdCBpdGVtS2V5c1NpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZShlbnRyeS5pdGVtS2V5cyk7XG4gICAgY29uc3QgdG90YWxTaXplID0gaGFzaFNpemUgKyBpdGVtS2V5c1NpemU7XG4gICAgdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemUgKz0gdG90YWxTaXplO1xuICAgIGxvZ2dlcjE2LnRyYWNlKFwiQWRkZWQgcXVlcnkgcmVzdWx0IHRvIHNpemUgdHJhY2tpbmdcIiwge1xuICAgICAgcXVlcnlIYXNoLFxuICAgICAgZXN0aW1hdGVkU2l6ZTogdG90YWxTaXplLFxuICAgICAgdG90YWxRdWVyeUNhY2hlU2l6ZTogdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHF1ZXJ5IHJlc3VsdCBmcm9tIHNpemUgdHJhY2tpbmdcbiAgICovXG4gIHJlbW92ZVF1ZXJ5UmVzdWx0RnJvbVNpemVUcmFja2luZyhxdWVyeUhhc2gpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVlcnlSZXN1bHRDYWNoZVtxdWVyeUhhc2hdO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgY29uc3QgaGFzaFNpemUgPSBlc3RpbWF0ZVZhbHVlU2l6ZShxdWVyeUhhc2gpO1xuICAgICAgY29uc3QgaXRlbUtleXNTaXplID0gZXN0aW1hdGVWYWx1ZVNpemUoZW50cnkuaXRlbUtleXMpO1xuICAgICAgY29uc3QgdG90YWxTaXplID0gaGFzaFNpemUgKyBpdGVtS2V5c1NpemU7XG4gICAgICB0aGlzLnF1ZXJ5UmVzdWx0c0NhY2hlU2l6ZSA9IE1hdGgubWF4KDAsIHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplIC0gdG90YWxTaXplKTtcbiAgICAgIGxvZ2dlcjE2LnRyYWNlKFwiUmVtb3ZlZCBxdWVyeSByZXN1bHQgZnJvbSBzaXplIHRyYWNraW5nXCIsIHtcbiAgICAgICAgcXVlcnlIYXNoLFxuICAgICAgICBlc3RpbWF0ZWRTaXplOiB0b3RhbFNpemUsXG4gICAgICAgIHRvdGFsUXVlcnlDYWNoZVNpemU6IHRoaXMucXVlcnlSZXN1bHRzQ2FjaGVTaXplXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0b3RhbCBjYWNoZSBzaXplIGluY2x1ZGluZyBxdWVyeSByZXN1bHRzXG4gICAqL1xuICBnZXRUb3RhbFNpemVCeXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U2l6ZUJ5dGVzICsgdGhpcy5xdWVyeVJlc3VsdHNDYWNoZVNpemU7XG4gIH1cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIGdldE1ldGFkYXRhKGtleSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBba2V5XTtcbiAgICBpZiAoZW50cnkgJiYgIWVudHJ5Lm1ldGFkYXRhQ2xlYXJlZCkge1xuICAgICAgcmV0dXJuIGVudHJ5Lm1ldGFkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcFtrZXldO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgIGVudHJ5Lm1ldGFkYXRhQ2xlYXJlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb3JpZ2luYWxLZXk7XG4gICAgICB0cnkge1xuICAgICAgICBvcmlnaW5hbEtleSA9IEpTT04ucGFyc2Uoa2V5KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBvcmlnaW5hbEtleSA9IHsga3Q6IFwibWV0YWRhdGEtb25seVwiLCBwazoga2V5IH07XG4gICAgICB9XG4gICAgICB0aGlzLm1hcFtrZXldID0ge1xuICAgICAgICBvcmlnaW5hbEtleSxcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIC8vIFBsYWNlaG9sZGVyIHZhbHVlXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBtZXRhZGF0YUNsZWFyZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBkZWxldGVNZXRhZGF0YShfa2V5KSB7XG4gIH1cbiAgZ2V0QWxsTWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2hhc2hlZEtleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubWFwKSkge1xuICAgICAgaWYgKCFlbnRyeS5tZXRhZGF0YUNsZWFyZWQpIHtcbiAgICAgICAgbWV0YWRhdGEuc2V0KGhhc2hlZEtleSwgZW50cnkubWV0YWRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cbiAgY2xlYXJNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBrZXlzVG9SZW1vdmUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtoYXNoZWRLZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm1hcCkpIHtcbiAgICAgIGlmIChlbnRyeS52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChoYXNoZWRLZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkubWV0YWRhdGFDbGVhcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c1RvUmVtb3ZlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBba2V5XTtcbiAgICB9XG4gIH1cbiAgZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1Db3VudDogdGhpcy5jdXJyZW50SXRlbUNvdW50LFxuICAgICAgc2l6ZUJ5dGVzOiB0aGlzLmN1cnJlbnRTaXplQnl0ZXNcbiAgICB9O1xuICB9XG4gIGdldFNpemVMaW1pdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEl0ZW1zOiB0aGlzLm1heEl0ZW1zID8/IG51bGwsXG4gICAgICBtYXhTaXplQnl0ZXM6IHRoaXMubWF4U2l6ZUJ5dGVzID8/IG51bGxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvYnJvd3Nlci9Mb2NhbFN0b3JhZ2VDYWNoZU1hcC50c1xuaW1wb3J0IHtcbiAgaXNDb21LZXkgYXMgaXNDb21LZXkzLFxuICBpc1F1ZXJ5TWF0Y2ggYXMgaXNRdWVyeU1hdGNoM1xufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbnZhciBsb2dnZXIxNyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkxvY2FsU3RvcmFnZUNhY2hlTWFwXCIpO1xudmFyIExvY2FsU3RvcmFnZUNhY2hlTWFwID0gY2xhc3MgX0xvY2FsU3RvcmFnZUNhY2hlTWFwIGV4dGVuZHMgQ2FjaGVNYXAge1xuICBpbXBsZW1lbnRhdGlvblR5cGUgPSBcImJyb3dzZXIvbG9jYWxTdG9yYWdlXCI7XG4gIGtleVByZWZpeDtcbiAgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjtcbiAgTUFYX1JFVFJZX0FUVEVNUFRTID0gMztcbiAgQUdHUkVTU0lWRV9DTEVBTlVQX1BFUkNFTlRBR0UgPSAwLjU7XG4gIC8vIFJlbW92ZSA1MCUgb2YgZW50cmllcyB3aGVuIHF1b3RhIGV4Y2VlZGVkXG4gIGNvbnN0cnVjdG9yKHR5cGVzLCBrZXlQcmVmaXggPSBcImZqZWxsLWNhY2hlXCIpIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbigpO1xuICB9XG4gIGdldFN0b3JhZ2VLZXkoa2V5KSB7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgcmV0dXJuIGAke3RoaXMua2V5UHJlZml4fToke2hhc2hlZEtleX1gO1xuICB9XG4gIGlzUXVvdGFFeGNlZWRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yICYmIChlcnJvci5uYW1lID09PSBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRURcIiB8fCBlcnJvci5jb2RlID09PSAyMiB8fCBlcnJvci5jb2RlID09PSAxMDE0KTtcbiAgfVxuICBnZXRBbGxLZXlzU3RhcnRpbmdXaXRoKHByZWZpeCkge1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIGdldHRpbmcga2V5cyBieSBwcmVmaXggZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBwcmVmaXgsIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHRyeUNsZWFudXBPbGRFbnRyaWVzKGFnZ3Jlc3NpdmUgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhbGxFbnRyaWVzID0gdGhpcy5jb2xsZWN0Q2FjaGVFbnRyaWVzKCk7XG4gICAgICBpZiAoYWxsRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nZ2VyMTcuZGVidWcoXCJObyBlbnRyaWVzIHRvIGNsZWFuIHVwXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVPbGRlc3RFbnRyaWVzKGFsbEVudHJpZXMsIGFnZ3Jlc3NpdmUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byBjbGVhbnVwIG9sZCBsb2NhbFN0b3JhZ2UgZW50cmllc1wiLCB7IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjb2xsZWN0Q2FjaGVFbnRyaWVzKCkge1xuICAgIGNvbnN0IGFsbEVudHJpZXMgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmIChrZXkuaW5jbHVkZXMoXCI6bWV0YWRhdGE6XCIpIHx8IGtleS5pbmNsdWRlcyhcIjpxdWVyeTpcIikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gXCJvYmplY3RcIiAmJiBcIm9yaWdpbmFsS2V5XCIgaW4gcGFyc2VkKSB7XG4gICAgICAgICAgICBhbGxFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogcGFyc2VkLnRpbWVzdGFtcCB8fCBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBzaXplOiBzdG9yZWQubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxsRW50cmllcy5wdXNoKHsga2V5LCB0aW1lc3RhbXA6IDAsIHNpemU6IHN0b3JlZC5sZW5ndGggfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIxNy5kZWJ1ZyhcIkZvdW5kIGNvcnJ1cHRlZCBlbnRyeSBkdXJpbmcgY2xlYW51cFwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgIGFsbEVudHJpZXMucHVzaCh7IGtleSwgdGltZXN0YW1wOiAwLCBzaXplOiAwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsRW50cmllcztcbiAgfVxuICByZW1vdmVPbGRlc3RFbnRyaWVzKGFsbEVudHJpZXMsIGFnZ3Jlc3NpdmUgPSBmYWxzZSkge1xuICAgIGFsbEVudHJpZXMuc29ydCgoYSwgYikgPT4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcCk7XG4gICAgY29uc3QgY2xlYW51cFBlcmNlbnRhZ2UgPSBhZ2dyZXNzaXZlID8gdGhpcy5BR0dSRVNTSVZFX0NMRUFOVVBfUEVSQ0VOVEFHRSA6IDAuMjU7XG4gICAgY29uc3QgdG9SZW1vdmUgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoYWxsRW50cmllcy5sZW5ndGggKiBjbGVhbnVwUGVyY2VudGFnZSkpO1xuICAgIGxldCByZW1vdmVkQ291bnQgPSAwO1xuICAgIGxldCByZW1vdmVkU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JlbW92ZSAmJiBpIDwgYWxsRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qga2V5ID0gYWxsRW50cmllc1tpXS5rZXk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJlbW92ZWRDb3VudCsrO1xuICAgICAgICByZW1vdmVkU2l6ZSArPSBhbGxFbnRyaWVzW2ldLnNpemU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byByZW1vdmUgZW50cnkgZHVyaW5nIGNsZWFudXBcIiwgeyBrZXk6IGFsbEVudHJpZXNbaV0ua2V5LCBlcnJvciB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92ZWRDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IGNsZWFudXBUeXBlID0gYWdncmVzc2l2ZSA/IFwiYWdncmVzc2l2ZVwiIDogXCJub3JtYWxcIjtcbiAgICAgIGxvZ2dlcjE3LmluZm8oYENsZWFuZWQgdXAgJHtyZW1vdmVkQ291bnR9IG9sZCBsb2NhbFN0b3JhZ2UgZW50cmllcyAoJHtyZW1vdmVkU2l6ZX0gYnl0ZXMpIHVzaW5nICR7Y2xlYW51cFR5cGV9IGNsZWFudXAgdG8gZnJlZSBzcGFjZWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZENvdW50ID4gMDtcbiAgfVxuICBnZXRBbGxTdG9yYWdlS2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGxLZXlzU3RhcnRpbmdXaXRoKGAke3RoaXMua2V5UHJlZml4fTpgKTtcbiAgfVxuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgbG9nZ2VyMTcudHJhY2UoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGxldCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmICghc3RvcmVkICYmIHR5cGVvZiBrZXk/Lmt0ID09PSBcInN0cmluZ1wiICYmIGtleT8ucGspIHtcbiAgICAgICAgY29uc3QgbGVnYWN5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OiR7a2V5Lmt0fToke2tleS5wa31gO1xuICAgICAgICBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsZWdhY3lLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBpZiAodGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSkgPT09IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE3LmRlYnVnKFwiRmFpbGVkIHRvIHBhcnNlIHN0b3JlZCB2YWx1ZVwiLCB7IGtleSwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIHJldHJpZXZpbmcgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgbG9nZ2VyMTcudHJhY2UoXCJzZXRcIiwgeyBrZXksIHZhbHVlIH0pO1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgdGhpcy5NQVhfUkVUUllfQVRURU1QVFM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgICBjb25zdCB0b1N0b3JlID0ge1xuICAgICAgICAgIG9yaWdpbmFsS2V5OiBrZXksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHRvU3RvcmUpKTtcbiAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgbG9nZ2VyMTcuaW5mbyhgU3VjY2Vzc2Z1bGx5IHN0b3JlZCBpdGVtIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdEF0dGVtcHQgPSBhdHRlbXB0ID09PSB0aGlzLk1BWF9SRVRSWV9BVFRFTVBUUyAtIDE7XG4gICAgICAgIGxvZ2dlcjE3LmVycm9yKGBFcnJvciBzdG9yaW5nIHRvIGxvY2FsU3RvcmFnZSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke3RoaXMuTUFYX1JFVFJZX0FUVEVNUFRTfSlgLCB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGlzTGFzdEF0dGVtcHRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlzUXVvdGFFeGNlZWRlZEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIGNvbnN0IHVzZUFnZ3Jlc3NpdmVDbGVhbnVwID0gYXR0ZW1wdCA+IDA7XG4gICAgICAgICAgdGhpcy50cnlDbGVhbnVwT2xkRW50cmllcyh1c2VBZ2dyZXNzaXZlQ2xlYW51cCk7XG4gICAgICAgICAgaWYgKGlzTGFzdEF0dGVtcHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzdG9yZSBpdGVtIGluIGxvY2FsU3RvcmFnZTogc3RvcmFnZSBxdW90YSBleGNlZWRlZCBldmVuIGFmdGVyIG11bHRpcGxlIGNsZWFudXAgYXR0ZW1wdHNcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN0b3JlIGl0ZW0gaW4gbG9jYWxTdG9yYWdlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5jbHVkZXNLZXkoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSkgPT09IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyMTcuZGVidWcoXCJGYWlsZWQgdG8gcGFyc2Ugc3RvcmVkIHZhbHVlIGluIGluY2x1ZGVzS2V5XCIsIHsga2V5LCBlcnJvcjogcGFyc2VFcnJvciB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBjaGVja2luZyBrZXkgaW4gbG9jYWxTdG9yYWdlXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIGxvZ2dlcjE3LnRyYWNlKFwiZGVsZXRlXCIsIHsga2V5IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBkZWxldGluZyBmcm9tIGxvY2FsU3RvcmFnZVwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWxsSW4obG9jYXRpb25zKSB7XG4gICAgY29uc3QgYWxsS2V5cyA9IHRoaXMua2V5cygpO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIxNy5kZWJ1ZyhcIlJldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHlcIik7XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvY0tleXMgPSBsb2NhdGlvbnM7XG4gICAgICBsb2dnZXIxNy5kZWJ1ZyhcImFsbEluXCIsIHsgbG9jS2V5cywga2V5czogYWxsS2V5cy5sZW5ndGggfSk7XG4gICAgICBjb25zdCBmaWx0ZXJlZEtleXMgPSBhbGxLZXlzLmZpbHRlcigoa2V5KSA9PiBrZXkgJiYgaXNDb21LZXkzKGtleSkpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IENvbUtleTEyID0ga2V5O1xuICAgICAgICBsb2dnZXIxNy5kZWJ1ZyhcIkNvbXBhcmluZyBMb2NhdGlvbiBLZXlzXCIsIHtcbiAgICAgICAgICBsb2NLZXlzLFxuICAgICAgICAgIENvbUtleTogQ29tS2V5MTJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jS2V5cywgQ29tS2V5MTIubG9jKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZpbHRlcmVkS2V5cykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5LCBsb2NhdGlvbnMpIHtcbiAgICBsb2dnZXIxNy5kZWJ1ZyhcImNvbnRhaW5zXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXNRdWVyeU1hdGNoMyhpdGVtLCBxdWVyeSkpO1xuICB9XG4gIGFzeW5jIHF1ZXJ5SW4ocXVlcnksIGxvY2F0aW9ucyA9IFtdKSB7XG4gICAgbG9nZ2VyMTcuZGVidWcoXCJxdWVyeUluXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2gzKGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cbiAgYXN5bmMgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTG9jYWxTdG9yYWdlQ2FjaGVNYXAodGhpcy50eXBlcywgdGhpcy5rZXlQcmVmaXgpO1xuICB9XG4gIHBhcnNlU3RvcmFnZUVudHJ5KHN0b3JhZ2VLZXkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZGVidWcoXCJTa2lwcGluZyBjb3JydXB0ZWQgbG9jYWxTdG9yYWdlIGVudHJ5XCIsIHsgc3RvcmFnZUtleSwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGtleXMoKSB7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qgc3RvcmFnZUtleSBvZiBzdG9yYWdlS2V5cykge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlU3RvcmFnZUVudHJ5KHN0b3JhZ2VLZXkpO1xuICAgICAgICBpZiAocGFyc2VkPy5vcmlnaW5hbEtleSkge1xuICAgICAgICAgIGtleXMucHVzaChwYXJzZWQub3JpZ2luYWxLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBrZXlzIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIGFzeW5jIHZhbHVlcygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVN0b3JhZ2VFbnRyeShzdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKHBhcnNlZD8udmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICBsb2dnZXIxNy5kZWJ1ZyhcIkNsZWFyaW5nIGxvY2FsU3RvcmFnZSBjYWNoZVwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgY2xlYXJpbmcgbG9jYWxTdG9yYWdlIGNhY2hlXCIsIHsgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgLy8gUXVlcnkgcmVzdWx0IGNhY2hpbmcgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuICBzZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGl0ZW1LZXlzKSB7XG4gICAgbG9nZ2VyMTcudHJhY2UoXCJzZXRRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgaXRlbUtleXMgfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGl0ZW1LZXlzXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0ocXVlcnlLZXksIEpTT04uc3RyaW5naWZ5KGVudHJ5KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRmFpbGVkIHRvIHN0b3JlIHF1ZXJ5IHJlc3VsdCBpbiBsb2NhbFN0b3JhZ2VcIiwgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxNy50cmFjZShcImdldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShxdWVyeUtleSk7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBlbnRyeSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5Lml0ZW1LZXlzIHx8IG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRmFpbGVkIHRvIHJldHJpZXZlIHF1ZXJ5IHJlc3VsdCBmcm9tIGxvY2FsU3RvcmFnZVwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHF1ZXJ5S2V5KSAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJGYWlsZWQgdG8gY2hlY2sgcXVlcnkgcmVzdWx0IGluIGxvY2FsU3RvcmFnZVwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGRlbGV0ZVF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGxvZ2dlcjE3LnRyYWNlKFwiZGVsZXRlUXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocXVlcnlLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byBkZWxldGUgcXVlcnkgcmVzdWx0IGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXMpIHtcbiAgICBsb2dnZXIxNy5kZWJ1ZyhcImludmFsaWRhdGVJdGVtS2V5c1wiLCB7IGtleXMgfSk7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIxNy5lcnJvcihcIkZhaWxlZCB0byBkZWxldGUga2V5IGR1cmluZyBpbnZhbGlkYXRpb25cIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGludmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbnMpIHtcbiAgICBsb2dnZXIxNy5kZWJ1ZyhcImludmFsaWRhdGVMb2NhdGlvblwiLCB7IGxvY2F0aW9ucyB9KTtcbiAgICB0cnkge1xuICAgICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgYWxsS2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IGFsbEtleXMuZmlsdGVyKChrZXkpID0+ICFpc0NvbUtleTMoa2V5KSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKHByaW1hcnlLZXlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleXNUb0ludmFsaWRhdGUgPSB0aGlzLmtleXMoKS5maWx0ZXIoKGtleSkgPT4ga2V5ICYmIGlzQ29tS2V5MyhrZXkpKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZUtleSA9IGtleTtcbiAgICAgICAgICByZXR1cm4gaXNMb2NLZXlBcnJheUVxdWFsKGxvY2F0aW9ucywgY29tcG9zaXRlS2V5LmxvYyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzVG9JbnZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJRdWVyeVJlc3VsdHMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBpbiBpbnZhbGlkYXRlTG9jYXRpb25cIiwgeyBsb2NhdGlvbnMsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICBjbGVhclF1ZXJ5UmVzdWx0cygpIHtcbiAgICBsb2dnZXIxNy50cmFjZShcImNsZWFyUXVlcnlSZXN1bHRzXCIpO1xuICAgIGNvbnN0IHF1ZXJ5UHJlZml4ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OmA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXNUb1JlbW92ZSA9IHRoaXMuZ2V0QWxsS2V5c1N0YXJ0aW5nV2l0aChxdWVyeVByZWZpeCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRmFpbGVkIHRvIHJlbW92ZSBxdWVyeSByZXN1bHQgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRmFpbGVkIHRvIGNsZWFyIHF1ZXJ5IHJlc3VsdHMgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIGdldE1ldGFkYXRhKGtleSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YToke2tleX1gO1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWV0YWRhdGFLZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIxNy5kZWJ1ZyhcIkludmFsaWQgbWV0YWRhdGEgSlNPTiwgdHJlYXRpbmcgYXMgbnVsbFwiLCB7IGtleSwgZXJyb3I6IGUgfSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIGdldHRpbmcgbWV0YWRhdGEgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpIHtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHRoaXMuTUFYX1JFVFJZX0FUVEVNUFRTOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1ldGFkYXRhS2V5LCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICBsb2dnZXIxNy5pbmZvKGBTdWNjZXNzZnVsbHkgc3RvcmVkIG1ldGFkYXRhIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdEF0dGVtcHQgPSBhdHRlbXB0ID09PSB0aGlzLk1BWF9SRVRSWV9BVFRFTVBUUyAtIDE7XG4gICAgICAgIGxvZ2dlcjE3LmVycm9yKGBFcnJvciBzdG9yaW5nIG1ldGFkYXRhIHRvIGxvY2FsU3RvcmFnZSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke3RoaXMuTUFYX1JFVFJZX0FUVEVNUFRTfSlgLCB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGlzTGFzdEF0dGVtcHRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlzUXVvdGFFeGNlZWRlZEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIGNvbnN0IHVzZUFnZ3Jlc3NpdmVDbGVhbnVwID0gYXR0ZW1wdCA+IDA7XG4gICAgICAgICAgdGhpcy50cnlDbGVhbnVwT2xkRW50cmllcyh1c2VBZ2dyZXNzaXZlQ2xlYW51cCk7XG4gICAgICAgICAgaWYgKGlzTGFzdEF0dGVtcHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzdG9yZSBtZXRhZGF0YSBpbiBsb2NhbFN0b3JhZ2U6IHN0b3JhZ2UgcXVvdGEgZXhjZWVkZWQgZXZlbiBhZnRlciBtdWx0aXBsZSBjbGVhbnVwIGF0dGVtcHRzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdG9yZSBtZXRhZGF0YSBpbiBsb2NhbFN0b3JhZ2U6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWxldGVNZXRhZGF0YShrZXkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG1ldGFkYXRhS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBkZWxldGluZyBtZXRhZGF0YSBmcm9tIGxvY2FsU3RvcmFnZVwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgZ2V0QWxsTWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuICAgICAgY29uc3QgbWV0YUtleXMgPSB0aGlzLmdldEFsbEtleXNTdGFydGluZ1dpdGgobWV0YWRhdGFQcmVmaXgpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgbWV0YUtleXMpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBrZXkuc3Vic3RyaW5nKG1ldGFkYXRhUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghc3RvcmVkKSBjb250aW51ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgaWYgKHBhcnNlZCAmJiB0eXBlb2YgcGFyc2VkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5zZXQobWV0YWRhdGFLZXksIHBhcnNlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE3LmRlYnVnKFwiU2tpcHBpbmcgaW52YWxpZCBtZXRhZGF0YSBlbnRyeVwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTcuZXJyb3IoXCJFcnJvciBnZXR0aW5nIG1ldGFkYXRhIGZyb20gbG9jYWxTdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG4gIGNsZWFyTWV0YWRhdGEoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhUHJlZml4ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOmA7XG4gICAgICBjb25zdCBrZXlzVG9EZWxldGUgPSB0aGlzLmdldEFsbEtleXNTdGFydGluZ1dpdGgobWV0YWRhdGFQcmVmaXgpO1xuICAgICAga2V5c1RvRGVsZXRlLmZvckVhY2goKGtleSkgPT4gbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE3LmVycm9yKFwiRXJyb3IgY2xlYXJpbmcgbWV0YWRhdGEgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBnZXRDdXJyZW50U2l6ZSgpIHtcbiAgICBsZXQgaXRlbUNvdW50ID0gMDtcbiAgICBsZXQgc2l6ZUJ5dGVzID0gMDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXZhbHVlKSBjb250aW51ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHNpemVCeXRlcyArPSBuZXcgQmxvYihbdmFsdWVdKS5zaXplO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBzaXplQnl0ZXMgKz0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5CdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHNpemVCeXRlcyArPSBnbG9iYWxUaGlzLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBcInV0ZjhcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemVCeXRlcyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha2V5LmluY2x1ZGVzKFwiOm1ldGFkYXRhOlwiKSAmJiAha2V5LmluY2x1ZGVzKFwiOnF1ZXJ5OlwiKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gXCJvYmplY3RcIiAmJiBcIm9yaWdpbmFsS2V5XCIgaW4gcGFyc2VkICYmIFwidmFsdWVcIiBpbiBwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyMTcuZGVidWcoXCJJbnZhbGlkIGVudHJ5IGluIGdldEN1cnJlbnRTaXplXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyMTcuZGVidWcoXCJTaXplIGNhbGN1bGF0aW9uIGZhaWxlZCwgdXNpbmcgc3RyaW5nIGxlbmd0aFwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgICAgICAgc2l6ZUJ5dGVzICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxNy5lcnJvcihcIkVycm9yIGNhbGN1bGF0aW5nIHNpemUgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4geyBpdGVtQ291bnQsIHNpemVCeXRlcyB9O1xuICB9XG4gIGdldFNpemVMaW1pdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEl0ZW1zOiBudWxsLFxuICAgICAgLy8gTm8gc3BlY2lmaWMgaXRlbSBsaW1pdFxuICAgICAgbWF4U2l6ZUJ5dGVzOiA1ICogMTAyNCAqIDEwMjRcbiAgICAgIC8vIDVNQiBjb25zZXJ2YXRpdmUgZXN0aW1hdGVcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvYnJvd3Nlci9TZXNzaW9uU3RvcmFnZUNhY2hlTWFwLnRzXG5pbXBvcnQge1xuICBpc0NvbUtleSBhcyBpc0NvbUtleTQsXG4gIGlzUXVlcnlNYXRjaCBhcyBpc1F1ZXJ5TWF0Y2g0XG59IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHNhZmVTdHJpbmdpZnkyIGZyb20gXCJmYXN0LXNhZmUtc3RyaW5naWZ5XCI7XG52YXIgbG9nZ2VyMTggPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJTZXNzaW9uU3RvcmFnZUNhY2hlTWFwXCIpO1xudmFyIFNlc3Npb25TdG9yYWdlQ2FjaGVNYXAgPSBjbGFzcyBfU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcCBleHRlbmRzIENhY2hlTWFwIHtcbiAgaW1wbGVtZW50YXRpb25UeXBlID0gXCJicm93c2VyL3Nlc3Npb25TdG9yYWdlXCI7XG4gIGtleVByZWZpeDtcbiAgbm9ybWFsaXplZEhhc2hGdW5jdGlvbjtcbiAgLy8gVXNlIGEgc2VwYXJhdGUsIHByaXZhdGUgdmVyaWZpZXIgdGhhdCBpcyBub3QgcmVmZXJlbmNlZCBieSB0ZXN0cyB0byBndWFyZCBhZ2FpbnN0IHRhbXBlcmluZ1xuICB2ZXJpZmljYXRpb25IYXNoRnVuY3Rpb247XG4gIGNvbnN0cnVjdG9yKHR5cGVzLCBrZXlQcmVmaXggPSBcImZqZWxsLXNlc3Npb24tY2FjaGVcIikge1xuICAgIHN1cGVyKHR5cGVzKTtcbiAgICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uKCk7XG4gICAgdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemVkSGFzaEZ1bmN0aW9uKCk7XG4gIH1cbiAgZ2V0U3RvcmFnZUtleShrZXkpIHtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICByZXR1cm4gYCR7dGhpcy5rZXlQcmVmaXh9OiR7aGFzaGVkS2V5fWA7XG4gIH1cbiAgLy8gVXNpbmcgZmxhdHRlZCBmb3Igc2FmZSBjaXJjdWxhciBzZXJpYWxpemF0aW9uOyBubyBtYW51YWwgcmVwbGFjZXIgbmVlZGVkXG4gIGdldEFsbFN0b3JhZ2VLZXlzKCkge1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXNzaW9uU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzZXNzaW9uU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoYCR7dGhpcy5rZXlQcmVmaXh9OmApKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJFcnJvciBnZXR0aW5nIGtleXMgZnJvbSBzZXNzaW9uU3RvcmFnZVwiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICAvLyBEZXRlY3QgaWYgY3VycmVudCBub3JtYWxpemVkIGhhc2ggZnVuY3Rpb24gY29sbGFwc2VzIG11bHRpcGxlIHN0b3JlZCBpdGVtcyBpbnRvIHRoZSBzYW1lIGhhc2hcbiAgaGFzQ29sbGlzaW9uRm9ySGFzaCh0YXJnZXRIYXNoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06JHt0YXJnZXRIYXNofWA7XG4gICAgICBjb25zdCByYXcgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKCFyYXcpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgIGlmICghcGFyc2VkPy5vcmlnaW5hbEtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3Qgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9IHBhcnNlZC5vcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2g7XG4gICAgICBjb25zdCBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaCA9IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSk7XG4gICAgICBpZiAoc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICBsb2dnZXIxOC50cmFjZShcImdldFwiLCB7IGtleSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudEhhc2ggPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgIGlmICh0aGlzLmhhc0NvbGxpc2lvbkZvckhhc2goY3VycmVudEhhc2gpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IHRoaXMuZ2V0U3RvcmFnZUtleShrZXkpO1xuICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICBjb25zdCBzdG9yZWRWZXJpZmljYXRpb25IYXNoID0gcGFyc2VkLm9yaWdpbmFsVmVyaWZpY2F0aW9uSGFzaDtcbiAgICAgICAgY29uc3QgY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggPSB0aGlzLnZlcmlmaWNhdGlvbkhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgICBjb25zdCBpc1NhbWVPcmlnaW5hbEtleSA9IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKHBhcnNlZC5vcmlnaW5hbEtleSkgPT09IGN1cnJlbnRWZXJpZmljYXRpb25IYXNoO1xuICAgICAgICBpZiAoc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCAmJiBzdG9yZWRWZXJpZmljYXRpb25IYXNoID09PSBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaCAmJiBpc1NhbWVPcmlnaW5hbEtleSkge1xuICAgICAgICAgIGlmIChwYXJzZWQudmFsdWUgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBmcm9tIHNlc3Npb25TdG9yYWdlXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBsb2dnZXIxOC50cmFjZShcInNldFwiLCB7IHN0b3JhZ2VLZXkgfSk7XG4gICAgICBjb25zdCB0b1N0b3JlID0ge1xuICAgICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBvcmlnaW5hbFZlcmlmaWNhdGlvbkhhc2g6IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKGtleSlcbiAgICAgIH07XG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gc2FmZVN0cmluZ2lmeTIodG9TdG9yZSk7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIGpzb25TdHJpbmcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkVycm9yIHN0b3JpbmcgdG8gc2Vzc2lvblN0b3JhZ2VcIiwgeyBlcnJvck1lc3NhZ2U6IGVycm9yPy5tZXNzYWdlIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RvcmUgaXRlbSBpbiBzZXNzaW9uU3RvcmFnZTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5jbHVkZXNLZXkoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRIYXNoID0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICBpZiAodGhpcy5oYXNDb2xsaXNpb25Gb3JIYXNoKGN1cnJlbnRIYXNoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggPSBwYXJzZWQub3JpZ2luYWxWZXJpZmljYXRpb25IYXNoO1xuICAgICAgICBjb25zdCBjdXJyZW50VmVyaWZpY2F0aW9uSGFzaCA9IHRoaXMudmVyaWZpY2F0aW9uSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICAgIGNvbnN0IGlzU2FtZU9yaWdpbmFsS2V5ID0gdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24ocGFyc2VkLm9yaWdpbmFsS2V5KSA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2g7XG4gICAgICAgIHJldHVybiAhIXN0b3JlZFZlcmlmaWNhdGlvbkhhc2ggJiYgc3RvcmVkVmVyaWZpY2F0aW9uSGFzaCA9PT0gY3VycmVudFZlcmlmaWNhdGlvbkhhc2ggJiYgaXNTYW1lT3JpZ2luYWxLZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRXJyb3IgY2hlY2tpbmcga2V5IGluIHNlc3Npb25TdG9yYWdlXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIGxvZ2dlcjE4LnRyYWNlKFwiZGVsZXRlXCIsIHsga2V5IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkVycm9yIGRlbGV0aW5nIGZyb20gc2Vzc2lvblN0b3JhZ2VcIiwgeyBrZXksIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBhbGxJbihsb2NhdGlvbnMpIHtcbiAgICBjb25zdCBhbGxLZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlcjE4LmRlYnVnKFwiUmV0dXJuaW5nIGFsbCBpdGVtcywgTG9jS2V5cyBpcyBlbXB0eVwiKTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG9jS2V5cyA9IGxvY2F0aW9ucztcbiAgICAgIGxvZ2dlcjE4LmRlYnVnKFwiYWxsSW5cIiwgeyBsb2NLZXlzLCBrZXlzOiBhbGxLZXlzLmxlbmd0aCB9KTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkS2V5cyA9IGFsbEtleXMuZmlsdGVyKChrZXkpID0+IGtleSAmJiBpc0NvbUtleTQoa2V5KSkuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgQ29tS2V5MTIgPSBrZXk7XG4gICAgICAgIGxvZ2dlcjE4LmRlYnVnKFwiQ29tcGFyaW5nIExvY2F0aW9uIEtleXNcIiwge1xuICAgICAgICAgIGxvY0tleXMsXG4gICAgICAgICAgQ29tS2V5OiBDb21LZXkxMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzTG9jS2V5QXJyYXlFcXVhbChsb2NLZXlzLCBDb21LZXkxMi5sb2MpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgZmlsdGVyZWRLZXlzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29udGFpbnMocXVlcnksIGxvY2F0aW9ucykge1xuICAgIGxvZ2dlcjE4LmRlYnVnKFwiY29udGFpbnNcIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5zb21lKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2g0KGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cbiAgYXN5bmMgcXVlcnlJbihxdWVyeSwgbG9jYXRpb25zID0gW10pIHtcbiAgICBsb2dnZXIxOC5kZWJ1ZyhcInF1ZXJ5SW5cIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGlzUXVlcnlNYXRjaDQoaXRlbSwgcXVlcnkpKTtcbiAgfVxuICBhc3luYyBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9TZXNzaW9uU3RvcmFnZUNhY2hlTWFwKHRoaXMudHlwZXMsIHRoaXMua2V5UHJlZml4KTtcbiAgfVxuICBrZXlzKCkge1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKCFzdG9yZWQpIGNvbnRpbnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICBpZiAocGFyc2VkLm9yaWdpbmFsS2V5KSB7XG4gICAgICAgICAgICBrZXlzLnB1c2gocGFyc2VkLm9yaWdpbmFsS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGl0ZW1FcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE4LnRyYWNlKFwiU2tpcHBpbmcgaW52YWxpZCBzdG9yYWdlIGl0ZW1cIiwgeyBzdG9yYWdlS2V5LCBlcnJvcjogaXRlbUVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBrZXlzIGZyb20gc2Vzc2lvblN0b3JhZ2VcIiwgeyBlcnJvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgYXN5bmMgdmFsdWVzKCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHRoaXMuZ2V0QWxsU3RvcmFnZUtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qgc3RvcmFnZUtleSBvZiBzdG9yYWdlS2V5cykge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICBpZiAoIXN0b3JlZCkgY29udGludWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgIGlmIChwYXJzZWQudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGl0ZW1FcnJvcikge1xuICAgICAgICAgIGxvZ2dlcjE4LnRyYWNlKFwiU2tpcHBpbmcgaW52YWxpZCBzdG9yYWdlIGl0ZW0gZm9yIHZhbHVlc1wiLCB7IHN0b3JhZ2VLZXksIGVycm9yOiBpdGVtRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJFcnJvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHNlc3Npb25TdG9yYWdlXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgbG9nZ2VyMTguZGVidWcoXCJDbGVhcmluZyBzZXNzaW9uU3RvcmFnZSBjYWNoZVwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB0aGlzLmdldEFsbFN0b3JhZ2VLZXlzKCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3JhZ2VLZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTguZXJyb3IoXCJFcnJvciBjbGVhcmluZyBzZXNzaW9uU3RvcmFnZSBjYWNoZVwiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzIGltcGxlbWVudGF0aW9uXG4gIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpIHtcbiAgICBsb2dnZXIxOC50cmFjZShcInNldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBpdGVtS2V5cyB9KTtcbiAgICBjb25zdCBxdWVyeUtleSA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgaXRlbUtleXNcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gc2FmZVN0cmluZ2lmeTIoZW50cnkpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShxdWVyeUtleSwganNvblN0cmluZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRmFpbGVkIHRvIHN0b3JlIHF1ZXJ5IHJlc3VsdCBpbiBzZXNzaW9uU3RvcmFnZVwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIGxvZ2dlcjE4LnRyYWNlKFwiZ2V0UXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2ggfSk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0ocXVlcnlLZXkpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgZW50cnkgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeS5pdGVtS2V5cyB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSBxdWVyeSByZXN1bHQgZnJvbSBzZXNzaW9uU3RvcmFnZVwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaGFzUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06cXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0ocXVlcnlLZXkpICE9PSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkZhaWxlZCB0byBjaGVjayBxdWVyeSByZXN1bHQgaW4gc2Vzc2lvblN0b3JhZ2VcIiwgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBkZWxldGVRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxOC50cmFjZShcImRlbGV0ZVF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9OnF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgdHJ5IHtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0ocXVlcnlLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOC5lcnJvcihcIkZhaWxlZCB0byBkZWxldGUgcXVlcnkgcmVzdWx0IGZyb20gc2Vzc2lvblN0b3JhZ2VcIiwgeyBxdWVyeUhhc2gsIGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICBpbnZhbGlkYXRlSXRlbUtleXMoa2V5cykge1xuICAgIGxvZ2dlcjE4LmRlYnVnKFwiaW52YWxpZGF0ZUl0ZW1LZXlzXCIsIHsga2V5cyB9KTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTguZGVidWcoXCJpbnZhbGlkYXRlTG9jYXRpb25cIiwgeyBsb2NhdGlvbnMgfSk7XG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGFsbEtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgIGNvbnN0IHByaW1hcnlLZXlzID0gYWxsS2V5cy5maWx0ZXIoKGtleSkgPT4gIWlzQ29tS2V5NChrZXkpKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKHByaW1hcnlLZXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXRlbXNJbkxvY2F0aW9uID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgICAgY29uc3Qga2V5c1RvSW52YWxpZGF0ZSA9IGl0ZW1zSW5Mb2NhdGlvbi5tYXAoKGl0ZW0pID0+IGl0ZW0ua2V5KTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXNUb0ludmFsaWRhdGUpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gIH1cbiAgY2xlYXJRdWVyeVJlc3VsdHMoKSB7XG4gICAgbG9nZ2VyMTgudHJhY2UoXCJjbGVhclF1ZXJ5UmVzdWx0c1wiKTtcbiAgICBjb25zdCBxdWVyeVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTpxdWVyeTpgO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzVG9SZW1vdmUgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vzc2lvblN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc2Vzc2lvblN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKHF1ZXJ5UHJlZml4KSkge1xuICAgICAgICAgIGtleXNUb1JlbW92ZS5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleXNUb1JlbW92ZS5mb3JFYWNoKChrZXkpID0+IHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRmFpbGVkIHRvIGNsZWFyIHF1ZXJ5IHJlc3VsdHMgZnJvbSBzZXNzaW9uU3RvcmFnZVwiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgfVxuICAvLyBDYWNoZU1hcE1ldGFkYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKG1ldGFkYXRhS2V5KTtcbiAgICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGFLZXkgPSBgJHt0aGlzLmtleVByZWZpeH06bWV0YWRhdGE6JHtrZXl9YDtcbiAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBzYWZlU3RyaW5naWZ5MihtZXRhZGF0YSk7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1ldGFkYXRhS2V5LCBqc29uU3RyaW5nKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgZGVsZXRlTWV0YWRhdGEoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOiR7a2V5fWA7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1ldGFkYXRhS2V5KTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgZ2V0QWxsTWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG1ldGFkYXRhUHJlZml4ID0gYCR7dGhpcy5rZXlQcmVmaXh9Om1ldGFkYXRhOmA7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBmb3VuZEFueSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXNzaW9uU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzZXNzaW9uU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgIGlmICgha2V5IHx8ICFrZXkuc3RhcnRzV2l0aChtZXRhZGF0YVByZWZpeCkpIGNvbnRpbnVlO1xuICAgICAgICBmb3VuZEFueSA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhS2V5ID0ga2V5LnN1YnN0cmluZyhtZXRhZGF0YVByZWZpeC5sZW5ndGgpO1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghc3RvcmVkKSBjb250aW51ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXRhZGF0YS5zZXQobWV0YWRhdGFLZXksIEpTT04ucGFyc2Uoc3RvcmVkKSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE4LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBhbGwgbWV0YWRhdGEgZnJvbSBzZXNzaW9uU3RvcmFnZVwiLCB7IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgfVxuICBjbGVhck1ldGFkYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IGAke3RoaXMua2V5UHJlZml4fTptZXRhZGF0YTpgO1xuICAgICAgY29uc3Qga2V5c1RvRGVsZXRlID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb25TdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlc3Npb25TdG9yYWdlLmtleShpKTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChtZXRhZGF0YVByZWZpeCkpIHtcbiAgICAgICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXlzVG9EZWxldGUuZm9yRWFjaCgoa2V5KSA9PiBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBnZXRDdXJyZW50U2l6ZSgpIHtcbiAgICBsZXQgaXRlbUNvdW50ID0gMDtcbiAgICBsZXQgc2l6ZUJ5dGVzID0gMDtcbiAgICB0cnkge1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uua2V5KDApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHsgaXRlbUNvdW50OiAwLCBzaXplQnl0ZXM6IDAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdGhpcy5nZXRBbGxTdG9yYWdlS2V5cygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc3RvcmFnZUtleXMpIHtcbiAgICAgICAgaWYgKCFrZXkuaW5jbHVkZXMoXCI6bWV0YWRhdGE6XCIpICYmICFrZXkuaW5jbHVkZXMoXCI6cXVlcnk6XCIpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICBpZiAocGFyc2VkPy5vcmlnaW5hbEtleSAmJiBwYXJzZWQ/Lm9yaWdpbmFsVmVyaWZpY2F0aW9uSGFzaCA9PT0gdGhpcy52ZXJpZmljYXRpb25IYXNoRnVuY3Rpb24ocGFyc2VkLm9yaWdpbmFsS2V5KSkge1xuICAgICAgICAgICAgICAgIGl0ZW1Db3VudCsrO1xuICAgICAgICAgICAgICAgIHNpemVCeXRlcyArPSBuZXcgQmxvYihbdmFsdWVdKS5zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4geyBpdGVtQ291bnQ6IDAsIHNpemVCeXRlczogMCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBpdGVtQ291bnQsIHNpemVCeXRlcyB9O1xuICB9XG4gIGdldFNpemVMaW1pdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEl0ZW1zOiBudWxsLFxuICAgICAgLy8gTm8gc3BlY2lmaWMgaXRlbSBsaW1pdFxuICAgICAgbWF4U2l6ZUJ5dGVzOiA1ICogMTAyNCAqIDEwMjRcbiAgICAgIC8vIDVNQiBjb25zZXJ2YXRpdmUgZXN0aW1hdGVcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvYnJvd3Nlci9Bc3luY0luZGV4REJDYWNoZU1hcC50c1xuaW1wb3J0IHtcbiAgaXNDb21LZXkgYXMgaXNDb21LZXk1LFxuICBpc1F1ZXJ5TWF0Y2ggYXMgaXNRdWVyeU1hdGNoNVxufSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCBzYWZlU3RyaW5naWZ5MyBmcm9tIFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiO1xudmFyIGxvZ2dlcjE5ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiQXN5bmNJbmRleERCQ2FjaGVNYXBcIik7XG52YXIgQXN5bmNJbmRleERCQ2FjaGVNYXAgPSBjbGFzcyBfQXN5bmNJbmRleERCQ2FjaGVNYXAge1xuICB0eXBlcztcbiAgZGJOYW1lO1xuICBzdG9yZU5hbWU7XG4gIHZlcnNpb247XG4gIG5vcm1hbGl6ZWRIYXNoRnVuY3Rpb247XG4gIGRiUHJvbWlzZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHR5cGVzLCBkYk5hbWUgPSBcImZqZWxsLWluZGV4ZGItY2FjaGVcIiwgc3RvcmVOYW1lID0gXCJjYWNoZVwiLCB2ZXJzaW9uID0gMSkge1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICB0aGlzLmRiTmFtZSA9IGRiTmFtZTtcbiAgICB0aGlzLnN0b3JlTmFtZSA9IHN0b3JlTmFtZTtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oKTtcbiAgfVxuICBhc3luYyBnZXREQigpIHtcbiAgICBpZiAoIXRoaXMuZGJQcm9taXNlKSB7XG4gICAgICB0aGlzLmRiUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBvcGVuaW5nIEluZGV4ZWREQlwiLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZGVidWcoXCJJbmRleGVkREIgb3BlbmVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5kZWJ1ZyhcIkluZGV4ZWREQiB1cGdyYWRlIG5lZWRlZFwiKTtcbiAgICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMuc3RvcmVOYW1lKSkge1xuICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgbG9nZ2VyMTkuZGVidWcoXCJDcmVhdGVkIG9iamVjdCBzdG9yZVwiLCB7IHN0b3JlTmFtZTogdGhpcy5zdG9yZU5hbWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRiUHJvbWlzZTtcbiAgfVxuICBnZXRTdG9yYWdlS2V5KGtleSkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oa2V5KTtcbiAgfVxuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgbG9nZ2VyMTkudHJhY2UoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWRvbmx5XCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KHN0b3JhZ2VLZXkpO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGZyb20gSW5kZXhlZERCXCIsIHsga2V5LCBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGlmIChzdG9yZWQgJiYgdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKHN0b3JlZC5vcmlnaW5hbEtleSkgPT09IHRoaXMubm9ybWFsaXplZEhhc2hGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgICAgICByZXNvbHZlKHN0b3JlZC52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgaW4gSW5kZXhlZERCIGdldCBvcGVyYXRpb25cIiwgeyBrZXksIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldChrZXksIHZhbHVlKSB7XG4gICAgbG9nZ2VyMTkudHJhY2UoXCJzZXRcIiwgeyBrZXksIHZhbHVlIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIGNvbnN0IHN0b3JlZEl0ZW0gPSB7XG4gICAgICAgIG9yaWdpbmFsS2V5OiBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChzdG9yZWRJdGVtLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3Igc2V0dGluZyBpbiBJbmRleGVkREJcIiwgeyBrZXksIHZhbHVlLCBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIEluZGV4ZWREQiBzZXQgb3BlcmF0aW9uXCIsIHsga2V5LCB2YWx1ZSwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdG9yZSBpdGVtIGluIEluZGV4ZWREQjogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5jbHVkZXNLZXkoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWRvbmx5XCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5nZXRTdG9yYWdlS2V5KGtleSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KHN0b3JhZ2VLZXkpO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBjaGVja2luZyBrZXkgaW4gSW5kZXhlZERCXCIsIHsga2V5LCBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24oc3RvcmVkLm9yaWdpbmFsS2V5KSA9PT0gdGhpcy5ub3JtYWxpemVkSGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICAgICAgICByZXNvbHZlKG1hdGNoZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBJbmRleGVkREIgaW5jbHVkZXNLZXkgb3BlcmF0aW9uXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVsZXRlKGtleSkge1xuICAgIGxvZ2dlcjE5LnRyYWNlKFwiZGVsZXRlXCIsIHsga2V5IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLmdldFN0b3JhZ2VLZXkoa2V5KTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoc3RvcmFnZUtleSk7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCXCIsIHsga2V5LCBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIEluZGV4ZWREQiBkZWxldGUgb3BlcmF0aW9uXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWxsSW4obG9jYXRpb25zKSB7XG4gICAgY29uc3QgYWxsS2V5cyA9IGF3YWl0IHRoaXMua2V5cygpO1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIxOS5kZWJ1ZyhcIlJldHVybmluZyBhbGwgaXRlbXMsIExvY0tleXMgaXMgZW1wdHlcIik7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IGFsbEtleXMubWFwKChrZXkpID0+IHRoaXMuZ2V0KGtleSkpO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvY0tleXMgPSBsb2NhdGlvbnM7XG4gICAgICBsb2dnZXIxOS5kZWJ1ZyhcImFsbEluXCIsIHsgbG9jS2V5cywga2V5czogYWxsS2V5cy5sZW5ndGggfSk7XG4gICAgICBjb25zdCBmaWx0ZXJlZEtleXMgPSBhbGxLZXlzLmZpbHRlcigoa2V5KSA9PiBrZXkgJiYgaXNDb21LZXk1KGtleSkpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IENvbUtleTEyID0ga2V5O1xuICAgICAgICBsb2dnZXIxOS5kZWJ1ZyhcIkNvbXBhcmluZyBMb2NhdGlvbiBLZXlzXCIsIHtcbiAgICAgICAgICBsb2NLZXlzLFxuICAgICAgICAgIENvbUtleTogQ29tS2V5MTJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpc0xvY0tleUFycmF5RXF1YWwobG9jS2V5cywgQ29tS2V5MTIubG9jKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBmaWx0ZXJlZEtleXMubWFwKChrZXkpID0+IHRoaXMuZ2V0KGtleSkpO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5LCBsb2NhdGlvbnMpIHtcbiAgICBsb2dnZXIxOS5kZWJ1ZyhcImNvbnRhaW5zXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuc29tZSgoaXRlbSkgPT4gaXNRdWVyeU1hdGNoNShpdGVtLCBxdWVyeSkpO1xuICB9XG4gIGFzeW5jIHF1ZXJ5SW4ocXVlcnksIGxvY2F0aW9ucyA9IFtdKSB7XG4gICAgbG9nZ2VyMTkuZGVidWcoXCJxdWVyeUluXCIsIHsgcXVlcnksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuYWxsSW4obG9jYXRpb25zKTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpc1F1ZXJ5TWF0Y2g1KGl0ZW0sIHF1ZXJ5KSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfQXN5bmNJbmRleERCQ2FjaGVNYXAodGhpcy50eXBlcywgdGhpcy5kYk5hbWUsIHRoaXMuc3RvcmVOYW1lLCB0aGlzLnZlcnNpb24pO1xuICB9XG4gIGFzeW5jIGtleXMoKSB7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkb25seVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgZ2V0dGluZyBrZXlzIGZyb20gSW5kZXhlZERCXCIsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAga2V5cy5wdXNoKHN0b3JlZC5vcmlnaW5hbEtleSk7XG4gICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBJbmRleGVkREIga2V5cyBvcGVyYXRpb25cIiwgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdmFsdWVzKCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkb25seVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBJbmRleGVkREJcIiwgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWQgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChzdG9yZWQudmFsdWUpO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBJbmRleGVkREIgdmFsdWVzIG9wZXJhdGlvblwiLCB7IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBhc3luYyBjbGVhcigpIHtcbiAgICBsb2dnZXIxOS5kZWJ1ZyhcIkNsZWFyaW5nIEluZGV4ZWREQiBjYWNoZVwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuY2xlYXIoKTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRXJyb3IgY2xlYXJpbmcgSW5kZXhlZERCIGNhY2hlXCIsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJFcnJvciBpbiBJbmRleGVkREIgY2xlYXIgb3BlcmF0aW9uXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG4gIC8vIEFzeW5jIFF1ZXJ5IHJlc3VsdCBjYWNoaW5nIG1ldGhvZHNcbiAgYXN5bmMgc2V0UXVlcnlSZXN1bHQocXVlcnlIYXNoLCBpdGVtS2V5cykge1xuICAgIGxvZ2dlcjE5LnRyYWNlKFwic2V0UXVlcnlSZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGl0ZW1LZXlzIH0pO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMudmVyc2lvbik7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkZhaWxlZCB0byBvcGVuIGRhdGFiYXNlIGZvciBzZXRRdWVyeVJlc3VsdFwiLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGIgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgaXRlbUtleXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5S2V5ID0gYHF1ZXJ5OiR7cXVlcnlIYXNofWA7XG4gICAgICAgICAgY29uc3QgcHV0UmVxdWVzdCA9IHN0b3JlLnB1dChzYWZlU3RyaW5naWZ5MyhlbnRyeSksIHF1ZXJ5S2V5KTtcbiAgICAgICAgICBwdXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkZhaWxlZCB0byBzdG9yZSBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGVycm9yOiBwdXRSZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgICAgcmVqZWN0KHB1dFJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIHNldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxOS50cmFjZShcImdldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMudmVyc2lvbik7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkZhaWxlZCB0byBvcGVuIGRhdGFiYXNlIGZvciBnZXRRdWVyeVJlc3VsdFwiLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGIgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBgcXVlcnk6JHtxdWVyeUhhc2h9YDtcbiAgICAgICAgICBjb25zdCBnZXRSZXF1ZXN0ID0gc3RvcmUuZ2V0KHF1ZXJ5S2V5KTtcbiAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIxOS5lcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGVycm9yOiBnZXRSZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgICAgcmVqZWN0KGdldFJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZ2V0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRSZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoZW50cnkuaXRlbUtleXMgfHwgbnVsbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHF1ZXJ5IHJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCwgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIGdldFF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBoYXNRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBsb2dnZXIxOS50cmFjZShcImhhc1F1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICE9PSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIGhhc1F1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgbG9nZ2VyMTkudHJhY2UoXCJkZWxldGVRdWVyeVJlc3VsdFwiLCB7IHF1ZXJ5SGFzaCB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3IgZGVsZXRlUXVlcnlSZXN1bHRcIiwgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCBxdWVyeUtleSA9IGBxdWVyeToke3F1ZXJ5SGFzaH1gO1xuICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcXVlc3QgPSBzdG9yZS5kZWxldGUocXVlcnlLZXkpO1xuICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBxdWVyeSByZXN1bHRcIiwgeyBxdWVyeUhhc2gsIGVycm9yOiBkZWxldGVSZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgICAgcmVqZWN0KGRlbGV0ZVJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIGRlbGV0ZVF1ZXJ5UmVzdWx0XCIsIHsgcXVlcnlIYXNoLCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlSXRlbUtleXMoa2V5cykge1xuICAgIGxvZ2dlcjE5LmRlYnVnKFwiaW52YWxpZGF0ZUl0ZW1LZXlzXCIsIHsga2V5cyB9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKSB7XG4gICAgbG9nZ2VyMTkuZGVidWcoXCJpbnZhbGlkYXRlTG9jYXRpb25cIiwgeyBsb2NhdGlvbnMgfSk7XG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuY2xlYXJRdWVyeVJlc3VsdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXRlbXNJbkxvY2F0aW9uID0gYXdhaXQgdGhpcy5hbGxJbihsb2NhdGlvbnMpO1xuICAgICAgY29uc3Qga2V5c1RvSW52YWxpZGF0ZSA9IGl0ZW1zSW5Mb2NhdGlvbi5tYXAoKGl0ZW0pID0+IGl0ZW0ua2V5KTtcbiAgICAgIGF3YWl0IHRoaXMuaW52YWxpZGF0ZUl0ZW1LZXlzKGtleXNUb0ludmFsaWRhdGUpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmNsZWFyUXVlcnlSZXN1bHRzKCk7XG4gIH1cbiAgYXN5bmMgY2xlYXJRdWVyeVJlc3VsdHMoKSB7XG4gICAgbG9nZ2VyMTkudHJhY2UoXCJjbGVhclF1ZXJ5UmVzdWx0c1wiKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZSBmb3IgY2xlYXJRdWVyeVJlc3VsdHNcIiwgeyBlcnJvcjogcmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCBjdXJzb3JSZXF1ZXN0ID0gc3RvcmUub3BlbkN1cnNvcigpO1xuICAgICAgICAgIGNvbnN0IGtleXNUb0RlbGV0ZSA9IFtdO1xuICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlcjE5LmVycm9yKFwiRmFpbGVkIHRvIG9wZW4gY3Vyc29yIGZvciBjbGVhclF1ZXJ5UmVzdWx0c1wiLCB7IGVycm9yOiBjdXJzb3JSZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICAgICAgcmVqZWN0KGN1cnNvclJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBjdXJzb3JSZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYga2V5LnN0YXJ0c1dpdGgoXCJxdWVyeTpcIikpIHtcbiAgICAgICAgICAgICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGtleXNUb0RlbGV0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkZWxldGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbFRvRGVsZXRlID0ga2V5c1RvRGVsZXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAga2V5c1RvRGVsZXRlLmZvckVhY2goKHF1ZXJ5S2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVxdWVzdCA9IHN0b3JlLmRlbGV0ZShxdWVyeUtleSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyMTkuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIHF1ZXJ5IGtleVwiLCB7IHF1ZXJ5S2V5LCBlcnJvcjogZGVsZXRlUmVxdWVzdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZWRDb3VudCA9PT0gdG90YWxUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZWRDb3VudCA9PT0gdG90YWxUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIxOS5lcnJvcihcIkVycm9yIGluIGNsZWFyUXVlcnlSZXN1bHRzXCIsIHsgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9icm93c2VyL0luZGV4REJDYWNoZU1hcC50c1xudmFyIEluZGV4REJDYWNoZU1hcCA9IGNsYXNzIF9JbmRleERCQ2FjaGVNYXAgZXh0ZW5kcyBDYWNoZU1hcCB7XG4gIGltcGxlbWVudGF0aW9uVHlwZSA9IFwiYnJvd3Nlci9pbmRleGVkREJcIjtcbiAgYXN5bmNDYWNoZTtcbiAgbWVtb3J5Q2FjaGU7XG4gIHN5bmNJbnRlcnZhbCA9IG51bGw7XG4gIFNZTkNfSU5URVJWQUxfTVMgPSA1ZTM7XG4gIC8vIFN5bmMgZXZlcnkgNSBzZWNvbmRzXG4gIHBlbmRpbmdTeW5jT3BlcmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7XG4gIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgTUFYX1JFVFJZX0FUVEVNUFRTID0gMztcbiAgb3BlcmF0aW9uU2VxdWVuY2UgPSAwO1xuICBjb25zdHJ1Y3Rvcih0eXBlcywgZGJOYW1lID0gXCJmamVsbC1pbmRleGRiLWNhY2hlXCIsIHN0b3JlTmFtZSA9IFwiY2FjaGVcIiwgdmVyc2lvbiA9IDEpIHtcbiAgICBzdXBlcih0eXBlcyk7XG4gICAgdGhpcy5hc3luY0NhY2hlID0gbmV3IEFzeW5jSW5kZXhEQkNhY2hlTWFwKHR5cGVzLCBkYk5hbWUsIHN0b3JlTmFtZSwgdmVyc2lvbik7XG4gICAgdGhpcy5tZW1vcnlDYWNoZSA9IG5ldyBNZW1vcnlDYWNoZU1hcCh0eXBlcyk7XG4gICAgdGhpcy5pbml0aWFsaXplRnJvbUluZGV4ZWREQigpO1xuICAgIHRoaXMuc3RhcnRQZXJpb2RpY1N5bmMoKTtcbiAgfVxuICBhc3luYyBpbml0aWFsaXplRnJvbUluZGV4ZWREQigpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXphdGlvblByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IHRoaXMuYXN5bmNDYWNoZS5rZXlzKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubWVtb3J5Q2FjaGUuaW5jbHVkZXNLZXkoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmFzeW5jQ2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZW1vcnlDYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBmcm9tIEluZGV4ZWREQjpcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICB9XG4gIHN0YXJ0UGVyaW9kaWNTeW5jKCkge1xuICAgIHRoaXMuc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5zeW5jVG9JbmRleGVkREIoKTtcbiAgICB9LCB0aGlzLlNZTkNfSU5URVJWQUxfTVMpO1xuICB9XG4gIGFzeW5jIHN5bmNUb0luZGV4ZWREQigpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUGVuZGluZ09wZXJhdGlvbnMoKTtcbiAgICAgIGNvbnN0IG1lbW9yeUtleXMgPSB0aGlzLm1lbW9yeUNhY2hlLmtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1lbW9yeUtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLm1lbW9yeUNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFzeW5jQ2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzeW5jIHRvIEluZGV4ZWREQjpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzUGVuZGluZ09wZXJhdGlvbnMoKSB7XG4gICAgY29uc3QgcGVuZGluZ09wcyA9IEFycmF5LmZyb20odGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZW50cmllcygpKTtcbiAgICBmb3IgKGNvbnN0IFtrZXlTdHIsIG9wZXJhdGlvbl0gb2YgcGVuZGluZ09wcykge1xuICAgICAgaWYgKG9wZXJhdGlvbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZGVsZXRlKGtleVN0cik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb3BlcmF0aW9uLnByb21pc2U7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcCA9IHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmdldChrZXlTdHIpO1xuICAgICAgICBpZiAoY3VycmVudE9wICYmIGN1cnJlbnRPcC5zZXF1ZW5jZUlkID09PSBvcGVyYXRpb24uc2VxdWVuY2VJZCkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmRlbGV0ZShrZXlTdHIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwcm9jZXNzIHBlbmRpbmcgJHtvcGVyYXRpb24udHlwZX0gb3BlcmF0aW9uOmAsIGVycm9yKTtcbiAgICAgICAgY29uc3QgY3VycmVudE9wID0gdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZ2V0KGtleVN0cik7XG4gICAgICAgIGlmICghY3VycmVudE9wIHx8IGN1cnJlbnRPcC5zZXF1ZW5jZUlkICE9PSBvcGVyYXRpb24uc2VxdWVuY2VJZCB8fCBjdXJyZW50T3AuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRPcCAmJiBjdXJyZW50T3Auc2VxdWVuY2VJZCA9PT0gb3BlcmF0aW9uLnNlcXVlbmNlSWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmRlbGV0ZShrZXlTdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBxdWV1ZUZvclN5bmMoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGtleVN0ciA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZCA9ICsrdGhpcy5vcGVyYXRpb25TZXF1ZW5jZTtcbiAgICBjb25zdCBleGlzdGluZ09wID0gdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZ2V0KGtleVN0cik7XG4gICAgaWYgKGV4aXN0aW5nT3ApIHtcbiAgICAgIGV4aXN0aW5nT3AuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3luY1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hc3luY0NhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgY29uc3QgY3VycmVudE9wID0gdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZ2V0KGtleVN0cik7XG4gICAgICAgIGlmIChjdXJyZW50T3AgJiYgY3VycmVudE9wLnNlcXVlbmNlSWQgPT09IHNlcXVlbmNlSWQgJiYgIWN1cnJlbnRPcC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5kZWxldGUoa2V5U3RyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHN5bmMgc2luZ2xlIG9wZXJhdGlvbiB0byBJbmRleGVkREI6XCIsIGVycm9yKTtcbiAgICAgICAgY29uc3QgY3VycmVudE9wID0gdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZ2V0KGtleVN0cik7XG4gICAgICAgIGlmICghY3VycmVudE9wIHx8IGN1cnJlbnRPcC5zZXF1ZW5jZUlkICE9PSBzZXF1ZW5jZUlkIHx8IGN1cnJlbnRPcC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBpZiAoY3VycmVudE9wICYmIGN1cnJlbnRPcC5zZXF1ZW5jZUlkID09PSBzZXF1ZW5jZUlkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5kZWxldGUoa2V5U3RyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLnNldChrZXlTdHIsIHtcbiAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIHNlcXVlbmNlSWQsXG4gICAgICBwcm9taXNlOiBzeW5jUHJvbWlzZSxcbiAgICAgIGNhbmNlbGxlZDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBxdWV1ZURlbGV0ZUZvclN5bmMoa2V5KSB7XG4gICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICBjb25zdCBzZXF1ZW5jZUlkID0gKyt0aGlzLm9wZXJhdGlvblNlcXVlbmNlO1xuICAgIGNvbnN0IGV4aXN0aW5nT3AgPSB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5nZXQoa2V5U3RyKTtcbiAgICBpZiAoZXhpc3RpbmdPcCkge1xuICAgICAgZXhpc3RpbmdPcC5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzeW5jUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmFzeW5jQ2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcCA9IHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmdldChrZXlTdHIpO1xuICAgICAgICBpZiAoY3VycmVudE9wICYmIGN1cnJlbnRPcC5zZXF1ZW5jZUlkID09PSBzZXF1ZW5jZUlkICYmICFjdXJyZW50T3AuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZGVsZXRlKGtleVN0cik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzeW5jIGRlbGV0ZSBvcGVyYXRpb24gdG8gSW5kZXhlZERCOlwiLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcCA9IHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLmdldChrZXlTdHIpO1xuICAgICAgICBpZiAoIWN1cnJlbnRPcCB8fCBjdXJyZW50T3Auc2VxdWVuY2VJZCAhPT0gc2VxdWVuY2VJZCB8fCBjdXJyZW50T3AuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRPcCAmJiBjdXJyZW50T3Auc2VxdWVuY2VJZCA9PT0gc2VxdWVuY2VJZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuZGVsZXRlKGtleVN0cik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICB0aGlzLnBlbmRpbmdTeW5jT3BlcmF0aW9ucy5zZXQoa2V5U3RyLCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAga2V5LFxuICAgICAgc2VxdWVuY2VJZCxcbiAgICAgIHByb21pc2U6IHN5bmNQcm9taXNlLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHF1ZXVlQ2xlYXJGb3JTeW5jKCkge1xuICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIHRoaXMucGVuZGluZ1N5bmNPcGVyYXRpb25zLnZhbHVlcygpKSB7XG4gICAgICBvcGVyYXRpb24uY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nU3luY09wZXJhdGlvbnMuY2xlYXIoKTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYXN5bmNDYWNoZS5jbGVhcigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHN5bmMgY2xlYXIgb3BlcmF0aW9uIHRvIEluZGV4ZWREQjpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCAmJiB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbmRleGVkREIgaW5pdGlhbGl6YXRpb24gZmFpbGVkLCB1c2luZyBtZW1vcnkgY2FjaGUgb25seTpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5nZXQoa2V5KTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMubWVtb3J5Q2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMucXVldWVGb3JTeW5jKGtleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGluY2x1ZGVzS2V5KGtleSkge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkICYmIHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkluZGV4ZWREQiBpbml0aWFsaXphdGlvbiBmYWlsZWQsIHVzaW5nIG1lbW9yeSBjYWNoZSBvbmx5OlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmluY2x1ZGVzS2V5KGtleSk7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMubWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5xdWV1ZURlbGV0ZUZvclN5bmMoa2V5KTtcbiAgfVxuICBhc3luYyBhbGxJbihsb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5hbGxJbihsb2NhdGlvbnMpO1xuICB9XG4gIGFzeW5jIGNvbnRhaW5zKHF1ZXJ5LCBsb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5jb250YWlucyhxdWVyeSwgbG9jYXRpb25zKTtcbiAgfVxuICBhc3luYyBxdWVyeUluKHF1ZXJ5LCBsb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5xdWVyeUluKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICB9XG4gIGFzeW5jIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0luZGV4REJDYWNoZU1hcCh0aGlzLnR5cGVzKTtcbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmtleXMoKTtcbiAgfVxuICBhc3luYyB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUudmFsdWVzKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5tZW1vcnlDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMucXVldWVDbGVhckZvclN5bmMoKTtcbiAgfVxuICAvLyBRdWVyeSByZXN1bHQgY2FjaGluZyBtZXRob2RzIGltcGxlbWVudGF0aW9uXG4gIHNldFF1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCwgaXRlbUtleXMpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5zZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gsIGl0ZW1LZXlzKTtcbiAgfVxuICBhc3luYyBnZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCAmJiB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbmRleGVkREIgaW5pdGlhbGl6YXRpb24gZmFpbGVkLCB1c2luZyBtZW1vcnkgY2FjaGUgb25seTpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5nZXRRdWVyeVJlc3VsdChxdWVyeUhhc2gpO1xuICB9XG4gIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5SGFzaCk7XG4gIH1cbiAgZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuZGVsZXRlUXVlcnlSZXN1bHQocXVlcnlIYXNoKTtcbiAgfVxuICBpbnZhbGlkYXRlSXRlbUtleXMoa2V5cykge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmludmFsaWRhdGVJdGVtS2V5cyhrZXlzKTtcbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlTG9jYXRpb24obG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubWVtb3J5Q2FjaGUuaW52YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9ucyk7XG4gIH1cbiAgY2xlYXJRdWVyeVJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuY2xlYXJRdWVyeVJlc3VsdHMoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYW4gdXAgcmVzb3VyY2VzIHdoZW4gdGhlIGNhY2hlIGlzIG5vIGxvbmdlciBuZWVkZWRcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3luY0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0ludGVydmFsKTtcbiAgICAgIHRoaXMuc3luY0ludGVydmFsID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLy8gQ2FjaGVNYXBNZXRhZGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gIC8vIERlbGVnYXRlIHRvIHRoZSBtZW1vcnkgY2FjaGUgZm9yIG1ldGFkYXRhIG9wZXJhdGlvbnMgZm9yIGNvbnNpc3RlbmN5XG4gIGdldE1ldGFkYXRhKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmdldE1ldGFkYXRhKGtleSk7XG4gIH1cbiAgc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSkge1xuICAgIHRoaXMubWVtb3J5Q2FjaGUuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cbiAgZGVsZXRlTWV0YWRhdGEoa2V5KSB7XG4gICAgdGhpcy5tZW1vcnlDYWNoZS5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG4gIGdldEFsbE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmdldEFsbE1ldGFkYXRhKCk7XG4gIH1cbiAgY2xlYXJNZXRhZGF0YSgpIHtcbiAgICB0aGlzLm1lbW9yeUNhY2hlLmNsZWFyTWV0YWRhdGEoKTtcbiAgfVxuICBnZXRDdXJyZW50U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1vcnlDYWNoZS5nZXRDdXJyZW50U2l6ZSgpO1xuICB9XG4gIGdldFNpemVMaW1pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGUuZ2V0U2l6ZUxpbWl0cygpO1xuICB9XG59O1xuXG4vLyBzcmMvT3B0aW9ucy50c1xudmFyIERFRkFVTFRfQ0FDSEVfT1BUSU9OUyA9IHtcbiAgY2FjaGVUeXBlOiBcIm1lbW9yeVwiLFxuICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IGZhbHNlLFxuICBhdXRvU3luYzogdHJ1ZSxcbiAgbWF4UmV0cmllczogMyxcbiAgcmV0cnlEZWxheTogMWUzLFxuICBpbmRleGVkREJDb25maWc6IHtcbiAgICBkYk5hbWU6IFwiZmplbGwtY2FjaGVcIixcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHN0b3JlTmFtZTogXCJjYWNoZVwiLFxuICAgIHNpemU6IHtcbiAgICAgIGV2aWN0aW9uUG9saWN5OiBcImxydVwiXG4gICAgfVxuICB9LFxuICB3ZWJTdG9yYWdlQ29uZmlnOiB7XG4gICAga2V5UHJlZml4OiBcImZqZWxsLWNhY2hlOlwiLFxuICAgIGNvbXByZXNzOiBmYWxzZSxcbiAgICBzaXplOiB7XG4gICAgICBldmljdGlvblBvbGljeTogXCJscnVcIlxuICAgIH1cbiAgfSxcbiAgbWVtb3J5Q29uZmlnOiB7XG4gICAgLy8gTm8gbGltaXRzIGJ5IGRlZmF1bHRcbiAgICBzaXplOiB7XG4gICAgICBldmljdGlvblBvbGljeTogXCJscnVcIlxuICAgIH1cbiAgfVxufTtcbnZhciBjcmVhdGVPcHRpb25zID0gKGNhY2hlT3B0aW9ucykgPT4ge1xuICBjb25zdCBpbmRleGVkREJDb25maWcgPSBjYWNoZU9wdGlvbnM/LmluZGV4ZWREQkNvbmZpZyA/IHtcbiAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMuaW5kZXhlZERCQ29uZmlnLFxuICAgIC4uLmNhY2hlT3B0aW9ucy5pbmRleGVkREJDb25maWcsXG4gICAgc2l6ZTogY2FjaGVPcHRpb25zLmluZGV4ZWREQkNvbmZpZy5zaXplID8ge1xuICAgICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLmluZGV4ZWREQkNvbmZpZz8uc2l6ZSxcbiAgICAgIC4uLmNhY2hlT3B0aW9ucy5pbmRleGVkREJDb25maWcuc2l6ZVxuICAgIH0gOiBERUZBVUxUX0NBQ0hFX09QVElPTlMuaW5kZXhlZERCQ29uZmlnPy5zaXplXG4gIH0gOiB7IC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5pbmRleGVkREJDb25maWcgfTtcbiAgY29uc3Qgd2ViU3RvcmFnZUNvbmZpZyA9IGNhY2hlT3B0aW9ucz8ud2ViU3RvcmFnZUNvbmZpZyA/IHtcbiAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMud2ViU3RvcmFnZUNvbmZpZyxcbiAgICAuLi5jYWNoZU9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZyxcbiAgICBzaXplOiBjYWNoZU9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZy5zaXplID8ge1xuICAgICAgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLndlYlN0b3JhZ2VDb25maWc/LnNpemUsXG4gICAgICAuLi5jYWNoZU9wdGlvbnMud2ViU3RvcmFnZUNvbmZpZy5zaXplXG4gICAgfSA6IERFRkFVTFRfQ0FDSEVfT1BUSU9OUy53ZWJTdG9yYWdlQ29uZmlnPy5zaXplXG4gIH0gOiB7IC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy53ZWJTdG9yYWdlQ29uZmlnIH07XG4gIGNvbnN0IG1lbW9yeUNvbmZpZyA9IGNhY2hlT3B0aW9ucz8ubWVtb3J5Q29uZmlnID8ge1xuICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUy5tZW1vcnlDb25maWcsXG4gICAgLi4uY2FjaGVPcHRpb25zLm1lbW9yeUNvbmZpZyxcbiAgICBzaXplOiBjYWNoZU9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUgPyB7XG4gICAgICAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMubWVtb3J5Q29uZmlnPy5zaXplLFxuICAgICAgLi4uY2FjaGVPcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplXG4gICAgfSA6IERFRkFVTFRfQ0FDSEVfT1BUSU9OUy5tZW1vcnlDb25maWc/LnNpemVcbiAgfSA6IHsgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLm1lbW9yeUNvbmZpZyB9O1xuICByZXR1cm4ge1xuICAgIC4uLkRFRkFVTFRfQ0FDSEVfT1BUSU9OUyxcbiAgICAuLi5jYWNoZU9wdGlvbnMsXG4gICAgaW5kZXhlZERCQ29uZmlnLFxuICAgIHdlYlN0b3JhZ2VDb25maWcsXG4gICAgbWVtb3J5Q29uZmlnXG4gIH07XG59O1xudmFyIGNyZWF0ZUNhY2hlTWFwID0gKGt0YSwgb3B0aW9ucykgPT4ge1xuICBzd2l0Y2ggKG9wdGlvbnMuY2FjaGVUeXBlKSB7XG4gICAgY2FzZSBcIm1lbW9yeVwiOlxuICAgICAgaWYgKG9wdGlvbnMubWVtb3J5Q29uZmlnPy5zaXplICYmIChvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heFNpemVCeXRlcyB8fCBvcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heEl0ZW1zKSkge1xuICAgICAgICBjb25zdCBzaXplQ29uZmlnID0ge1xuICAgICAgICAgIG1heFNpemVCeXRlczogb3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZS5tYXhTaXplQnl0ZXMsXG4gICAgICAgICAgbWF4SXRlbXM6IG9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUubWF4SXRlbXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbmhhbmNlZE1lbW9yeUNhY2hlTWFwKFxuICAgICAgICAgIGt0YSxcbiAgICAgICAgICBzaXplQ29uZmlnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE1lbW9yeUNhY2hlTWFwKGt0YSk7XG4gICAgY2FzZSBcImxvY2FsU3RvcmFnZVwiOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JhZ2VDYWNoZU1hcChcbiAgICAgICAga3RhLFxuICAgICAgICBvcHRpb25zLndlYlN0b3JhZ2VDb25maWc/LmtleVByZWZpeFxuICAgICAgKTtcbiAgICBjYXNlIFwic2Vzc2lvblN0b3JhZ2VcIjpcbiAgICAgIHJldHVybiBuZXcgU2Vzc2lvblN0b3JhZ2VDYWNoZU1hcChcbiAgICAgICAga3RhLFxuICAgICAgICBvcHRpb25zLndlYlN0b3JhZ2VDb25maWc/LmtleVByZWZpeFxuICAgICAgKTtcbiAgICBjYXNlIFwiaW5kZXhlZERCXCI6XG4gICAgICByZXR1cm4gbmV3IEluZGV4REJDYWNoZU1hcChcbiAgICAgICAga3RhLFxuICAgICAgICBvcHRpb25zLmluZGV4ZWREQkNvbmZpZz8uZGJOYW1lLFxuICAgICAgICBvcHRpb25zLmluZGV4ZWREQkNvbmZpZz8uc3RvcmVOYW1lLFxuICAgICAgICBvcHRpb25zLmluZGV4ZWREQkNvbmZpZz8udmVyc2lvblxuICAgICAgKTtcbiAgICBjYXNlIFwiY3VzdG9tXCI6XG4gICAgICBpZiAoIW9wdGlvbnMuY3VzdG9tQ2FjaGVNYXBGYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIGNhY2hlIG1hcCBmYWN0b3J5IGlzIHJlcXVpcmVkIHdoZW4gY2FjaGVUeXBlIGlzIFwiY3VzdG9tXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmN1c3RvbUNhY2hlTWFwRmFjdG9yeShrdGEpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNhY2hlIHR5cGU6ICR7b3B0aW9ucy5jYWNoZVR5cGV9YCk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMuY2FjaGVUeXBlID09PSBcImN1c3RvbVwiICYmICFvcHRpb25zLmN1c3RvbUNhY2hlTWFwRmFjdG9yeSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY3VzdG9tQ2FjaGVNYXBGYWN0b3J5IGlzIHJlcXVpcmVkIHdoZW4gY2FjaGVUeXBlIGlzIFwiY3VzdG9tXCInKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMubWF4UmV0cmllcyA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1heFJldHJpZXMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF4UmV0cmllcyBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV0cnlEZWxheSA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLnJldHJ5RGVsYXkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmV0cnlEZWxheSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMudHRsID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMudHRsIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dGwgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMubWVtb3J5Q29uZmlnPy5tYXhJdGVtcyA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1lbW9yeUNvbmZpZy5tYXhJdGVtcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWVtb3J5Q29uZmlnLm1heEl0ZW1zIG11c3QgYmUgcG9zaXRpdmVcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWVtb3J5Q29uZmlnPy5zaXplKSB7XG4gICAgdmFsaWRhdGVTaXplQ29uZmlnKG9wdGlvbnMubWVtb3J5Q29uZmlnLnNpemUpO1xuICB9XG4gIGlmIChvcHRpb25zLndlYlN0b3JhZ2VDb25maWc/LnNpemUpIHtcbiAgICB2YWxpZGF0ZVNpemVDb25maWcob3B0aW9ucy53ZWJTdG9yYWdlQ29uZmlnLnNpemUpO1xuICB9XG4gIGlmIChvcHRpb25zLmluZGV4ZWREQkNvbmZpZz8uc2l6ZSkge1xuICAgIHZhbGlkYXRlU2l6ZUNvbmZpZyhvcHRpb25zLmluZGV4ZWREQkNvbmZpZy5zaXplKTtcbiAgfVxuICBpZiAoW1wibG9jYWxTdG9yYWdlXCIsIFwic2Vzc2lvblN0b3JhZ2VcIl0uaW5jbHVkZXMob3B0aW9ucy5jYWNoZVR5cGUpKSB7XG4gICAgY29uc3QgaXNSZWFsQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAoIWlzUmVhbEJyb3dzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLmNhY2hlVHlwZX0gaXMgbm90IGF2YWlsYWJsZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHNgKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2FjaGVUeXBlID09PSBcImluZGV4ZWREQlwiKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIXdpbmRvdy5pbmRleGVkREIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLmNhY2hlVHlwZX0gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50YCk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhY2hlVHlwZSA9PT0gXCJhc3luY0luZGV4ZWREQlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmNJbmRleGVkREIgY2Fubm90IGJlIHVzZWQgd2l0aCBzeW5jaHJvbm91cyBjYWNoZSBmYWN0b3J5LiBVc2UgQXN5bmNJbmRleERCQ2FjaGVNYXAgZGlyZWN0bHkgZm9yIGFzeW5jIG9wZXJhdGlvbnMuXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvb3BzL3Jlc2V0LnRzXG52YXIgcmVzZXQgPSBhc3luYyAoY29vcmRpbmF0ZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBjYWNoZU1hcCA9IGNyZWF0ZUNhY2hlTWFwKGNvb3JkaW5hdGUua3RhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gW2NhY2hlTWFwXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL09wZXJhdGlvbnMudHNcbnZhciBjcmVhdGVPcGVyYXRpb25zID0gKGFwaSwgY29vcmRpbmF0ZSwgY2FjaGVNYXAsIHBrVHlwZSwgb3B0aW9ucywgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIHN0YXRzTWFuYWdlcikgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FjaGVDb250ZXh0KGFwaSwgY2FjaGVNYXAsIHBrVHlwZSwgb3B0aW9ucywgZXZlbnRFbWl0dGVyLCB0dGxNYW5hZ2VyLCBldmljdGlvbk1hbmFnZXIsIHN0YXRzTWFuYWdlcik7XG4gIHJldHVybiB7XG4gICAgYWxsOiAocXVlcnksIGxvY2F0aW9ucykgPT4gYWxsKHF1ZXJ5LCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgb25lOiAocXVlcnksIGxvY2F0aW9ucykgPT4gb25lKHF1ZXJ5LCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgY3JlYXRlOiAoaXRlbSwgbG9jYXRpb25zKSA9PiBjcmVhdGUoaXRlbSwgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGdldDogKGtleSkgPT4gZ2V0KGtleSwgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICByZXRyaWV2ZTogKGtleSkgPT4gcmV0cmlldmUoa2V5LCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIHJlbW92ZTogKGtleSkgPT4gcmVtb3ZlKGtleSwgY29udGV4dCkudGhlbigoY3R4KSA9PiB2b2lkIDApLFxuICAgIHVwZGF0ZTogKGtleSwgaXRlbSkgPT4gdXBkYXRlKGtleSwgaXRlbSwgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBhY3Rpb246IChrZXksIGFjdGlvbk5hbWUsIGJvZHkpID0+IGFjdGlvbihrZXksIGFjdGlvbk5hbWUsIGJvZHksIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgYWxsQWN0aW9uOiAoYWN0aW9uTmFtZSwgYm9keSwgbG9jYXRpb25zKSA9PiBhbGxBY3Rpb24oYWN0aW9uTmFtZSwgYm9keSwgbG9jYXRpb25zLCBjb250ZXh0KS50aGVuKChbY3R4LCByZXN1bHRdKSA9PiByZXN1bHQpLFxuICAgIGZhY2V0OiAoa2V5LCBmYWNldE5hbWUsIHBhcmFtcykgPT4gZmFjZXQoa2V5LCBmYWNldE5hbWUsIHBhcmFtcywgY29udGV4dCkudGhlbigocmVzdWx0KSA9PiByZXN1bHQpLFxuICAgIGFsbEZhY2V0OiAoZmFjZXROYW1lLCBwYXJhbXMsIGxvY2F0aW9ucykgPT4gYWxsRmFjZXQoZmFjZXROYW1lLCBwYXJhbXMsIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigocmVzdWx0KSA9PiByZXN1bHQpLFxuICAgIGZpbmQ6IChmaW5kZXIsIHBhcmFtcywgbG9jYXRpb25zKSA9PiBmaW5kKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMsIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgZmluZE9uZTogKGZpbmRlciwgcGFyYW1zLCBsb2NhdGlvbnMpID0+IGZpbmRPbmUoZmluZGVyLCBwYXJhbXMsIGxvY2F0aW9ucywgY29udGV4dCkudGhlbigoW2N0eCwgcmVzdWx0XSkgPT4gcmVzdWx0KSxcbiAgICBzZXQ6IChrZXksIGl0ZW0pID0+IHNldChrZXksIGl0ZW0sIGNvbnRleHQpLnRoZW4oKFtjdHgsIHJlc3VsdF0pID0+IHJlc3VsdCksXG4gICAgcmVzZXQ6ICgpID0+IHJlc2V0KGNvb3JkaW5hdGUsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdm9pZCAwKVxuICB9O1xufTtcblxuLy8gc3JjL2V2aWN0aW9uL0V2aWN0aW9uTWFuYWdlci50c1xudmFyIGxvZ2dlcjIwID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiRXZpY3Rpb25NYW5hZ2VyXCIpO1xudmFyIEV2aWN0aW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgZXZpY3Rpb25TdHJhdGVneTtcbiAgY29uc3RydWN0b3IoZXZpY3Rpb25TdHJhdGVneSkge1xuICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneSA9IGV2aWN0aW9uU3RyYXRlZ3kgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0IG9yIHVwZGF0ZSB0aGUgZXZpY3Rpb24gc3RyYXRlZ3lcbiAgICogQHBhcmFtIHN0cmF0ZWd5IC0gVGhlIGV2aWN0aW9uIHN0cmF0ZWd5IHRvIHVzZVxuICAgKi9cbiAgc2V0RXZpY3Rpb25TdHJhdGVneShzdHJhdGVneSkge1xuICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIGxvZ2dlcjIwLmRlYnVnKFwiRXZpY3Rpb24gc3RyYXRlZ3kgdXBkYXRlZFwiLCB7XG4gICAgICBzdHJhdGVneTogc3RyYXRlZ3k/LmdldFN0cmF0ZWd5TmFtZSgpIHx8IFwibm9uZVwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBldmljdGlvbiBzdHJhdGVneSBuYW1lXG4gICAqIEByZXR1cm5zIFN0cmF0ZWd5IG5hbWUgb3IgbnVsbCBpZiBubyBldmljdGlvblxuICAgKi9cbiAgZ2V0RXZpY3Rpb25TdHJhdGVneU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZpY3Rpb25TdHJhdGVneT8uZ2V0U3RyYXRlZ3lOYW1lKCkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGl0ZW0gYWNjZXNzIC0gdXBkYXRlIG1ldGFkYXRhIGZvciBldmljdGlvbiBzdHJhdGVneVxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKi9cbiAgb25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgaWYgKCF0aGlzLmV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1BY2Nlc3NlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIyMC5lcnJvcihcIkVycm9yIGluIGV2aWN0aW9uIHN0cmF0ZWd5IG9uSXRlbUFjY2Vzc2VkXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBpdGVtIGFkZGl0aW9uIC0gdXBkYXRlIG1ldGFkYXRhIGFuZCBwZXJmb3JtIGV2aWN0aW9uIGlmIG5lZWRlZFxuICAgKiBAcGFyYW0ga2V5IC0gSXRlbSBrZXlcbiAgICogQHBhcmFtIHZhbHVlIC0gSXRlbSB2YWx1ZSAoZm9yIHNpemUgZXN0aW1hdGlvbilcbiAgICogQHBhcmFtIG1ldGFkYXRhUHJvdmlkZXIgLSBDYWNoZSBtZXRhZGF0YSBwcm92aWRlclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXlzIHRoYXQgd2VyZSBldmljdGVkXG4gICAqL1xuICBvbkl0ZW1BZGRlZChrZXksIHZhbHVlLCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgZXZpY3RlZEtleXMgPSBbXTtcbiAgICBpZiAoIXRoaXMuZXZpY3Rpb25TdHJhdGVneSkge1xuICAgICAgcmV0dXJuIGV2aWN0ZWRLZXlzO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlVmFsdWVTaXplKHZhbHVlKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNyZWF0ZUV2aWN0aW9uQ29udGV4dChtZXRhZGF0YVByb3ZpZGVyLCBlc3RpbWF0ZWRTaXplKTtcbiAgICAgIGNvbnN0IGtleXNUb0V2aWN0ID0gdGhpcy5ldmljdGlvblN0cmF0ZWd5LnNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpO1xuICAgICAgZm9yIChjb25zdCBldmljdEtleSBvZiBrZXlzVG9FdmljdCkge1xuICAgICAgICB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kub25JdGVtUmVtb3ZlZChldmljdEtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgICAgIGV2aWN0ZWRLZXlzLnB1c2goZXZpY3RLZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5ldmljdGlvblN0cmF0ZWd5Lm9uSXRlbUFkZGVkKGtleSwgZXN0aW1hdGVkU2l6ZSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgICBpZiAoZXZpY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2dnZXIyMC5kZWJ1ZyhcIkl0ZW1zIGV2aWN0ZWQgZHVyaW5nIGFkZGl0aW9uXCIsIHtcbiAgICAgICAgICBuZXdLZXk6IGtleSxcbiAgICAgICAgICBldmljdGVkS2V5cyxcbiAgICAgICAgICBzdHJhdGVneTogdGhpcy5ldmljdGlvblN0cmF0ZWd5LmdldFN0cmF0ZWd5TmFtZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIyMC5lcnJvcihcIkVycm9yIGluIGV2aWN0aW9uIHN0cmF0ZWd5IG9uSXRlbUFkZGVkXCIsIHsga2V5LCBlcnJvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2aWN0ZWRLZXlzO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgaXRlbSByZW1vdmFsIC0gY2xlYW4gdXAgbWV0YWRhdGFcbiAgICogQHBhcmFtIGtleSAtIEl0ZW0ga2V5XG4gICAqIEBwYXJhbSBtZXRhZGF0YVByb3ZpZGVyIC0gQ2FjaGUgbWV0YWRhdGEgcHJvdmlkZXJcbiAgICovXG4gIG9uSXRlbVJlbW92ZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgaWYgKCF0aGlzLmV2aWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjIwLmVycm9yKFwiRXJyb3IgaW4gZXZpY3Rpb24gc3RyYXRlZ3kgb25JdGVtUmVtb3ZlZFwiLCB7IGtleSwgZXJyb3IgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIG1hbnVhbCBldmljdGlvbiBjaGVja1xuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGtleXMgdGhhdCB3ZXJlIGV2aWN0ZWRcbiAgICovXG4gIHBlcmZvcm1FdmljdGlvbihtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgZXZpY3RlZEtleXMgPSBbXTtcbiAgICBpZiAoIXRoaXMuZXZpY3Rpb25TdHJhdGVneSkge1xuICAgICAgcmV0dXJuIGV2aWN0ZWRLZXlzO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY3JlYXRlRXZpY3Rpb25Db250ZXh0KG1ldGFkYXRhUHJvdmlkZXIpO1xuICAgICAgY29uc3Qga2V5c1RvRXZpY3QgPSB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kuc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCk7XG4gICAgICBmb3IgKGNvbnN0IGV2aWN0S2V5IG9mIGtleXNUb0V2aWN0KSB7XG4gICAgICAgIHRoaXMuZXZpY3Rpb25TdHJhdGVneS5vbkl0ZW1SZW1vdmVkKGV2aWN0S2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICAgICAgZXZpY3RlZEtleXMucHVzaChldmljdEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoZXZpY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2dnZXIyMC5kZWJ1ZyhcIk1hbnVhbCBldmljdGlvbiBwZXJmb3JtZWRcIiwge1xuICAgICAgICAgIGV2aWN0ZWRLZXlzLFxuICAgICAgICAgIHN0cmF0ZWd5OiB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kuZ2V0U3RyYXRlZ3lOYW1lKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjIwLmVycm9yKFwiRXJyb3IgaW4gbWFudWFsIGV2aWN0aW9uXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBldmljdGVkS2V5cztcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgZXZpY3Rpb24gaXMgc3VwcG9ydGVkIChpLmUuLCBzdHJhdGVneSBpcyBzZXQpXG4gICAqIEByZXR1cm5zIFRydWUgaWYgZXZpY3Rpb24gaXMgc3VwcG9ydGVkXG4gICAqL1xuICBpc0V2aWN0aW9uU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmV2aWN0aW9uU3RyYXRlZ3kgIT09IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBldmljdGlvbiBjb250ZXh0IGZyb20gY3VycmVudCBjYWNoZSBzdGF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGFQcm92aWRlciAtIENhY2hlIG1ldGFkYXRhIHByb3ZpZGVyXG4gICAqIEBwYXJhbSBuZXdJdGVtU2l6ZSAtIFNpemUgb2YgaXRlbSBiZWluZyBhZGRlZCAob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIEV2aWN0aW9uIGNvbnRleHRcbiAgICovXG4gIGNyZWF0ZUV2aWN0aW9uQ29udGV4dChtZXRhZGF0YVByb3ZpZGVyLCBuZXdJdGVtU2l6ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRTaXplID0gbWV0YWRhdGFQcm92aWRlci5nZXRDdXJyZW50U2l6ZSgpO1xuICAgIGNvbnN0IGxpbWl0cyA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0U2l6ZUxpbWl0cygpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50U2l6ZSxcbiAgICAgIGxpbWl0cyxcbiAgICAgIG5ld0l0ZW1TaXplXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2V2aWN0aW9uL0V2aWN0aW9uU3RyYXRlZ3lDb25maWcudHNcbnZhciBERUZBVUxUX0xGVV9DT05GSUcgPSB7XG4gIHR5cGU6IFwibGZ1XCIsXG4gIGRlY2F5RmFjdG9yOiAwLjEsXG4gIGRlY2F5SW50ZXJ2YWw6IDZlNCxcbiAgLy8gMSBtaW51dGVcbiAgc2tldGNoV2lkdGg6IDEwMjQsXG4gIHNrZXRjaERlcHRoOiA0LFxuICB1c2VQcm9iYWJpbGlzdGljQ291bnRpbmc6IHRydWUsXG4gIG1pbkZyZXF1ZW5jeVRocmVzaG9sZDogMVxufTtcbnZhciBERUZBVUxUX0FSQ19DT05GSUcgPSB7XG4gIHR5cGU6IFwiYXJjXCIsXG4gIG1heENhY2hlU2l6ZTogMWUzLFxuICBmcmVxdWVuY3lUaHJlc2hvbGQ6IDIsXG4gIHVzZUVuaGFuY2VkRnJlcXVlbmN5OiB0cnVlLFxuICBmcmVxdWVuY3lEZWNheUZhY3RvcjogMC4wNSxcbiAgZnJlcXVlbmN5RGVjYXlJbnRlcnZhbDogNmU1LFxuICAvLyAxMCBtaW51dGVzXG4gIHVzZUZyZXF1ZW5jeVdlaWdodGVkU2VsZWN0aW9uOiB0cnVlLFxuICBhZGFwdGl2ZUxlYXJuaW5nUmF0ZTogMVxufTtcbnZhciBERUZBVUxUX1RXT19RVUVVRV9DT05GSUcgPSB7XG4gIHR5cGU6IFwiMnFcIixcbiAgbWF4Q2FjaGVTaXplOiAxZTMsXG4gIHVzZUZyZXF1ZW5jeVByb21vdGlvbjogdHJ1ZSxcbiAgcHJvbW90aW9uVGhyZXNob2xkOiAyLFxuICBob3RRdWV1ZURlY2F5RmFjdG9yOiAwLjA1LFxuICBob3RRdWV1ZURlY2F5SW50ZXJ2YWw6IDNlNSxcbiAgLy8gNSBtaW51dGVzXG4gIHVzZUZyZXF1ZW5jeVdlaWdodGVkTFJVOiB0cnVlXG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneS50c1xudmFyIEV2aWN0aW9uU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgZXZpY3Rpb24gaXMgbmVlZGVkIGJhc2VkIG9uIGN1cnJlbnQgY29udGV4dFxuICAgKiBAcGFyYW0gY29udGV4dCAtIEN1cnJlbnQgY2FjaGUgc3RhdGUgYW5kIGxpbWl0c1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIGV2aWN0aW9uIHNob3VsZCBvY2N1clxuICAgKi9cbiAgaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSB7XG4gICAgY29uc3QgeyBjdXJyZW50U2l6ZSwgbGltaXRzLCBuZXdJdGVtU2l6ZSA9IDAgfSA9IGNvbnRleHQ7XG4gICAgaWYgKGxpbWl0cy5tYXhJdGVtcyAhPT0gbnVsbCAmJiBjdXJyZW50U2l6ZS5pdGVtQ291bnQgPj0gbGltaXRzLm1heEl0ZW1zKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxpbWl0cy5tYXhTaXplQnl0ZXMgIT09IG51bGwgJiYgY3VycmVudFNpemUuc2l6ZUJ5dGVzICsgbmV3SXRlbVNpemUgPiBsaW1pdHMubWF4U2l6ZUJ5dGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgaG93IG1hbnkgaXRlbXMgbmVlZCB0byBiZSBldmljdGVkXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gQ3VycmVudCBjYWNoZSBzdGF0ZSBhbmQgbGltaXRzXG4gICAqIEByZXR1cm5zIE51bWJlciBvZiBpdGVtcyB0aGF0IHNob3VsZCBiZSBldmljdGVkXG4gICAqL1xuICBjYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTaXplLCBsaW1pdHMsIG5ld0l0ZW1TaXplID0gMCB9ID0gY29udGV4dDtcbiAgICBsZXQgZXZpY3Rpb25Db3VudCA9IDA7XG4gICAgaWYgKGxpbWl0cy5tYXhJdGVtcyAhPT0gbnVsbCAmJiBjdXJyZW50U2l6ZS5pdGVtQ291bnQgPj0gbGltaXRzLm1heEl0ZW1zKSB7XG4gICAgICBldmljdGlvbkNvdW50ID0gTWF0aC5tYXgoZXZpY3Rpb25Db3VudCwgY3VycmVudFNpemUuaXRlbUNvdW50IC0gbGltaXRzLm1heEl0ZW1zICsgMSk7XG4gICAgfVxuICAgIGlmIChsaW1pdHMubWF4U2l6ZUJ5dGVzICE9PSBudWxsICYmIGN1cnJlbnRTaXplLnNpemVCeXRlcyArIG5ld0l0ZW1TaXplID4gbGltaXRzLm1heFNpemVCeXRlcykge1xuICAgICAgY29uc3QgZXhjZXNzQnl0ZXMgPSBjdXJyZW50U2l6ZS5zaXplQnl0ZXMgKyBuZXdJdGVtU2l6ZSAtIGxpbWl0cy5tYXhTaXplQnl0ZXM7XG4gICAgICBjb25zdCBhdmdJdGVtU2l6ZSA9IGN1cnJlbnRTaXplLml0ZW1Db3VudCA+IDAgPyBjdXJyZW50U2l6ZS5zaXplQnl0ZXMgLyBjdXJyZW50U2l6ZS5pdGVtQ291bnQgOiAxMDI0O1xuICAgICAgY29uc3QgZXN0aW1hdGVkRXZpY3Rpb25Db3VudCA9IE1hdGguY2VpbChleGNlc3NCeXRlcyAvIGF2Z0l0ZW1TaXplKTtcbiAgICAgIGV2aWN0aW9uQ291bnQgPSBNYXRoLm1heChldmljdGlvbkNvdW50LCBlc3RpbWF0ZWRFdmljdGlvbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2aWN0aW9uQ291bnQ7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmljdGlvbi9zdHJhdGVnaWVzL0xSVUV2aWN0aW9uU3RyYXRlZ3kudHNcbnZhciBMUlVFdmljdGlvblN0cmF0ZWd5ID0gY2xhc3MgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgY29uc3Qga2V5c1RvRXZpY3QgPSBbXTtcbiAgICBjb25zdCBzb3J0ZWRFbnRyaWVzID0gQXJyYXkuZnJvbShhbGxNZXRhZGF0YS5lbnRyaWVzKCkpLnNvcnQoKFssIGFdLCBbLCBiXSkgPT4gYS5sYXN0QWNjZXNzZWRBdCAtIGIubGFzdEFjY2Vzc2VkQXQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oZXZpY3Rpb25Db3VudCwgc29ydGVkRW50cmllcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGtleXNUb0V2aWN0LnB1c2goc29ydGVkRW50cmllc1tpXVswXSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuICBvbkl0ZW1BY2Nlc3NlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuICBvbkl0ZW1BZGRlZChrZXksIGVzdGltYXRlZFNpemUsIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZVxuICAgIH07XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuICBnZXRTdHJhdGVneU5hbWUoKSB7XG4gICAgcmV0dXJuIFwibHJ1XCI7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmljdGlvbi9FdmljdGlvblN0cmF0ZWd5VmFsaWRhdGlvbi50c1xuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgsIGZpZWxkTmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ZpZWxkTmFtZX0gbXVzdCBiZSBhIGZpbml0ZSBudW1iZXJgKTtcbiAgfVxuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGJlIGJldHdlZW4gJHttaW59IGFuZCAke21heH0sIGdvdCAke3ZhbHVlfWApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcih2YWx1ZSwgZmllbGROYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHwgaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGROYW1lfSBtdXN0IGJlIGEgZmluaXRlIG51bWJlcmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtmaWVsZE5hbWV9IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBnb3QgJHt2YWx1ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVMRlVDb25maWcoY29uZmlnKSB7XG4gIGNvbnN0IHNhbml0aXplZCA9IHsgLi4uY29uZmlnIH07XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmRlY2F5RmFjdG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHNhbml0aXplZC5kZWNheUZhY3RvciA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgZGVjYXlGYWN0b3IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGdvdCAke3Nhbml0aXplZC5kZWNheUZhY3Rvcn0uIENvcnJlY3RpbmcgdG8gMC5gKTtcbiAgICAgIHNhbml0aXplZC5kZWNheUZhY3RvciA9IDA7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuZGVjYXlGYWN0b3IgPiAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGRlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuZGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDEuYCk7XG4gICAgICBzYW5pdGl6ZWQuZGVjYXlGYWN0b3IgPSAxO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5kZWNheUludGVydmFsID09PSBcIm51bWJlclwiICYmIHNhbml0aXplZC5kZWNheUludGVydmFsIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYGRlY2F5SW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLmRlY2F5SW50ZXJ2YWx9LiBDb3JyZWN0aW5nIHRvIDMwMDAwMC5gKTtcbiAgICBzYW5pdGl6ZWQuZGVjYXlJbnRlcnZhbCA9IDNlNTtcbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5za2V0Y2hXaWR0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChzYW5pdGl6ZWQuc2tldGNoV2lkdGggPD0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hXaWR0aCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoV2lkdGh9LiBDb3JyZWN0aW5nIHRvIDEwMjQuYCk7XG4gICAgICBzYW5pdGl6ZWQuc2tldGNoV2lkdGggPSAxMDI0O1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLnNrZXRjaFdpZHRoIDwgMTYpIHtcbiAgICAgIGNvbnNvbGUud2Fybihgc2tldGNoV2lkdGggc2hvdWxkIGJlIGF0IGxlYXN0IDE2IGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlLCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoV2lkdGh9LiBDb3JyZWN0aW5nIHRvIDE2LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaFdpZHRoID0gMTY7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuc2tldGNoV2lkdGggPiA2NTUzNikge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hXaWR0aCBzaG91bGQgbm90IGV4Y2VlZCA2NTUzNiBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaFdpZHRofS4gQ29ycmVjdGluZyB0byA2NTUzNi5gKTtcbiAgICAgIHNhbml0aXplZC5za2V0Y2hXaWR0aCA9IDY1NTM2O1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5za2V0Y2hEZXB0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChzYW5pdGl6ZWQuc2tldGNoRGVwdGggPD0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hEZXB0aCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoRGVwdGh9LiBDb3JyZWN0aW5nIHRvIDQuYCk7XG4gICAgICBzYW5pdGl6ZWQuc2tldGNoRGVwdGggPSA0O1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLnNrZXRjaERlcHRoIDwgMSkge1xuICAgICAgY29uc29sZS53YXJuKGBza2V0Y2hEZXB0aCBzaG91bGQgYmUgYXQgbGVhc3QgMSBmb3Igb3B0aW1hbCBhY2N1cmFjeSwgZ290ICR7c2FuaXRpemVkLnNrZXRjaERlcHRofS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaERlcHRoID0gMTtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5za2V0Y2hEZXB0aCA+IDE2KSB7XG4gICAgICBjb25zb2xlLndhcm4oYHNrZXRjaERlcHRoIHNob3VsZCBub3QgZXhjZWVkIDE2IGZvciBvcHRpbWFsIGFjY3VyYWN5LCBnb3QgJHtzYW5pdGl6ZWQuc2tldGNoRGVwdGh9LiBDb3JyZWN0aW5nIHRvIDE2LmApO1xuICAgICAgc2FuaXRpemVkLnNrZXRjaERlcHRoID0gMTY7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA9PT0gXCJudW1iZXJcIiAmJiBzYW5pdGl6ZWQubWluRnJlcXVlbmN5VGhyZXNob2xkIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYG1pbkZyZXF1ZW5jeVRocmVzaG9sZCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQubWluRnJlcXVlbmN5VGhyZXNob2xkfS4gQ29ycmVjdGluZyB0byAxLmApO1xuICAgIHNhbml0aXplZC5taW5GcmVxdWVuY3lUaHJlc2hvbGQgPSAxO1xuICB9XG4gIHJldHVybiBzYW5pdGl6ZWQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxGVUNvbmZpZyhjb25maWcpIHtcbiAgaWYgKHR5cGVvZiBjb25maWcuZGVjYXlGYWN0b3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZU51bWJlclJhbmdlKGNvbmZpZy5kZWNheUZhY3RvciwgMCwgMSwgXCJkZWNheUZhY3RvclwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5kZWNheUludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLmRlY2F5SW50ZXJ2YWwsIFwiZGVjYXlJbnRlcnZhbFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5za2V0Y2hXaWR0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5za2V0Y2hXaWR0aCwgXCJza2V0Y2hXaWR0aFwiKTtcbiAgICBpZiAoY29uZmlnLnNrZXRjaFdpZHRoIDwgMTYgfHwgY29uZmlnLnNrZXRjaFdpZHRoID4gNjU1MzYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2tldGNoV2lkdGggbXVzdCBiZSBiZXR3ZWVuIDE2IGFuZCA2NTUzNiwgZ290ICR7Y29uZmlnLnNrZXRjaFdpZHRofWApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5za2V0Y2hEZXB0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5za2V0Y2hEZXB0aCwgXCJza2V0Y2hEZXB0aFwiKTtcbiAgICBpZiAoY29uZmlnLnNrZXRjaERlcHRoIDwgMSB8fCBjb25maWcuc2tldGNoRGVwdGggPiAxNikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBza2V0Y2hEZXB0aCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMTYsIGdvdCAke2NvbmZpZy5za2V0Y2hEZXB0aH1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcubWluRnJlcXVlbmN5VGhyZXNob2xkID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCwgXCJtaW5GcmVxdWVuY3lUaHJlc2hvbGRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhbml0aXplQVJDQ29uZmlnKGNvbmZpZykge1xuICBjb25zdCBzYW5pdGl6ZWQgPSB7IC4uLmNvbmZpZyB9O1xuICBpZiAodHlwZW9mIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPT09IFwibnVtYmVyXCIgJiYgc2FuaXRpemVkLm1heENhY2hlU2l6ZSA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBtYXhDYWNoZVNpemUgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLm1heENhY2hlU2l6ZX0uIENvcnJlY3RpbmcgdG8gMTAwMC5gKTtcbiAgICBzYW5pdGl6ZWQubWF4Q2FjaGVTaXplID0gMWUzO1xuICB9XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmZyZXF1ZW5jeVRocmVzaG9sZCA9PT0gXCJudW1iZXJcIiAmJiBzYW5pdGl6ZWQuZnJlcXVlbmN5VGhyZXNob2xkIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeVRocmVzaG9sZCBtdXN0IGJlIHBvc2l0aXZlLCBnb3QgJHtzYW5pdGl6ZWQuZnJlcXVlbmN5VGhyZXNob2xkfS4gQ29ycmVjdGluZyB0byAyLmApO1xuICAgIHNhbml0aXplZC5mcmVxdWVuY3lUaHJlc2hvbGQgPSAyO1xuICB9XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5RmFjdG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUZhY3RvciA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgZnJlcXVlbmN5RGVjYXlGYWN0b3IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGdvdCAke3Nhbml0aXplZC5mcmVxdWVuY3lEZWNheUZhY3Rvcn0uIENvcnJlY3RpbmcgdG8gMC5gKTtcbiAgICAgIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUZhY3RvciA9IDA7XG4gICAgfSBlbHNlIGlmIChzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPiAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeURlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3J9LiBDb3JyZWN0aW5nIHRvIDEuYCk7XG4gICAgICBzYW5pdGl6ZWQuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPSAxO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUludGVydmFsID09PSBcIm51bWJlclwiICYmIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUludGVydmFsIDw9IDApIHtcbiAgICBjb25zb2xlLndhcm4oYGZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWx9LiBDb3JyZWN0aW5nIHRvIDYwMDAwLmApO1xuICAgIHNhbml0aXplZC5mcmVxdWVuY3lEZWNheUludGVydmFsID0gNmU0O1xuICB9XG4gIGlmICh0eXBlb2Ygc2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHNhbml0aXplZC5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgYWRhcHRpdmVMZWFybmluZ1JhdGUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwLCBnb3QgJHtzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGV9LiBDb3JyZWN0aW5nIHRvIDAuYCk7XG4gICAgICBzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGUgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlID4gMTApIHtcbiAgICAgIGNvbnNvbGUud2FybihgYWRhcHRpdmVMZWFybmluZ1JhdGUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwLCBnb3QgJHtzYW5pdGl6ZWQuYWRhcHRpdmVMZWFybmluZ1JhdGV9LiBDb3JyZWN0aW5nIHRvIDEwLmApO1xuICAgICAgc2FuaXRpemVkLmFkYXB0aXZlTGVhcm5pbmdSYXRlID0gMTA7XG4gICAgfVxuICB9XG4gIHJldHVybiBzYW5pdGl6ZWQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFSQ0NvbmZpZyhjb25maWcpIHtcbiAgaWYgKHR5cGVvZiBjb25maWcubWF4Q2FjaGVTaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLm1heENhY2hlU2l6ZSwgXCJtYXhDYWNoZVNpemVcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuZnJlcXVlbmN5VGhyZXNob2xkID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLmZyZXF1ZW5jeVRocmVzaG9sZCwgXCJmcmVxdWVuY3lUaHJlc2hvbGRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZU51bWJlclJhbmdlKGNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciwgMCwgMSwgXCJmcmVxdWVuY3lEZWNheUZhY3RvclwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5mcmVxdWVuY3lEZWNheUludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoY29uZmlnLmZyZXF1ZW5jeURlY2F5SW50ZXJ2YWwsIFwiZnJlcXVlbmN5RGVjYXlJbnRlcnZhbFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlTnVtYmVyUmFuZ2UoY29uZmlnLmFkYXB0aXZlTGVhcm5pbmdSYXRlLCAwLCAxMCwgXCJhZGFwdGl2ZUxlYXJuaW5nUmF0ZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVUd29RdWV1ZUNvbmZpZyhjb25maWcpIHtcbiAgY29uc3Qgc2FuaXRpemVkID0geyAuLi5jb25maWcgfTtcbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQubWF4Q2FjaGVTaXplID09PSBcIm51bWJlclwiICYmIHNhbml0aXplZC5tYXhDYWNoZVNpemUgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgbWF4Q2FjaGVTaXplIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5tYXhDYWNoZVNpemV9LiBDb3JyZWN0aW5nIHRvIDEwMDAuYCk7XG4gICAgc2FuaXRpemVkLm1heENhY2hlU2l6ZSA9IDFlMztcbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5wcm9tb3Rpb25UaHJlc2hvbGQgPT09IFwibnVtYmVyXCIgJiYgc2FuaXRpemVkLnByb21vdGlvblRocmVzaG9sZCA8PSAwKSB7XG4gICAgY29uc29sZS53YXJuKGBwcm9tb3Rpb25UaHJlc2hvbGQgbXVzdCBiZSBwb3NpdGl2ZSwgZ290ICR7c2FuaXRpemVkLnByb21vdGlvblRocmVzaG9sZH0uIENvcnJlY3RpbmcgdG8gMi5gKTtcbiAgICBzYW5pdGl6ZWQucHJvbW90aW9uVGhyZXNob2xkID0gMjtcbiAgfVxuICBpZiAodHlwZW9mIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHNhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yIDwgMCkge1xuICAgICAgY29uc29sZS53YXJuKGBob3RRdWV1ZURlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3Rvcn0uIENvcnJlY3RpbmcgdG8gMC5gKTtcbiAgICAgIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yID0gMDtcbiAgICB9IGVsc2UgaWYgKHNhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKGBob3RRdWV1ZURlY2F5RmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHtzYW5pdGl6ZWQuaG90UXVldWVEZWNheUZhY3Rvcn0uIENvcnJlY3RpbmcgdG8gMS5gKTtcbiAgICAgIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5RmFjdG9yID0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUludGVydmFsID09PSBcIm51bWJlclwiICYmIHNhbml0aXplZC5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPD0gMCkge1xuICAgIGNvbnNvbGUud2FybihgaG90UXVldWVEZWNheUludGVydmFsIG11c3QgYmUgcG9zaXRpdmUsIGdvdCAke3Nhbml0aXplZC5ob3RRdWV1ZURlY2F5SW50ZXJ2YWx9LiBDb3JyZWN0aW5nIHRvIDMwMDAwMC5gKTtcbiAgICBzYW5pdGl6ZWQuaG90UXVldWVEZWNheUludGVydmFsID0gM2U1O1xuICB9XG4gIHJldHVybiBzYW5pdGl6ZWQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR3b1F1ZXVlQ29uZmlnKGNvbmZpZykge1xuICBpZiAodHlwZW9mIGNvbmZpZy5tYXhDYWNoZVNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcubWF4Q2FjaGVTaXplLCBcIm1heENhY2hlU2l6ZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5wcm9tb3Rpb25UaHJlc2hvbGQgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcihjb25maWcucHJvbW90aW9uVGhyZXNob2xkLCBcInByb21vdGlvblRocmVzaG9sZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsaWRhdGVOdW1iZXJSYW5nZShjb25maWcuaG90UXVldWVEZWNheUZhY3RvciwgMCwgMSwgXCJob3RRdWV1ZURlY2F5RmFjdG9yXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgY29uZmlnLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKGNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwsIFwiaG90UXVldWVEZWNheUludGVydmFsXCIpO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2aWN0aW9uU3RyYXRlZ3lDb25maWcoY29uZmlnKSB7XG4gIGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWd1cmF0aW9uIG11c3QgYmUgYSBub24tbnVsbCBvYmplY3RcIik7XG4gIH1cbiAgaWYgKCFjb25maWcudHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZ3VyYXRpb24gbXVzdCBzcGVjaWZ5IGEgdHlwZVwiKTtcbiAgfVxuICBjb25zdCB2YWxpZFR5cGVzID0gW1wibGZ1XCIsIFwibHJ1XCIsIFwiZmlmb1wiLCBcIm1ydVwiLCBcInJhbmRvbVwiLCBcImFyY1wiLCBcIjJxXCJdO1xuICBpZiAoIXZhbGlkVHlwZXMuaW5jbHVkZXMoY29uZmlnLnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2aWN0aW9uIHN0cmF0ZWd5IHR5cGU6ICR7Y29uZmlnLnR5cGV9LiBNdXN0IGJlIG9uZSBvZjogJHt2YWxpZFR5cGVzLmpvaW4oXCIsIFwiKX1gKTtcbiAgfVxuICBzd2l0Y2ggKGNvbmZpZy50eXBlKSB7XG4gICAgY2FzZSBcImxmdVwiOlxuICAgICAgdmFsaWRhdGVMRlVDb25maWcoY29uZmlnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhcmNcIjpcbiAgICAgIHZhbGlkYXRlQVJDQ29uZmlnKGNvbmZpZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiMnFcIjpcbiAgICAgIHZhbGlkYXRlVHdvUXVldWVDb25maWcoY29uZmlnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJscnVcIjpcbiAgICBjYXNlIFwiZmlmb1wiOlxuICAgIGNhc2UgXCJtcnVcIjpcbiAgICBjYXNlIFwicmFuZG9tXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBldmljdGlvbiBzdHJhdGVneSB0eXBlOiAke2NvbmZpZy50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUNvbmZpZ0J5VHlwZShjb25maWcpIHtcbiAgaWYgKCFjb25maWcudHlwZSkge1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgIGNhc2UgXCJsZnVcIjpcbiAgICAgIHJldHVybiBzYW5pdGl6ZUxGVUNvbmZpZyhjb25maWcpO1xuICAgIGNhc2UgXCJhcmNcIjpcbiAgICAgIHJldHVybiBzYW5pdGl6ZUFSQ0NvbmZpZyhjb25maWcpO1xuICAgIGNhc2UgXCIycVwiOlxuICAgICAgcmV0dXJuIHNhbml0aXplVHdvUXVldWVDb25maWcoY29uZmlnKTtcbiAgICBjYXNlIFwibHJ1XCI6XG4gICAgY2FzZSBcImZpZm9cIjpcbiAgICBjYXNlIFwibXJ1XCI6XG4gICAgY2FzZSBcInJhbmRvbVwiOlxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdGVkQ29uZmlnKGJhc2VDb25maWcsIHVzZXJDb25maWcpIHtcbiAgY29uc3QgbWVyZ2VkQ29uZmlnID0geyAuLi5iYXNlQ29uZmlnLCAuLi51c2VyQ29uZmlnIH07XG4gIGNvbnN0IHNhbml0aXplZENvbmZpZyA9IHNhbml0aXplQ29uZmlnQnlUeXBlKG1lcmdlZENvbmZpZyk7XG4gIHZhbGlkYXRlRXZpY3Rpb25TdHJhdGVneUNvbmZpZyhzYW5pdGl6ZWRDb25maWcpO1xuICByZXR1cm4gc2FuaXRpemVkQ29uZmlnO1xufVxuXG4vLyBzcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9MRlVFdmljdGlvblN0cmF0ZWd5LnRzXG5mdW5jdGlvbiBmbnYxYUhhc2goa2V5LCBzZWVkKSB7XG4gIGNvbnN0IEZOVl9PRkZTRVRfQkFTSVMgPSAyMTY2MTM2MjYxO1xuICBjb25zdCBGTlZfUFJJTUUgPSAxNjc3NzYxOTtcbiAgbGV0IGhhc2ggPSAoRk5WX09GRlNFVF9CQVNJUyBeIHNlZWQpID4+PiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIGhhc2ggXj0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IGhhc2ggKiBGTlZfUFJJTUUgPj4+IDA7XG4gIH1cbiAgaGFzaCBePSBoYXNoID4+PiAxNjtcbiAgaGFzaCA9IGhhc2ggKiAyMjQ2ODIyNTA3ID4+PiAwO1xuICBoYXNoIF49IGhhc2ggPj4+IDEzO1xuICBoYXNoID0gaGFzaCAqIDMyNjY0ODk5MDkgPj4+IDA7XG4gIGhhc2ggXj0gaGFzaCA+Pj4gMTY7XG4gIHJldHVybiBoYXNoID4+PiAwO1xufVxudmFyIENvdW50TWluU2tldGNoID0gY2xhc3Mge1xuICBza2V0Y2hlcztcbiAgd2lkdGg7XG4gIGRlcHRoO1xuICBzZWVkcztcbiAgY29uc3RydWN0b3Iod2lkdGggPSAxMDI0LCBkZXB0aCA9IDQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuc2tldGNoZXMgPSBBcnJheShkZXB0aCkuZmlsbChudWxsKS5tYXAoKCkgPT4gbmV3IEFycmF5KHdpZHRoKS5maWxsKDApKTtcbiAgICB0aGlzLnNlZWRzID0gQXJyYXkoZGVwdGgpLmZpbGwobnVsbCkubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNikpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIDIgZm9yIG9wdGltaXplZCBiaXQgbWFza2luZ1xuICAgKi9cbiAgaXNQb3dlck9mVHdvKG4pIHtcbiAgICByZXR1cm4gbiA+IDAgJiYgKG4gJiBuIC0gMSkgPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgZnJlcXVlbmN5IGNvdW50IGZvciBhIGtleVxuICAgKi9cbiAgaW5jcmVtZW50KGtleSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXB0aDsgaSsrKSB7XG4gICAgICBjb25zdCBoYXNoID0gZm52MWFIYXNoKGtleSwgdGhpcy5zZWVkc1tpXSk7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaXNQb3dlck9mVHdvKHRoaXMud2lkdGgpID8gaGFzaCAmIHRoaXMud2lkdGggLSAxIDogaGFzaCAlIHRoaXMud2lkdGg7XG4gICAgICB0aGlzLnNrZXRjaGVzW2ldW2luZGV4XSsrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXN0aW1hdGUgdGhlIGZyZXF1ZW5jeSBjb3VudCBmb3IgYSBrZXlcbiAgICovXG4gIGVzdGltYXRlKGtleSkge1xuICAgIGxldCBtaW5Db3VudCA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXB0aDsgaSsrKSB7XG4gICAgICBjb25zdCBoYXNoID0gZm52MWFIYXNoKGtleSwgdGhpcy5zZWVkc1tpXSk7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaXNQb3dlck9mVHdvKHRoaXMud2lkdGgpID8gaGFzaCAmIHRoaXMud2lkdGggLSAxIDogaGFzaCAlIHRoaXMud2lkdGg7XG4gICAgICBtaW5Db3VudCA9IE1hdGgubWluKG1pbkNvdW50LCB0aGlzLnNrZXRjaGVzW2ldW2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiBtaW5Db3VudCA9PT0gSW5maW5pdHkgPyAwIDogbWluQ291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IGRlY2F5IHRvIGFsbCBmcmVxdWVuY2llc1xuICAgKi9cbiAgZGVjYXkoZmFjdG9yKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlcHRoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy53aWR0aDsgaisrKSB7XG4gICAgICAgIHRoaXMuc2tldGNoZXNbaV1bal0gPSBNYXRoLmZsb29yKHRoaXMuc2tldGNoZXNbaV1bal0gKiAoMSAtIGZhY3RvcikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXQgYWxsIGZyZXF1ZW5jaWVzIHRvIHplcm9cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXB0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMud2lkdGg7IGorKykge1xuICAgICAgICB0aGlzLnNrZXRjaGVzW2ldW2pdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgTEZVRXZpY3Rpb25TdHJhdGVneSA9IGNsYXNzIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIGdldFN0cmF0ZWd5TmFtZSgpIHtcbiAgICByZXR1cm4gXCJsZnVcIjtcbiAgfVxuICBjb25maWc7XG4gIHNrZXRjaDtcbiAgbGFzdERlY2F5VGltZTtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IGRlZmF1bHRCYWNrd2FyZHNDb21wYXRpYmxlID0ge1xuICAgICAgdXNlUHJvYmFiaWxpc3RpY0NvdW50aW5nOiBmYWxzZSxcbiAgICAgIGRlY2F5RmFjdG9yOiAwLFxuICAgICAgZGVjYXlJbnRlcnZhbDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSB7IC4uLkRFRkFVTFRfTEZVX0NPTkZJRywgLi4uZGVmYXVsdEJhY2t3YXJkc0NvbXBhdGlibGUgfTtcbiAgICB0aGlzLmNvbmZpZyA9IGNyZWF0ZVZhbGlkYXRlZENvbmZpZyhiYXNlQ29uZmlnLCBjb25maWcpO1xuICAgIHRoaXMuc2tldGNoID0gdGhpcy5jb25maWcudXNlUHJvYmFiaWxpc3RpY0NvdW50aW5nID8gbmV3IENvdW50TWluU2tldGNoKHRoaXMuY29uZmlnLnNrZXRjaFdpZHRoLCB0aGlzLmNvbmZpZy5za2V0Y2hEZXB0aCkgOiBudWxsO1xuICAgIHRoaXMubGFzdERlY2F5VGltZSA9IERhdGUubm93KCk7XG4gIH1cbiAgc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSByZXR1cm4gW107XG4gICAgaWYgKCF0aGlzLmlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBpZiAoZXZpY3Rpb25Db3VudCA8PSAwKSByZXR1cm4gW107XG4gICAgdGhpcy5hcHBseVBlcmlvZGljRGVjYXkoKTtcbiAgICBjb25zdCBzb3J0ZWRFbnRyaWVzID0gQXJyYXkuZnJvbShhbGxNZXRhZGF0YS5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGZyZXFBID0gdGhpcy5nZXRFZmZlY3RpdmVGcmVxdWVuY3koYVswXSwgYVsxXSk7XG4gICAgICBjb25zdCBmcmVxQiA9IHRoaXMuZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KGJbMF0sIGJbMV0pO1xuICAgICAgaWYgKGZyZXFBICE9PSBmcmVxQikge1xuICAgICAgICByZXR1cm4gZnJlcUEgLSBmcmVxQjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhWzFdLmxhc3RBY2Nlc3NlZEF0IC0gYlsxXS5sYXN0QWNjZXNzZWRBdDtcbiAgICB9KTtcbiAgICByZXR1cm4gc29ydGVkRW50cmllcy5zbGljZSgwLCBldmljdGlvbkNvdW50KS5tYXAoKFtrZXldKSA9PiBrZXkpO1xuICB9XG4gIG9uSXRlbUFjY2Vzc2VkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHJldHVybjtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gbm93O1xuICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgaWYgKHRoaXMuc2tldGNoKSB7XG4gICAgICB0aGlzLnNrZXRjaC5pbmNyZW1lbnQoa2V5KTtcbiAgICAgIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSA9IHRoaXMuc2tldGNoLmVzdGltYXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSA9IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIH1cbiAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IHRoaXMuY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGEsIG5vdyk7XG4gICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbUFkZGVkKGtleSwgZXN0aW1hdGVkU2l6ZSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICBrZXksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplLFxuICAgICAgcmF3RnJlcXVlbmN5OiAxXG4gICAgfTtcbiAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IDE7XG4gICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICBpZiAodGhpcy5za2V0Y2gpIHtcbiAgICAgIHRoaXMuc2tldGNoLmluY3JlbWVudChrZXkpO1xuICAgIH1cbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbVJlbW92ZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVmZmVjdGl2ZSBmcmVxdWVuY3kgZm9yIGFuIGl0ZW0sIGFwcGx5aW5nIHJlYWwtdGltZSBkZWNheSBpZiBuZWVkZWRcbiAgICovXG4gIGdldEVmZmVjdGl2ZUZyZXF1ZW5jeShfa2V5LCBtZXRhZGF0YSkge1xuICAgIGlmICgodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgdGltZVNpbmNlVXBkYXRlID0gbm93IC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gdGltZVNpbmNlVXBkYXRlIC8gKHRoaXMuY29uZmlnLmRlY2F5SW50ZXJ2YWwgPz8gNmU0KSAqICh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwLjEpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuY29uZmlnLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA/PyAxLCBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSAqICgxIC0gZGVjYXlBbW91bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhLnJhd0ZyZXF1ZW5jeSB8fCBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIGZyZXF1ZW5jeSBzY29yZSB3aXRoIGRlY2F5IGFwcGxpZWRcbiAgICovXG4gIGNhbGN1bGF0ZUZyZXF1ZW5jeVNjb3JlKG1ldGFkYXRhLCBjdXJyZW50VGltZSkge1xuICAgIGNvbnN0IHJhd0ZyZXEgPSBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJhd0ZyZXE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHJhd0ZyZXE7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IGN1cnJlbnRUaW1lIC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICBjb25zdCBkZWNheUFtb3VudCA9IHRpbWVTaW5jZVVwZGF0ZSAvICh0aGlzLmNvbmZpZy5kZWNheUludGVydmFsID8/IDZlNCkgKiAodGhpcy5jb25maWcuZGVjYXlGYWN0b3IgPz8gMC4xKTtcbiAgICBjb25zdCBwcmV2aW91c1Njb3JlID0gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgfHwgcmF3RnJlcTtcbiAgICBjb25zdCBkZWNheWVkU2NvcmUgPSBwcmV2aW91c1Njb3JlICogKDEgLSBkZWNheUFtb3VudCk7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuY29uZmlnLm1pbkZyZXF1ZW5jeVRocmVzaG9sZCA/PyAxLCBkZWNheWVkU2NvcmUgKyAxKTtcbiAgfVxuICAvKipcbiAgICogQXBwbHkgcGVyaW9kaWMgZGVjYXkgdG8gdGhlIGZyZXF1ZW5jeSBza2V0Y2ggYW5kIG1ldGFkYXRhXG4gICAqL1xuICBhcHBseVBlcmlvZGljRGVjYXkoKSB7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwKSA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZVNpbmNlRGVjYXkgPSBub3cgLSB0aGlzLmxhc3REZWNheVRpbWU7XG4gICAgaWYgKHRpbWVTaW5jZURlY2F5ID49ICh0aGlzLmNvbmZpZy5kZWNheUludGVydmFsID8/IDZlNCkpIHtcbiAgICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgICB0aGlzLnNrZXRjaC5kZWNheSh0aGlzLmNvbmZpZy5kZWNheUZhY3RvciA/PyAwLjEpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gbm93O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgc3RyYXRlZ3lcbiAgICovXG4gIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBmcmVxdWVuY3kgdHJhY2tpbmcgKHVzZWZ1bCBmb3IgdGVzdGluZyBvciBjYWNoZSBjbGVhcmluZylcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgdGhpcy5za2V0Y2gucmVzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2aWN0aW9uL3N0cmF0ZWdpZXMvRklGT0V2aWN0aW9uU3RyYXRlZ3kudHNcbnZhciBGSUZPRXZpY3Rpb25TdHJhdGVneSA9IGNsYXNzIGV4dGVuZHMgRXZpY3Rpb25TdHJhdGVneSB7XG4gIHNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGNvbnN0IGtleXNUb0V2aWN0ID0gW107XG4gICAgY29uc3Qgc29ydGVkRW50cmllcyA9IEFycmF5LmZyb20oYWxsTWV0YWRhdGEuZW50cmllcygpKS5zb3J0KChbLCBhXSwgWywgYl0pID0+IGEuYWRkZWRBdCAtIGIuYWRkZWRBdCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihldmljdGlvbkNvdW50LCBzb3J0ZWRFbnRyaWVzLmxlbmd0aCk7IGkrKykge1xuICAgICAga2V5c1RvRXZpY3QucHVzaChzb3J0ZWRFbnRyaWVzW2ldWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXNUb0V2aWN0O1xuICB9XG4gIG9uSXRlbUFjY2Vzc2VkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcbiAgICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gICAgfVxuICB9XG4gIG9uSXRlbUFkZGVkKGtleSwgZXN0aW1hdGVkU2l6ZSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICBrZXksXG4gICAgICBhZGRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzZWRBdDogbm93LFxuICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICBlc3RpbWF0ZWRTaXplXG4gICAgfTtcbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbVJlbW92ZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgbWV0YWRhdGFQcm92aWRlci5kZWxldGVNZXRhZGF0YShrZXkpO1xuICB9XG4gIGdldFN0cmF0ZWd5TmFtZSgpIHtcbiAgICByZXR1cm4gXCJmaWZvXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmljdGlvbi9zdHJhdGVnaWVzL01SVUV2aWN0aW9uU3RyYXRlZ3kudHNcbnZhciBNUlVFdmljdGlvblN0cmF0ZWd5ID0gY2xhc3MgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgZ2V0U3RyYXRlZ3lOYW1lKCkge1xuICAgIHJldHVybiBcIk1SVVwiO1xuICB9XG4gIHNlbGVjdEZvckV2aWN0aW9uKG1ldGFkYXRhUHJvdmlkZXIsIGNvbnRleHQpIHtcbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBpZiAoYWxsTWV0YWRhdGEuc2l6ZSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgaWYgKGV2aWN0aW9uQ291bnQgPD0gMCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNvcnRlZEVudHJpZXMgPSBBcnJheS5mcm9tKGFsbE1ldGFkYXRhLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIGJbMV0ubGFzdEFjY2Vzc2VkQXQgLSBhWzFdLmxhc3RBY2Nlc3NlZEF0O1xuICAgIH0pO1xuICAgIHJldHVybiBzb3J0ZWRFbnRyaWVzLnNsaWNlKDAsIGV2aWN0aW9uQ291bnQpLm1hcCgoW2tleV0pID0+IGtleSk7XG4gIH1cbiAgb25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuO1xuICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICBtZXRhZGF0YS5hY2Nlc3NDb3VudCsrO1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cbiAgb25JdGVtQWRkZWQoa2V5LCBlc3RpbWF0ZWRTaXplLCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemVcbiAgICB9O1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSk7XG4gIH1cbiAgb25JdGVtUmVtb3ZlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmljdGlvbi9zdHJhdGVnaWVzL1JhbmRvbUV2aWN0aW9uU3RyYXRlZ3kudHNcbnZhciBSYW5kb21FdmljdGlvblN0cmF0ZWd5ID0gY2xhc3MgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5pc0V2aWN0aW9uTmVlZGVkKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGV2aWN0aW9uQ291bnQgPSB0aGlzLmNhbGN1bGF0ZUV2aWN0aW9uQ291bnQoY29udGV4dCk7XG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20oYWxsTWV0YWRhdGEua2V5cygpKTtcbiAgICBjb25zdCBrZXlzVG9FdmljdCA9IFtdO1xuICAgIGNvbnN0IGF2YWlsYWJsZUtleXMgPSBbLi4ua2V5c107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihldmljdGlvbkNvdW50LCBhdmFpbGFibGVLZXlzLmxlbmd0aCk7IGkrKykge1xuICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhdmFpbGFibGVLZXlzLmxlbmd0aCk7XG4gICAgICBrZXlzVG9FdmljdC5wdXNoKGF2YWlsYWJsZUtleXMuc3BsaWNlKHJhbmRvbUluZGV4LCAxKVswXSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuICBvbkl0ZW1BY2Nlc3NlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIG1ldGFkYXRhLmFjY2Vzc0NvdW50Kys7XG4gICAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuICBvbkl0ZW1BZGRlZChrZXksIGVzdGltYXRlZFNpemUsIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAga2V5LFxuICAgICAgYWRkZWRBdDogbm93LFxuICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgZXN0aW1hdGVkU2l6ZVxuICAgIH07XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIG1ldGFkYXRhKTtcbiAgfVxuICBvbkl0ZW1SZW1vdmVkKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuZGVsZXRlTWV0YWRhdGEoa2V5KTtcbiAgfVxuICBnZXRTdHJhdGVneU5hbWUoKSB7XG4gICAgcmV0dXJuIFwicmFuZG9tXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmljdGlvbi9zdHJhdGVnaWVzL0FSQ0V2aWN0aW9uU3RyYXRlZ3kudHNcbnZhciBBUkNFdmljdGlvblN0cmF0ZWd5ID0gY2xhc3MgZXh0ZW5kcyBFdmljdGlvblN0cmF0ZWd5IHtcbiAgZ2V0U3RyYXRlZ3lOYW1lKCkge1xuICAgIHJldHVybiBcIkFSQ1wiO1xuICB9XG4gIHJlY2VudEdob3N0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8vIFQxIGdob3N0IGVudHJpZXNcbiAgZnJlcXVlbnRHaG9zdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAvLyBUMiBnaG9zdCBlbnRyaWVzXG4gIHRhcmdldFJlY2VudFNpemUgPSAwO1xuICAvLyBUYXJnZXQgc2l6ZSBmb3IgVDEgKHJlY2VudCBlbnRyaWVzKVxuICBjb25maWc7XG4gIG1heEdob3N0U2l6ZTtcbiAgbGFzdERlY2F5VGltZTtcbiAgY29uc3RydWN0b3IobWF4Q2FjaGVTaXplID0gMWUzLCBjb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHsgLi4uREVGQVVMVF9BUkNfQ09ORklHLCBtYXhDYWNoZVNpemUgfTtcbiAgICB0aGlzLmNvbmZpZyA9IGNyZWF0ZVZhbGlkYXRlZENvbmZpZyhiYXNlQ29uZmlnLCBjb25maWcpO1xuICAgIHRoaXMubWF4R2hvc3RTaXplID0gdGhpcy5jb25maWcubWF4Q2FjaGVTaXplO1xuICAgIHRoaXMubGFzdERlY2F5VGltZSA9IERhdGUubm93KCk7XG4gIH1cbiAgc2VsZWN0Rm9yRXZpY3Rpb24obWV0YWRhdGFQcm92aWRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IGFsbE1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRBbGxNZXRhZGF0YSgpO1xuICAgIGlmIChhbGxNZXRhZGF0YS5zaXplID09PSAwKSByZXR1cm4gW107XG4gICAgaWYgKCF0aGlzLmlzRXZpY3Rpb25OZWVkZWQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZXZpY3Rpb25Db3VudCA9IHRoaXMuY2FsY3VsYXRlRXZpY3Rpb25Db3VudChjb250ZXh0KTtcbiAgICBpZiAoZXZpY3Rpb25Db3VudCA8PSAwKSByZXR1cm4gW107XG4gICAgdGhpcy5hcHBseVBlcmlvZGljRGVjYXkoYWxsTWV0YWRhdGEpO1xuICAgIGNvbnN0IHJlY2VudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBmcmVxdWVudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIG1ldGFkYXRhXSBvZiBhbGxNZXRhZGF0YSkge1xuICAgICAgaWYgKHRoaXMuaXNGcmVxdWVudEl0ZW0obWV0YWRhdGEpKSB7XG4gICAgICAgIGZyZXF1ZW50SXRlbXMuc2V0KGtleSwgbWV0YWRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjZW50SXRlbXMuc2V0KGtleSwgbWV0YWRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXlzVG9FdmljdCA9IFtdO1xuICAgIGNvbnN0IHRvdGFsSXRlbXMgPSByZWNlbnRJdGVtcy5zaXplICsgZnJlcXVlbnRJdGVtcy5zaXplO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1pbihldmljdGlvbkNvdW50LCB0b3RhbEl0ZW1zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgbGV0IGtleVRvRXZpY3QgPSBudWxsO1xuICAgICAgbGV0IHNvdXJjZUxpc3QgPSBudWxsO1xuICAgICAgaWYgKHJlY2VudEl0ZW1zLnNpemUgPiB0aGlzLnRhcmdldFJlY2VudFNpemUgJiYgcmVjZW50SXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAga2V5VG9FdmljdCA9IHRoaXMuY29uZmlnLnVzZUZyZXF1ZW5jeVdlaWdodGVkU2VsZWN0aW9uID8gdGhpcy5zZWxlY3RGcmVxdWVuY3lXZWlnaHRlZEZyb21JdGVtcyhyZWNlbnRJdGVtcywgXCJyZWNlbnRcIikgOiB0aGlzLnNlbGVjdExSVUZyb21JdGVtcyhyZWNlbnRJdGVtcyk7XG4gICAgICAgIHNvdXJjZUxpc3QgPSByZWNlbnRJdGVtcztcbiAgICAgIH0gZWxzZSBpZiAoZnJlcXVlbnRJdGVtcy5zaXplID4gMCkge1xuICAgICAgICBrZXlUb0V2aWN0ID0gdGhpcy5jb25maWcudXNlRnJlcXVlbmN5V2VpZ2h0ZWRTZWxlY3Rpb24gPyB0aGlzLnNlbGVjdEZyZXF1ZW5jeVdlaWdodGVkRnJvbUl0ZW1zKGZyZXF1ZW50SXRlbXMsIFwiZnJlcXVlbnRcIikgOiB0aGlzLnNlbGVjdExSVUZyb21JdGVtcyhmcmVxdWVudEl0ZW1zKTtcbiAgICAgICAgc291cmNlTGlzdCA9IGZyZXF1ZW50SXRlbXM7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VudEl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgIGtleVRvRXZpY3QgPSB0aGlzLmNvbmZpZy51c2VGcmVxdWVuY3lXZWlnaHRlZFNlbGVjdGlvbiA/IHRoaXMuc2VsZWN0RnJlcXVlbmN5V2VpZ2h0ZWRGcm9tSXRlbXMocmVjZW50SXRlbXMsIFwicmVjZW50XCIpIDogdGhpcy5zZWxlY3RMUlVGcm9tSXRlbXMocmVjZW50SXRlbXMpO1xuICAgICAgICBzb3VyY2VMaXN0ID0gcmVjZW50SXRlbXM7XG4gICAgICB9XG4gICAgICBpZiAoa2V5VG9FdmljdCAmJiBzb3VyY2VMaXN0KSB7XG4gICAgICAgIGtleXNUb0V2aWN0LnB1c2goa2V5VG9FdmljdCk7XG4gICAgICAgIHNvdXJjZUxpc3QuZGVsZXRlKGtleVRvRXZpY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocmVjZW50SXRlbXMuc2l6ZSA9PT0gMCAmJiBmcmVxdWVudEl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzVG9FdmljdDtcbiAgfVxuICBzZWxlY3RMUlVGcm9tSXRlbXMoaXRlbXMpIHtcbiAgICBpZiAoaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBvbGRlc3RLZXkgPSBudWxsO1xuICAgIGxldCBvbGRlc3RUaW1lID0gSW5maW5pdHk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIG1ldGFkYXRhXSBvZiBpdGVtcykge1xuICAgICAgaWYgKCFtZXRhZGF0YSB8fCB0eXBlb2YgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgIT09IFwibnVtYmVyXCIgfHwgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPiBub3cpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPCBvbGRlc3RUaW1lKSB7XG4gICAgICAgIG9sZGVzdFRpbWUgPSBtZXRhZGF0YS5sYXN0QWNjZXNzZWRBdDtcbiAgICAgICAgb2xkZXN0S2V5ID0ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkZXN0S2V5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2xkZXN0S2V5O1xuICAgIH1cbiAgICBpZiAoaXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5ID0gaXRlbXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBmaXJzdEtleSA/PyBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBvbkl0ZW1BY2Nlc3NlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhKSByZXR1cm47XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB1cGRhdGVkTWV0YWRhdGEgPSB7XG4gICAgICAuLi5tZXRhZGF0YSxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogbWV0YWRhdGEuYWNjZXNzQ291bnQgKyAxXG4gICAgfTtcbiAgICB1cGRhdGVkTWV0YWRhdGEucmF3RnJlcXVlbmN5ID0gdXBkYXRlZE1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIGlmICh0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSAmJiAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICB1cGRhdGVkTWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUZyZXF1ZW5jeVNjb3JlKHVwZGF0ZWRNZXRhZGF0YSwgbm93KTtcbiAgICAgIHVwZGF0ZWRNZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgIH1cbiAgICBjb25zdCBsZWFybmluZ1JhdGUgPSB0aGlzLmNvbmZpZy5hZGFwdGl2ZUxlYXJuaW5nUmF0ZSA/PyAxO1xuICAgIGxldCB0YXJnZXRBZGp1c3RlZCA9IGZhbHNlO1xuICAgIGlmIChsZWFybmluZ1JhdGUgPiAwKSB7XG4gICAgICBpZiAodGhpcy5yZWNlbnRHaG9zdHMuaGFzKGtleSkpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChsZWFybmluZ1JhdGUpKTtcbiAgICAgICAgdGhpcy50YXJnZXRSZWNlbnRTaXplID0gTWF0aC5taW4odGhpcy50YXJnZXRSZWNlbnRTaXplICsgYWRqdXN0bWVudCwgdGhpcy5tYXhHaG9zdFNpemUpO1xuICAgICAgICB0aGlzLnJlY2VudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICAgICAgdGFyZ2V0QWRqdXN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZyZXF1ZW50R2hvc3RzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwobGVhcm5pbmdSYXRlKSk7XG4gICAgICAgIHRoaXMudGFyZ2V0UmVjZW50U2l6ZSA9IE1hdGgubWF4KHRoaXMudGFyZ2V0UmVjZW50U2l6ZSAtIGFkanVzdG1lbnQsIDApO1xuICAgICAgICB0aGlzLmZyZXF1ZW50R2hvc3RzLmRlbGV0ZShrZXkpO1xuICAgICAgICB0YXJnZXRBZGp1c3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnJlY2VudEdob3N0cy5oYXMoa2V5KSkge1xuICAgICAgICB0aGlzLnJlY2VudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmVxdWVudEdob3N0cy5oYXMoa2V5KSkge1xuICAgICAgICB0aGlzLmZyZXF1ZW50R2hvc3RzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0QWRqdXN0ZWQpIHtcbiAgICAgIHRoaXMuY2xlYW51cEdob3N0TGlzdHMoKTtcbiAgICB9XG4gICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIHVwZGF0ZWRNZXRhZGF0YSk7XG4gIH1cbiAgb25JdGVtQWRkZWQoa2V5LCBlc3RpbWF0ZWRTaXplLCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgIGtleSxcbiAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY2Nlc3NlZEF0OiBub3csXG4gICAgICBhY2Nlc3NDb3VudDogMSxcbiAgICAgIGVzdGltYXRlZFNpemUsXG4gICAgICByYXdGcmVxdWVuY3k6IDFcbiAgICB9O1xuICAgIGlmICh0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSAmJiAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IDE7XG4gICAgICBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgIH1cbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbVJlbW92ZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKG1ldGFkYXRhICYmIHRoaXMuaXNGcmVxdWVudEl0ZW0obWV0YWRhdGEpKSB7XG4gICAgICB0aGlzLmFkZFRvRnJlcXVlbnRHaG9zdHMoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRUb1JlY2VudEdob3N0cyhrZXkpO1xuICAgIH1cbiAgICBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gICAgdGhpcy5jbGVhbnVwR2hvc3RMaXN0cygpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQga2V5IHRvIHJlY2VudCBnaG9zdCBsaXN0IHdpdGggcHJvcGVyIHNpemUgbWFuYWdlbWVudFxuICAgKi9cbiAgYWRkVG9SZWNlbnRHaG9zdHMoa2V5KSB7XG4gICAgdGhpcy5mcmVxdWVudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICB0aGlzLnJlY2VudEdob3N0cy5hZGQoa2V5KTtcbiAgICB0aGlzLmVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQodGhpcy5yZWNlbnRHaG9zdHMsIHRoaXMubWF4R2hvc3RTaXplKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGtleSB0byBmcmVxdWVudCBnaG9zdCBsaXN0IHdpdGggcHJvcGVyIHNpemUgbWFuYWdlbWVudFxuICAgKi9cbiAgYWRkVG9GcmVxdWVudEdob3N0cyhrZXkpIHtcbiAgICB0aGlzLnJlY2VudEdob3N0cy5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmZyZXF1ZW50R2hvc3RzLmFkZChrZXkpO1xuICAgIHRoaXMuZW5mb3JjZUdob3N0TGlzdFNpemVMaW1pdCh0aGlzLmZyZXF1ZW50R2hvc3RzLCB0aGlzLm1heEdob3N0U2l6ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFudXAgZ2hvc3QgbGlzdHMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICovXG4gIGNsZWFudXBHaG9zdExpc3RzKCkge1xuICAgIHRoaXMuZW5mb3JjZUdob3N0TGlzdFNpemVMaW1pdCh0aGlzLnJlY2VudEdob3N0cywgdGhpcy5tYXhHaG9zdFNpemUpO1xuICAgIHRoaXMuZW5mb3JjZUdob3N0TGlzdFNpemVMaW1pdCh0aGlzLmZyZXF1ZW50R2hvc3RzLCB0aGlzLm1heEdob3N0U2l6ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuZm9yY2Ugc2l6ZSBsaW1pdCBvbiBhIGdob3N0IGxpc3QgYnkgcmVtb3Zpbmcgb2xkZXN0IGVudHJpZXNcbiAgICovXG4gIGVuZm9yY2VHaG9zdExpc3RTaXplTGltaXQoZ2hvc3RMaXN0LCBtYXhTaXplKSB7XG4gICAgaWYgKG1heFNpemUgPD0gMCkge1xuICAgICAgZ2hvc3RMaXN0LmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2hvc3RMaXN0LnZhbHVlcygpO1xuICAgIHdoaWxlIChnaG9zdExpc3Quc2l6ZSA+IG1heFNpemUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZ2hvc3RMaXN0LmRlbGV0ZShuZXh0LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhbiBpdGVtIHNob3VsZCBiZSBjbGFzc2lmaWVkIGFzIGZyZXF1ZW50IHZzIHJlY2VudFxuICAgKi9cbiAgaXNGcmVxdWVudEl0ZW0obWV0YWRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnVzZUVuaGFuY2VkRnJlcXVlbmN5KSB7XG4gICAgICByZXR1cm4gbWV0YWRhdGEuYWNjZXNzQ291bnQgPiAxO1xuICAgIH1cbiAgICBjb25zdCBmcmVxdWVuY3kgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YSk7XG4gICAgcmV0dXJuIGZyZXF1ZW5jeSA+PSAodGhpcy5jb25maWcuZnJlcXVlbmN5VGhyZXNob2xkID8/IDIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZWZmZWN0aXZlIGZyZXF1ZW5jeSBmb3IgYW4gaXRlbSwgYXBwbHlpbmcgZGVjYXkgaWYgZW5hYmxlZFxuICAgKi9cbiAgZ2V0RWZmZWN0aXZlRnJlcXVlbmN5KG1ldGFkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy51c2VFbmhhbmNlZEZyZXF1ZW5jeSB8fCAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgdGltZVNpbmNlVXBkYXRlID0gbm93IC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICAgIGNvbnN0IGRlY2F5SW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUludGVydmFsID8/IDZlNTtcbiAgICAgIGlmICh0aW1lU2luY2VVcGRhdGUgPiBkZWNheUludGVydmFsIC8gMTApIHtcbiAgICAgICAgY29uc3QgZGVjYXlBbW91bnQgPSBNYXRoLm1pbigwLjksIHRpbWVTaW5jZVVwZGF0ZSAvIGRlY2F5SW50ZXJ2YWwgKiAodGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMC4wNSkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMSwgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmU7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSBhcHBsaWVkXG4gICAqL1xuICBjYWxjdWxhdGVGcmVxdWVuY3lTY29yZShtZXRhZGF0YSwgY3VycmVudFRpbWUpIHtcbiAgICBjb25zdCByYXdGcmVxID0gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHJhd0ZyZXE7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IGN1cnJlbnRUaW1lIC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICBjb25zdCBkZWNheUludGVydmFsID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA/PyA2ZTU7XG4gICAgY29uc3QgZGVjYXlGYWN0b3IgPSB0aGlzLmNvbmZpZy5mcmVxdWVuY3lEZWNheUZhY3RvciA/PyAwLjA1O1xuICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gTWF0aC5taW4oMC45LCB0aW1lU2luY2VVcGRhdGUgLyBkZWNheUludGVydmFsICogZGVjYXlGYWN0b3IpO1xuICAgIGNvbnN0IHByZXZpb3VzU2NvcmUgPSBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSB8fCByYXdGcmVxO1xuICAgIGNvbnN0IGRlY2F5ZWRTY29yZSA9IE1hdGgubWF4KDEsIHByZXZpb3VzU2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KDEsIGRlY2F5ZWRTY29yZSArIDEpO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgZXZpY3Rpb24gY2FuZGlkYXRlIHVzaW5nIGZyZXF1ZW5jeS13ZWlnaHRlZCBhcHByb2FjaFxuICAgKi9cbiAgc2VsZWN0RnJlcXVlbmN5V2VpZ2h0ZWRGcm9tSXRlbXMoaXRlbXMsIGNvbnRleHQpIHtcbiAgICBpZiAoaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBiZXN0S2V5ID0gbnVsbDtcbiAgICBsZXQgYmVzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIG1ldGFkYXRhXSBvZiBpdGVtcykge1xuICAgICAgaWYgKCFtZXRhZGF0YSB8fCB0eXBlb2YgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgIT09IFwibnVtYmVyXCIgfHwgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPiBub3cpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmcmVxdWVuY3kgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YSk7XG4gICAgICBjb25zdCB0aW1lRmFjdG9yID0gTWF0aC5tYXgoMCwgbm93IC0gbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQpO1xuICAgICAgbGV0IHNjb3JlO1xuICAgICAgaWYgKGNvbnRleHQgPT09IFwicmVjZW50XCIpIHtcbiAgICAgICAgc2NvcmUgPSB0aW1lRmFjdG9yICsgMWUzIC8gTWF0aC5tYXgoMSwgZnJlcXVlbmN5KTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gXCJmcmVxdWVudFwiKSB7XG4gICAgICAgIHNjb3JlID0gdGltZUZhY3RvciAvIDFlMyArIDEwIC8gTWF0aC5tYXgoMSwgZnJlcXVlbmN5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3JlID0gdGltZUZhY3RvciAvIDFlMyAvIE1hdGgubWF4KDEsIGZyZXF1ZW5jeSk7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcmUgPCBiZXN0U2NvcmUpIHtcbiAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgIGJlc3RLZXkgPSBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0S2V5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmVzdEtleTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdEtleSA9IGl0ZW1zLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gZmlyc3RLZXkgPz8gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IHBlcmlvZGljIGRlY2F5IHRvIGZyZXF1ZW5jeSBzY29yZXNcbiAgICovXG4gIGFwcGx5UGVyaW9kaWNEZWNheShpdGVtcykge1xuICAgIGlmICghdGhpcy5jb25maWcudXNlRW5oYW5jZWRGcmVxdWVuY3kgfHwgKHRoaXMuY29uZmlnLmZyZXF1ZW5jeURlY2F5RmFjdG9yID8/IDApID09PSAwKSByZXR1cm47XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lU2luY2VEZWNheSA9IG5vdyAtIHRoaXMubGFzdERlY2F5VGltZTtcbiAgICBjb25zdCBkZWNheUludGVydmFsID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlJbnRlcnZhbCA/PyA2ZTU7XG4gICAgaWYgKHRpbWVTaW5jZURlY2F5ID49IGRlY2F5SW50ZXJ2YWwgJiYgaXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGRlY2F5RmFjdG9yID0gdGhpcy5jb25maWcuZnJlcXVlbmN5RGVjYXlGYWN0b3IgPz8gMC4wNTtcbiAgICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2YgaXRlbXMudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnN0IGludGVydmFsc1Bhc3NlZCA9IHRpbWVTaW5jZURlY2F5IC8gZGVjYXlJbnRlcnZhbDtcbiAgICAgICAgICBjb25zdCB0b3RhbERlY2F5ID0gTWF0aC5taW4oMC45LCBkZWNheUZhY3RvciAqIGludGVydmFsc1Bhc3NlZCk7XG4gICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSAqICgxIC0gdG90YWxEZWNheSk7XG4gICAgICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSBNYXRoLm1heCgxLCBuZXdTY29yZSk7XG4gICAgICAgICAgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9IG5vdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gbm93O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgc3RyYXRlZ3lcbiAgICovXG4gIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBpbnRlcm5hbCBzdGF0ZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5yZWNlbnRHaG9zdHMuY2xlYXIoKTtcbiAgICB0aGlzLmZyZXF1ZW50R2hvc3RzLmNsZWFyKCk7XG4gICAgdGhpcy50YXJnZXRSZWNlbnRTaXplID0gMDtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBhZGFwdGl2ZSBzdGF0ZSBmb3IgbW9uaXRvcmluZy9kZWJ1Z2dpbmdcbiAgICovXG4gIGdldEFkYXB0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldFJlY2VudFNpemU6IHRoaXMudGFyZ2V0UmVjZW50U2l6ZSxcbiAgICAgIHJlY2VudEdob3N0U2l6ZTogdGhpcy5yZWNlbnRHaG9zdHMuc2l6ZSxcbiAgICAgIGZyZXF1ZW50R2hvc3RTaXplOiB0aGlzLmZyZXF1ZW50R2hvc3RzLnNpemVcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vc3RyYXRlZ2llcy9Ud29RdWV1ZUV2aWN0aW9uU3RyYXRlZ3kudHNcbnZhciBUd29RdWV1ZUV2aWN0aW9uU3RyYXRlZ3kgPSBjbGFzcyBleHRlbmRzIEV2aWN0aW9uU3RyYXRlZ3kge1xuICBnZXRTdHJhdGVneU5hbWUoKSB7XG4gICAgcmV0dXJuIFwiMlFcIjtcbiAgfVxuICByZWNlbnRRdWV1ZSA9IFtdO1xuICAvLyBBMSBxdWV1ZSBmb3IgcmVjZW50IGl0ZW1zXG4gIGhvdFF1ZXVlID0gW107XG4gIC8vIEFtIHF1ZXVlIGZvciBob3QgaXRlbXNcbiAgZ2hvc3RRdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8vIEExb3V0IGdob3N0IHF1ZXVlXG4gIGNvbmZpZztcbiAgbWF4UmVjZW50U2l6ZTtcbiAgbWF4R2hvc3RTaXplO1xuICBsYXN0RGVjYXlUaW1lO1xuICBjb25zdHJ1Y3RvcihtYXhDYWNoZVNpemUgPSAxZTMsIGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0geyAuLi5ERUZBVUxUX1RXT19RVUVVRV9DT05GSUcsIG1heENhY2hlU2l6ZSB9O1xuICAgIHRoaXMuY29uZmlnID0gY3JlYXRlVmFsaWRhdGVkQ29uZmlnKGJhc2VDb25maWcsIGNvbmZpZyk7XG4gICAgdGhpcy5tYXhSZWNlbnRTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0aGlzLmNvbmZpZy5tYXhDYWNoZVNpemUgKiAwLjI1KSk7XG4gICAgdGhpcy5tYXhHaG9zdFNpemUgPSB0aGlzLmNvbmZpZy5tYXhDYWNoZVNpemU7XG4gICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuICBzZWxlY3RGb3JFdmljdGlvbihtZXRhZGF0YVByb3ZpZGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYWxsTWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldEFsbE1ldGFkYXRhKCk7XG4gICAgaWYgKGFsbE1ldGFkYXRhLnNpemUgPT09IDApIHJldHVybiBbXTtcbiAgICBpZiAoIXRoaXMuaXNFdmljdGlvbk5lZWRlZChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBldmljdGlvbkNvdW50ID0gdGhpcy5jYWxjdWxhdGVFdmljdGlvbkNvdW50KGNvbnRleHQpO1xuICAgIGlmIChldmljdGlvbkNvdW50IDw9IDApIHJldHVybiBbXTtcbiAgICB0aGlzLmFwcGx5UGVyaW9kaWNEZWNheShhbGxNZXRhZGF0YSk7XG4gICAgY29uc3Qga2V5c1RvRXZpY3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2aWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgbGV0IGtleVRvRXZpY3QgPSBudWxsO1xuICAgICAgZm9yIChsZXQgaiA9IHRoaXMucmVjZW50UXVldWUubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5yZWNlbnRRdWV1ZVtqXTtcbiAgICAgICAgaWYgKGFsbE1ldGFkYXRhLmhhcyhrZXkpICYmICFrZXlzVG9FdmljdC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAga2V5VG9FdmljdCA9IGtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFrZXlUb0V2aWN0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy51c2VGcmVxdWVuY3lXZWlnaHRlZExSVSkge1xuICAgICAgICAgIGtleVRvRXZpY3QgPSB0aGlzLnNlbGVjdEZyb21Ib3RRdWV1ZUZyZXF1ZW5jeVdlaWdodGVkKGFsbE1ldGFkYXRhLCBrZXlzVG9FdmljdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5VG9FdmljdCA9IHRoaXMuc2VsZWN0RnJvbUhvdFF1ZXVlTFJVKGFsbE1ldGFkYXRhLCBrZXlzVG9FdmljdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXlUb0V2aWN0KSB7XG4gICAgICAgIGtleXNUb0V2aWN0LnB1c2goa2V5VG9FdmljdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXNUb0V2aWN0O1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgZXZpY3Rpb24gY2FuZGlkYXRlIGZyb20gaG90IHF1ZXVlIHVzaW5nIHRyYWRpdGlvbmFsIExSVVxuICAgKi9cbiAgc2VsZWN0RnJvbUhvdFF1ZXVlTFJVKGl0ZW1zLCBleGNsdWRlS2V5cyA9IFtdKSB7XG4gICAgbGV0IG9sZGVzdEtleSA9IG51bGw7XG4gICAgbGV0IG9sZGVzdFRpbWUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmhvdFF1ZXVlKSB7XG4gICAgICBpZiAoZXhjbHVkZUtleXMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGl0ZW1zLmdldChrZXkpO1xuICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0IDwgb2xkZXN0VGltZSkge1xuICAgICAgICBvbGRlc3RUaW1lID0gbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQ7XG4gICAgICAgIG9sZGVzdEtleSA9IGtleTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9sZGVzdEtleSB8fCAoaXRlbXMuc2l6ZSA+IDAgPyBpdGVtcy5rZXlzKCkubmV4dCgpLnZhbHVlID8/IG51bGwgOiBudWxsKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IGV2aWN0aW9uIGNhbmRpZGF0ZSBmcm9tIGhvdCBxdWV1ZSB1c2luZyBmcmVxdWVuY3ktd2VpZ2h0ZWQgTFJVXG4gICAqL1xuICBzZWxlY3RGcm9tSG90UXVldWVGcmVxdWVuY3lXZWlnaHRlZChpdGVtcywgZXhjbHVkZUtleXMgPSBbXSkge1xuICAgIGxldCBiZXN0S2V5ID0gbnVsbDtcbiAgICBsZXQgbG93ZXN0U2NvcmUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmhvdFF1ZXVlKSB7XG4gICAgICBpZiAoZXhjbHVkZUtleXMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGl0ZW1zLmdldChrZXkpO1xuICAgICAgaWYgKCFtZXRhZGF0YSkgY29udGludWU7XG4gICAgICBjb25zdCBmcmVxdWVuY3kgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YSk7XG4gICAgICBjb25zdCB0aW1lRmFjdG9yID0gRGF0ZS5ub3coKSAtIG1ldGFkYXRhLmxhc3RBY2Nlc3NlZEF0O1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFRpbWVGYWN0b3IgPSB0aW1lRmFjdG9yIC8gKDFlMyAqIDYwKTtcbiAgICAgIGNvbnN0IHNjb3JlID0gbm9ybWFsaXplZFRpbWVGYWN0b3IgLyBNYXRoLm1heCgxLCBmcmVxdWVuY3kpO1xuICAgICAgaWYgKHNjb3JlIDwgbG93ZXN0U2NvcmUpIHtcbiAgICAgICAgbG93ZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgYmVzdEtleSA9IGtleTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3RLZXkgfHwgKGl0ZW1zLnNpemUgPiAwID8gaXRlbXMua2V5cygpLm5leHQoKS52YWx1ZSA/PyBudWxsIDogbnVsbCk7XG4gIH1cbiAgb25JdGVtQWNjZXNzZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbWV0YWRhdGEubGFzdEFjY2Vzc2VkQXQgPSBub3c7XG4gICAgbWV0YWRhdGEuYWNjZXNzQ291bnQrKztcbiAgICBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgPSBtZXRhZGF0YS5hY2Nlc3NDb3VudDtcbiAgICBpZiAoKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMCkgPiAwKSB7XG4gICAgICBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9IHRoaXMuY2FsY3VsYXRlRnJlcXVlbmN5U2NvcmUobWV0YWRhdGEsIG5vdyk7XG4gICAgICBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRJbmRleCA9IHRoaXMucmVjZW50UXVldWUuaW5kZXhPZihrZXkpO1xuICAgIGlmIChyZWNlbnRJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFByb21vdGVUb0hvdFF1ZXVlKG1ldGFkYXRhKSkge1xuICAgICAgICB0aGlzLnJlY2VudFF1ZXVlLnNwbGljZShyZWNlbnRJbmRleCwgMSk7XG4gICAgICAgIHRoaXMuaG90UXVldWUudW5zaGlmdChrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBob3RJbmRleCA9IHRoaXMuaG90UXVldWUuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGhvdEluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmhvdFF1ZXVlLnNwbGljZShob3RJbmRleCwgMSk7XG4gICAgICAgIHRoaXMuaG90UXVldWUudW5zaGlmdChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbUFkZGVkKGtleSwgZXN0aW1hdGVkU2l6ZSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIGFkZGVkQXQ6IG5vdyxcbiAgICAgICAgbGFzdEFjY2Vzc2VkQXQ6IG5vdyxcbiAgICAgICAgYWNjZXNzQ291bnQ6IDEsXG4gICAgICAgIGVzdGltYXRlZFNpemUsXG4gICAgICAgIHJhd0ZyZXF1ZW5jeTogMVxuICAgICAgfTtcbiAgICAgIGlmICgodGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwKSA+IDApIHtcbiAgICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSAxO1xuICAgICAgICBtZXRhZGF0YS5sYXN0RnJlcXVlbmN5VXBkYXRlID0gbm93O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5naG9zdFF1ZXVlLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmdob3N0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmhvdFF1ZXVlLnVuc2hpZnQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWNlbnRRdWV1ZS51bnNoaWZ0KGtleSk7XG4gICAgICBpZiAodGhpcy5yZWNlbnRRdWV1ZS5sZW5ndGggPiB0aGlzLm1heFJlY2VudFNpemUpIHtcbiAgICAgICAgY29uc3QgZXZpY3RlZCA9IHRoaXMucmVjZW50UXVldWUucG9wKCk7XG4gICAgICAgIGlmIChldmljdGVkKSB7XG4gICAgICAgICAgdGhpcy5naG9zdFF1ZXVlLmFkZChldmljdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5naG9zdFF1ZXVlLnNpemUgPiB0aGlzLm1heEdob3N0U2l6ZSkge1xuICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLmdob3N0UXVldWUudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgaWYgKGZpcnN0S2V5KSB7XG4gICAgICAgIHRoaXMuZ2hvc3RRdWV1ZS5kZWxldGUoZmlyc3RLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICB9XG4gIG9uSXRlbVJlbW92ZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgcmVjZW50SW5kZXggPSB0aGlzLnJlY2VudFF1ZXVlLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAocmVjZW50SW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnJlY2VudFF1ZXVlLnNwbGljZShyZWNlbnRJbmRleCwgMSk7XG4gICAgfVxuICAgIGNvbnN0IGhvdEluZGV4ID0gdGhpcy5ob3RRdWV1ZS5pbmRleE9mKGtleSk7XG4gICAgaWYgKGhvdEluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5ob3RRdWV1ZS5zcGxpY2UoaG90SW5kZXgsIDEpO1xuICAgIH1cbiAgICBtZXRhZGF0YVByb3ZpZGVyLmRlbGV0ZU1ldGFkYXRhKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhbiBpdGVtIHNob3VsZCBiZSBwcm9tb3RlZCBmcm9tIHJlY2VudCB0byBob3QgcXVldWVcbiAgICovXG4gIHNob3VsZFByb21vdGVUb0hvdFF1ZXVlKG1ldGFkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy51c2VGcmVxdWVuY3lQcm9tb3Rpb24pIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5hY2Nlc3NDb3VudCA+PSAyO1xuICAgIH1cbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLmNvbmZpZy5wcm9tb3Rpb25UaHJlc2hvbGQgPz8gMjtcbiAgICBjb25zdCBmcmVxdWVuY3kgPSB0aGlzLmdldEVmZmVjdGl2ZUZyZXF1ZW5jeShtZXRhZGF0YSk7XG4gICAgcmV0dXJuIGZyZXF1ZW5jeSA+PSB0aHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBlZmZlY3RpdmUgZnJlcXVlbmN5IGZvciBhbiBpdGVtLCBhcHBseWluZyBkZWNheSBpZiBlbmFibGVkXG4gICAqL1xuICBnZXRFZmZlY3RpdmVGcmVxdWVuY3kobWV0YWRhdGEpIHtcbiAgICBpZiAoKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgdGltZVNpbmNlVXBkYXRlID0gbm93IC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gdGltZVNpbmNlVXBkYXRlIC8gKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA/PyAzZTUpICogKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlGYWN0b3IgPz8gMC4wNSk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMSwgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YS5yYXdGcmVxdWVuY3kgfHwgbWV0YWRhdGEuYWNjZXNzQ291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBmcmVxdWVuY3kgc2NvcmUgd2l0aCBkZWNheSBhcHBsaWVkXG4gICAqL1xuICBjYWxjdWxhdGVGcmVxdWVuY3lTY29yZShtZXRhZGF0YSwgY3VycmVudFRpbWUpIHtcbiAgICBjb25zdCByYXdGcmVxID0gbWV0YWRhdGEucmF3RnJlcXVlbmN5IHx8IG1ldGFkYXRhLmFjY2Vzc0NvdW50O1xuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHJhd0ZyZXE7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVTaW5jZVVwZGF0ZSA9IGN1cnJlbnRUaW1lIC0gbWV0YWRhdGEubGFzdEZyZXF1ZW5jeVVwZGF0ZTtcbiAgICBjb25zdCBkZWNheUFtb3VudCA9IHRpbWVTaW5jZVVwZGF0ZSAvICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5SW50ZXJ2YWwgPz8gM2U1KSAqICh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDAuMDUpO1xuICAgIGNvbnN0IHByZXZpb3VzU2NvcmUgPSBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSB8fCByYXdGcmVxO1xuICAgIGNvbnN0IGRlY2F5ZWRTY29yZSA9IHByZXZpb3VzU2NvcmUgKiAoMSAtIGRlY2F5QW1vdW50KTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMSwgZGVjYXllZFNjb3JlICsgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IHBlcmlvZGljIGRlY2F5IHRvIGhvdCBxdWV1ZSBpdGVtc1xuICAgKi9cbiAgYXBwbHlQZXJpb2RpY0RlY2F5KGl0ZW1zKSB7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5ob3RRdWV1ZURlY2F5RmFjdG9yID8/IDApID09PSAwKSByZXR1cm47XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lU2luY2VEZWNheSA9IG5vdyAtIHRoaXMubGFzdERlY2F5VGltZTtcbiAgICBpZiAodGltZVNpbmNlRGVjYXkgPj0gKHRoaXMuY29uZmlnLmhvdFF1ZXVlRGVjYXlJbnRlcnZhbCA/PyAzZTUpKSB7XG4gICAgICBpZiAodGhpcy5ob3RRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuaG90UXVldWUpIHtcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgIGlmIChtZXRhZGF0YSAmJiB0eXBlb2YgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY2F5QW1vdW50ID0gdGhpcy5jb25maWcuaG90UXVldWVEZWNheUZhY3RvciA/PyAwLjA1O1xuICAgICAgICAgICAgbWV0YWRhdGEuZnJlcXVlbmN5U2NvcmUgPSBNYXRoLm1heCgxLCBtZXRhZGF0YS5mcmVxdWVuY3lTY29yZSAqICgxIC0gZGVjYXlBbW91bnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0RGVjYXlUaW1lID0gbm93O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgc3RyYXRlZ3lcbiAgICovXG4gIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBpbnRlcm5hbCBzdGF0ZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5yZWNlbnRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuaG90UXVldWUgPSBbXTtcbiAgICB0aGlzLmdob3N0UXVldWUuY2xlYXIoKTtcbiAgICB0aGlzLmxhc3REZWNheVRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZpY3Rpb24vRXZpY3Rpb25TdHJhdGVneUZhY3RvcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUV2aWN0aW9uU3RyYXRlZ3kocG9saWN5LCBtYXhDYWNoZVNpemUsIGNvbmZpZykge1xuICBjb25zdCBzYWZlTWF4Q2FjaGVTaXplID0gdHlwZW9mIG1heENhY2hlU2l6ZSA9PT0gXCJudW1iZXJcIiAmJiBtYXhDYWNoZVNpemUgPiAwID8gbWF4Q2FjaGVTaXplIDogMWUzO1xuICBzd2l0Y2ggKHBvbGljeSkge1xuICAgIGNhc2UgXCJscnVcIjpcbiAgICAgIHJldHVybiBuZXcgTFJVRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgIGNhc2UgXCJsZnVcIjoge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbGZ1Q29uZmlnID0gY29uZmlnPy50eXBlID09PSBcImxmdVwiID8gY29uZmlnIDogeyB0eXBlOiBcImxmdVwiIH07XG4gICAgICAgIHJldHVybiBuZXcgTEZVRXZpY3Rpb25TdHJhdGVneShsZnVDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjcmVhdGUgbGZ1IHN0cmF0ZWd5IHdpdGggcHJvdmlkZWQgY29uZmlndXJhdGlvbiwgZmFsbGluZyBiYWNrIHRvIExSVTpgLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IExSVUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSBcImZpZm9cIjpcbiAgICAgIHJldHVybiBuZXcgRklGT0V2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICBjYXNlIFwibXJ1XCI6XG4gICAgICByZXR1cm4gbmV3IE1SVUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICBjYXNlIFwicmFuZG9tXCI6XG4gICAgICByZXR1cm4gbmV3IFJhbmRvbUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICBjYXNlIFwiYXJjXCI6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFyY0NvbmZpZyA9IGNvbmZpZz8udHlwZSA9PT0gXCJhcmNcIiA/IGNvbmZpZyA6IHsgLi4uREVGQVVMVF9BUkNfQ09ORklHLCBtYXhDYWNoZVNpemU6IHNhZmVNYXhDYWNoZVNpemUgfTtcbiAgICAgICAgY29uc3QgZmluYWxNYXhTaXplID0gYXJjQ29uZmlnLm1heENhY2hlU2l6ZSAmJiBhcmNDb25maWcubWF4Q2FjaGVTaXplID4gMCA/IGFyY0NvbmZpZy5tYXhDYWNoZVNpemUgOiBzYWZlTWF4Q2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gbmV3IEFSQ0V2aWN0aW9uU3RyYXRlZ3koZmluYWxNYXhTaXplLCB7IC4uLmFyY0NvbmZpZywgbWF4Q2FjaGVTaXplOiBmaW5hbE1heFNpemUgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNyZWF0ZSBhcmMgc3RyYXRlZ3kgd2l0aCBwcm92aWRlZCBjb25maWd1cmF0aW9uLCBmYWxsaW5nIGJhY2sgdG8gTFJVOmAsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJVRXZpY3Rpb25TdHJhdGVneSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiMnFcIjoge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHdvUUNvbmZpZyA9IGNvbmZpZz8udHlwZSA9PT0gXCIycVwiID8gY29uZmlnIDogeyAuLi5ERUZBVUxUX1RXT19RVUVVRV9DT05GSUcsIG1heENhY2hlU2l6ZTogc2FmZU1heENhY2hlU2l6ZSB9O1xuICAgICAgICBjb25zdCBmaW5hbE1heFNpemUgPSB0d29RQ29uZmlnLm1heENhY2hlU2l6ZSAmJiB0d29RQ29uZmlnLm1heENhY2hlU2l6ZSA+IDAgPyB0d29RQ29uZmlnLm1heENhY2hlU2l6ZSA6IHNhZmVNYXhDYWNoZVNpemU7XG4gICAgICAgIHJldHVybiBuZXcgVHdvUXVldWVFdmljdGlvblN0cmF0ZWd5KGZpbmFsTWF4U2l6ZSwgeyAuLi50d29RQ29uZmlnLCBtYXhDYWNoZVNpemU6IGZpbmFsTWF4U2l6ZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY3JlYXRlIDJxIHN0cmF0ZWd5IHdpdGggcHJvdmlkZWQgY29uZmlndXJhdGlvbiwgZmFsbGluZyBiYWNrIHRvIExSVTpgLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IExSVUV2aWN0aW9uU3RyYXRlZ3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZXZpY3Rpb24gcG9saWN5OiAke3BvbGljeX1gKTtcbiAgfVxufVxuXG4vLyBzcmMvdHRsL1RUTE1hbmFnZXIudHNcbnZhciBsb2dnZXIyMSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIlRUTE1hbmFnZXJcIik7XG52YXIgVFRMTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uZmlnO1xuICBjbGVhbnVwVGltZXI7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBhdXRvQ2xlYW51cDogdHJ1ZSxcbiAgICAgIGNsZWFudXBJbnRlcnZhbDogNmU0LFxuICAgICAgLy8gMSBtaW51dGUgZGVmYXVsdFxuICAgICAgdmFsaWRhdGVPbkFjY2VzczogdHJ1ZSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gICAgaWYgKHRoaXMuY29uZmlnLmF1dG9DbGVhbnVwICYmIHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgdGhpcy5zdGFydEF1dG9DbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBUVEwgaXMgZW5hYmxlZFxuICAgKi9cbiAgaXNUVExFbmFibGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5jb25maWcuZGVmYXVsdFRUTCA9PT0gXCJudW1iZXJcIiAmJiB0aGlzLmNvbmZpZy5kZWZhdWx0VFRMID4gMDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IFRUTCB2YWx1ZVxuICAgKi9cbiAgZ2V0RGVmYXVsdFRUTCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGVmYXVsdFRUTDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIFRUTCBjb25maWd1cmF0aW9uXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3Qgb2xkQ29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICBpZiAob2xkQ29uZmlnLmF1dG9DbGVhbnVwICE9PSB0aGlzLmNvbmZpZy5hdXRvQ2xlYW51cCB8fCBvbGRDb25maWcuY2xlYW51cEludGVydmFsICE9PSB0aGlzLmNvbmZpZy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuc3RvcEF1dG9DbGVhbnVwKCk7XG4gICAgICBpZiAodGhpcy5jb25maWcuYXV0b0NsZWFudXAgJiYgdGhpcy5jb25maWcuY2xlYW51cEludGVydmFsKSB7XG4gICAgICAgIHRoaXMuc3RhcnRBdXRvQ2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIyMS5kZWJ1ZyhcIlRUTCBjb25maWd1cmF0aW9uIHVwZGF0ZWRcIiwgeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgVFRMIG1ldGFkYXRhIGZvciBhbiBpdGVtIHdoZW4gaXQncyBhZGRlZFxuICAgKi9cbiAgb25JdGVtQWRkZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyLCBpdGVtVFRMKSB7XG4gICAgaWYgKCF0aGlzLmlzVFRMRW5hYmxlZCgpICYmICFpdGVtVFRMKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgIGxvZ2dlcjIxLndhcm5pbmcoXCJObyBtZXRhZGF0YSBmb3VuZCBmb3IgaXRlbSB3aGVuIHNldHRpbmcgVFRMXCIsIHsga2V5IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0dGwgPSBpdGVtVFRMIHx8IHRoaXMuY29uZmlnLmRlZmF1bHRUVEw7XG4gICAgaWYgKHR0bCAmJiB0dGwgPiAwKSB7XG4gICAgICBjb25zdCB0dGxNZXRhZGF0YSA9IHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIGV4cGlyZXNBdDogbWV0YWRhdGEuYWRkZWRBdCArIHR0bCxcbiAgICAgICAgdHRsXG4gICAgICB9O1xuICAgICAgbWV0YWRhdGFQcm92aWRlci5zZXRNZXRhZGF0YShrZXksIHR0bE1ldGFkYXRhKTtcbiAgICAgIGxvZ2dlcjIxLnRyYWNlKFwiVFRMIHNldCBmb3IgaXRlbVwiLCB7IGtleSwgdHRsLCBleHBpcmVzQXQ6IHR0bE1ldGFkYXRhLmV4cGlyZXNBdCB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGl0ZW0gaGFzIGV4cGlyZWRcbiAgICovXG4gIGlzRXhwaXJlZChrZXksIG1ldGFkYXRhUHJvdmlkZXIpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICBpZiAoIW1ldGFkYXRhIHx8ICFtZXRhZGF0YS5leHBpcmVzQXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBleHBpcmVkID0gbm93ID49IG1ldGFkYXRhLmV4cGlyZXNBdDtcbiAgICBpZiAoZXhwaXJlZCkge1xuICAgICAgbG9nZ2VyMjEudHJhY2UoXCJJdGVtIGV4cGlyZWRcIiwgeyBrZXksIGV4cGlyZXNBdDogbWV0YWRhdGEuZXhwaXJlc0F0LCBub3cgfSk7XG4gICAgfVxuICAgIHJldHVybiBleHBpcmVkO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBpdGVtIGlzIHZhbGlkIChub3QgZXhwaXJlZCkgYmVmb3JlIHJldHVybmluZyBpdFxuICAgKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyB2YWxpZCwgZmFsc2UgaWYgZXhwaXJlZFxuICAgKi9cbiAgdmFsaWRhdGVJdGVtKGtleSwgbWV0YWRhdGFQcm92aWRlcikge1xuICAgIGlmICghdGhpcy5jb25maWcudmFsaWRhdGVPbkFjY2Vzcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0V4cGlyZWQoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgfVxuICAvKipcbiAgICogR2V0IFRUTCBpbmZvcm1hdGlvbiBmb3IgYW4gaXRlbVxuICAgKi9cbiAgZ2V0SXRlbVRUTEluZm8oa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSB8fCAhbWV0YWRhdGEuZXhwaXJlc0F0KSB7XG4gICAgICByZXR1cm4geyBoYXNUVEw6IGZhbHNlLCBpc0V4cGlyZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaXNFeHBpcmVkID0gbm93ID49IG1ldGFkYXRhLmV4cGlyZXNBdDtcbiAgICBjb25zdCByZW1haW5pbmdUVEwgPSBpc0V4cGlyZWQgPyAwIDogbWV0YWRhdGEuZXhwaXJlc0F0IC0gbm93O1xuICAgIHJldHVybiB7XG4gICAgICBoYXNUVEw6IHRydWUsXG4gICAgICB0dGw6IG1ldGFkYXRhLnR0bCxcbiAgICAgIGV4cGlyZXNBdDogbWV0YWRhdGEuZXhwaXJlc0F0LFxuICAgICAgcmVtYWluaW5nVFRMLFxuICAgICAgaXNFeHBpcmVkXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbGwgZXhwaXJlZCBpdGVtc1xuICAgKi9cbiAgZmluZEV4cGlyZWRJdGVtcyhtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgZXhwaXJlZEtleXMgPSBbXTtcbiAgICBjb25zdCBhbGxNZXRhZGF0YSA9IG1ldGFkYXRhUHJvdmlkZXIuZ2V0QWxsTWV0YWRhdGEoKTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgbWV0YWRhdGFdIG9mIGFsbE1ldGFkYXRhKSB7XG4gICAgICBjb25zdCB0dGxNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgaWYgKHR0bE1ldGFkYXRhLmV4cGlyZXNBdCAmJiBub3cgPj0gdHRsTWV0YWRhdGEuZXhwaXJlc0F0KSB7XG4gICAgICAgIGV4cGlyZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cGlyZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZ2dlcjIxLmRlYnVnKFwiRm91bmQgZXhwaXJlZCBpdGVtc1wiLCB7IGNvdW50OiBleHBpcmVkS2V5cy5sZW5ndGgsIGtleXM6IGV4cGlyZWRLZXlzIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwaXJlZEtleXM7XG4gIH1cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGNsZWFuIHVwIGV4cGlyZWQgaXRlbXNcbiAgICogUmV0dXJucyB0aGUga2V5cyBvZiBpdGVtcyB0aGF0IHdlcmUgZXhwaXJlZFxuICAgKi9cbiAgY2xlYW51cEV4cGlyZWRJdGVtcyhtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEV4cGlyZWRJdGVtcyhtZXRhZGF0YVByb3ZpZGVyKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHJlbWFpbmluZyBUVEwgZm9yIGFuIGl0ZW0gaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBnZXRSZW1haW5pbmdUVEwoa2V5LCBtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuZ2V0SXRlbVRUTEluZm8oa2V5LCBtZXRhZGF0YVByb3ZpZGVyKTtcbiAgICByZXR1cm4gaW5mby5oYXNUVEwgPyBpbmZvLnJlbWFpbmluZ1RUTCB8fCAwIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogRXh0ZW5kIFRUTCBmb3IgYW4gaXRlbVxuICAgKi9cbiAgZXh0ZW5kVFRMKGtleSwgbWV0YWRhdGFQcm92aWRlciwgYWRkaXRpb25hbFRUTCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFQcm92aWRlci5nZXRNZXRhZGF0YShrZXkpO1xuICAgIGlmICghbWV0YWRhdGEgfHwgIW1ldGFkYXRhLmV4cGlyZXNBdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtZXRhZGF0YS5leHBpcmVzQXQgKz0gYWRkaXRpb25hbFRUTDtcbiAgICBtZXRhZGF0YVByb3ZpZGVyLnNldE1ldGFkYXRhKGtleSwgbWV0YWRhdGEpO1xuICAgIGxvZ2dlcjIxLnRyYWNlKFwiVFRMIGV4dGVuZGVkIGZvciBpdGVtXCIsIHsga2V5LCBhZGRpdGlvbmFsVFRMLCBuZXdFeHBpcmVzQXQ6IG1ldGFkYXRhLmV4cGlyZXNBdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgVFRMIGZvciBhbiBpdGVtIChyZWZyZXNoIGV4cGlyYXRpb24pXG4gICAqL1xuICByZWZyZXNoVFRMKGtleSwgbWV0YWRhdGFQcm92aWRlciwgbmV3VFRMKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb3ZpZGVyLmdldE1ldGFkYXRhKGtleSk7XG4gICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0dGwgPSBuZXdUVEwgfHwgbWV0YWRhdGEudHRsIHx8IHRoaXMuY29uZmlnLmRlZmF1bHRUVEw7XG4gICAgaWYgKCF0dGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0dGxNZXRhZGF0YSA9IHtcbiAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgZXhwaXJlc0F0OiBub3cgKyB0dGwsXG4gICAgICB0dGxcbiAgICB9O1xuICAgIG1ldGFkYXRhUHJvdmlkZXIuc2V0TWV0YWRhdGEoa2V5LCB0dGxNZXRhZGF0YSk7XG4gICAgbG9nZ2VyMjEudHJhY2UoXCJUVEwgcmVmcmVzaGVkIGZvciBpdGVtXCIsIHsga2V5LCB0dGwsIGV4cGlyZXNBdDogdHRsTWV0YWRhdGEuZXhwaXJlc0F0IH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhdXRvbWF0aWMgY2xlYW51cCBvZiBleHBpcmVkIGl0ZW1zXG4gICAqL1xuICBzdGFydEF1dG9DbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmNsZWFudXBUaW1lcikge1xuICAgICAgdGhpcy5zdG9wQXV0b0NsZWFudXAoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGxvZ2dlcjIxLnRyYWNlKFwiQXV0byBjbGVhbnVwIHRpbWVyIHRyaWdnZXJlZFwiKTtcbiAgICAgIH0sIHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCk7XG4gICAgICBsb2dnZXIyMS5kZWJ1ZyhcIkF1dG8gY2xlYW51cCBzdGFydGVkXCIsIHsgaW50ZXJ2YWw6IHRoaXMuY29uZmlnLmNsZWFudXBJbnRlcnZhbCB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgYXV0b21hdGljIGNsZWFudXBcbiAgICovXG4gIHN0b3BBdXRvQ2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgICAgbG9nZ2VyMjEuZGVidWcoXCJBdXRvIGNsZWFudXAgc3RvcHBlZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsZWFudXAgcmVzb3VyY2VzXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RvcEF1dG9DbGVhbnVwKCk7XG4gICAgbG9nZ2VyMjEuZGVidWcoXCJUVEwgbWFuYWdlciBkZXN0cm95ZWRcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvQ2FjaGVFdmVudEVtaXR0ZXIudHNcbnZhciBDYWNoZUV2ZW50RW1pdHRlciA9IGNsYXNzIHtcbiAgc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG5leHRTdWJzY3JpcHRpb25JZCA9IDE7XG4gIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gIGNsZWFudXBJbnRlcnZhbCA9IG51bGw7XG4gIENMRUFOVVBfSU5URVJWQUxfTVMgPSAzZTQ7XG4gIC8vIDMwIHNlY29uZHNcbiAgTUFYX0lOQUNUSVZFX1RJTUVfTVMgPSAzZTU7XG4gIC8vIDUgbWludXRlc1xuICBXRUFLX1JFRl9FTkFCTEVEID0gdHlwZW9mIFdlYWtSZWYgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhcnRQZXJpb2RpY0NsZWFudXAoKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgcGVyaW9kaWMgY2xlYW51cCBvZiBpbmFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAqL1xuICBzdGFydFBlcmlvZGljQ2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwpIHJldHVybjtcbiAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMucGVyZm9ybVBlcmlvZGljQ2xlYW51cCgpO1xuICAgIH0sIHRoaXMuQ0xFQU5VUF9JTlRFUlZBTF9NUyk7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsLnVucmVmKSB7XG4gICAgICB0aGlzLmNsZWFudXBJbnRlcnZhbC51bnJlZigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBwZXJpb2RpYyBjbGVhbnVwIG9mIGluYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIHBlcmZvcm1QZXJpb2RpY0NsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIHN1YnNjcmlwdGlvbl0gb2YgdGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoIXN1YnNjcmlwdGlvbi5pc0FjdGl2ZSB8fCBub3cgLSBzdWJzY3JpcHRpb24ubGFzdEFjY2Vzc1RpbWUgPiB0aGlzLk1BWF9JTkFDVElWRV9USU1FX01TKSB7XG4gICAgICAgIHRvUmVtb3ZlLnB1c2goaWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLldFQUtfUkVGX0VOQUJMRUQgJiYgc3Vic2NyaXB0aW9uLmxpc3RlbmVyUmVmKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gc3Vic2NyaXB0aW9uLmxpc3RlbmVyUmVmLmRlcmVmKCk7XG4gICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGlkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0b1JlbW92ZS5mb3JFYWNoKChpZCkgPT4gdGhpcy51bnN1YnNjcmliZShpZCkpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gY2FjaGUgZXZlbnRzXG4gICAqL1xuICBzdWJzY3JpYmUobGlzdGVuZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3Vic2NyaWJlIHRvIGRlc3Ryb3llZCBldmVudCBlbWl0dGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBzdWJzY3JpcHRpb25fJHt0aGlzLm5leHRTdWJzY3JpcHRpb25JZCsrfWA7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICBpZCxcbiAgICAgIGxpc3RlbmVyLFxuICAgICAgbGlzdGVuZXJSZWY6IHRoaXMuV0VBS19SRUZfRU5BQkxFRCAmJiBvcHRpb25zLnVzZVdlYWtSZWYgIT09IGZhbHNlID8gbmV3IFdlYWtSZWYobGlzdGVuZXIpIDogdm9pZCAwLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICBsYXN0QWNjZXNzVGltZTogbm93XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB0aGlzLnVuc3Vic2NyaWJlKGlkKSxcbiAgICAgIGlzQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgc3ViLmxhc3RBY2Nlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViPy5pc0FjdGl2ZSA/PyBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBnZXRPcHRpb25zOiAoKSA9PiAoeyAuLi5vcHRpb25zIH0pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBldmVudHNcbiAgICovXG4gIHVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbklkKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChzdWJzY3JpcHRpb25JZCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIpO1xuICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBzdWJzY3JpcHRpb24uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbklkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogRW1pdCBhbiBldmVudCB0byBhbGwgbWF0Y2hpbmcgc3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgZW1pdChldmVudCkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFzdWJzY3JpcHRpb24uaXNBY3RpdmUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaG91bGRFbWl0VG9TdWJzY3JpcHRpb24oZXZlbnQsIHN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgdGhpcy5lbWl0VG9TdWJzY3JpcHRpb24oZXZlbnQsIHN1YnNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgY291bnQgb2YgYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIGdldFN1YnNjcmlwdGlvbkNvdW50KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKChzKSA9PiBzLmlzQWN0aXZlKS5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzdWJzY3JpcHRpb24gZGV0YWlscyAoZm9yIGRlYnVnZ2luZylcbiAgICovXG4gIGdldFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKS5maWx0ZXIoKHMpID0+IHMuaXNBY3RpdmUpLm1hcCgocykgPT4gKHsgaWQ6IHMuaWQsIG9wdGlvbnM6IHsgLi4ucy5vcHRpb25zIH0gfSkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBldmVudCBlbWl0dGVyIGFuZCBjbGVhbiB1cCBhbGwgc3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIpO1xuICAgICAgICBzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdWJzY3JpcHRpb24uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGV2ZW50IHNob3VsZCBiZSBlbWl0dGVkIHRvIGEgc3BlY2lmaWMgc3Vic2NyaXB0aW9uXG4gICAqL1xuICBzaG91bGRFbWl0VG9TdWJzY3JpcHRpb24oZXZlbnQsIHN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc3Vic2NyaXB0aW9uO1xuICAgIGlmIChvcHRpb25zLmV2ZW50VHlwZXMgJiYgIW9wdGlvbnMuZXZlbnRUeXBlcy5pbmNsdWRlcyhldmVudC50eXBlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5rZXlzICYmIG9wdGlvbnMua2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBldmVudCkge1xuICAgICAgICBjb25zdCBldmVudEtleVN0ciA9IHRoaXMubm9ybWFsaXplS2V5KGV2ZW50LmtleSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXNLZXkgPSBvcHRpb25zLmtleXMuc29tZShcbiAgICAgICAgICAoa2V5KSA9PiB0aGlzLm5vcm1hbGl6ZUtleShrZXkpID09PSBldmVudEtleVN0clxuICAgICAgICApO1xuICAgICAgICBpZiAoIW1hdGNoZXNLZXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXCJhZmZlY3RlZEtleXNcIiBpbiBldmVudCkge1xuICAgICAgICBjb25zdCBldmVudEtleVN0cnMgPSBldmVudC5hZmZlY3RlZEtleXMubWFwKChrZXkpID0+IHRoaXMubm9ybWFsaXplS2V5KGtleSkpO1xuICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0tleSA9IG9wdGlvbnMua2V5cy5zb21lKFxuICAgICAgICAgIChrZXkpID0+IGV2ZW50S2V5U3Rycy5pbmNsdWRlcyh0aGlzLm5vcm1hbGl6ZUtleShrZXkpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIWhhc01hdGNoaW5nS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucyAmJiBvcHRpb25zLmxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoXCJhZmZlY3RlZExvY2F0aW9uc1wiIGluIGV2ZW50ICYmIGV2ZW50LmFmZmVjdGVkTG9jYXRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2NhdGlvbnNNYXRjaChvcHRpb25zLmxvY2F0aW9ucywgZXZlbnQuYWZmZWN0ZWRMb2NhdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFwibG9jYXRpb25zXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2F0aW9uc01hdGNoKG9wdGlvbnMubG9jYXRpb25zLCBldmVudC5sb2NhdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFwia2V5XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleU1hdGNoZXNMb2NhdGlvbnMoZXZlbnQua2V5LCBvcHRpb25zLmxvY2F0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICAgIGlmIChcInF1ZXJ5XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnF1ZXJpZXNNYXRjaChvcHRpb25zLnF1ZXJ5LCBldmVudC5xdWVyeSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogRW1pdCBldmVudCB0byBhIHNwZWNpZmljIHN1YnNjcmlwdGlvbiwgaGFuZGxpbmcgZGVib3VuY2luZ1xuICAgKi9cbiAgZW1pdFRvU3Vic2NyaXB0aW9uKGV2ZW50LCBzdWJzY3JpcHRpb24pIHtcbiAgICBzdWJzY3JpcHRpb24ubGFzdEFjY2Vzc1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBsaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lcjtcbiAgICBpZiAodGhpcy5XRUFLX1JFRl9FTkFCTEVEICYmIHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZikge1xuICAgICAgY29uc3Qgd2Vha0xpc3RlbmVyID0gc3Vic2NyaXB0aW9uLmxpc3RlbmVyUmVmLmRlcmVmKCk7XG4gICAgICBpZiAoIXdlYWtMaXN0ZW5lcikge1xuICAgICAgICBzdWJzY3JpcHRpb24uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIgPSB3ZWFrTGlzdGVuZXI7XG4gICAgfVxuICAgIGlmICghc3Vic2NyaXB0aW9uLm9wdGlvbnMuZGVib3VuY2VNcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVMaXN0ZW5lckVycm9yKGVycm9yLCBldmVudCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIpO1xuICAgICAgc3Vic2NyaXB0aW9uLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5pc0FjdGl2ZSkge1xuICAgICAgICBsZXQgY3VycmVudExpc3RlbmVyID0gc3Vic2NyaXB0aW9uLmxpc3RlbmVyO1xuICAgICAgICBpZiAodGhpcy5XRUFLX1JFRl9FTkFCTEVEICYmIHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZikge1xuICAgICAgICAgIGNvbnN0IHdlYWtMaXN0ZW5lciA9IHN1YnNjcmlwdGlvbi5saXN0ZW5lclJlZi5kZXJlZigpO1xuICAgICAgICAgIGlmICghd2Vha0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudExpc3RlbmVyID0gd2Vha0xpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY3VycmVudExpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24ubGFzdEVtaXRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUxpc3RlbmVyRXJyb3IoZXJyb3IsIGV2ZW50LCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdWJzY3JpcHRpb24uZGVib3VuY2VUaW1lciA9IG51bGw7XG4gICAgfSwgc3Vic2NyaXB0aW9uLm9wdGlvbnMuZGVib3VuY2VNcyk7XG4gIH1cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBhIGtleSBmb3IgY29tcGFyaXNvblxuICAgKi9cbiAgbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXksIChrLCB2KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUtleVZhbHVlKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBhIGxvY2F0aW9uIGtleSBmb3IgY29tcGFyaXNvblxuICAgKi9cbiAgbm9ybWFsaXplTG9jS2V5KGtleSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXksIChrLCB2KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUtleVZhbHVlKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byBsb2NhdGlvbiBhcnJheXMgbWF0Y2hcbiAgICovXG4gIGxvY2F0aW9uc01hdGNoKGZpbHRlciwgZXZlbnRMb2NhdGlvbnMpIHtcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCA9PT0gMCAmJiBldmVudExvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmxlbmd0aCAhPT0gZXZlbnRMb2NhdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXIuZXZlcnkoKGZpbHRlckxvYywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50TG9jID0gZXZlbnRMb2NhdGlvbnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplS2V5KGZpbHRlckxvYykgPT09IHRoaXMubm9ybWFsaXplS2V5KGV2ZW50TG9jKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgbWF0Y2hlcyBsb2NhdGlvbiBmaWx0ZXJzXG4gICAqL1xuICBrZXlNYXRjaGVzTG9jYXRpb25zKGtleSwgZmlsdGVyTG9jYXRpb25zKSB7XG4gICAgaWYgKFwibG9jXCIgaW4ga2V5ICYmIGtleS5sb2MpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uc01hdGNoKGZpbHRlckxvY2F0aW9ucywga2V5LmxvYyk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJMb2NhdGlvbnMubGVuZ3RoID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gcXVlcmllcyBtYXRjaCAoaW1wcm92ZWQgY29tcGFyaXNvbilcbiAgICovXG4gIHF1ZXJpZXNNYXRjaChmaWx0ZXJRdWVyeSwgZXZlbnRRdWVyeSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IChvYmopID0+IHtcbiAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG9iajtcbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSByZXR1cm4gb2JqO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iai5tYXAobm9ybWFsaXplKS5zb3J0KCk7XG4gICAgICBjb25zdCBzb3J0ZWQgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG9iaikuc29ydCgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBzb3J0ZWRba2V5XSA9IG5vcm1hbGl6ZShvYmpba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3J0ZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplKGZpbHRlclF1ZXJ5KSkgPT09IEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZShldmVudFF1ZXJ5KSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBlcnJvcnMgdGhhdCBvY2N1ciBpbiBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGhhbmRsZUxpc3RlbmVyRXJyb3IoZXJyb3IsIGV2ZW50LCBzdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBlcnJvck9iaiA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLm9wdGlvbnMub25FcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLm9wdGlvbnMub25FcnJvcihlcnJvck9iaiwgZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoaGFuZGxlckVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjYWNoZSBldmVudCBsaXN0ZW5lcjpcIiwgZXJyb3JPYmopO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXJyb3IgaGFuZGxlcjpcIiwgaGFuZGxlckVycm9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNhY2hlIGV2ZW50IGxpc3RlbmVyOlwiLCBlcnJvck9iaik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvQ2FjaGVTdGF0cy50c1xudmFyIENhY2hlU3RhdHNNYW5hZ2VyID0gY2xhc3Mge1xuICBzdGF0cyA9IHtcbiAgICBudW1SZXF1ZXN0czogMCxcbiAgICBudW1NaXNzZXM6IDAsXG4gICAgbnVtSGl0czogMCxcbiAgICBudW1TdWJzY3JpcHRpb25zOiAwLFxuICAgIG51bVVuc3Vic2NyaXB0aW9uczogMCxcbiAgICBhY3RpdmVTdWJzY3JpcHRpb25zOiAwXG4gIH07XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHJlcXVlc3QgY291bnRlclxuICAgKi9cbiAgaW5jcmVtZW50UmVxdWVzdHMoKSB7XG4gICAgdGhpcy5zdGF0cy5udW1SZXF1ZXN0cysrO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIGNhY2hlIGhpdCBjb3VudGVyXG4gICAqL1xuICBpbmNyZW1lbnRIaXRzKCkge1xuICAgIHRoaXMuc3RhdHMubnVtSGl0cysrO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIGNhY2hlIG1pc3MgY291bnRlclxuICAgKi9cbiAgaW5jcmVtZW50TWlzc2VzKCkge1xuICAgIHRoaXMuc3RhdHMubnVtTWlzc2VzKys7XG4gIH1cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgc3Vic2NyaXB0aW9uIGNvdW50ZXJcbiAgICovXG4gIGluY3JlbWVudFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgdGhpcy5zdGF0cy5udW1TdWJzY3JpcHRpb25zKys7XG4gICAgdGhpcy5zdGF0cy5hY3RpdmVTdWJzY3JpcHRpb25zKys7XG4gIH1cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgdW5zdWJzY3JpcHRpb24gY291bnRlclxuICAgKi9cbiAgaW5jcmVtZW50VW5zdWJzY3JpcHRpb25zKCkge1xuICAgIHRoaXMuc3RhdHMubnVtVW5zdWJzY3JpcHRpb25zKys7XG4gICAgaWYgKHRoaXMuc3RhdHMuYWN0aXZlU3Vic2NyaXB0aW9ucyA+IDApIHtcbiAgICAgIHRoaXMuc3RhdHMuYWN0aXZlU3Vic2NyaXB0aW9ucy0tO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IGEgY29weSBvZiB0aGUgY3VycmVudCBzdGF0aXN0aWNzXG4gICAqL1xuICBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnN0YXRzIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBzdGF0aXN0aWNzIHRvIHplcm9cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICBudW1SZXF1ZXN0czogMCxcbiAgICAgIG51bU1pc3NlczogMCxcbiAgICAgIG51bUhpdHM6IDAsXG4gICAgICBudW1TdWJzY3JpcHRpb25zOiAwLFxuICAgICAgbnVtVW5zdWJzY3JpcHRpb25zOiAwLFxuICAgICAgYWN0aXZlU3Vic2NyaXB0aW9uczogMFxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9DYWNoZS50c1xudmFyIGxvZ2dlcjIyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiQ2FjaGVcIik7XG52YXIgY3JlYXRlQ2FjaGUgPSAoYXBpLCBjb29yZGluYXRlLCByZWdpc3RyeSwgb3B0aW9ucykgPT4ge1xuICBsb2dnZXIyMi5kZWJ1ZyhcImNyZWF0ZUNhY2hlXCIsIHsgY29vcmRpbmF0ZSwgcmVnaXN0cnksIG9wdGlvbnMgfSk7XG4gIGNvbnN0IGNvbXBsZXRlT3B0aW9ucyA9IGNyZWF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IGNhY2hlTWFwID0gY3JlYXRlQ2FjaGVNYXAoY29vcmRpbmF0ZS5rdGEsIGNvbXBsZXRlT3B0aW9ucyk7XG4gIGNvbnN0IHBrVHlwZSA9IGNvb3JkaW5hdGUua3RhWzBdO1xuICBjb25zdCBldmVudEVtaXR0ZXIgPSBuZXcgQ2FjaGVFdmVudEVtaXR0ZXIoKTtcbiAgY29uc3QgZXZpY3Rpb25NYW5hZ2VyID0gbmV3IEV2aWN0aW9uTWFuYWdlcigpO1xuICBjb25zdCBldmljdGlvbkNvbmZpZyA9IGNvbXBsZXRlT3B0aW9ucy5ldmljdGlvbkNvbmZpZztcbiAgaWYgKCFldmljdGlvbkNvbmZpZyAmJiBjb21wbGV0ZU9wdGlvbnMubWVtb3J5Q29uZmlnPy5zaXplPy5ldmljdGlvblBvbGljeSAmJiAoY29tcGxldGVPcHRpb25zLm1lbW9yeUNvbmZpZy5zaXplLm1heEl0ZW1zIHx8IGNvbXBsZXRlT3B0aW9ucy5tZW1vcnlDb25maWcuc2l6ZS5tYXhTaXplQnl0ZXMpKSB7XG4gIH1cbiAgaWYgKGV2aWN0aW9uQ29uZmlnKSB7XG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjcmVhdGVFdmljdGlvblN0cmF0ZWd5KFxuICAgICAgZXZpY3Rpb25Db25maWcudHlwZSB8fCBcImxydVwiLFxuICAgICAgY29tcGxldGVPcHRpb25zLm1lbW9yeUNvbmZpZz8ubWF4SXRlbXMsXG4gICAgICBldmljdGlvbkNvbmZpZ1xuICAgICk7XG4gICAgZXZpY3Rpb25NYW5hZ2VyLnNldEV2aWN0aW9uU3RyYXRlZ3koc3RyYXRlZ3kpO1xuICB9XG4gIGNvbnN0IHR0bE1hbmFnZXIgPSBuZXcgVFRMTWFuYWdlcih7XG4gICAgZGVmYXVsdFRUTDogY29tcGxldGVPcHRpb25zLnR0bCxcbiAgICBhdXRvQ2xlYW51cDogdHJ1ZSxcbiAgICB2YWxpZGF0ZU9uQWNjZXNzOiB0cnVlXG4gIH0pO1xuICBjb25zdCBzdGF0c01hbmFnZXIgPSBuZXcgQ2FjaGVTdGF0c01hbmFnZXIoKTtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IGNyZWF0ZU9wZXJhdGlvbnMoYXBpLCBjb29yZGluYXRlLCBjYWNoZU1hcCwgcGtUeXBlLCBjb21wbGV0ZU9wdGlvbnMsIGV2ZW50RW1pdHRlciwgdHRsTWFuYWdlciwgZXZpY3Rpb25NYW5hZ2VyLCBzdGF0c01hbmFnZXIpO1xuICBjb25zdCBjYWNoZSA9IHtcbiAgICBjb29yZGluYXRlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGFwaSxcbiAgICBjYWNoZU1hcCxcbiAgICBvcGVyYXRpb25zLFxuICAgIG9wdGlvbnM6IGNvbXBsZXRlT3B0aW9ucyxcbiAgICBldmVudEVtaXR0ZXIsXG4gICAgZXZpY3Rpb25NYW5hZ2VyLFxuICAgIHR0bE1hbmFnZXIsXG4gICAgc3RhdHNNYW5hZ2VyLFxuICAgIGdldENhY2hlSW5mbzogKCkgPT4ge1xuICAgICAgY29uc3QgZXZpY3Rpb25TdHJhdGVneU5hbWUgPSBldmljdGlvbk1hbmFnZXIuZ2V0RXZpY3Rpb25TdHJhdGVneU5hbWUoKTtcbiAgICAgIGNvbnN0IGNhY2hlSW5mbyA9IHtcbiAgICAgICAgaW1wbGVtZW50YXRpb25UeXBlOiBjYWNoZU1hcC5pbXBsZW1lbnRhdGlvblR5cGUsXG4gICAgICAgIGRlZmF1bHRUVEw6IHR0bE1hbmFnZXIuZ2V0RGVmYXVsdFRUTCgpLFxuICAgICAgICAvLyBDYWNoZSBzdXBwb3J0cyBUVEwgaWYgdGhlIENhY2hlTWFwIHN1cHBvcnRzIGl0IE9SIGlmIFRUTCBpcyBjb25maWd1cmVkXG4gICAgICAgIHN1cHBvcnRzVFRMOiBjYWNoZU1hcC5zdXBwb3J0c1RUTD8uKCkgfHwgISF0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSxcbiAgICAgICAgc3VwcG9ydHNFdmljdGlvbjogZXZpY3Rpb25NYW5hZ2VyLmlzRXZpY3Rpb25TdXBwb3J0ZWQoKVxuICAgICAgfTtcbiAgICAgIGlmIChldmljdGlvblN0cmF0ZWd5TmFtZSkge1xuICAgICAgICBjYWNoZUluZm8uZXZpY3Rpb25Qb2xpY3kgPSBldmljdGlvblN0cmF0ZWd5TmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZUluZm87XG4gICAgfSxcbiAgICBnZXRTdGF0czogKCkgPT4gc3RhdHNNYW5hZ2VyLmdldFN0YXRzKCksXG4gICAgc3Vic2NyaWJlOiAobGlzdGVuZXIsIG9wdGlvbnMyKSA9PiB7XG4gICAgICBzdGF0c01hbmFnZXIuaW5jcmVtZW50U3Vic2NyaXB0aW9ucygpO1xuICAgICAgcmV0dXJuIGV2ZW50RW1pdHRlci5zdWJzY3JpYmUobGlzdGVuZXIsIG9wdGlvbnMyKTtcbiAgICB9LFxuICAgIHVuc3Vic2NyaWJlOiAoc3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBldmVudEVtaXR0ZXIudW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uLmlkKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgc3RhdHNNYW5hZ2VyLmluY3JlbWVudFVuc3Vic2NyaXB0aW9ucygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgIGV2ZW50RW1pdHRlci5kZXN0cm95KCk7XG4gICAgICBpZiAodHRsTWFuYWdlciAmJiB0eXBlb2YgdHRsTWFuYWdlci5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHRsTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVNYXAgJiYgdHlwZW9mIGNhY2hlTWFwLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWNoZU1hcC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBDYWNoZUV2ZW50RmFjdG9yeS5kZXN0cm95SW5zdGFuY2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBjYWNoZTtcbn07XG52YXIgaXNDYWNoZSA9IChjYWNoZSkgPT4ge1xuICByZXR1cm4gY2FjaGUgIT09IG51bGwgJiYgdHlwZW9mIGNhY2hlID09PSBcIm9iamVjdFwiICYmIFwiY29vcmRpbmF0ZVwiIGluIGNhY2hlICYmIFwicmVnaXN0cnlcIiBpbiBjYWNoZSAmJiBcImFwaVwiIGluIGNhY2hlICYmIFwiY2FjaGVNYXBcIiBpbiBjYWNoZSAmJiBcIm9wZXJhdGlvbnNcIiBpbiBjYWNoZTtcbn07XG5cbi8vIHNyYy9JbnN0YW5jZUZhY3RvcnkudHNcbnZhciBsb2dnZXIyMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkluc3RhbmNlRmFjdG9yeVwiKTtcbnZhciBjcmVhdGVJbnN0YW5jZUZhY3RvcnkgPSAoYXBpLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlT3B0aW9ucyA9IGNyZWF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gIHZhbGlkYXRlT3B0aW9ucyh0ZW1wbGF0ZU9wdGlvbnMpO1xuICByZXR1cm4gKGNvb3JkaW5hdGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZU9wdGlvbnMgPSBjcmVhdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGxvZ2dlcjIzLmRlYnVnKFwiQ3JlYXRpbmcgY2FjaGUgaW5zdGFuY2VcIiwge1xuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHJlZ2lzdHJ5OiBjb250ZXh0LnJlZ2lzdHJ5LFxuICAgICAgYXBpLFxuICAgICAgY2FjaGVUeXBlOiBpbnN0YW5jZU9wdGlvbnMuY2FjaGVUeXBlLFxuICAgICAgb3B0aW9uczogaW5zdGFuY2VPcHRpb25zXG4gICAgfSk7XG4gICAgY29uc3QgY2FjaGVNYXAgPSBjcmVhdGVDYWNoZU1hcChjb29yZGluYXRlLmt0YSwgaW5zdGFuY2VPcHRpb25zKTtcbiAgICBjb25zdCBwa1R5cGUgPSBjb29yZGluYXRlLmt0YVswXTtcbiAgICBjb25zdCBldmVudEVtaXR0ZXIgPSBuZXcgQ2FjaGVFdmVudEVtaXR0ZXIoKTtcbiAgICBjb25zdCB0dGxNYW5hZ2VyID0gbmV3IFRUTE1hbmFnZXIoe1xuICAgICAgZGVmYXVsdFRUTDogaW5zdGFuY2VPcHRpb25zLnR0bCxcbiAgICAgIGF1dG9DbGVhbnVwOiB0cnVlLFxuICAgICAgdmFsaWRhdGVPbkFjY2VzczogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGV2aWN0aW9uTWFuYWdlciA9IG5ldyBFdmljdGlvbk1hbmFnZXIoKTtcbiAgICBjb25zdCBzdGF0c01hbmFnZXIgPSBuZXcgQ2FjaGVTdGF0c01hbmFnZXIoKTtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gY3JlYXRlT3BlcmF0aW9ucyhcbiAgICAgIGFwaSxcbiAgICAgIGNvb3JkaW5hdGUsXG4gICAgICBjYWNoZU1hcCxcbiAgICAgIHBrVHlwZSxcbiAgICAgIGluc3RhbmNlT3B0aW9ucyxcbiAgICAgIGV2ZW50RW1pdHRlcixcbiAgICAgIHR0bE1hbmFnZXIsXG4gICAgICBldmljdGlvbk1hbmFnZXIsXG4gICAgICBzdGF0c01hbmFnZXJcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBjb29yZGluYXRlLFxuICAgICAgcmVnaXN0cnk6IGNvbnRleHQucmVnaXN0cnksXG4gICAgICBhcGksXG4gICAgICBjYWNoZU1hcCxcbiAgICAgIG9wZXJhdGlvbnMsXG4gICAgICBvcHRpb25zOiBpbnN0YW5jZU9wdGlvbnMsXG4gICAgICBldmVudEVtaXR0ZXIsXG4gICAgICB0dGxNYW5hZ2VyLFxuICAgICAgZXZpY3Rpb25NYW5hZ2VyLFxuICAgICAgZ2V0Q2FjaGVJbmZvOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2aWN0aW9uU3RyYXRlZ3lOYW1lID0gZXZpY3Rpb25NYW5hZ2VyLmdldEV2aWN0aW9uU3RyYXRlZ3lOYW1lKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlSW5mbyA9IHtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblR5cGU6IGNhY2hlTWFwLmltcGxlbWVudGF0aW9uVHlwZSxcbiAgICAgICAgICBkZWZhdWx0VFRMOiB0dGxNYW5hZ2VyLmdldERlZmF1bHRUVEwoKSxcbiAgICAgICAgICBzdXBwb3J0c1RUTDogY2FjaGVNYXAuc3VwcG9ydHNUVEw/LigpIHx8ICEhdHRsTWFuYWdlci5nZXREZWZhdWx0VFRMKCksXG4gICAgICAgICAgc3VwcG9ydHNFdmljdGlvbjogZXZpY3Rpb25NYW5hZ2VyLmlzRXZpY3Rpb25TdXBwb3J0ZWQoKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZpY3Rpb25TdHJhdGVneU5hbWUpIHtcbiAgICAgICAgICBjYWNoZUluZm8uZXZpY3Rpb25Qb2xpY3kgPSBldmljdGlvblN0cmF0ZWd5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVJbmZvO1xuICAgICAgfSxcbiAgICAgIHN1YnNjcmliZTogKGxpc3RlbmVyLCBvcHRpb25zMikgPT4gZXZlbnRFbWl0dGVyLnN1YnNjcmliZShsaXN0ZW5lciwgb3B0aW9uczIpLFxuICAgICAgdW5zdWJzY3JpYmU6IChzdWJzY3JpcHRpb24pID0+IGV2ZW50RW1pdHRlci51bnN1YnNjcmliZShzdWJzY3JpcHRpb24uaWQpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHR0bE1hbmFnZXIuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHRsTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRFbWl0dGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuLy8gc3JjL0luc3RhbmNlLnRzXG52YXIgbG9nZ2VyMjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJbnN0YW5jZVwiKTtcbnZhciBjcmVhdGVJbnN0YW5jZSA9IChyZWdpc3RyeSwgY29vcmRpbmF0ZSwgYXBpLCBvcHRpb25zKSA9PiB7XG4gIGxvZ2dlcjI0LmRlYnVnKFwiY3JlYXRlSW5zdGFuY2VcIiwgeyBjb29yZGluYXRlLCBhcGksIHJlZ2lzdHJ5LCBvcHRpb25zIH0pO1xuICByZXR1cm4gY3JlYXRlQ2FjaGUoYXBpLCBjb29yZGluYXRlLCByZWdpc3RyeSwgb3B0aW9ucyk7XG59O1xudmFyIGlzSW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgcmV0dXJuIGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZSA9PT0gXCJvYmplY3RcIiAmJiBcImNvb3JkaW5hdGVcIiBpbiBpbnN0YW5jZSAmJiBcInJlZ2lzdHJ5XCIgaW4gaW5zdGFuY2UgJiYgXCJhcGlcIiBpbiBpbnN0YW5jZSAmJiBcImNhY2hlTWFwXCIgaW4gaW5zdGFuY2UgJiYgXCJvcGVyYXRpb25zXCIgaW4gaW5zdGFuY2U7XG59O1xuXG4vLyBzcmMvQWdncmVnYXRvci50c1xudmFyIGxvZ2dlcjI1ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSXRlbUFnZ3JlZ2F0b3JcIik7XG52YXIgdG9DYWNoZUNvbmZpZyA9IChjb25maWcpID0+IHtcbiAgbGV0IGNhY2hlQ29uZmlnO1xuICBpZiAoY29uZmlnLm9wdGlvbmFsID09PSB2b2lkIDApIHtcbiAgICBjYWNoZUNvbmZpZyA9IHsgY2FjaGU6IGNvbmZpZywgb3B0aW9uYWw6IGZhbHNlIH07XG4gIH0gZWxzZSB7XG4gICAgY2FjaGVDb25maWcgPSBjb25maWc7XG4gIH1cbiAgcmV0dXJuIGNhY2hlQ29uZmlnO1xufTtcbnZhciBjcmVhdGVBZ2dyZWdhdG9yID0gYXN5bmMgKGNhY2hlLCB7IGFnZ3JlZ2F0ZXMgPSB7fSwgZXZlbnRzID0ge30gfSkgPT4ge1xuICBjb25zdCBwb3B1bGF0ZSA9IGFzeW5jIChpdGVtKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcInBvcHVsYXRlXCIsIHsgaXRlbSB9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhZ2dyZWdhdGVzKSB7XG4gICAgICBhd2FpdCBwb3B1bGF0ZUFnZ3JlZ2F0ZShrZXksIGl0ZW0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudHMpIHtcbiAgICAgIGF3YWl0IHBvcHVsYXRlRXZlbnQoa2V5LCBpdGVtKTtcbiAgICB9XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcInBvcHVsYXRlIGRvbmVcIiwgeyBpdGVtIH0pO1xuICAgIHJldHVybiBpdGVtO1xuICB9O1xuICBjb25zdCBwb3B1bGF0ZUFnZ3JlZ2F0ZSA9IGFzeW5jIChrZXksIGl0ZW0pID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwicG9wdWxhdGUgYWdncmVnYXRlIGtleVwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBjYWNoZUNvbmZpZyA9IHRvQ2FjaGVDb25maWcoYWdncmVnYXRlc1trZXldKTtcbiAgICBpZiAoaXRlbS5yZWZzID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChjYWNoZUNvbmZpZy5vcHRpb25hbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbG9nZ2VyMjUuZXJyb3IoXCJJdGVtIGRvZXMgbm90IGhhdmUgcmVmcyBhbiBpcyBub3Qgb3B0aW9uYWwgXCIsIHsgaXRlbSB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXRlbSBkb2VzIG5vdCBoYXZlIHJlZnMgYW4gaXMgbm90IG9wdGlvbmFsIFwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW0uZXZlbnRzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpdGVtLmV2ZW50cywga2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSBpdGVtLmV2ZW50c1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpdGVtLnJlZnNba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoY2FjaGVDb25maWcub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ2dlcjI1LmVycm9yKFwiSXRlbSBkb2VzIG5vdCBoYXZlIG1hbmRhdG9yeSByZWYgd2l0aCBrZXksIG5vdCBvcHRpb25hbCBcIiwgeyBrZXksIGl0ZW0gfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0ZW0gZG9lcyBub3QgaGF2ZSBtYW5kYXRvcnkgcmVmIHdpdGgga2V5LCBub3Qgb3B0aW9uYWwgXCIgKyBrZXkgKyBcIiBcIiArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtLmV2ZW50cyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlbS5ldmVudHMsIGtleSkpIHtcbiAgICAgICAgICBkZWxldGUgaXRlbS5ldmVudHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWYgPSBpdGVtLnJlZnNba2V5XTtcbiAgICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJBR0cgUmV0cmlldmluZyBJdGVtIGluIFBvcHVsYXRlXCIsIHsga2V5OiByZWYgfSk7XG4gICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgY2FjaGVDb25maWcuY2FjaGUub3BlcmF0aW9ucy5yZXRyaWV2ZShyZWYpO1xuICAgICAgaWYgKG5ld0l0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uYWdncyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaXRlbS5hZ2dzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5hZ2dzW2tleV0gPSB7XG4gICAgICAgICAga2V5OiByZWYsXG4gICAgICAgICAgaXRlbTogbmV3SXRlbVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcG9wdWxhdGVFdmVudCA9IGFzeW5jIChrZXksIGl0ZW0pID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwicG9wdWxhdGUgZXZlbnQga2V5XCIsIHsga2V5IH0pO1xuICAgIGNvbnN0IGNhY2hlQ29uZmlnID0gdG9DYWNoZUNvbmZpZyhldmVudHNba2V5XSk7XG4gICAgaWYgKGl0ZW0uZXZlbnRzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0ZW0gZG9lcyBub3QgaGF2ZSBldmVudHMgXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gICAgfSBlbHNlIGlmIChpdGVtLmV2ZW50c1trZXldID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChjYWNoZUNvbmZpZy5vcHRpb25hbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbG9nZ2VyMjUuZXJyb3IoXCJJdGVtIGRvZXMgbm90IGhhdmUgbWFuZGF0b3J5IGV2ZW50IHdpdGgga2V5XCIsIHsga2V5LCBpdGVtIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdGVtIGRvZXMgbm90IGhhdmUgbWFuZGF0b3J5IGV2ZW50IHdpdGgga2V5IFwiICsga2V5ICsgXCIgXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gaXRlbS5ldmVudHNba2V5XTtcbiAgICAgIGlmIChldmVudC5ieSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxvZ2dlcjI1LmVycm9yKFxuICAgICAgICAgIFwicG9wdWxhdGVFdmVudCB3aXRoIGFuIEV2ZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBieVwiLFxuICAgICAgICAgIHsgZXZlbnQsIGlrOiBpdGVtLmtleSwgZXZlbnRLZXk6IGtleSB9XG4gICAgICAgICk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvcHVsYXRlRXZlbnQgd2l0aCBhbiBFdmVudCB0aGF0IGRvZXMgbm90IGhhdmUgYnk6IFwiICsgSlNPTi5zdHJpbmdpZnkoeyBrZXkgfSkpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyMjUuZGVmYXVsdChcIkVWRU5UIFJldHJpZXZpbmcgSXRlbSBpbiBQb3B1bGF0ZVwiLCB7IGtleTogZXZlbnQuYnkgfSk7XG4gICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgY2FjaGVDb25maWcuY2FjaGUub3BlcmF0aW9ucy5yZXRyaWV2ZShldmVudC5ieSk7XG4gICAgICBpZiAobmV3SXRlbSkge1xuICAgICAgICBldmVudC5hZ2cgPSBuZXdJdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgYWxsMiA9IGFzeW5jIChxdWVyeSA9IHt9LCBsb2NhdGlvbnMgPSBbXSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJhbGxcIiwgeyBxdWVyeSwgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5hbGwocXVlcnksIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW0pID0+IHBvcHVsYXRlKGl0ZW0pKSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW1zO1xuICB9O1xuICBjb25zdCBvbmUyID0gYXN5bmMgKHF1ZXJ5ID0ge30sIGxvY2F0aW9ucyA9IFtdKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcIm9uZVwiLCB7IHF1ZXJ5LCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMub25lKHF1ZXJ5LCBsb2NhdGlvbnMpO1xuICAgIGxldCBwb3B1bGF0ZWRJdGVtID0gbnVsbDtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdWxhdGVkSXRlbTtcbiAgfTtcbiAgY29uc3QgYWN0aW9uMiA9IGFzeW5jIChrZXksIGFjdGlvbjMsIGJvZHkgPSB7fSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJhY3Rpb25cIiwgeyBrZXksIGFjdGlvbjogYWN0aW9uMywgYm9keSB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5hY3Rpb24oa2V5LCBhY3Rpb24zLCBib2R5KTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH07XG4gIGNvbnN0IGFsbEFjdGlvbjIgPSBhc3luYyAoYWN0aW9uMywgYm9keSA9IHt9LCBsb2NhdGlvbnMgPSBbXSkgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJhY3Rpb25cIiwgeyBhY3Rpb246IGFjdGlvbjMsIGJvZHksIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWxsQWN0aW9uKGFjdGlvbjMsIGJvZHksIGxvY2F0aW9ucyk7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW0pID0+IHBvcHVsYXRlKGl0ZW0pKSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW1zO1xuICB9O1xuICBjb25zdCBhbGxGYWNldDIgPSBhc3luYyAoZmFjZXQzLCBwYXJhbXMgPSB7fSwgbG9jYXRpb25zID0gW10pID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwiYWxsRmFjZXRcIiwgeyBmYWNldDogZmFjZXQzLCBwYXJhbXMsIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuYWxsRmFjZXQoZmFjZXQzLCBwYXJhbXMsIGxvY2F0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuICBjb25zdCBjcmVhdGUyID0gYXN5bmMgKHYsIGxvY2F0aW9ucyA9IFtdKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcImNyZWF0ZVwiLCB7IHYsIGxvY2F0aW9ucyB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5jcmVhdGUodiwgbG9jYXRpb25zKTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH07XG4gIGNvbnN0IGdldDIgPSBhc3luYyAoa2V5KSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcImdldFwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5nZXQoa2V5KTtcbiAgICBsZXQgcG9wdWxhdGVkSXRlbSA9IG51bGw7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH07XG4gIGNvbnN0IHJldHJpZXZlMiA9IGFzeW5jIChrZXkpID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwicmV0cmlldmVcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMucmV0cmlldmUoa2V5KTtcbiAgICBsZXQgcG9wdWxhdGVkSXRlbSA9IG51bGw7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHBvcHVsYXRlZEl0ZW0gPSBhd2FpdCBwb3B1bGF0ZShpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH07XG4gIGNvbnN0IHJlbW92ZTIgPSBhc3luYyAoa2V5KSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcInJlbW92ZVwiLCB7IGtleSB9KTtcbiAgICBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJlbW92ZShrZXkpO1xuICB9O1xuICBjb25zdCB1cGRhdGUyID0gYXN5bmMgKGtleSwgdikgPT4ge1xuICAgIGxvZ2dlcjI1LmRlZmF1bHQoXCJ1cGRhdGVcIiwgeyBrZXksIHYgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMudXBkYXRlKGtleSwgdik7XG4gICAgY29uc3QgcG9wdWxhdGVkSXRlbSA9IGF3YWl0IHBvcHVsYXRlKGl0ZW0pO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtO1xuICB9O1xuICBjb25zdCBmYWNldDIgPSBhc3luYyAoa2V5LCBmYWNldDMpID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwiZmFjZXRcIiwgeyBrZXksIGZhY2V0OiBmYWNldDMgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLmZhY2V0KGtleSwgZmFjZXQzKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG4gIGNvbnN0IGZpbmQyID0gYXN5bmMgKGZpbmRlciwgZmluZGVyUGFyYW1zID0ge30sIGxvY2F0aW9ucyA9IFtdKSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcImZpbmRcIiwgeyBmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zIH0pO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5maW5kKGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMpO1xuICAgIGNvbnN0IHBvcHVsYXRlZEl0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtKSA9PiBwb3B1bGF0ZShpdGVtKSkpO1xuICAgIHJldHVybiBwb3B1bGF0ZWRJdGVtcztcbiAgfTtcbiAgY29uc3QgZmluZE9uZTIgPSBhc3luYyAoZmluZGVyLCBmaW5kZXJQYXJhbXMgPSB7fSwgbG9jYXRpb25zID0gW10pID0+IHtcbiAgICBsb2dnZXIyNS5kZWZhdWx0KFwiZmluZFwiLCB7IGZpbmRlciwgZmluZGVyUGFyYW1zLCBsb2NhdGlvbnMgfSk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IGNhY2hlLm9wZXJhdGlvbnMuZmluZE9uZShmaW5kZXIsIGZpbmRlclBhcmFtcywgbG9jYXRpb25zKTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH07XG4gIGNvbnN0IHNldDIgPSBhc3luYyAoa2V5LCB2KSA9PiB7XG4gICAgbG9nZ2VyMjUuZGVmYXVsdChcInNldFwiLCB7IGtleSwgdiB9KTtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgY2FjaGUub3BlcmF0aW9ucy5zZXQoa2V5LCB2KTtcbiAgICBjb25zdCBwb3B1bGF0ZWRJdGVtID0gYXdhaXQgcG9wdWxhdGUoaXRlbSk7XG4gICAgcmV0dXJuIHBvcHVsYXRlZEl0ZW07XG4gIH07XG4gIGNvbnN0IHJlc2V0MiA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBjYWNoZS5vcGVyYXRpb25zLnJlc2V0KCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgLy8gQ2FjaGUgcHJvcGVydGllc1xuICAgIGNvb3JkaW5hdGU6IGNhY2hlLmNvb3JkaW5hdGUsXG4gICAgcmVnaXN0cnk6IGNhY2hlLnJlZ2lzdHJ5LFxuICAgIGFwaTogY2FjaGUuYXBpLFxuICAgIGNhY2hlTWFwOiBjYWNoZS5jYWNoZU1hcCxcbiAgICBvcGVyYXRpb25zOiBjYWNoZS5vcGVyYXRpb25zLFxuICAgIGV2aWN0aW9uTWFuYWdlcjogY2FjaGUuZXZpY3Rpb25NYW5hZ2VyLFxuICAgIHR0bE1hbmFnZXI6IGNhY2hlLnR0bE1hbmFnZXIsXG4gICAgc3RhdHNNYW5hZ2VyOiBjYWNoZS5zdGF0c01hbmFnZXIsXG4gICAgZ2V0U3RhdHM6IGNhY2hlLmdldFN0YXRzLmJpbmQoY2FjaGUpLFxuICAgIGdldENhY2hlSW5mbzogY2FjaGUuZ2V0Q2FjaGVJbmZvLmJpbmQoY2FjaGUpLFxuICAgIC8vIENhY2hlIG9wZXJhdGlvbnMgZXhwb3NlZCBkaXJlY3RseVxuICAgIGFsbDogYWxsMixcbiAgICBvbmU6IG9uZTIsXG4gICAgYWN0aW9uOiBhY3Rpb24yLFxuICAgIGFsbEFjdGlvbjogYWxsQWN0aW9uMixcbiAgICBhbGxGYWNldDogYWxsRmFjZXQyLFxuICAgIGNyZWF0ZTogY3JlYXRlMixcbiAgICBnZXQ6IGdldDIsXG4gICAgcmV0cmlldmU6IHJldHJpZXZlMixcbiAgICByZW1vdmU6IHJlbW92ZTIsXG4gICAgdXBkYXRlOiB1cGRhdGUyLFxuICAgIGZhY2V0OiBmYWNldDIsXG4gICAgZmluZDogZmluZDIsXG4gICAgZmluZE9uZTogZmluZE9uZTIsXG4gICAgcmVzZXQ6IHJlc2V0MixcbiAgICBzZXQ6IHNldDIsXG4gICAgLy8gQWdncmVnYXRvci1zcGVjaWZpYyBvcGVyYXRpb25zXG4gICAgcG9wdWxhdGUsXG4gICAgcG9wdWxhdGVBZ2dyZWdhdGUsXG4gICAgcG9wdWxhdGVFdmVudCxcbiAgICAvLyBFdmVudCBzeXN0ZW1cbiAgICBldmVudEVtaXR0ZXI6IGNhY2hlLmV2ZW50RW1pdHRlcixcbiAgICBzdWJzY3JpYmU6IChsaXN0ZW5lciwgb3B0aW9ucykgPT4gY2FjaGUuc3Vic2NyaWJlKGxpc3RlbmVyLCBvcHRpb25zKSxcbiAgICB1bnN1YnNjcmliZTogKHN1YnNjcmlwdGlvbikgPT4gY2FjaGUudW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uKSxcbiAgICBkZXN0cm95OiAoKSA9PiBjYWNoZS5kZXN0cm95KClcbiAgfTtcbn07XG5cbi8vIHNyYy9SZWdpc3RyeS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlUmVnaXN0cnkgYXMgY3JlYXRlQmFzZVJlZ2lzdHJ5XG59IGZyb20gXCJAZmplbGwvcmVnaXN0cnlcIjtcbnZhciBsb2dnZXIyNiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIlJlZ2lzdHJ5XCIpO1xudmFyIGNyZWF0ZVJlZ2lzdHJ5RmFjdG9yeSA9ICgpID0+IHtcbiAgcmV0dXJuICh0eXBlLCByZWdpc3RyeUh1YikgPT4ge1xuICAgIGlmICh0eXBlICE9PSBcImNhY2hlXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FjaGUgcmVnaXN0cnkgZmFjdG9yeSBjYW4gb25seSBjcmVhdGUgJ2NhY2hlJyB0eXBlIHJlZ2lzdHJpZXMsIGdvdDogJHt0eXBlfWApO1xuICAgIH1cbiAgICBsb2dnZXIyNi5kZWJ1ZyhcIkNyZWF0aW5nIGNhY2hlIHJlZ2lzdHJ5XCIsIHsgdHlwZSwgcmVnaXN0cnlIdWIgfSk7XG4gICAgY29uc3QgYmFzZVJlZ2lzdHJ5ID0gY3JlYXRlQmFzZVJlZ2lzdHJ5KHR5cGUsIHJlZ2lzdHJ5SHViKTtcbiAgICByZXR1cm4gYmFzZVJlZ2lzdHJ5O1xuICB9O1xufTtcbnZhciBjcmVhdGVSZWdpc3RyeSA9IChyZWdpc3RyeUh1YikgPT4ge1xuICBjb25zdCBiYXNlUmVnaXN0cnkgPSBjcmVhdGVCYXNlUmVnaXN0cnkoXCJjYWNoZVwiLCByZWdpc3RyeUh1Yik7XG4gIHJldHVybiB7XG4gICAgLi4uYmFzZVJlZ2lzdHJ5XG4gIH07XG59O1xuZXhwb3J0IHtcbiAgQXN5bmNJbmRleERCQ2FjaGVNYXAsXG4gIENhY2hlRXZlbnRFbWl0dGVyLFxuICBDYWNoZUV2ZW50RmFjdG9yeSxcbiAgQ2FjaGVNYXAsXG4gIENhY2hlU3RhdHNNYW5hZ2VyLFxuICBFbmhhbmNlZE1lbW9yeUNhY2hlTWFwLFxuICBFdmljdGlvbk1hbmFnZXIsXG4gIEluZGV4REJDYWNoZU1hcCxcbiAgTG9jYWxTdG9yYWdlQ2FjaGVNYXAsXG4gIE1lbW9yeUNhY2hlTWFwLFxuICBTZXNzaW9uU3RvcmFnZUNhY2hlTWFwLFxuICBUVExNYW5hZ2VyLFxuICBjcmVhdGVBZ2dyZWdhdG9yLFxuICBjcmVhdGVDYWNoZSxcbiAgY3JlYXRlQ2FjaGVNYXAsXG4gIGNyZWF0ZUV2aWN0aW9uU3RyYXRlZ3ksXG4gIGNyZWF0ZUluc3RhbmNlLFxuICBjcmVhdGVJbnN0YW5jZUZhY3RvcnksXG4gIGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24sXG4gIGNyZWF0ZU9wZXJhdGlvbnMsXG4gIGNyZWF0ZU9wdGlvbnMsXG4gIGNyZWF0ZVJlZ2lzdHJ5LFxuICBjcmVhdGVSZWdpc3RyeUZhY3RvcnksXG4gIGNyZWF0ZVZhbGlkYXRlZENvbmZpZyxcbiAgZXN0aW1hdGVWYWx1ZVNpemUsXG4gIGZvcm1hdEJ5dGVzLFxuICBpc0NhY2hlLFxuICBpc0luc3RhbmNlLFxuICBpc0xvY0tleUFycmF5RXF1YWwsXG4gIG5vcm1hbGl6ZUtleVZhbHVlLFxuICBub3JtYWxpemVMb2NLZXlJdGVtLFxuICBwYXJzZVNpemVTdHJpbmcsXG4gIHRvQ2FjaGVDb25maWcsXG4gIHZhbGlkYXRlQVJDQ29uZmlnLFxuICB2YWxpZGF0ZUV2aWN0aW9uU3RyYXRlZ3lDb25maWcsXG4gIHZhbGlkYXRlTEZVQ29uZmlnLFxuICB2YWxpZGF0ZU9wdGlvbnMsXG4gIHZhbGlkYXRlU2l6ZUNvbmZpZyxcbiAgdmFsaWRhdGVUd29RdWV1ZUNvbmZpZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/@fjell/cache/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/@fjell/core/dist/index.js":
/*!*****************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/core/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AItemService: () => (/* binding */ AItemService),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   IFactory: () => (/* binding */ IFactory),\n/* harmony export */   IQFactory: () => (/* binding */ IQFactory),\n/* harmony export */   abbrevAgg: () => (/* binding */ abbrevAgg),\n/* harmony export */   abbrevCompoundCondition: () => (/* binding */ abbrevCompoundCondition),\n/* harmony export */   abbrevCondition: () => (/* binding */ abbrevCondition),\n/* harmony export */   abbrevIK: () => (/* binding */ abbrevIK),\n/* harmony export */   abbrevLKA: () => (/* binding */ abbrevLKA),\n/* harmony export */   abbrevQuery: () => (/* binding */ abbrevQuery),\n/* harmony export */   abbrevRef: () => (/* binding */ abbrevRef),\n/* harmony export */   cPK: () => (/* binding */ cPK),\n/* harmony export */   constructPriKey: () => (/* binding */ constructPriKey),\n/* harmony export */   createNormalizedHashFunction: () => (/* binding */ createNormalizedHashFunction),\n/* harmony export */   generateKeyArray: () => (/* binding */ generateKeyArray),\n/* harmony export */   ikToLKA: () => (/* binding */ ikToLKA),\n/* harmony export */   isComItem: () => (/* binding */ isComItem),\n/* harmony export */   isComKey: () => (/* binding */ isComKey),\n/* harmony export */   isComKeyEqual: () => (/* binding */ isComKeyEqual),\n/* harmony export */   isComKeyEqualNormalized: () => (/* binding */ isComKeyEqualNormalized),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isItemKey: () => (/* binding */ isItemKey),\n/* harmony export */   isItemKeyEqual: () => (/* binding */ isItemKeyEqual),\n/* harmony export */   isItemKeyEqualNormalized: () => (/* binding */ isItemKeyEqualNormalized),\n/* harmony export */   isLocKey: () => (/* binding */ isLocKey),\n/* harmony export */   isLocKeyEqual: () => (/* binding */ isLocKeyEqual),\n/* harmony export */   isLocKeyEqualNormalized: () => (/* binding */ isLocKeyEqualNormalized),\n/* harmony export */   isPriItem: () => (/* binding */ isPriItem),\n/* harmony export */   isPriKey: () => (/* binding */ isPriKey),\n/* harmony export */   isPriKeyEqual: () => (/* binding */ isPriKeyEqual),\n/* harmony export */   isPriKeyEqualNormalized: () => (/* binding */ isPriKeyEqualNormalized),\n/* harmony export */   isQueryMatch: () => (/* binding */ isQueryMatch),\n/* harmony export */   isValidComKey: () => (/* binding */ isValidComKey),\n/* harmony export */   isValidItemKey: () => (/* binding */ isValidItemKey),\n/* harmony export */   isValidLocKey: () => (/* binding */ isValidLocKey),\n/* harmony export */   isValidLocKeyArray: () => (/* binding */ isValidLocKeyArray),\n/* harmony export */   isValidPriKey: () => (/* binding */ isValidPriKey),\n/* harmony export */   itemKeyToLocKeyArray: () => (/* binding */ itemKeyToLocKeyArray),\n/* harmony export */   lkaToIK: () => (/* binding */ lkaToIK),\n/* harmony export */   locKeyArrayToItemKey: () => (/* binding */ locKeyArrayToItemKey),\n/* harmony export */   paramsToQuery: () => (/* binding */ paramsToQuery),\n/* harmony export */   primaryType: () => (/* binding */ primaryType),\n/* harmony export */   queryToParams: () => (/* binding */ queryToParams),\n/* harmony export */   toKeyTypeArray: () => (/* binding */ toKeyTypeArray),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys),\n/* harmony export */   validatePK: () => (/* binding */ validatePK)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/../fjell-providers/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! luxon */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/luxon.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/core\");\nvar logger_default = LibLogger;\n\n// src/dictionary.ts\nvar logger = logger_default.get(\"Dictionary\");\nvar Dictionary = class _Dictionary {\n  map = {};\n  hashFunction = (key) => JSON.stringify(key);\n  constructor(map, hashFunction) {\n    if (hashFunction) {\n      this.hashFunction = hashFunction;\n    }\n    if (map) {\n      Object.entries(map).forEach(([hashedKey, value]) => {\n        try {\n          const originalKey = JSON.parse(hashedKey);\n          this.map[hashedKey] = { originalKey, value };\n        } catch {\n          logger.warning(\"Cannot recover original key from legacy map entry\", { hashedKey });\n        }\n      });\n    }\n  }\n  set(key, item) {\n    logger.trace(\"set\", { key, item });\n    const hashedKey = this.hashFunction(key);\n    this.map[hashedKey] = { originalKey: key, value: item };\n  }\n  get(key) {\n    logger.trace(\"get\", { key });\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry && this.keysEqual(entry.originalKey, key) ? entry.value : null;\n  }\n  keysEqual(key1, key2) {\n    return key1 === key2;\n  }\n  delete(key) {\n    logger.trace(\"delete\", { key });\n    const hashedKey = this.hashFunction(key);\n    delete this.map[hashedKey];\n  }\n  keys() {\n    return Object.values(this.map).map((entry) => entry.originalKey);\n  }\n  values() {\n    return Object.values(this.map).map((entry) => entry.value);\n  }\n  includesKey(key) {\n    const hashedKey = this.hashFunction(key);\n    const entry = this.map[hashedKey];\n    return entry ? this.keysEqual(entry.originalKey, key) : false;\n  }\n  clone() {\n    const clonedMap = {};\n    Object.entries(this.map).forEach(([hashedKey, entry]) => {\n      clonedMap[hashedKey] = entry.value;\n    });\n    const clone = new _Dictionary(clonedMap, this.hashFunction);\n    clone.map = Object.assign({}, this.map);\n    return clone;\n  }\n};\n\n// src/item/IFactory.ts\n\n\n// src/key/KUtils.ts\nvar logger2 = logger_default.get(\"KUtils\");\nvar normalizeKeyValue = (value) => {\n  return String(value);\n};\nvar createNormalizedHashFunction = () => {\n  return (key) => {\n    if (typeof key === \"object\" && key !== null) {\n      const normalizedKey = JSON.parse(JSON.stringify(key));\n      if (\"pk\" in normalizedKey && (normalizedKey.pk !== void 0 && normalizedKey.pk !== null)) {\n        normalizedKey.pk = normalizeKeyValue(normalizedKey.pk);\n      }\n      if (\"lk\" in normalizedKey && (normalizedKey.lk !== void 0 && normalizedKey.lk !== null)) {\n        normalizedKey.lk = normalizeKeyValue(normalizedKey.lk);\n      }\n      if (\"loc\" in normalizedKey && Array.isArray(normalizedKey.loc)) {\n        normalizedKey.loc = normalizedKey.loc.map((locItem) => {\n          if (locItem && \"lk\" in locItem && (locItem.lk !== void 0 && locItem.lk !== null)) {\n            return { ...locItem, lk: normalizeKeyValue(locItem.lk) };\n          }\n          return locItem;\n        });\n      }\n      return JSON.stringify(normalizedKey);\n    }\n    return JSON.stringify(key);\n  };\n};\nvar isPriKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isPriKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.pk) === normalizeKeyValue(b.pk) && a.kt === b.kt;\n};\nvar isLocKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isLocKeyEqualNormalized\", { a, b });\n  return a && b && normalizeKeyValue(a.lk) === normalizeKeyValue(b.lk) && a.kt === b.kt;\n};\nvar isComKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isComKeyEqualNormalized\", { a, b });\n  if (a && b && isPriKeyEqualNormalized({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqualNormalized(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqualNormalized = (a, b) => {\n  logger2.trace(\"isItemKeyEqualNormalized\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqualNormalized(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqualNormalized(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKeyEqual = (a, b) => {\n  logger2.trace(\"isKeyEqual\", { a, b });\n  if (isComKey(a) && isComKey(b)) {\n    return isComKeyEqual(a, b);\n  } else if (isPriKey(a) && isPriKey(b)) {\n    if (isComKey(a) || isComKey(b)) {\n      return false;\n    } else {\n      return isPriKeyEqual(a, b);\n    }\n  } else {\n    return false;\n  }\n};\nvar isPriKeyEqual = (a, b) => {\n  logger2.trace(\"isPriKeyEqual\", { a, b });\n  return a && b && a.pk === b.pk && a.kt === b.kt;\n};\nvar isLocKeyEqual = (a, b) => {\n  logger2.trace(\"isLocKeyEqual\", { a, b });\n  return a && b && a.lk === b.lk && a.kt === b.kt;\n};\nvar isComKeyEqual = (a, b) => {\n  logger2.trace(\"isComKeyEqual\", { a, b });\n  if (a && b && isPriKeyEqual({ kt: a.kt, pk: a.pk }, { kt: b.kt, pk: b.pk })) {\n    if (a.loc.length === b.loc.length) {\n      for (let i = 0; i < a.loc.length; i++) {\n        if (!isLocKeyEqual(a.loc[i], b.loc[i])) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\nvar isItemKey = (key) => {\n  logger2.trace(\"isItemKey\", { key });\n  return key !== void 0 && (isComKey(key) || isPriKey(key));\n};\nvar isComKey = (key) => {\n  logger2.trace(\"isComKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc !== void 0 && key.loc.length > 0);\n};\nvar isPriKey = (key) => {\n  logger2.trace(\"isPriKey\", { key });\n  return key !== void 0 && (key.pk !== void 0 && key.kt !== void 0) && (key.loc === void 0 || key.loc.length === 0);\n};\nvar isLocKey = (key) => {\n  logger2.trace(\"isLocKey\", { key });\n  return key !== void 0 && (key.lk !== void 0 && key.kt !== void 0);\n};\nvar generateKeyArray = (key) => {\n  logger2.trace(\"generateKeyArray\", { key });\n  const keys = [];\n  if (isComKey(key) || isPriKey(key)) {\n    if (isComKey(key)) {\n      const comKey = key;\n      keys.push({ pk: comKey.pk, kt: comKey.kt });\n      for (let i = 0; i < comKey.loc.length; i++) {\n        keys.push(comKey.loc[i]);\n      }\n    } else {\n      keys.push(key);\n    }\n  } else {\n    const locKeys = key;\n    for (let i = 0; i < locKeys.length; i++) {\n      keys.push(locKeys[i]);\n    }\n  }\n  return keys;\n};\nvar constructPriKey = (pk, kt) => {\n  logger2.trace(\"constructPriKey\", { pk, kt });\n  let pri;\n  if (typeof pk === \"string\" || typeof pk === \"number\") {\n    pri = { kt, pk };\n  } else {\n    pri = pk;\n  }\n  return pri;\n};\nvar cPK = constructPriKey;\nvar toKeyTypeArray = (ik) => {\n  logger2.trace(\"toKeyTypeArray\", { ik });\n  if (isComKey(ik)) {\n    const ck = ik;\n    return [ck.kt, ...ck.loc.map((l) => l.kt)];\n  } else {\n    return [ik.kt];\n  }\n};\nvar abbrevIK = (ik) => {\n  logger2.trace(\"abbrevIK\", { ik });\n  if (ik) {\n    if (isComKey(ik)) {\n      const ck = ik;\n      return `${ck.kt}:${ck.pk}:${ck.loc.map((l) => `${l.kt}:${l.lk}`).join(\",\")}`;\n    } else {\n      return `${ik.kt}:${ik.pk}`;\n    }\n  } else {\n    return \"null IK\";\n  }\n};\nvar abbrevLKA = (keyArray) => {\n  logger2.trace(\"abbrevLKA\", { keyArray });\n  if (keyArray === void 0 || keyArray === null) {\n    return \"null LKA\";\n  } else {\n    return keyArray.map((key) => {\n      if (key) {\n        return `${key.kt}:${key.lk}`;\n      } else {\n        return key;\n      }\n    }).join(\",\");\n  }\n};\nvar primaryType = (ik) => {\n  logger2.trace(\"primaryType\", { ik });\n  if (isComKey(ik)) {\n    return ik.kt;\n  } else {\n    return ik.kt;\n  }\n};\nvar itemKeyToLocKeyArray = (ik) => {\n  logger2.trace(\"itemKeyToLocKeyArray\", { ik: abbrevIK(ik) });\n  let lka = [];\n  if (isComKey(ik)) {\n    const ck = ik;\n    lka = [{ kt: ck.kt, lk: ck.pk }, ...ck.loc];\n  } else {\n    const pk = ik;\n    lka = [{ kt: pk.kt, lk: pk.pk }];\n  }\n  logger2.trace(\"itemKeyToLocKeyArray Results\", { ik: abbrevIK(ik), lka: abbrevLKA(lka) });\n  return lka;\n};\nvar ikToLKA = itemKeyToLocKeyArray;\nvar locKeyArrayToItemKey = (lka) => {\n  logger2.trace(\"locKeyArrayToItemKey\", { lka: abbrevLKA(lka) });\n  if (lka && lka.length === 1) {\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    return priKey;\n  } else if (lka && lka.length > 1 && lka[0] !== void 0) {\n    const locs = lka.slice(1);\n    const priKey = cPK(lka[0].lk, lka[0].kt);\n    const comKey = { kt: priKey.kt, pk: priKey.pk, loc: locs };\n    return comKey;\n  } else {\n    throw new Error(\"locKeyArrayToItemKey: lka is undefined or empty\");\n  }\n};\nvar isValidPriKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.pk !== void 0 && key.pk !== null && key.pk !== \"\" && key.pk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKey = (key) => {\n  const valid = key !== void 0 && key !== null && (key.lk !== void 0 && key.lk !== null && key.lk !== \"\" && key.lk !== \"null\") && (key.kt !== void 0 && key.kt !== null && key.kt !== \"\" && key.kt !== \"null\");\n  return valid;\n};\nvar isValidLocKeyArray = (keyArray) => {\n  return keyArray !== void 0 && keyArray !== null && keyArray.every(isValidLocKey);\n};\nvar isValidComKey = (key) => {\n  return key !== void 0 && key !== null && isValidPriKey(key) && isValidLocKeyArray(key.loc);\n};\nvar isValidItemKey = (key) => {\n  return isComKey(key) && isValidComKey(key) || isPriKey(key) && isValidPriKey(key);\n};\nvar lkaToIK = locKeyArrayToItemKey;\n\n// src/item/IFactory.ts\nvar IFactory = class _IFactory {\n  item = {};\n  constructor(props = {}) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n  }\n  addRef(i, name) {\n    const ik = i.key;\n    const refName = name || primaryType(ik);\n    if (!this.item.refs) {\n      this.item.refs = {};\n    }\n    this.item.refs[refName] = ik;\n    return this;\n  }\n  static addRef(i, name) {\n    return new _IFactory().addRef(i, name);\n  }\n  addDefaultEvents() {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    const now = /* @__PURE__ */ new Date();\n    if (!this.item.events.created) {\n      this.item.events.created = { at: now };\n    }\n    if (!this.item.events.updated) {\n      this.item.events.updated = { at: now };\n    }\n    if (!this.item.events.deleted) {\n      this.item.events.deleted = { at: null };\n    }\n    return this;\n  }\n  addEvent(name, at, by) {\n    if (!this.item.events) {\n      this.item.events = {};\n    }\n    this.item.events[name] = { at, by };\n    return this;\n  }\n  static addEvent(name, at, by) {\n    return new _IFactory().addEvent(name, at, by);\n  }\n  addProp(name, value) {\n    this.item[name] = value;\n    return this;\n  }\n  static addProp(name, value) {\n    return new _IFactory().addProp(name, value);\n  }\n  addProps(props) {\n    this.item = deepmerge__WEBPACK_IMPORTED_MODULE_1__(this.item, props);\n    return this;\n  }\n  static addProps(props) {\n    return new _IFactory().addProps(props);\n  }\n  toItem() {\n    return this.item;\n  }\n};\n\n// src/AItemService.ts\nvar AItemService = class {\n  pkType;\n  parentService = null;\n  constructor(pkType, parentService) {\n    this.pkType = pkType;\n    if (parentService) {\n      this.parentService = parentService;\n    }\n  }\n  getPkType = () => {\n    return this.pkType;\n  };\n  getKeyTypes = () => {\n    let keyTypes = [this.getPkType()];\n    if (this.parentService) {\n      keyTypes = keyTypes.concat(this.parentService.getKeyTypes());\n    }\n    return keyTypes;\n  };\n};\n\n// src/item/ItemQuery.ts\nvar isCondition = (condition) => {\n  return (typeof condition.column === \"string\" && (Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"string\")) || Array.isArray(condition.value) && condition.value.every((item) => typeof item === \"number\") || typeof condition.value === \"string\" || typeof condition.value === \"number\" || typeof condition.value === \"boolean\" || condition.value instanceof Date) && (condition.operator ? typeof condition.operator === \"string\" : true);\n};\n\n// src/item/IQFactory.ts\nvar IQFactory = class _IQFactory {\n  query = {};\n  constructor(query = {}) {\n    this.query = query;\n  }\n  orderBy(field, direction = \"asc\") {\n    if (!this.query.orderBy) {\n      this.query.orderBy = [];\n    }\n    this.query.orderBy.push({ field, direction });\n    return this;\n  }\n  agg(name, query) {\n    if (!this.query.aggs) {\n      this.query.aggs = {};\n    }\n    this.query.aggs[name] = query;\n    return this;\n  }\n  event(name, query) {\n    if (!this.query.events) {\n      this.query.events = {};\n    }\n    this.query.events[name] = query;\n    return this;\n  }\n  conditions(conditions, compoundType = \"AND\") {\n    for (const condition of conditions) {\n      if (!isCondition(condition)) {\n        throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n      }\n    }\n    if (!this.query.compoundCondition) {\n      this.query.compoundCondition = {\n        compoundType,\n        conditions\n      };\n    } else {\n      const compoundCondition = {\n        compoundType,\n        conditions\n      };\n      this.query.compoundCondition.conditions.push(compoundCondition);\n    }\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  // TODO: right now, we're only supporting PK refs for queries.  Should add support for CKs\n  pk(kt, pk, name) {\n    if (!this.query.refs) {\n      this.query.refs = {};\n    }\n    const refName = name || kt;\n    this.query.refs[refName] = cPK(pk, kt);\n    return this;\n  }\n  condition(column, value, operator = \"==\") {\n    const condition = { column, value, operator };\n    if (isCondition(condition)) {\n      if (!this.query.compoundCondition) {\n        this.query.compoundCondition = {\n          compoundType: \"AND\",\n          conditions: []\n        };\n      }\n      this.query.compoundCondition.conditions.push(condition);\n      return this;\n    } else {\n      throw new Error(`Invalid condition: ${JSON.stringify(condition)}`);\n    }\n  }\n  static all() {\n    const iqFactory = new _IQFactory();\n    return iqFactory;\n  }\n  static orderBy(field, direction = \"asc\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.orderBy(field, direction);\n  }\n  static agg(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.agg(name, query);\n  }\n  static event(name, query) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.event(name, query);\n  }\n  static limit(limit) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.limit(limit);\n  }\n  static offset(offset) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.offset(offset);\n  }\n  static pk(kt, pk, name) {\n    const iqFactory = new _IQFactory();\n    return iqFactory.pk(kt, pk, name);\n  }\n  static condition(column, value, operator = \"==\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.condition(column, value, operator);\n  }\n  static conditions(conditions, compoundType = \"AND\") {\n    const iqFactory = new _IQFactory();\n    return iqFactory.conditions(conditions, compoundType);\n  }\n  toQuery() {\n    return this.query;\n  }\n};\n\n// src/item/IQUtils.ts\n\nvar logger3 = logger_default.get(\"IQUtils\");\nvar queryToParams = (query) => {\n  const params = {};\n  if (query.compoundCondition) {\n    params.compoundCondition = JSON.stringify(query.compoundCondition);\n  }\n  if (query.refs) {\n    params.refs = JSON.stringify(query.refs);\n  }\n  if (query.limit) {\n    params.limit = query.limit;\n  }\n  if (query.offset) {\n    params.offset = query.offset;\n  }\n  if (query.aggs) {\n    params.aggs = JSON.stringify(query.aggs);\n  }\n  if (query.events) {\n    params.events = JSON.stringify(query.events);\n  }\n  return params;\n};\nvar dateTimeReviver = function(key, value) {\n  if (typeof value === \"string\") {\n    const parsedDate = luxon__WEBPACK_IMPORTED_MODULE_2__.DateTime.fromISO(value);\n    if (parsedDate.isValid) {\n      return parsedDate.toJSDate();\n      ;\n    }\n  }\n  return value;\n};\nvar paramsToQuery = (params) => {\n  const query = {};\n  if (params.compoundCondition) {\n    query.compoundCondition = JSON.parse(params.compoundCondition);\n  }\n  if (params.refs) {\n    query.refs = JSON.parse(params.refs);\n  }\n  if (params.limit) {\n    query.limit = Number(params.limit);\n  }\n  if (params.offset) {\n    query.offset = Number(params.offset);\n  }\n  if (params.aggs) {\n    query.aggs = JSON.parse(params.aggs);\n  }\n  if (params.events) {\n    query.events = JSON.parse(params.events, dateTimeReviver);\n  }\n  return query;\n};\nvar isRefQueryMatch = (refKey, queryRef, references) => {\n  logger3.trace(\"doesRefMatch\", { queryRef, references });\n  logger3.debug(\"Comparing Ref\", { refKey, itemRef: references[refKey], queryRef });\n  return isItemKeyEqual(queryRef, references[refKey]);\n};\nvar isCompoundConditionQueryMatch = (queryCondition, item) => {\n  if (queryCondition.compoundType === \"AND\") {\n    return queryCondition.conditions.every(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  } else {\n    return queryCondition.conditions.some(\n      (condition) => isCondition(condition) ? isConditionQueryMatch(condition, item) : isCompoundConditionQueryMatch(condition, item)\n    );\n  }\n};\nvar isConditionQueryMatch = (queryCondition, item) => {\n  const propKey = queryCondition.column;\n  logger3.trace(\"doesConditionMatch\", { propKey, queryCondition, item });\n  if (item[propKey] === void 0) {\n    logger3.debug(\"Item does not contain prop under key\", { propKey, item });\n    return false;\n  }\n  logger3.debug(\"Comparing Condition\", { propKey, itemProp: item[propKey], queryCondition });\n  let result = false;\n  switch (queryCondition.operator) {\n    case \"==\":\n      result = item[propKey] === queryCondition.value;\n      break;\n    case \"!=\":\n      result = item[propKey] !== queryCondition.value;\n      break;\n    case \">\":\n      result = item[propKey] > queryCondition.value;\n      break;\n    case \">=\":\n      result = item[propKey] >= queryCondition.value;\n      break;\n    case \"<\":\n      result = item[propKey] < queryCondition.value;\n      break;\n    case \"<=\":\n      result = item[propKey] <= queryCondition.value;\n      break;\n    case \"in\":\n      result = queryCondition.value.includes(item[propKey]);\n      break;\n    case \"not-in\":\n      result = !queryCondition.value.includes(item[propKey]);\n      break;\n    case \"array-contains\":\n      result = item[propKey].includes(queryCondition.value);\n      break;\n    case \"array-contains-any\":\n      result = queryCondition.value.some((value) => item[propKey].includes(value));\n      break;\n  }\n  return result;\n};\nvar isAggQueryMatch = (aggKey, aggQuery, agg) => {\n  const aggItem = agg.item;\n  logger3.debug(\"Comparing Agg\", { aggKey, aggItem, aggQuery });\n  return isQueryMatch(aggItem, aggQuery);\n};\nvar isEventQueryMatch = (eventKey, eventQuery, item) => {\n  if (!item.events[eventKey]) {\n    logger3.debug(\"Item does not contain event under key\", { eventKey, events: item.events });\n    return false;\n  } else {\n    const itemEvent = item.events[eventKey];\n    if (itemEvent.at !== null) {\n      if (eventQuery.start && !(eventQuery.start.getTime() <= itemEvent.at.getTime())) {\n        logger3.debug(\"Item date before event start query\", { eventQuery, itemEvent });\n        return false;\n      }\n      if (eventQuery.end && !(eventQuery.end.getTime() > itemEvent.at.getTime())) {\n        logger3.debug(\"Item date after event end query\", { eventQuery, itemEvent });\n        return false;\n      }\n    } else {\n      logger3.debug(\"Item event does contains a null at\", { itemEvent });\n      return false;\n    }\n    return true;\n  }\n};\nvar isQueryMatch = (item, query) => {\n  logger3.trace(\"isMatch\", { item, query });\n  if (query.refs && item.refs) {\n    for (const key in query.refs) {\n      const queryRef = query.refs[key];\n      if (!isRefQueryMatch(key, queryRef, item.refs)) return false;\n    }\n  } else if (query.refs && !item.refs) {\n    logger3.debug(\"Query contains refs but item does not have refs\", { query, item });\n    return false;\n  }\n  if (query.compoundCondition && item) {\n    if (!isCompoundConditionQueryMatch(query.compoundCondition, item)) return false;\n  }\n  if (query.events && item.events) {\n    for (const key in query.events) {\n      const queryEvent = query.events[key];\n      if (!isEventQueryMatch(key, queryEvent, item)) return false;\n    }\n    return true;\n  }\n  if (query.aggs && item.aggs) {\n    for (const key in query.aggs) {\n      const aggQuery = query.aggs[key];\n      if (item.aggs[key] && !isAggQueryMatch(key, aggQuery, item.aggs[key])) return false;\n    }\n  }\n  if (query.aggs && !item.aggs) {\n    logger3.debug(\"Query contains aggs but item does not have aggs\", { query, item });\n    return false;\n  }\n  return true;\n};\nvar abbrevQuery = (query) => {\n  const abbrev = [\"IQ\"];\n  if (query) {\n    if (query.refs) {\n      for (const key in query.refs) {\n        const ref = abbrevRef(key, query.refs[key]);\n        abbrev.push(ref);\n      }\n    }\n    if (query.compoundCondition) {\n      const props = abbrevCompoundCondition(query.compoundCondition);\n      abbrev.push(props);\n    }\n    if (query.aggs) {\n      for (const key in query.aggs) {\n        const agg = abbrevAgg(key, query.aggs[key]);\n        abbrev.push(agg);\n      }\n    }\n    if (query.events) {\n      const events = `(E${Object.keys(query.events).join(\",\")})`;\n      abbrev.push(events);\n    }\n    if (query.limit) {\n      abbrev.push(`L${query.limit}`);\n    }\n    if (query.offset) {\n      abbrev.push(`O${query.offset}`);\n    }\n  } else {\n    abbrev.push(\"(empty)\");\n  }\n  return abbrev.join(\" \");\n};\nvar abbrevRef = (key, ref) => {\n  if (isPriKey(ref)) {\n    const priKey = ref;\n    return `R(${key},${priKey.kt},${priKey.pk})`;\n  } else {\n    const comKey = ref;\n    return `R(${key},${JSON.stringify(comKey)})`;\n  }\n};\nvar abbrevAgg = (key, agg) => {\n  return `A(${key},${abbrevQuery(agg)})`;\n};\nvar abbrevCompoundCondition = (compoundCondition) => {\n  return `CC(${compoundCondition.compoundType},${compoundCondition.conditions ? compoundCondition.conditions.map(abbrevCondition).join(\",\") : \"No Conditions\"})`;\n};\nvar abbrevCondition = (condition) => {\n  if (isCondition(condition)) {\n    return `(${condition.column},${condition.value},${condition.operator})`;\n  } else {\n    return abbrevCompoundCondition(condition);\n  }\n};\n\n// src/item/IUtils.ts\nvar logger4 = logger_default.get(\"IUtils\");\nvar validatePKForItem = (item, pkType) => {\n  if (!item) {\n    logger4.error(\"Validating PK, Item is undefined\", { item });\n    throw new Error(\"Validating PK, Item is undefined\");\n  }\n  if (!item.key) {\n    logger4.error(\"Validating PK, Item does not have a key\", { item });\n    throw new Error(\"Validating PK, Item does not have a key\");\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray[0] !== pkType) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, pkType });\n    throw new Error(`Item does not have the correct primary key type. Expected ${pkType}, got ${keyTypeArray[0]}`);\n  }\n  return item;\n};\nvar validatePK = (input, pkType) => {\n  logger4.trace(\"Checking Return Type\", { input });\n  if (Array.isArray(input)) {\n    return input.map((item) => validatePKForItem(item, pkType));\n  }\n  return validatePKForItem(input, pkType);\n};\nvar validateKeys = (item, keyTypes) => {\n  logger4.trace(\"Checking Return Type\", { item });\n  if (!item) {\n    throw new Error(\"validating keys, item is undefined\");\n  }\n  if (!item.key) {\n    throw new Error(\"validating keys, item does not have a key: \" + JSON.stringify(item));\n  }\n  const keyTypeArray = toKeyTypeArray(item.key);\n  if (keyTypeArray.length !== keyTypes.length) {\n    throw new Error(`Item does not have the correct number of keys. Expected ${keyTypes.length}, but got ${keyTypeArray.length}`);\n  }\n  const match = JSON.stringify(keyTypeArray) === JSON.stringify(keyTypes);\n  if (!match) {\n    logger4.error(\"Key Type Array Mismatch\", { keyTypeArray, thisKeyTypes: keyTypes });\n    throw new Error(`Item does not have the correct key types. Expected [${keyTypes.join(\", \")}], but got [${keyTypeArray.join(\", \")}]`);\n  }\n  return item;\n};\nvar isPriItem = (item) => {\n  return !!(item && item.key && isPriKey(item.key));\n};\nvar isComItem = (item) => {\n  return !!(item && item.key && isComKey(item.key));\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDO0FBQ3JDLGdCQUFnQixnRUFBaUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsVUFBVTtBQUNWLGdGQUFnRixXQUFXO0FBQzNGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRCwwQ0FBMEMsb0JBQW9CLElBQUksb0JBQW9CO0FBQ3RGO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekMsZ0NBQWdDLG9CQUFvQixJQUFJLG9CQUFvQjtBQUM1RTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hELHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0EsWUFBWTtBQUNaLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSxHQUFHLE1BQU0sR0FBRyxxQkFBcUIsS0FBSyxHQUFHLEtBQUssYUFBYTtBQUNqRixNQUFNO0FBQ04sZ0JBQWdCLE1BQU0sR0FBRyxNQUFNO0FBQy9CO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0JBQWtCLE9BQU8sR0FBRyxPQUFPO0FBQ25DLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLElBQUk7QUFDSjtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0Esa0RBQWtELHVDQUF1QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0Isc0NBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQytCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQsbUNBQW1DLCtDQUErQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQSw0REFBNEQsZUFBZTtBQUMzRTtBQUNBO0FBQ0EseUNBQXlDLGtEQUFrRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsK0JBQStCO0FBQzVGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx1QkFBdUI7QUFDckY7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLEdBQUcsVUFBVSxHQUFHLFVBQVU7QUFDOUMsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLElBQUksR0FBRyx1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEdBQUcsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxlQUFlLCtCQUErQixHQUFHLDZHQUE2RztBQUM5SjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQjtBQUN6RSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFLGlGQUFpRixPQUFPLFFBQVEsZ0JBQWdCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDL0g7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNDQUFzQztBQUNyRiwyRUFBMkUsb0JBQW9CLGNBQWMsd0JBQXdCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdERTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvQGZqZWxsL2NvcmUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbG9nZ2VyLnRzXG5pbXBvcnQgTG9nZ2luZyBmcm9tIFwiQGZqZWxsL2xvZ2dpbmdcIjtcbnZhciBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcihcIkBmamVsbC9jb3JlXCIpO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTGliTG9nZ2VyO1xuXG4vLyBzcmMvZGljdGlvbmFyeS50c1xudmFyIGxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIkRpY3Rpb25hcnlcIik7XG52YXIgRGljdGlvbmFyeSA9IGNsYXNzIF9EaWN0aW9uYXJ5IHtcbiAgbWFwID0ge307XG4gIGhhc2hGdW5jdGlvbiA9IChrZXkpID0+IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIGNvbnN0cnVjdG9yKG1hcCwgaGFzaEZ1bmN0aW9uKSB7XG4gICAgaWYgKGhhc2hGdW5jdGlvbikge1xuICAgICAgdGhpcy5oYXNoRnVuY3Rpb24gPSBoYXNoRnVuY3Rpb247XG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG1hcCkuZm9yRWFjaCgoW2hhc2hlZEtleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBKU09OLnBhcnNlKGhhc2hlZEtleSk7XG4gICAgICAgICAgdGhpcy5tYXBbaGFzaGVkS2V5XSA9IHsgb3JpZ2luYWxLZXksIHZhbHVlIH07XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGxvZ2dlci53YXJuaW5nKFwiQ2Fubm90IHJlY292ZXIgb3JpZ2luYWwga2V5IGZyb20gbGVnYWN5IG1hcCBlbnRyeVwiLCB7IGhhc2hlZEtleSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNldChrZXksIGl0ZW0pIHtcbiAgICBsb2dnZXIudHJhY2UoXCJzZXRcIiwgeyBrZXksIGl0ZW0gfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICB0aGlzLm1hcFtoYXNoZWRLZXldID0geyBvcmlnaW5hbEtleToga2V5LCB2YWx1ZTogaXRlbSB9O1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBsb2dnZXIudHJhY2UoXCJnZXRcIiwgeyBrZXkgfSk7XG4gICAgY29uc3QgaGFzaGVkS2V5ID0gdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwW2hhc2hlZEtleV07XG4gICAgcmV0dXJuIGVudHJ5ICYmIHRoaXMua2V5c0VxdWFsKGVudHJ5Lm9yaWdpbmFsS2V5LCBrZXkpID8gZW50cnkudmFsdWUgOiBudWxsO1xuICB9XG4gIGtleXNFcXVhbChrZXkxLCBrZXkyKSB7XG4gICAgcmV0dXJuIGtleTEgPT09IGtleTI7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIGxvZ2dlci50cmFjZShcImRlbGV0ZVwiLCB7IGtleSB9KTtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtoYXNoZWRLZXldO1xuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcCgoZW50cnkpID0+IGVudHJ5Lm9yaWdpbmFsS2V5KTtcbiAgfVxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5tYXApLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKTtcbiAgfVxuICBpbmNsdWRlc0tleShrZXkpIHtcbiAgICBjb25zdCBoYXNoZWRLZXkgPSB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBbaGFzaGVkS2V5XTtcbiAgICByZXR1cm4gZW50cnkgPyB0aGlzLmtleXNFcXVhbChlbnRyeS5vcmlnaW5hbEtleSwga2V5KSA6IGZhbHNlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lZE1hcCA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMubWFwKS5mb3JFYWNoKChbaGFzaGVkS2V5LCBlbnRyeV0pID0+IHtcbiAgICAgIGNsb25lZE1hcFtoYXNoZWRLZXldID0gZW50cnkudmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgX0RpY3Rpb25hcnkoY2xvbmVkTWFwLCB0aGlzLmhhc2hGdW5jdGlvbik7XG4gICAgY2xvbmUubWFwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5tYXApO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufTtcblxuLy8gc3JjL2l0ZW0vSUZhY3RvcnkudHNcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSBcImRlZXBtZXJnZVwiO1xuXG4vLyBzcmMva2V5L0tVdGlscy50c1xudmFyIGxvZ2dlcjIgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJLVXRpbHNcIik7XG52YXIgbm9ybWFsaXplS2V5VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xudmFyIGNyZWF0ZU5vcm1hbGl6ZWRIYXNoRnVuY3Rpb24gPSAoKSA9PiB7XG4gIHJldHVybiAoa2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShrZXkpKTtcbiAgICAgIGlmIChcInBrXCIgaW4gbm9ybWFsaXplZEtleSAmJiAobm9ybWFsaXplZEtleS5wayAhPT0gdm9pZCAwICYmIG5vcm1hbGl6ZWRLZXkucGsgIT09IG51bGwpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkucGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LnBrKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImxrXCIgaW4gbm9ybWFsaXplZEtleSAmJiAobm9ybWFsaXplZEtleS5sayAhPT0gdm9pZCAwICYmIG5vcm1hbGl6ZWRLZXkubGsgIT09IG51bGwpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRLZXkubGsgPSBub3JtYWxpemVLZXlWYWx1ZShub3JtYWxpemVkS2V5LmxrKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImxvY1wiIGluIG5vcm1hbGl6ZWRLZXkgJiYgQXJyYXkuaXNBcnJheShub3JtYWxpemVkS2V5LmxvYykpIHtcbiAgICAgICAgbm9ybWFsaXplZEtleS5sb2MgPSBub3JtYWxpemVkS2V5LmxvYy5tYXAoKGxvY0l0ZW0pID0+IHtcbiAgICAgICAgICBpZiAobG9jSXRlbSAmJiBcImxrXCIgaW4gbG9jSXRlbSAmJiAobG9jSXRlbS5sayAhPT0gdm9pZCAwICYmIGxvY0l0ZW0ubGsgIT09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5sb2NJdGVtLCBsazogbm9ybWFsaXplS2V5VmFsdWUobG9jSXRlbS5saykgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY0l0ZW07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgfTtcbn07XG52YXIgaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWRcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIG5vcm1hbGl6ZUtleVZhbHVlKGEucGspID09PSBub3JtYWxpemVLZXlWYWx1ZShiLnBrKSAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0xvY0tleUVxdWFsTm9ybWFsaXplZCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0xvY0tleUVxdWFsTm9ybWFsaXplZFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgbm9ybWFsaXplS2V5VmFsdWUoYS5saykgPT09IG5vcm1hbGl6ZUtleVZhbHVlKGIubGspICYmIGEua3QgPT09IGIua3Q7XG59O1xudmFyIGlzQ29tS2V5RXF1YWxOb3JtYWxpemVkID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzQ29tS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGEgJiYgYiAmJiBpc1ByaUtleUVxdWFsTm9ybWFsaXplZCh7IGt0OiBhLmt0LCBwazogYS5wayB9LCB7IGt0OiBiLmt0LCBwazogYi5wayB9KSkge1xuICAgIGlmIChhLmxvYy5sZW5ndGggPT09IGIubG9jLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTG9jS2V5RXF1YWxOb3JtYWxpemVkKGEubG9jW2ldLCBiLmxvY1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWQgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNJdGVtS2V5RXF1YWxOb3JtYWxpemVkXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGlzQ29tS2V5KGEpICYmIGlzQ29tS2V5KGIpKSB7XG4gICAgcmV0dXJuIGlzQ29tS2V5RXF1YWxOb3JtYWxpemVkKGEsIGIpO1xuICB9IGVsc2UgaWYgKGlzUHJpS2V5KGEpICYmIGlzUHJpS2V5KGIpKSB7XG4gICAgaWYgKGlzQ29tS2V5KGEpIHx8IGlzQ29tS2V5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc1ByaUtleUVxdWFsTm9ybWFsaXplZChhLCBiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzSXRlbUtleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICBpZiAoaXNDb21LZXkoYSkgJiYgaXNDb21LZXkoYikpIHtcbiAgICByZXR1cm4gaXNDb21LZXlFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmIChpc1ByaUtleShhKSAmJiBpc1ByaUtleShiKSkge1xuICAgIGlmIChpc0NvbUtleShhKSB8fCBpc0NvbUtleShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNQcmlLZXlFcXVhbChhLCBiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzUHJpS2V5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNQcmlLZXlFcXVhbFwiLCB7IGEsIGIgfSk7XG4gIHJldHVybiBhICYmIGIgJiYgYS5wayA9PT0gYi5wayAmJiBhLmt0ID09PSBiLmt0O1xufTtcbnZhciBpc0xvY0tleUVxdWFsID0gKGEsIGIpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImlzTG9jS2V5RXF1YWxcIiwgeyBhLCBiIH0pO1xuICByZXR1cm4gYSAmJiBiICYmIGEubGsgPT09IGIubGsgJiYgYS5rdCA9PT0gYi5rdDtcbn07XG52YXIgaXNDb21LZXlFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc0NvbUtleUVxdWFsXCIsIHsgYSwgYiB9KTtcbiAgaWYgKGEgJiYgYiAmJiBpc1ByaUtleUVxdWFsKHsga3Q6IGEua3QsIHBrOiBhLnBrIH0sIHsga3Q6IGIua3QsIHBrOiBiLnBrIH0pKSB7XG4gICAgaWYgKGEubG9jLmxlbmd0aCA9PT0gYi5sb2MubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNMb2NLZXlFcXVhbChhLmxvY1tpXSwgYi5sb2NbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgaXNJdGVtS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNJdGVtS2V5XCIsIHsga2V5IH0pO1xuICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYgKGlzQ29tS2V5KGtleSkgfHwgaXNQcmlLZXkoa2V5KSk7XG59O1xudmFyIGlzQ29tS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNDb21LZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoa2V5LnBrICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSB2b2lkIDApICYmIChrZXkubG9jICE9PSB2b2lkIDAgJiYga2V5LmxvYy5sZW5ndGggPiAwKTtcbn07XG52YXIgaXNQcmlLZXkgPSAoa2V5KSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpc1ByaUtleVwiLCB7IGtleSB9KTtcbiAgcmV0dXJuIGtleSAhPT0gdm9pZCAwICYmIChrZXkucGsgIT09IHZvaWQgMCAmJiBrZXkua3QgIT09IHZvaWQgMCkgJiYgKGtleS5sb2MgPT09IHZvaWQgMCB8fCBrZXkubG9jLmxlbmd0aCA9PT0gMCk7XG59O1xudmFyIGlzTG9jS2V5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiaXNMb2NLZXlcIiwgeyBrZXkgfSk7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiAoa2V5LmxrICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSB2b2lkIDApO1xufTtcbnZhciBnZW5lcmF0ZUtleUFycmF5ID0gKGtleSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiZ2VuZXJhdGVLZXlBcnJheVwiLCB7IGtleSB9KTtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBpZiAoaXNDb21LZXkoa2V5KSB8fCBpc1ByaUtleShrZXkpKSB7XG4gICAgaWYgKGlzQ29tS2V5KGtleSkpIHtcbiAgICAgIGNvbnN0IGNvbUtleSA9IGtleTtcbiAgICAgIGtleXMucHVzaCh7IHBrOiBjb21LZXkucGssIGt0OiBjb21LZXkua3QgfSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbUtleS5sb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5cy5wdXNoKGNvbUtleS5sb2NbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbG9jS2V5cyA9IGtleTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaChsb2NLZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIGNvbnN0cnVjdFByaUtleSA9IChwaywga3QpID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcImNvbnN0cnVjdFByaUtleVwiLCB7IHBrLCBrdCB9KTtcbiAgbGV0IHByaTtcbiAgaWYgKHR5cGVvZiBwayA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGsgPT09IFwibnVtYmVyXCIpIHtcbiAgICBwcmkgPSB7IGt0LCBwayB9O1xuICB9IGVsc2Uge1xuICAgIHByaSA9IHBrO1xuICB9XG4gIHJldHVybiBwcmk7XG59O1xudmFyIGNQSyA9IGNvbnN0cnVjdFByaUtleTtcbnZhciB0b0tleVR5cGVBcnJheSA9IChpaykgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwidG9LZXlUeXBlQXJyYXlcIiwgeyBpayB9KTtcbiAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgIGNvbnN0IGNrID0gaWs7XG4gICAgcmV0dXJuIFtjay5rdCwgLi4uY2subG9jLm1hcCgobCkgPT4gbC5rdCldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaWsua3RdO1xuICB9XG59O1xudmFyIGFiYnJldklLID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJhYmJyZXZJS1wiLCB7IGlrIH0pO1xuICBpZiAoaWspIHtcbiAgICBpZiAoaXNDb21LZXkoaWspKSB7XG4gICAgICBjb25zdCBjayA9IGlrO1xuICAgICAgcmV0dXJuIGAke2NrLmt0fToke2NrLnBrfToke2NrLmxvYy5tYXAoKGwpID0+IGAke2wua3R9OiR7bC5sa31gKS5qb2luKFwiLFwiKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7aWsua3R9OiR7aWsucGt9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwibnVsbCBJS1wiO1xuICB9XG59O1xudmFyIGFiYnJldkxLQSA9IChrZXlBcnJheSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwiYWJicmV2TEtBXCIsIHsga2V5QXJyYXkgfSk7XG4gIGlmIChrZXlBcnJheSA9PT0gdm9pZCAwIHx8IGtleUFycmF5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbCBMS0FcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5QXJyYXkubWFwKChrZXkpID0+IHtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGAke2tleS5rdH06JHtrZXkubGt9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfSkuam9pbihcIixcIik7XG4gIH1cbn07XG52YXIgcHJpbWFyeVR5cGUgPSAoaWspID0+IHtcbiAgbG9nZ2VyMi50cmFjZShcInByaW1hcnlUeXBlXCIsIHsgaWsgfSk7XG4gIGlmIChpc0NvbUtleShpaykpIHtcbiAgICByZXR1cm4gaWsua3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlrLmt0O1xuICB9XG59O1xudmFyIGl0ZW1LZXlUb0xvY0tleUFycmF5ID0gKGlrKSA9PiB7XG4gIGxvZ2dlcjIudHJhY2UoXCJpdGVtS2V5VG9Mb2NLZXlBcnJheVwiLCB7IGlrOiBhYmJyZXZJSyhpaykgfSk7XG4gIGxldCBsa2EgPSBbXTtcbiAgaWYgKGlzQ29tS2V5KGlrKSkge1xuICAgIGNvbnN0IGNrID0gaWs7XG4gICAgbGthID0gW3sga3Q6IGNrLmt0LCBsazogY2sucGsgfSwgLi4uY2subG9jXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwayA9IGlrO1xuICAgIGxrYSA9IFt7IGt0OiBway5rdCwgbGs6IHBrLnBrIH1dO1xuICB9XG4gIGxvZ2dlcjIudHJhY2UoXCJpdGVtS2V5VG9Mb2NLZXlBcnJheSBSZXN1bHRzXCIsIHsgaWs6IGFiYnJldklLKGlrKSwgbGthOiBhYmJyZXZMS0EobGthKSB9KTtcbiAgcmV0dXJuIGxrYTtcbn07XG52YXIgaWtUb0xLQSA9IGl0ZW1LZXlUb0xvY0tleUFycmF5O1xudmFyIGxvY0tleUFycmF5VG9JdGVtS2V5ID0gKGxrYSkgPT4ge1xuICBsb2dnZXIyLnRyYWNlKFwibG9jS2V5QXJyYXlUb0l0ZW1LZXlcIiwgeyBsa2E6IGFiYnJldkxLQShsa2EpIH0pO1xuICBpZiAobGthICYmIGxrYS5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBwcmlLZXkgPSBjUEsobGthWzBdLmxrLCBsa2FbMF0ua3QpO1xuICAgIHJldHVybiBwcmlLZXk7XG4gIH0gZWxzZSBpZiAobGthICYmIGxrYS5sZW5ndGggPiAxICYmIGxrYVswXSAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbG9jcyA9IGxrYS5zbGljZSgxKTtcbiAgICBjb25zdCBwcmlLZXkgPSBjUEsobGthWzBdLmxrLCBsa2FbMF0ua3QpO1xuICAgIGNvbnN0IGNvbUtleSA9IHsga3Q6IHByaUtleS5rdCwgcGs6IHByaUtleS5waywgbG9jOiBsb2NzIH07XG4gICAgcmV0dXJuIGNvbUtleTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2NLZXlBcnJheVRvSXRlbUtleTogbGthIGlzIHVuZGVmaW5lZCBvciBlbXB0eVwiKTtcbiAgfVxufTtcbnZhciBpc1ZhbGlkUHJpS2V5ID0gKGtleSkgPT4ge1xuICBjb25zdCB2YWxpZCA9IGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gbnVsbCAmJiAoa2V5LnBrICE9PSB2b2lkIDAgJiYga2V5LnBrICE9PSBudWxsICYmIGtleS5wayAhPT0gXCJcIiAmJiBrZXkucGsgIT09IFwibnVsbFwiKSAmJiAoa2V5Lmt0ICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSBudWxsICYmIGtleS5rdCAhPT0gXCJcIiAmJiBrZXkua3QgIT09IFwibnVsbFwiKTtcbiAgcmV0dXJuIHZhbGlkO1xufTtcbnZhciBpc1ZhbGlkTG9jS2V5ID0gKGtleSkgPT4ge1xuICBjb25zdCB2YWxpZCA9IGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gbnVsbCAmJiAoa2V5LmxrICE9PSB2b2lkIDAgJiYga2V5LmxrICE9PSBudWxsICYmIGtleS5sayAhPT0gXCJcIiAmJiBrZXkubGsgIT09IFwibnVsbFwiKSAmJiAoa2V5Lmt0ICE9PSB2b2lkIDAgJiYga2V5Lmt0ICE9PSBudWxsICYmIGtleS5rdCAhPT0gXCJcIiAmJiBrZXkua3QgIT09IFwibnVsbFwiKTtcbiAgcmV0dXJuIHZhbGlkO1xufTtcbnZhciBpc1ZhbGlkTG9jS2V5QXJyYXkgPSAoa2V5QXJyYXkpID0+IHtcbiAgcmV0dXJuIGtleUFycmF5ICE9PSB2b2lkIDAgJiYga2V5QXJyYXkgIT09IG51bGwgJiYga2V5QXJyYXkuZXZlcnkoaXNWYWxpZExvY0tleSk7XG59O1xudmFyIGlzVmFsaWRDb21LZXkgPSAoa2V5KSA9PiB7XG4gIHJldHVybiBrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IG51bGwgJiYgaXNWYWxpZFByaUtleShrZXkpICYmIGlzVmFsaWRMb2NLZXlBcnJheShrZXkubG9jKTtcbn07XG52YXIgaXNWYWxpZEl0ZW1LZXkgPSAoa2V5KSA9PiB7XG4gIHJldHVybiBpc0NvbUtleShrZXkpICYmIGlzVmFsaWRDb21LZXkoa2V5KSB8fCBpc1ByaUtleShrZXkpICYmIGlzVmFsaWRQcmlLZXkoa2V5KTtcbn07XG52YXIgbGthVG9JSyA9IGxvY0tleUFycmF5VG9JdGVtS2V5O1xuXG4vLyBzcmMvaXRlbS9JRmFjdG9yeS50c1xudmFyIElGYWN0b3J5ID0gY2xhc3MgX0lGYWN0b3J5IHtcbiAgaXRlbSA9IHt9O1xuICBjb25zdHJ1Y3Rvcihwcm9wcyA9IHt9KSB7XG4gICAgdGhpcy5pdGVtID0gZGVlcG1lcmdlKHRoaXMuaXRlbSwgcHJvcHMpO1xuICB9XG4gIGFkZFJlZihpLCBuYW1lKSB7XG4gICAgY29uc3QgaWsgPSBpLmtleTtcbiAgICBjb25zdCByZWZOYW1lID0gbmFtZSB8fCBwcmltYXJ5VHlwZShpayk7XG4gICAgaWYgKCF0aGlzLml0ZW0ucmVmcykge1xuICAgICAgdGhpcy5pdGVtLnJlZnMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pdGVtLnJlZnNbcmVmTmFtZV0gPSBpaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkUmVmKGksIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZFJlZihpLCBuYW1lKTtcbiAgfVxuICBhZGREZWZhdWx0RXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cykge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBpZiAoIXRoaXMuaXRlbS5ldmVudHMuY3JlYXRlZCkge1xuICAgICAgdGhpcy5pdGVtLmV2ZW50cy5jcmVhdGVkID0geyBhdDogbm93IH07XG4gICAgfVxuICAgIGlmICghdGhpcy5pdGVtLmV2ZW50cy51cGRhdGVkKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzLnVwZGF0ZWQgPSB7IGF0OiBub3cgfTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzLmRlbGV0ZWQpIHtcbiAgICAgIHRoaXMuaXRlbS5ldmVudHMuZGVsZXRlZCA9IHsgYXQ6IG51bGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkRXZlbnQobmFtZSwgYXQsIGJ5KSB7XG4gICAgaWYgKCF0aGlzLml0ZW0uZXZlbnRzKSB7XG4gICAgICB0aGlzLml0ZW0uZXZlbnRzID0ge307XG4gICAgfVxuICAgIHRoaXMuaXRlbS5ldmVudHNbbmFtZV0gPSB7IGF0LCBieSB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRFdmVudChuYW1lLCBhdCwgYnkpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZEV2ZW50KG5hbWUsIGF0LCBieSk7XG4gIH1cbiAgYWRkUHJvcChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuaXRlbVtuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhZGRQcm9wKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfSUZhY3RvcnkoKS5hZGRQcm9wKG5hbWUsIHZhbHVlKTtcbiAgfVxuICBhZGRQcm9wcyhwcm9wcykge1xuICAgIHRoaXMuaXRlbSA9IGRlZXBtZXJnZSh0aGlzLml0ZW0sIHByb3BzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYWRkUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IF9JRmFjdG9yeSgpLmFkZFByb3BzKHByb3BzKTtcbiAgfVxuICB0b0l0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgfVxufTtcblxuLy8gc3JjL0FJdGVtU2VydmljZS50c1xudmFyIEFJdGVtU2VydmljZSA9IGNsYXNzIHtcbiAgcGtUeXBlO1xuICBwYXJlbnRTZXJ2aWNlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGtUeXBlLCBwYXJlbnRTZXJ2aWNlKSB7XG4gICAgdGhpcy5wa1R5cGUgPSBwa1R5cGU7XG4gICAgaWYgKHBhcmVudFNlcnZpY2UpIHtcbiAgICAgIHRoaXMucGFyZW50U2VydmljZSA9IHBhcmVudFNlcnZpY2U7XG4gICAgfVxuICB9XG4gIGdldFBrVHlwZSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5wa1R5cGU7XG4gIH07XG4gIGdldEtleVR5cGVzID0gKCkgPT4ge1xuICAgIGxldCBrZXlUeXBlcyA9IFt0aGlzLmdldFBrVHlwZSgpXTtcbiAgICBpZiAodGhpcy5wYXJlbnRTZXJ2aWNlKSB7XG4gICAgICBrZXlUeXBlcyA9IGtleVR5cGVzLmNvbmNhdCh0aGlzLnBhcmVudFNlcnZpY2UuZ2V0S2V5VHlwZXMoKSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlUeXBlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9pdGVtL0l0ZW1RdWVyeS50c1xudmFyIGlzQ29uZGl0aW9uID0gKGNvbmRpdGlvbikgPT4ge1xuICByZXR1cm4gKHR5cGVvZiBjb25kaXRpb24uY29sdW1uID09PSBcInN0cmluZ1wiICYmIChBcnJheS5pc0FycmF5KGNvbmRpdGlvbi52YWx1ZSkgJiYgY29uZGl0aW9uLnZhbHVlLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikpIHx8IEFycmF5LmlzQXJyYXkoY29uZGl0aW9uLnZhbHVlKSAmJiBjb25kaXRpb24udmFsdWUuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiKSB8fCB0eXBlb2YgY29uZGl0aW9uLnZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjb25kaXRpb24udmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbmRpdGlvbi52YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgY29uZGl0aW9uLnZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgKGNvbmRpdGlvbi5vcGVyYXRvciA/IHR5cGVvZiBjb25kaXRpb24ub3BlcmF0b3IgPT09IFwic3RyaW5nXCIgOiB0cnVlKTtcbn07XG5cbi8vIHNyYy9pdGVtL0lRRmFjdG9yeS50c1xudmFyIElRRmFjdG9yeSA9IGNsYXNzIF9JUUZhY3Rvcnkge1xuICBxdWVyeSA9IHt9O1xuICBjb25zdHJ1Y3RvcihxdWVyeSA9IHt9KSB7XG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICB9XG4gIG9yZGVyQnkoZmllbGQsIGRpcmVjdGlvbiA9IFwiYXNjXCIpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkub3JkZXJCeSkge1xuICAgICAgdGhpcy5xdWVyeS5vcmRlckJ5ID0gW107XG4gICAgfVxuICAgIHRoaXMucXVlcnkub3JkZXJCeS5wdXNoKHsgZmllbGQsIGRpcmVjdGlvbiB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZ2cobmFtZSwgcXVlcnkpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkuYWdncykge1xuICAgICAgdGhpcy5xdWVyeS5hZ2dzID0ge307XG4gICAgfVxuICAgIHRoaXMucXVlcnkuYWdnc1tuYW1lXSA9IHF1ZXJ5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGV2ZW50KG5hbWUsIHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJ5LmV2ZW50cykge1xuICAgICAgdGhpcy5xdWVyeS5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeS5ldmVudHNbbmFtZV0gPSBxdWVyeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb25kaXRpb25zKGNvbmRpdGlvbnMsIGNvbXBvdW5kVHlwZSA9IFwiQU5EXCIpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbiBvZiBjb25kaXRpb25zKSB7XG4gICAgICBpZiAoIWlzQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbmRpdGlvbjogJHtKU09OLnN0cmluZ2lmeShjb25kaXRpb24pfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24gPSB7XG4gICAgICAgIGNvbXBvdW5kVHlwZSxcbiAgICAgICAgY29uZGl0aW9uc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcG91bmRDb25kaXRpb24gPSB7XG4gICAgICAgIGNvbXBvdW5kVHlwZSxcbiAgICAgICAgY29uZGl0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucy5wdXNoKGNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGltaXQobGltaXQpIHtcbiAgICB0aGlzLnF1ZXJ5LmxpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMucXVlcnkub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIFRPRE86IHJpZ2h0IG5vdywgd2UncmUgb25seSBzdXBwb3J0aW5nIFBLIHJlZnMgZm9yIHF1ZXJpZXMuICBTaG91bGQgYWRkIHN1cHBvcnQgZm9yIENLc1xuICBwayhrdCwgcGssIG5hbWUpIHtcbiAgICBpZiAoIXRoaXMucXVlcnkucmVmcykge1xuICAgICAgdGhpcy5xdWVyeS5yZWZzID0ge307XG4gICAgfVxuICAgIGNvbnN0IHJlZk5hbWUgPSBuYW1lIHx8IGt0O1xuICAgIHRoaXMucXVlcnkucmVmc1tyZWZOYW1lXSA9IGNQSyhwaywga3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbmRpdGlvbihjb2x1bW4sIHZhbHVlLCBvcGVyYXRvciA9IFwiPT1cIikge1xuICAgIGNvbnN0IGNvbmRpdGlvbiA9IHsgY29sdW1uLCB2YWx1ZSwgb3BlcmF0b3IgfTtcbiAgICBpZiAoaXNDb25kaXRpb24oY29uZGl0aW9uKSkge1xuICAgICAgaWYgKCF0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMucXVlcnkuY29tcG91bmRDb25kaXRpb24gPSB7XG4gICAgICAgICAgY29tcG91bmRUeXBlOiBcIkFORFwiLFxuICAgICAgICAgIGNvbmRpdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLnF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uLmNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb25kaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoY29uZGl0aW9uKX1gKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFsbCgpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3Rvcnk7XG4gIH1cbiAgc3RhdGljIG9yZGVyQnkoZmllbGQsIGRpcmVjdGlvbiA9IFwiYXNjXCIpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3Rvcnkub3JkZXJCeShmaWVsZCwgZGlyZWN0aW9uKTtcbiAgfVxuICBzdGF0aWMgYWdnKG5hbWUsIHF1ZXJ5KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmFnZyhuYW1lLCBxdWVyeSk7XG4gIH1cbiAgc3RhdGljIGV2ZW50KG5hbWUsIHF1ZXJ5KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmV2ZW50KG5hbWUsIHF1ZXJ5KTtcbiAgfVxuICBzdGF0aWMgbGltaXQobGltaXQpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkubGltaXQobGltaXQpO1xuICB9XG4gIHN0YXRpYyBvZmZzZXQob2Zmc2V0KSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5Lm9mZnNldChvZmZzZXQpO1xuICB9XG4gIHN0YXRpYyBwayhrdCwgcGssIG5hbWUpIHtcbiAgICBjb25zdCBpcUZhY3RvcnkgPSBuZXcgX0lRRmFjdG9yeSgpO1xuICAgIHJldHVybiBpcUZhY3RvcnkucGsoa3QsIHBrLCBuYW1lKTtcbiAgfVxuICBzdGF0aWMgY29uZGl0aW9uKGNvbHVtbiwgdmFsdWUsIG9wZXJhdG9yID0gXCI9PVwiKSB7XG4gICAgY29uc3QgaXFGYWN0b3J5ID0gbmV3IF9JUUZhY3RvcnkoKTtcbiAgICByZXR1cm4gaXFGYWN0b3J5LmNvbmRpdGlvbihjb2x1bW4sIHZhbHVlLCBvcGVyYXRvcik7XG4gIH1cbiAgc3RhdGljIGNvbmRpdGlvbnMoY29uZGl0aW9ucywgY29tcG91bmRUeXBlID0gXCJBTkRcIikge1xuICAgIGNvbnN0IGlxRmFjdG9yeSA9IG5ldyBfSVFGYWN0b3J5KCk7XG4gICAgcmV0dXJuIGlxRmFjdG9yeS5jb25kaXRpb25zKGNvbmRpdGlvbnMsIGNvbXBvdW5kVHlwZSk7XG4gIH1cbiAgdG9RdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeTtcbiAgfVxufTtcblxuLy8gc3JjL2l0ZW0vSVFVdGlscy50c1xuaW1wb3J0ICogYXMgbHV4b24gZnJvbSBcImx1eG9uXCI7XG52YXIgbG9nZ2VyMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcIklRVXRpbHNcIik7XG52YXIgcXVlcnlUb1BhcmFtcyA9IChxdWVyeSkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgaWYgKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgcGFyYW1zLmNvbXBvdW5kQ29uZGl0aW9uID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuY29tcG91bmRDb25kaXRpb24pO1xuICB9XG4gIGlmIChxdWVyeS5yZWZzKSB7XG4gICAgcGFyYW1zLnJlZnMgPSBKU09OLnN0cmluZ2lmeShxdWVyeS5yZWZzKTtcbiAgfVxuICBpZiAocXVlcnkubGltaXQpIHtcbiAgICBwYXJhbXMubGltaXQgPSBxdWVyeS5saW1pdDtcbiAgfVxuICBpZiAocXVlcnkub2Zmc2V0KSB7XG4gICAgcGFyYW1zLm9mZnNldCA9IHF1ZXJ5Lm9mZnNldDtcbiAgfVxuICBpZiAocXVlcnkuYWdncykge1xuICAgIHBhcmFtcy5hZ2dzID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuYWdncyk7XG4gIH1cbiAgaWYgKHF1ZXJ5LmV2ZW50cykge1xuICAgIHBhcmFtcy5ldmVudHMgPSBKU09OLnN0cmluZ2lmeShxdWVyeS5ldmVudHMpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xudmFyIGRhdGVUaW1lUmV2aXZlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHBhcnNlZERhdGUgPSBsdXhvbi5EYXRlVGltZS5mcm9tSVNPKHZhbHVlKTtcbiAgICBpZiAocGFyc2VkRGF0ZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGF0ZS50b0pTRGF0ZSgpO1xuICAgICAgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIHBhcmFtc1RvUXVlcnkgPSAocGFyYW1zKSA9PiB7XG4gIGNvbnN0IHF1ZXJ5ID0ge307XG4gIGlmIChwYXJhbXMuY29tcG91bmRDb25kaXRpb24pIHtcbiAgICBxdWVyeS5jb21wb3VuZENvbmRpdGlvbiA9IEpTT04ucGFyc2UocGFyYW1zLmNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgfVxuICBpZiAocGFyYW1zLnJlZnMpIHtcbiAgICBxdWVyeS5yZWZzID0gSlNPTi5wYXJzZShwYXJhbXMucmVmcyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgIHF1ZXJ5LmxpbWl0ID0gTnVtYmVyKHBhcmFtcy5saW1pdCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5vZmZzZXQpIHtcbiAgICBxdWVyeS5vZmZzZXQgPSBOdW1iZXIocGFyYW1zLm9mZnNldCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5hZ2dzKSB7XG4gICAgcXVlcnkuYWdncyA9IEpTT04ucGFyc2UocGFyYW1zLmFnZ3MpO1xuICB9XG4gIGlmIChwYXJhbXMuZXZlbnRzKSB7XG4gICAgcXVlcnkuZXZlbnRzID0gSlNPTi5wYXJzZShwYXJhbXMuZXZlbnRzLCBkYXRlVGltZVJldml2ZXIpO1xuICB9XG4gIHJldHVybiBxdWVyeTtcbn07XG52YXIgaXNSZWZRdWVyeU1hdGNoID0gKHJlZktleSwgcXVlcnlSZWYsIHJlZmVyZW5jZXMpID0+IHtcbiAgbG9nZ2VyMy50cmFjZShcImRvZXNSZWZNYXRjaFwiLCB7IHF1ZXJ5UmVmLCByZWZlcmVuY2VzIH0pO1xuICBsb2dnZXIzLmRlYnVnKFwiQ29tcGFyaW5nIFJlZlwiLCB7IHJlZktleSwgaXRlbVJlZjogcmVmZXJlbmNlc1tyZWZLZXldLCBxdWVyeVJlZiB9KTtcbiAgcmV0dXJuIGlzSXRlbUtleUVxdWFsKHF1ZXJ5UmVmLCByZWZlcmVuY2VzW3JlZktleV0pO1xufTtcbnZhciBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaCA9IChxdWVyeUNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICBpZiAocXVlcnlDb25kaXRpb24uY29tcG91bmRUeXBlID09PSBcIkFORFwiKSB7XG4gICAgcmV0dXJuIHF1ZXJ5Q29uZGl0aW9uLmNvbmRpdGlvbnMuZXZlcnkoXG4gICAgICAoY29uZGl0aW9uKSA9PiBpc0NvbmRpdGlvbihjb25kaXRpb24pID8gaXNDb25kaXRpb25RdWVyeU1hdGNoKGNvbmRpdGlvbiwgaXRlbSkgOiBpc0NvbXBvdW5kQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcXVlcnlDb25kaXRpb24uY29uZGl0aW9ucy5zb21lKFxuICAgICAgKGNvbmRpdGlvbikgPT4gaXNDb25kaXRpb24oY29uZGl0aW9uKSA/IGlzQ29uZGl0aW9uUXVlcnlNYXRjaChjb25kaXRpb24sIGl0ZW0pIDogaXNDb21wb3VuZENvbmRpdGlvblF1ZXJ5TWF0Y2goY29uZGl0aW9uLCBpdGVtKVxuICAgICk7XG4gIH1cbn07XG52YXIgaXNDb25kaXRpb25RdWVyeU1hdGNoID0gKHF1ZXJ5Q29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gIGNvbnN0IHByb3BLZXkgPSBxdWVyeUNvbmRpdGlvbi5jb2x1bW47XG4gIGxvZ2dlcjMudHJhY2UoXCJkb2VzQ29uZGl0aW9uTWF0Y2hcIiwgeyBwcm9wS2V5LCBxdWVyeUNvbmRpdGlvbiwgaXRlbSB9KTtcbiAgaWYgKGl0ZW1bcHJvcEtleV0gPT09IHZvaWQgMCkge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRvZXMgbm90IGNvbnRhaW4gcHJvcCB1bmRlciBrZXlcIiwgeyBwcm9wS2V5LCBpdGVtIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2dnZXIzLmRlYnVnKFwiQ29tcGFyaW5nIENvbmRpdGlvblwiLCB7IHByb3BLZXksIGl0ZW1Qcm9wOiBpdGVtW3Byb3BLZXldLCBxdWVyeUNvbmRpdGlvbiB9KTtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICBzd2l0Y2ggKHF1ZXJ5Q29uZGl0aW9uLm9wZXJhdG9yKSB7XG4gICAgY2FzZSBcIj09XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldID09PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIhPVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSAhPT0gcXVlcnlDb25kaXRpb24udmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiPlwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA+IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIj49XCI6XG4gICAgICByZXN1bHQgPSBpdGVtW3Byb3BLZXldID49IHF1ZXJ5Q29uZGl0aW9uLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIjxcIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0gPCBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI8PVwiOlxuICAgICAgcmVzdWx0ID0gaXRlbVtwcm9wS2V5XSA8PSBxdWVyeUNvbmRpdGlvbi52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpblwiOlxuICAgICAgcmVzdWx0ID0gcXVlcnlDb25kaXRpb24udmFsdWUuaW5jbHVkZXMoaXRlbVtwcm9wS2V5XSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibm90LWluXCI6XG4gICAgICByZXN1bHQgPSAhcXVlcnlDb25kaXRpb24udmFsdWUuaW5jbHVkZXMoaXRlbVtwcm9wS2V5XSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJyYXktY29udGFpbnNcIjpcbiAgICAgIHJlc3VsdCA9IGl0ZW1bcHJvcEtleV0uaW5jbHVkZXMocXVlcnlDb25kaXRpb24udmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFycmF5LWNvbnRhaW5zLWFueVwiOlxuICAgICAgcmVzdWx0ID0gcXVlcnlDb25kaXRpb24udmFsdWUuc29tZSgodmFsdWUpID0+IGl0ZW1bcHJvcEtleV0uaW5jbHVkZXModmFsdWUpKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGlzQWdnUXVlcnlNYXRjaCA9IChhZ2dLZXksIGFnZ1F1ZXJ5LCBhZ2cpID0+IHtcbiAgY29uc3QgYWdnSXRlbSA9IGFnZy5pdGVtO1xuICBsb2dnZXIzLmRlYnVnKFwiQ29tcGFyaW5nIEFnZ1wiLCB7IGFnZ0tleSwgYWdnSXRlbSwgYWdnUXVlcnkgfSk7XG4gIHJldHVybiBpc1F1ZXJ5TWF0Y2goYWdnSXRlbSwgYWdnUXVlcnkpO1xufTtcbnZhciBpc0V2ZW50UXVlcnlNYXRjaCA9IChldmVudEtleSwgZXZlbnRRdWVyeSwgaXRlbSkgPT4ge1xuICBpZiAoIWl0ZW0uZXZlbnRzW2V2ZW50S2V5XSkge1xuICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRvZXMgbm90IGNvbnRhaW4gZXZlbnQgdW5kZXIga2V5XCIsIHsgZXZlbnRLZXksIGV2ZW50czogaXRlbS5ldmVudHMgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGl0ZW1FdmVudCA9IGl0ZW0uZXZlbnRzW2V2ZW50S2V5XTtcbiAgICBpZiAoaXRlbUV2ZW50LmF0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXZlbnRRdWVyeS5zdGFydCAmJiAhKGV2ZW50UXVlcnkuc3RhcnQuZ2V0VGltZSgpIDw9IGl0ZW1FdmVudC5hdC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIGxvZ2dlcjMuZGVidWcoXCJJdGVtIGRhdGUgYmVmb3JlIGV2ZW50IHN0YXJ0IHF1ZXJ5XCIsIHsgZXZlbnRRdWVyeSwgaXRlbUV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRRdWVyeS5lbmQgJiYgIShldmVudFF1ZXJ5LmVuZC5nZXRUaW1lKCkgPiBpdGVtRXZlbnQuYXQuZ2V0VGltZSgpKSkge1xuICAgICAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBkYXRlIGFmdGVyIGV2ZW50IGVuZCBxdWVyeVwiLCB7IGV2ZW50UXVlcnksIGl0ZW1FdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIzLmRlYnVnKFwiSXRlbSBldmVudCBkb2VzIGNvbnRhaW5zIGEgbnVsbCBhdFwiLCB7IGl0ZW1FdmVudCB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgaXNRdWVyeU1hdGNoID0gKGl0ZW0sIHF1ZXJ5KSA9PiB7XG4gIGxvZ2dlcjMudHJhY2UoXCJpc01hdGNoXCIsIHsgaXRlbSwgcXVlcnkgfSk7XG4gIGlmIChxdWVyeS5yZWZzICYmIGl0ZW0ucmVmcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LnJlZnMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5UmVmID0gcXVlcnkucmVmc1trZXldO1xuICAgICAgaWYgKCFpc1JlZlF1ZXJ5TWF0Y2goa2V5LCBxdWVyeVJlZiwgaXRlbS5yZWZzKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChxdWVyeS5yZWZzICYmICFpdGVtLnJlZnMpIHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiUXVlcnkgY29udGFpbnMgcmVmcyBidXQgaXRlbSBkb2VzIG5vdCBoYXZlIHJlZnNcIiwgeyBxdWVyeSwgaXRlbSB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uICYmIGl0ZW0pIHtcbiAgICBpZiAoIWlzQ29tcG91bmRDb25kaXRpb25RdWVyeU1hdGNoKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uLCBpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChxdWVyeS5ldmVudHMgJiYgaXRlbS5ldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5ldmVudHMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5RXZlbnQgPSBxdWVyeS5ldmVudHNba2V5XTtcbiAgICAgIGlmICghaXNFdmVudFF1ZXJ5TWF0Y2goa2V5LCBxdWVyeUV2ZW50LCBpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocXVlcnkuYWdncyAmJiBpdGVtLmFnZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5hZ2dzKSB7XG4gICAgICBjb25zdCBhZ2dRdWVyeSA9IHF1ZXJ5LmFnZ3Nba2V5XTtcbiAgICAgIGlmIChpdGVtLmFnZ3Nba2V5XSAmJiAhaXNBZ2dRdWVyeU1hdGNoKGtleSwgYWdnUXVlcnksIGl0ZW0uYWdnc1trZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAocXVlcnkuYWdncyAmJiAhaXRlbS5hZ2dzKSB7XG4gICAgbG9nZ2VyMy5kZWJ1ZyhcIlF1ZXJ5IGNvbnRhaW5zIGFnZ3MgYnV0IGl0ZW0gZG9lcyBub3QgaGF2ZSBhZ2dzXCIsIHsgcXVlcnksIGl0ZW0gfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBhYmJyZXZRdWVyeSA9IChxdWVyeSkgPT4ge1xuICBjb25zdCBhYmJyZXYgPSBbXCJJUVwiXTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5LnJlZnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LnJlZnMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gYWJicmV2UmVmKGtleSwgcXVlcnkucmVmc1trZXldKTtcbiAgICAgICAgYWJicmV2LnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uKHF1ZXJ5LmNvbXBvdW5kQ29uZGl0aW9uKTtcbiAgICAgIGFiYnJldi5wdXNoKHByb3BzKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmFnZ3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5LmFnZ3MpIHtcbiAgICAgICAgY29uc3QgYWdnID0gYWJicmV2QWdnKGtleSwgcXVlcnkuYWdnc1trZXldKTtcbiAgICAgICAgYWJicmV2LnB1c2goYWdnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmV2ZW50cykge1xuICAgICAgY29uc3QgZXZlbnRzID0gYChFJHtPYmplY3Qua2V5cyhxdWVyeS5ldmVudHMpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgYWJicmV2LnB1c2goZXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmxpbWl0KSB7XG4gICAgICBhYmJyZXYucHVzaChgTCR7cXVlcnkubGltaXR9YCk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5vZmZzZXQpIHtcbiAgICAgIGFiYnJldi5wdXNoKGBPJHtxdWVyeS5vZmZzZXR9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFiYnJldi5wdXNoKFwiKGVtcHR5KVwiKTtcbiAgfVxuICByZXR1cm4gYWJicmV2LmpvaW4oXCIgXCIpO1xufTtcbnZhciBhYmJyZXZSZWYgPSAoa2V5LCByZWYpID0+IHtcbiAgaWYgKGlzUHJpS2V5KHJlZikpIHtcbiAgICBjb25zdCBwcmlLZXkgPSByZWY7XG4gICAgcmV0dXJuIGBSKCR7a2V5fSwke3ByaUtleS5rdH0sJHtwcmlLZXkucGt9KWA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29tS2V5ID0gcmVmO1xuICAgIHJldHVybiBgUigke2tleX0sJHtKU09OLnN0cmluZ2lmeShjb21LZXkpfSlgO1xuICB9XG59O1xudmFyIGFiYnJldkFnZyA9IChrZXksIGFnZykgPT4ge1xuICByZXR1cm4gYEEoJHtrZXl9LCR7YWJicmV2UXVlcnkoYWdnKX0pYDtcbn07XG52YXIgYWJicmV2Q29tcG91bmRDb25kaXRpb24gPSAoY29tcG91bmRDb25kaXRpb24pID0+IHtcbiAgcmV0dXJuIGBDQygke2NvbXBvdW5kQ29uZGl0aW9uLmNvbXBvdW5kVHlwZX0sJHtjb21wb3VuZENvbmRpdGlvbi5jb25kaXRpb25zID8gY29tcG91bmRDb25kaXRpb24uY29uZGl0aW9ucy5tYXAoYWJicmV2Q29uZGl0aW9uKS5qb2luKFwiLFwiKSA6IFwiTm8gQ29uZGl0aW9uc1wifSlgO1xufTtcbnZhciBhYmJyZXZDb25kaXRpb24gPSAoY29uZGl0aW9uKSA9PiB7XG4gIGlmIChpc0NvbmRpdGlvbihjb25kaXRpb24pKSB7XG4gICAgcmV0dXJuIGAoJHtjb25kaXRpb24uY29sdW1ufSwke2NvbmRpdGlvbi52YWx1ZX0sJHtjb25kaXRpb24ub3BlcmF0b3J9KWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFiYnJldkNvbXBvdW5kQ29uZGl0aW9uKGNvbmRpdGlvbik7XG4gIH1cbn07XG5cbi8vIHNyYy9pdGVtL0lVdGlscy50c1xudmFyIGxvZ2dlcjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJJVXRpbHNcIik7XG52YXIgdmFsaWRhdGVQS0Zvckl0ZW0gPSAoaXRlbSwgcGtUeXBlKSA9PiB7XG4gIGlmICghaXRlbSkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGlzIHVuZGVmaW5lZFwiLCB7IGl0ZW0gfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGluZyBQSywgSXRlbSBpcyB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKCFpdGVtLmtleSkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJWYWxpZGF0aW5nIFBLLCBJdGVtIGRvZXMgbm90IGhhdmUgYSBrZXlcIiwgeyBpdGVtIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpbmcgUEssIEl0ZW0gZG9lcyBub3QgaGF2ZSBhIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlUeXBlQXJyYXkgPSB0b0tleVR5cGVBcnJheShpdGVtLmtleSk7XG4gIGlmIChrZXlUeXBlQXJyYXlbMF0gIT09IHBrVHlwZSkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJLZXkgVHlwZSBBcnJheSBNaXNtYXRjaFwiLCB7IGtleVR5cGVBcnJheSwgcGtUeXBlIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgSXRlbSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IHByaW1hcnkga2V5IHR5cGUuIEV4cGVjdGVkICR7cGtUeXBlfSwgZ290ICR7a2V5VHlwZUFycmF5WzBdfWApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcbnZhciB2YWxpZGF0ZVBLID0gKGlucHV0LCBwa1R5cGUpID0+IHtcbiAgbG9nZ2VyNC50cmFjZShcIkNoZWNraW5nIFJldHVybiBUeXBlXCIsIHsgaW5wdXQgfSk7XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHZhbGlkYXRlUEtGb3JJdGVtKGl0ZW0sIHBrVHlwZSkpO1xuICB9XG4gIHJldHVybiB2YWxpZGF0ZVBLRm9ySXRlbShpbnB1dCwgcGtUeXBlKTtcbn07XG52YXIgdmFsaWRhdGVLZXlzID0gKGl0ZW0sIGtleVR5cGVzKSA9PiB7XG4gIGxvZ2dlcjQudHJhY2UoXCJDaGVja2luZyBSZXR1cm4gVHlwZVwiLCB7IGl0ZW0gfSk7XG4gIGlmICghaXRlbSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInZhbGlkYXRpbmcga2V5cywgaXRlbSBpcyB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKCFpdGVtLmtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInZhbGlkYXRpbmcga2V5cywgaXRlbSBkb2VzIG5vdCBoYXZlIGEga2V5OiBcIiArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgfVxuICBjb25zdCBrZXlUeXBlQXJyYXkgPSB0b0tleVR5cGVBcnJheShpdGVtLmtleSk7XG4gIGlmIChrZXlUeXBlQXJyYXkubGVuZ3RoICE9PSBrZXlUeXBlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBudW1iZXIgb2Yga2V5cy4gRXhwZWN0ZWQgJHtrZXlUeXBlcy5sZW5ndGh9LCBidXQgZ290ICR7a2V5VHlwZUFycmF5Lmxlbmd0aH1gKTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IEpTT04uc3RyaW5naWZ5KGtleVR5cGVBcnJheSkgPT09IEpTT04uc3RyaW5naWZ5KGtleVR5cGVzKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZ2dlcjQuZXJyb3IoXCJLZXkgVHlwZSBBcnJheSBNaXNtYXRjaFwiLCB7IGtleVR5cGVBcnJheSwgdGhpc0tleVR5cGVzOiBrZXlUeXBlcyB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBrZXkgdHlwZXMuIEV4cGVjdGVkIFske2tleVR5cGVzLmpvaW4oXCIsIFwiKX1dLCBidXQgZ290IFske2tleVR5cGVBcnJheS5qb2luKFwiLCBcIil9XWApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcbnZhciBpc1ByaUl0ZW0gPSAoaXRlbSkgPT4ge1xuICByZXR1cm4gISEoaXRlbSAmJiBpdGVtLmtleSAmJiBpc1ByaUtleShpdGVtLmtleSkpO1xufTtcbnZhciBpc0NvbUl0ZW0gPSAoaXRlbSkgPT4ge1xuICByZXR1cm4gISEoaXRlbSAmJiBpdGVtLmtleSAmJiBpc0NvbUtleShpdGVtLmtleSkpO1xufTtcbmV4cG9ydCB7XG4gIEFJdGVtU2VydmljZSxcbiAgRGljdGlvbmFyeSxcbiAgSUZhY3RvcnksXG4gIElRRmFjdG9yeSxcbiAgYWJicmV2QWdnLFxuICBhYmJyZXZDb21wb3VuZENvbmRpdGlvbixcbiAgYWJicmV2Q29uZGl0aW9uLFxuICBhYmJyZXZJSyxcbiAgYWJicmV2TEtBLFxuICBhYmJyZXZRdWVyeSxcbiAgYWJicmV2UmVmLFxuICBjUEssXG4gIGNvbnN0cnVjdFByaUtleSxcbiAgY3JlYXRlTm9ybWFsaXplZEhhc2hGdW5jdGlvbixcbiAgZ2VuZXJhdGVLZXlBcnJheSxcbiAgaWtUb0xLQSxcbiAgaXNDb21JdGVtLFxuICBpc0NvbUtleSxcbiAgaXNDb21LZXlFcXVhbCxcbiAgaXNDb21LZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzQ29uZGl0aW9uLFxuICBpc0l0ZW1LZXksXG4gIGlzSXRlbUtleUVxdWFsLFxuICBpc0l0ZW1LZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzTG9jS2V5LFxuICBpc0xvY0tleUVxdWFsLFxuICBpc0xvY0tleUVxdWFsTm9ybWFsaXplZCxcbiAgaXNQcmlJdGVtLFxuICBpc1ByaUtleSxcbiAgaXNQcmlLZXlFcXVhbCxcbiAgaXNQcmlLZXlFcXVhbE5vcm1hbGl6ZWQsXG4gIGlzUXVlcnlNYXRjaCxcbiAgaXNWYWxpZENvbUtleSxcbiAgaXNWYWxpZEl0ZW1LZXksXG4gIGlzVmFsaWRMb2NLZXksXG4gIGlzVmFsaWRMb2NLZXlBcnJheSxcbiAgaXNWYWxpZFByaUtleSxcbiAgaXRlbUtleVRvTG9jS2V5QXJyYXksXG4gIGxrYVRvSUssXG4gIGxvY0tleUFycmF5VG9JdGVtS2V5LFxuICBwYXJhbXNUb1F1ZXJ5LFxuICBwcmltYXJ5VHlwZSxcbiAgcXVlcnlUb1BhcmFtcyxcbiAgdG9LZXlUeXBlQXJyYXksXG4gIHZhbGlkYXRlS2V5cyxcbiAgdmFsaWRhdGVQS1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/@fjell/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/@fjell/http-api/dist/index.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/http-api/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   ForbiddenError: () => (/* binding */ ForbiddenError),\n/* harmony export */   GoneError: () => (/* binding */ GoneError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   MethodNotAllowedError: () => (/* binding */ MethodNotAllowedError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),\n/* harmony export */   RequestTimeoutError: () => (/* binding */ RequestTimeoutError),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   ServiceUnavailableError: () => (/* binding */ ServiceUnavailableError),\n/* harmony export */   TooManyRequestsError: () => (/* binding */ TooManyRequestsError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   connectMethod: () => (/* binding */ connectMethod),\n/* harmony export */   deleteMethod: () => (/* binding */ deleteMethod2),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getHttp: () => (/* binding */ getHttp),\n/* harmony export */   getHttpApi: () => (/* binding */ getHttpApi),\n/* harmony export */   getHttpFile: () => (/* binding */ getHttpFile),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   optionsMethod: () => (/* binding */ optionsMethod),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   patchMethod: () => (/* binding */ patchMethod),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   postFileMethod: () => (/* binding */ postFileMethod2),\n/* harmony export */   postMethod: () => (/* binding */ postMethod),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   putMethod: () => (/* binding */ putMethod),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   traceMethod: () => (/* binding */ traceMethod),\n/* harmony export */   uploadAsyncMethod: () => (/* binding */ uploadAsyncMethod2)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// src/errors.ts\nvar APIError = class _APIError extends Error {\n  httpResponseCode;\n  path;\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, options2);\n    this.httpResponseCode = httpResponseCode;\n    this.path = path;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, _APIError);\n    }\n  }\n};\nvar ClientError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar BadRequestError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 400, options2);\n  }\n};\nvar UnauthorizedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 401, options2);\n  }\n};\nvar ForbiddenError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 403, options2);\n  }\n};\nvar NotFoundError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 404, options2);\n  }\n};\nvar MethodNotAllowedError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 405, options2);\n  }\n};\nvar RequestTimeoutError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 408, options2);\n  }\n};\nvar ConflictError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 409, options2);\n  }\n};\nvar GoneError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 410, options2);\n  }\n};\nvar TooManyRequestsError = class extends ClientError {\n  constructor(message, path, options2) {\n    super(`${message} ${path}`, path, 429, options2);\n  }\n};\nvar ServerError = class extends APIError {\n  constructor(message, path, httpResponseCode, options2) {\n    super(message, path, httpResponseCode, options2);\n  }\n};\nvar InternalServerError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 500, options2);\n  }\n};\nvar NotImplementedError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 501, options2);\n  }\n};\nvar ServiceUnavailableError = class extends ServerError {\n  constructor(message, path, options2) {\n    super(message, path, 503, options2);\n  }\n};\n\n// src/api/util.ts\nvar getParameterValue = (value) => {\n  if (value) {\n    return value instanceof Date ? value.toISOString() : value.toString();\n  } else {\n    return \"\";\n  }\n};\nvar generateQueryParameters = (params) => Object.keys(params).length > 0 ? \"?\" + Object.keys(params).filter(\n  (key) => params[key] !== void 0 && (typeof params[key] === \"string\" && params[key].length === 0) === false\n).map((key) => {\n  let value;\n  if (params[key] === false) {\n    value = \"false\";\n  } else {\n    value = params[key];\n  }\n  return `${key}=${encodeURIComponent(getParameterValue(value))}`;\n}).join(\"&\") : \"\";\n\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/http-api\");\nvar logger_default = LibLogger;\n\n// src/api/http.ts\nvar logger = logger_default.get(\"api\", \"http\");\nfunction getHttp(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, body = {}, httpOptions = {}) => {\n    logger.trace(\"http\", { method, path, body, httpOptions });\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const headers = {};\n    if (!options2.skipContentType) {\n      headers[\"Content-Type\"] = options2.contentType;\n    }\n    headers[\"Accept\"] = options2.accept;\n    headers[\"X-Client-Name\"] = config.clientName;\n    const debugOptions = {\n      ...options2,\n      method,\n      path,\n      body\n    };\n    await populateAuthHeader(options2.isAuthenticated, headers);\n    logger.debug(\"http Request: %j, %j\", method, path);\n    const fetchOptions = {\n      method,\n      headers,\n      credentials: options2.requestCredentials\n    };\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      fetchOptions.body = body ? options2.isJsonBody ? JSON.stringify(body) : body : null;\n    }\n    const response = await fetch(\n      `${config.url}${path}${generateQueryParameters(options2.params)}`,\n      fetchOptions\n    );\n    let returnValue;\n    returnValue = await response.text();\n    if (response.status >= 400) {\n      let error;\n      if (response.status >= 500) {\n        if (response.status === 500) {\n          error = new InternalServerError(response.statusText, path, debugOptions);\n        } else if (response.status === 501) {\n          error = new NotImplementedError(response.statusText, path, debugOptions);\n        } else if (response.status === 503) {\n          error = new ServiceUnavailableError(response.statusText, path, debugOptions);\n        } else {\n          error = new ServerError(response.statusText, path, response.status, debugOptions);\n        }\n      } else {\n        if (response.status === 400) {\n          error = new BadRequestError(response.statusText, path, debugOptions);\n        } else if (response.status === 401) {\n          error = new UnauthorizedError(response.statusText, path, debugOptions);\n        } else if (response.status === 403) {\n          error = new ForbiddenError(response.statusText, path, debugOptions);\n        } else if (response.status === 404) {\n          error = new NotFoundError(response.statusText, path, debugOptions);\n        } else if (response.status === 405) {\n          error = new MethodNotAllowedError(response.statusText, path, debugOptions);\n        } else if (response.status === 408) {\n          error = new RequestTimeoutError(response.statusText, path, debugOptions);\n        } else if (response.status === 409) {\n          error = new ConflictError(response.statusText, path, debugOptions);\n        } else if (response.status === 410) {\n          error = new GoneError(response.statusText, path, debugOptions);\n        } else if (response.status === 429) {\n          error = new TooManyRequestsError(response.statusText, path, debugOptions);\n        } else {\n          error = new ClientError(response.statusText, path, response.status, debugOptions);\n        }\n      }\n      throw error;\n    }\n    if (options2.isJson) {\n      try {\n        returnValue = JSON.parse(returnValue);\n        logger.default(\"API RESPONSE JSON: %j\", { status: response.status, body: returnValue });\n      } catch (e) {\n        logger.error(\"Error parsing JSON\", { message: e.message, stack: e.stack, returnValue });\n        throw e;\n      }\n    } else {\n      logger.default(\"API RESPONSE TEXT: %j\", { status: response.status, body: returnValue });\n    }\n    return returnValue;\n  };\n}\n\n// src/api/deleteMethod.ts\nvar logger2 = logger_default.get(\"api\", \"deleteMethod\");\nfunction deleteMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, deleteOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...deleteOptions\n    };\n    logger2.debug(\"httpDelete Request: %j, %j\", path, options2);\n    const s = await http(\n      \"DELETE\",\n      path,\n      body,\n      options2\n    );\n    logger2.default(\"httpDelete Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/getMethod.ts\nvar logger3 = logger_default.get(\"api\", \"getMethod\");\nfunction getMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger3.debug(\"httpGet Request: %j, %j\", path, options2);\n    const s = await http(\"GET\", path, null, options2);\n    logger3.default(\"httpGet Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/postMethod.ts\nvar logger4 = logger_default.get(\"api\", \"postMethod\");\nfunction postMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger4.debug(\"httpPost Request: %j, %j\", path, options2);\n    const s = await http(\"POST\", path, body, options2);\n    logger4.default(\"httpPost Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/putMethod.ts\nvar logger5 = logger_default.get(\"api\", \"putMethod\");\nfunction putMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, getOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...getOptions\n    };\n    logger5.debug(\"httpPut Request: %j, %j\", path, options2);\n    const s = await http(\"PUT\", path, body, options2);\n    logger5.default(\"httpPut Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/optionsMethod.ts\nvar logger6 = logger_default.get(\"api\", \"optionsMethod\");\nfunction optionsMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger6.debug(\"httpOptions Request: %j, %j\", path, opts);\n    const s = await http(\"OPTIONS\", path, null, opts);\n    logger6.default(\"httpOptions Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/connectMethod.ts\nvar logger7 = logger_default.get(\"api\", \"connectMethod\");\nfunction connectMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger7.debug(\"httpConnect Request: %j, %j\", path, opts);\n    const s = await http(\"CONNECT\", path, null, opts);\n    logger7.default(\"httpConnect Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/traceMethod.ts\nvar logger8 = logger_default.get(\"api\", \"traceMethod\");\nfunction traceMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger8.debug(\"httpTrace Request: %j, %j\", path, opts);\n    const s = await http(\"TRACE\", path, null, opts);\n    logger8.default(\"httpTrace Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/patchMethod.ts\nvar logger9 = logger_default.get(\"api\", \"patchMethod\");\nfunction patchMethod(apiParams) {\n  const http = getHttp(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    isJsonBody: true,\n    contentType: \"application/json\",\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    skipContentType: false,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, options2 = {}) => {\n    const opts = {\n      ...getOptionDefaults(apiParams),\n      ...options2\n    };\n    logger9.debug(\"httpPatch Request: %j, %j\", path, opts);\n    const s = await http(\"PATCH\", path, body, opts);\n    logger9.default(\"httpPatch Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/httpFile.ts\nfunction getHttpFile(apiParams) {\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (method, path, file, httpFileOptions = {}, body = {}, headers = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...httpFileOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    try {\n      headers[\"Accept\"] = options2.accept;\n      headers[\"X-Client-Name\"] = config.clientName;\n      await populateAuthHeader(options2.isAuthenticated, headers);\n      const bodyData = new FormData();\n      Object.keys(body).forEach((key) => {\n        bodyData.set(key, body[key]);\n      });\n      bodyData.set(\"file\", new Blob([new Uint8Array(file.buffer)]), file.bufferName);\n      const response = await fetch(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        {\n          method,\n          headers,\n          body: bodyData,\n          credentials: options2.requestCredentials\n        }\n      );\n      const returnValue = options2.isJson ? await response.json() : await response.text();\n      if (response.status >= 400) {\n        console.error(\n          `Error executing API request httpFile, status: ${response.status}: ` + JSON.stringify({ method, path, params: options2.params, body, returnValue })\n        );\n        throw new Error(options2.isJson ? returnValue.message : returnValue);\n      }\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api/postFileMethod.ts\nvar logger10 = logger_default.get(\"api\", \"postFileMethod\");\nfunction postFileMethod(apiParams) {\n  const httpFile = getHttpFile(apiParams);\n  const getOptionDefaults = (apiParams2) => ({\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    requestCredentials: apiParams2.config.requestCredentials\n  });\n  return async (path, body = {}, headers = {}, file, postFileOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(apiParams),\n      ...postFileOptions\n    };\n    logger10.debug(\"httpPostFileData Request: %s, %j\", path, options2);\n    logger10.default(\"httpPostFileData Request Body: %j\", body);\n    const s = await httpFile(\n      \"POST\",\n      path,\n      file,\n      options2,\n      body,\n      headers\n    );\n    logger10.default(\"httpPostFileData Result: %j\", s);\n    return s;\n  };\n}\n\n// src/api/uploadAsyncMethod.ts\nfunction uploadAsyncMethod(apiParams) {\n  const getOptionDefaults = () => ({\n    method: \"POST\",\n    isJson: true,\n    accept: \"application/json\",\n    params: {},\n    isAuthenticated: true,\n    fieldName: \"file\",\n    headers: {}\n  });\n  return async (path, uri, uploadAsyncOptions = {}) => {\n    const options2 = {\n      ...getOptionDefaults(),\n      ...uploadAsyncOptions\n    };\n    const config = apiParams.config;\n    const populateAuthHeader = apiParams.populateAuthHeader;\n    const uploadAsyncFile = apiParams.uploadAsyncFile;\n    try {\n      options2.headers[\"Accept\"] = options2.accept;\n      await populateAuthHeader(options2.isAuthenticated, options2.headers);\n      const result = await uploadAsyncFile(\n        `${config.url}${path}${generateQueryParameters(options2.params)}`,\n        uri,\n        options2.method,\n        \"multipart\",\n        options2.fieldName,\n        options2.headers\n      );\n      const returnValue = options2.isJson ? JSON.parse(result.body) : result.body;\n      return returnValue;\n    } catch (e) {\n      console.error(\n        `Error executing API request http ${options2.method} ${path} ${generateQueryParameters(\n          options2.params\n        )}`,\n        e\n      );\n      throw e;\n    }\n  };\n}\n\n// src/api.ts\nvar getHttpApi = (apiParams) => {\n  const httpDelete = deleteMethod(apiParams);\n  const httpGet = getMethod(apiParams);\n  const httpPost = postMethod(apiParams);\n  const httpPut = putMethod(apiParams);\n  const httpOptions = optionsMethod(apiParams);\n  const httpConnect = connectMethod(apiParams);\n  const httpTrace = traceMethod(apiParams);\n  const httpPatch = patchMethod(apiParams);\n  const httpPostFile = postFileMethod(apiParams);\n  const uploadAsync = uploadAsyncMethod(apiParams);\n  return {\n    httpDelete,\n    httpGet,\n    httpPut,\n    httpPost,\n    httpPostFile,\n    uploadAsync,\n    httpOptions,\n    httpConnect,\n    httpTrace,\n    httpPatch\n  };\n};\n\n// src/simple-api.ts\nvar defaultApiParams = {\n  config: {\n    url: \"\",\n    requestCredentials: \"same-origin\",\n    clientName: \"fjell-http-api-examples\"\n  },\n  populateAuthHeader: async (isAuthenticated, headers) => {\n    if (isAuthenticated) {\n      headers[\"Authorization\"] = \"Bearer example-token\";\n    }\n  },\n  uploadAsyncFile: async () => {\n    return {\n      headers: {},\n      status: 200,\n      mimeType: \"application/json\",\n      body: JSON.stringify({ success: true })\n    };\n  }\n};\nvar getImpl = getMethod(defaultApiParams);\nvar postImpl = postMethod(defaultApiParams);\nvar putImpl = putMethod(defaultApiParams);\nvar optionsImpl = optionsMethod(defaultApiParams);\nvar connectImpl = connectMethod(defaultApiParams);\nvar traceImpl = traceMethod(defaultApiParams);\nvar patchImpl = patchMethod(defaultApiParams);\nvar deleteImpl = deleteMethod(defaultApiParams);\nvar postFileImpl = postFileMethod(defaultApiParams);\nvar uploadAsyncImpl = uploadAsyncMethod(defaultApiParams);\nvar get = (path, options2) => {\n  return getImpl(path, options2);\n};\nvar post = (path, body, options2) => {\n  return postImpl(path, body, options2);\n};\nvar put = (path, body, options2) => {\n  return putImpl(path, body, options2);\n};\nvar deleteMethod2 = (path, body, options2) => {\n  return deleteImpl(path, body, options2);\n};\nvar options = (path, opts) => {\n  return optionsImpl(path, opts);\n};\nvar connect = (path, opts) => {\n  return connectImpl(path, opts);\n};\nvar trace = (path, opts) => {\n  return traceImpl(path, opts);\n};\nvar patch = (path, body, opts) => {\n  return patchImpl(path, body, opts);\n};\nvar postFileMethod2 = (path, file, options2) => {\n  const fileBuffer = {\n    buffer: Buffer.from([]),\n    // Placeholder - would need proper File reading in browser\n    bufferName: file.name\n  };\n  return postFileImpl(path, {}, {}, fileBuffer, options2);\n};\nvar uploadAsyncMethod2 = (path, uri, options2) => {\n  return uploadAsyncImpl(path, uri, options2);\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9odHRwLWFwaS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxFQUFFLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsRUFBRSxLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSxJQUFJLEdBQUcsNkNBQTZDO0FBQ2hFLENBQUM7O0FBRUQ7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0Q0FBNEMsaUJBQWlCLEVBQUUsTUFBTSxFQUFFO0FBQ3ZFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBcUNFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9AZmplbGwvaHR0cC1hcGkvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3JzLnRzXG52YXIgQVBJRXJyb3IgPSBjbGFzcyBfQVBJRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGh0dHBSZXNwb25zZUNvZGU7XG4gIHBhdGg7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0aW9uczIpO1xuICAgIHRoaXMuaHR0cFJlc3BvbnNlQ29kZSA9IGh0dHBSZXNwb25zZUNvZGU7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIF9BUElFcnJvcik7XG4gICAgfVxuICB9XG59O1xudmFyIENsaWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgaHR0cFJlc3BvbnNlQ29kZSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIEJhZFJlcXVlc3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDAsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBVbmF1dGhvcml6ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDEsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBGb3JiaWRkZW5FcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDMsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwNCwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIE1ldGhvZE5vdEFsbG93ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ2xpZW50RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCBvcHRpb25zMikge1xuICAgIHN1cGVyKGAke21lc3NhZ2V9ICR7cGF0aH1gLCBwYXRoLCA0MDUsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBSZXF1ZXN0VGltZW91dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQwOCwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIENvbmZsaWN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIENsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAke3BhdGh9YCwgcGF0aCwgNDA5LCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgR29uZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQxMCwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIFRvb01hbnlSZXF1ZXN0c0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0gJHtwYXRofWAsIHBhdGgsIDQyOSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIFNlcnZlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIGh0dHBSZXNwb25zZUNvZGUsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgaHR0cFJlc3BvbnNlQ29kZSwgb3B0aW9uczIpO1xuICB9XG59O1xudmFyIEludGVybmFsU2VydmVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIFNlcnZlckVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCA1MDAsIG9wdGlvbnMyKTtcbiAgfVxufTtcbnZhciBOb3RJbXBsZW1lbnRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIG9wdGlvbnMyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcGF0aCwgNTAxLCBvcHRpb25zMik7XG4gIH1cbn07XG52YXIgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFNlcnZlckVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgb3B0aW9uczIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBwYXRoLCA1MDMsIG9wdGlvbnMyKTtcbiAgfVxufTtcblxuLy8gc3JjL2FwaS91dGlsLnRzXG52YXIgZ2V0UGFyYW1ldGVyVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlLnRvSVNPU3RyaW5nKCkgOiB2YWx1ZS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xudmFyIGdlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzID0gKHBhcmFtcykgPT4gT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPiAwID8gXCI/XCIgKyBPYmplY3Qua2V5cyhwYXJhbXMpLmZpbHRlcihcbiAgKGtleSkgPT4gcGFyYW1zW2tleV0gIT09IHZvaWQgMCAmJiAodHlwZW9mIHBhcmFtc1trZXldID09PSBcInN0cmluZ1wiICYmIHBhcmFtc1trZXldLmxlbmd0aCA9PT0gMCkgPT09IGZhbHNlXG4pLm1hcCgoa2V5KSA9PiB7XG4gIGxldCB2YWx1ZTtcbiAgaWYgKHBhcmFtc1trZXldID09PSBmYWxzZSkge1xuICAgIHZhbHVlID0gXCJmYWxzZVwiO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gcGFyYW1zW2tleV07XG4gIH1cbiAgcmV0dXJuIGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW1ldGVyVmFsdWUodmFsdWUpKX1gO1xufSkuam9pbihcIiZcIikgOiBcIlwiO1xuXG4vLyBzcmMvbG9nZ2VyLnRzXG5pbXBvcnQgTG9nZ2luZyBmcm9tIFwiQGZqZWxsL2xvZ2dpbmdcIjtcbnZhciBMaWJMb2dnZXIgPSBMb2dnaW5nLmdldExvZ2dlcihcIkBmamVsbC9odHRwLWFwaVwiKTtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExpYkxvZ2dlcjtcblxuLy8gc3JjL2FwaS9odHRwLnRzXG52YXIgbG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwiaHR0cFwiKTtcbmZ1bmN0aW9uIGdldEh0dHAoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChtZXRob2QsIHBhdGgsIGJvZHkgPSB7fSwgaHR0cE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGxvZ2dlci50cmFjZShcImh0dHBcIiwgeyBtZXRob2QsIHBhdGgsIGJvZHksIGh0dHBPcHRpb25zIH0pO1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmh0dHBPcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBhcGlQYXJhbXMuY29uZmlnO1xuICAgIGNvbnN0IHBvcHVsYXRlQXV0aEhlYWRlciA9IGFwaVBhcmFtcy5wb3B1bGF0ZUF1dGhIZWFkZXI7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICghb3B0aW9uczIuc2tpcENvbnRlbnRUeXBlKSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gb3B0aW9uczIuY29udGVudFR5cGU7XG4gICAgfVxuICAgIGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBvcHRpb25zMi5hY2NlcHQ7XG4gICAgaGVhZGVyc1tcIlgtQ2xpZW50LU5hbWVcIl0gPSBjb25maWcuY2xpZW50TmFtZTtcbiAgICBjb25zdCBkZWJ1Z09wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zMixcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBib2R5XG4gICAgfTtcbiAgICBhd2FpdCBwb3B1bGF0ZUF1dGhIZWFkZXIob3B0aW9uczIuaXNBdXRoZW50aWNhdGVkLCBoZWFkZXJzKTtcbiAgICBsb2dnZXIuZGVidWcoXCJodHRwIFJlcXVlc3Q6ICVqLCAlalwiLCBtZXRob2QsIHBhdGgpO1xuICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBjcmVkZW50aWFsczogb3B0aW9uczIucmVxdWVzdENyZWRlbnRpYWxzXG4gICAgfTtcbiAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gYm9keSA/IG9wdGlvbnMyLmlzSnNvbkJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IGJvZHkgOiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7Y29uZmlnLnVybH0ke3BhdGh9JHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhvcHRpb25zMi5wYXJhbXMpfWAsXG4gICAgICBmZXRjaE9wdGlvbnNcbiAgICApO1xuICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICByZXR1cm5WYWx1ZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAxKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAzKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBTZXJ2ZXJFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCByZXNwb25zZS5zdGF0dXMsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEJhZFJlcXVlc3RFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgVW5hdXRob3JpemVkRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgIGVycm9yID0gbmV3IEZvcmJpZGRlbkVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBOb3RGb3VuZEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHBhdGgsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDUpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBNZXRob2ROb3RBbGxvd2VkRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFJlcXVlc3RUaW1lb3V0RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IENvbmZsaWN0RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQxMCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEdvbmVFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCBkZWJ1Z09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcGF0aCwgZGVidWdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBDbGllbnRFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBwYXRoLCByZXNwb25zZS5zdGF0dXMsIGRlYnVnT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuaXNKc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IEpTT04ucGFyc2UocmV0dXJuVmFsdWUpO1xuICAgICAgICBsb2dnZXIuZGVmYXVsdChcIkFQSSBSRVNQT05TRSBKU09OOiAlalwiLCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBib2R5OiByZXR1cm5WYWx1ZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgcGFyc2luZyBKU09OXCIsIHsgbWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjaywgcmV0dXJuVmFsdWUgfSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWZhdWx0KFwiQVBJIFJFU1BPTlNFIFRFWFQ6ICVqXCIsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGJvZHk6IHJldHVyblZhbHVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvZGVsZXRlTWV0aG9kLnRzXG52YXIgbG9nZ2VyMiA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcImRlbGV0ZU1ldGhvZFwiKTtcbmZ1bmN0aW9uIGRlbGV0ZU1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIGJvZHkgPSB7fSwgZGVsZXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uZGVsZXRlT3B0aW9uc1xuICAgIH07XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImh0dHBEZWxldGUgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdGlvbnMyKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcbiAgICAgIFwiREVMRVRFXCIsXG4gICAgICBwYXRoLFxuICAgICAgYm9keSxcbiAgICAgIG9wdGlvbnMyXG4gICAgKTtcbiAgICBsb2dnZXIyLmRlZmF1bHQoXCJodHRwRGVsZXRlIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvZ2V0TWV0aG9kLnRzXG52YXIgbG9nZ2VyMyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcImdldE1ldGhvZFwiKTtcbmZ1bmN0aW9uIGdldE1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIGdldE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmdldE9wdGlvbnNcbiAgICB9O1xuICAgIGxvZ2dlcjMuZGVidWcoXCJodHRwR2V0IFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRpb25zMik7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJHRVRcIiwgcGF0aCwgbnVsbCwgb3B0aW9uczIpO1xuICAgIGxvZ2dlcjMuZGVmYXVsdChcImh0dHBHZXQgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9wb3N0TWV0aG9kLnRzXG52YXIgbG9nZ2VyNCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcInBvc3RNZXRob2RcIik7XG5mdW5jdGlvbiBwb3N0TWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgYm9keSA9IHt9LCBnZXRPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5nZXRPcHRpb25zXG4gICAgfTtcbiAgICBsb2dnZXI0LmRlYnVnKFwiaHR0cFBvc3QgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdGlvbnMyKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcIlBPU1RcIiwgcGF0aCwgYm9keSwgb3B0aW9uczIpO1xuICAgIGxvZ2dlcjQuZGVmYXVsdChcImh0dHBQb3N0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvcHV0TWV0aG9kLnRzXG52YXIgbG9nZ2VyNSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcInB1dE1ldGhvZFwiKTtcbmZ1bmN0aW9uIHB1dE1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIGJvZHkgPSB7fSwgZ2V0T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4uZ2V0T3B0aW9uc1xuICAgIH07XG4gICAgbG9nZ2VyNS5kZWJ1ZyhcImh0dHBQdXQgUmVxdWVzdDogJWosICVqXCIsIHBhdGgsIG9wdGlvbnMyKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcIlBVVFwiLCBwYXRoLCBib2R5LCBvcHRpb25zMik7XG4gICAgbG9nZ2VyNS5kZWZhdWx0KFwiaHR0cFB1dCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL29wdGlvbnNNZXRob2QudHNcbnZhciBsb2dnZXI2ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwib3B0aW9uc01ldGhvZFwiKTtcbmZ1bmN0aW9uIG9wdGlvbnNNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBvcHRpb25zMiA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH07XG4gICAgbG9nZ2VyNi5kZWJ1ZyhcImh0dHBPcHRpb25zIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRzKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcIk9QVElPTlNcIiwgcGF0aCwgbnVsbCwgb3B0cyk7XG4gICAgbG9nZ2VyNi5kZWZhdWx0KFwiaHR0cE9wdGlvbnMgUmVzdWx0OiAlalwiLCBzKTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9jb25uZWN0TWV0aG9kLnRzXG52YXIgbG9nZ2VyNyA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcImNvbm5lY3RNZXRob2RcIik7XG5mdW5jdGlvbiBjb25uZWN0TWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBodHRwID0gZ2V0SHR0cChhcGlQYXJhbXMpO1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9IChhcGlQYXJhbXMyKSA9PiAoe1xuICAgIGlzSnNvbjogdHJ1ZSxcbiAgICBpc0pzb25Cb2R5OiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIHBhcmFtczoge30sXG4gICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgIHNraXBDb250ZW50VHlwZTogZmFsc2UsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBhcGlQYXJhbXMyLmNvbmZpZy5yZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSk7XG4gIHJldHVybiBhc3luYyAocGF0aCwgb3B0aW9uczIgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5nZXRPcHRpb25EZWZhdWx0cyhhcGlQYXJhbXMpLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9O1xuICAgIGxvZ2dlcjcuZGVidWcoXCJodHRwQ29ubmVjdCBSZXF1ZXN0OiAlaiwgJWpcIiwgcGF0aCwgb3B0cyk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHAoXCJDT05ORUNUXCIsIHBhdGgsIG51bGwsIG9wdHMpO1xuICAgIGxvZ2dlcjcuZGVmYXVsdChcImh0dHBDb25uZWN0IFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvdHJhY2VNZXRob2QudHNcbnZhciBsb2dnZXI4ID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiYXBpXCIsIFwidHJhY2VNZXRob2RcIik7XG5mdW5jdGlvbiB0cmFjZU1ldGhvZChhcGlQYXJhbXMpIHtcbiAgY29uc3QgaHR0cCA9IGdldEh0dHAoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgaXNKc29uQm9keTogdHJ1ZSxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBza2lwQ29udGVudFR5cGU6IGZhbHNlLFxuICAgIHJlcXVlc3RDcmVkZW50aWFsczogYXBpUGFyYW1zMi5jb25maWcucmVxdWVzdENyZWRlbnRpYWxzXG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIG9wdGlvbnMyID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLm9wdGlvbnMyXG4gICAgfTtcbiAgICBsb2dnZXI4LmRlYnVnKFwiaHR0cFRyYWNlIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRzKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcIlRSQUNFXCIsIHBhdGgsIG51bGwsIG9wdHMpO1xuICAgIGxvZ2dlcjguZGVmYXVsdChcImh0dHBUcmFjZSBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL3BhdGNoTWV0aG9kLnRzXG52YXIgbG9nZ2VyOSA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcInBhdGNoTWV0aG9kXCIpO1xuZnVuY3Rpb24gcGF0Y2hNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHAgPSBnZXRIdHRwKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGdldE9wdGlvbkRlZmF1bHRzID0gKGFwaVBhcmFtczIpID0+ICh7XG4gICAgaXNKc29uOiB0cnVlLFxuICAgIGlzSnNvbkJvZHk6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgc2tpcENvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBib2R5ID0ge30sIG9wdGlvbnMyID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLm9wdGlvbnMyXG4gICAgfTtcbiAgICBsb2dnZXI5LmRlYnVnKFwiaHR0cFBhdGNoIFJlcXVlc3Q6ICVqLCAlalwiLCBwYXRoLCBvcHRzKTtcbiAgICBjb25zdCBzID0gYXdhaXQgaHR0cChcIlBBVENIXCIsIHBhdGgsIGJvZHksIG9wdHMpO1xuICAgIGxvZ2dlcjkuZGVmYXVsdChcImh0dHBQYXRjaCBSZXN1bHQ6ICVqXCIsIHMpO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG4vLyBzcmMvYXBpL2h0dHBGaWxlLnRzXG5mdW5jdGlvbiBnZXRIdHRwRmlsZShhcGlQYXJhbXMpIHtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChtZXRob2QsIHBhdGgsIGZpbGUsIGh0dHBGaWxlT3B0aW9ucyA9IHt9LCBib2R5ID0ge30sIGhlYWRlcnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgLi4uZ2V0T3B0aW9uRGVmYXVsdHMoYXBpUGFyYW1zKSxcbiAgICAgIC4uLmh0dHBGaWxlT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgY29uZmlnID0gYXBpUGFyYW1zLmNvbmZpZztcbiAgICBjb25zdCBwb3B1bGF0ZUF1dGhIZWFkZXIgPSBhcGlQYXJhbXMucG9wdWxhdGVBdXRoSGVhZGVyO1xuICAgIHRyeSB7XG4gICAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gb3B0aW9uczIuYWNjZXB0O1xuICAgICAgaGVhZGVyc1tcIlgtQ2xpZW50LU5hbWVcIl0gPSBjb25maWcuY2xpZW50TmFtZTtcbiAgICAgIGF3YWl0IHBvcHVsYXRlQXV0aEhlYWRlcihvcHRpb25zMi5pc0F1dGhlbnRpY2F0ZWQsIGhlYWRlcnMpO1xuICAgICAgY29uc3QgYm9keURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIE9iamVjdC5rZXlzKGJvZHkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBib2R5RGF0YS5zZXQoa2V5LCBib2R5W2tleV0pO1xuICAgICAgfSk7XG4gICAgICBib2R5RGF0YS5zZXQoXCJmaWxlXCIsIG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShmaWxlLmJ1ZmZlcildKSwgZmlsZS5idWZmZXJOYW1lKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGAke2NvbmZpZy51cmx9JHtwYXRofSR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMob3B0aW9uczIucGFyYW1zKX1gLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keTogYm9keURhdGEsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMyLnJlcXVlc3RDcmVkZW50aWFsc1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcHRpb25zMi5pc0pzb24gPyBhd2FpdCByZXNwb25zZS5qc29uKCkgOiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBFcnJvciBleGVjdXRpbmcgQVBJIHJlcXVlc3QgaHR0cEZpbGUsIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9OiBgICsgSlNPTi5zdHJpbmdpZnkoeyBtZXRob2QsIHBhdGgsIHBhcmFtczogb3B0aW9uczIucGFyYW1zLCBib2R5LCByZXR1cm5WYWx1ZSB9KVxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9uczIuaXNKc29uID8gcmV0dXJuVmFsdWUubWVzc2FnZSA6IHJldHVyblZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIEFQSSByZXF1ZXN0IGh0dHAgJHttZXRob2R9ICR7cGF0aH0gJHtnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVycyhcbiAgICAgICAgICBvcHRpb25zMi5wYXJhbXNcbiAgICAgICAgKX1gLFxuICAgICAgICBlXG4gICAgICApO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvcG9zdEZpbGVNZXRob2QudHNcbnZhciBsb2dnZXIxMCA9IGxvZ2dlcl9kZWZhdWx0LmdldChcImFwaVwiLCBcInBvc3RGaWxlTWV0aG9kXCIpO1xuZnVuY3Rpb24gcG9zdEZpbGVNZXRob2QoYXBpUGFyYW1zKSB7XG4gIGNvbnN0IGh0dHBGaWxlID0gZ2V0SHR0cEZpbGUoYXBpUGFyYW1zKTtcbiAgY29uc3QgZ2V0T3B0aW9uRGVmYXVsdHMgPSAoYXBpUGFyYW1zMikgPT4gKHtcbiAgICBpc0pzb246IHRydWUsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHM6IGFwaVBhcmFtczIuY29uZmlnLnJlcXVlc3RDcmVkZW50aWFsc1xuICB9KTtcbiAgcmV0dXJuIGFzeW5jIChwYXRoLCBib2R5ID0ge30sIGhlYWRlcnMgPSB7fSwgZmlsZSwgcG9zdEZpbGVPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKGFwaVBhcmFtcyksXG4gICAgICAuLi5wb3N0RmlsZU9wdGlvbnNcbiAgICB9O1xuICAgIGxvZ2dlcjEwLmRlYnVnKFwiaHR0cFBvc3RGaWxlRGF0YSBSZXF1ZXN0OiAlcywgJWpcIiwgcGF0aCwgb3B0aW9uczIpO1xuICAgIGxvZ2dlcjEwLmRlZmF1bHQoXCJodHRwUG9zdEZpbGVEYXRhIFJlcXVlc3QgQm9keTogJWpcIiwgYm9keSk7XG4gICAgY29uc3QgcyA9IGF3YWl0IGh0dHBGaWxlKFxuICAgICAgXCJQT1NUXCIsXG4gICAgICBwYXRoLFxuICAgICAgZmlsZSxcbiAgICAgIG9wdGlvbnMyLFxuICAgICAgYm9keSxcbiAgICAgIGhlYWRlcnNcbiAgICApO1xuICAgIGxvZ2dlcjEwLmRlZmF1bHQoXCJodHRwUG9zdEZpbGVEYXRhIFJlc3VsdDogJWpcIiwgcyk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbi8vIHNyYy9hcGkvdXBsb2FkQXN5bmNNZXRob2QudHNcbmZ1bmN0aW9uIHVwbG9hZEFzeW5jTWV0aG9kKGFwaVBhcmFtcykge1xuICBjb25zdCBnZXRPcHRpb25EZWZhdWx0cyA9ICgpID0+ICh7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBpc0pzb246IHRydWUsXG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBwYXJhbXM6IHt9LFxuICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICBmaWVsZE5hbWU6IFwiZmlsZVwiLFxuICAgIGhlYWRlcnM6IHt9XG4gIH0pO1xuICByZXR1cm4gYXN5bmMgKHBhdGgsIHVyaSwgdXBsb2FkQXN5bmNPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgIC4uLmdldE9wdGlvbkRlZmF1bHRzKCksXG4gICAgICAuLi51cGxvYWRBc3luY09wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IGFwaVBhcmFtcy5jb25maWc7XG4gICAgY29uc3QgcG9wdWxhdGVBdXRoSGVhZGVyID0gYXBpUGFyYW1zLnBvcHVsYXRlQXV0aEhlYWRlcjtcbiAgICBjb25zdCB1cGxvYWRBc3luY0ZpbGUgPSBhcGlQYXJhbXMudXBsb2FkQXN5bmNGaWxlO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zMi5oZWFkZXJzW1wiQWNjZXB0XCJdID0gb3B0aW9uczIuYWNjZXB0O1xuICAgICAgYXdhaXQgcG9wdWxhdGVBdXRoSGVhZGVyKG9wdGlvbnMyLmlzQXV0aGVudGljYXRlZCwgb3B0aW9uczIuaGVhZGVycyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGxvYWRBc3luY0ZpbGUoXG4gICAgICAgIGAke2NvbmZpZy51cmx9JHtwYXRofSR7Z2VuZXJhdGVRdWVyeVBhcmFtZXRlcnMob3B0aW9uczIucGFyYW1zKX1gLFxuICAgICAgICB1cmksXG4gICAgICAgIG9wdGlvbnMyLm1ldGhvZCxcbiAgICAgICAgXCJtdWx0aXBhcnRcIixcbiAgICAgICAgb3B0aW9uczIuZmllbGROYW1lLFxuICAgICAgICBvcHRpb25zMi5oZWFkZXJzXG4gICAgICApO1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcHRpb25zMi5pc0pzb24gPyBKU09OLnBhcnNlKHJlc3VsdC5ib2R5KSA6IHJlc3VsdC5ib2R5O1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBFcnJvciBleGVjdXRpbmcgQVBJIHJlcXVlc3QgaHR0cCAke29wdGlvbnMyLm1ldGhvZH0gJHtwYXRofSAke2dlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzKFxuICAgICAgICAgIG9wdGlvbnMyLnBhcmFtc1xuICAgICAgICApfWAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FwaS50c1xudmFyIGdldEh0dHBBcGkgPSAoYXBpUGFyYW1zKSA9PiB7XG4gIGNvbnN0IGh0dHBEZWxldGUgPSBkZWxldGVNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cEdldCA9IGdldE1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwUG9zdCA9IHBvc3RNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cFB1dCA9IHB1dE1ldGhvZChhcGlQYXJhbXMpO1xuICBjb25zdCBodHRwT3B0aW9ucyA9IG9wdGlvbnNNZXRob2QoYXBpUGFyYW1zKTtcbiAgY29uc3QgaHR0cENvbm5lY3QgPSBjb25uZWN0TWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBUcmFjZSA9IHRyYWNlTWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBQYXRjaCA9IHBhdGNoTWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IGh0dHBQb3N0RmlsZSA9IHBvc3RGaWxlTWV0aG9kKGFwaVBhcmFtcyk7XG4gIGNvbnN0IHVwbG9hZEFzeW5jID0gdXBsb2FkQXN5bmNNZXRob2QoYXBpUGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICBodHRwRGVsZXRlLFxuICAgIGh0dHBHZXQsXG4gICAgaHR0cFB1dCxcbiAgICBodHRwUG9zdCxcbiAgICBodHRwUG9zdEZpbGUsXG4gICAgdXBsb2FkQXN5bmMsXG4gICAgaHR0cE9wdGlvbnMsXG4gICAgaHR0cENvbm5lY3QsXG4gICAgaHR0cFRyYWNlLFxuICAgIGh0dHBQYXRjaFxuICB9O1xufTtcblxuLy8gc3JjL3NpbXBsZS1hcGkudHNcbnZhciBkZWZhdWx0QXBpUGFyYW1zID0ge1xuICBjb25maWc6IHtcbiAgICB1cmw6IFwiXCIsXG4gICAgcmVxdWVzdENyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgY2xpZW50TmFtZTogXCJmamVsbC1odHRwLWFwaS1leGFtcGxlc1wiXG4gIH0sXG4gIHBvcHVsYXRlQXV0aEhlYWRlcjogYXN5bmMgKGlzQXV0aGVudGljYXRlZCwgaGVhZGVycykgPT4ge1xuICAgIGlmIChpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgZXhhbXBsZS10b2tlblwiO1xuICAgIH1cbiAgfSxcbiAgdXBsb2FkQXN5bmNGaWxlOiBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGdldEltcGwgPSBnZXRNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgcG9zdEltcGwgPSBwb3N0TWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIHB1dEltcGwgPSBwdXRNZXRob2QoZGVmYXVsdEFwaVBhcmFtcyk7XG52YXIgb3B0aW9uc0ltcGwgPSBvcHRpb25zTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIGNvbm5lY3RJbXBsID0gY29ubmVjdE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciB0cmFjZUltcGwgPSB0cmFjZU1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBwYXRjaEltcGwgPSBwYXRjaE1ldGhvZChkZWZhdWx0QXBpUGFyYW1zKTtcbnZhciBkZWxldGVJbXBsID0gZGVsZXRlTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIHBvc3RGaWxlSW1wbCA9IHBvc3RGaWxlTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIHVwbG9hZEFzeW5jSW1wbCA9IHVwbG9hZEFzeW5jTWV0aG9kKGRlZmF1bHRBcGlQYXJhbXMpO1xudmFyIGdldCA9IChwYXRoLCBvcHRpb25zMikgPT4ge1xuICByZXR1cm4gZ2V0SW1wbChwYXRoLCBvcHRpb25zMik7XG59O1xudmFyIHBvc3QgPSAocGF0aCwgYm9keSwgb3B0aW9uczIpID0+IHtcbiAgcmV0dXJuIHBvc3RJbXBsKHBhdGgsIGJvZHksIG9wdGlvbnMyKTtcbn07XG52YXIgcHV0ID0gKHBhdGgsIGJvZHksIG9wdGlvbnMyKSA9PiB7XG4gIHJldHVybiBwdXRJbXBsKHBhdGgsIGJvZHksIG9wdGlvbnMyKTtcbn07XG52YXIgZGVsZXRlTWV0aG9kMiA9IChwYXRoLCBib2R5LCBvcHRpb25zMikgPT4ge1xuICByZXR1cm4gZGVsZXRlSW1wbChwYXRoLCBib2R5LCBvcHRpb25zMik7XG59O1xudmFyIG9wdGlvbnMgPSAocGF0aCwgb3B0cykgPT4ge1xuICByZXR1cm4gb3B0aW9uc0ltcGwocGF0aCwgb3B0cyk7XG59O1xudmFyIGNvbm5lY3QgPSAocGF0aCwgb3B0cykgPT4ge1xuICByZXR1cm4gY29ubmVjdEltcGwocGF0aCwgb3B0cyk7XG59O1xudmFyIHRyYWNlID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgcmV0dXJuIHRyYWNlSW1wbChwYXRoLCBvcHRzKTtcbn07XG52YXIgcGF0Y2ggPSAocGF0aCwgYm9keSwgb3B0cykgPT4ge1xuICByZXR1cm4gcGF0Y2hJbXBsKHBhdGgsIGJvZHksIG9wdHMpO1xufTtcbnZhciBwb3N0RmlsZU1ldGhvZDIgPSAocGF0aCwgZmlsZSwgb3B0aW9uczIpID0+IHtcbiAgY29uc3QgZmlsZUJ1ZmZlciA9IHtcbiAgICBidWZmZXI6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAvLyBQbGFjZWhvbGRlciAtIHdvdWxkIG5lZWQgcHJvcGVyIEZpbGUgcmVhZGluZyBpbiBicm93c2VyXG4gICAgYnVmZmVyTmFtZTogZmlsZS5uYW1lXG4gIH07XG4gIHJldHVybiBwb3N0RmlsZUltcGwocGF0aCwge30sIHt9LCBmaWxlQnVmZmVyLCBvcHRpb25zMik7XG59O1xudmFyIHVwbG9hZEFzeW5jTWV0aG9kMiA9IChwYXRoLCB1cmksIG9wdGlvbnMyKSA9PiB7XG4gIHJldHVybiB1cGxvYWRBc3luY0ltcGwocGF0aCwgdXJpLCBvcHRpb25zMik7XG59O1xuZXhwb3J0IHtcbiAgQVBJRXJyb3IsXG4gIEJhZFJlcXVlc3RFcnJvcixcbiAgQ2xpZW50RXJyb3IsXG4gIENvbmZsaWN0RXJyb3IsXG4gIEZvcmJpZGRlbkVycm9yLFxuICBHb25lRXJyb3IsXG4gIEludGVybmFsU2VydmVyRXJyb3IsXG4gIE1ldGhvZE5vdEFsbG93ZWRFcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgUmVxdWVzdFRpbWVvdXRFcnJvcixcbiAgU2VydmVyRXJyb3IsXG4gIFNlcnZpY2VVbmF2YWlsYWJsZUVycm9yLFxuICBUb29NYW55UmVxdWVzdHNFcnJvcixcbiAgVW5hdXRob3JpemVkRXJyb3IsXG4gIGNvbm5lY3QsXG4gIGNvbm5lY3RNZXRob2QsXG4gIGRlbGV0ZU1ldGhvZDIgYXMgZGVsZXRlTWV0aG9kLFxuICBnZXQsXG4gIGdldEh0dHAsXG4gIGdldEh0dHBBcGksXG4gIGdldEh0dHBGaWxlLFxuICBnZXRNZXRob2QsXG4gIG9wdGlvbnMsXG4gIG9wdGlvbnNNZXRob2QsXG4gIHBhdGNoLFxuICBwYXRjaE1ldGhvZCxcbiAgcG9zdCxcbiAgcG9zdEZpbGVNZXRob2QyIGFzIHBvc3RGaWxlTWV0aG9kLFxuICBwb3N0TWV0aG9kLFxuICBwdXQsXG4gIHB1dE1ldGhvZCxcbiAgdHJhY2UsXG4gIHRyYWNlTWV0aG9kLFxuICB1cGxvYWRBc3luY01ldGhvZDIgYXMgdXBsb2FkQXN5bmNNZXRob2Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/@fjell/http-api/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/@fjell/logging/dist/index.js":
/*!********************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/logging/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogFormat: () => (/* binding */ LogFormat_exports),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel_exports),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogger: () => (/* binding */ getLogger)\n/* harmony export */ });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/LogFormat.ts\nvar LogFormat_exports = {};\n__export(LogFormat_exports, {\n  LogFormats: () => LogFormats,\n  STRUCTURED: () => STRUCTURED,\n  TEXT: () => TEXT,\n  getConfig: () => getConfig\n});\nvar TEXT = {\n  name: \"TEXT\",\n  description: \"Text format\"\n};\nvar STRUCTURED = {\n  name: \"STRUCTURED\",\n  description: \"Structured format\"\n};\nvar LogFormats = [\n  TEXT,\n  STRUCTURED\n];\nvar getConfig = (name) => {\n  const config = LogFormats.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Format Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/LogLevel.ts\nvar LogLevel_exports = {};\n__export(LogLevel_exports, {\n  ALERT: () => ALERT,\n  CRITICAL: () => CRITICAL,\n  DEBUG: () => DEBUG,\n  DEFAULT: () => DEFAULT,\n  EMERGENCY: () => EMERGENCY,\n  ERROR: () => ERROR,\n  INFO: () => INFO,\n  LogLevels: () => LogLevels,\n  NOTICE: () => NOTICE,\n  TRACE: () => TRACE,\n  WARNING: () => WARNING,\n  getConfig: () => getConfig2\n});\nvar EMERGENCY = {\n  name: \"EMERGENCY\",\n  value: 0\n};\nvar ALERT = {\n  name: \"ALERT\",\n  value: 1\n};\nvar CRITICAL = {\n  name: \"CRITICAL\",\n  value: 2\n};\nvar ERROR = {\n  name: \"ERROR\",\n  value: 3\n};\nvar WARNING = {\n  name: \"WARNING\",\n  value: 4\n};\nvar NOTICE = {\n  name: \"NOTICE\",\n  value: 5\n};\nvar INFO = {\n  name: \"INFO\",\n  value: 6\n};\nvar DEBUG = {\n  name: \"DEBUG\",\n  value: 7\n};\nvar TRACE = {\n  name: \"TRACE\",\n  value: 8\n};\nvar DEFAULT = {\n  name: \"DEFAULT\",\n  value: 9\n};\nvar LogLevels = [\n  EMERGENCY,\n  ALERT,\n  CRITICAL,\n  ERROR,\n  WARNING,\n  NOTICE,\n  INFO,\n  DEBUG,\n  TRACE,\n  DEFAULT\n];\nvar getConfig2 = (name) => {\n  const config = LogLevels.find((config2) => config2.name === name);\n  if (!config) {\n    throw new Error(`Invalid Log Level Supplied to Logging Configuration '${name}'`);\n  }\n  return config;\n};\n\n// src/config.ts\nvar defaultLogLevel = INFO;\nvar defaultLogFormat = TEXT;\nvar defaultLoggingConfig = {\n  logLevel: defaultLogLevel,\n  logFormat: defaultLogFormat,\n  overrides: {},\n  floodControl: {\n    enabled: false,\n    threshold: 10,\n    timeframe: 1e3\n    // 1 second\n  }\n};\nvar convertOverrides = (overrides) => {\n  const convertedOverrides = {};\n  if (overrides) {\n    Object.entries(overrides).forEach(([key, value]) => {\n      convertedOverrides[key] = { logLevel: value.logLevel ? getConfig2(value.logLevel) : defaultLogLevel };\n    });\n  }\n  return convertedOverrides;\n};\nvar convertConfig = (config) => {\n  return {\n    logLevel: config.logLevel ? getConfig2(config.logLevel) : defaultLogLevel,\n    logFormat: config.logFormat ? getConfig(config.logFormat) : defaultLogFormat,\n    overrides: convertOverrides(config.overrides),\n    floodControl: {\n      ...defaultLoggingConfig.floodControl,\n      ...config.floodControl || {}\n    }\n  };\n};\nvar configureLogging = () => {\n  let config = {};\n  const loggingConfigEnv = process.env.LOGGING_CONFIG;\n  const expoLoggingConfigEnv = process.env.EXPO_PUBLIC_LOGGING_CONFIG;\n  const nextLoggingConfigEnv = process.env.NEXT_PUBLIC_LOGGING_CONFIG;\n  let logLevelEnv = process.env.LOG_LEVEL;\n  let logFormatEnv = process.env.LOG_FORMAT;\n  if (loggingConfigEnv) {\n    try {\n      config = JSON.parse(loggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (expoLoggingConfigEnv) {\n    try {\n      config = JSON.parse(expoLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in EXPO_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  } else if (nextLoggingConfigEnv) {\n    try {\n      config = JSON.parse(nextLoggingConfigEnv);\n    } catch (error) {\n      console.error(\"Invalid JSON in NEXT_PUBLIC_LOGGING_CONFIG environment variable:\", error);\n      config = {};\n    }\n  }\n  const convertedConfig = convertConfig(config);\n  if (logLevelEnv) {\n    logLevelEnv = logLevelEnv?.toUpperCase();\n    const logLevelConfig = getConfig2(logLevelEnv);\n    convertedConfig.logLevel = logLevelConfig;\n  }\n  if (logFormatEnv) {\n    logFormatEnv = logFormatEnv.toUpperCase();\n    const logFormatConfig = getConfig(logFormatEnv);\n    convertedConfig.logFormat = logFormatConfig;\n  }\n  const finalConfig = { ...defaultLoggingConfig, ...convertedConfig };\n  return finalConfig;\n};\n\n// src/Writer.ts\nvar createWriter = (formatter, logMethod, options = {}) => {\n  const {\n    respectInjectedMethod = false,\n    errorMethod = console.error,\n    warningMethod = console.warn,\n    infoMethod = console.log\n  } = options;\n  return {\n    write: (level, coordinates, payload) => {\n      let finalLogMethod = logMethod;\n      if (!respectInjectedMethod) {\n        if (level.name === ERROR.name || level.name === CRITICAL.name || level.name === ALERT.name || level.name === EMERGENCY.name) {\n          finalLogMethod = errorMethod;\n        } else if (level.name === WARNING.name) {\n          finalLogMethod = warningMethod;\n        } else {\n          finalLogMethod = infoMethod;\n        }\n      }\n      finalLogMethod(formatter.formatLog(level, coordinates, payload));\n    }\n  };\n};\n\n// src/formatter.ts\n\nvar safeInspect = (obj) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.inspect(obj);\n  } catch {\n    return `[Object: ${typeof obj}]`;\n  }\n};\nvar safeFormat = (message, ...args) => {\n  try {\n    return util__WEBPACK_IMPORTED_MODULE_0__.format(message, ...args);\n  } catch {\n    return `${message} ${safeInspect(args)}`;\n  }\n};\nvar createFormatter = (logFormat) => {\n  if (logFormat.name === \"TEXT\") {\n    return getTextFormatter();\n  } else if (logFormat.name === \"STRUCTURED\") {\n    return getStructuredFormatter();\n  }\n  throw new Error(`Unknown log format: ${logFormat.name}`);\n};\nvar getTextFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    let logMessage;\n    if (payload.data.length === 0) {\n      logMessage = payload.message;\n    } else if (hasSpecifiers) {\n      logMessage = safeFormat(payload.message, ...payload.data);\n    } else {\n      logMessage = `${payload.message} ${safeInspect(payload.data)}`;\n    }\n    return `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${logMessage}`;\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const randomInt = Math.floor(Math.random() * 1e6);\n    const timerMessage2 = `(${(/* @__PURE__ */ new Date()).valueOf()}) [${level.name}] - [${coordinates.category}] ${coordinates.components.map((c) => `[${c}]`)} ${safeFormat(payload.message, ...payload.data)} ${safeInspect(payload.data)} ${randomInt}`;\n    return timerMessage2;\n  };\n  return { formatLog, timerMessage, getLogFormat: () => TEXT };\n};\nvar getStructuredFormatter = () => {\n  const formatLog = (level, coordinates, payload) => {\n    const severity = level.name;\n    const hasSpecifiers = /%[sdjifoO%]/.test(payload.message);\n    return JSON.stringify({\n      severity,\n      message: hasSpecifiers ? safeFormat(payload.message, ...payload.data) : payload.message,\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      ...!hasSpecifiers && payload.data.length > 0 && { data: safeInspect(payload.data) }\n    });\n  };\n  const timerMessage = (level, coordinates, payload) => {\n    const severity = level.name;\n    const randomInt = Math.floor(Math.random() * 1e6);\n    return JSON.stringify({\n      severity,\n      message: safeFormat(payload.message, ...payload.data),\n      \"logging.googleapis.com/labels\": {\n        category: coordinates.category,\n        components: `${coordinates.components.map((c) => `[${c}]`)}`\n      },\n      data: safeInspect(payload.data),\n      \"logging.googleapis.com/spanId\": String(randomInt)\n    });\n  };\n  return { formatLog, timerMessage, getLogFormat: () => STRUCTURED };\n};\n\n// src/FloodControl.ts\n\nvar hash = (message, data) => {\n  const dataString = data.map((item) => {\n    try {\n      return JSON.stringify(item);\n    } catch {\n      return util__WEBPACK_IMPORTED_MODULE_0__.inspect(item);\n    }\n  }).join(\"\");\n  return `${message}${dataString}`;\n};\nvar FloodControl = class {\n  config;\n  history = /* @__PURE__ */ new Map();\n  suppressed = /* @__PURE__ */ new Map();\n  cleanupTimer = null;\n  constructor(config) {\n    this.config = config;\n    if (this.config.enabled) {\n      this.cleanupTimer = setInterval(() => this.cleanup(), this.config.timeframe * 2);\n    }\n  }\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [hash2, timestamps] of this.history.entries()) {\n      const recentTimestamps = timestamps.filter(\n        (timestamp) => now - timestamp < this.config.timeframe\n      );\n      if (recentTimestamps.length > 0) {\n        this.history.set(hash2, recentTimestamps);\n      } else {\n        this.history.delete(hash2);\n        this.suppressed.delete(hash2);\n      }\n    }\n  }\n  check(message, data) {\n    if (!this.config.enabled) {\n      return \"log\";\n    }\n    const messageHash = hash(message, data);\n    const now = Date.now();\n    const timestamps = (this.history.get(messageHash) || []).filter(\n      (timestamp) => now - timestamp < this.config.timeframe\n    );\n    timestamps.push(now);\n    this.history.set(messageHash, timestamps);\n    if (timestamps.length > this.config.threshold) {\n      const suppressedInfo = this.suppressed.get(messageHash);\n      if (suppressedInfo) {\n        suppressedInfo.count++;\n        return \"suppress\";\n      } else {\n        this.suppressed.set(messageHash, { count: 1, firstTimestamp: timestamps[0], summaryLogged: false });\n        return \"suppress\";\n      }\n    } else {\n      if (this.suppressed.has(messageHash)) {\n        this.suppressed.delete(messageHash);\n        return \"resume\";\n      }\n    }\n    return \"log\";\n  }\n  getSuppressedCount(message, data) {\n    const messageHash = hash(message, data);\n    return this.suppressed.get(messageHash)?.count || 0;\n  }\n};\n\n// src/Logger.ts\nvar createLogger = (logFormat, logLevel, coordinates, floodControlConfig, writerOptions) => {\n  const formatter = createFormatter(logFormat);\n  const floodControl = floodControlConfig.enabled ? new FloodControl(floodControlConfig) : null;\n  const logFunction = console.log;\n  const writer = createWriter(formatter, logFunction, writerOptions);\n  const write = (level, message, data) => {\n    if (logLevel.value < level.value) {\n      return;\n    }\n    const check = floodControl ? floodControl.check(message, data) : \"log\";\n    const payload = { message, data };\n    switch (check) {\n      case \"log\":\n        writer.write(level, coordinates, payload);\n        break;\n      case \"suppress\":\n        if (floodControl && floodControl.getSuppressedCount(message, data) === 1) {\n          const originalLevel = level;\n          const newPayload = { message: `Started suppressing repeated log message`, data: [] };\n          writer.write(originalLevel, coordinates, newPayload);\n        }\n        break;\n      case \"resume\": {\n        const count = floodControl ? floodControl.getSuppressedCount(message, data) : 0;\n        const resumePayload = {\n          message: `Stopped suppressing repeated log message. Suppressed ${count} times.`,\n          data: []\n        };\n        writer.write(level, coordinates, resumePayload);\n        writer.write(level, coordinates, payload);\n        break;\n      }\n    }\n  };\n  const startTimeLogger = (logLevel2, coordinates2, payload) => {\n    const timerMessage = formatter.timerMessage(logLevel2, coordinates2, payload);\n    logLevel2.value >= DEBUG.value && console.time(timerMessage);\n    return {\n      end: () => {\n        logLevel2.value >= DEBUG.value && console.timeEnd(timerMessage);\n      },\n      log: (...data) => {\n        logLevel2.value >= DEBUG.value && console.timeLog(timerMessage, ...data);\n      }\n    };\n  };\n  return {\n    emergency: (message, ...data) => {\n      write(EMERGENCY, message, data);\n    },\n    alert: (message, ...data) => {\n      write(ALERT, message, data);\n    },\n    critical: (message, ...data) => {\n      write(CRITICAL, message, data);\n    },\n    error: (message, ...data) => {\n      write(ERROR, message, data);\n    },\n    warning: (message, ...data) => {\n      write(WARNING, message, data);\n    },\n    notice: (message, ...data) => {\n      write(NOTICE, message, data);\n    },\n    info: (message, ...data) => {\n      write(INFO, message, data);\n    },\n    debug: (message, ...data) => {\n      write(DEBUG, message, data);\n    },\n    trace: (message, ...data) => {\n      write(TRACE, message, data);\n    },\n    default: (message, ...data) => {\n      write(DEFAULT, message, data);\n    },\n    time: (message, ...data) => {\n      const payload = { message, data };\n      return startTimeLogger(logLevel, coordinates, payload);\n    },\n    get: (...additionalComponents) => {\n      return createLogger(logFormat, logLevel, {\n        category: coordinates.category,\n        components: [...coordinates.components, ...additionalComponents]\n      }, floodControlConfig, writerOptions);\n    },\n    destroy: () => {\n      if (floodControl) {\n        floodControl.destroy();\n      }\n    }\n  };\n};\n\n// src/logging.ts\nvar getLogger = (name) => {\n  const config = configureLogging();\n  const logger = createBaseLogger(name, config);\n  return logger;\n};\nvar createBaseLogger = (name, config) => {\n  let { logLevel } = config;\n  const { logFormat, floodControl } = config;\n  const overrides = config.overrides;\n  if (overrides && overrides[name]) {\n    logLevel = overrides[name].logLevel;\n  }\n  const coordinates = { category: name, components: [] };\n  return createLogger(logFormat, logLevel, coordinates, floodControl);\n};\n\n// src/index.ts\nvar index_default = { getLogger };\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9sb2dnaW5nL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsS0FBSztBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEtBQUs7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQixVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBTXBCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9AZmplbGwvbG9nZ2luZy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9Mb2dGb3JtYXQudHNcbnZhciBMb2dGb3JtYXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoTG9nRm9ybWF0X2V4cG9ydHMsIHtcbiAgTG9nRm9ybWF0czogKCkgPT4gTG9nRm9ybWF0cyxcbiAgU1RSVUNUVVJFRDogKCkgPT4gU1RSVUNUVVJFRCxcbiAgVEVYVDogKCkgPT4gVEVYVCxcbiAgZ2V0Q29uZmlnOiAoKSA9PiBnZXRDb25maWdcbn0pO1xudmFyIFRFWFQgPSB7XG4gIG5hbWU6IFwiVEVYVFwiLFxuICBkZXNjcmlwdGlvbjogXCJUZXh0IGZvcm1hdFwiXG59O1xudmFyIFNUUlVDVFVSRUQgPSB7XG4gIG5hbWU6IFwiU1RSVUNUVVJFRFwiLFxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmVkIGZvcm1hdFwiXG59O1xudmFyIExvZ0Zvcm1hdHMgPSBbXG4gIFRFWFQsXG4gIFNUUlVDVFVSRURcbl07XG52YXIgZ2V0Q29uZmlnID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gTG9nRm9ybWF0cy5maW5kKChjb25maWcyKSA9PiBjb25maWcyLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMb2cgRm9ybWF0IFN1cHBsaWVkIHRvIExvZ2dpbmcgQ29uZmlndXJhdGlvbiAnJHtuYW1lfSdgKTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufTtcblxuLy8gc3JjL0xvZ0xldmVsLnRzXG52YXIgTG9nTGV2ZWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoTG9nTGV2ZWxfZXhwb3J0cywge1xuICBBTEVSVDogKCkgPT4gQUxFUlQsXG4gIENSSVRJQ0FMOiAoKSA9PiBDUklUSUNBTCxcbiAgREVCVUc6ICgpID0+IERFQlVHLFxuICBERUZBVUxUOiAoKSA9PiBERUZBVUxULFxuICBFTUVSR0VOQ1k6ICgpID0+IEVNRVJHRU5DWSxcbiAgRVJST1I6ICgpID0+IEVSUk9SLFxuICBJTkZPOiAoKSA9PiBJTkZPLFxuICBMb2dMZXZlbHM6ICgpID0+IExvZ0xldmVscyxcbiAgTk9USUNFOiAoKSA9PiBOT1RJQ0UsXG4gIFRSQUNFOiAoKSA9PiBUUkFDRSxcbiAgV0FSTklORzogKCkgPT4gV0FSTklORyxcbiAgZ2V0Q29uZmlnOiAoKSA9PiBnZXRDb25maWcyXG59KTtcbnZhciBFTUVSR0VOQ1kgPSB7XG4gIG5hbWU6IFwiRU1FUkdFTkNZXCIsXG4gIHZhbHVlOiAwXG59O1xudmFyIEFMRVJUID0ge1xuICBuYW1lOiBcIkFMRVJUXCIsXG4gIHZhbHVlOiAxXG59O1xudmFyIENSSVRJQ0FMID0ge1xuICBuYW1lOiBcIkNSSVRJQ0FMXCIsXG4gIHZhbHVlOiAyXG59O1xudmFyIEVSUk9SID0ge1xuICBuYW1lOiBcIkVSUk9SXCIsXG4gIHZhbHVlOiAzXG59O1xudmFyIFdBUk5JTkcgPSB7XG4gIG5hbWU6IFwiV0FSTklOR1wiLFxuICB2YWx1ZTogNFxufTtcbnZhciBOT1RJQ0UgPSB7XG4gIG5hbWU6IFwiTk9USUNFXCIsXG4gIHZhbHVlOiA1XG59O1xudmFyIElORk8gPSB7XG4gIG5hbWU6IFwiSU5GT1wiLFxuICB2YWx1ZTogNlxufTtcbnZhciBERUJVRyA9IHtcbiAgbmFtZTogXCJERUJVR1wiLFxuICB2YWx1ZTogN1xufTtcbnZhciBUUkFDRSA9IHtcbiAgbmFtZTogXCJUUkFDRVwiLFxuICB2YWx1ZTogOFxufTtcbnZhciBERUZBVUxUID0ge1xuICBuYW1lOiBcIkRFRkFVTFRcIixcbiAgdmFsdWU6IDlcbn07XG52YXIgTG9nTGV2ZWxzID0gW1xuICBFTUVSR0VOQ1ksXG4gIEFMRVJULFxuICBDUklUSUNBTCxcbiAgRVJST1IsXG4gIFdBUk5JTkcsXG4gIE5PVElDRSxcbiAgSU5GTyxcbiAgREVCVUcsXG4gIFRSQUNFLFxuICBERUZBVUxUXG5dO1xudmFyIGdldENvbmZpZzIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb25maWcgPSBMb2dMZXZlbHMuZmluZCgoY29uZmlnMikgPT4gY29uZmlnMi5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG9nIExldmVsIFN1cHBsaWVkIHRvIExvZ2dpbmcgQ29uZmlndXJhdGlvbiAnJHtuYW1lfSdgKTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufTtcblxuLy8gc3JjL2NvbmZpZy50c1xudmFyIGRlZmF1bHRMb2dMZXZlbCA9IElORk87XG52YXIgZGVmYXVsdExvZ0Zvcm1hdCA9IFRFWFQ7XG52YXIgZGVmYXVsdExvZ2dpbmdDb25maWcgPSB7XG4gIGxvZ0xldmVsOiBkZWZhdWx0TG9nTGV2ZWwsXG4gIGxvZ0Zvcm1hdDogZGVmYXVsdExvZ0Zvcm1hdCxcbiAgb3ZlcnJpZGVzOiB7fSxcbiAgZmxvb2RDb250cm9sOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgdGhyZXNob2xkOiAxMCxcbiAgICB0aW1lZnJhbWU6IDFlM1xuICAgIC8vIDEgc2Vjb25kXG4gIH1cbn07XG52YXIgY29udmVydE92ZXJyaWRlcyA9IChvdmVycmlkZXMpID0+IHtcbiAgY29uc3QgY29udmVydGVkT3ZlcnJpZGVzID0ge307XG4gIGlmIChvdmVycmlkZXMpIHtcbiAgICBPYmplY3QuZW50cmllcyhvdmVycmlkZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29udmVydGVkT3ZlcnJpZGVzW2tleV0gPSB7IGxvZ0xldmVsOiB2YWx1ZS5sb2dMZXZlbCA/IGdldENvbmZpZzIodmFsdWUubG9nTGV2ZWwpIDogZGVmYXVsdExvZ0xldmVsIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE92ZXJyaWRlcztcbn07XG52YXIgY29udmVydENvbmZpZyA9IChjb25maWcpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBsb2dMZXZlbDogY29uZmlnLmxvZ0xldmVsID8gZ2V0Q29uZmlnMihjb25maWcubG9nTGV2ZWwpIDogZGVmYXVsdExvZ0xldmVsLFxuICAgIGxvZ0Zvcm1hdDogY29uZmlnLmxvZ0Zvcm1hdCA/IGdldENvbmZpZyhjb25maWcubG9nRm9ybWF0KSA6IGRlZmF1bHRMb2dGb3JtYXQsXG4gICAgb3ZlcnJpZGVzOiBjb252ZXJ0T3ZlcnJpZGVzKGNvbmZpZy5vdmVycmlkZXMpLFxuICAgIGZsb29kQ29udHJvbDoge1xuICAgICAgLi4uZGVmYXVsdExvZ2dpbmdDb25maWcuZmxvb2RDb250cm9sLFxuICAgICAgLi4uY29uZmlnLmZsb29kQ29udHJvbCB8fCB7fVxuICAgIH1cbiAgfTtcbn07XG52YXIgY29uZmlndXJlTG9nZ2luZyA9ICgpID0+IHtcbiAgbGV0IGNvbmZpZyA9IHt9O1xuICBjb25zdCBsb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuTE9HR0lOR19DT05GSUc7XG4gIGNvbnN0IGV4cG9Mb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuRVhQT19QVUJMSUNfTE9HR0lOR19DT05GSUc7XG4gIGNvbnN0IG5leHRMb2dnaW5nQ29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTE9HR0lOR19DT05GSUc7XG4gIGxldCBsb2dMZXZlbEVudiA9IHByb2Nlc3MuZW52LkxPR19MRVZFTDtcbiAgbGV0IGxvZ0Zvcm1hdEVudiA9IHByb2Nlc3MuZW52LkxPR19GT1JNQVQ7XG4gIGlmIChsb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UobG9nZ2luZ0NvbmZpZ0Vudik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gaW4gTE9HR0lOR19DT05GSUcgZW52aXJvbm1lbnQgdmFyaWFibGU6XCIsIGVycm9yKTtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBvTG9nZ2luZ0NvbmZpZ0Vudikge1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBKU09OLnBhcnNlKGV4cG9Mb2dnaW5nQ29uZmlnRW52KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlNPTiBpbiBFWFBPX1BVQkxJQ19MT0dHSU5HX0NPTkZJRyBlbnZpcm9ubWVudCB2YXJpYWJsZTpcIiwgZXJyb3IpO1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKG5leHRMb2dnaW5nQ29uZmlnRW52KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UobmV4dExvZ2dpbmdDb25maWdFbnYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIE5FWFRfUFVCTElDX0xPR0dJTkdfQ09ORklHIGVudmlyb25tZW50IHZhcmlhYmxlOlwiLCBlcnJvcik7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29udmVydGVkQ29uZmlnID0gY29udmVydENvbmZpZyhjb25maWcpO1xuICBpZiAobG9nTGV2ZWxFbnYpIHtcbiAgICBsb2dMZXZlbEVudiA9IGxvZ0xldmVsRW52Py50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGxvZ0xldmVsQ29uZmlnID0gZ2V0Q29uZmlnMihsb2dMZXZlbEVudik7XG4gICAgY29udmVydGVkQ29uZmlnLmxvZ0xldmVsID0gbG9nTGV2ZWxDb25maWc7XG4gIH1cbiAgaWYgKGxvZ0Zvcm1hdEVudikge1xuICAgIGxvZ0Zvcm1hdEVudiA9IGxvZ0Zvcm1hdEVudi50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGxvZ0Zvcm1hdENvbmZpZyA9IGdldENvbmZpZyhsb2dGb3JtYXRFbnYpO1xuICAgIGNvbnZlcnRlZENvbmZpZy5sb2dGb3JtYXQgPSBsb2dGb3JtYXRDb25maWc7XG4gIH1cbiAgY29uc3QgZmluYWxDb25maWcgPSB7IC4uLmRlZmF1bHRMb2dnaW5nQ29uZmlnLCAuLi5jb252ZXJ0ZWRDb25maWcgfTtcbiAgcmV0dXJuIGZpbmFsQ29uZmlnO1xufTtcblxuLy8gc3JjL1dyaXRlci50c1xudmFyIGNyZWF0ZVdyaXRlciA9IChmb3JtYXR0ZXIsIGxvZ01ldGhvZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZXNwZWN0SW5qZWN0ZWRNZXRob2QgPSBmYWxzZSxcbiAgICBlcnJvck1ldGhvZCA9IGNvbnNvbGUuZXJyb3IsXG4gICAgd2FybmluZ01ldGhvZCA9IGNvbnNvbGUud2FybixcbiAgICBpbmZvTWV0aG9kID0gY29uc29sZS5sb2dcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgd3JpdGU6IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICAgIGxldCBmaW5hbExvZ01ldGhvZCA9IGxvZ01ldGhvZDtcbiAgICAgIGlmICghcmVzcGVjdEluamVjdGVkTWV0aG9kKSB7XG4gICAgICAgIGlmIChsZXZlbC5uYW1lID09PSBFUlJPUi5uYW1lIHx8IGxldmVsLm5hbWUgPT09IENSSVRJQ0FMLm5hbWUgfHwgbGV2ZWwubmFtZSA9PT0gQUxFUlQubmFtZSB8fCBsZXZlbC5uYW1lID09PSBFTUVSR0VOQ1kubmFtZSkge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gZXJyb3JNZXRob2Q7XG4gICAgICAgIH0gZWxzZSBpZiAobGV2ZWwubmFtZSA9PT0gV0FSTklORy5uYW1lKSB7XG4gICAgICAgICAgZmluYWxMb2dNZXRob2QgPSB3YXJuaW5nTWV0aG9kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbmFsTG9nTWV0aG9kID0gaW5mb01ldGhvZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluYWxMb2dNZXRob2QoZm9ybWF0dGVyLmZvcm1hdExvZyhsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvZm9ybWF0dGVyLnRzXG5pbXBvcnQgdXRpbCBmcm9tIFwidXRpbFwiO1xudmFyIHNhZmVJbnNwZWN0ID0gKG9iaikgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qob2JqKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGBbT2JqZWN0OiAke3R5cGVvZiBvYmp9XWA7XG4gIH1cbn07XG52YXIgc2FmZUZvcm1hdCA9IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHV0aWwuZm9ybWF0KG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYCR7bWVzc2FnZX0gJHtzYWZlSW5zcGVjdChhcmdzKX1gO1xuICB9XG59O1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IChsb2dGb3JtYXQpID0+IHtcbiAgaWYgKGxvZ0Zvcm1hdC5uYW1lID09PSBcIlRFWFRcIikge1xuICAgIHJldHVybiBnZXRUZXh0Rm9ybWF0dGVyKCk7XG4gIH0gZWxzZSBpZiAobG9nRm9ybWF0Lm5hbWUgPT09IFwiU1RSVUNUVVJFRFwiKSB7XG4gICAgcmV0dXJuIGdldFN0cnVjdHVyZWRGb3JtYXR0ZXIoKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbG9nIGZvcm1hdDogJHtsb2dGb3JtYXQubmFtZX1gKTtcbn07XG52YXIgZ2V0VGV4dEZvcm1hdHRlciA9ICgpID0+IHtcbiAgY29uc3QgZm9ybWF0TG9nID0gKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGhhc1NwZWNpZmllcnMgPSAvJVtzZGppZm9PJV0vLnRlc3QocGF5bG9hZC5tZXNzYWdlKTtcbiAgICBsZXQgbG9nTWVzc2FnZTtcbiAgICBpZiAocGF5bG9hZC5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nTWVzc2FnZSA9IHBheWxvYWQubWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKGhhc1NwZWNpZmllcnMpIHtcbiAgICAgIGxvZ01lc3NhZ2UgPSBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nTWVzc2FnZSA9IGAke3BheWxvYWQubWVzc2FnZX0gJHtzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpfWA7XG4gICAgfVxuICAgIHJldHVybiBgKCR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS52YWx1ZU9mKCl9KSBbJHtsZXZlbC5uYW1lfV0gLSBbJHtjb29yZGluYXRlcy5jYXRlZ29yeX1dICR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX0gJHtsb2dNZXNzYWdlfWA7XG4gIH07XG4gIGNvbnN0IHRpbWVyTWVzc2FnZSA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCByYW5kb21JbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTYpO1xuICAgIGNvbnN0IHRpbWVyTWVzc2FnZTIgPSBgKCR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS52YWx1ZU9mKCl9KSBbJHtsZXZlbC5uYW1lfV0gLSBbJHtjb29yZGluYXRlcy5jYXRlZ29yeX1dICR7Y29vcmRpbmF0ZXMuY29tcG9uZW50cy5tYXAoKGMpID0+IGBbJHtjfV1gKX0gJHtzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKX0gJHtzYWZlSW5zcGVjdChwYXlsb2FkLmRhdGEpfSAke3JhbmRvbUludH1gO1xuICAgIHJldHVybiB0aW1lck1lc3NhZ2UyO1xuICB9O1xuICByZXR1cm4geyBmb3JtYXRMb2csIHRpbWVyTWVzc2FnZSwgZ2V0TG9nRm9ybWF0OiAoKSA9PiBURVhUIH07XG59O1xudmFyIGdldFN0cnVjdHVyZWRGb3JtYXR0ZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGZvcm1hdExvZyA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IC8lW3Nkamlmb08lXS8udGVzdChwYXlsb2FkLm1lc3NhZ2UpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzZXZlcml0eSxcbiAgICAgIG1lc3NhZ2U6IGhhc1NwZWNpZmllcnMgPyBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKSA6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9sYWJlbHNcIjoge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IGAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9YFxuICAgICAgfSxcbiAgICAgIC4uLiFoYXNTcGVjaWZpZXJzICYmIHBheWxvYWQuZGF0YS5sZW5ndGggPiAwICYmIHsgZGF0YTogc2FmZUluc3BlY3QocGF5bG9hZC5kYXRhKSB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHRpbWVyTWVzc2FnZSA9IChsZXZlbCwgY29vcmRpbmF0ZXMsIHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBzZXZlcml0eSA9IGxldmVsLm5hbWU7XG4gICAgY29uc3QgcmFuZG9tSW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU2KTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc2V2ZXJpdHksXG4gICAgICBtZXNzYWdlOiBzYWZlRm9ybWF0KHBheWxvYWQubWVzc2FnZSwgLi4ucGF5bG9hZC5kYXRhKSxcbiAgICAgIFwibG9nZ2luZy5nb29nbGVhcGlzLmNvbS9sYWJlbHNcIjoge1xuICAgICAgICBjYXRlZ29yeTogY29vcmRpbmF0ZXMuY2F0ZWdvcnksXG4gICAgICAgIGNvbXBvbmVudHM6IGAke2Nvb3JkaW5hdGVzLmNvbXBvbmVudHMubWFwKChjKSA9PiBgWyR7Y31dYCl9YFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHNhZmVJbnNwZWN0KHBheWxvYWQuZGF0YSksXG4gICAgICBcImxvZ2dpbmcuZ29vZ2xlYXBpcy5jb20vc3BhbklkXCI6IFN0cmluZyhyYW5kb21JbnQpXG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB7IGZvcm1hdExvZywgdGltZXJNZXNzYWdlLCBnZXRMb2dGb3JtYXQ6ICgpID0+IFNUUlVDVFVSRUQgfTtcbn07XG5cbi8vIHNyYy9GbG9vZENvbnRyb2wudHNcbmltcG9ydCB1dGlsMiBmcm9tIFwidXRpbFwiO1xudmFyIGhhc2ggPSAobWVzc2FnZSwgZGF0YSkgPT4ge1xuICBjb25zdCBkYXRhU3RyaW5nID0gZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHV0aWwyLmluc3BlY3QoaXRlbSk7XG4gICAgfVxuICB9KS5qb2luKFwiXCIpO1xuICByZXR1cm4gYCR7bWVzc2FnZX0ke2RhdGFTdHJpbmd9YDtcbn07XG52YXIgRmxvb2RDb250cm9sID0gY2xhc3Mge1xuICBjb25maWc7XG4gIGhpc3RvcnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdXBwcmVzc2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5jbGVhbnVwKCksIHRoaXMuY29uZmlnLnRpbWVmcmFtZSAqIDIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmNsZWFudXBUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IFtoYXNoMiwgdGltZXN0YW1wc10gb2YgdGhpcy5oaXN0b3J5LmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgcmVjZW50VGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuZmlsdGVyKFxuICAgICAgICAodGltZXN0YW1wKSA9PiBub3cgLSB0aW1lc3RhbXAgPCB0aGlzLmNvbmZpZy50aW1lZnJhbWVcbiAgICAgICk7XG4gICAgICBpZiAocmVjZW50VGltZXN0YW1wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5zZXQoaGFzaDIsIHJlY2VudFRpbWVzdGFtcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LmRlbGV0ZShoYXNoMik7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5kZWxldGUoaGFzaDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGVjayhtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gXCJsb2dcIjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBoYXNoKG1lc3NhZ2UsIGRhdGEpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9ICh0aGlzLmhpc3RvcnkuZ2V0KG1lc3NhZ2VIYXNoKSB8fCBbXSkuZmlsdGVyKFxuICAgICAgKHRpbWVzdGFtcCkgPT4gbm93IC0gdGltZXN0YW1wIDwgdGhpcy5jb25maWcudGltZWZyYW1lXG4gICAgKTtcbiAgICB0aW1lc3RhbXBzLnB1c2gobm93KTtcbiAgICB0aGlzLmhpc3Rvcnkuc2V0KG1lc3NhZ2VIYXNoLCB0aW1lc3RhbXBzKTtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPiB0aGlzLmNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgIGNvbnN0IHN1cHByZXNzZWRJbmZvID0gdGhpcy5zdXBwcmVzc2VkLmdldChtZXNzYWdlSGFzaCk7XG4gICAgICBpZiAoc3VwcHJlc3NlZEluZm8pIHtcbiAgICAgICAgc3VwcHJlc3NlZEluZm8uY291bnQrKztcbiAgICAgICAgcmV0dXJuIFwic3VwcHJlc3NcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5zZXQobWVzc2FnZUhhc2gsIHsgY291bnQ6IDEsIGZpcnN0VGltZXN0YW1wOiB0aW1lc3RhbXBzWzBdLCBzdW1tYXJ5TG9nZ2VkOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIFwic3VwcHJlc3NcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuc3VwcHJlc3NlZC5oYXMobWVzc2FnZUhhc2gpKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NlZC5kZWxldGUobWVzc2FnZUhhc2gpO1xuICAgICAgICByZXR1cm4gXCJyZXN1bWVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwibG9nXCI7XG4gIH1cbiAgZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2gobWVzc2FnZSwgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuc3VwcHJlc3NlZC5nZXQobWVzc2FnZUhhc2gpPy5jb3VudCB8fCAwO1xuICB9XG59O1xuXG4vLyBzcmMvTG9nZ2VyLnRzXG52YXIgY3JlYXRlTG9nZ2VyID0gKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBmbG9vZENvbnRyb2xDb25maWcsIHdyaXRlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGxvZ0Zvcm1hdCk7XG4gIGNvbnN0IGZsb29kQ29udHJvbCA9IGZsb29kQ29udHJvbENvbmZpZy5lbmFibGVkID8gbmV3IEZsb29kQ29udHJvbChmbG9vZENvbnRyb2xDb25maWcpIDogbnVsbDtcbiAgY29uc3QgbG9nRnVuY3Rpb24gPSBjb25zb2xlLmxvZztcbiAgY29uc3Qgd3JpdGVyID0gY3JlYXRlV3JpdGVyKGZvcm1hdHRlciwgbG9nRnVuY3Rpb24sIHdyaXRlck9wdGlvbnMpO1xuICBjb25zdCB3cml0ZSA9IChsZXZlbCwgbWVzc2FnZSwgZGF0YSkgPT4ge1xuICAgIGlmIChsb2dMZXZlbC52YWx1ZSA8IGxldmVsLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrID0gZmxvb2RDb250cm9sID8gZmxvb2RDb250cm9sLmNoZWNrKG1lc3NhZ2UsIGRhdGEpIDogXCJsb2dcIjtcbiAgICBjb25zdCBwYXlsb2FkID0geyBtZXNzYWdlLCBkYXRhIH07XG4gICAgc3dpdGNoIChjaGVjaykge1xuICAgICAgY2FzZSBcImxvZ1wiOlxuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3VwcHJlc3NcIjpcbiAgICAgICAgaWYgKGZsb29kQ29udHJvbCAmJiBmbG9vZENvbnRyb2wuZ2V0U3VwcHJlc3NlZENvdW50KG1lc3NhZ2UsIGRhdGEpID09PSAxKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGNvbnN0IG5ld1BheWxvYWQgPSB7IG1lc3NhZ2U6IGBTdGFydGVkIHN1cHByZXNzaW5nIHJlcGVhdGVkIGxvZyBtZXNzYWdlYCwgZGF0YTogW10gfTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUob3JpZ2luYWxMZXZlbCwgY29vcmRpbmF0ZXMsIG5ld1BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlc3VtZVwiOiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZmxvb2RDb250cm9sID8gZmxvb2RDb250cm9sLmdldFN1cHByZXNzZWRDb3VudChtZXNzYWdlLCBkYXRhKSA6IDA7XG4gICAgICAgIGNvbnN0IHJlc3VtZVBheWxvYWQgPSB7XG4gICAgICAgICAgbWVzc2FnZTogYFN0b3BwZWQgc3VwcHJlc3NpbmcgcmVwZWF0ZWQgbG9nIG1lc3NhZ2UuIFN1cHByZXNzZWQgJHtjb3VudH0gdGltZXMuYCxcbiAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9O1xuICAgICAgICB3cml0ZXIud3JpdGUobGV2ZWwsIGNvb3JkaW5hdGVzLCByZXN1bWVQYXlsb2FkKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGxldmVsLCBjb29yZGluYXRlcywgcGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhcnRUaW1lTG9nZ2VyID0gKGxvZ0xldmVsMiwgY29vcmRpbmF0ZXMyLCBwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgdGltZXJNZXNzYWdlID0gZm9ybWF0dGVyLnRpbWVyTWVzc2FnZShsb2dMZXZlbDIsIGNvb3JkaW5hdGVzMiwgcGF5bG9hZCk7XG4gICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZSh0aW1lck1lc3NhZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZUVuZCh0aW1lck1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICAgIGxvZzogKC4uLmRhdGEpID0+IHtcbiAgICAgICAgbG9nTGV2ZWwyLnZhbHVlID49IERFQlVHLnZhbHVlICYmIGNvbnNvbGUudGltZUxvZyh0aW1lck1lc3NhZ2UsIC4uLmRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgZW1lcmdlbmN5OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoRU1FUkdFTkNZLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIGFsZXJ0OiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoQUxFUlQsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgY3JpdGljYWw6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShDUklUSUNBTCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBlcnJvcjogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKEVSUk9SLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHdhcm5pbmc6IChtZXNzYWdlLCAuLi5kYXRhKSA9PiB7XG4gICAgICB3cml0ZShXQVJOSU5HLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIG5vdGljZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKE5PVElDRSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoSU5GTywgbWVzc2FnZSwgZGF0YSk7XG4gICAgfSxcbiAgICBkZWJ1ZzogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKERFQlVHLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9LFxuICAgIHRyYWNlOiAobWVzc2FnZSwgLi4uZGF0YSkgPT4ge1xuICAgICAgd3JpdGUoVFJBQ0UsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgZGVmYXVsdDogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIHdyaXRlKERFRkFVTFQsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG4gICAgdGltZTogKG1lc3NhZ2UsIC4uLmRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG1lc3NhZ2UsIGRhdGEgfTtcbiAgICAgIHJldHVybiBzdGFydFRpbWVMb2dnZXIobG9nTGV2ZWwsIGNvb3JkaW5hdGVzLCBwYXlsb2FkKTtcbiAgICB9LFxuICAgIGdldDogKC4uLmFkZGl0aW9uYWxDb21wb25lbnRzKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlTG9nZ2VyKGxvZ0Zvcm1hdCwgbG9nTGV2ZWwsIHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvb3JkaW5hdGVzLmNhdGVnb3J5LFxuICAgICAgICBjb21wb25lbnRzOiBbLi4uY29vcmRpbmF0ZXMuY29tcG9uZW50cywgLi4uYWRkaXRpb25hbENvbXBvbmVudHNdXG4gICAgICB9LCBmbG9vZENvbnRyb2xDb25maWcsIHdyaXRlck9wdGlvbnMpO1xuICAgIH0sXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgaWYgKGZsb29kQ29udHJvbCkge1xuICAgICAgICBmbG9vZENvbnRyb2wuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9sb2dnaW5nLnRzXG52YXIgZ2V0TG9nZ2VyID0gKG5hbWUpID0+IHtcbiAgY29uc3QgY29uZmlnID0gY29uZmlndXJlTG9nZ2luZygpO1xuICBjb25zdCBsb2dnZXIgPSBjcmVhdGVCYXNlTG9nZ2VyKG5hbWUsIGNvbmZpZyk7XG4gIHJldHVybiBsb2dnZXI7XG59O1xudmFyIGNyZWF0ZUJhc2VMb2dnZXIgPSAobmFtZSwgY29uZmlnKSA9PiB7XG4gIGxldCB7IGxvZ0xldmVsIH0gPSBjb25maWc7XG4gIGNvbnN0IHsgbG9nRm9ybWF0LCBmbG9vZENvbnRyb2wgfSA9IGNvbmZpZztcbiAgY29uc3Qgb3ZlcnJpZGVzID0gY29uZmlnLm92ZXJyaWRlcztcbiAgaWYgKG92ZXJyaWRlcyAmJiBvdmVycmlkZXNbbmFtZV0pIHtcbiAgICBsb2dMZXZlbCA9IG92ZXJyaWRlc1tuYW1lXS5sb2dMZXZlbDtcbiAgfVxuICBjb25zdCBjb29yZGluYXRlcyA9IHsgY2F0ZWdvcnk6IG5hbWUsIGNvbXBvbmVudHM6IFtdIH07XG4gIHJldHVybiBjcmVhdGVMb2dnZXIobG9nRm9ybWF0LCBsb2dMZXZlbCwgY29vcmRpbmF0ZXMsIGZsb29kQ29udHJvbCk7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0geyBnZXRMb2dnZXIgfTtcbmV4cG9ydCB7XG4gIExvZ0Zvcm1hdF9leHBvcnRzIGFzIExvZ0Zvcm1hdCxcbiAgTG9nTGV2ZWxfZXhwb3J0cyBhcyBMb2dMZXZlbCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBnZXRMb2dnZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/@fjell/registry/dist/index.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/@fjell/registry/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateError: () => (/* binding */ CoordinateError),\n/* harmony export */   DuplicateRegistryTypeError: () => (/* binding */ DuplicateRegistryTypeError),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InstanceNotFoundError: () => (/* binding */ InstanceNotFoundError),\n/* harmony export */   InvalidCoordinateError: () => (/* binding */ InvalidCoordinateError),\n/* harmony export */   InvalidFactoryResultError: () => (/* binding */ InvalidFactoryResultError),\n/* harmony export */   InvalidInstanceRegistrationError: () => (/* binding */ InvalidInstanceRegistrationError),\n/* harmony export */   InvalidKTAError: () => (/* binding */ InvalidKTAError),\n/* harmony export */   InvalidRegistryFactoryResultError: () => (/* binding */ InvalidRegistryFactoryResultError),\n/* harmony export */   InvalidScopesError: () => (/* binding */ InvalidScopesError),\n/* harmony export */   NoChildrenAvailableError: () => (/* binding */ NoChildrenAvailableError),\n/* harmony export */   NoInstancesAvailableError: () => (/* binding */ NoInstancesAvailableError),\n/* harmony export */   NoInstancesRegisteredError: () => (/* binding */ NoInstancesRegisteredError),\n/* harmony export */   RegistryCreationError: () => (/* binding */ RegistryCreationError),\n/* harmony export */   RegistryError: () => (/* binding */ RegistryError),\n/* harmony export */   RegistryFactoryError: () => (/* binding */ RegistryFactoryError),\n/* harmony export */   RegistryHubError: () => (/* binding */ RegistryHubError),\n/* harmony export */   RegistryStats: () => (/* binding */ RegistryStats),\n/* harmony export */   RegistryTypeNotFoundError: () => (/* binding */ RegistryTypeNotFoundError),\n/* harmony export */   ScopeNotFoundError: () => (/* binding */ ScopeNotFoundError),\n/* harmony export */   createCoordinate: () => (/* binding */ createCoordinate),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   createRegistry: () => (/* binding */ createRegistry),\n/* harmony export */   createRegistryHub: () => (/* binding */ createRegistryHub),\n/* harmony export */   isInstance: () => (/* binding */ isInstance)\n/* harmony export */ });\n/* harmony import */ var _fjell_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fjell/logging */ \"(app-pages-browser)/../fjell-providers/node_modules/@fjell/logging/dist/index.js\");\n// src/logger.ts\n\nvar LibLogger = _fjell_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"@fjell/registry\");\nvar logger_default = LibLogger;\n\n// src/Coordinate.ts\nvar logger = logger_default.get(\"Coordinate\");\nvar createCoordinate = (kta, scopes = []) => {\n  const ktArray = Array.isArray(kta) ? kta : [kta];\n  const toString = () => {\n    logger.debug(\"toString\", { kta, scopes });\n    return `${ktArray.join(\", \")} - ${scopes.join(\", \")}`;\n  };\n  logger.debug(\"createCoordinate\", { kta: ktArray, scopes, toString });\n  return { kta: ktArray, scopes, toString };\n};\n\n// src/Instance.ts\nvar logger2 = logger_default.get(\"Instance\");\nvar createInstance = (registry, coordinate) => {\n  logger2.debug(\"createInstance\", { coordinate, registry });\n  return { coordinate, registry };\n};\nvar isInstance = (instance) => {\n  return instance !== null && instance !== void 0 && instance.coordinate !== void 0 && instance.registry !== void 0;\n};\n\n// src/RegistryStats.ts\nvar RegistryStats = class {\n  totalCalls = 0;\n  // Map structure: ktaKey -> scopeKey -> clientKey -> count\n  coordinateCalls = /* @__PURE__ */ new Map();\n  /**\n   * Records a get() call for the specified coordinate and client\n   */\n  recordGetCall(kta, scopes, client) {\n    this.totalCalls++;\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    if (!this.coordinateCalls.has(ktaKey)) {\n      this.coordinateCalls.set(ktaKey, /* @__PURE__ */ new Map());\n    }\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap.has(scopeKey)) {\n      scopeMap.set(scopeKey, /* @__PURE__ */ new Map());\n    }\n    const clientMap = scopeMap.get(scopeKey);\n    const currentCount = clientMap.get(clientKey) || 0;\n    clientMap.set(clientKey, currentCount + 1);\n  }\n  /**\n   * Gets the current statistics snapshot\n   */\n  getStatistics() {\n    const coordinateCallRecords = [];\n    let serviceCalls = 0;\n    let applicationCalls = 0;\n    let unidentifiedCalls = 0;\n    for (const [ktaKey, scopeMap] of this.coordinateCalls) {\n      for (const [scopeKey, clientMap] of scopeMap) {\n        const clientCalls = [];\n        let totalCount = 0;\n        for (const [clientKey, count] of clientMap) {\n          const client = this.parseClientKey(clientKey);\n          if (client !== null) {\n            clientCalls.push({ client, count });\n          }\n          totalCount += count;\n          if (clientKey === \"__no_client__\") {\n            unidentifiedCalls += count;\n          } else if (typeof client === \"string\") {\n            applicationCalls += count;\n          } else if (client !== null) {\n            serviceCalls += count;\n          }\n        }\n        coordinateCallRecords.push({\n          kta: ktaKey.split(\".\"),\n          scopes: this.parseScopeKey(scopeKey),\n          count: totalCount,\n          clientCalls: [...clientCalls]\n          // Return a copy\n        });\n      }\n    }\n    return {\n      totalGetCalls: this.totalCalls,\n      coordinateCallRecords: [...coordinateCallRecords],\n      // Return a copy\n      clientSummary: {\n        serviceCalls,\n        applicationCalls,\n        unidentifiedCalls\n      }\n    };\n  }\n  /**\n   * Gets call count for a specific coordinate combination\n   */\n  getCallCount(kta, scopes) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    let total = 0;\n    for (const count of clientMap.values()) {\n      total += count;\n    }\n    return total;\n  }\n  /**\n   * Gets call count for a specific coordinate combination from a specific client\n   */\n  getCallCountByClient(kta, scopes, client) {\n    const ktaKey = kta.join(\".\");\n    const scopeKey = this.createScopeKey(scopes || []);\n    const clientKey = this.createClientKey(client);\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    const clientMap = scopeMap.get(scopeKey);\n    if (!clientMap) return 0;\n    return clientMap.get(clientKey) || 0;\n  }\n  /**\n   * Gets total calls for a specific kta (across all scopes)\n   */\n  getTotalCallsForKta(kta) {\n    const ktaKey = kta.join(\".\");\n    const scopeMap = this.coordinateCalls.get(ktaKey);\n    if (!scopeMap) return 0;\n    let total = 0;\n    for (const clientMap of scopeMap.values()) {\n      for (const count of clientMap.values()) {\n        total += count;\n      }\n    }\n    return total;\n  }\n  /**\n   * Gets all unique kta paths that have been called\n   */\n  getCalledKtaPaths() {\n    const ktaPaths = [];\n    for (const ktaKey of this.coordinateCalls.keys()) {\n      ktaPaths.push(ktaKey.split(\".\"));\n    }\n    return ktaPaths;\n  }\n  /**\n   * Creates a normalized scope key from scopes array\n   */\n  createScopeKey(scopes) {\n    if (scopes.length === 0) return \"__no_scopes__\";\n    return [...scopes].sort().join(\",\");\n  }\n  /**\n   * Parses a scope key back to scopes array\n   */\n  parseScopeKey(scopeKey) {\n    if (scopeKey === \"__no_scopes__\") return [];\n    return scopeKey.split(\",\");\n  }\n  /**\n   * Creates a normalized client key from client identifier\n   */\n  createClientKey(client) {\n    if (!client) return \"__no_client__\";\n    if (typeof client === \"string\") {\n      return `app:${client}`;\n    }\n    const coordKey = `${client.coordinate.kta.join(\".\")};${this.createScopeKey(client.coordinate.scopes)}`;\n    return `service:${client.registryType}:${coordKey}`;\n  }\n  /**\n   * Parses a client key back to client identifier\n   */\n  parseClientKey(clientKey) {\n    if (clientKey === \"__no_client__\") return null;\n    if (clientKey.startsWith(\"app:\")) {\n      return clientKey.substring(4);\n    }\n    if (clientKey.startsWith(\"service:\")) {\n      const parts = clientKey.substring(8).split(\":\");\n      if (parts.length !== 2) return null;\n      const registryType = parts[0];\n      const coordParts = parts[1].split(\";\");\n      if (coordParts.length !== 2) return null;\n      const kta = coordParts[0].split(\".\");\n      const scopes = this.parseScopeKey(coordParts[1]);\n      return {\n        registryType,\n        coordinate: { kta, scopes }\n      };\n    }\n    return null;\n  }\n};\n\n// src/Registry.ts\nvar logger3 = logger_default.get(\"Registry\");\nvar findScopedInstance = (scopedInstances, requestedScopes) => {\n  if (!requestedScopes || requestedScopes.length === 0) {\n    const firstInstance = scopedInstances[0]?.instance;\n    if (!firstInstance) {\n      throw new Error(\"No instances available\");\n    }\n    return firstInstance;\n  }\n  const matchingInstance = scopedInstances.find((scopedInstance) => {\n    if (!scopedInstance.scopes) return false;\n    return requestedScopes.every(\n      (scope) => scopedInstance.scopes && scopedInstance.scopes.includes(scope)\n    );\n  });\n  if (!matchingInstance) {\n    throw new Error(`No instance found matching scopes: ${requestedScopes.join(\", \")}`);\n  }\n  return matchingInstance.instance;\n};\nvar createRegistry = (type, registryHub) => {\n  const instanceTree = {};\n  const registryStats = new RegistryStats();\n  const createProxiedRegistry = (callingCoordinate) => {\n    const serviceClient = {\n      registryType: type,\n      coordinate: {\n        kta: callingCoordinate.kta,\n        scopes: callingCoordinate.scopes\n      }\n    };\n    return {\n      ...registry,\n      get: (kta, options) => {\n        const clientToUse = options?.client || serviceClient;\n        return registry.get(kta, { ...options, client: clientToUse });\n      }\n    };\n  };\n  const createInstance2 = (kta, scopes, factory) => {\n    logger3.debug(`Creating and registering instance for key path and scopes`, kta, scopes, `in registry type: ${type}`);\n    const coordinate = createCoordinate(kta, scopes);\n    const proxiedRegistry = createProxiedRegistry(coordinate);\n    const instance = factory(coordinate, {\n      registry: proxiedRegistry,\n      registryHub\n    });\n    if (!isInstance(instance)) {\n      throw new Error(`Factory did not return a valid instance for: ${kta.join(\".\")}`);\n    }\n    registerInternal(kta, instance, { scopes });\n    return instance;\n  };\n  const registerInternal = (kta, instance, options) => {\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    logger3.debug(`Registering instance for key path and scopes`, keyPath, options?.scopes, `in registry type: ${type}`);\n    if (!isInstance(instance)) {\n      throw new Error(`Attempting to register a non-instance: ${kta.join(\".\")}`);\n    }\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        currentLevel[keyType] = {\n          instances: [],\n          children: isLeaf ? null : {}\n        };\n      }\n      if (isLeaf) {\n        currentLevel[keyType].instances.push({\n          scopes: options?.scopes,\n          instance\n        });\n      } else {\n        if (!currentLevel[keyType].children) {\n          currentLevel[keyType].children = {};\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n  };\n  const register = (kta, instance, options) => {\n    logger3.debug(\"Using deprecated register method. Consider using createInstance instead.\");\n    registerInternal(kta, instance, options);\n  };\n  const get = (kta, options) => {\n    registryStats.recordGetCall(kta, options?.scopes, options?.client);\n    const keyPath = [...kta].reverse();\n    let currentLevel = instanceTree;\n    for (let i = 0; i < keyPath.length; i++) {\n      const keyType = keyPath[i];\n      const isLeaf = i === keyPath.length - 1;\n      if (!currentLevel[keyType]) {\n        throw new Error(`Instance not found for key path: ${kta.join(\".\")}, Missing key: ${keyType}`);\n      }\n      if (isLeaf) {\n        const scopedInstances = currentLevel[keyType].instances;\n        if (scopedInstances.length === 0) {\n          throw new Error(`No instances registered for key path: ${kta.join(\".\")}`);\n        }\n        return findScopedInstance(scopedInstances, options?.scopes);\n      } else {\n        if (!currentLevel[keyType].children) {\n          throw new Error(`Instance not found for key path: ${kta.join(\".\")}, No children for: ${keyType}`);\n        }\n        currentLevel = currentLevel[keyType].children;\n      }\n    }\n    return null;\n  };\n  const getCoordinates = () => {\n    const coordinates = [];\n    const traverseTree = (node) => {\n      for (const keyType in node) {\n        const treeNode = node[keyType];\n        for (const scopedInstance of treeNode.instances) {\n          coordinates.push(scopedInstance.instance.coordinate);\n        }\n        if (treeNode.children) {\n          traverseTree(treeNode.children);\n        }\n      }\n    };\n    traverseTree(instanceTree);\n    return coordinates;\n  };\n  const getStatistics = () => {\n    return registryStats.getStatistics();\n  };\n  const registry = {\n    type,\n    registryHub,\n    createInstance: createInstance2,\n    register,\n    get,\n    getCoordinates,\n    getStatistics,\n    instanceTree\n  };\n  return registry;\n};\n\n// src/errors/RegistryError.ts\nvar RegistryError = class extends Error {\n  registryType;\n  context;\n  constructor(message, registryType, context) {\n    super(message);\n    this.name = this.constructor.name;\n    this.registryType = registryType;\n    this.context = context;\n    const ErrorConstructor = Error;\n    if (typeof ErrorConstructor.captureStackTrace === \"function\") {\n      ErrorConstructor.captureStackTrace(this, this.constructor);\n    }\n  }\n  getDetails() {\n    const details = [this.message];\n    if (this.registryType) {\n      details.push(`Registry Type: ${this.registryType}`);\n    }\n    if (this.context) {\n      details.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n    }\n    return details.join(\"\\n\");\n  }\n};\nvar RegistryCreationError = class extends RegistryError {\n  constructor(type, reason, context) {\n    super(`Failed to create registry of type '${type}': ${reason}`, type, context);\n  }\n};\nvar InvalidFactoryResultError = class extends RegistryError {\n  keyPath;\n  factoryResult;\n  constructor(keyPath, factoryResult, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Factory did not return a valid instance for: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof factoryResult}`,\n      registryType,\n      { keyPath, factoryResult: typeof factoryResult }\n    );\n    this.keyPath = keyPath;\n    this.factoryResult = factoryResult;\n  }\n};\nvar InvalidInstanceRegistrationError = class extends RegistryError {\n  keyPath;\n  attemptedRegistration;\n  constructor(keyPath, attemptedRegistration, registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Attempting to register a non-instance: ${keyPathStr}. Expected instance with 'coordinate' and 'registry' properties, got: ${typeof attemptedRegistration}`,\n      registryType,\n      { keyPath, attemptedRegistration: typeof attemptedRegistration }\n    );\n    this.keyPath = keyPath;\n    this.attemptedRegistration = attemptedRegistration;\n  }\n};\n\n// src/errors/RegistryHubError.ts\nvar RegistryHubError = class extends RegistryError {\n  hubType;\n  constructor(message, hubType, context) {\n    const enrichedContext = hubType ? { ...context, hubType } : context;\n    super(message, \"\", enrichedContext);\n    this.hubType = hubType;\n  }\n};\nvar DuplicateRegistryTypeError = class extends RegistryHubError {\n  duplicateType;\n  constructor(type, context) {\n    super(\n      `Registry already registered under type: ${type}. Each registry type must be unique within a registry hub.`,\n      \"\",\n      { ...context, duplicateType: type }\n    );\n    this.duplicateType = type;\n  }\n};\nvar RegistryTypeNotFoundError = class extends RegistryHubError {\n  requestedType;\n  availableTypes;\n  constructor(requestedType, availableTypes = [], context) {\n    let message = `No registry registered under type: ${requestedType}`;\n    if (availableTypes.length > 0) {\n      message += `. Available types: [${availableTypes.join(\", \")}]`;\n    }\n    super(message, \"\", { ...context, requestedType, availableTypes });\n    this.requestedType = requestedType;\n    this.availableTypes = availableTypes;\n  }\n};\nvar RegistryFactoryError = class extends RegistryHubError {\n  factoryError;\n  attemptedType;\n  constructor(type, factoryError, context) {\n    super(\n      `Registry factory failed to create registry of type '${type}': ${factoryError.message}`,\n      \"\",\n      { ...context, attemptedType: type, originalError: factoryError.message }\n    );\n    this.factoryError = factoryError;\n    this.attemptedType = type;\n  }\n};\nvar InvalidRegistryFactoryResultError = class extends RegistryHubError {\n  factoryResult;\n  attemptedType;\n  constructor(type, factoryResult, context) {\n    super(\n      `Registry factory returned invalid registry for type '${type}'. Expected registry with 'type', 'get', 'register', and 'createInstance' properties, got: ${typeof factoryResult}`,\n      \"\",\n      { ...context, attemptedType: type, factoryResult: typeof factoryResult }\n    );\n    this.factoryResult = factoryResult;\n    this.attemptedType = type;\n  }\n};\n\n// src/RegistryHub.ts\nvar logger4 = logger_default.get(\"RegistryHub\");\nvar createRegistryHub = () => {\n  const registries = {};\n  const createRegistry2 = (type, factory) => {\n    logger4.debug(`Creating new registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    const registry = factory(type, hub);\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    registries[type] = registry;\n    logger4.debug(`Successfully created and registered new registry with type: ${type}`);\n    return registry;\n  };\n  const registerRegistry = (registry) => {\n    const type = registry.type;\n    logger4.debug(`Registering registry with type: ${type}`);\n    if (registries[type]) {\n      throw new DuplicateRegistryTypeError(type);\n    }\n    registries[type] = registry;\n    if (!(\"registryHub\" in registry) || registry.registryHub !== hub) {\n      registry.registryHub = hub;\n    }\n    logger4.debug(`Successfully registered registry with type: ${type}`);\n  };\n  const get = (type, kta, options) => {\n    logger4.debug(`Looking up instance for type: ${type}, kta: ${kta.join(\".\")}, scopes: ${options?.scopes?.join(\",\") || \"none\"}`);\n    const registry = registries[type];\n    if (!registry) {\n      const availableTypes = Object.keys(registries);\n      throw new RegistryTypeNotFoundError(type, availableTypes);\n    }\n    return registry.get(kta, options);\n  };\n  const getRegistry = (type) => {\n    return registries[type] || null;\n  };\n  const getRegisteredTypes = () => {\n    return Object.keys(registries);\n  };\n  const unregisterRegistry = (type) => {\n    if (registries[type]) {\n      delete registries[type];\n      logger4.debug(`Unregistered registry under type: ${type}`);\n      return true;\n    }\n    return false;\n  };\n  const getAllCoordinates = () => {\n    const allCoordinates = [];\n    for (const registryType in registries) {\n      const registry = registries[registryType];\n      const coordinates = registry.getCoordinates();\n      coordinates.forEach((coordinate) => {\n        allCoordinates.push({\n          coordinate,\n          registryType\n        });\n      });\n    }\n    logger4.debug(`Retrieved ${allCoordinates.length} total coordinates from ${Object.keys(registries).length} registries`);\n    return allCoordinates;\n  };\n  const hub = {\n    createRegistry: createRegistry2,\n    registerRegistry,\n    get,\n    getRegistry,\n    getRegisteredTypes,\n    getAllCoordinates,\n    unregisterRegistry\n  };\n  return hub;\n};\n\n// src/errors/InstanceError.ts\nvar InstanceError = class extends RegistryError {\n  keyPath;\n  constructor(message, keyPath, registryType, context) {\n    super(message, registryType, { ...context, keyPath });\n    this.keyPath = keyPath;\n  }\n};\nvar InstanceNotFoundError = class extends InstanceError {\n  missingKey;\n  constructor(keyPath, missingKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    let message = `Instance not found for key path: ${keyPathStr}`;\n    if (missingKey) {\n      message += `, Missing key: ${missingKey}`;\n    }\n    super(message, keyPath, registryType, { ...context, missingKey });\n    this.missingKey = missingKey;\n  }\n};\nvar NoInstancesRegisteredError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances registered for key path: ${keyPathStr}. The key path exists in the registry tree but contains no instances.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar NoInstancesAvailableError = class extends InstanceError {\n  constructor(keyPath, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `No instances available for key path: ${keyPathStr}. This typically indicates an internal registry state issue.`,\n      keyPath,\n      registryType,\n      context\n    );\n  }\n};\nvar ScopeNotFoundError = class extends InstanceError {\n  requestedScopes;\n  availableScopes;\n  constructor(keyPath, requestedScopes, availableScopes = [], registryType) {\n    const keyPathStr = keyPath.join(\".\");\n    const scopesStr = requestedScopes.join(\", \");\n    const availableScopesStr = availableScopes.map((scopes) => `[${scopes.join(\", \")}]`).join(\", \");\n    let message = `No instance found matching scopes: ${scopesStr} for key path: ${keyPathStr}`;\n    if (availableScopes.length > 0) {\n      message += `. Available scopes: ${availableScopesStr}`;\n    }\n    super(message, keyPath, registryType, { requestedScopes, availableScopes });\n    this.requestedScopes = requestedScopes;\n    this.availableScopes = availableScopes;\n  }\n};\nvar NoChildrenAvailableError = class extends InstanceError {\n  parentKey;\n  constructor(keyPath, parentKey, registryType, context) {\n    const keyPathStr = keyPath.join(\".\");\n    super(\n      `Instance not found for key path: ${keyPathStr}, No children for: ${parentKey}. The path cannot be traversed further as '${parentKey}' has no child nodes.`,\n      keyPath,\n      registryType,\n      { ...context, parentKey }\n    );\n    this.parentKey = parentKey;\n  }\n};\n\n// src/errors/CoordinateError.ts\nvar CoordinateError = class extends RegistryError {\n  kta;\n  scopes;\n  constructor(message, kta, scopes, context) {\n    super(message, \"\", { ...context, kta, scopes });\n    this.kta = kta;\n    this.scopes = scopes;\n  }\n};\nvar InvalidCoordinateError = class extends CoordinateError {\n  constructor(kta, scopes, reason, context) {\n    super(\n      `Invalid coordinate parameters: ${reason}. KTA: ${JSON.stringify(kta)}, Scopes: [${scopes.join(\", \")}]`,\n      kta,\n      scopes,\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidKTAError = class extends CoordinateError {\n  constructor(kta, reason, context) {\n    super(\n      `Invalid KTA (Key Type Array): ${reason}. Expected string or array of strings, got: ${JSON.stringify(kta)}`,\n      kta,\n      [],\n      { ...context, reason }\n    );\n  }\n};\nvar InvalidScopesError = class extends CoordinateError {\n  invalidScopes;\n  constructor(scopes, invalidScopes, reason, context) {\n    super(\n      `Invalid scopes: ${reason}. Invalid scope values: ${JSON.stringify(invalidScopes)}`,\n      null,\n      scopes.filter((s) => typeof s === \"string\"),\n      { ...context, reason, invalidScopes }\n    );\n    this.invalidScopes = invalidScopes;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL0BmamVsbC9yZWdpc3RyeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDcUM7QUFDckMsZ0JBQWdCLGdFQUFpQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUMsY0FBYyxvQkFBb0IsSUFBSSxrQkFBa0I7QUFDeEQ7QUFDQSxxQ0FBcUMsZ0NBQWdDO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQTJCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvQGZqZWxsL3JlZ2lzdHJ5L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xvZ2dlci50c1xuaW1wb3J0IExvZ2dpbmcgZnJvbSBcIkBmamVsbC9sb2dnaW5nXCI7XG52YXIgTGliTG9nZ2VyID0gTG9nZ2luZy5nZXRMb2dnZXIoXCJAZmplbGwvcmVnaXN0cnlcIik7XG52YXIgbG9nZ2VyX2RlZmF1bHQgPSBMaWJMb2dnZXI7XG5cbi8vIHNyYy9Db29yZGluYXRlLnRzXG52YXIgbG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiQ29vcmRpbmF0ZVwiKTtcbnZhciBjcmVhdGVDb29yZGluYXRlID0gKGt0YSwgc2NvcGVzID0gW10pID0+IHtcbiAgY29uc3Qga3RBcnJheSA9IEFycmF5LmlzQXJyYXkoa3RhKSA/IGt0YSA6IFtrdGFdO1xuICBjb25zdCB0b1N0cmluZyA9ICgpID0+IHtcbiAgICBsb2dnZXIuZGVidWcoXCJ0b1N0cmluZ1wiLCB7IGt0YSwgc2NvcGVzIH0pO1xuICAgIHJldHVybiBgJHtrdEFycmF5LmpvaW4oXCIsIFwiKX0gLSAke3Njb3Blcy5qb2luKFwiLCBcIil9YDtcbiAgfTtcbiAgbG9nZ2VyLmRlYnVnKFwiY3JlYXRlQ29vcmRpbmF0ZVwiLCB7IGt0YToga3RBcnJheSwgc2NvcGVzLCB0b1N0cmluZyB9KTtcbiAgcmV0dXJuIHsga3RhOiBrdEFycmF5LCBzY29wZXMsIHRvU3RyaW5nIH07XG59O1xuXG4vLyBzcmMvSW5zdGFuY2UudHNcbnZhciBsb2dnZXIyID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiSW5zdGFuY2VcIik7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAocmVnaXN0cnksIGNvb3JkaW5hdGUpID0+IHtcbiAgbG9nZ2VyMi5kZWJ1ZyhcImNyZWF0ZUluc3RhbmNlXCIsIHsgY29vcmRpbmF0ZSwgcmVnaXN0cnkgfSk7XG4gIHJldHVybiB7IGNvb3JkaW5hdGUsIHJlZ2lzdHJ5IH07XG59O1xudmFyIGlzSW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgcmV0dXJuIGluc3RhbmNlICE9PSBudWxsICYmIGluc3RhbmNlICE9PSB2b2lkIDAgJiYgaW5zdGFuY2UuY29vcmRpbmF0ZSAhPT0gdm9pZCAwICYmIGluc3RhbmNlLnJlZ2lzdHJ5ICE9PSB2b2lkIDA7XG59O1xuXG4vLyBzcmMvUmVnaXN0cnlTdGF0cy50c1xudmFyIFJlZ2lzdHJ5U3RhdHMgPSBjbGFzcyB7XG4gIHRvdGFsQ2FsbHMgPSAwO1xuICAvLyBNYXAgc3RydWN0dXJlOiBrdGFLZXkgLT4gc2NvcGVLZXkgLT4gY2xpZW50S2V5IC0+IGNvdW50XG4gIGNvb3JkaW5hdGVDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEgZ2V0KCkgY2FsbCBmb3IgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlIGFuZCBjbGllbnRcbiAgICovXG4gIHJlY29yZEdldENhbGwoa3RhLCBzY29wZXMsIGNsaWVudCkge1xuICAgIHRoaXMudG90YWxDYWxscysrO1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZUtleSA9IHRoaXMuY3JlYXRlU2NvcGVLZXkoc2NvcGVzIHx8IFtdKTtcbiAgICBjb25zdCBjbGllbnRLZXkgPSB0aGlzLmNyZWF0ZUNsaWVudEtleShjbGllbnQpO1xuICAgIGlmICghdGhpcy5jb29yZGluYXRlQ2FsbHMuaGFzKGt0YUtleSkpIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZUNhbGxzLnNldChrdGFLZXksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXAuaGFzKHNjb3BlS2V5KSkge1xuICAgICAgc2NvcGVNYXAuc2V0KHNjb3BlS2V5LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50TWFwID0gc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KTtcbiAgICBjb25zdCBjdXJyZW50Q291bnQgPSBjbGllbnRNYXAuZ2V0KGNsaWVudEtleSkgfHwgMDtcbiAgICBjbGllbnRNYXAuc2V0KGNsaWVudEtleSwgY3VycmVudENvdW50ICsgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGlzdGljcyBzbmFwc2hvdFxuICAgKi9cbiAgZ2V0U3RhdGlzdGljcygpIHtcbiAgICBjb25zdCBjb29yZGluYXRlQ2FsbFJlY29yZHMgPSBbXTtcbiAgICBsZXQgc2VydmljZUNhbGxzID0gMDtcbiAgICBsZXQgYXBwbGljYXRpb25DYWxscyA9IDA7XG4gICAgbGV0IHVuaWRlbnRpZmllZENhbGxzID0gMDtcbiAgICBmb3IgKGNvbnN0IFtrdGFLZXksIHNjb3BlTWFwXSBvZiB0aGlzLmNvb3JkaW5hdGVDYWxscykge1xuICAgICAgZm9yIChjb25zdCBbc2NvcGVLZXksIGNsaWVudE1hcF0gb2Ygc2NvcGVNYXApIHtcbiAgICAgICAgY29uc3QgY2xpZW50Q2FsbHMgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IFtjbGllbnRLZXksIGNvdW50XSBvZiBjbGllbnRNYXApIHtcbiAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLnBhcnNlQ2xpZW50S2V5KGNsaWVudEtleSk7XG4gICAgICAgICAgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xpZW50Q2FsbHMucHVzaCh7IGNsaWVudCwgY291bnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsQ291bnQgKz0gY291bnQ7XG4gICAgICAgICAgaWYgKGNsaWVudEtleSA9PT0gXCJfX25vX2NsaWVudF9fXCIpIHtcbiAgICAgICAgICAgIHVuaWRlbnRpZmllZENhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNsaWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBwbGljYXRpb25DYWxscyArPSBjb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VydmljZUNhbGxzICs9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb29yZGluYXRlQ2FsbFJlY29yZHMucHVzaCh7XG4gICAgICAgICAga3RhOiBrdGFLZXkuc3BsaXQoXCIuXCIpLFxuICAgICAgICAgIHNjb3BlczogdGhpcy5wYXJzZVNjb3BlS2V5KHNjb3BlS2V5KSxcbiAgICAgICAgICBjb3VudDogdG90YWxDb3VudCxcbiAgICAgICAgICBjbGllbnRDYWxsczogWy4uLmNsaWVudENhbGxzXVxuICAgICAgICAgIC8vIFJldHVybiBhIGNvcHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEdldENhbGxzOiB0aGlzLnRvdGFsQ2FsbHMsXG4gICAgICBjb29yZGluYXRlQ2FsbFJlY29yZHM6IFsuLi5jb29yZGluYXRlQ2FsbFJlY29yZHNdLFxuICAgICAgLy8gUmV0dXJuIGEgY29weVxuICAgICAgY2xpZW50U3VtbWFyeToge1xuICAgICAgICBzZXJ2aWNlQ2FsbHMsXG4gICAgICAgIGFwcGxpY2F0aW9uQ2FsbHMsXG4gICAgICAgIHVuaWRlbnRpZmllZENhbGxzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBjYWxsIGNvdW50IGZvciBhIHNwZWNpZmljIGNvb3JkaW5hdGUgY29tYmluYXRpb25cbiAgICovXG4gIGdldENhbGxDb3VudChrdGEsIHNjb3Blcykge1xuICAgIGNvbnN0IGt0YUtleSA9IGt0YS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBzY29wZUtleSA9IHRoaXMuY3JlYXRlU2NvcGVLZXkoc2NvcGVzIHx8IFtdKTtcbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgaWYgKCFjbGllbnRNYXApIHJldHVybiAwO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChjb25zdCBjb3VudCBvZiBjbGllbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgIHRvdGFsICs9IGNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgY2FsbCBjb3VudCBmb3IgYSBzcGVjaWZpYyBjb29yZGluYXRlIGNvbWJpbmF0aW9uIGZyb20gYSBzcGVjaWZpYyBjbGllbnRcbiAgICovXG4gIGdldENhbGxDb3VudEJ5Q2xpZW50KGt0YSwgc2NvcGVzLCBjbGllbnQpIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVLZXkgPSB0aGlzLmNyZWF0ZVNjb3BlS2V5KHNjb3BlcyB8fCBbXSk7XG4gICAgY29uc3QgY2xpZW50S2V5ID0gdGhpcy5jcmVhdGVDbGllbnRLZXkoY2xpZW50KTtcbiAgICBjb25zdCBzY29wZU1hcCA9IHRoaXMuY29vcmRpbmF0ZUNhbGxzLmdldChrdGFLZXkpO1xuICAgIGlmICghc2NvcGVNYXApIHJldHVybiAwO1xuICAgIGNvbnN0IGNsaWVudE1hcCA9IHNjb3BlTWFwLmdldChzY29wZUtleSk7XG4gICAgaWYgKCFjbGllbnRNYXApIHJldHVybiAwO1xuICAgIHJldHVybiBjbGllbnRNYXAuZ2V0KGNsaWVudEtleSkgfHwgMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0b3RhbCBjYWxscyBmb3IgYSBzcGVjaWZpYyBrdGEgKGFjcm9zcyBhbGwgc2NvcGVzKVxuICAgKi9cbiAgZ2V0VG90YWxDYWxsc0Zvckt0YShrdGEpIHtcbiAgICBjb25zdCBrdGFLZXkgPSBrdGEuam9pbihcIi5cIik7XG4gICAgY29uc3Qgc2NvcGVNYXAgPSB0aGlzLmNvb3JkaW5hdGVDYWxscy5nZXQoa3RhS2V5KTtcbiAgICBpZiAoIXNjb3BlTWFwKSByZXR1cm4gMDtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgY2xpZW50TWFwIG9mIHNjb3BlTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvdW50IG9mIGNsaWVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgICB0b3RhbCArPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFsbCB1bmlxdWUga3RhIHBhdGhzIHRoYXQgaGF2ZSBiZWVuIGNhbGxlZFxuICAgKi9cbiAgZ2V0Q2FsbGVkS3RhUGF0aHMoKSB7XG4gICAgY29uc3Qga3RhUGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGt0YUtleSBvZiB0aGlzLmNvb3JkaW5hdGVDYWxscy5rZXlzKCkpIHtcbiAgICAgIGt0YVBhdGhzLnB1c2goa3RhS2V5LnNwbGl0KFwiLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBrdGFQYXRocztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5vcm1hbGl6ZWQgc2NvcGUga2V5IGZyb20gc2NvcGVzIGFycmF5XG4gICAqL1xuICBjcmVhdGVTY29wZUtleShzY29wZXMpIHtcbiAgICBpZiAoc2NvcGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiX19ub19zY29wZXNfX1wiO1xuICAgIHJldHVybiBbLi4uc2NvcGVzXS5zb3J0KCkuam9pbihcIixcIik7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNjb3BlIGtleSBiYWNrIHRvIHNjb3BlcyBhcnJheVxuICAgKi9cbiAgcGFyc2VTY29wZUtleShzY29wZUtleSkge1xuICAgIGlmIChzY29wZUtleSA9PT0gXCJfX25vX3Njb3Blc19fXCIpIHJldHVybiBbXTtcbiAgICByZXR1cm4gc2NvcGVLZXkuc3BsaXQoXCIsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9ybWFsaXplZCBjbGllbnQga2V5IGZyb20gY2xpZW50IGlkZW50aWZpZXJcbiAgICovXG4gIGNyZWF0ZUNsaWVudEtleShjbGllbnQpIHtcbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuIFwiX19ub19jbGllbnRfX1wiO1xuICAgIGlmICh0eXBlb2YgY2xpZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gYGFwcDoke2NsaWVudH1gO1xuICAgIH1cbiAgICBjb25zdCBjb29yZEtleSA9IGAke2NsaWVudC5jb29yZGluYXRlLmt0YS5qb2luKFwiLlwiKX07JHt0aGlzLmNyZWF0ZVNjb3BlS2V5KGNsaWVudC5jb29yZGluYXRlLnNjb3Blcyl9YDtcbiAgICByZXR1cm4gYHNlcnZpY2U6JHtjbGllbnQucmVnaXN0cnlUeXBlfToke2Nvb3JkS2V5fWA7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGNsaWVudCBrZXkgYmFjayB0byBjbGllbnQgaWRlbnRpZmllclxuICAgKi9cbiAgcGFyc2VDbGllbnRLZXkoY2xpZW50S2V5KSB7XG4gICAgaWYgKGNsaWVudEtleSA9PT0gXCJfX25vX2NsaWVudF9fXCIpIHJldHVybiBudWxsO1xuICAgIGlmIChjbGllbnRLZXkuc3RhcnRzV2l0aChcImFwcDpcIikpIHtcbiAgICAgIHJldHVybiBjbGllbnRLZXkuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50S2V5LnN0YXJ0c1dpdGgoXCJzZXJ2aWNlOlwiKSkge1xuICAgICAgY29uc3QgcGFydHMgPSBjbGllbnRLZXkuc3Vic3RyaW5nKDgpLnNwbGl0KFwiOlwiKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgcmVnaXN0cnlUeXBlID0gcGFydHNbMF07XG4gICAgICBjb25zdCBjb29yZFBhcnRzID0gcGFydHNbMV0uc3BsaXQoXCI7XCIpO1xuICAgICAgaWYgKGNvb3JkUGFydHMubGVuZ3RoICE9PSAyKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGt0YSA9IGNvb3JkUGFydHNbMF0uc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5wYXJzZVNjb3BlS2V5KGNvb3JkUGFydHNbMV0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgICBjb29yZGluYXRlOiB7IGt0YSwgc2NvcGVzIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyBzcmMvUmVnaXN0cnkudHNcbnZhciBsb2dnZXIzID0gbG9nZ2VyX2RlZmF1bHQuZ2V0KFwiUmVnaXN0cnlcIik7XG52YXIgZmluZFNjb3BlZEluc3RhbmNlID0gKHNjb3BlZEluc3RhbmNlcywgcmVxdWVzdGVkU2NvcGVzKSA9PiB7XG4gIGlmICghcmVxdWVzdGVkU2NvcGVzIHx8IHJlcXVlc3RlZFNjb3Blcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBmaXJzdEluc3RhbmNlID0gc2NvcGVkSW5zdGFuY2VzWzBdPy5pbnN0YW5jZTtcbiAgICBpZiAoIWZpcnN0SW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGluc3RhbmNlcyBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdEluc3RhbmNlO1xuICB9XG4gIGNvbnN0IG1hdGNoaW5nSW5zdGFuY2UgPSBzY29wZWRJbnN0YW5jZXMuZmluZCgoc2NvcGVkSW5zdGFuY2UpID0+IHtcbiAgICBpZiAoIXNjb3BlZEluc3RhbmNlLnNjb3BlcykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiByZXF1ZXN0ZWRTY29wZXMuZXZlcnkoXG4gICAgICAoc2NvcGUpID0+IHNjb3BlZEluc3RhbmNlLnNjb3BlcyAmJiBzY29wZWRJbnN0YW5jZS5zY29wZXMuaW5jbHVkZXMoc2NvcGUpXG4gICAgKTtcbiAgfSk7XG4gIGlmICghbWF0Y2hpbmdJbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5zdGFuY2UgZm91bmQgbWF0Y2hpbmcgc2NvcGVzOiAke3JlcXVlc3RlZFNjb3Blcy5qb2luKFwiLCBcIil9YCk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoaW5nSW5zdGFuY2UuaW5zdGFuY2U7XG59O1xudmFyIGNyZWF0ZVJlZ2lzdHJ5ID0gKHR5cGUsIHJlZ2lzdHJ5SHViKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlVHJlZSA9IHt9O1xuICBjb25zdCByZWdpc3RyeVN0YXRzID0gbmV3IFJlZ2lzdHJ5U3RhdHMoKTtcbiAgY29uc3QgY3JlYXRlUHJveGllZFJlZ2lzdHJ5ID0gKGNhbGxpbmdDb29yZGluYXRlKSA9PiB7XG4gICAgY29uc3Qgc2VydmljZUNsaWVudCA9IHtcbiAgICAgIHJlZ2lzdHJ5VHlwZTogdHlwZSxcbiAgICAgIGNvb3JkaW5hdGU6IHtcbiAgICAgICAga3RhOiBjYWxsaW5nQ29vcmRpbmF0ZS5rdGEsXG4gICAgICAgIHNjb3BlczogY2FsbGluZ0Nvb3JkaW5hdGUuc2NvcGVzXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVnaXN0cnksXG4gICAgICBnZXQ6IChrdGEsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgY2xpZW50VG9Vc2UgPSBvcHRpb25zPy5jbGllbnQgfHwgc2VydmljZUNsaWVudDtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChrdGEsIHsgLi4ub3B0aW9ucywgY2xpZW50OiBjbGllbnRUb1VzZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBjcmVhdGVJbnN0YW5jZTIgPSAoa3RhLCBzY29wZXMsIGZhY3RvcnkpID0+IHtcbiAgICBsb2dnZXIzLmRlYnVnKGBDcmVhdGluZyBhbmQgcmVnaXN0ZXJpbmcgaW5zdGFuY2UgZm9yIGtleSBwYXRoIGFuZCBzY29wZXNgLCBrdGEsIHNjb3BlcywgYGluIHJlZ2lzdHJ5IHR5cGU6ICR7dHlwZX1gKTtcbiAgICBjb25zdCBjb29yZGluYXRlID0gY3JlYXRlQ29vcmRpbmF0ZShrdGEsIHNjb3Blcyk7XG4gICAgY29uc3QgcHJveGllZFJlZ2lzdHJ5ID0gY3JlYXRlUHJveGllZFJlZ2lzdHJ5KGNvb3JkaW5hdGUpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gZmFjdG9yeShjb29yZGluYXRlLCB7XG4gICAgICByZWdpc3RyeTogcHJveGllZFJlZ2lzdHJ5LFxuICAgICAgcmVnaXN0cnlIdWJcbiAgICB9KTtcbiAgICBpZiAoIWlzSW5zdGFuY2UoaW5zdGFuY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhY3RvcnkgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBmb3I6ICR7a3RhLmpvaW4oXCIuXCIpfWApO1xuICAgIH1cbiAgICByZWdpc3RlckludGVybmFsKGt0YSwgaW5zdGFuY2UsIHsgc2NvcGVzIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXJJbnRlcm5hbCA9IChrdGEsIGluc3RhbmNlLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qga2V5UGF0aCA9IFsuLi5rdGFdLnJldmVyc2UoKTtcbiAgICBsZXQgY3VycmVudExldmVsID0gaW5zdGFuY2VUcmVlO1xuICAgIGxvZ2dlcjMuZGVidWcoYFJlZ2lzdGVyaW5nIGluc3RhbmNlIGZvciBrZXkgcGF0aCBhbmQgc2NvcGVzYCwga2V5UGF0aCwgb3B0aW9ucz8uc2NvcGVzLCBgaW4gcmVnaXN0cnkgdHlwZTogJHt0eXBlfWApO1xuICAgIGlmICghaXNJbnN0YW5jZShpbnN0YW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIG5vbi1pbnN0YW5jZTogJHtrdGEuam9pbihcIi5cIil9YCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5VHlwZSA9IGtleVBhdGhbaV07XG4gICAgICBjb25zdCBpc0xlYWYgPSBpID09PSBrZXlQYXRoLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXSkge1xuICAgICAgICBjdXJyZW50TGV2ZWxba2V5VHlwZV0gPSB7XG4gICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogaXNMZWFmID8gbnVsbCA6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5pbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGVzOiBvcHRpb25zPy5zY29wZXMsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbikge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlZ2lzdGVyID0gKGt0YSwgaW5zdGFuY2UsIG9wdGlvbnMpID0+IHtcbiAgICBsb2dnZXIzLmRlYnVnKFwiVXNpbmcgZGVwcmVjYXRlZCByZWdpc3RlciBtZXRob2QuIENvbnNpZGVyIHVzaW5nIGNyZWF0ZUluc3RhbmNlIGluc3RlYWQuXCIpO1xuICAgIHJlZ2lzdGVySW50ZXJuYWwoa3RhLCBpbnN0YW5jZSwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IGdldCA9IChrdGEsIG9wdGlvbnMpID0+IHtcbiAgICByZWdpc3RyeVN0YXRzLnJlY29yZEdldENhbGwoa3RhLCBvcHRpb25zPy5zY29wZXMsIG9wdGlvbnM/LmNsaWVudCk7XG4gICAgY29uc3Qga2V5UGF0aCA9IFsuLi5rdGFdLnJldmVyc2UoKTtcbiAgICBsZXQgY3VycmVudExldmVsID0gaW5zdGFuY2VUcmVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5VHlwZSA9IGtleVBhdGhbaV07XG4gICAgICBjb25zdCBpc0xlYWYgPSBpID09PSBrZXlQYXRoLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZCBmb3Iga2V5IHBhdGg6ICR7a3RhLmpvaW4oXCIuXCIpfSwgTWlzc2luZyBrZXk6ICR7a2V5VHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVkSW5zdGFuY2VzID0gY3VycmVudExldmVsW2tleVR5cGVdLmluc3RhbmNlcztcbiAgICAgICAgaWYgKHNjb3BlZEluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluc3RhbmNlcyByZWdpc3RlcmVkIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbihcIi5cIil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmRTY29wZWRJbnN0YW5jZShzY29wZWRJbnN0YW5jZXMsIG9wdGlvbnM/LnNjb3Blcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbFtrZXlUeXBlXS5jaGlsZHJlbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrdGEuam9pbihcIi5cIil9LCBObyBjaGlsZHJlbiBmb3I6ICR7a2V5VHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxba2V5VHlwZV0uY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCBnZXRDb29yZGluYXRlcyA9ICgpID0+IHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IFtdO1xuICAgIGNvbnN0IHRyYXZlcnNlVHJlZSA9IChub2RlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleVR5cGUgaW4gbm9kZSkge1xuICAgICAgICBjb25zdCB0cmVlTm9kZSA9IG5vZGVba2V5VHlwZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGVkSW5zdGFuY2Ugb2YgdHJlZU5vZGUuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucHVzaChzY29wZWRJbnN0YW5jZS5pbnN0YW5jZS5jb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZU5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICB0cmF2ZXJzZVRyZWUodHJlZU5vZGUuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0cmF2ZXJzZVRyZWUoaW5zdGFuY2VUcmVlKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gIH07XG4gIGNvbnN0IGdldFN0YXRpc3RpY3MgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5U3RhdHMuZ2V0U3RhdGlzdGljcygpO1xuICB9O1xuICBjb25zdCByZWdpc3RyeSA9IHtcbiAgICB0eXBlLFxuICAgIHJlZ2lzdHJ5SHViLFxuICAgIGNyZWF0ZUluc3RhbmNlOiBjcmVhdGVJbnN0YW5jZTIsXG4gICAgcmVnaXN0ZXIsXG4gICAgZ2V0LFxuICAgIGdldENvb3JkaW5hdGVzLFxuICAgIGdldFN0YXRpc3RpY3MsXG4gICAgaW5zdGFuY2VUcmVlXG4gIH07XG4gIHJldHVybiByZWdpc3RyeTtcbn07XG5cbi8vIHNyYy9lcnJvcnMvUmVnaXN0cnlFcnJvci50c1xudmFyIFJlZ2lzdHJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgcmVnaXN0cnlUeXBlO1xuICBjb250ZXh0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5yZWdpc3RyeVR5cGUgPSByZWdpc3RyeVR5cGU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCBFcnJvckNvbnN0cnVjdG9yID0gRXJyb3I7XG4gICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIEVycm9yQ29uc3RydWN0b3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICB9XG4gIGdldERldGFpbHMoKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IFt0aGlzLm1lc3NhZ2VdO1xuICAgIGlmICh0aGlzLnJlZ2lzdHJ5VHlwZSkge1xuICAgICAgZGV0YWlscy5wdXNoKGBSZWdpc3RyeSBUeXBlOiAke3RoaXMucmVnaXN0cnlUeXBlfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBkZXRhaWxzLnB1c2goYENvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jb250ZXh0LCBudWxsLCAyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFpbHMuam9pbihcIlxcblwiKTtcbiAgfVxufTtcbnZhciBSZWdpc3RyeUNyZWF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihgRmFpbGVkIHRvIGNyZWF0ZSByZWdpc3RyeSBvZiB0eXBlICcke3R5cGV9JzogJHtyZWFzb259YCwgdHlwZSwgY29udGV4dCk7XG4gIH1cbn07XG52YXIgSW52YWxpZEZhY3RvcnlSZXN1bHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgUmVnaXN0cnlFcnJvciB7XG4gIGtleVBhdGg7XG4gIGZhY3RvcnlSZXN1bHQ7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIGZhY3RvcnlSZXN1bHQsIHJlZ2lzdHJ5VHlwZSkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIHN1cGVyKFxuICAgICAgYEZhY3RvcnkgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBmb3I6ICR7a2V5UGF0aFN0cn0uIEV4cGVjdGVkIGluc3RhbmNlIHdpdGggJ2Nvb3JkaW5hdGUnIGFuZCAncmVnaXN0cnknIHByb3BlcnRpZXMsIGdvdDogJHt0eXBlb2YgZmFjdG9yeVJlc3VsdH1gLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgeyBrZXlQYXRoLCBmYWN0b3J5UmVzdWx0OiB0eXBlb2YgZmFjdG9yeVJlc3VsdCB9XG4gICAgKTtcbiAgICB0aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHRoaXMuZmFjdG9yeVJlc3VsdCA9IGZhY3RvcnlSZXN1bHQ7XG4gIH1cbn07XG52YXIgSW52YWxpZEluc3RhbmNlUmVnaXN0cmF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrZXlQYXRoO1xuICBhdHRlbXB0ZWRSZWdpc3RyYXRpb247XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIGF0dGVtcHRlZFJlZ2lzdHJhdGlvbiwgcmVnaXN0cnlUeXBlKSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIG5vbi1pbnN0YW5jZTogJHtrZXlQYXRoU3RyfS4gRXhwZWN0ZWQgaW5zdGFuY2Ugd2l0aCAnY29vcmRpbmF0ZScgYW5kICdyZWdpc3RyeScgcHJvcGVydGllcywgZ290OiAke3R5cGVvZiBhdHRlbXB0ZWRSZWdpc3RyYXRpb259YCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIHsga2V5UGF0aCwgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uOiB0eXBlb2YgYXR0ZW1wdGVkUmVnaXN0cmF0aW9uIH1cbiAgICApO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpc3RyYXRpb24gPSBhdHRlbXB0ZWRSZWdpc3RyYXRpb247XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvUmVnaXN0cnlIdWJFcnJvci50c1xudmFyIFJlZ2lzdHJ5SHViRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBodWJUeXBlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBodWJUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZW5yaWNoZWRDb250ZXh0ID0gaHViVHlwZSA/IHsgLi4uY29udGV4dCwgaHViVHlwZSB9IDogY29udGV4dDtcbiAgICBzdXBlcihtZXNzYWdlLCBcIlwiLCBlbnJpY2hlZENvbnRleHQpO1xuICAgIHRoaXMuaHViVHlwZSA9IGh1YlR5cGU7XG4gIH1cbn07XG52YXIgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5SHViRXJyb3Ige1xuICBkdXBsaWNhdGVUeXBlO1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVnaXN0cnkgYWxyZWFkeSByZWdpc3RlcmVkIHVuZGVyIHR5cGU6ICR7dHlwZX0uIEVhY2ggcmVnaXN0cnkgdHlwZSBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gYSByZWdpc3RyeSBodWIuYCxcbiAgICAgIFwiXCIsXG4gICAgICB7IC4uLmNvbnRleHQsIGR1cGxpY2F0ZVR5cGU6IHR5cGUgfVxuICAgICk7XG4gICAgdGhpcy5kdXBsaWNhdGVUeXBlID0gdHlwZTtcbiAgfVxufTtcbnZhciBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgcmVxdWVzdGVkVHlwZTtcbiAgYXZhaWxhYmxlVHlwZXM7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3RlZFR5cGUsIGF2YWlsYWJsZVR5cGVzID0gW10sIGNvbnRleHQpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBObyByZWdpc3RyeSByZWdpc3RlcmVkIHVuZGVyIHR5cGU6ICR7cmVxdWVzdGVkVHlwZX1gO1xuICAgIGlmIChhdmFpbGFibGVUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlICs9IGAuIEF2YWlsYWJsZSB0eXBlczogWyR7YXZhaWxhYmxlVHlwZXMuam9pbihcIiwgXCIpfV1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBcIlwiLCB7IC4uLmNvbnRleHQsIHJlcXVlc3RlZFR5cGUsIGF2YWlsYWJsZVR5cGVzIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkVHlwZSA9IHJlcXVlc3RlZFR5cGU7XG4gICAgdGhpcy5hdmFpbGFibGVUeXBlcyA9IGF2YWlsYWJsZVR5cGVzO1xuICB9XG59O1xudmFyIFJlZ2lzdHJ5RmFjdG9yeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgZmFjdG9yeUVycm9yO1xuICBhdHRlbXB0ZWRUeXBlO1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBmYWN0b3J5RXJyb3IsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZWdpc3RyeSBmYWN0b3J5IGZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cnkgb2YgdHlwZSAnJHt0eXBlfSc6ICR7ZmFjdG9yeUVycm9yLm1lc3NhZ2V9YCxcbiAgICAgIFwiXCIsXG4gICAgICB7IC4uLmNvbnRleHQsIGF0dGVtcHRlZFR5cGU6IHR5cGUsIG9yaWdpbmFsRXJyb3I6IGZhY3RvcnlFcnJvci5tZXNzYWdlIH1cbiAgICApO1xuICAgIHRoaXMuZmFjdG9yeUVycm9yID0gZmFjdG9yeUVycm9yO1xuICAgIHRoaXMuYXR0ZW1wdGVkVHlwZSA9IHR5cGU7XG4gIH1cbn07XG52YXIgSW52YWxpZFJlZ2lzdHJ5RmFjdG9yeVJlc3VsdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUh1YkVycm9yIHtcbiAgZmFjdG9yeVJlc3VsdDtcbiAgYXR0ZW1wdGVkVHlwZTtcbiAgY29uc3RydWN0b3IodHlwZSwgZmFjdG9yeVJlc3VsdCwgY29udGV4dCkge1xuICAgIHN1cGVyKFxuICAgICAgYFJlZ2lzdHJ5IGZhY3RvcnkgcmV0dXJuZWQgaW52YWxpZCByZWdpc3RyeSBmb3IgdHlwZSAnJHt0eXBlfScuIEV4cGVjdGVkIHJlZ2lzdHJ5IHdpdGggJ3R5cGUnLCAnZ2V0JywgJ3JlZ2lzdGVyJywgYW5kICdjcmVhdGVJbnN0YW5jZScgcHJvcGVydGllcywgZ290OiAke3R5cGVvZiBmYWN0b3J5UmVzdWx0fWAsXG4gICAgICBcIlwiLFxuICAgICAgeyAuLi5jb250ZXh0LCBhdHRlbXB0ZWRUeXBlOiB0eXBlLCBmYWN0b3J5UmVzdWx0OiB0eXBlb2YgZmFjdG9yeVJlc3VsdCB9XG4gICAgKTtcbiAgICB0aGlzLmZhY3RvcnlSZXN1bHQgPSBmYWN0b3J5UmVzdWx0O1xuICAgIHRoaXMuYXR0ZW1wdGVkVHlwZSA9IHR5cGU7XG4gIH1cbn07XG5cbi8vIHNyYy9SZWdpc3RyeUh1Yi50c1xudmFyIGxvZ2dlcjQgPSBsb2dnZXJfZGVmYXVsdC5nZXQoXCJSZWdpc3RyeUh1YlwiKTtcbnZhciBjcmVhdGVSZWdpc3RyeUh1YiA9ICgpID0+IHtcbiAgY29uc3QgcmVnaXN0cmllcyA9IHt9O1xuICBjb25zdCBjcmVhdGVSZWdpc3RyeTIgPSAodHlwZSwgZmFjdG9yeSkgPT4ge1xuICAgIGxvZ2dlcjQuZGVidWcoYENyZWF0aW5nIG5ldyByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IER1cGxpY2F0ZVJlZ2lzdHJ5VHlwZUVycm9yKHR5cGUpO1xuICAgIH1cbiAgICBjb25zdCByZWdpc3RyeSA9IGZhY3RvcnkodHlwZSwgaHViKTtcbiAgICBpZiAoIShcInJlZ2lzdHJ5SHViXCIgaW4gcmVnaXN0cnkpIHx8IHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViICE9PSBodWIpIHtcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViID0gaHViO1xuICAgIH1cbiAgICByZWdpc3RyaWVzW3R5cGVdID0gcmVnaXN0cnk7XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYW5kIHJlZ2lzdGVyZWQgbmV3IHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICAgIHJldHVybiByZWdpc3RyeTtcbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXJSZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSByZWdpc3RyeS50eXBlO1xuICAgIGxvZ2dlcjQuZGVidWcoYFJlZ2lzdGVyaW5nIHJlZ2lzdHJ5IHdpdGggdHlwZTogJHt0eXBlfWApO1xuICAgIGlmIChyZWdpc3RyaWVzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlUmVnaXN0cnlUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIHJlZ2lzdHJpZXNbdHlwZV0gPSByZWdpc3RyeTtcbiAgICBpZiAoIShcInJlZ2lzdHJ5SHViXCIgaW4gcmVnaXN0cnkpIHx8IHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViICE9PSBodWIpIHtcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdHJ5SHViID0gaHViO1xuICAgIH1cbiAgICBsb2dnZXI0LmRlYnVnKGBTdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCByZWdpc3RyeSB3aXRoIHR5cGU6ICR7dHlwZX1gKTtcbiAgfTtcbiAgY29uc3QgZ2V0ID0gKHR5cGUsIGt0YSwgb3B0aW9ucykgPT4ge1xuICAgIGxvZ2dlcjQuZGVidWcoYExvb2tpbmcgdXAgaW5zdGFuY2UgZm9yIHR5cGU6ICR7dHlwZX0sIGt0YTogJHtrdGEuam9pbihcIi5cIil9LCBzY29wZXM6ICR7b3B0aW9ucz8uc2NvcGVzPy5qb2luKFwiLFwiKSB8fCBcIm5vbmVcIn1gKTtcbiAgICBjb25zdCByZWdpc3RyeSA9IHJlZ2lzdHJpZXNbdHlwZV07XG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgY29uc3QgYXZhaWxhYmxlVHlwZXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyaWVzKTtcbiAgICAgIHRocm93IG5ldyBSZWdpc3RyeVR5cGVOb3RGb3VuZEVycm9yKHR5cGUsIGF2YWlsYWJsZVR5cGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChrdGEsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBnZXRSZWdpc3RyeSA9ICh0eXBlKSA9PiB7XG4gICAgcmV0dXJuIHJlZ2lzdHJpZXNbdHlwZV0gfHwgbnVsbDtcbiAgfTtcbiAgY29uc3QgZ2V0UmVnaXN0ZXJlZFR5cGVzID0gKCkgPT4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyaWVzKTtcbiAgfTtcbiAgY29uc3QgdW5yZWdpc3RlclJlZ2lzdHJ5ID0gKHR5cGUpID0+IHtcbiAgICBpZiAocmVnaXN0cmllc1t0eXBlXSkge1xuICAgICAgZGVsZXRlIHJlZ2lzdHJpZXNbdHlwZV07XG4gICAgICBsb2dnZXI0LmRlYnVnKGBVbnJlZ2lzdGVyZWQgcmVnaXN0cnkgdW5kZXIgdHlwZTogJHt0eXBlfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgY29uc3QgZ2V0QWxsQ29vcmRpbmF0ZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgYWxsQ29vcmRpbmF0ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlZ2lzdHJ5VHlwZSBpbiByZWdpc3RyaWVzKSB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IHJlZ2lzdHJpZXNbcmVnaXN0cnlUeXBlXTtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcmVnaXN0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2goKGNvb3JkaW5hdGUpID0+IHtcbiAgICAgICAgYWxsQ29vcmRpbmF0ZXMucHVzaCh7XG4gICAgICAgICAgY29vcmRpbmF0ZSxcbiAgICAgICAgICByZWdpc3RyeVR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbG9nZ2VyNC5kZWJ1ZyhgUmV0cmlldmVkICR7YWxsQ29vcmRpbmF0ZXMubGVuZ3RofSB0b3RhbCBjb29yZGluYXRlcyBmcm9tICR7T2JqZWN0LmtleXMocmVnaXN0cmllcykubGVuZ3RofSByZWdpc3RyaWVzYCk7XG4gICAgcmV0dXJuIGFsbENvb3JkaW5hdGVzO1xuICB9O1xuICBjb25zdCBodWIgPSB7XG4gICAgY3JlYXRlUmVnaXN0cnk6IGNyZWF0ZVJlZ2lzdHJ5MixcbiAgICByZWdpc3RlclJlZ2lzdHJ5LFxuICAgIGdldCxcbiAgICBnZXRSZWdpc3RyeSxcbiAgICBnZXRSZWdpc3RlcmVkVHlwZXMsXG4gICAgZ2V0QWxsQ29vcmRpbmF0ZXMsXG4gICAgdW5yZWdpc3RlclJlZ2lzdHJ5XG4gIH07XG4gIHJldHVybiBodWI7XG59O1xuXG4vLyBzcmMvZXJyb3JzL0luc3RhbmNlRXJyb3IudHNcbnZhciBJbnN0YW5jZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeUVycm9yIHtcbiAga2V5UGF0aDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwga2V5UGF0aCwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIobWVzc2FnZSwgcmVnaXN0cnlUeXBlLCB7IC4uLmNvbnRleHQsIGtleVBhdGggfSk7XG4gICAgdGhpcy5rZXlQYXRoID0ga2V5UGF0aDtcbiAgfVxufTtcbnZhciBJbnN0YW5jZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBtaXNzaW5nS2V5O1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCBtaXNzaW5nS2V5LCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnN0YW5jZSBub3QgZm91bmQgZm9yIGtleSBwYXRoOiAke2tleVBhdGhTdHJ9YDtcbiAgICBpZiAobWlzc2luZ0tleSkge1xuICAgICAgbWVzc2FnZSArPSBgLCBNaXNzaW5nIGtleTogJHttaXNzaW5nS2V5fWA7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgeyAuLi5jb250ZXh0LCBtaXNzaW5nS2V5IH0pO1xuICAgIHRoaXMubWlzc2luZ0tleSA9IG1pc3NpbmdLZXk7XG4gIH1cbn07XG52YXIgTm9JbnN0YW5jZXNSZWdpc3RlcmVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBObyBpbnN0YW5jZXMgcmVnaXN0ZXJlZCBmb3Iga2V5IHBhdGg6ICR7a2V5UGF0aFN0cn0uIFRoZSBrZXkgcGF0aCBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5IHRyZWUgYnV0IGNvbnRhaW5zIG5vIGluc3RhbmNlcy5gLFxuICAgICAga2V5UGF0aCxcbiAgICAgIHJlZ2lzdHJ5VHlwZSxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG59O1xudmFyIE5vSW5zdGFuY2VzQXZhaWxhYmxlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihrZXlQYXRoLCByZWdpc3RyeVR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBrZXlQYXRoU3RyID0ga2V5UGF0aC5qb2luKFwiLlwiKTtcbiAgICBzdXBlcihcbiAgICAgIGBObyBpbnN0YW5jZXMgYXZhaWxhYmxlIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfS4gVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIGFuIGludGVybmFsIHJlZ2lzdHJ5IHN0YXRlIGlzc3VlLmAsXG4gICAgICBrZXlQYXRoLFxuICAgICAgcmVnaXN0cnlUeXBlLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbn07XG52YXIgU2NvcGVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBJbnN0YW5jZUVycm9yIHtcbiAgcmVxdWVzdGVkU2NvcGVzO1xuICBhdmFpbGFibGVTY29wZXM7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHJlcXVlc3RlZFNjb3BlcywgYXZhaWxhYmxlU2NvcGVzID0gW10sIHJlZ2lzdHJ5VHlwZSkge1xuICAgIGNvbnN0IGtleVBhdGhTdHIgPSBrZXlQYXRoLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IHNjb3Blc1N0ciA9IHJlcXVlc3RlZFNjb3Blcy5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgYXZhaWxhYmxlU2NvcGVzU3RyID0gYXZhaWxhYmxlU2NvcGVzLm1hcCgoc2NvcGVzKSA9PiBgWyR7c2NvcGVzLmpvaW4oXCIsIFwiKX1dYCkuam9pbihcIiwgXCIpO1xuICAgIGxldCBtZXNzYWdlID0gYE5vIGluc3RhbmNlIGZvdW5kIG1hdGNoaW5nIHNjb3BlczogJHtzY29wZXNTdHJ9IGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfWA7XG4gICAgaWYgKGF2YWlsYWJsZVNjb3Blcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlICs9IGAuIEF2YWlsYWJsZSBzY29wZXM6ICR7YXZhaWxhYmxlU2NvcGVzU3RyfWA7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIGtleVBhdGgsIHJlZ2lzdHJ5VHlwZSwgeyByZXF1ZXN0ZWRTY29wZXMsIGF2YWlsYWJsZVNjb3BlcyB9KTtcbiAgICB0aGlzLnJlcXVlc3RlZFNjb3BlcyA9IHJlcXVlc3RlZFNjb3BlcztcbiAgICB0aGlzLmF2YWlsYWJsZVNjb3BlcyA9IGF2YWlsYWJsZVNjb3BlcztcbiAgfVxufTtcbnZhciBOb0NoaWxkcmVuQXZhaWxhYmxlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEluc3RhbmNlRXJyb3Ige1xuICBwYXJlbnRLZXk7XG4gIGNvbnN0cnVjdG9yKGtleVBhdGgsIHBhcmVudEtleSwgcmVnaXN0cnlUeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5UGF0aFN0ciA9IGtleVBhdGguam9pbihcIi5cIik7XG4gICAgc3VwZXIoXG4gICAgICBgSW5zdGFuY2Ugbm90IGZvdW5kIGZvciBrZXkgcGF0aDogJHtrZXlQYXRoU3RyfSwgTm8gY2hpbGRyZW4gZm9yOiAke3BhcmVudEtleX0uIFRoZSBwYXRoIGNhbm5vdCBiZSB0cmF2ZXJzZWQgZnVydGhlciBhcyAnJHtwYXJlbnRLZXl9JyBoYXMgbm8gY2hpbGQgbm9kZXMuYCxcbiAgICAgIGtleVBhdGgsXG4gICAgICByZWdpc3RyeVR5cGUsXG4gICAgICB7IC4uLmNvbnRleHQsIHBhcmVudEtleSB9XG4gICAgKTtcbiAgICB0aGlzLnBhcmVudEtleSA9IHBhcmVudEtleTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9Db29yZGluYXRlRXJyb3IudHNcbnZhciBDb29yZGluYXRlRXJyb3IgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5RXJyb3Ige1xuICBrdGE7XG4gIHNjb3BlcztcbiAgY29uc3RydWN0b3IobWVzc2FnZSwga3RhLCBzY29wZXMsIGNvbnRleHQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBcIlwiLCB7IC4uLmNvbnRleHQsIGt0YSwgc2NvcGVzIH0pO1xuICAgIHRoaXMua3RhID0ga3RhO1xuICAgIHRoaXMuc2NvcGVzID0gc2NvcGVzO1xuICB9XG59O1xudmFyIEludmFsaWRDb29yZGluYXRlRXJyb3IgPSBjbGFzcyBleHRlbmRzIENvb3JkaW5hdGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGt0YSwgc2NvcGVzLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhbGlkIGNvb3JkaW5hdGUgcGFyYW1ldGVyczogJHtyZWFzb259LiBLVEE6ICR7SlNPTi5zdHJpbmdpZnkoa3RhKX0sIFNjb3BlczogWyR7c2NvcGVzLmpvaW4oXCIsIFwiKX1dYCxcbiAgICAgIGt0YSxcbiAgICAgIHNjb3BlcyxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVhc29uIH1cbiAgICApO1xuICB9XG59O1xudmFyIEludmFsaWRLVEFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ29vcmRpbmF0ZUVycm9yIHtcbiAgY29uc3RydWN0b3Ioa3RhLCByZWFzb24sIGNvbnRleHQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhbGlkIEtUQSAoS2V5IFR5cGUgQXJyYXkpOiAke3JlYXNvbn0uIEV4cGVjdGVkIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoa3RhKX1gLFxuICAgICAga3RhLFxuICAgICAgW10sXG4gICAgICB7IC4uLmNvbnRleHQsIHJlYXNvbiB9XG4gICAgKTtcbiAgfVxufTtcbnZhciBJbnZhbGlkU2NvcGVzRXJyb3IgPSBjbGFzcyBleHRlbmRzIENvb3JkaW5hdGVFcnJvciB7XG4gIGludmFsaWRTY29wZXM7XG4gIGNvbnN0cnVjdG9yKHNjb3BlcywgaW52YWxpZFNjb3BlcywgcmVhc29uLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBzY29wZXM6ICR7cmVhc29ufS4gSW52YWxpZCBzY29wZSB2YWx1ZXM6ICR7SlNPTi5zdHJpbmdpZnkoaW52YWxpZFNjb3Blcyl9YCxcbiAgICAgIG51bGwsXG4gICAgICBzY29wZXMuZmlsdGVyKChzKSA9PiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiksXG4gICAgICB7IC4uLmNvbnRleHQsIHJlYXNvbiwgaW52YWxpZFNjb3BlcyB9XG4gICAgKTtcbiAgICB0aGlzLmludmFsaWRTY29wZXMgPSBpbnZhbGlkU2NvcGVzO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQ29vcmRpbmF0ZUVycm9yLFxuICBEdXBsaWNhdGVSZWdpc3RyeVR5cGVFcnJvcixcbiAgSW5zdGFuY2VFcnJvcixcbiAgSW5zdGFuY2VOb3RGb3VuZEVycm9yLFxuICBJbnZhbGlkQ29vcmRpbmF0ZUVycm9yLFxuICBJbnZhbGlkRmFjdG9yeVJlc3VsdEVycm9yLFxuICBJbnZhbGlkSW5zdGFuY2VSZWdpc3RyYXRpb25FcnJvcixcbiAgSW52YWxpZEtUQUVycm9yLFxuICBJbnZhbGlkUmVnaXN0cnlGYWN0b3J5UmVzdWx0RXJyb3IsXG4gIEludmFsaWRTY29wZXNFcnJvcixcbiAgTm9DaGlsZHJlbkF2YWlsYWJsZUVycm9yLFxuICBOb0luc3RhbmNlc0F2YWlsYWJsZUVycm9yLFxuICBOb0luc3RhbmNlc1JlZ2lzdGVyZWRFcnJvcixcbiAgUmVnaXN0cnlDcmVhdGlvbkVycm9yLFxuICBSZWdpc3RyeUVycm9yLFxuICBSZWdpc3RyeUZhY3RvcnlFcnJvcixcbiAgUmVnaXN0cnlIdWJFcnJvcixcbiAgUmVnaXN0cnlTdGF0cyxcbiAgUmVnaXN0cnlUeXBlTm90Rm91bmRFcnJvcixcbiAgU2NvcGVOb3RGb3VuZEVycm9yLFxuICBjcmVhdGVDb29yZGluYXRlLFxuICBjcmVhdGVJbnN0YW5jZSxcbiAgY3JlYXRlUmVnaXN0cnksXG4gIGNyZWF0ZVJlZ2lzdHJ5SHViLFxuICBpc0luc3RhbmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/@fjell/registry/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/deepmerge/dist/cjs.js":
/*!*************************************************************!*\
  !*** ../fjell-providers/node_modules/deepmerge/dist/cjs.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/deepmerge/dist/cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/fast-safe-stringify/index.js":
/*!********************************************************************!*\
  !*** ../fjell-providers/node_modules/fast-safe-stringify/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeVxuc3RyaW5naWZ5LmRlZmF1bHQgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5zdGFibGUgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlU3RyaW5naWZ5ID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuXG52YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gJ1suLi5dJ1xudmFyIENJUkNVTEFSX1JFUExBQ0VfTk9ERSA9ICdbQ2lyY3VsYXJdJ1xuXG52YXIgYXJyID0gW11cbnZhciByZXBsYWNlclN0YWNrID0gW11cblxuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMgKCkge1xuICByZXR1cm4ge1xuICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH1cbn1cblxuLy8gUmVndWxhciBzdHJpbmdpZnlcbmZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKVxuICB9XG5cbiAgZGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpXG4gIHZhciByZXNcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKVxuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpXG4gIH0gZmluYWxseSB7XG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHNldFJlcGxhY2UgKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgaylcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pXG4gICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2tdID0gcmVwbGFjZVxuICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbiAoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpIHx8IG9ialxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc3RvcmUgdGhlIG9iamVjdCBhcyBpdCB3YXMuXG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmMgKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICBkZXB0aCArPSAxXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWwpXG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgdmFyIHRtcCA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcbiAgICAgICAgcGFyZW50W2tdID0gdG1wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG1wXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cbn1cblxuLy8gd3JhcHMgcmVwbGFjZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHZhbHVlcyB3ZSBjb3VsZG4ndCByZXBsYWNlXG4vLyBhbmQgbWFyayB0aGVtIGFzIHJlcGxhY2VkIHZhbHVlXG5mdW5jdGlvbiByZXBsYWNlR2V0dGVyVmFsdWVzIChyZXBsYWNlcikge1xuICByZXBsYWNlciA9XG4gICAgdHlwZW9mIHJlcGxhY2VyICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyByZXBsYWNlclxuICAgICAgOiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICByZXR1cm4gdlxuICAgICAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXVxuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnRbMl1cbiAgICAgICAgICByZXBsYWNlclN0YWNrLnNwbGljZShpLCAxKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/fast-safe-stringify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js":
/*!*************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/datetime.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DateTime),\n/* harmony export */   friendlyDateTime: () => (/* binding */ friendlyDateTime)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/info.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_diff_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./impl/diff.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/diff.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./impl/tokenParser.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/tokenParser.js\");\n/* harmony import */ var _impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./impl/conversions.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/conversions.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/invalid.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid DateTime\";\nconst MAX_DATE = 8.64e15;\n\nfunction unsupportedZone(zone) {\n  return new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unsupported zone\", `the zone \"${zone.name}\" is not supported`);\n}\n\n// we cache week data on the DT object and this intermediates the cache\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedWeekData(dt) {\n  if (dt.weekData === null) {\n    dt.weekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(dt.c);\n  }\n  return dt.weekData;\n}\n\n/**\n * @param {DateTime} dt\n */\nfunction possiblyCachedLocalWeekData(dt) {\n  if (dt.localWeekData === null) {\n    dt.localWeekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(\n      dt.c,\n      dt.loc.getMinDaysInFirstWeek(),\n      dt.loc.getStartOfWeek()\n    );\n  }\n  return dt.localWeekData;\n}\n\n// clone really means, \"make a new object with these modifications\". all \"setters\" really use this\n// to create a new object while only changing some of the properties\nfunction clone(inst, alts) {\n  const current = {\n    ts: inst.ts,\n    zone: inst.zone,\n    c: inst.c,\n    o: inst.o,\n    loc: inst.loc,\n    invalid: inst.invalid,\n  };\n  return new DateTime({ ...current, ...alts, old: current });\n}\n\n// find the right offset a given local time. The o input is our guess, which determines which\n// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)\nfunction fixOffset(localTS, o, tz) {\n  // Our UTC time is just a guess because our offset is just a guess\n  let utcGuess = localTS - o * 60 * 1000;\n\n  // Test whether the zone matches the offset for this ts\n  const o2 = tz.offset(utcGuess);\n\n  // If so, offset didn't change and we're done\n  if (o === o2) {\n    return [utcGuess, o];\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= (o2 - o) * 60 * 1000;\n\n  // If that gives us the local time we want, we're done\n  const o3 = tz.offset(utcGuess);\n  if (o2 === o3) {\n    return [utcGuess, o2];\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];\n}\n\n// convert an epoch timestamp into a calendar object with the given offset\nfunction tsToObj(ts, offset) {\n  ts += offset * 60 * 1000;\n\n  const d = new Date(ts);\n\n  return {\n    year: d.getUTCFullYear(),\n    month: d.getUTCMonth() + 1,\n    day: d.getUTCDate(),\n    hour: d.getUTCHours(),\n    minute: d.getUTCMinutes(),\n    second: d.getUTCSeconds(),\n    millisecond: d.getUTCMilliseconds(),\n  };\n}\n\n// convert a calendar object to a epoch timestamp\nfunction objToTS(obj, offset, zone) {\n  return fixOffset((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(obj), offset, zone);\n}\n\n// create a new DT instance by adding a duration, adjusting for DSTs\nfunction adjustTime(inst, dur) {\n  const oPre = inst.o,\n    year = inst.c.year + Math.trunc(dur.years),\n    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,\n    c = {\n      ...inst.c,\n      year,\n      month,\n      day:\n        Math.min(inst.c.day, (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(year, month)) +\n        Math.trunc(dur.days) +\n        Math.trunc(dur.weeks) * 7,\n    },\n    millisToAdd = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject({\n      years: dur.years - Math.trunc(dur.years),\n      quarters: dur.quarters - Math.trunc(dur.quarters),\n      months: dur.months - Math.trunc(dur.months),\n      weeks: dur.weeks - Math.trunc(dur.weeks),\n      days: dur.days - Math.trunc(dur.days),\n      hours: dur.hours,\n      minutes: dur.minutes,\n      seconds: dur.seconds,\n      milliseconds: dur.milliseconds,\n    }).as(\"milliseconds\"),\n    localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(c);\n\n  let [ts, o] = fixOffset(localTS, oPre, inst.zone);\n\n  if (millisToAdd !== 0) {\n    ts += millisToAdd;\n    // that could have changed the offset by going over a DST, but we want to keep the ts the same\n    o = inst.zone.offset(ts);\n  }\n\n  return { ts, o };\n}\n\n// helper useful in turning the results of parsing into real dates\n// by handling the zone options\nfunction parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {\n  const { setZone, zone } = opts;\n  if ((parsed && Object.keys(parsed).length !== 0) || parsedZone) {\n    const interpretationZone = parsedZone || zone,\n      inst = DateTime.fromObject(parsed, {\n        ...opts,\n        zone: interpretationZone,\n        specificOffset,\n      });\n    return setZone ? inst : inst.setZone(zone);\n  } else {\n    return DateTime.invalid(\n      new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"unparsable\", `the input \"${text}\" can't be parsed as ${format}`)\n    );\n  }\n}\n\n// if you want to output a technical format (e.g. RFC 2822), this helper\n// helps handle the details\nfunction toTechFormat(dt, format, allowZ = true) {\n  return dt.isValid\n    ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(_impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create(\"en-US\"), {\n        allowZ,\n        forceSimple: true,\n      }).formatDateTimeFromString(dt, format)\n    : null;\n}\n\nfunction toISODate(o, extended, precision) {\n  const longFormat = o.c.year > 9999 || o.c.year < 0;\n  let c = \"\";\n  if (longFormat && o.c.year >= 0) c += \"+\";\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.year, longFormat ? 6 : 4);\n  if (precision === \"year\") return c;\n  if (extended) {\n    c += \"-\";\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n    c += \"-\";\n  } else {\n    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);\n    if (precision === \"month\") return c;\n  }\n  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.day);\n  return c;\n}\n\nfunction toISOTime(\n  o,\n  extended,\n  suppressSeconds,\n  suppressMilliseconds,\n  includeOffset,\n  extendedZone,\n  precision\n) {\n  let showSeconds = !suppressSeconds || o.c.millisecond !== 0 || o.c.second !== 0,\n    c = \"\";\n  switch (precision) {\n    case \"day\":\n    case \"month\":\n    case \"year\":\n      break;\n    default:\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.hour);\n      if (precision === \"hour\") break;\n      if (extended) {\n        c += \":\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += \":\";\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      } else {\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);\n        if (precision === \"minute\") break;\n        if (showSeconds) {\n          c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);\n        }\n      }\n      if (precision === \"second\") break;\n      if (showSeconds && (!suppressMilliseconds || o.c.millisecond !== 0)) {\n        c += \".\";\n        c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.millisecond, 3);\n      }\n  }\n\n  if (includeOffset) {\n    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {\n      c += \"Z\";\n    } else if (o.o < 0) {\n      c += \"-\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o % 60));\n    } else {\n      c += \"+\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o / 60));\n      c += \":\";\n      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o % 60));\n    }\n  }\n\n  if (extendedZone) {\n    c += \"[\" + o.zone.ianaName + \"]\";\n  }\n  return c;\n}\n\n// defaults for unspecified units in the supported calendars\nconst defaultUnitValues = {\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultWeekUnitValues = {\n    weekNumber: 1,\n    weekday: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  defaultOrdinalUnitValues = {\n    ordinal: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  };\n\n// Units in the supported calendars, sorted by bigness\nconst orderedUnits = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"],\n  orderedWeekUnits = [\n    \"weekYear\",\n    \"weekNumber\",\n    \"weekday\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\",\n  ],\n  orderedOrdinalUnits = [\"year\", \"ordinal\", \"hour\", \"minute\", \"second\", \"millisecond\"];\n\n// standardize case and plurality in units\nfunction normalizeUnit(unit) {\n  const normalized = {\n    year: \"year\",\n    years: \"year\",\n    month: \"month\",\n    months: \"month\",\n    day: \"day\",\n    days: \"day\",\n    hour: \"hour\",\n    hours: \"hour\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    second: \"second\",\n    seconds: \"second\",\n    millisecond: \"millisecond\",\n    milliseconds: \"millisecond\",\n    weekday: \"weekday\",\n    weekdays: \"weekday\",\n    weeknumber: \"weekNumber\",\n    weeksnumber: \"weekNumber\",\n    weeknumbers: \"weekNumber\",\n    weekyear: \"weekYear\",\n    weekyears: \"weekYear\",\n    ordinal: \"ordinal\",\n  }[unit.toLowerCase()];\n\n  if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidUnitError(unit);\n\n  return normalized;\n}\n\nfunction normalizeUnitWithLocalWeeks(unit) {\n  switch (unit.toLowerCase()) {\n    case \"localweekday\":\n    case \"localweekdays\":\n      return \"localWeekday\";\n    case \"localweeknumber\":\n    case \"localweeknumbers\":\n      return \"localWeekNumber\";\n    case \"localweekyear\":\n    case \"localweekyears\":\n      return \"localWeekYear\";\n    default:\n      return normalizeUnit(unit);\n  }\n}\n\n// cache offsets for zones based on the current timestamp when this function is\n// first called. When we are handling a datetime from components like (year,\n// month, day, hour) in a time zone, we need a guess about what the timezone\n// offset is so that we can convert into a UTC timestamp. One way is to find the\n// offset of now in the zone. The actual date may have a different offset (for\n// example, if we handle a date in June while we're in December in a zone that\n// observes DST), but we can check and adjust that.\n//\n// When handling many dates, calculating the offset for now every time is\n// expensive. It's just a guess, so we can cache the offset to use even if we\n// are right on a time change boundary (we'll just correct in the other\n// direction). Using a timestamp from first read is a slight optimization for\n// handling dates close to the current date, since those dates will usually be\n// in the same offset (we could set the timestamp statically, instead). We use a\n// single timestamp for all zones to make things a bit more predictable.\n//\n// This is safe for quickDT (used by local() and utc()) because we don't fill in\n// higher-order units from tsNow (as we do in fromObject, this requires that\n// offset is calculated from tsNow).\n/**\n * @param {Zone} zone\n * @return {number}\n */\nfunction guessOffsetForZone(zone) {\n  if (zoneOffsetTs === undefined) {\n    zoneOffsetTs = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  // Do not cache anything but IANA zones, because it is not safe to do so.\n  // Guessing an offset which is not present in the zone can cause wrong results from fixOffset\n  if (zone.type !== \"iana\") {\n    return zone.offset(zoneOffsetTs);\n  }\n  const zoneName = zone.name;\n  let offsetGuess = zoneOffsetGuessCache.get(zoneName);\n  if (offsetGuess === undefined) {\n    offsetGuess = zone.offset(zoneOffsetTs);\n    zoneOffsetGuessCache.set(zoneName, offsetGuess);\n  }\n  return offsetGuess;\n}\n\n// this is a dumbed down version of fromObject() that runs about 60% faster\n// but doesn't do any validation, makes a bunch of assumptions about what units\n// are present, and so on.\nfunction quickDT(obj, opts) {\n  const zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  if (!zone.isValid) {\n    return DateTime.invalid(unsupportedZone(zone));\n  }\n\n  const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n\n  let ts, o;\n\n  // assume we have the higher-order units\n  if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj.year)) {\n    for (const u of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj[u])) {\n        obj[u] = defaultUnitValues[u];\n      }\n    }\n\n    const invalid = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(obj) || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(obj);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    const offsetProvis = guessOffsetForZone(zone);\n    [ts, o] = objToTS(obj, offsetProvis, zone);\n  } else {\n    ts = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now();\n  }\n\n  return new DateTime({ ts, zone, loc, o });\n}\n\nfunction diffRelative(start, end, opts) {\n  const round = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.round) ? true : opts.round,\n    rounding = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.rounding) ? \"trunc\" : opts.rounding,\n    format = (c, unit) => {\n      c = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.roundTo)(c, round || opts.calendary ? 0 : 2, opts.calendary ? \"round\" : rounding);\n      const formatter = end.loc.clone(opts).relFormatter(opts);\n      return formatter.format(c, unit);\n    },\n    differ = (unit) => {\n      if (opts.calendary) {\n        if (!end.hasSame(start, unit)) {\n          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);\n        } else return 0;\n      } else {\n        return end.diff(start, unit).get(unit);\n      }\n    };\n\n  if (opts.unit) {\n    return format(differ(opts.unit), opts.unit);\n  }\n\n  for (const unit of opts.units) {\n    const count = differ(unit);\n    if (Math.abs(count) >= 1) {\n      return format(count, unit);\n    }\n  }\n  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);\n}\n\nfunction lastOpts(argList) {\n  let opts = {},\n    args;\n  if (argList.length > 0 && typeof argList[argList.length - 1] === \"object\") {\n    opts = argList[argList.length - 1];\n    args = Array.from(argList).slice(0, argList.length - 1);\n  } else {\n    args = Array.from(argList);\n  }\n  return [opts, args];\n}\n\n/**\n * Timestamp to use for cached zone offset guesses (exposed for test)\n */\nlet zoneOffsetTs;\n/**\n * Cache for zone offset guesses (exposed for test).\n *\n * This optimizes quickDT via guessOffsetForZone to avoid repeated calls of\n * zone.offset().\n */\nconst zoneOffsetGuessCache = new Map();\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},\n * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.\n * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nclass DateTime {\n  /**\n   * @access private\n   */\n  constructor(config) {\n    const zone = config.zone || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone;\n\n    let invalid =\n      config.invalid ||\n      (Number.isNaN(config.ts) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null) ||\n      (!zone.isValid ? unsupportedZone(zone) : null);\n    /**\n     * @access private\n     */\n    this.ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(config.ts) ? _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now() : config.ts;\n\n    let c = null,\n      o = null;\n    if (!invalid) {\n      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);\n\n      if (unchanged) {\n        [c, o] = [config.old.c, config.old.o];\n      } else {\n        // If an offset has been passed and we have not been called from\n        // clone(), we can trust it and avoid the offset calculation.\n        const ot = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(config.o) && !config.old ? config.o : zone.offset(this.ts);\n        c = tsToObj(this.ts, ot);\n        invalid = Number.isNaN(c.year) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](\"invalid input\") : null;\n        c = invalid ? null : c;\n        o = invalid ? null : ot;\n      }\n    }\n\n    /**\n     * @access private\n     */\n    this._zone = zone;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.invalid = invalid;\n    /**\n     * @access private\n     */\n    this.weekData = null;\n    /**\n     * @access private\n     */\n    this.localWeekData = null;\n    /**\n     * @access private\n     */\n    this.c = c;\n    /**\n     * @access private\n     */\n    this.o = o;\n    /**\n     * @access private\n     */\n    this.isLuxonDateTime = true;\n  }\n\n  // CONSTRUCT\n\n  /**\n   * Create a DateTime for the current instant, in the system's time zone.\n   *\n   * Use Settings to override these default values if needed.\n   * @example DateTime.now().toISO() //~> now in the ISO format\n   * @return {DateTime}\n   */\n  static now() {\n    return new DateTime({});\n  }\n\n  /**\n   * Create a local DateTime\n   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month, 1-indexed\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @example DateTime.local()                                  //~> now\n   * @example DateTime.local({ zone: \"America/New_York\" })      //~> now, in US east coast time\n   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00\n   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00\n   * @example DateTime.local(2017, 3, 12, { locale: \"fr\" })     //~> 2017-03-12T00:00:00, with a French locale\n   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00\n   * @example DateTime.local(2017, 3, 12, 5, { zone: \"utc\" })   //~> 2017-03-12T05:00:00, in UTC\n   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765\n   * @return {DateTime}\n   */\n  static local() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime in UTC\n   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n   * @param {number} [month=1] - The month, 1-indexed\n   * @param {number} [day=1] - The day of the month\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\n   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59\n   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59\n   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.utc()                                              //~> now\n   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z\n   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: \"fr\" })          //~> 2017-03-12T05:45:00Z with a French locale\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: \"fr\" }) //~> 2017-03-12T05:45:10.765Z with a French locale\n   * @return {DateTime}\n   */\n  static utc() {\n    const [opts, args] = lastOpts(arguments),\n      [year, month, day, hour, minute, second, millisecond] = args;\n\n    opts.zone = _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].utcInstance;\n    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);\n  }\n\n  /**\n   * Create a DateTime from a JavaScript Date object. Uses the default zone.\n   * @param {Date} date - a JavaScript Date object\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @return {DateTime}\n   */\n  static fromJSDate(date, options = {}) {\n    const ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isDate)(date) ? date.valueOf() : NaN;\n    if (Number.isNaN(ts)) {\n      return DateTime.invalid(\"invalid input\");\n    }\n\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    return new DateTime({\n      ts: ts,\n      zone: zoneToUse,\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n    });\n  }\n\n  /**\n   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} milliseconds - a number of milliseconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromMillis(milliseconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(milliseconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`\n      );\n    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {\n      // this isn't perfect because we can still end up out of range because of additional shifting, but it's a start\n      return DateTime.invalid(\"Timestamp out of range\");\n    } else {\n      return new DateTime({\n        ts: milliseconds,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} seconds - a number of seconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromSeconds(seconds, options = {}) {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(seconds)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromSeconds requires a numerical input\");\n    } else {\n      return new DateTime({\n        ts: seconds * 1000,\n        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone),\n        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(options),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.year - a year, such as 1987\n   * @param {number} obj.month - a month, 1-12\n   * @param {number} obj.day - a day of the month, 1-31, depending on the month\n   * @param {number} obj.ordinal - day of the year, 1-365 or 366\n   * @param {number} obj.weekYear - an ISO week year\n   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n   * @param {number} obj.localWeekYear - a week year, according to the locale\n   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale\n   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale\n   * @param {number} obj.hour - hour of the day, 0-23\n   * @param {number} obj.minute - minute of the hour, 0-59\n   * @param {number} obj.second - second of the minute, 0-59\n   * @param {number} obj.millisecond - millisecond of the second, 0-999\n   * @param {Object} opts - options for creating this DateTime\n   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()\n   * @param {string} [opts.locale='system\\'s locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })\n   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: \"en-US\" }).toISODate() //=> '2021-12-26'\n   * @return {DateTime}\n   */\n  static fromObject(obj, opts = {}) {\n    obj = obj || {};\n    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    const loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(opts);\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(obj, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, loc);\n\n    const tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].now(),\n      offsetProvis = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.specificOffset)\n        ? opts.specificOffset\n        : zoneToUse.offset(tsNow),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    // cases:\n    // just a weekday -> this week's instance of that weekday, no worries\n    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error\n    // (gregorian month or day) + ordinal -> error\n    // otherwise just use weeks or ordinals or gregorian, depending on what's specified\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);\n\n    // configure ourselves to deal with gregorian dates or week stuff\n    let units,\n      defaultValues,\n      objNow = tsToObj(tsNow, offsetProvis);\n    if (useWeekData) {\n      units = orderedWeekUnits;\n      defaultValues = defaultWeekUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(objNow, minDaysInFirstWeek, startOfWeek);\n    } else if (containsOrdinal) {\n      units = orderedOrdinalUnits;\n      defaultValues = defaultOrdinalUnitValues;\n      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(objNow);\n    } else {\n      units = orderedUnits;\n      defaultValues = defaultUnitValues;\n    }\n\n    // set default values for missing stuff\n    let foundFirst = false;\n    for (const u of units) {\n      const v = normalized[u];\n      if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(v)) {\n        foundFirst = true;\n      } else if (foundFirst) {\n        normalized[u] = defaultValues[u];\n      } else {\n        normalized[u] = objNow[u];\n      }\n    }\n\n    // make sure the values we have are in range\n    const higherOrderInvalid = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidWeekData)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidOrdinalData)(normalized)\n        : (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(normalized),\n      invalid = higherOrderInvalid || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(normalized);\n\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    // compute the actual time\n    const gregorian = useWeekData\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(normalized, minDaysInFirstWeek, startOfWeek)\n        : containsOrdinal\n        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)(normalized)\n        : normalized,\n      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),\n      inst = new DateTime({\n        ts: tsFinal,\n        zone: zoneToUse,\n        o: offsetFinal,\n        loc,\n      });\n\n    // gregorian data + weekday serves only to validate\n    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {\n      return DateTime.invalid(\n        \"mismatched weekday\",\n        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`\n      );\n    }\n\n    if (!inst.isValid) {\n      return DateTime.invalid(inst.invalid);\n    }\n\n    return inst;\n  }\n\n  /**\n   * Create a DateTime from an ISO 8601 string\n   * @param {string} text - the ISO string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n   * @example DateTime.fromISO('2016-W05-4')\n   * @return {DateTime}\n   */\n  static fromISO(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseISODate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"ISO 8601\", text);\n  }\n\n  /**\n   * Create a DateTime from an RFC 2822 string\n   * @param {string} text - the RFC 2822 string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n   * @return {DateTime}\n   */\n  static fromRFC2822(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseRFC2822Date)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"RFC 2822\", text);\n  }\n\n  /**\n   * Create a DateTime from an HTTP header date\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @param {string} text - the HTTP header date\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n   * @return {DateTime}\n   */\n  static fromHTTP(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseHTTPDate)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"HTTP\", opts);\n  }\n\n  /**\n   * Create a DateTime from an input string and format string.\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromFormat(text, fmt, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(fmt)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"fromFormat requires an input string and a format\");\n    }\n\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      }),\n      [vals, parsedZone, specificOffset, invalid] = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.parseFromTokens)(localeToUse, text, fmt);\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    } else {\n      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);\n    }\n  }\n\n  /**\n   * @deprecated use fromFormat instead\n   */\n  static fromString(text, fmt, opts = {}) {\n    return DateTime.fromFormat(text, fmt, opts);\n  }\n\n  /**\n   * Create a DateTime from a SQL date, time, or datetime\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale\n   * @param {string} text - the string to parse\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @example DateTime.fromSQL('2017-05-15')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n   * @example DateTime.fromSQL('09:12:34.342')\n   * @return {DateTime}\n   */\n  static fromSQL(text, opts = {}) {\n    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseSQL)(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"SQL\", text);\n  }\n\n  /**\n   * Create an invalid DateTime.\n   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {DateTime}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"need to specify a reason the DateTime is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidDateTimeError(invalid);\n    } else {\n      return new DateTime({ invalid });\n    }\n  }\n\n  /**\n   * Check if an object is an instance of DateTime. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDateTime(o) {\n    return (o && o.isLuxonDateTime) || false;\n  }\n\n  /**\n   * Produce the format string for a set of options\n   * @param formatOpts\n   * @param localeOpts\n   * @returns {string}\n   */\n  static parseFormatForOpts(formatOpts, localeOpts = {}) {\n    const tokenList = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.formatOptsToTokens)(formatOpts, _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join(\"\");\n  }\n\n  /**\n   * Produce the the fully expanded format token for the locale\n   * Does NOT quote characters, so quoted tokens will not round trip correctly\n   * @param fmt\n   * @param localeOpts\n   * @returns {string}\n   */\n  static expandFormat(fmt, localeOpts = {}) {\n    const expanded = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.expandMacroTokens)(_impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parseFormat(fmt), _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromObject(localeOpts));\n    return expanded.map((t) => t.val).join(\"\");\n  }\n\n  static resetCache() {\n    zoneOffsetTs = undefined;\n    zoneOffsetGuessCache.clear();\n  }\n\n  // INFO\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7\n   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4\n   * @return {number}\n   */\n  get(unit) {\n    return this[unit];\n  }\n\n  /**\n   * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n   * * The DateTime was created by an operation on another invalid date\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n   *\n   * @type {string}\n   */\n  get outputCalendar() {\n    return this.isValid ? this.loc.outputCalendar : null;\n  }\n\n  /**\n   * Get the time zone associated with this DateTime.\n   * @type {Zone}\n   */\n  get zone() {\n    return this._zone;\n  }\n\n  /**\n   * Get the name of the time zone.\n   * @type {string}\n   */\n  get zoneName() {\n    return this.isValid ? this.zone.name : null;\n  }\n\n  /**\n   * Get the year\n   * @example DateTime.local(2017, 5, 25).year //=> 2017\n   * @type {number}\n   */\n  get year() {\n    return this.isValid ? this.c.year : NaN;\n  }\n\n  /**\n   * Get the quarter\n   * @example DateTime.local(2017, 5, 25).quarter //=> 2\n   * @type {number}\n   */\n  get quarter() {\n    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\n  }\n\n  /**\n   * Get the month (1-12).\n   * @example DateTime.local(2017, 5, 25).month //=> 5\n   * @type {number}\n   */\n  get month() {\n    return this.isValid ? this.c.month : NaN;\n  }\n\n  /**\n   * Get the day of the month (1-30ish).\n   * @example DateTime.local(2017, 5, 25).day //=> 25\n   * @type {number}\n   */\n  get day() {\n    return this.isValid ? this.c.day : NaN;\n  }\n\n  /**\n   * Get the hour of the day (0-23).\n   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n   * @type {number}\n   */\n  get hour() {\n    return this.isValid ? this.c.hour : NaN;\n  }\n\n  /**\n   * Get the minute of the hour (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n   * @type {number}\n   */\n  get minute() {\n    return this.isValid ? this.c.minute : NaN;\n  }\n\n  /**\n   * Get the second of the minute (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n   * @type {number}\n   */\n  get second() {\n    return this.isValid ? this.c.second : NaN;\n  }\n\n  /**\n   * Get the millisecond of the second (0-999).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n   * @type {number}\n   */\n  get millisecond() {\n    return this.isValid ? this.c.millisecond : NaN;\n  }\n\n  /**\n   * Get the week year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015\n   * @type {number}\n   */\n  get weekYear() {\n    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the week number of the week year (1-52ish).\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21\n   * @type {number}\n   */\n  get weekNumber() {\n    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the day of the week.\n   * 1 is Monday and 7 is Sunday\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2014, 11, 31).weekday //=> 4\n   * @type {number}\n   */\n  get weekday() {\n    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Returns true if this date is on a weekend according to the locale, false otherwise\n   * @returns {boolean}\n   */\n  get isWeekend() {\n    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);\n  }\n\n  /**\n   * Get the day of the week according to the locale.\n   * 1 is the first day of the week and 7 is the last day of the week.\n   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,\n   * @returns {number}\n   */\n  get localWeekday() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;\n  }\n\n  /**\n   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,\n   * because the week can start on different days of the week (see localWeekday) and because a different number of days\n   * is required for a week to count as the first week of a year.\n   * @returns {number}\n   */\n  get localWeekNumber() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;\n  }\n\n  /**\n   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)\n   * differently, see localWeekNumber.\n   * @returns {number}\n   */\n  get localWeekYear() {\n    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;\n  }\n\n  /**\n   * Get the ordinal (meaning the day of the year)\n   * @example DateTime.local(2017, 5, 25).ordinal //=> 145\n   * @type {number|DateTime}\n   */\n  get ordinal() {\n    return this.isValid ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c).ordinal : NaN;\n  }\n\n  /**\n   * Get the human readable short month name, such as 'Oct'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct\n   * @type {string}\n   */\n  get monthShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"short\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable long month name, such as 'October'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).monthLong //=> October\n   * @type {string}\n   */\n  get monthLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].months(\"long\", { locObj: this.loc })[this.month - 1] : null;\n  }\n\n  /**\n   * Get the human readable short weekday, such as 'Mon'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n   * @type {string}\n   */\n  get weekdayShort() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"short\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the human readable long weekday, such as 'Monday'.\n   * Defaults to the system's locale if no locale has been specified\n   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n   * @type {string}\n   */\n  get weekdayLong() {\n    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].weekdays(\"long\", { locObj: this.loc })[this.weekday - 1] : null;\n  }\n\n  /**\n   * Get the UTC offset of this DateTime in minutes\n   * @example DateTime.now().offset //=> -240\n   * @example DateTime.utc().offset //=> 0\n   * @type {number}\n   */\n  get offset() {\n    return this.isValid ? +this.o : NaN;\n  }\n\n  /**\n   * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameShort() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"short\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n   * Defaults to the system's locale if no locale has been specified\n   * @type {string}\n   */\n  get offsetNameLong() {\n    if (this.isValid) {\n      return this.zone.offsetName(this.ts, {\n        format: \"long\",\n        locale: this.locale,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get whether this zone's offset ever changes, as in a DST.\n   * @type {boolean}\n   */\n  get isOffsetFixed() {\n    return this.isValid ? this.zone.isUniversal : null;\n  }\n\n  /**\n   * Get whether the DateTime is in a DST.\n   * @type {boolean}\n   */\n  get isInDST() {\n    if (this.isOffsetFixed) {\n      return false;\n    } else {\n      return (\n        this.offset > this.set({ month: 1, day: 1 }).offset ||\n        this.offset > this.set({ month: 5 }).offset\n      );\n    }\n  }\n\n  /**\n   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC\n   * in this DateTime's zone. During DST changes local time can be ambiguous, for example\n   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.\n   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.\n   * @returns {DateTime[]}\n   */\n  getPossibleOffsets() {\n    if (!this.isValid || this.isOffsetFixed) {\n      return [this];\n    }\n    const dayMs = 86400000;\n    const minuteMs = 60000;\n    const localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(this.c);\n    const oEarlier = this.zone.offset(localTS - dayMs);\n    const oLater = this.zone.offset(localTS + dayMs);\n\n    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);\n    const o2 = this.zone.offset(localTS - oLater * minuteMs);\n    if (o1 === o2) {\n      return [this];\n    }\n    const ts1 = localTS - o1 * minuteMs;\n    const ts2 = localTS - o2 * minuteMs;\n    const c1 = tsToObj(ts1, o1);\n    const c2 = tsToObj(ts2, o2);\n    if (\n      c1.hour === c2.hour &&\n      c1.minute === c2.minute &&\n      c1.second === c2.second &&\n      c1.millisecond === c2.millisecond\n    ) {\n      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];\n    }\n    return [this];\n  }\n\n  /**\n   * Returns true if this DateTime is in a leap year, false otherwise\n   * @example DateTime.local(2016).isInLeapYear //=> true\n   * @example DateTime.local(2013).isInLeapYear //=> false\n   * @type {boolean}\n   */\n  get isInLeapYear() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isLeapYear)(this.year);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's month\n   * @example DateTime.local(2016, 2).daysInMonth //=> 29\n   * @example DateTime.local(2016, 3).daysInMonth //=> 31\n   * @type {number}\n   */\n  get daysInMonth() {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(this.year, this.month);\n  }\n\n  /**\n   * Returns the number of days in this DateTime's year\n   * @example DateTime.local(2016).daysInYear //=> 366\n   * @example DateTime.local(2013).daysInYear //=> 365\n   * @type {number}\n   */\n  get daysInYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInYear)(this.year) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's year\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\n   * @example DateTime.local(2004).weeksInWeekYear //=> 53\n   * @example DateTime.local(2013).weeksInWeekYear //=> 52\n   * @type {number}\n   */\n  get weeksInWeekYear() {\n    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(this.weekYear) : NaN;\n  }\n\n  /**\n   * Returns the number of weeks in this DateTime's local week year\n   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52\n   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53\n   * @type {number}\n   */\n  get weeksInLocalWeekYear() {\n    return this.isValid\n      ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(\n          this.localWeekYear,\n          this.loc.getMinDaysInFirstWeek(),\n          this.loc.getStartOfWeek()\n        )\n      : NaN;\n  }\n\n  /**\n   * Returns the resolved Intl options for this DateTime.\n   * This is useful in understanding the behavior of formatting methods\n   * @param {Object} opts - the same options as toLocaleString\n   * @return {Object}\n   */\n  resolvedLocaleOptions(opts = {}) {\n    const { locale, numberingSystem, calendar } = _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(\n      this.loc.clone(opts),\n      opts\n    ).resolvedOptions(this);\n    return { locale, numberingSystem, outputCalendar: calendar };\n  }\n\n  // TRANSFORM\n\n  /**\n   * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to {@link DateTime#setZone}('utc')\n   * @param {number} [offset=0] - optionally, an offset from UTC in minutes\n   * @param {Object} [opts={}] - options to pass to `setZone()`\n   * @return {DateTime}\n   */\n  toUTC(offset = 0, opts = {}) {\n    return this.setZone(_zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance(offset), opts);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to `setZone('local')`\n   * @return {DateTime}\n   */\n  toLocal() {\n    return this.setZone(_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n   *\n   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.\n   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.\n   * @return {DateTime}\n   */\n  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {\n    zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultZone);\n    if (zone.equals(this.zone)) {\n      return this;\n    } else if (!zone.isValid) {\n      return DateTime.invalid(unsupportedZone(zone));\n    } else {\n      let newTS = this.ts;\n      if (keepLocalTime || keepCalendarTime) {\n        const offsetGuess = zone.offset(this.ts);\n        const asObj = this.toObject();\n        [newTS] = objToTS(asObj, offsetGuess, zone);\n      }\n      return clone(this, { ts: newTS, zone });\n    }\n  }\n\n  /**\n   * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\n   * @param {Object} properties - the properties to set\n   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\n   * @return {DateTime}\n   */\n  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });\n    return clone(this, { loc });\n  }\n\n  /**\n   * \"Set\" the locale. Returns a newly-constructed DateTime.\n   * Just a convenient alias for reconfigure({ locale })\n   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')\n   * @return {DateTime}\n   */\n  setLocale(locale) {\n    return this.reconfigure({ locale });\n  }\n\n  /**\n   * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n   * You can only set units with this method; for \"setting\" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.\n   *\n   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.\n   * They cannot be mixed with ISO-week units like `weekday`.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dt.set({ year: 2017 })\n   * @example dt.set({ hour: 8, minute: 30 })\n   * @example dt.set({ weekday: 5 })\n   * @example dt.set({ year: 2005, ordinal: 234 })\n   * @return {DateTime}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(values, normalizeUnitWithLocalWeeks);\n    const { minDaysInFirstWeek, startOfWeek } = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.usesLocalWeekValues)(normalized, this.loc);\n\n    const settingWeekStuff =\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekYear) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekNumber) ||\n        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekday),\n      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),\n      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),\n      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    let mixed;\n    if (settingWeekStuff) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(\n        { ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },\n        minDaysInFirstWeek,\n        startOfWeek\n      );\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal)) {\n      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)({ ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c), ...normalized });\n    } else {\n      mixed = { ...this.toObject(), ...normalized };\n\n      // if we didn't set the day but we ended up on an overflow date,\n      // use the last day of the right month\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day)) {\n        mixed.day = Math.min((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(mixed.year, mixed.month), mixed.day);\n      }\n    }\n\n    const [ts, o] = objToTS(mixed, this.o, this.zone);\n    return clone(this, { ts, o });\n  }\n\n  /**\n   * Add a period of time to this DateTime and return the resulting DateTime\n   *\n   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @example DateTime.now().plus(123) //~> in 123 milliseconds\n   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday\n   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n   * @return {DateTime}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration);\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * Subtract a period of time to this DateTime and return the resulting DateTime\n   * See {@link DateTime#plus}\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   @return {DateTime}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDurationLike(duration).negate();\n    return clone(this, adjustTime(this, dur));\n  }\n\n  /**\n   * \"Set\" this DateTime to the beginning of a unit of time.\n   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n   * @return {DateTime}\n   */\n  startOf(unit, { useLocaleWeeks = false } = {}) {\n    if (!this.isValid) return this;\n\n    const o = {},\n      normalizedUnit = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit(unit);\n    switch (normalizedUnit) {\n      case \"years\":\n        o.month = 1;\n      // falls through\n      case \"quarters\":\n      case \"months\":\n        o.day = 1;\n      // falls through\n      case \"weeks\":\n      case \"days\":\n        o.hour = 0;\n      // falls through\n      case \"hours\":\n        o.minute = 0;\n      // falls through\n      case \"minutes\":\n        o.second = 0;\n      // falls through\n      case \"seconds\":\n        o.millisecond = 0;\n        break;\n      case \"milliseconds\":\n        break;\n      // no default, invalid units throw in normalizeUnit()\n    }\n\n    if (normalizedUnit === \"weeks\") {\n      if (useLocaleWeeks) {\n        const startOfWeek = this.loc.getStartOfWeek();\n        const { weekday } = this;\n        if (weekday < startOfWeek) {\n          o.weekNumber = this.weekNumber - 1;\n        }\n        o.weekday = startOfWeek;\n      } else {\n        o.weekday = 1;\n      }\n    }\n\n    if (normalizedUnit === \"quarters\") {\n      const q = Math.ceil(this.month / 3);\n      o.month = (q - 1) * 3 + 1;\n    }\n\n    return this.set(o);\n  }\n\n  /**\n   * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week\n   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n   * @return {DateTime}\n   */\n  endOf(unit, opts) {\n    return this.isValid\n      ? this.plus({ [unit]: 1 })\n          .startOf(unit, opts)\n          .minus(1)\n      : this;\n  }\n\n  // OUTPUT\n\n  /**\n   * Returns a string representation of this DateTime formatted according to the specified format string.\n   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n   * @example DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.\n   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation\n   * of the DateTime in the assigned locale.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options\n   * @param {Object} opts - opts to override the configuration options on this DateTime\n   * @example DateTime.now().toLocaleString(); //=> 4/20/2017\n   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'\n   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), formatOpts).formatDateTime(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an array of format \"parts\", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\n   * Defaults to the system's locale if no locale has been specified\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\n   * @example DateTime.now().toLocaleParts(); //=> [\n   *                                   //=>   { type: 'day', value: '25' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'month', value: '05' },\n   *                                   //=>   { type: 'literal', value: '/' },\n   *                                   //=>   { type: 'year', value: '1982' }\n   *                                   //=> ]\n   */\n  toLocaleParts(opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(this.loc.clone(opts), opts).formatDateTimeParts(this)\n      : [];\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n   * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'\n   * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'\n   * @return {string|null}\n   */\n  toISO({\n    format = \"extended\",\n    suppressSeconds = false,\n    suppressMilliseconds = false,\n    includeOffset = true,\n    extendedZone = false,\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    const ext = format === \"extended\";\n\n    let c = toISODate(this, ext, precision);\n    if (orderedUnits.indexOf(precision) >= 3) c += \"T\";\n    c += toISOTime(\n      this,\n      ext,\n      suppressSeconds,\n      suppressMilliseconds,\n      includeOffset,\n      extendedZone,\n      precision\n    );\n    return c;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's date component\n   * @param {Object} opts - options\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.\n   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n   * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'\n   * @return {string|null}\n   */\n  toISODate({ format = \"extended\", precision = \"day\" } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, format === \"extended\", normalizeUnit(precision));\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's week date\n   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n   * @return {string}\n   */\n  toISOWeekDate() {\n    return toTechFormat(this, \"kkkk-'W'WW-c\");\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this DateTime's time component\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n   * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'\n   * @return {string}\n   */\n  toISOTime({\n    suppressMilliseconds = false,\n    suppressSeconds = false,\n    includeOffset = true,\n    includePrefix = false,\n    extendedZone = false,\n    format = \"extended\",\n    precision = \"milliseconds\",\n  } = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    precision = normalizeUnit(precision);\n    let c = includePrefix && orderedUnits.indexOf(precision) >= 3 ? \"T\" : \"\";\n    return (\n      c +\n      toISOTime(\n        this,\n        format === \"extended\",\n        suppressSeconds,\n        suppressMilliseconds,\n        includeOffset,\n        extendedZone,\n        precision\n      )\n    );\n  }\n\n  /**\n   * Returns an RFC 2822-compatible string representation of this DateTime\n   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n   * @return {string}\n   */\n  toRFC2822() {\n    return toTechFormat(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\", false);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.\n   * Specifically, the string conforms to RFC 1123.\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n   * @return {string}\n   */\n  toHTTP() {\n    return toTechFormat(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\");\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Date\n   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n   * @return {string|null}\n   */\n  toSQLDate() {\n    if (!this.isValid) {\n      return null;\n    }\n    return toISODate(this, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL Time\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc().toSQL() //=> '05:15:16.345'\n   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n   * @return {string}\n   */\n  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {\n    let fmt = \"HH:mm:ss.SSS\";\n\n    if (includeZone || includeOffset) {\n      if (includeOffsetSpace) {\n        fmt += \" \";\n      }\n      if (includeZone) {\n        fmt += \"z\";\n      } else if (includeOffset) {\n        fmt += \"ZZ\";\n      }\n    }\n\n    return toTechFormat(this, fmt, true);\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n   * @param {Object} opts - options\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\n   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'\n   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n   * @return {string}\n   */\n  toSQL(opts = {}) {\n    if (!this.isValid) {\n      return null;\n    }\n\n    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for debugging\n   * @return {string}\n   */\n  toString() {\n    return this.isValid ? this.toISO() : INVALID;\n  }\n\n  /**\n   * Returns a string representation of this DateTime appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;\n    } else {\n      return `DateTime { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Returns the epoch milliseconds of this DateTime.\n   * @return {number}\n   */\n  toMillis() {\n    return this.isValid ? this.ts : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.\n   * @return {number}\n   */\n  toSeconds() {\n    return this.isValid ? this.ts / 1000 : NaN;\n  }\n\n  /**\n   * Returns the epoch seconds (as a whole number) of this DateTime.\n   * @return {number}\n   */\n  toUnixInteger() {\n    return this.isValid ? Math.floor(this.ts / 1000) : NaN;\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a BSON serializable equivalent to this DateTime.\n   * @return {Date}\n   */\n  toBSON() {\n    return this.toJSDate();\n  }\n\n  /**\n   * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n   * @param opts - options for generating the object\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\n   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n   * @return {Object}\n   */\n  toObject(opts = {}) {\n    if (!this.isValid) return {};\n\n    const base = { ...this.c };\n\n    if (opts.includeConfig) {\n      base.outputCalendar = this.outputCalendar;\n      base.numberingSystem = this.loc.numberingSystem;\n      base.locale = this.loc.locale;\n    }\n    return base;\n  }\n\n  /**\n   * Returns a JavaScript Date equivalent to this DateTime.\n   * @return {Date}\n   */\n  toJSDate() {\n    return new Date(this.isValid ? this.ts : NaN);\n  }\n\n  // COMPARE\n\n  /**\n   * Return the difference between two DateTimes as a Duration.\n   * @param {DateTime} otherDateTime - the DateTime to compare this one to\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example\n   * var i1 = DateTime.fromISO('1982-05-25T09:45'),\n   *     i2 = DateTime.fromISO('1983-10-14T10:30');\n   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n   * @return {Duration}\n   */\n  diff(otherDateTime, unit = \"milliseconds\", opts = {}) {\n    if (!this.isValid || !otherDateTime.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].invalid(\"created by diffing an invalid DateTime\");\n    }\n\n    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };\n\n    const units = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.maybeArray)(unit).map(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeUnit),\n      otherIsLater = otherDateTime.valueOf() > this.valueOf(),\n      earlier = otherIsLater ? this : otherDateTime,\n      later = otherIsLater ? otherDateTime : this,\n      diffed = (0,_impl_diff_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(earlier, later, units, durOpts);\n\n    return otherIsLater ? diffed.negate() : diffed;\n  }\n\n  /**\n   * Return the difference between this DateTime and right now.\n   * See {@link DateTime#diff}\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  diffNow(unit = \"milliseconds\", opts = {}) {\n    return this.diff(DateTime.now(), unit, opts);\n  }\n\n  /**\n   * Return an Interval spanning between this DateTime and another DateTime\n   * @param {DateTime} otherDateTime - the other end point of the Interval\n   * @return {Interval|DateTime}\n   */\n  until(otherDateTime) {\n    return this.isValid ? _interval_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDateTimes(this, otherDateTime) : this;\n  }\n\n  /**\n   * Return whether this DateTime is in the same unit of time as another DateTime.\n   * Higher-order units must also be identical for this function to return `true`.\n   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.\n   * @param {DateTime} otherDateTime - the other DateTime\n   * @param {string} unit - the unit of time to check sameness on\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used\n   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n   * @return {boolean}\n   */\n  hasSame(otherDateTime, unit, opts) {\n    if (!this.isValid) return false;\n\n    const inputMs = otherDateTime.valueOf();\n    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });\n    return (\n      adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts)\n    );\n  }\n\n  /**\n   * Equality check\n   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.\n   * To compare just the millisecond values, use `+dt1 === +dt2`.\n   * @param {DateTime} other - the other DateTime\n   * @return {boolean}\n   */\n  equals(other) {\n    return (\n      this.isValid &&\n      other.isValid &&\n      this.valueOf() === other.valueOf() &&\n      this.zone.equals(other.zone) &&\n      this.loc.equals(other.loc)\n    );\n  }\n\n  /**\n   * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\n   * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} [options.style=\"long\"] - the style of units, must be \"long\", \"short\", or \"narrow\"\n   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of \"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", or \"seconds\"\n   * @param {boolean} [options.round=true] - whether to round the numbers in the output.\n   * @param {string} [options.rounding=\"trunc\"] - rounding method to use when rounding the numbers in the output. Can be \"trunc\" (toward zero), \"expand\" (away from zero), \"round\", \"floor\", or \"ceil\".\n   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n   * @example DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"\n   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n   */\n  toRelative(options = {}) {\n    if (!this.isValid) return null;\n    const base = options.base || DateTime.fromObject({}, { zone: this.zone }),\n      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;\n    let units = [\"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\"];\n    let unit = options.unit;\n    if (Array.isArray(options.unit)) {\n      units = options.unit;\n      unit = undefined;\n    }\n    return diffRelative(base, this.plus(padding), {\n      ...options,\n      numeric: \"always\",\n      units,\n      unit,\n    });\n  }\n\n  /**\n   * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n   * @param {Object} options - options that affect the output\n   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\n   * @param {string} options.locale - override the locale of this DateTime\n   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"years\", \"quarters\", \"months\", \"weeks\", or \"days\"\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n   * @example DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"maana\"\n   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n   */\n  toRelativeCalendar(options = {}) {\n    if (!this.isValid) return null;\n\n    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {\n      ...options,\n      numeric: \"auto\",\n      units: [\"years\", \"months\", \"days\"],\n      calendary: true,\n    });\n  }\n\n  /**\n   * Return the min of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum\n   * @return {DateTime} the min DateTime, or undefined if called with no argument\n   */\n  static min(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"min requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.min);\n  }\n\n  /**\n   * Return the max of several date times\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum\n   * @return {DateTime} the max DateTime, or undefined if called with no argument\n   */\n  static max(...dateTimes) {\n    if (!dateTimes.every(DateTime.isDateTime)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\"max requires all arguments be DateTimes\");\n    }\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.max);\n  }\n\n  // MISC\n\n  /**\n   * Explain how a string would be parsed by fromFormat()\n   * @param {string} text - the string to parse\n   * @param {string} fmt - the format the string is expected to be in (see description)\n   * @param {Object} options - options taken by fromFormat()\n   * @return {Object}\n   */\n  static fromFormatExplain(text, fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.explainFromTokens)(localeToUse, text, fmt);\n  }\n\n  /**\n   * @deprecated use fromFormatExplain instead\n   */\n  static fromStringExplain(text, fmt, options = {}) {\n    return DateTime.fromFormatExplain(text, fmt, options);\n  }\n\n  /**\n   * Build a parser for `fmt` using the given locale. This parser can be passed\n   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This\n   * can be used to optimize cases where many dates need to be parsed in a\n   * specific format.\n   *\n   * @param {String} fmt - the format the string is expected to be in (see\n   * description)\n   * @param {Object} options - options used to set locale and numberingSystem\n   * for parser\n   * @returns {TokenParser} - opaque object to be used\n   */\n  static buildFormatParser(fmt, options = {}) {\n    const { locale = null, numberingSystem = null } = options,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n    return new _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.TokenParser(localeToUse, fmt);\n  }\n\n  /**\n   * Create a DateTime from an input string and format parser.\n   *\n   * The format parser must have been created with the same locale as this call.\n   *\n   * @param {String} text - the string to parse\n   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}\n   * @param {Object} opts - options taken by fromFormat()\n   * @returns {DateTime}\n   */\n  static fromFormatParser(text, formatParser, opts = {}) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(formatParser)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        \"fromFormatParser requires an input string and a format parser\"\n      );\n    }\n    const { locale = null, numberingSystem = null } = opts,\n      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromOpts({\n        locale,\n        numberingSystem,\n        defaultToEN: true,\n      });\n\n    if (!localeToUse.equals(formatParser.locale)) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n        `fromFormatParser called with a locale of ${localeToUse}, ` +\n          `but the format parser was created for ${formatParser.locale}`\n      );\n    }\n\n    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);\n\n    if (invalidReason) {\n      return DateTime.invalid(invalidReason);\n    } else {\n      return parseDataToDateTime(\n        result,\n        zone,\n        opts,\n        `format ${formatParser.format}`,\n        text,\n        specificOffset\n      );\n    }\n  }\n\n  // FORMAT PRESETS\n\n  /**\n   * {@link DateTime#toLocaleString} format like 10/14/1983\n   * @type {Object}\n   */\n  static get DATE_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'\n   * @type {Object}\n   */\n  static get DATE_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get TIME_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_SIMPLE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_SIMPLE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_SHORT_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SHORT_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n   * @type {Object}\n   */\n  static get TIME_24_WITH_LONG_OFFSET() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_LONG_OFFSET;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_SHORT_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_MED_WITH_WEEKDAY() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_WEEKDAY;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_FULL_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL_WITH_SECONDS;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE;\n  }\n\n  /**\n   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n   * @type {Object}\n   */\n  static get DATETIME_HUGE_WITH_SECONDS() {\n    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE_WITH_SECONDS;\n  }\n}\n\n/**\n * @private\n */\nfunction friendlyDateTime(dateTimeish) {\n  if (DateTime.isDateTime(dateTimeish)) {\n    return dateTimeish;\n  } else if (dateTimeish && dateTimeish.valueOf && (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(dateTimeish.valueOf())) {\n    return DateTime.fromJSDate(dateTimeish);\n  } else if (dateTimeish && typeof dateTimeish === \"object\") {\n    return DateTime.fromObject(dateTimeish);\n  } else {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(\n      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`\n    );\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kYXRldGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQTtBQUNBO0FBQ1I7QUFDZTtBQUNhO0FBQ25CO0FBZWQ7QUFDMkI7QUFDakI7QUFDOEQ7QUFPakU7QUFZQTtBQUNjO0FBTXhCO0FBQ21COztBQUV4QztBQUNBOztBQUVBO0FBQ0EsYUFBYSx5REFBTyxrQ0FBa0MsVUFBVTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzRUFBZTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNFQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFZO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBEQUFXO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLG9EQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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O0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJLCtDQUErQyx1REFBUTtBQUMzRDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixjQUFjLDZEQUFvQjtBQUNsQyxvQ0FBb0MsWUFBWSxZQUFZLG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IEluZm8gZnJvbSBcIi4vaW5mby5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7XG4gIGlzVW5kZWZpbmVkLFxuICBtYXliZUFycmF5LFxuICBpc0RhdGUsXG4gIGlzTnVtYmVyLFxuICBiZXN0QnksXG4gIGRheXNJbk1vbnRoLFxuICBkYXlzSW5ZZWFyLFxuICBpc0xlYXBZZWFyLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbiAgb2JqVG9Mb2NhbFRTLFxuICBwYWRTdGFydCxcbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuaW1wb3J0IGRpZmYgZnJvbSBcIi4vaW1wbC9kaWZmLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVJGQzI4MjJEYXRlLCBwYXJzZUlTT0RhdGUsIHBhcnNlSFRUUERhdGUsIHBhcnNlU1FMIH0gZnJvbSBcIi4vaW1wbC9yZWdleFBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgcGFyc2VGcm9tVG9rZW5zLFxuICBleHBsYWluRnJvbVRva2VucyxcbiAgZm9ybWF0T3B0c1RvVG9rZW5zLFxuICBleHBhbmRNYWNyb1Rva2VucyxcbiAgVG9rZW5QYXJzZXIsXG59IGZyb20gXCIuL2ltcGwvdG9rZW5QYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGdyZWdvcmlhblRvV2VlayxcbiAgd2Vla1RvR3JlZ29yaWFuLFxuICBncmVnb3JpYW5Ub09yZGluYWwsXG4gIG9yZGluYWxUb0dyZWdvcmlhbixcbiAgaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEsXG4gIGhhc0ludmFsaWRXZWVrRGF0YSxcbiAgaGFzSW52YWxpZE9yZGluYWxEYXRhLFxuICBoYXNJbnZhbGlkVGltZURhdGEsXG4gIHVzZXNMb2NhbFdlZWtWYWx1ZXMsXG4gIGlzb1dlZWtkYXlUb0xvY2FsLFxufSBmcm9tIFwiLi9pbXBsL2NvbnZlcnNpb25zLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yLFxuICBJbnZhbGlkVW5pdEVycm9yLFxuICBJbnZhbGlkRGF0ZVRpbWVFcnJvcixcbn0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBEYXRlVGltZVwiO1xuY29uc3QgTUFYX0RBVEUgPSA4LjY0ZTE1O1xuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFpvbmUoem9uZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXCJ1bnN1cHBvcnRlZCB6b25lXCIsIGB0aGUgem9uZSBcIiR7em9uZS5uYW1lfVwiIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbn1cblxuLy8gd2UgY2FjaGUgd2VlayBkYXRhIG9uIHRoZSBEVCBvYmplY3QgYW5kIHRoaXMgaW50ZXJtZWRpYXRlcyB0aGUgY2FjaGVcbi8qKlxuICogQHBhcmFtIHtEYXRlVGltZX0gZHRcbiAqL1xuZnVuY3Rpb24gcG9zc2libHlDYWNoZWRXZWVrRGF0YShkdCkge1xuICBpZiAoZHQud2Vla0RhdGEgPT09IG51bGwpIHtcbiAgICBkdC53ZWVrRGF0YSA9IGdyZWdvcmlhblRvV2VlayhkdC5jKTtcbiAgfVxuICByZXR1cm4gZHQud2Vla0RhdGE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEYXRlVGltZX0gZHRcbiAqL1xuZnVuY3Rpb24gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC5sb2NhbFdlZWtEYXRhID09PSBudWxsKSB7XG4gICAgZHQubG9jYWxXZWVrRGF0YSA9IGdyZWdvcmlhblRvV2VlayhcbiAgICAgIGR0LmMsXG4gICAgICBkdC5sb2MuZ2V0TWluRGF5c0luRmlyc3RXZWVrKCksXG4gICAgICBkdC5sb2MuZ2V0U3RhcnRPZldlZWsoKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGR0LmxvY2FsV2Vla0RhdGE7XG59XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucywgXCJtYWtlIGEgbmV3IG9iamVjdCB3aXRoIHRoZXNlIG1vZGlmaWNhdGlvbnNcIi4gYWxsIFwic2V0dGVyc1wiIHJlYWxseSB1c2UgdGhpc1xuLy8gdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB3aGlsZSBvbmx5IGNoYW5naW5nIHNvbWUgb2YgdGhlIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGNsb25lKGluc3QsIGFsdHMpIHtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICB0czogaW5zdC50cyxcbiAgICB6b25lOiBpbnN0LnpvbmUsXG4gICAgYzogaW5zdC5jLFxuICAgIG86IGluc3QubyxcbiAgICBsb2M6IGluc3QubG9jLFxuICAgIGludmFsaWQ6IGluc3QuaW52YWxpZCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IC4uLmN1cnJlbnQsIC4uLmFsdHMsIG9sZDogY3VycmVudCB9KTtcbn1cblxuLy8gZmluZCB0aGUgcmlnaHQgb2Zmc2V0IGEgZ2l2ZW4gbG9jYWwgdGltZS4gVGhlIG8gaW5wdXQgaXMgb3VyIGd1ZXNzLCB3aGljaCBkZXRlcm1pbmVzIHdoaWNoXG4vLyBvZmZzZXQgd2UnbGwgcGljayBpbiBhbWJpZ3VvdXMgY2FzZXMgKGUuZy4gdGhlcmUgYXJlIHR3byAzIEFNcyBiL2MgRmFsbGJhY2sgRFNUKVxuZnVuY3Rpb24gZml4T2Zmc2V0KGxvY2FsVFMsIG8sIHR6KSB7XG4gIC8vIE91ciBVVEMgdGltZSBpcyBqdXN0IGEgZ3Vlc3MgYmVjYXVzZSBvdXIgb2Zmc2V0IGlzIGp1c3QgYSBndWVzc1xuICBsZXQgdXRjR3Vlc3MgPSBsb2NhbFRTIC0gbyAqIDYwICogMTAwMDtcblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlIHpvbmUgbWF0Y2hlcyB0aGUgb2Zmc2V0IGZvciB0aGlzIHRzXG4gIGNvbnN0IG8yID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcblxuICAvLyBJZiBzbywgb2Zmc2V0IGRpZG4ndCBjaGFuZ2UgYW5kIHdlJ3JlIGRvbmVcbiAgaWYgKG8gPT09IG8yKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgb107XG4gIH1cblxuICAvLyBJZiBub3QsIGNoYW5nZSB0aGUgdHMgYnkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIG9mZnNldFxuICB1dGNHdWVzcyAtPSAobzIgLSBvKSAqIDYwICogMTAwMDtcblxuICAvLyBJZiB0aGF0IGdpdmVzIHVzIHRoZSBsb2NhbCB0aW1lIHdlIHdhbnQsIHdlJ3JlIGRvbmVcbiAgY29uc3QgbzMgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuICBpZiAobzIgPT09IG8zKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgbzJdO1xuICB9XG5cbiAgLy8gSWYgaXQncyBkaWZmZXJlbnQsIHdlJ3JlIGluIGEgaG9sZSB0aW1lLiBUaGUgb2Zmc2V0IGhhcyBjaGFuZ2VkLCBidXQgdGhlIHdlIGRvbid0IGFkanVzdCB0aGUgdGltZVxuICByZXR1cm4gW2xvY2FsVFMgLSBNYXRoLm1pbihvMiwgbzMpICogNjAgKiAxMDAwLCBNYXRoLm1heChvMiwgbzMpXTtcbn1cblxuLy8gY29udmVydCBhbiBlcG9jaCB0aW1lc3RhbXAgaW50byBhIGNhbGVuZGFyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBvZmZzZXRcbmZ1bmN0aW9uIHRzVG9PYmoodHMsIG9mZnNldCkge1xuICB0cyArPSBvZmZzZXQgKiA2MCAqIDEwMDA7XG5cbiAgY29uc3QgZCA9IG5ldyBEYXRlKHRzKTtcblxuICByZXR1cm4ge1xuICAgIHllYXI6IGQuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogZC5nZXRVVENNb250aCgpICsgMSxcbiAgICBkYXk6IGQuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGQuZ2V0VVRDSG91cnMoKSxcbiAgICBtaW51dGU6IGQuZ2V0VVRDTWludXRlcygpLFxuICAgIHNlY29uZDogZC5nZXRVVENTZWNvbmRzKCksXG4gICAgbWlsbGlzZWNvbmQ6IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIH07XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBlcG9jaCB0aW1lc3RhbXBcbmZ1bmN0aW9uIG9ialRvVFMob2JqLCBvZmZzZXQsIHpvbmUpIHtcbiAgcmV0dXJuIGZpeE9mZnNldChvYmpUb0xvY2FsVFMob2JqKSwgb2Zmc2V0LCB6b25lKTtcbn1cblxuLy8gY3JlYXRlIGEgbmV3IERUIGluc3RhbmNlIGJ5IGFkZGluZyBhIGR1cmF0aW9uLCBhZGp1c3RpbmcgZm9yIERTVHNcbmZ1bmN0aW9uIGFkanVzdFRpbWUoaW5zdCwgZHVyKSB7XG4gIGNvbnN0IG9QcmUgPSBpbnN0Lm8sXG4gICAgeWVhciA9IGluc3QuYy55ZWFyICsgTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgIG1vbnRoID0gaW5zdC5jLm1vbnRoICsgTWF0aC50cnVuYyhkdXIubW9udGhzKSArIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSAqIDMsXG4gICAgYyA9IHtcbiAgICAgIC4uLmluc3QuYyxcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheTpcbiAgICAgICAgTWF0aC5taW4oaW5zdC5jLmRheSwgZGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLmRheXMpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIud2Vla3MpICogNyxcbiAgICB9LFxuICAgIG1pbGxpc1RvQWRkID0gRHVyYXRpb24uZnJvbU9iamVjdCh7XG4gICAgICB5ZWFyczogZHVyLnllYXJzIC0gTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICAgIG1vbnRoczogZHVyLm1vbnRocyAtIE1hdGgudHJ1bmMoZHVyLm1vbnRocyksXG4gICAgICB3ZWVrczogZHVyLndlZWtzIC0gTWF0aC50cnVuYyhkdXIud2Vla3MpLFxuICAgICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICAgIGhvdXJzOiBkdXIuaG91cnMsXG4gICAgICBtaW51dGVzOiBkdXIubWludXRlcyxcbiAgICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkdXIubWlsbGlzZWNvbmRzLFxuICAgIH0pLmFzKFwibWlsbGlzZWNvbmRzXCIpLFxuICAgIGxvY2FsVFMgPSBvYmpUb0xvY2FsVFMoYyk7XG5cbiAgbGV0IFt0cywgb10gPSBmaXhPZmZzZXQobG9jYWxUUywgb1ByZSwgaW5zdC56b25lKTtcblxuICBpZiAobWlsbGlzVG9BZGQgIT09IDApIHtcbiAgICB0cyArPSBtaWxsaXNUb0FkZDtcbiAgICAvLyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgb2Zmc2V0IGJ5IGdvaW5nIG92ZXIgYSBEU1QsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRzIHRoZSBzYW1lXG4gICAgbyA9IGluc3Quem9uZS5vZmZzZXQodHMpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHMsIG8gfTtcbn1cblxuLy8gaGVscGVyIHVzZWZ1bCBpbiB0dXJuaW5nIHRoZSByZXN1bHRzIG9mIHBhcnNpbmcgaW50byByZWFsIGRhdGVzXG4vLyBieSBoYW5kbGluZyB0aGUgem9uZSBvcHRpb25zXG5mdW5jdGlvbiBwYXJzZURhdGFUb0RhdGVUaW1lKHBhcnNlZCwgcGFyc2VkWm9uZSwgb3B0cywgZm9ybWF0LCB0ZXh0LCBzcGVjaWZpY09mZnNldCkge1xuICBjb25zdCB7IHNldFpvbmUsIHpvbmUgfSA9IG9wdHM7XG4gIGlmICgocGFyc2VkICYmIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoICE9PSAwKSB8fCBwYXJzZWRab25lKSB7XG4gICAgY29uc3QgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgaW5zdCA9IERhdGVUaW1lLmZyb21PYmplY3QocGFyc2VkLCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHpvbmU6IGludGVycHJldGF0aW9uWm9uZSxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXQsXG4gICAgICB9KTtcbiAgICByZXR1cm4gc2V0Wm9uZSA/IGluc3QgOiBpbnN0LnNldFpvbmUoem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICBuZXcgSW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgJHtmb3JtYXR9YClcbiAgICApO1xuICB9XG59XG5cbi8vIGlmIHlvdSB3YW50IHRvIG91dHB1dCBhIHRlY2huaWNhbCBmb3JtYXQgKGUuZy4gUkZDIDI4MjIpLCB0aGlzIGhlbHBlclxuLy8gaGVscHMgaGFuZGxlIHRoZSBkZXRhaWxzXG5mdW5jdGlvbiB0b1RlY2hGb3JtYXQoZHQsIGZvcm1hdCwgYWxsb3daID0gdHJ1ZSkge1xuICByZXR1cm4gZHQuaXNWYWxpZFxuICAgID8gRm9ybWF0dGVyLmNyZWF0ZShMb2NhbGUuY3JlYXRlKFwiZW4tVVNcIiksIHtcbiAgICAgICAgYWxsb3daLFxuICAgICAgICBmb3JjZVNpbXBsZTogdHJ1ZSxcbiAgICAgIH0pLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm9ybWF0KVxuICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9JU09EYXRlKG8sIGV4dGVuZGVkLCBwcmVjaXNpb24pIHtcbiAgY29uc3QgbG9uZ0Zvcm1hdCA9IG8uYy55ZWFyID4gOTk5OSB8fCBvLmMueWVhciA8IDA7XG4gIGxldCBjID0gXCJcIjtcbiAgaWYgKGxvbmdGb3JtYXQgJiYgby5jLnllYXIgPj0gMCkgYyArPSBcIitcIjtcbiAgYyArPSBwYWRTdGFydChvLmMueWVhciwgbG9uZ0Zvcm1hdCA/IDYgOiA0KTtcbiAgaWYgKHByZWNpc2lvbiA9PT0gXCJ5ZWFyXCIpIHJldHVybiBjO1xuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiLVwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBpZiAocHJlY2lzaW9uID09PSBcIm1vbnRoXCIpIHJldHVybiBjO1xuICAgIGMgKz0gXCItXCI7XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGlmIChwcmVjaXNpb24gPT09IFwibW9udGhcIikgcmV0dXJuIGM7XG4gIH1cbiAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHRvSVNPVGltZShcbiAgbyxcbiAgZXh0ZW5kZWQsXG4gIHN1cHByZXNzU2Vjb25kcyxcbiAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gIGluY2x1ZGVPZmZzZXQsXG4gIGV4dGVuZGVkWm9uZSxcbiAgcHJlY2lzaW9uXG4pIHtcbiAgbGV0IHNob3dTZWNvbmRzID0gIXN1cHByZXNzU2Vjb25kcyB8fCBvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgby5jLnNlY29uZCAhPT0gMCxcbiAgICBjID0gXCJcIjtcbiAgc3dpdGNoIChwcmVjaXNpb24pIHtcbiAgICBjYXNlIFwiZGF5XCI6XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgY2FzZSBcInllYXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjICs9IHBhZFN0YXJ0KG8uYy5ob3VyKTtcbiAgICAgIGlmIChwcmVjaXNpb24gPT09IFwiaG91clwiKSBicmVhaztcbiAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICBjICs9IFwiOlwiO1xuICAgICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICAgICAgICBpZiAocHJlY2lzaW9uID09PSBcIm1pbnV0ZVwiKSBicmVhaztcbiAgICAgICAgaWYgKHNob3dTZWNvbmRzKSB7XG4gICAgICAgICAgYyArPSBcIjpcIjtcbiAgICAgICAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICAgICAgICBpZiAocHJlY2lzaW9uID09PSBcIm1pbnV0ZVwiKSBicmVhaztcbiAgICAgICAgaWYgKHNob3dTZWNvbmRzKSB7XG4gICAgICAgICAgYyArPSBwYWRTdGFydChvLmMuc2Vjb25kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZWNpc2lvbiA9PT0gXCJzZWNvbmRcIikgYnJlYWs7XG4gICAgICBpZiAoc2hvd1NlY29uZHMgJiYgKCFzdXBwcmVzc01pbGxpc2Vjb25kcyB8fCBvLmMubWlsbGlzZWNvbmQgIT09IDApKSB7XG4gICAgICAgIGMgKz0gXCIuXCI7XG4gICAgICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbGxpc2Vjb25kLCAzKTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgaWYgKG8uaXNPZmZzZXRGaXhlZCAmJiBvLm9mZnNldCA9PT0gMCAmJiAhZXh0ZW5kZWRab25lKSB7XG4gICAgICBjICs9IFwiWlwiO1xuICAgIH0gZWxzZSBpZiAoby5vIDwgMCkge1xuICAgICAgYyArPSBcIi1cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAlIDYwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgKz0gXCIrXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vICUgNjApKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXh0ZW5kZWRab25lKSB7XG4gICAgYyArPSBcIltcIiArIG8uem9uZS5pYW5hTmFtZSArIFwiXVwiO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBkZWZhdWx0cyBmb3IgdW5zcGVjaWZpZWQgdW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnNcbmNvbnN0IGRlZmF1bHRVbml0VmFsdWVzID0ge1xuICAgIG1vbnRoOiAxLFxuICAgIGRheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRXZWVrVW5pdFZhbHVlcyA9IHtcbiAgICB3ZWVrTnVtYmVyOiAxLFxuICAgIHdlZWtkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9LFxuICBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXMgPSB7XG4gICAgb3JkaW5hbDogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH07XG5cbi8vIFVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzLCBzb3J0ZWQgYnkgYmlnbmVzc1xuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1wieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdLFxuICBvcmRlcmVkV2Vla1VuaXRzID0gW1xuICAgIFwid2Vla1llYXJcIixcbiAgICBcIndlZWtOdW1iZXJcIixcbiAgICBcIndlZWtkYXlcIixcbiAgICBcImhvdXJcIixcbiAgICBcIm1pbnV0ZVwiLFxuICAgIFwic2Vjb25kXCIsXG4gICAgXCJtaWxsaXNlY29uZFwiLFxuICBdLFxuICBvcmRlcmVkT3JkaW5hbFVuaXRzID0gW1wieWVhclwiLCBcIm9yZGluYWxcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl07XG5cbi8vIHN0YW5kYXJkaXplIGNhc2UgYW5kIHBsdXJhbGl0eSBpbiB1bml0c1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgeWVhcjogXCJ5ZWFyXCIsXG4gICAgeWVhcnM6IFwieWVhclwiLFxuICAgIG1vbnRoOiBcIm1vbnRoXCIsXG4gICAgbW9udGhzOiBcIm1vbnRoXCIsXG4gICAgZGF5OiBcImRheVwiLFxuICAgIGRheXM6IFwiZGF5XCIsXG4gICAgaG91cjogXCJob3VyXCIsXG4gICAgaG91cnM6IFwiaG91clwiLFxuICAgIG1pbnV0ZTogXCJtaW51dGVcIixcbiAgICBtaW51dGVzOiBcIm1pbnV0ZVwiLFxuICAgIHF1YXJ0ZXI6IFwicXVhcnRlclwiLFxuICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJcIixcbiAgICBzZWNvbmQ6IFwic2Vjb25kXCIsXG4gICAgc2Vjb25kczogXCJzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZFwiLFxuICAgIHdlZWtkYXk6IFwid2Vla2RheVwiLFxuICAgIHdlZWtkYXlzOiBcIndlZWtkYXlcIixcbiAgICB3ZWVrbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrc251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla251bWJlcnM6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWt5ZWFyOiBcIndlZWtZZWFyXCIsXG4gICAgd2Vla3llYXJzOiBcIndlZWtZZWFyXCIsXG4gICAgb3JkaW5hbDogXCJvcmRpbmFsXCIsXG4gIH1bdW5pdC50b0xvd2VyQ2FzZSgpXTtcblxuICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3ModW5pdCkge1xuICBzd2l0Y2ggKHVuaXQudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJsb2NhbHdlZWtkYXlcIjpcbiAgICBjYXNlIFwibG9jYWx3ZWVrZGF5c1wiOlxuICAgICAgcmV0dXJuIFwibG9jYWxXZWVrZGF5XCI7XG4gICAgY2FzZSBcImxvY2Fsd2Vla251bWJlclwiOlxuICAgIGNhc2UgXCJsb2NhbHdlZWtudW1iZXJzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtOdW1iZXJcIjtcbiAgICBjYXNlIFwibG9jYWx3ZWVreWVhclwiOlxuICAgIGNhc2UgXCJsb2NhbHdlZWt5ZWFyc1wiOlxuICAgICAgcmV0dXJuIFwibG9jYWxXZWVrWWVhclwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbm9ybWFsaXplVW5pdCh1bml0KTtcbiAgfVxufVxuXG4vLyBjYWNoZSBvZmZzZXRzIGZvciB6b25lcyBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lc3RhbXAgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzXG4vLyBmaXJzdCBjYWxsZWQuIFdoZW4gd2UgYXJlIGhhbmRsaW5nIGEgZGF0ZXRpbWUgZnJvbSBjb21wb25lbnRzIGxpa2UgKHllYXIsXG4vLyBtb250aCwgZGF5LCBob3VyKSBpbiBhIHRpbWUgem9uZSwgd2UgbmVlZCBhIGd1ZXNzIGFib3V0IHdoYXQgdGhlIHRpbWV6b25lXG4vLyBvZmZzZXQgaXMgc28gdGhhdCB3ZSBjYW4gY29udmVydCBpbnRvIGEgVVRDIHRpbWVzdGFtcC4gT25lIHdheSBpcyB0byBmaW5kIHRoZVxuLy8gb2Zmc2V0IG9mIG5vdyBpbiB0aGUgem9uZS4gVGhlIGFjdHVhbCBkYXRlIG1heSBoYXZlIGEgZGlmZmVyZW50IG9mZnNldCAoZm9yXG4vLyBleGFtcGxlLCBpZiB3ZSBoYW5kbGUgYSBkYXRlIGluIEp1bmUgd2hpbGUgd2UncmUgaW4gRGVjZW1iZXIgaW4gYSB6b25lIHRoYXRcbi8vIG9ic2VydmVzIERTVCksIGJ1dCB3ZSBjYW4gY2hlY2sgYW5kIGFkanVzdCB0aGF0LlxuLy9cbi8vIFdoZW4gaGFuZGxpbmcgbWFueSBkYXRlcywgY2FsY3VsYXRpbmcgdGhlIG9mZnNldCBmb3Igbm93IGV2ZXJ5IHRpbWUgaXNcbi8vIGV4cGVuc2l2ZS4gSXQncyBqdXN0IGEgZ3Vlc3MsIHNvIHdlIGNhbiBjYWNoZSB0aGUgb2Zmc2V0IHRvIHVzZSBldmVuIGlmIHdlXG4vLyBhcmUgcmlnaHQgb24gYSB0aW1lIGNoYW5nZSBib3VuZGFyeSAod2UnbGwganVzdCBjb3JyZWN0IGluIHRoZSBvdGhlclxuLy8gZGlyZWN0aW9uKS4gVXNpbmcgYSB0aW1lc3RhbXAgZnJvbSBmaXJzdCByZWFkIGlzIGEgc2xpZ2h0IG9wdGltaXphdGlvbiBmb3Jcbi8vIGhhbmRsaW5nIGRhdGVzIGNsb3NlIHRvIHRoZSBjdXJyZW50IGRhdGUsIHNpbmNlIHRob3NlIGRhdGVzIHdpbGwgdXN1YWxseSBiZVxuLy8gaW4gdGhlIHNhbWUgb2Zmc2V0ICh3ZSBjb3VsZCBzZXQgdGhlIHRpbWVzdGFtcCBzdGF0aWNhbGx5LCBpbnN0ZWFkKS4gV2UgdXNlIGFcbi8vIHNpbmdsZSB0aW1lc3RhbXAgZm9yIGFsbCB6b25lcyB0byBtYWtlIHRoaW5ncyBhIGJpdCBtb3JlIHByZWRpY3RhYmxlLlxuLy9cbi8vIFRoaXMgaXMgc2FmZSBmb3IgcXVpY2tEVCAodXNlZCBieSBsb2NhbCgpIGFuZCB1dGMoKSkgYmVjYXVzZSB3ZSBkb24ndCBmaWxsIGluXG4vLyBoaWdoZXItb3JkZXIgdW5pdHMgZnJvbSB0c05vdyAoYXMgd2UgZG8gaW4gZnJvbU9iamVjdCwgdGhpcyByZXF1aXJlcyB0aGF0XG4vLyBvZmZzZXQgaXMgY2FsY3VsYXRlZCBmcm9tIHRzTm93KS5cbi8qKlxuICogQHBhcmFtIHtab25lfSB6b25lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGd1ZXNzT2Zmc2V0Rm9yWm9uZSh6b25lKSB7XG4gIGlmICh6b25lT2Zmc2V0VHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHpvbmVPZmZzZXRUcyA9IFNldHRpbmdzLm5vdygpO1xuICB9XG5cbiAgLy8gRG8gbm90IGNhY2hlIGFueXRoaW5nIGJ1dCBJQU5BIHpvbmVzLCBiZWNhdXNlIGl0IGlzIG5vdCBzYWZlIHRvIGRvIHNvLlxuICAvLyBHdWVzc2luZyBhbiBvZmZzZXQgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gdGhlIHpvbmUgY2FuIGNhdXNlIHdyb25nIHJlc3VsdHMgZnJvbSBmaXhPZmZzZXRcbiAgaWYgKHpvbmUudHlwZSAhPT0gXCJpYW5hXCIpIHtcbiAgICByZXR1cm4gem9uZS5vZmZzZXQoem9uZU9mZnNldFRzKTtcbiAgfVxuICBjb25zdCB6b25lTmFtZSA9IHpvbmUubmFtZTtcbiAgbGV0IG9mZnNldEd1ZXNzID0gem9uZU9mZnNldEd1ZXNzQ2FjaGUuZ2V0KHpvbmVOYW1lKTtcbiAgaWYgKG9mZnNldEd1ZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHpvbmVPZmZzZXRUcyk7XG4gICAgem9uZU9mZnNldEd1ZXNzQ2FjaGUuc2V0KHpvbmVOYW1lLCBvZmZzZXRHdWVzcyk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldEd1ZXNzO1xufVxuXG4vLyB0aGlzIGlzIGEgZHVtYmVkIGRvd24gdmVyc2lvbiBvZiBmcm9tT2JqZWN0KCkgdGhhdCBydW5zIGFib3V0IDYwJSBmYXN0ZXJcbi8vIGJ1dCBkb2Vzbid0IGRvIGFueSB2YWxpZGF0aW9uLCBtYWtlcyBhIGJ1bmNoIG9mIGFzc3VtcHRpb25zIGFib3V0IHdoYXQgdW5pdHNcbi8vIGFyZSBwcmVzZW50LCBhbmQgc28gb24uXG5mdW5jdGlvbiBxdWlja0RUKG9iaiwgb3B0cykge1xuICBjb25zdCB6b25lID0gbm9ybWFsaXplWm9uZShvcHRzLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgaWYgKCF6b25lLmlzVmFsaWQpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICB9XG5cbiAgY29uc3QgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyk7XG5cbiAgbGV0IHRzLCBvO1xuXG4gIC8vIGFzc3VtZSB3ZSBoYXZlIHRoZSBoaWdoZXItb3JkZXIgdW5pdHNcbiAgaWYgKCFpc1VuZGVmaW5lZChvYmoueWVhcikpIHtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQob2JqW3VdKSkge1xuICAgICAgICBvYmpbdV0gPSBkZWZhdWx0VW5pdFZhbHVlc1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB8fCBoYXNJbnZhbGlkVGltZURhdGEob2JqKTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0UHJvdmlzID0gZ3Vlc3NPZmZzZXRGb3Jab25lKHpvbmUpO1xuICAgIFt0cywgb10gPSBvYmpUb1RTKG9iaiwgb2Zmc2V0UHJvdmlzLCB6b25lKTtcbiAgfSBlbHNlIHtcbiAgICB0cyA9IFNldHRpbmdzLm5vdygpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IHRzLCB6b25lLCBsb2MsIG8gfSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZSZWxhdGl2ZShzdGFydCwgZW5kLCBvcHRzKSB7XG4gIGNvbnN0IHJvdW5kID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZCkgPyB0cnVlIDogb3B0cy5yb3VuZCxcbiAgICByb3VuZGluZyA9IGlzVW5kZWZpbmVkKG9wdHMucm91bmRpbmcpID8gXCJ0cnVuY1wiIDogb3B0cy5yb3VuZGluZyxcbiAgICBmb3JtYXQgPSAoYywgdW5pdCkgPT4ge1xuICAgICAgYyA9IHJvdW5kVG8oYywgcm91bmQgfHwgb3B0cy5jYWxlbmRhcnkgPyAwIDogMiwgb3B0cy5jYWxlbmRhcnkgPyBcInJvdW5kXCIgOiByb3VuZGluZyk7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBlbmQubG9jLmNsb25lKG9wdHMpLnJlbEZvcm1hdHRlcihvcHRzKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGMsIHVuaXQpO1xuICAgIH0sXG4gICAgZGlmZmVyID0gKHVuaXQpID0+IHtcbiAgICAgIGlmIChvcHRzLmNhbGVuZGFyeSkge1xuICAgICAgICBpZiAoIWVuZC5oYXNTYW1lKHN0YXJ0LCB1bml0KSkge1xuICAgICAgICAgIHJldHVybiBlbmQuc3RhcnRPZih1bml0KS5kaWZmKHN0YXJ0LnN0YXJ0T2YodW5pdCksIHVuaXQpLmdldCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCk7XG4gICAgICB9XG4gICAgfTtcblxuICBpZiAob3B0cy51bml0KSB7XG4gICAgcmV0dXJuIGZvcm1hdChkaWZmZXIob3B0cy51bml0KSwgb3B0cy51bml0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdW5pdCBvZiBvcHRzLnVuaXRzKSB7XG4gICAgY29uc3QgY291bnQgPSBkaWZmZXIodW5pdCk7XG4gICAgaWYgKE1hdGguYWJzKGNvdW50KSA+PSAxKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzdGFydCA+IGVuZCA/IC0wIDogMCwgb3B0cy51bml0c1tvcHRzLnVuaXRzLmxlbmd0aCAtIDFdKTtcbn1cblxuZnVuY3Rpb24gbGFzdE9wdHMoYXJnTGlzdCkge1xuICBsZXQgb3B0cyA9IHt9LFxuICAgIGFyZ3M7XG4gIGlmIChhcmdMaXN0Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICAgIG9wdHMgPSBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV07XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCkuc2xpY2UoMCwgYXJnTGlzdC5sZW5ndGggLSAxKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KTtcbiAgfVxuICByZXR1cm4gW29wdHMsIGFyZ3NdO1xufVxuXG4vKipcbiAqIFRpbWVzdGFtcCB0byB1c2UgZm9yIGNhY2hlZCB6b25lIG9mZnNldCBndWVzc2VzIChleHBvc2VkIGZvciB0ZXN0KVxuICovXG5sZXQgem9uZU9mZnNldFRzO1xuLyoqXG4gKiBDYWNoZSBmb3Igem9uZSBvZmZzZXQgZ3Vlc3NlcyAoZXhwb3NlZCBmb3IgdGVzdCkuXG4gKlxuICogVGhpcyBvcHRpbWl6ZXMgcXVpY2tEVCB2aWEgZ3Vlc3NPZmZzZXRGb3Jab25lIHRvIGF2b2lkIHJlcGVhdGVkIGNhbGxzIG9mXG4gKiB6b25lLm9mZnNldCgpLlxuICovXG5jb25zdCB6b25lT2Zmc2V0R3Vlc3NDYWNoZSA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBBIERhdGVUaW1lIGlzIGFuIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBzcGVjaWZpYyBkYXRlIGFuZCB0aW1lIGFuZCBhY2NvbXBhbnlpbmcgbWV0aG9kcy4gSXQgY29udGFpbnMgY2xhc3MgYW5kIGluc3RhbmNlIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogQSBEYXRlVGltZSBjb21wcmlzZXMgb2Y6XG4gKiAqIEEgdGltZXN0YW1wLiBFYWNoIERhdGVUaW1lIGluc3RhbmNlIHJlZmVycyB0byBhIHNwZWNpZmljIG1pbGxpc2Vjb25kIG9mIHRoZSBVbml4IGVwb2NoLlxuICogKiBBIHRpbWUgem9uZS4gRWFjaCBpbnN0YW5jZSBpcyBjb25zaWRlcmVkIGluIHRoZSBjb250ZXh0IG9mIGEgc3BlY2lmaWMgem9uZSAoYnkgZGVmYXVsdCB0aGUgbG9jYWwgc3lzdGVtJ3Mgem9uZSkuXG4gKiAqIENvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0aGF0IGVmZmVjdCBob3cgb3V0cHV0IHN0cmluZ3MgYXJlIGZvcm1hdHRlZCwgc3VjaCBhcyBgbG9jYWxlYCwgYG51bWJlcmluZ1N5c3RlbWAsIGFuZCBgb3V0cHV0Q2FsZW5kYXJgLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIGZ1bmN0aW9uYWxpdHkgaXQgcHJvdmlkZXM6XG4gKlxuICogKiAqKkNyZWF0aW9uKio6IFRvIGNyZWF0ZSBhIERhdGVUaW1lIGZyb20gaXRzIGNvbXBvbmVudHMsIHVzZSBvbmUgb2YgaXRzIGZhY3RvcnkgY2xhc3MgbWV0aG9kczoge0BsaW5rIERhdGVUaW1lLmxvY2FsfSwge0BsaW5rIERhdGVUaW1lLnV0Y30sIGFuZCAobW9zdCBmbGV4aWJseSkge0BsaW5rIERhdGVUaW1lLmZyb21PYmplY3R9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBzdGFuZGFyZCBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21JU099LCB7QGxpbmsgRGF0ZVRpbWUuZnJvbUhUVFB9LCBhbmQge0BsaW5rIERhdGVUaW1lLmZyb21SRkMyODIyfS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgY3VzdG9tIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUZvcm1hdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIG5hdGl2ZSBKUyBkYXRlLCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21KU0RhdGV9LlxuICogKiAqKkdyZWdvcmlhbiBjYWxlbmRhciBhbmQgdGltZSoqOiBUbyBleGFtaW5lIHRoZSBHcmVnb3JpYW4gcHJvcGVydGllcyBvZiBhIERhdGVUaW1lIGluZGl2aWR1YWxseSAoaS5lIGFzIG9wcG9zZWQgdG8gY29sbGVjdGl2ZWx5IHRocm91Z2gge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSksIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbW9udGh9LFxuICoge0BsaW5rIERhdGVUaW1lI2RheX0sIHtAbGluayBEYXRlVGltZSNob3VyfSwge0BsaW5rIERhdGVUaW1lI21pbnV0ZX0sIHtAbGluayBEYXRlVGltZSNzZWNvbmR9LCB7QGxpbmsgRGF0ZVRpbWUjbWlsbGlzZWNvbmR9IGFjY2Vzc29ycy5cbiAqICogKipXZWVrIGNhbGVuZGFyKio6IEZvciBJU08gd2VlayBjYWxlbmRhciBhdHRyaWJ1dGVzLCBzZWUgdGhlIHtAbGluayBEYXRlVGltZSN3ZWVrWWVhcn0sIHtAbGluayBEYXRlVGltZSN3ZWVrTnVtYmVyfSwgYW5kIHtAbGluayBEYXRlVGltZSN3ZWVrZGF5fSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSB0aGUge0BsaW5rIERhdGVUaW1lI2xvY2FsZX0gYW5kIHtAbGluayBEYXRlVGltZSNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqOiBUbyB0cmFuc2Zvcm0gdGhlIERhdGVUaW1lIGludG8gb3RoZXIgRGF0ZVRpbWVzLCB1c2Uge0BsaW5rIERhdGVUaW1lI3NldH0sIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0sIHtAbGluayBEYXRlVGltZSNzZXRab25lfSwge0BsaW5rIERhdGVUaW1lI3NldExvY2FsZX0sIHtAbGluayBEYXRlVGltZS5wbHVzfSwge0BsaW5rIERhdGVUaW1lI21pbnVzfSwge0BsaW5rIERhdGVUaW1lI2VuZE9mfSwge0BsaW5rIERhdGVUaW1lI3N0YXJ0T2Z9LCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9LCBhbmQge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9LlxuICogKiAqKk91dHB1dCoqOiBUbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmV9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZUNhbGVuZGFyfSwge0BsaW5rIERhdGVUaW1lI3RvSlNPTn0sIHtAbGluayBEYXRlVGltZSN0b0lTT30sIHtAbGluayBEYXRlVGltZSN0b0hUVFB9LCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SRkMyODIyfSwge0BsaW5rIERhdGVUaW1lI3RvU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSwge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfSBhbmQge0BsaW5rIERhdGVUaW1lI3RvSlNEYXRlfS5cbiAqXG4gKiBUaGVyZSdzIHBsZW50eSBvdGhlcnMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24sIHRpbWUgem9uZXMsIGFsdGVybmF0aXZlIGNhbGVuZGFycywgdmFsaWRpdHksIGFuZCBzbyBvbiwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlVGltZSB7XG4gIC8qKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IHpvbmUgPSBjb25maWcuem9uZSB8fCBTZXR0aW5ncy5kZWZhdWx0Wm9uZTtcblxuICAgIGxldCBpbnZhbGlkID1cbiAgICAgIGNvbmZpZy5pbnZhbGlkIHx8XG4gICAgICAoTnVtYmVyLmlzTmFOKGNvbmZpZy50cykgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsKSB8fFxuICAgICAgKCF6b25lLmlzVmFsaWQgPyB1bnN1cHBvcnRlZFpvbmUoem9uZSkgOiBudWxsKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRzID0gaXNVbmRlZmluZWQoY29uZmlnLnRzKSA/IFNldHRpbmdzLm5vdygpIDogY29uZmlnLnRzO1xuXG4gICAgbGV0IGMgPSBudWxsLFxuICAgICAgbyA9IG51bGw7XG4gICAgaWYgKCFpbnZhbGlkKSB7XG4gICAgICBjb25zdCB1bmNoYW5nZWQgPSBjb25maWcub2xkICYmIGNvbmZpZy5vbGQudHMgPT09IHRoaXMudHMgJiYgY29uZmlnLm9sZC56b25lLmVxdWFscyh6b25lKTtcblxuICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICBbYywgb10gPSBbY29uZmlnLm9sZC5jLCBjb25maWcub2xkLm9dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IGhhcyBiZWVuIHBhc3NlZCBhbmQgd2UgaGF2ZSBub3QgYmVlbiBjYWxsZWQgZnJvbVxuICAgICAgICAvLyBjbG9uZSgpLCB3ZSBjYW4gdHJ1c3QgaXQgYW5kIGF2b2lkIHRoZSBvZmZzZXQgY2FsY3VsYXRpb24uXG4gICAgICAgIGNvbnN0IG90ID0gaXNOdW1iZXIoY29uZmlnLm8pICYmICFjb25maWcub2xkID8gY29uZmlnLm8gOiB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgYyA9IHRzVG9PYmoodGhpcy50cywgb3QpO1xuICAgICAgICBpbnZhbGlkID0gTnVtYmVyLmlzTmFOKGMueWVhcikgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsO1xuICAgICAgICBjID0gaW52YWxpZCA/IG51bGwgOiBjO1xuICAgICAgICBvID0gaW52YWxpZCA/IG51bGwgOiBvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl96b25lID0gem9uZTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53ZWVrRGF0YSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2NhbFdlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmMgPSBjO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubyA9IG87XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRGF0ZVRpbWUgPSB0cnVlO1xuICB9XG5cbiAgLy8gQ09OU1RSVUNUXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZvciB0aGUgY3VycmVudCBpbnN0YW50LCBpbiB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKlxuICAgKiBVc2UgU2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vfj4gbm93IGluIHRoZSBJU08gZm9ybWF0XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhbCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGBsb2NhbCgpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoeyB6b25lOiBcIkFtZXJpY2EvTmV3X1lvcmtcIiB9KSAgICAgIC8vfj4gbm93LCBpbiBVUyBlYXN0IGNvYXN0IHRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMCwgd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIHsgem9uZTogXCJ1dGNcIiB9KSAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMCwgaW4gVVRDXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSkgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBsb2NhbCgpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGluIFVUQ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGB1dGMoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLndlZWtTZXR0aW5nc10gLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyB1dGMoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcblxuICAgIG9wdHMuem9uZSA9IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTRGF0ZShkYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0cyA9IGlzRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogTmFOO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odHMpKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcImludmFsaWQgaW5wdXRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHMsXG4gICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud2Vla1NldHRpbmdzIC0gdGhlIHdlZWsgc2V0dGluZ3MgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIobWlsbGlzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbU1pbGxpcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dCwgYnV0IHJlY2VpdmVkIGEgJHt0eXBlb2YgbWlsbGlzZWNvbmRzfSB3aXRoIHZhbHVlICR7bWlsbGlzZWNvbmRzfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAtTUFYX0RBVEUgfHwgbWlsbGlzZWNvbmRzID4gTUFYX0RBVEUpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgcGVyZmVjdCBiZWNhdXNlIHdlIGNhbiBzdGlsbCBlbmQgdXAgb3V0IG9mIHJhbmdlIGJlY2F1c2Ugb2YgYWRkaXRpb25hbCBzaGlmdGluZywgYnV0IGl0J3MgYSBzdGFydFxuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJUaW1lc3RhbXAgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgLSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNvbmRzKHNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIoc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21TZWNvbmRzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHNlY29uZHMgKiAxMDAwLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcicgYW5kICdob3VyJyB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXIgLSBhIHllYXIsIHN1Y2ggYXMgMTk4N1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoIC0gYSBtb250aCwgMS0xMlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheSAtIGEgZGF5IG9mIHRoZSBtb250aCwgMS0zMSwgZGVwZW5kaW5nIG9uIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm9yZGluYWwgLSBkYXkgb2YgdGhlIHllYXIsIDEtMzY1IG9yIDM2NlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtZZWFyIC0gYW4gSVNPIHdlZWsgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtOdW1iZXIgLSBhbiBJU08gd2VlayBudW1iZXIsIGJldHdlZW4gMSBhbmQgNTIgb3IgNTMsIGRlcGVuZGluZyBvbiB0aGUgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtkYXkgLSBhbiBJU08gd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5sb2NhbFdlZWtZZWFyIC0gYSB3ZWVrIHllYXIsIGFjY29yZGluZyB0byB0aGUgbG9jYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubG9jYWxXZWVrTnVtYmVyIC0gYSB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyLCBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmxvY2FsV2Vla2RheSAtIGEgd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIHRoZSBmaXJzdCBhbmQgNyBpcyB0aGUgbGFzdCBkYXkgb2YgdGhlIHdlZWssIGFjY29yZGluZyB0byB0aGUgbG9jYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91ciAtIGhvdXIgb2YgdGhlIGRheSwgMC0yM1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZSAtIG1pbnV0ZSBvZiB0aGUgaG91ciwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZCAtIHNlY29uZCBvZiB0aGUgbWludXRlLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCAwLTk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGludGVycHJldCB0aGUgbnVtYmVycyBpbiB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXIgem9uZS4gQ2FuIHRha2UgYW55IHZhbHVlIHRha2VuIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBzZXRab25lKClcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtXFwncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiwgbW9udGg6IDUsIGRheTogMjV9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiB9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9KSAvL34+IHRvZGF5IGF0IDEwOjI2OjA2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ3V0YycgfSksXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ2xvY2FsJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgd2Vla1llYXI6IDIwMTYsIHdlZWtOdW1iZXI6IDIsIHdlZWtkYXk6IDMgfSkudG9JU09EYXRlKCkgLy89PiAnMjAxNi0wMS0xMydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGxvY2FsV2Vla1llYXI6IDIwMjIsIGxvY2FsV2Vla051bWJlcjogMSwgbG9jYWxXZWVrZGF5OiAxIH0sIHsgbG9jYWxlOiBcImVuLVVTXCIgfSkudG9JU09EYXRlKCkgLy89PiAnMjAyMS0xMi0yNidcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKTtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplVW5pdFdpdGhMb2NhbFdlZWtzKTtcbiAgICBjb25zdCB7IG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWsgfSA9IHVzZXNMb2NhbFdlZWtWYWx1ZXMobm9ybWFsaXplZCwgbG9jKTtcblxuICAgIGNvbnN0IHRzTm93ID0gU2V0dGluZ3Mubm93KCksXG4gICAgICBvZmZzZXRQcm92aXMgPSAhaXNVbmRlZmluZWQob3B0cy5zcGVjaWZpY09mZnNldClcbiAgICAgICAgPyBvcHRzLnNwZWNpZmljT2Zmc2V0XG4gICAgICAgIDogem9uZVRvVXNlLm9mZnNldCh0c05vdyksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyO1xuXG4gICAgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlV2Vla0RhdGEgPSBkZWZpbml0ZVdlZWtEZWYgfHwgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3IpO1xuXG4gICAgLy8gY29uZmlndXJlIG91cnNlbHZlcyB0byBkZWFsIHdpdGggZ3JlZ29yaWFuIGRhdGVzIG9yIHdlZWsgc3R1ZmZcbiAgICBsZXQgdW5pdHMsXG4gICAgICBkZWZhdWx0VmFsdWVzLFxuICAgICAgb2JqTm93ID0gdHNUb09iaih0c05vdywgb2Zmc2V0UHJvdmlzKTtcbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93LCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VW5pdFZhbHVlcztcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG1pc3Npbmcgc3R1ZmZcbiAgICBsZXQgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdSBvZiB1bml0cykge1xuICAgICAgY29uc3QgdiA9IG5vcm1hbGl6ZWRbdV07XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHYpKSB7XG4gICAgICAgIGZvdW5kRmlyc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZpcnN0KSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBkZWZhdWx0VmFsdWVzW3VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IG9iak5vd1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuICAgIGNvbnN0IGhpZ2hlck9yZGVySW52YWxpZCA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gaGFzSW52YWxpZFdlZWtEYXRhKG5vcm1hbGl6ZWQsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gaGFzSW52YWxpZE9yZGluYWxEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEobm9ybWFsaXplZCksXG4gICAgICBpbnZhbGlkID0gaGlnaGVyT3JkZXJJbnZhbGlkIHx8IGhhc0ludmFsaWRUaW1lRGF0YShub3JtYWxpemVkKTtcblxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBhY3R1YWwgdGltZVxuICAgIGNvbnN0IGdyZWdvcmlhbiA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gd2Vla1RvR3JlZ29yaWFuKG5vcm1hbGl6ZWQsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gb3JkaW5hbFRvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogbm9ybWFsaXplZCxcbiAgICAgIFt0c0ZpbmFsLCBvZmZzZXRGaW5hbF0gPSBvYmpUb1RTKGdyZWdvcmlhbiwgb2Zmc2V0UHJvdmlzLCB6b25lVG9Vc2UpLFxuICAgICAgaW5zdCA9IG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiB0c0ZpbmFsLFxuICAgICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICAgIG86IG9mZnNldEZpbmFsLFxuICAgICAgICBsb2MsXG4gICAgICB9KTtcblxuICAgIC8vIGdyZWdvcmlhbiBkYXRhICsgd2Vla2RheSBzZXJ2ZXMgb25seSB0byB2YWxpZGF0ZVxuICAgIGlmIChub3JtYWxpemVkLndlZWtkYXkgJiYgY29udGFpbnNHcmVnb3IgJiYgb2JqLndlZWtkYXkgIT09IGluc3Qud2Vla2RheSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICAgIFwibWlzbWF0Y2hlZCB3ZWVrZGF5XCIsXG4gICAgICAgIGB5b3UgY2FuJ3Qgc3BlY2lmeSBib3RoIGEgd2Vla2RheSBvZiAke25vcm1hbGl6ZWQud2Vla2RheX0gYW5kIGEgZGF0ZSBvZiAke2luc3QudG9JU08oKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaW5zdC5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnN0LmludmFsaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMud2Vla1NldHRpbmdzXSAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcsIHtzZXRab25lOiB0cnVlfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnLCB7em9uZTogJ3V0Yyd9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LVcwNS00JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUlTT0RhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJJU08gODYwMVwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSB0aGUgb2Zmc2V0IGlzIGFsd2F5cyBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMzoxMiBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignRnJpLCAyNSBOb3YgMjAxNiAxMzoyMzoxMiArMDYwMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMyBaJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJGQzI4MjIodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgSFRUUCBkYXRlcyBhcmUgYWx3YXlzIGluIFVUQywgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggdGhlIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nLiBGb3IgSFRUUCBkYXRlcywgdGhpcyBpcyBhbHdheXMgVVRDLCBzbyB0aGlzIG9wdGlvbiBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhlIGB6b25lYCBvcHRpb24gdG8gJ3V0YycsIGJ1dCB0aGlzIG9wdGlvbiBpcyBpbmNsdWRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBzaW1pbGFyIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4sIDA2IE5vdiAxOTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW5kYXksIDA2LU5vdi05NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuIE5vdiAgNiAwODo0OTozNyAxOTk0JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUhUVFAodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VIVFRQRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIkhUVFBcIiwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvcGFyc2luZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53ZWVrU2V0dGluZ3MgLSB0aGUgd2VlayBzZXR0aW5ncyB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFt2YWxzLCBwYXJzZWRab25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZF0gPSBwYXJzZUZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBgZm9ybWF0ICR7Zm10fWAsIHRleHQsIHNwZWNpZmljT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBTUUwgZGF0ZSwgdGltZSwgb3IgZGF0ZXRpbWVcbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndlZWtTZXR0aW5ncyAtIHRoZSB3ZWVrIHNldHRpbmdzIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycsIHsgc2V0Wm9uZTogdHJ1ZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicsIHsgem9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzA5OjEyOjM0LjM0MicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TUUwodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VTUUwodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJTUUxcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIERhdGVUaW1lIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRlVGltZUVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIERhdGVUaW1lLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkRhdGVUaW1lKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSBmb3JtYXQgc3RyaW5nIGZvciBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzXG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VGb3JtYXRGb3JPcHRzKGZvcm1hdE9wdHMsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRva2VuTGlzdCA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuICF0b2tlbkxpc3QgPyBudWxsIDogdG9rZW5MaXN0Lm1hcCgodCkgPT4gKHQgPyB0LnZhbCA6IG51bGwpKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIHRoZSBmdWxseSBleHBhbmRlZCBmb3JtYXQgdG9rZW4gZm9yIHRoZSBsb2NhbGVcbiAgICogRG9lcyBOT1QgcXVvdGUgY2hhcmFjdGVycywgc28gcXVvdGVkIHRva2VucyB3aWxsIG5vdCByb3VuZCB0cmlwIGNvcnJlY3RseVxuICAgKiBAcGFyYW0gZm10XG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXhwYW5kRm9ybWF0KGZtdCwgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiBleHBhbmRlZC5tYXAoKHQpID0+IHQudmFsKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgem9uZU9mZnNldFRzID0gdW5kZWZpbmVkO1xuICAgIHpvbmVPZmZzZXRHdWVzc0NhY2hlLmNsZWFyKCk7XG4gIH1cblxuICAvLyBJTkZPXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ21vbnRoJyk7IC8vPT4gN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ2RheScpOyAvLz0+IDRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1t1bml0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIHZhbGlkLiBJbnZhbGlkIERhdGVUaW1lcyBvY2N1ciB3aGVuOlxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBmcm9tIGludmFsaWQgY2FsZW5kYXIgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIDEzdGggbW9udGggb3IgRmVicnVhcnkgMzBcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgYnkgYW4gb3BlcmF0aW9uIG9uIGFub3RoZXIgaW52YWxpZCBkYXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYWxlIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2VuLUdCJy4gVGhlIGxvY2FsZSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvdXRwdXQgY2FsZW5kYXIgb2YgYSBEYXRlVGltZSwgc3VjaCAnaXNsYW1pYycuIFRoZSBvdXRwdXQgY2FsZW5kYXIgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm91dHB1dENhbGVuZGFyIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbWUgem9uZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBEYXRlVGltZS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBnZXQgem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB6b25lTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLm5hbWUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkueWVhciAvLz0+IDIwMTdcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMueWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnF1YXJ0ZXIgLy89PiAyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5jZWlsKHRoaXMuYy5tb250aCAvIDMpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggKDEtMTIpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkubW9udGggLy89PiA1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5tb250aCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgbW9udGggKDEtMzBpc2gpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuZGF5IC8vPT4gMjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5kYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3VyIG9mIHRoZSBkYXkgKDAtMjMpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSkuaG91ciAvLz0+IDlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuaG91ciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCkubWludXRlIC8vPT4gMzBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taW51dGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIpLnNlY29uZCAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCAoMC05OTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyLCA2NTQpLm1pbGxpc2Vjb25kIC8vPT4gNjU0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taWxsaXNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTIsIDMxKS53ZWVrWWVhciAvLz0+IDIwMTVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSB3ZWVrIHllYXIgKDEtNTJpc2gpLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLndlZWtOdW1iZXIgLy89PiAyMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla051bWJlciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMSwgMzEpLndlZWtkYXkgLy89PiA0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRhdGUgaXMgb24gYSB3ZWVrZW5kIGFjY29yZGluZyB0byB0aGUgbG9jYWxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNXZWVrZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgJiYgdGhpcy5sb2MuZ2V0V2Vla2VuZERheXMoKS5pbmNsdWRlcyh0aGlzLndlZWtkYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrIGFjY29yZGluZyB0byB0aGUgbG9jYWxlLlxuICAgKiAxIGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgYW5kIDcgaXMgdGhlIGxhc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBJZiB0aGUgbG9jYWxlIGFzc2lnbnMgU3VuZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWssIHRoZW4gYSBkYXRlIHdoaWNoIGlzIGEgU3VuZGF5IHdpbGwgcmV0dXJuIDEsXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbG9jYWxXZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSB3ZWVrIHllYXIgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUuIERpZmZlcmVudCBsb2NhbGVzIGFzc2lnbiB3ZWVrIG51bWJlcnMgZGlmZmVyZW50bHksXG4gICAqIGJlY2F1c2UgdGhlIHdlZWsgY2FuIHN0YXJ0IG9uIGRpZmZlcmVudCBkYXlzIG9mIHRoZSB3ZWVrIChzZWUgbG9jYWxXZWVrZGF5KSBhbmQgYmVjYXVzZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZGF5c1xuICAgKiBpcyByZXF1aXJlZCBmb3IgYSB3ZWVrIHRvIGNvdW50IGFzIHRoZSBmaXJzdCB3ZWVrIG9mIGEgeWVhci5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbFdlZWtOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YSh0aGlzKS53ZWVrTnVtYmVyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayB5ZWFyIGFjY29yZGluZyB0byB0aGUgbG9jYWxlLiBEaWZmZXJlbnQgbG9jYWxlcyBhc3NpZ24gd2VlayBudW1iZXJzIChhbmQgdGhlcmVmb3Igd2VlayB5ZWFycylcbiAgICogZGlmZmVyZW50bHksIHNlZSBsb2NhbFdlZWtOdW1iZXIuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbG9jYWxXZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKHRoaXMpLndlZWtZZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JkaW5hbCAobWVhbmluZyB0aGUgZGF5IG9mIHRoZSB5ZWFyKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkub3JkaW5hbCAvLz0+IDE0NVxuICAgKiBAdHlwZSB7bnVtYmVyfERhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IG9yZGluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLm9yZGluYWwgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCBtb250aCBuYW1lLCBzdWNoIGFzICdPY3QnLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aFNob3J0IC8vPT4gT2N0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0b2JlcicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoTG9uZyAvLz0+IE9jdG9iZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aExvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IHdlZWtkYXksIHN1Y2ggYXMgJ01vbicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlTaG9ydCAvLz0+IE1vblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIHdlZWtkYXksIHN1Y2ggYXMgJ01vbmRheScuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlMb25nIC8vPT4gTW9uZGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheUxvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBVVEMgb2Zmc2V0IG9mIHRoaXMgRGF0ZVRpbWUgaW4gbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5vZmZzZXQgLy89PiAtMjQwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLm9mZnNldCAvLz0+IDBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/ICt0aGlzLm8gOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVTVFwiIG9yIFwiRURUXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVTaG9ydCgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwic2hvcnRcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb25nIGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRWFzdGVybiBTdGFuZGFyZCBUaW1lXCIgb3IgXCJFYXN0ZXJuIERheWxpZ2h0IFRpbWVcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZUxvbmcoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcImxvbmdcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhpcyB6b25lJ3Mgb2Zmc2V0IGV2ZXIgY2hhbmdlcywgYXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzT2Zmc2V0Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5pc1VuaXZlcnNhbCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luRFNUKCkge1xuICAgIGlmICh0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiAxLCBkYXk6IDEgfSkub2Zmc2V0IHx8XG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogNSB9KS5vZmZzZXRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aG9zZSBEYXRlVGltZXMgd2hpY2ggaGF2ZSB0aGUgc2FtZSBsb2NhbCB0aW1lIGFzIHRoaXMgRGF0ZVRpbWUsIGJ1dCBhIGRpZmZlcmVudCBvZmZzZXQgZnJvbSBVVENcbiAgICogaW4gdGhpcyBEYXRlVGltZSdzIHpvbmUuIER1cmluZyBEU1QgY2hhbmdlcyBsb2NhbCB0aW1lIGNhbiBiZSBhbWJpZ3VvdXMsIGZvciBleGFtcGxlXG4gICAqIGAyMDIzLTEwLTI5VDAyOjMwOjAwYCBpbiBgRXVyb3BlL0JlcmxpbmAgY2FuIGhhdmUgb2Zmc2V0IGArMDE6MDBgIG9yIGArMDI6MDBgLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBib3RoIHBvc3NpYmxlIERhdGVUaW1lcyBpZiB0aGlzIERhdGVUaW1lJ3MgbG9jYWwgdGltZSBpcyBhbWJpZ3VvdXMuXG4gICAqIEByZXR1cm5zIHtEYXRlVGltZVtdfVxuICAgKi9cbiAgZ2V0UG9zc2libGVPZmZzZXRzKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8IHRoaXMuaXNPZmZzZXRGaXhlZCkge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgY29uc3QgZGF5TXMgPSA4NjQwMDAwMDtcbiAgICBjb25zdCBtaW51dGVNcyA9IDYwMDAwO1xuICAgIGNvbnN0IGxvY2FsVFMgPSBvYmpUb0xvY2FsVFModGhpcy5jKTtcbiAgICBjb25zdCBvRWFybGllciA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIGRheU1zKTtcbiAgICBjb25zdCBvTGF0ZXIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgKyBkYXlNcyk7XG5cbiAgICBjb25zdCBvMSA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIG9FYXJsaWVyICogbWludXRlTXMpO1xuICAgIGNvbnN0IG8yID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gb0xhdGVyICogbWludXRlTXMpO1xuICAgIGlmIChvMSA9PT0gbzIpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGNvbnN0IHRzMSA9IGxvY2FsVFMgLSBvMSAqIG1pbnV0ZU1zO1xuICAgIGNvbnN0IHRzMiA9IGxvY2FsVFMgLSBvMiAqIG1pbnV0ZU1zO1xuICAgIGNvbnN0IGMxID0gdHNUb09iaih0czEsIG8xKTtcbiAgICBjb25zdCBjMiA9IHRzVG9PYmoodHMyLCBvMik7XG4gICAgaWYgKFxuICAgICAgYzEuaG91ciA9PT0gYzIuaG91ciAmJlxuICAgICAgYzEubWludXRlID09PSBjMi5taW51dGUgJiZcbiAgICAgIGMxLnNlY29uZCA9PT0gYzIuc2Vjb25kICYmXG4gICAgICBjMS5taWxsaXNlY29uZCA9PT0gYzIubWlsbGlzZWNvbmRcbiAgICApIHtcbiAgICAgIHJldHVybiBbY2xvbmUodGhpcywgeyB0czogdHMxIH0pLCBjbG9uZSh0aGlzLCB7IHRzOiB0czIgfSldO1xuICAgIH1cbiAgICByZXR1cm4gW3RoaXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIERhdGVUaW1lIGlzIGluIGEgbGVhcCB5ZWFyLCBmYWxzZSBvdGhlcndpc2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNikuaXNJbkxlYXBZZWFyIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS5pc0luTGVhcFllYXIgLy89PiBmYWxzZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luTGVhcFllYXIoKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgbW9udGhcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMikuZGF5c0luTW9udGggLy89PiAyOVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAzKS5kYXlzSW5Nb250aCAvLz0+IDMxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5c0luTW9udGgoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNikuZGF5c0luWWVhciAvLz0+IDM2NlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS5kYXlzSW5ZZWFyIC8vPT4gMzY1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5c0luWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZGF5c0luWWVhcih0aGlzLnllYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAwNCkud2Vla3NJbldlZWtZZWFyIC8vPT4gNTNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykud2Vla3NJbldlZWtZZWFyIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrc0luV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHdlZWtzSW5XZWVrWWVhcih0aGlzLndlZWtZZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIGxvY2FsIHdlZWsgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDIwLCA2LCB7bG9jYWxlOiAnZW4tVVMnfSkud2Vla3NJbkxvY2FsV2Vla1llYXIgLy89PiA1MlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDIwLCA2LCB7bG9jYWxlOiAnZGUtREUnfSkud2Vla3NJbkxvY2FsV2Vla1llYXIgLy89PiA1M1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzSW5Mb2NhbFdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gd2Vla3NJbldlZWtZZWFyKFxuICAgICAgICAgIHRoaXMubG9jYWxXZWVrWWVhcixcbiAgICAgICAgICB0aGlzLmxvYy5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSxcbiAgICAgICAgICB0aGlzLmxvYy5nZXRTdGFydE9mV2VlaygpXG4gICAgICAgIClcbiAgICAgIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdmVkIEludGwgb3B0aW9ucyBmb3IgdGhpcyBEYXRlVGltZS5cbiAgICogVGhpcyBpcyB1c2VmdWwgaW4gdW5kZXJzdGFuZGluZyB0aGUgYmVoYXZpb3Igb2YgZm9ybWF0dGluZyBtZXRob2RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gdGhlIHNhbWUgb3B0aW9ucyBhcyB0b0xvY2FsZVN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICByZXNvbHZlZExvY2FsZU9wdGlvbnMob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IEZvcm1hdHRlci5jcmVhdGUoXG4gICAgICB0aGlzLmxvYy5jbG9uZShvcHRzKSxcbiAgICAgIG9wdHNcbiAgICApLnJlc29sdmVkT3B0aW9ucyh0aGlzKTtcbiAgICByZXR1cm4geyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXI6IGNhbGVuZGFyIH07XG4gIH1cblxuICAvLyBUUkFOU0ZPUk1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIFVUQy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIHtAbGluayBEYXRlVGltZSNzZXRab25lfSgndXRjJylcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBvcHRpb25hbGx5LCBhbiBvZmZzZXQgZnJvbSBVVEMgaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gb3B0aW9ucyB0byBwYXNzIHRvIGBzZXRab25lKClgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9VVEMob2Zmc2V0ID0gMCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2Uob2Zmc2V0KSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHRoZSBob3N0J3MgbG9jYWwgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzZXRab25lKCdsb2NhbCcpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHNwZWNpZmllZCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBzZXR0ZXIga2VlcHMgdGhlIHVuZGVybHlpbmcgdGltZSB0aGUgc2FtZSAoYXMgaW4sIHRoZSBzYW1lIHRpbWVzdGFtcCksIGJ1dCB0aGUgbmV3IGluc3RhbmNlIHdpbGwgcmVwb3J0IGRpZmZlcmVudCBsb2NhbCB0aW1lcyBhbmQgY29uc2lkZXIgRFNUcyB3aGVuIG1ha2luZyBjb21wdXRhdGlvbnMsIGFzIHdpdGgge0BsaW5rIERhdGVUaW1lI3BsdXN9LiBZb3UgbWF5IHdpc2ggdG8gdXNlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfSBhbmQge0BsaW5rIERhdGVUaW1lI3RvVVRDfSB3aGljaCBwcm92aWRlIHNpbXBsZSBjb252ZW5pZW5jZSB3cmFwcGVycyBmb3IgY29tbW9ubHkgdXNlZCB6b25lcy5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBhIHpvbmUgaWRlbnRpZmllci4gQXMgYSBzdHJpbmcsIHRoYXQgY2FuIGJlIGFueSBJQU5BIHpvbmUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IGVudmlyb25tZW50LCBvciBhIGZpeGVkLW9mZnNldCBuYW1lIG9mIHRoZSBmb3JtICdVVEMrMycsIG9yIHRoZSBzdHJpbmdzICdsb2NhbCcgb3IgJ3V0YycuIFlvdSBtYXkgYWxzbyBzdXBwbHkgYW4gaW5zdGFuY2Ugb2YgYSB7QGxpbmsgRGF0ZVRpbWUjWm9uZX0gY2xhc3MuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmtlZXBMb2NhbFRpbWU9ZmFsc2VdIC0gSWYgdHJ1ZSwgYWRqdXN0IHRoZSB1bmRlcmx5aW5nIHRpbWUgc28gdGhhdCB0aGUgbG9jYWwgdGltZSBzdGF5cyB0aGUgc2FtZSwgYnV0IGluIHRoZSB0YXJnZXQgem9uZS4gWW91IHNob3VsZCByYXJlbHkgbmVlZCB0aGlzLlxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldFpvbmUoem9uZSwgeyBrZWVwTG9jYWxUaW1lID0gZmFsc2UsIGtlZXBDYWxlbmRhclRpbWUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICB6b25lID0gbm9ybWFsaXplWm9uZSh6b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKHpvbmUuZXF1YWxzKHRoaXMuem9uZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoIXpvbmUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5ld1RTID0gdGhpcy50cztcbiAgICAgIGlmIChrZWVwTG9jYWxUaW1lIHx8IGtlZXBDYWxlbmRhclRpbWUpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0R3Vlc3MgPSB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgY29uc3QgYXNPYmogPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIFtuZXdUU10gPSBvYmpUb1RTKGFzT2JqLCBvZmZzZXRHdWVzcywgem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0czogbmV3VFMsIHpvbmUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvciBvdXRwdXRDYWxlbmRhci4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIHRoZSBwcm9wZXJ0aWVzIHRvIHNldFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyBsb2MgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEp1c3QgYSBjb252ZW5pZW50IGFsaWFzIGZvciByZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuc2V0TG9jYWxlKCdlbi1HQicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgIHJldHVybiB0aGlzLnJlY29uZmlndXJlKHsgbG9jYWxlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogWW91IGNhbiBvbmx5IHNldCB1bml0cyB3aXRoIHRoaXMgbWV0aG9kOyBmb3IgXCJzZXR0aW5nXCIgbWV0YWRhdGEsIHNlZSB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGFsc28gc3VwcG9ydHMgc2V0dGluZyBsb2NhbGUtYmFzZWQgd2VlayB1bml0cywgaS5lLiBgbG9jYWxXZWVrZGF5YCwgYGxvY2FsV2Vla051bWJlcmAgYW5kIGBsb2NhbFdlZWtZZWFyYC5cbiAgICogVGhleSBjYW5ub3QgYmUgbWl4ZWQgd2l0aCBJU08td2VlayB1bml0cyBsaWtlIGB3ZWVrZGF5YC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgaG91cjogOCwgbWludXRlOiAzMCB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB3ZWVrZGF5OiA1IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMDUsIG9yZGluYWw6IDIzNCB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdFdpdGhMb2NhbFdlZWtzKTtcbiAgICBjb25zdCB7IG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWsgfSA9IHVzZXNMb2NhbFdlZWtWYWx1ZXMobm9ybWFsaXplZCwgdGhpcy5sb2MpO1xuXG4gICAgY29uc3Qgc2V0dGluZ1dlZWtTdHVmZiA9XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtZZWFyKSB8fFxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrTnVtYmVyKSB8fFxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrZGF5KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXI7XG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgbGV0IG1peGVkO1xuICAgIGlmIChzZXR0aW5nV2Vla1N0dWZmKSB7XG4gICAgICBtaXhlZCA9IHdlZWtUb0dyZWdvcmlhbihcbiAgICAgICAgeyAuLi5ncmVnb3JpYW5Ub1dlZWsodGhpcy5jLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKSwgLi4ubm9ybWFsaXplZCB9LFxuICAgICAgICBtaW5EYXlzSW5GaXJzdFdlZWssXG4gICAgICAgIHN0YXJ0T2ZXZWVrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCkpIHtcbiAgICAgIG1peGVkID0gb3JkaW5hbFRvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1peGVkID0geyAuLi50aGlzLnRvT2JqZWN0KCksIC4uLm5vcm1hbGl6ZWQgfTtcblxuICAgICAgLy8gaWYgd2UgZGlkbid0IHNldCB0aGUgZGF5IGJ1dCB3ZSBlbmRlZCB1cCBvbiBhbiBvdmVyZmxvdyBkYXRlLFxuICAgICAgLy8gdXNlIHRoZSBsYXN0IGRheSBvZiB0aGUgcmlnaHQgbW9udGhcbiAgICAgIGlmIChpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSkpIHtcbiAgICAgICAgbWl4ZWQuZGF5ID0gTWF0aC5taW4oZGF5c0luTW9udGgobWl4ZWQueWVhciwgbWl4ZWQubW9udGgpLCBtaXhlZC5kYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFt0cywgb10gPSBvYmpUb1RTKG1peGVkLCB0aGlzLm8sIHRoaXMuem9uZSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdHMsIG8gfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICpcbiAgICogQWRkaW5nIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBvciBtaWxsaXNlY29uZHMgaW5jcmVhc2VzIHRoZSB0aW1lc3RhbXAgYnkgdGhlIHJpZ2h0IG51bWJlciBvZiBtaWxsaXNlY29uZHMuIEFkZGluZyBkYXlzLCBtb250aHMsIG9yIHllYXJzIHNoaWZ0cyB0aGUgY2FsZW5kYXIsIGFjY291bnRpbmcgZm9yIERTVHMgYW5kIGxlYXAgeWVhcnMgYWxvbmcgdGhlIHdheS4gVGh1cywgYGR0LnBsdXMoeyBob3VyczogMjQgfSlgIG1heSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdGltZSB0aGFuIGBkdC5wbHVzKHsgZGF5czogMSB9KWAgaWYgdGhlcmUncyBhIERTVCBzaGlmdCBpbiBiZXR3ZWVuLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoMTIzKSAvL34+IGluIDEyMyBtaWxsaXNlY29uZHNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IG1pbnV0ZXM6IDE1IH0pIC8vfj4gaW4gMTUgbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KSAvL34+IHRoaXMgdGltZSB0b21vcnJvd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogLTEgfSkgLy9+PiB0aGlzIHRpbWUgeWVzdGVyZGF5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBob3VyczogMywgbWludXRlczogMTMgfSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyhEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pKSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIGFkanVzdFRpbWUodGhpcywgZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3QgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI3BsdXN9XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIHN1YnRyYWN0LiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHVuaXQgb2YgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgYmVnaW5uaW5nIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy51c2VMb2NhbGVXZWVrcz1mYWxzZV0gLSBJZiB0cnVlLCB1c2Ugd2Vla3MgYmFzZWQgb24gdGhlIGxvY2FsZSwgaS5lLiB1c2UgdGhlIGxvY2FsZS1kZXBlbmRlbnQgc3RhcnQgb2YgdGhlIHdlZWtcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignbW9udGgnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZigneWVhcicpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd3ZWVrJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDMnLCB3ZWVrcyBhbHdheXMgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignZGF5JykudG9JU09UaW1lKCk7IC8vPT4gJzAwOjAwLjAwMC0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2hvdXInKS50b0lTT1RpbWUoKTsgLy89PiAnMDU6MDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXJ0T2YodW5pdCwgeyB1c2VMb2NhbGVXZWVrcyA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG8gPSB7fSxcbiAgICAgIG5vcm1hbGl6ZWRVbml0ID0gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KTtcbiAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRVbml0KSB7XG4gICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgby5tb250aCA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwicXVhcnRlcnNcIjpcbiAgICAgIGNhc2UgXCJtb250aHNcIjpcbiAgICAgICAgby5kYXkgPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBvLmhvdXIgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcImhvdXJzXCI6XG4gICAgICAgIG8ubWludXRlID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJtaW51dGVzXCI6XG4gICAgICAgIG8uc2Vjb25kID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJzZWNvbmRzXCI6XG4gICAgICAgIG8ubWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBubyBkZWZhdWx0LCBpbnZhbGlkIHVuaXRzIHRocm93IGluIG5vcm1hbGl6ZVVuaXQoKVxuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJ3ZWVrc1wiKSB7XG4gICAgICBpZiAodXNlTG9jYWxlV2Vla3MpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRPZldlZWsgPSB0aGlzLmxvYy5nZXRTdGFydE9mV2VlaygpO1xuICAgICAgICBjb25zdCB7IHdlZWtkYXkgfSA9IHRoaXM7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgc3RhcnRPZldlZWspIHtcbiAgICAgICAgICBvLndlZWtOdW1iZXIgPSB0aGlzLndlZWtOdW1iZXIgLSAxO1xuICAgICAgICB9XG4gICAgICAgIG8ud2Vla2RheSA9IHN0YXJ0T2ZXZWVrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgby53ZWVrZGF5ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZFVuaXQgPT09IFwicXVhcnRlcnNcIikge1xuICAgICAgY29uc3QgcSA9IE1hdGguY2VpbCh0aGlzLm1vbnRoIC8gMyk7XG4gICAgICBvLm1vbnRoID0gKHEgLSAxKSAqIDMgKyAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldChvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGVuZCAobWVhbmluZyB0aGUgbGFzdCBtaWxsaXNlY29uZCkgb2YgYSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgZW5kIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy51c2VMb2NhbGVXZWVrcz1mYWxzZV0gLSBJZiB0cnVlLCB1c2Ugd2Vla3MgYmFzZWQgb24gdGhlIGxvY2FsZSwgaS5lLiB1c2UgdGhlIGxvY2FsZS1kZXBlbmRlbnQgc3RhcnQgb2YgdGhlIHdlZWtcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ21vbnRoJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd5ZWFyJykudG9JU08oKTsgLy89PiAnMjAxNC0xMi0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd3ZWVrJykudG9JU08oKTsgLy8gPT4gJzIwMTQtMDMtMDlUMjM6NTk6NTkuOTk5LTA1OjAwJywgd2Vla3Mgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2RheScpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2hvdXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDA1OjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBlbmRPZih1bml0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB0aGlzLnBsdXMoeyBbdW5pdF06IDEgfSlcbiAgICAgICAgICAuc3RhcnRPZih1bml0LCBvcHRzKVxuICAgICAgICAgIC5taW51cygxKVxuICAgICAgOiB0aGlzO1xuICB9XG5cbiAgLy8gT1VUUFVUXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy5cbiAgICogKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZSBmb3JtYXR0aW5nIHRvb2wuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL2Zvcm1hdHRpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdmcicpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJywgeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5yZWRlZmF1bHRUb0VOKG9wdHMpKS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIGRhdGUuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGUgSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhcyBgRGF0ZVRpbWUuREFURV9GVUxMYCBvciBgRGF0ZVRpbWUuVElNRV9TSU1QTEVgLlxuICAgKiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIERhdGVUaW1lIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zIGFuZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDQvMjAvMjAxN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2VuLWdiJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiAnQXByaWwgMjAsIDIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmcicgfSk7IC8vPT4gJzI4IGFvw7t0IDIwMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiAnMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnbG9uZycsIG1vbnRoOiAnbG9uZycsIGRheTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHVyc2RheSwgQXByaWwgMjAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHUsIEFwciAyMCwgMTE6MjcgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91ckN5Y2xlOiAnaDIzJyB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0RGF0ZVRpbWUodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdCBcInBhcnRzXCIsIG1lYW5pbmcgaW5kaXZpZHVhbCB0b2tlbnMgYWxvbmcgd2l0aCBtZXRhZGF0YS4gVGhpcyBpcyBhbGxvd3MgY2FsbGVycyB0byBwb3N0LXByb2Nlc3MgaW5kaXZpZHVhbCBzZWN0aW9ucyBvZiB0aGUgZm9ybWF0dGVkIG91dHB1dC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0c1xuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucywgc2FtZSBhcyBgdG9Mb2NhbGVTdHJpbmdgLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVBhcnRzKCk7IC8vPT4gW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2RheScsIHZhbHVlOiAnMjUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdtb250aCcsIHZhbHVlOiAnMDUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICd5ZWFyJywgdmFsdWU6ICcxOTgyJyB9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+IF1cbiAgICovXG4gIHRvTG9jYWxlUGFydHMob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5mb3JtYXREYXRlVGltZVBhcnRzKHRoaXMpXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT1mYWxzZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJlY2lzaW9uPSdtaWxsaXNlY29uZHMnXSAtIHRydW5jYXRlIG91dHB1dCB0byBkZXNpcmVkIHByZXNpY2lvbjogJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycgb3IgJ21pbGxpc2Vjb25kcycuIFdoZW4gcHJlY2lzaW9uIGFuZCBzdXBwcmVzc1NlY29uZHMgb3Igc3VwcHJlc3NNaWxsaXNlY29uZHMgYXJlIHVzZWQgdG9nZXRoZXIsIHByZWNpc2lvbiBzZXRzIHRoZSBtYXhpbXVtIHVuaXQgc2hvd24gaW4gdGhlIG91dHB1dCwgaG93ZXZlciBzZWNvbmRzIG9yIG1pbGxpc2Vjb25kcyB3aWxsIHN0aWxsIGJlIHN1cHByZXNzZWQgaWYgdGhleSBhcmUgMC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODMsIDUsIDI1KS50b0lTTygpIC8vPT4gJzE5ODItMDUtMjVUMDA6MDA6MDAuMDAwWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oKSAvLz0+ICcyMDE3LTA0LTIyVDIwOjQ3OjA1LjMzNS0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcyMDE3LTA0LTIyVDIwOjQ3OjA1LjMzNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMjAxNzA0MjJUMjA0NzA1LjMzNS0wNDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IHByZWNpc2lvbjogJ2RheScgfSkgLy89PiAnMjAxNy0wNC0yMlonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgcHJlY2lzaW9uOiAnbWludXRlJyB9KSAvLz0+ICcyMDE3LTA0LTIyVDIwOjQ3WidcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gICAqL1xuICB0b0lTTyh7XG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgZXh0ZW5kZWRab25lID0gZmFsc2UsXG4gICAgcHJlY2lzaW9uID0gXCJtaWxsaXNlY29uZHNcIixcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByZWNpc2lvbiA9IG5vcm1hbGl6ZVVuaXQocHJlY2lzaW9uKTtcbiAgICBjb25zdCBleHQgPSBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIjtcblxuICAgIGxldCBjID0gdG9JU09EYXRlKHRoaXMsIGV4dCwgcHJlY2lzaW9uKTtcbiAgICBpZiAob3JkZXJlZFVuaXRzLmluZGV4T2YocHJlY2lzaW9uKSA+PSAzKSBjICs9IFwiVFwiO1xuICAgIGMgKz0gdG9JU09UaW1lKFxuICAgICAgdGhpcyxcbiAgICAgIGV4dCxcbiAgICAgIHN1cHByZXNzU2Vjb25kcyxcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgaW5jbHVkZU9mZnNldCxcbiAgICAgIGV4dGVuZGVkWm9uZSxcbiAgICAgIHByZWNpc2lvblxuICAgICk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyBkYXRlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wcmVjaXNpb249J2RheSddIC0gdHJ1bmNhdGUgb3V0cHV0IHRvIGRlc2lyZWQgcHJlY2lzaW9uOiAneWVhcnMnLCAnbW9udGhzJywgb3IgJ2RheXMnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzE5ODIwNTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IHByZWNpc2lvbjogJ21vbnRoJyB9KSAvLz0+ICcxOTgyLTA1J1xuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICovXG4gIHRvSVNPRGF0ZSh7IGZvcm1hdCA9IFwiZXh0ZW5kZWRcIiwgcHJlY2lzaW9uID0gXCJkYXlcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b0lTT0RhdGUodGhpcywgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIsIG5vcm1hbGl6ZVVuaXQocHJlY2lzaW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB3ZWVrIGRhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT1dlZWtEYXRlKCkgLy89PiAnMTk4Mi1XMjEtMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09XZWVrRGF0ZSgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwia2tray0nVydXVy1jXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgdGltZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPXRydWVdIC0gYWRkIHRoZSB0aW1lIHpvbmUgZm9ybWF0IGV4dGVuc2lvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByZWNpc2lvbj0nbWlsbGlzZWNvbmRzJ10gLSB0cnVuY2F0ZSBvdXRwdXQgdG8gZGVzaXJlZCBwcmVzaWNpb246ICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnIG9yICdtaWxsaXNlY29uZHMnLiBXaGVuIHByZWNpc2lvbiBhbmQgc3VwcHJlc3NTZWNvbmRzIG9yIHN1cHByZXNzTWlsbGlzZWNvbmRzIGFyZSB1c2VkIHRvZ2V0aGVyLCBwcmVjaXNpb24gc2V0cyB0aGUgbWF4aW11bSB1bml0IHNob3duIGluIHRoZSBvdXRwdXQsIGhvd2V2ZXIgc2Vjb25kcyBvciBtaWxsaXNlY29uZHMgd2lsbCBzdGlsbCBiZSBzdXBwcmVzc2VkIGlmIHRoZXkgYXJlIDAuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDA3OjM0OjE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQsIHNlY29uZDogNTYgfSkudG9JU09UaW1lKHsgcHJlY2lzaW9uOiAnbWludXRlJyB9KSAvLz0+ICcwNzozNFonXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZSh7XG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgZXh0ZW5kZWRab25lID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICAgIHByZWNpc2lvbiA9IFwibWlsbGlzZWNvbmRzXCIsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcmVjaXNpb24gPSBub3JtYWxpemVVbml0KHByZWNpc2lvbik7XG4gICAgbGV0IGMgPSBpbmNsdWRlUHJlZml4ICYmIG9yZGVyZWRVbml0cy5pbmRleE9mKHByZWNpc2lvbikgPj0gMyA/IFwiVFwiIDogXCJcIjtcbiAgICByZXR1cm4gKFxuICAgICAgYyArXG4gICAgICB0b0lTT1RpbWUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiLFxuICAgICAgICBzdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgICBleHRlbmRlZFpvbmUsXG4gICAgICAgIHByZWNpc2lvblxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBSRkMgMjgyMi1jb21wYXRpYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCArMDAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgLTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvUkZDMjgyMigpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyBaWlpcIiwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEhUVFAgaGVhZGVycy4gVGhlIG91dHB1dCBpcyBhbHdheXMgZXhwcmVzc2VkIGluIEdNVC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgc3RyaW5nIGNvbmZvcm1zIHRvIFJGQyAxMTIzLlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgR01UJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMsIDE5KS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDE5OjAwOjAwIEdNVCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9IVFRQKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcy50b1VUQygpLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgJ0dNVCdcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIERhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTERhdGUoKSAvLz0+ICcyMDE0LTA3LTEzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICovXG4gIHRvU1FMRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b0lTT0RhdGUodGhpcywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIFRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTFRpbWUoeyBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSwgaW5jbHVkZVpvbmUgPSBmYWxzZSwgaW5jbHVkZU9mZnNldFNwYWNlID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBsZXQgZm10ID0gXCJISDptbTpzcy5TU1NcIjtcblxuICAgIGlmIChpbmNsdWRlWm9uZSB8fCBpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICBpZiAoaW5jbHVkZU9mZnNldFNwYWNlKSB7XG4gICAgICAgIGZtdCArPSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlWm9uZSkge1xuICAgICAgICBmbXQgKz0gXCJ6XCI7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgICAgZm10ICs9IFwiWlpcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIGZtdCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXRTcGFjZT10cnVlXSAtIGluY2x1ZGUgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHRpbWUgYW5kIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlWm9uZTogdHJ1ZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMudG9TUUxEYXRlKCl9ICR7dGhpcy50b1NRTFRpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0lTTygpIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHRoZSBSRVBMLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gYERhdGVUaW1lIHsgdHM6ICR7dGhpcy50b0lTTygpfSwgem9uZTogJHt0aGlzLnpvbmUubmFtZX0sIGxvY2FsZTogJHt0aGlzLmxvY2FsZX0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgRGF0ZVRpbWUgeyBJbnZhbGlkLCByZWFzb246ICR7dGhpcy5pbnZhbGlkUmVhc29ufSB9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuIEFsaWFzIG9mIHtAbGluayBEYXRlVGltZSN0b01pbGxpc31cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b01pbGxpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIChpbmNsdWRpbmcgbWlsbGlzZWNvbmRzIGluIHRoZSBmcmFjdGlvbmFsIHBhcnQpIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50cyAvIDEwMDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyAoYXMgYSB3aG9sZSBudW1iZXIpIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvVW5peEludGVnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguZmxvb3IodGhpcy50cyAvIDEwMDApIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCU09OIHNlcmlhbGl6YWJsZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU0RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIERhdGVUaW1lJ3MgeWVhciwgbW9udGgsIGRheSwgYW5kIHNvIG9uLlxuICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVDb25maWc9ZmFsc2VdIC0gaW5jbHVkZSBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgaW4gdGhlIG91dHB1dFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b09iamVjdCgpIC8vPT4geyB5ZWFyOiAyMDE3LCBtb250aDogNCwgZGF5OiAyMiwgaG91cjogMjAsIG1pbnV0ZTogNDksIHNlY29uZDogNDIsIG1pbGxpc2Vjb25kOiAyNjggfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgYmFzZSA9IHsgLi4udGhpcy5jIH07XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLm91dHB1dENhbGVuZGFyID0gdGhpcy5vdXRwdXRDYWxlbmRhcjtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IERhdGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9KU0RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU4pO1xuICB9XG5cbiAgLy8gQ09NUEFSRVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gRGF0ZVRpbWVzIGFzIGEgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgRGF0ZVRpbWUgdG8gY29tcGFyZSB0aGlzIG9uZSB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciBhcnJheSBvZiB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaTEgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgyLTA1LTI1VDA5OjQ1JyksXG4gICAqICAgICBpMiA9IERhdGVUaW1lLmZyb21JU08oJzE5ODMtMTAtMTRUMTA6MzAnKTtcbiAgICogaTIuZGlmZihpMSkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA0MzgwNzUwMDAwMCB9XG4gICAqIGkyLmRpZmYoaTEsICdob3VycycpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMjE2OC43NSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTkuMDMxMjUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LCBob3VyczogMC43NSB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZihvdGhlckRhdGVUaW1lLCB1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyRGF0ZVRpbWUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJjcmVhdGVkIGJ5IGRpZmZpbmcgYW4gaW52YWxpZCBEYXRlVGltZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJPcHRzID0geyBsb2NhbGU6IHRoaXMubG9jYWxlLCBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLCAuLi5vcHRzIH07XG5cbiAgICBjb25zdCB1bml0cyA9IG1heWJlQXJyYXkodW5pdCkubWFwKER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgb3RoZXJJc0xhdGVyID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCkgPiB0aGlzLnZhbHVlT2YoKSxcbiAgICAgIGVhcmxpZXIgPSBvdGhlcklzTGF0ZXIgPyB0aGlzIDogb3RoZXJEYXRlVGltZSxcbiAgICAgIGxhdGVyID0gb3RoZXJJc0xhdGVyID8gb3RoZXJEYXRlVGltZSA6IHRoaXMsXG4gICAgICBkaWZmZWQgPSBkaWZmKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgZHVyT3B0cyk7XG5cbiAgICByZXR1cm4gb3RoZXJJc0xhdGVyID8gZGlmZmVkLm5lZ2F0ZSgpIDogZGlmZmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIHJpZ2h0IG5vdy5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNkaWZmfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZk5vdyh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlmZihEYXRlVGltZS5ub3coKSwgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHNwYW5uaW5nIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgYW5vdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIGVuZCBwb2ludCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHJldHVybiB7SW50ZXJ2YWx8RGF0ZVRpbWV9XG4gICAqL1xuICB1bnRpbChvdGhlckRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEludGVydmFsLmZyb21EYXRlVGltZXModGhpcywgb3RoZXJEYXRlVGltZSkgOiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgRGF0ZVRpbWUgaXMgaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lIGFzIGFub3RoZXIgRGF0ZVRpbWUuXG4gICAqIEhpZ2hlci1vcmRlciB1bml0cyBtdXN0IGFsc28gYmUgaWRlbnRpY2FsIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiBgdHJ1ZWAuXG4gICAqIE5vdGUgdGhhdCB0aW1lIHpvbmVzIGFyZSAqKmlnbm9yZWQqKiBpbiB0aGlzIGNvbXBhcmlzb24sIHdoaWNoIGNvbXBhcmVzIHRoZSAqKmxvY2FsKiogY2FsZW5kYXIgdGltZS4gVXNlIHtAbGluayBEYXRlVGltZSNzZXRab25lfSB0byBjb252ZXJ0IG9uZSBvZiB0aGUgZGF0ZXMgaWYgbmVlZGVkLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy51c2VMb2NhbGVXZWVrcz1mYWxzZV0gLSBJZiB0cnVlLCB1c2Ugd2Vla3MgYmFzZWQgb24gdGhlIGxvY2FsZSwgaS5lLiB1c2UgdGhlIGxvY2FsZS1kZXBlbmRlbnQgc3RhcnQgb2YgdGhlIHdlZWs7IG9ubHkgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lIGlzIHVzZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuaGFzU2FtZShvdGhlckRULCAnZGF5Jyk7IC8vfj4gdHJ1ZSBpZiBvdGhlckRUIGlzIGluIHRoZSBzYW1lIGN1cnJlbnQgY2FsZW5kYXIgZGF5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKG90aGVyRGF0ZVRpbWUsIHVuaXQsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaW5wdXRNcyA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpO1xuICAgIGNvbnN0IGFkanVzdGVkVG9ab25lID0gdGhpcy5zZXRab25lKG90aGVyRGF0ZVRpbWUuem9uZSwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pO1xuICAgIHJldHVybiAoXG4gICAgICBhZGp1c3RlZFRvWm9uZS5zdGFydE9mKHVuaXQsIG9wdHMpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSBhZGp1c3RlZFRvWm9uZS5lbmRPZih1bml0LCBvcHRzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIERhdGVUaW1lcyBhcmUgZXF1YWwgaWYgYW5kIG9ubHkgaWYgdGhleSByZXByZXNlbnQgdGhlIHNhbWUgbWlsbGlzZWNvbmQsIGhhdmUgdGhlIHNhbWUgem9uZSBhbmQgbG9jYXRpb24sIGFuZCBhcmUgYm90aCB2YWxpZC5cbiAgICogVG8gY29tcGFyZSBqdXN0IHRoZSBtaWxsaXNlY29uZCB2YWx1ZXMsIHVzZSBgK2R0MSA9PT0gK2R0MmAuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pc1ZhbGlkICYmXG4gICAgICBvdGhlci5pc1ZhbGlkICYmXG4gICAgICB0aGlzLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpICYmXG4gICAgICB0aGlzLnpvbmUuZXF1YWxzKG90aGVyLnpvbmUpICYmXG4gICAgICB0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRoaXMgdGltZSByZWxhdGl2ZSB0byBub3csIHN1Y2ggYXMgXCJpbiB0d28gZGF5c1wiLiBDYW4gb25seSBpbnRlcm5hdGlvbmFsaXplIGlmIHlvdXJcbiAgICogcGxhdGZvcm0gc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuIFJvdW5kcyB0b3dhcmRzIHplcm8gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0eWxlPVwibG9uZ1wiXSAtIHRoZSBzdHlsZSBvZiB1bml0cywgbXVzdCBiZSBcImxvbmdcIiwgXCJzaG9ydFwiLCBvciBcIm5hcnJvd1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0IG9yIGFycmF5IG9mIHVuaXRzOyBpZiBvbWl0dGVkLCBvciBhbiBhcnJheSwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIGJlc3QgdW5pdC4gVXNlIGFuIGFycmF5IG9yIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgb3IgXCJzZWNvbmRzXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZD10cnVlXSAtIHdoZXRoZXIgdG8gcm91bmQgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJvdW5kaW5nPVwidHJ1bmNcIl0gLSByb3VuZGluZyBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC4gQ2FuIGJlIFwidHJ1bmNcIiAodG93YXJkIHplcm8pLCBcImV4cGFuZFwiIChhd2F5IGZyb20gemVybyksIFwicm91bmRcIiwgXCJmbG9vclwiLCBvciBcImNlaWxcIi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcImluIDEgZGF5XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikudG9SZWxhdGl2ZSh7IGRheXM6IDEgfSkgLy89PiBcImRlbnRybyBkZSAxIGTDrWFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRhbnMgMjMgaGV1cmVzXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKHsgdW5pdDogXCJob3Vyc1wiIH0pIC8vPT4gXCI0OCBob3VycyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGhvdXJzOiAzNiB9KS50b1JlbGF0aXZlKHsgcm91bmQ6IGZhbHNlIH0pIC8vPT4gXCIxLjUgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZShvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYmFzZSA9IG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgPyAodGhpcyA8IGJhc2UgPyAtb3B0aW9ucy5wYWRkaW5nIDogb3B0aW9ucy5wYWRkaW5nKSA6IDA7XG4gICAgbGV0IHVuaXRzID0gW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXTtcbiAgICBsZXQgdW5pdCA9IG9wdGlvbnMudW5pdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnVuaXQpKSB7XG4gICAgICB1bml0cyA9IG9wdGlvbnMudW5pdDtcbiAgICAgIHVuaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUoYmFzZSwgdGhpcy5wbHVzKHBhZGRpbmcpLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhbHdheXNcIixcbiAgICAgIHVuaXRzLFxuICAgICAgdW5pdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZSByZWxhdGl2ZSB0byB0b2RheSwgc3VjaCBhcyBcInllc3RlcmRheVwiIG9yIFwibmV4dCBtb250aFwiLlxuICAgKiBPbmx5IGludGVybmF0aW9uYWxpemVzIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQ7IGlmIG9taXR0ZWQsIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSB1bml0LiBVc2Ugb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIG9yIFwiZGF5c1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcInRvbW9ycm93XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJcIm1hw7FhbmFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGVtYWluXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmVDYWxlbmRhcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSwgdGhpcywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYXV0b1wiLFxuICAgICAgdW5pdHM6IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiXSxcbiAgICAgIGNhbGVuZGFyeTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1pbiBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWluaW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1pbiBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWluKC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtaW4gcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heCBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWF4aW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1heCBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWF4KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXggcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWF4KTtcbiAgfVxuXG4gIC8vIE1JU0NcblxuICAvKipcbiAgICogRXhwbGFpbiBob3cgYSBzdHJpbmcgd291bGQgYmUgcGFyc2VkIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0aW9ucyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSk7XG4gICAgcmV0dXJuIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0RXhwbGFpbiBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZ0V4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIHBhcnNlciBmb3IgYGZtdGAgdXNpbmcgdGhlIGdpdmVuIGxvY2FsZS4gVGhpcyBwYXJzZXIgY2FuIGJlIHBhc3NlZFxuICAgKiB0byB7QGxpbmsgRGF0ZVRpbWUuZnJvbUZvcm1hdFBhcnNlcn0gdG8gYSBwYXJzZSBhIGRhdGUgaW4gdGhpcyBmb3JtYXQuIFRoaXNcbiAgICogY2FuIGJlIHVzZWQgdG8gb3B0aW1pemUgY2FzZXMgd2hlcmUgbWFueSBkYXRlcyBuZWVkIHRvIGJlIHBhcnNlZCBpbiBhXG4gICAqIHNwZWNpZmljIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlXG4gICAqIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdXNlZCB0byBzZXQgbG9jYWxlIGFuZCBudW1iZXJpbmdTeXN0ZW1cbiAgICogZm9yIHBhcnNlclxuICAgKiBAcmV0dXJucyB7VG9rZW5QYXJzZXJ9IC0gb3BhcXVlIG9iamVjdCB0byBiZSB1c2VkXG4gICAqL1xuICBzdGF0aWMgYnVpbGRGb3JtYXRQYXJzZXIoZm10LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdGlvbnMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIHJldHVybiBuZXcgVG9rZW5QYXJzZXIobG9jYWxlVG9Vc2UsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBwYXJzZXIuXG4gICAqXG4gICAqIFRoZSBmb3JtYXQgcGFyc2VyIG11c3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2l0aCB0aGUgc2FtZSBsb2NhbGUgYXMgdGhpcyBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtUb2tlblBhcnNlcn0gZm9ybWF0UGFyc2VyIC0gcGFyc2VyIGZyb20ge0BsaW5rIERhdGVUaW1lLmJ1aWxkRm9ybWF0UGFyc2VyfVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm5zIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0UGFyc2VyKHRleHQsIGZvcm1hdFBhcnNlciwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRleHQpIHx8IGlzVW5kZWZpbmVkKGZvcm1hdFBhcnNlcikpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgXCJmcm9tRm9ybWF0UGFyc2VyIHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXQgcGFyc2VyXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0cyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICBpZiAoIWxvY2FsZVRvVXNlLmVxdWFscyhmb3JtYXRQYXJzZXIubG9jYWxlKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbUZvcm1hdFBhcnNlciBjYWxsZWQgd2l0aCBhIGxvY2FsZSBvZiAke2xvY2FsZVRvVXNlfSwgYCArXG4gICAgICAgICAgYGJ1dCB0aGUgZm9ybWF0IHBhcnNlciB3YXMgY3JlYXRlZCBmb3IgJHtmb3JtYXRQYXJzZXIubG9jYWxlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgeyByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uIH0gPSBmb3JtYXRQYXJzZXIuZXhwbGFpbkZyb21Ub2tlbnModGV4dCk7XG5cbiAgICBpZiAoaW52YWxpZFJlYXNvbikge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZFJlYXNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHpvbmUsXG4gICAgICAgIG9wdHMsXG4gICAgICAgIGBmb3JtYXQgJHtmb3JtYXRQYXJzZXIuZm9ybWF0fWAsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZPUk1BVCBQUkVTRVRTXG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgMTAvMTQvMTk4M1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIE9jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ1R1ZXNkYXksIE9jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMycsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFRFQnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCAxNCBPY3QgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFM7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJpZW5kbHlEYXRlVGltZShkYXRlVGltZWlzaCkge1xuICBpZiAoRGF0ZVRpbWUuaXNEYXRlVGltZShkYXRlVGltZWlzaCkpIHtcbiAgICByZXR1cm4gZGF0ZVRpbWVpc2g7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgZGF0ZVRpbWVpc2gudmFsdWVPZiAmJiBpc051bWJlcihkYXRlVGltZWlzaC52YWx1ZU9mKCkpKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21KU0RhdGUoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIHR5cGVvZiBkYXRlVGltZWlzaCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICBgVW5rbm93biBkYXRldGltZSBhcmd1bWVudDogJHtkYXRlVGltZWlzaH0sIG9mIHR5cGUgJHt0eXBlb2YgZGF0ZVRpbWVpc2h9YFxuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/duration.js":
/*!*************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/duration.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accurateMatrix: () => (/* binding */ accurateMatrix),\n/* harmony export */   casualMatrix: () => (/* binding */ casualMatrix),\n/* harmony export */   daysInMonthAccurate: () => (/* binding */ daysInMonthAccurate),\n/* harmony export */   daysInYearAccurate: () => (/* binding */ daysInYearAccurate),\n/* harmony export */   \"default\": () => (/* binding */ Duration),\n/* harmony export */   lowOrderMatrix: () => (/* binding */ lowOrderMatrix)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/regexParser.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/regexParser.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\");\n\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Duration\";\n\n// unit conversion constants\nconst lowOrderMatrix = {\n    weeks: {\n      days: 7,\n      hours: 7 * 24,\n      minutes: 7 * 24 * 60,\n      seconds: 7 * 24 * 60 * 60,\n      milliseconds: 7 * 24 * 60 * 60 * 1000,\n    },\n    days: {\n      hours: 24,\n      minutes: 24 * 60,\n      seconds: 24 * 60 * 60,\n      milliseconds: 24 * 60 * 60 * 1000,\n    },\n    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },\n    minutes: { seconds: 60, milliseconds: 60 * 1000 },\n    seconds: { milliseconds: 1000 },\n  },\n  casualMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: 52,\n      days: 365,\n      hours: 365 * 24,\n      minutes: 365 * 24 * 60,\n      seconds: 365 * 24 * 60 * 60,\n      milliseconds: 365 * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: 13,\n      days: 91,\n      hours: 91 * 24,\n      minutes: 91 * 24 * 60,\n      seconds: 91 * 24 * 60 * 60,\n      milliseconds: 91 * 24 * 60 * 60 * 1000,\n    },\n    months: {\n      weeks: 4,\n      days: 30,\n      hours: 30 * 24,\n      minutes: 30 * 24 * 60,\n      seconds: 30 * 24 * 60 * 60,\n      milliseconds: 30 * 24 * 60 * 60 * 1000,\n    },\n\n    ...lowOrderMatrix,\n  },\n  daysInYearAccurate = 146097.0 / 400,\n  daysInMonthAccurate = 146097.0 / 4800,\n  accurateMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: daysInYearAccurate / 7,\n      days: daysInYearAccurate,\n      hours: daysInYearAccurate * 24,\n      minutes: daysInYearAccurate * 24 * 60,\n      seconds: daysInYearAccurate * 24 * 60 * 60,\n      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: daysInYearAccurate / 28,\n      days: daysInYearAccurate / 4,\n      hours: (daysInYearAccurate * 24) / 4,\n      minutes: (daysInYearAccurate * 24 * 60) / 4,\n      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,\n      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,\n    },\n    months: {\n      weeks: daysInMonthAccurate / 7,\n      days: daysInMonthAccurate,\n      hours: daysInMonthAccurate * 24,\n      minutes: daysInMonthAccurate * 24 * 60,\n      seconds: daysInMonthAccurate * 24 * 60 * 60,\n      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,\n    },\n    ...lowOrderMatrix,\n  };\n\n// units ordered by size\nconst orderedUnits = [\n  \"years\",\n  \"quarters\",\n  \"months\",\n  \"weeks\",\n  \"days\",\n  \"hours\",\n  \"minutes\",\n  \"seconds\",\n  \"milliseconds\",\n];\n\nconst reverseUnits = orderedUnits.slice(0).reverse();\n\n// clone really means \"create another instance just like this one, but with these changes\"\nfunction clone(dur, alts, clear = false) {\n  // deep merge for vals\n  const conf = {\n    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },\n    loc: dur.loc.clone(alts.loc),\n    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,\n    matrix: alts.matrix || dur.matrix,\n  };\n  return new Duration(conf);\n}\n\nfunction durationToMillis(matrix, vals) {\n  let sum = vals.milliseconds ?? 0;\n  for (const unit of reverseUnits.slice(1)) {\n    if (vals[unit]) {\n      sum += vals[unit] * matrix[unit][\"milliseconds\"];\n    }\n  }\n  return sum;\n}\n\n// NB: mutates parameters\nfunction normalizeValues(matrix, vals) {\n  // the logic below assumes the overall value of the duration is positive\n  // if this is not the case, factor is used to make it so\n  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;\n\n  orderedUnits.reduceRight((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const previousVal = vals[previous] * factor;\n        const conv = matrix[current][previous];\n\n        // if (previousVal < 0):\n        // lower order unit is negative (e.g. { years: 2, days: -2 })\n        // normalize this by reducing the higher order unit by the appropriate amount\n        // and increasing the lower order unit\n        // this can never make the higher order unit negative, because this function only operates\n        // on positive durations, so the amount of time represented by the lower order unit cannot\n        // be larger than the higher order unit\n        // else:\n        // lower order unit is positive (e.g. { years: 2, days: 450 } or { years: -2, days: 450 })\n        // in this case we attempt to convert as much as possible from the lower order unit into\n        // the higher order one\n        //\n        // Math.floor takes care of both of these cases, rounding away from 0\n        // if previousVal < 0 it makes the absolute value larger\n        // if previousVal >= it makes the absolute value smaller\n        const rollUp = Math.floor(previousVal / conv);\n        vals[current] += rollUp * factor;\n        vals[previous] -= rollUp * conv * factor;\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n\n  // try to convert any decimals into smaller units if possible\n  // for example for { years: 2.5, days: 0, seconds: 0 } we want to get { years: 2, days: 182, hours: 12 }\n  orderedUnits.reduce((previous, current) => {\n    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {\n      if (previous) {\n        const fraction = vals[previous] % 1;\n        vals[previous] -= fraction;\n        vals[current] += fraction * matrix[previous][current];\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n}\n\n// Remove all properties with a value of 0 from an object\nfunction removeZeroes(vals) {\n  const newVals = {};\n  for (const [key, value] of Object.entries(vals)) {\n    if (value !== 0) {\n      newVals[key] = value;\n    }\n  }\n  return newVals;\n}\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nclass Duration {\n  /**\n   * @private\n   */\n  constructor(config) {\n    const accurate = config.conversionAccuracy === \"longterm\" || false;\n    let matrix = accurate ? accurateMatrix : casualMatrix;\n\n    if (config.matrix) {\n      matrix = config.matrix;\n    }\n\n    /**\n     * @access private\n     */\n    this.values = config.values;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create();\n    /**\n     * @access private\n     */\n    this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.matrix = matrix;\n    /**\n     * @access private\n     */\n    this.isLuxonDuration = true;\n  }\n\n  /**\n   * Create Duration from a number of milliseconds.\n   * @param {number} count of milliseconds\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  static fromMillis(count, opts) {\n    return Duration.fromObject({ milliseconds: count }, opts);\n  }\n\n  /**\n   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n   * If this object is empty then a zero milliseconds duration is returned.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.years\n   * @param {number} obj.quarters\n   * @param {number} obj.months\n   * @param {number} obj.weeks\n   * @param {number} obj.days\n   * @param {number} obj.hours\n   * @param {number} obj.minutes\n   * @param {number} obj.seconds\n   * @param {number} obj.milliseconds\n   * @param {Object} [opts=[]] - options for creating this Duration\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the custom conversion system to use\n   * @return {Duration}\n   */\n  static fromObject(obj, opts = {}) {\n    if (obj == null || typeof obj !== \"object\") {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Duration.fromObject: argument expected to be an object, got ${\n          obj === null ? \"null\" : typeof obj\n        }`\n      );\n    }\n\n    return new Duration({\n      values: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(obj, Duration.normalizeUnit),\n      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromObject(opts),\n      conversionAccuracy: opts.conversionAccuracy,\n      matrix: opts.matrix,\n    });\n  }\n\n  /**\n   * Create a Duration from DurationLike.\n   *\n   * @param {Object | number | Duration} durationLike\n   * One of:\n   * - object with keys like 'years' and 'hours'.\n   * - number representing milliseconds\n   * - Duration instance\n   * @return {Duration}\n   */\n  static fromDurationLike(durationLike) {\n    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(durationLike)) {\n      return Duration.fromMillis(durationLike);\n    } else if (Duration.isDuration(durationLike)) {\n      return durationLike;\n    } else if (typeof durationLike === \"object\") {\n      return Duration.fromObject(durationLike);\n    } else {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\n        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`\n      );\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 duration string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the preset conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n   * @return {Duration}\n   */\n  static fromISO(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISODuration)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 time string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use\n   * @param {string} [opts.matrix=Object] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @return {Duration}\n   */\n  static fromISOTime(text, opts) {\n    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISOTimeOnly)(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create an invalid Duration.\n   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Duration}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidDurationError(invalid);\n    } else {\n      return new Duration({ invalid });\n    }\n  }\n\n  /**\n   * @private\n   */\n  static normalizeUnit(unit) {\n    const normalized = {\n      year: \"years\",\n      years: \"years\",\n      quarter: \"quarters\",\n      quarters: \"quarters\",\n      month: \"months\",\n      months: \"months\",\n      week: \"weeks\",\n      weeks: \"weeks\",\n      day: \"days\",\n      days: \"days\",\n      hour: \"hours\",\n      hours: \"hours\",\n      minute: \"minutes\",\n      minutes: \"minutes\",\n      second: \"seconds\",\n      seconds: \"seconds\",\n      millisecond: \"milliseconds\",\n      milliseconds: \"milliseconds\",\n    }[unit ? unit.toLowerCase() : unit];\n\n    if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUnitError(unit);\n\n    return normalized;\n  }\n\n  /**\n   * Check if an object is a Duration. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDuration(o) {\n    return (o && o.isLuxonDuration) || false;\n  }\n\n  /**\n   * Get  the locale of a Duration, such 'en-GB'\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n   * * `S` for milliseconds\n   * * `s` for seconds\n   * * `m` for minutes\n   * * `h` for hours\n   * * `d` for days\n   * * `w` for weeks\n   * * `M` for months\n   * * `y` for years\n   * Notes:\n   * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n   * * Tokens can be escaped by wrapping with single quotes.\n   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - options\n   * @param {boolean} [opts.floor=true] - floor numerical values\n   * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n   * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"+6 +2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"all\" }) //=> \"-6 -2\"\n   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat(\"d s\", { signMode: \"negativeLargestOnly\" }) //=> \"-6 2\"\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    // reverse-compat since 1.2; we always round down now, never up, and we do it by default\n    const fmtOpts = {\n      ...opts,\n      floor: opts.round !== false && opts.floor !== false,\n    };\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(this.loc, fmtOpts).formatDurationFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a string representation of a Duration with all units included.\n   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options\n   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.\n   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.\n   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero\n   * @example\n   * ```js\n   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })\n   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'\n   * dur.toHuman({ listStyle: \"long\" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'\n   * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 mth, 0 wks, 5 hr, 6 min'\n   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'\n   * ```\n   */\n  toHuman(opts = {}) {\n    if (!this.isValid) return INVALID;\n\n    const showZeros = opts.showZeros !== false;\n\n    const l = orderedUnits\n      .map((unit) => {\n        const val = this.values[unit];\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(val) || (val === 0 && !showZeros)) {\n          return null;\n        }\n        return this.loc\n          .numberFormatter({ style: \"unit\", unitDisplay: \"long\", ...opts, unit: unit.slice(0, -1) })\n          .format(val);\n      })\n      .filter((n) => n);\n\n    return this.loc\n      .listFormatter({ type: \"conjunction\", style: opts.listStyle || \"narrow\", ...opts })\n      .format(l);\n  }\n\n  /**\n   * Returns a JavaScript object with this Duration's values.\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n   * @return {Object}\n   */\n  toObject() {\n    if (!this.isValid) return {};\n    return { ...this.values };\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n   * @return {string}\n   */\n  toISO() {\n    // we could use the formatter, but this is an easier way to get the minimum string\n    if (!this.isValid) return null;\n\n    let s = \"P\";\n    if (this.years !== 0) s += this.years + \"Y\";\n    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\n    if (this.weeks !== 0) s += this.weeks + \"W\";\n    if (this.days !== 0) s += this.days + \"D\";\n    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)\n      s += \"T\";\n    if (this.hours !== 0) s += this.hours + \"H\";\n    if (this.minutes !== 0) s += this.minutes + \"M\";\n    if (this.seconds !== 0 || this.milliseconds !== 0)\n      // this will handle \"floating point madness\" by removing extra decimal places\n      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken\n      s += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.roundTo)(this.seconds + this.milliseconds / 1000, 3) + \"S\";\n    if (s === \"P\") s += \"T0S\";\n    return s;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n   * @return {string}\n   */\n  toISOTime(opts = {}) {\n    if (!this.isValid) return null;\n\n    const millis = this.toMillis();\n    if (millis < 0 || millis >= 86400000) return null;\n\n    opts = {\n      suppressMilliseconds: false,\n      suppressSeconds: false,\n      includePrefix: false,\n      format: \"extended\",\n      ...opts,\n      includeOffset: false,\n    };\n\n    const dateTime = _datetime_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromMillis(millis, { zone: \"UTC\" });\n    return dateTime.toISOTime(opts);\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n   * @return {string}\n   */\n  toString() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns a string representation of this Duration appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Duration { values: ${JSON.stringify(this.values)} }`;\n    } else {\n      return `Duration { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration.\n   * @return {number}\n   */\n  toMillis() {\n    if (!this.isValid) return NaN;\n\n    return durationToMillis(this.matrix, this.values);\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration),\n      result = {};\n\n    for (const k of orderedUnits) {\n      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(dur.values, k) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(this.values, k)) {\n        result[k] = dur.get(k) + this.get(k);\n      }\n    }\n\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration);\n    return this.plus(dur.negate());\n  }\n\n  /**\n   * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === \"hours\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n   * @return {Duration}\n   */\n  mapUnits(fn) {\n    if (!this.isValid) return this;\n    const result = {};\n    for (const k of Object.keys(this.values)) {\n      result[k] = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.asNumber)(fn(this.values[k], k));\n    }\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n   * @return {number}\n   */\n  get(unit) {\n    return this[Duration.normalizeUnit(unit)];\n  }\n\n  /**\n   * \"Set\" the values of specified units. Return a newly-constructed Duration.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dur.set({ years: 2017 })\n   * @example dur.set({ hours: 8, minutes: 30 })\n   * @return {Duration}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const mixed = { ...this.values, ...(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(values, Duration.normalizeUnit) };\n    return clone(this, { values: mixed });\n  }\n\n  /**\n   * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n   * @example dur.reconfigure({ locale: 'en-GB' })\n   * @return {Duration}\n   */\n  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem });\n    const opts = { loc, matrix, conversionAccuracy };\n    return clone(this, opts);\n  }\n\n  /**\n   * Return the length of the duration in the specified unit.\n   * @param {string} unit - a unit such as 'minutes' or 'days'\n   * @example Duration.fromObject({years: 1}).as('days') //=> 365\n   * @example Duration.fromObject({years: 1}).as('months') //=> 12\n   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\n   * @return {number}\n   */\n  as(unit) {\n    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\n  }\n\n  /**\n   * Reduce this Duration to its canonical representation in its current units.\n   * Assuming the overall value of the Duration is positive, this means:\n   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)\n   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise\n   *   the overall value would be negative, see third example)\n   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)\n   *\n   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.\n   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }\n   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }\n   * @return {Duration}\n   */\n  normalize() {\n    if (!this.isValid) return this;\n    const vals = this.toObject();\n    normalizeValues(this.matrix, vals);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Rescale units to its largest representation\n   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }\n   * @return {Duration}\n   */\n  rescale() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.normalize().shiftToAll().toObject());\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Convert this Duration into its representation in a different set of units.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n   * @return {Duration}\n   */\n  shiftTo(...units) {\n    if (!this.isValid) return this;\n\n    if (units.length === 0) {\n      return this;\n    }\n\n    units = units.map((u) => Duration.normalizeUnit(u));\n\n    const built = {},\n      accumulated = {},\n      vals = this.toObject();\n    let lastUnit;\n\n    for (const k of orderedUnits) {\n      if (units.indexOf(k) >= 0) {\n        lastUnit = k;\n\n        let own = 0;\n\n        // anything we haven't boiled down yet should get boiled to this unit\n        for (const ak in accumulated) {\n          own += this.matrix[ak][k] * accumulated[ak];\n          accumulated[ak] = 0;\n        }\n\n        // plus anything that's already in this unit\n        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n          own += vals[k];\n        }\n\n        // only keep the integer part for now in the hopes of putting any decimal part\n        // into a smaller unit later\n        const i = Math.trunc(own);\n        built[k] = i;\n        accumulated[k] = (own * 1000 - i * 1000) / 1000;\n\n        // otherwise, keep it in the wings to boil it later\n      } else if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {\n        accumulated[k] = vals[k];\n      }\n    }\n\n    // anything leftover becomes the decimal for the last unit\n    // lastUnit must be defined since units is not empty\n    for (const key in accumulated) {\n      if (accumulated[key] !== 0) {\n        built[lastUnit] +=\n          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\n      }\n    }\n\n    normalizeValues(this.matrix, built);\n    return clone(this, { values: built }, true);\n  }\n\n  /**\n   * Shift this Duration to all available units.\n   * Same as shiftTo(\"years\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"milliseconds\")\n   * @return {Duration}\n   */\n  shiftToAll() {\n    if (!this.isValid) return this;\n    return this.shiftTo(\n      \"years\",\n      \"months\",\n      \"weeks\",\n      \"days\",\n      \"hours\",\n      \"minutes\",\n      \"seconds\",\n      \"milliseconds\"\n    );\n  }\n\n  /**\n   * Return the negative of this Duration.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n   * @return {Duration}\n   */\n  negate() {\n    if (!this.isValid) return this;\n    const negated = {};\n    for (const k of Object.keys(this.values)) {\n      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];\n    }\n    return clone(this, { values: negated }, true);\n  }\n\n  /**\n   * Removes all units with values equal to 0 from this Duration.\n   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }\n   * @return {Duration}\n   */\n  removeZeros() {\n    if (!this.isValid) return this;\n    const vals = removeZeroes(this.values);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Get the years.\n   * @type {number}\n   */\n  get years() {\n    return this.isValid ? this.values.years || 0 : NaN;\n  }\n\n  /**\n   * Get the quarters.\n   * @type {number}\n   */\n  get quarters() {\n    return this.isValid ? this.values.quarters || 0 : NaN;\n  }\n\n  /**\n   * Get the months.\n   * @type {number}\n   */\n  get months() {\n    return this.isValid ? this.values.months || 0 : NaN;\n  }\n\n  /**\n   * Get the weeks\n   * @type {number}\n   */\n  get weeks() {\n    return this.isValid ? this.values.weeks || 0 : NaN;\n  }\n\n  /**\n   * Get the days.\n   * @type {number}\n   */\n  get days() {\n    return this.isValid ? this.values.days || 0 : NaN;\n  }\n\n  /**\n   * Get the hours.\n   * @type {number}\n   */\n  get hours() {\n    return this.isValid ? this.values.hours || 0 : NaN;\n  }\n\n  /**\n   * Get the minutes.\n   * @type {number}\n   */\n  get minutes() {\n    return this.isValid ? this.values.minutes || 0 : NaN;\n  }\n\n  /**\n   * Get the seconds.\n   * @return {number}\n   */\n  get seconds() {\n    return this.isValid ? this.values.seconds || 0 : NaN;\n  }\n\n  /**\n   * Get the milliseconds.\n   * @return {number}\n   */\n  get milliseconds() {\n    return this.isValid ? this.values.milliseconds || 0 : NaN;\n  }\n\n  /**\n   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n   * on invalid DateTimes or Intervals.\n   * @return {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this Duration became invalid, or null if the Duration is valid\n   * @return {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Equality check\n   * Two Durations are equal iff they have the same units and the same values for each unit.\n   * @param {Duration} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    if (!this.loc.equals(other.loc)) {\n      return false;\n    }\n\n    function eq(v1, v2) {\n      // Consider 0 and undefined as equal\n      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;\n      return v1 === v2;\n    }\n\n    for (const u of orderedUnits) {\n      if (!eq(this.values[u], other.values[u])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUEyRjtBQUMvQztBQUNKO0FBQ0Y7QUFDcUM7QUFRbkQ7QUFDYTtBQUNBOztBQUVyQzs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYSw2REFBNkQ7QUFDMUUsZUFBZSxzQ0FBc0M7QUFDckQsZUFBZSxvQkFBb0I7QUFDbkMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQyxHQUFHO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZHVyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzTnVtYmVyLFxuICBpc1VuZGVmaW5lZCxcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgIG1hdHJpeDogYWx0cy5tYXRyaXggfHwgZHVyLm1hdHJpeCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEdXJhdGlvbihjb25mKTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Ub01pbGxpcyhtYXRyaXgsIHZhbHMpIHtcbiAgbGV0IHN1bSA9IHZhbHMubWlsbGlzZWNvbmRzID8/IDA7XG4gIGZvciAoY29uc3QgdW5pdCBvZiByZXZlcnNlVW5pdHMuc2xpY2UoMSkpIHtcbiAgICBpZiAodmFsc1t1bml0XSkge1xuICAgICAgc3VtICs9IHZhbHNbdW5pdF0gKiBtYXRyaXhbdW5pdF1bXCJtaWxsaXNlY29uZHNcIl07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlcyhtYXRyaXgsIHZhbHMpIHtcbiAgLy8gdGhlIGxvZ2ljIGJlbG93IGFzc3VtZXMgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIGR1cmF0aW9uIGlzIHBvc2l0aXZlXG4gIC8vIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLCBmYWN0b3IgaXMgdXNlZCB0byBtYWtlIGl0IHNvXG4gIGNvbnN0IGZhY3RvciA9IGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSA8IDAgPyAtMSA6IDE7XG5cbiAgb3JkZXJlZFVuaXRzLnJlZHVjZVJpZ2h0KChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbCA9IHZhbHNbcHJldmlvdXNdICogZmFjdG9yO1xuICAgICAgICBjb25zdCBjb252ID0gbWF0cml4W2N1cnJlbnRdW3ByZXZpb3VzXTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNWYWwgPCAwKTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBuZWdhdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiAtMiB9KVxuICAgICAgICAvLyBub3JtYWxpemUgdGhpcyBieSByZWR1Y2luZyB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgYnkgdGhlIGFwcHJvcHJpYXRlIGFtb3VudFxuICAgICAgICAvLyBhbmQgaW5jcmVhc2luZyB0aGUgbG93ZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyB0aGlzIGNhbiBuZXZlciBtYWtlIHRoZSBoaWdoZXIgb3JkZXIgdW5pdCBuZWdhdGl2ZSwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgb3BlcmF0ZXNcbiAgICAgICAgLy8gb24gcG9zaXRpdmUgZHVyYXRpb25zLCBzbyB0aGUgYW1vdW50IG9mIHRpbWUgcmVwcmVzZW50ZWQgYnkgdGhlIGxvd2VyIG9yZGVyIHVuaXQgY2Fubm90XG4gICAgICAgIC8vIGJlIGxhcmdlciB0aGFuIHRoZSBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyBlbHNlOlxuICAgICAgICAvLyBsb3dlciBvcmRlciB1bml0IGlzIHBvc2l0aXZlIChlLmcuIHsgeWVhcnM6IDIsIGRheXM6IDQ1MCB9IG9yIHsgeWVhcnM6IC0yLCBkYXlzOiA0NTAgfSlcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGF0dGVtcHQgdG8gY29udmVydCBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGxvd2VyIG9yZGVyIHVuaXQgaW50b1xuICAgICAgICAvLyB0aGUgaGlnaGVyIG9yZGVyIG9uZVxuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRoLmZsb29yIHRha2VzIGNhcmUgb2YgYm90aCBvZiB0aGVzZSBjYXNlcywgcm91bmRpbmcgYXdheSBmcm9tIDBcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPCAwIGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBsYXJnZXJcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPj0gaXQgbWFrZXMgdGhlIGFic29sdXRlIHZhbHVlIHNtYWxsZXJcbiAgICAgICAgY29uc3Qgcm9sbFVwID0gTWF0aC5mbG9vcihwcmV2aW91c1ZhbCAvIGNvbnYpO1xuICAgICAgICB2YWxzW2N1cnJlbnRdICs9IHJvbGxVcCAqIGZhY3RvcjtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gcm9sbFVwICogY29udiAqIGZhY3RvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcblxuICAvLyB0cnkgdG8gY29udmVydCBhbnkgZGVjaW1hbHMgaW50byBzbWFsbGVyIHVuaXRzIGlmIHBvc3NpYmxlXG4gIC8vIGZvciBleGFtcGxlIGZvciB7IHllYXJzOiAyLjUsIGRheXM6IDAsIHNlY29uZHM6IDAgfSB3ZSB3YW50IHRvIGdldCB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gIG9yZGVyZWRVbml0cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gdmFsc1twcmV2aW91c10gJSAxO1xuICAgICAgICB2YWxzW3ByZXZpb3VzXSAtPSBmcmFjdGlvbjtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSBmcmFjdGlvbiAqIG1hdHJpeFtwcmV2aW91c11bY3VycmVudF07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG5cbi8vIFJlbW92ZSBhbGwgcHJvcGVydGllcyB3aXRoIGEgdmFsdWUgb2YgMCBmcm9tIGFuIG9iamVjdFxuZnVuY3Rpb24gcmVtb3ZlWmVyb2VzKHZhbHMpIHtcbiAgY29uc3QgbmV3VmFscyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWxzKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgbmV3VmFsc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWxzO1xufVxuXG4vKipcbiAqIEEgRHVyYXRpb24gb2JqZWN0IHJlcHJlc2VudHMgYSBwZXJpb2Qgb2YgdGltZSwgbGlrZSBcIjIgbW9udGhzXCIgb3IgXCIxIGRheSwgMSBob3VyXCIuIENvbmNlcHR1YWxseSwgaXQncyBqdXN0IGEgbWFwIG9mIHVuaXRzIHRvIHRoZWlyIHF1YW50aXRpZXMsIGFjY29tcGFuaWVkIGJ5IHNvbWUgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGFuZCBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLiBUaGV5IGNhbiBiZSB1c2VkIG9uIHRoZWlyIG93biBvciBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEx1eG9uIHR5cGVzOyBmb3IgZXhhbXBsZSwgeW91IGNhbiB1c2Uge0BsaW5rIERhdGVUaW1lI3BsdXN9IHRvIGFkZCBhIER1cmF0aW9uIG9iamVjdCB0byBhIERhdGVUaW1lLCBwcm9kdWNpbmcgYW5vdGhlciBEYXRlVGltZS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIER1cmF0aW9uOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhIER1cmF0aW9uLCB1c2Uge0BsaW5rIER1cmF0aW9uLmZyb21NaWxsaXN9LCB7QGxpbmsgRHVyYXRpb24uZnJvbU9iamVjdH0sIG9yIHtAbGluayBEdXJhdGlvbi5mcm9tSVNPfS5cbiAqICogKipVbml0IHZhbHVlcyoqIFNlZSB0aGUge0BsaW5rIER1cmF0aW9uI3llYXJzfSwge0BsaW5rIER1cmF0aW9uI21vbnRoc30sIHtAbGluayBEdXJhdGlvbiN3ZWVrc30sIHtAbGluayBEdXJhdGlvbiNkYXlzfSwge0BsaW5rIER1cmF0aW9uI2hvdXJzfSwge0BsaW5rIER1cmF0aW9uI21pbnV0ZXN9LCB7QGxpbmsgRHVyYXRpb24jc2Vjb25kc30sIHtAbGluayBEdXJhdGlvbiNtaWxsaXNlY29uZHN9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlICB7QGxpbmsgRHVyYXRpb24jbG9jYWxlfSBhbmQge0BsaW5rIER1cmF0aW9uI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG5ldyBEdXJhdGlvbnMgb3V0IG9mIG9sZCBvbmVzIHVzZSB7QGxpbmsgRHVyYXRpb24jcGx1c30sIHtAbGluayBEdXJhdGlvbiNtaW51c30sIHtAbGluayBEdXJhdGlvbiNub3JtYWxpemV9LCB7QGxpbmsgRHVyYXRpb24jc2V0fSwge0BsaW5rIER1cmF0aW9uI3JlY29uZmlndXJlfSwge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99LCBhbmQge0BsaW5rIER1cmF0aW9uI25lZ2F0ZX0uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgRHVyYXRpb24gaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgRHVyYXRpb24jYXN9LCB7QGxpbmsgRHVyYXRpb24jdG9JU099LCB7QGxpbmsgRHVyYXRpb24jdG9Gb3JtYXR9LCBhbmQge0BsaW5rIER1cmF0aW9uI3RvSlNPTn1cbiAqXG4gKiBUaGVyZSdzIGFyZSBtb3JlIG1ldGhvZHMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24gYW5kIHZhbGlkaXR5LCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER1cmF0aW9uIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBhY2N1cmF0ZSA9IGNvbmZpZy5jb252ZXJzaW9uQWNjdXJhY3kgPT09IFwibG9uZ3Rlcm1cIiB8fCBmYWxzZTtcbiAgICBsZXQgbWF0cml4ID0gYWNjdXJhdGUgPyBhY2N1cmF0ZU1hdHJpeCA6IGNhc3VhbE1hdHJpeDtcblxuICAgIGlmIChjb25maWcubWF0cml4KSB7XG4gICAgICBtYXRyaXggPSBjb25maWcubWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRHVyYXRpb24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEdXJhdGlvbiBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhjb3VudCwgb3B0cykge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiBjb3VudCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogSWYgdGhpcyBvYmplY3QgaXMgZW1wdHkgdGhlbiBhIHplcm8gbWlsbGlzZWNvbmRzIGR1cmF0aW9uIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnF1YXJ0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGhzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91cnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9W11dIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGN1c3RvbSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtcbiAgICAgIHZhbHVlczogbm9ybWFsaXplT2JqZWN0KG9iaiwgRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgICAgY29udmVyc2lvbkFjY3VyYWN5OiBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICAgIG1hdHJpeDogb3B0cy5tYXRyaXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBEdXJhdGlvbkxpa2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRHVyYXRpb259IGR1cmF0aW9uTGlrZVxuICAgKiBPbmUgb2Y6XG4gICAqIC0gb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIC0gbnVtYmVyIHJlcHJlc2VudGluZyBtaWxsaXNlY29uZHNcbiAgICogLSBEdXJhdGlvbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uTGlrZSkge1xuICAgIGlmIChpc051bWJlcihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSBpZiAoRHVyYXRpb24uaXNEdXJhdGlvbihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gZHVyYXRpb25MaWtlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uTGlrZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgVW5rbm93biBkdXJhdGlvbiBhcmd1bWVudCAke2R1cmF0aW9uTGlrZX0gb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkxpa2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSBkdXJhdGlvbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1AzWTZNMVc0RFQxMkgzME01UycpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAzLCBtb250aHM6IDYsIHdlZWtzOiAxLCBkYXlzOiA0LCBob3VyczogMTIsIG1pbnV0ZXM6IDMwLCBzZWNvbmRzOiA1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUFQyM0gnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjMgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQNVkzTScpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiA1LCBtb250aHM6IDMgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPRHVyYXRpb24odGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgdGltZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MjI6MzMuNDQ0JykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAyMiwgc2Vjb25kczogMzMsIG1pbGxpc2Vjb25kczogNDQ0IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTT1RpbWUodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09UaW1lT25seSh0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIGRhdGV0aW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRHVyYXRpb24gaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZER1cmF0aW9uRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgICB5ZWFyOiBcInllYXJzXCIsXG4gICAgICB5ZWFyczogXCJ5ZWFyc1wiLFxuICAgICAgcXVhcnRlcjogXCJxdWFydGVyc1wiLFxuICAgICAgcXVhcnRlcnM6IFwicXVhcnRlcnNcIixcbiAgICAgIG1vbnRoOiBcIm1vbnRoc1wiLFxuICAgICAgbW9udGhzOiBcIm1vbnRoc1wiLFxuICAgICAgd2VlazogXCJ3ZWVrc1wiLFxuICAgICAgd2Vla3M6IFwid2Vla3NcIixcbiAgICAgIGRheTogXCJkYXlzXCIsXG4gICAgICBkYXlzOiBcImRheXNcIixcbiAgICAgIGhvdXI6IFwiaG91cnNcIixcbiAgICAgIGhvdXJzOiBcImhvdXJzXCIsXG4gICAgICBtaW51dGU6IFwibWludXRlc1wiLFxuICAgICAgbWludXRlczogXCJtaW51dGVzXCIsXG4gICAgICBzZWNvbmQ6IFwic2Vjb25kc1wiLFxuICAgICAgc2Vjb25kczogXCJzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZHNcIixcbiAgICB9W3VuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiB1bml0XTtcblxuICAgIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEdXJhdGlvbi4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRHVyYXRpb24obykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EdXJhdGlvbikgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0ICB0aGUgbG9jYWxlIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2VuLUdCJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEdXJhdGlvbiwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEdXJhdGlvblxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuIFlvdSBtYXkgdXNlIHRoZXNlIHRva2VuczpcbiAgICogKiBgU2AgZm9yIG1pbGxpc2Vjb25kc1xuICAgKiAqIGBzYCBmb3Igc2Vjb25kc1xuICAgKiAqIGBtYCBmb3IgbWludXRlc1xuICAgKiAqIGBoYCBmb3IgaG91cnNcbiAgICogKiBgZGAgZm9yIGRheXNcbiAgICogKiBgd2AgZm9yIHdlZWtzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRva2VucyBjYW4gYmUgZXNjYXBlZCBieSB3cmFwcGluZyB3aXRoIHNpbmdsZSBxdW90ZXMuXG4gICAqICogVGhlIGR1cmF0aW9uIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSBzZXQgb2YgdW5pdHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgdXNpbmcge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99IGFuZCB0aGUgRHVyYXRpb25zJ3MgY29udmVyc2lvbiBhY2N1cmFjeSBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmxvb3I9dHJ1ZV0gLSBmbG9vciBudW1lcmljYWwgdmFsdWVzXG4gICAqIEBwYXJhbSB7J25lZ2F0aXZlJ3wnYWxsJ3wnbmVnYXRpdmVMYXJnZXN0T25seSd9IFtvcHRzLnNpZ25Nb2RlPW5lZ2F0aXZlXSAtIEhvdyB0byBoYW5kbGUgc2lnbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwieSBkIHNcIikgLy89PiBcIjEgNiAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwieXkgZGQgc3NzXCIpIC8vPT4gXCIwMSAwNiAwMDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJNIFNcIikgLy89PiBcIjEyIDUxODQwMjAwMFwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwiZCBzXCIsIHsgc2lnbk1vZGU6IFwiYWxsXCIgfSkgLy89PiBcIis2ICsyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IC02LCBzZWNvbmRzOiAtMiB9KS50b0Zvcm1hdChcImQgc1wiLCB7IHNpZ25Nb2RlOiBcImFsbFwiIH0pIC8vPT4gXCItNiAtMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAtNiwgc2Vjb25kczogLTIgfSkudG9Gb3JtYXQoXCJkIHNcIiwgeyBzaWduTW9kZTogXCJuZWdhdGl2ZUxhcmdlc3RPbmx5XCIgfSkgLy89PiBcIi02IDJcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIC8vIHJldmVyc2UtY29tcGF0IHNpbmNlIDEuMjsgd2UgYWx3YXlzIHJvdW5kIGRvd24gbm93LCBuZXZlciB1cCwgYW5kIHdlIGRvIGl0IGJ5IGRlZmF1bHRcbiAgICBjb25zdCBmbXRPcHRzID0ge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGZsb29yOiBvcHRzLnJvdW5kICE9PSBmYWxzZSAmJiBvcHRzLmZsb29yICE9PSBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYywgZm10T3B0cykuZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRHVyYXRpb24gd2l0aCBhbGwgdW5pdHMgaW5jbHVkZWQuXG4gICAqIFRvIG1vZGlmeSBpdHMgYmVoYXZpb3IsIHVzZSBgbGlzdFN0eWxlYCBhbmQgYW55IEludGwuTnVtYmVyRm9ybWF0IG9wdGlvbiwgdGhvdWdoIGB1bml0RGlzcGxheWAgaXMgZXNwZWNpYWxseSByZWxldmFudC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL051bWJlckZvcm1hdC9OdW1iZXJGb3JtYXQjb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEZvcm1hdHRpbmcgb3B0aW9ucy4gQWNjZXB0cyB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiB0aGUgbmF0aXZlIGBJbnRsLk51bWJlckZvcm1hdGAgY29uc3RydWN0b3IsIGFzIHdlbGwgYXMgYGxpc3RTdHlsZWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5saXN0U3R5bGU9J25hcnJvdyddIC0gSG93IHRvIGZvcm1hdCB0aGUgbWVyZ2VkIGxpc3QuIENvcnJlc3BvbmRzIHRvIHRoZSBgc3R5bGVgIHByb3BlcnR5IG9mIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiB0aGUgbmF0aXZlIGBJbnRsLkxpc3RGb3JtYXRgIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNob3daZXJvcz10cnVlXSAtIFNob3cgYWxsIHVuaXRzIHByZXZpb3VzbHkgdXNlZCBieSB0aGUgZHVyYXRpb24gZXZlbiBpZiB0aGV5IGFyZSB6ZXJvXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBkdXIgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxLCB3ZWVrczogMCwgaG91cnM6IDUsIG1pbnV0ZXM6IDYgfSlcbiAgICogZHVyLnRvSHVtYW4oKSAvLz0+ICcxIG1vbnRoLCAwIHdlZWtzLCA1IGhvdXJzLCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgbGlzdFN0eWxlOiBcImxvbmdcIiB9KSAvLz0+ICcxIG1vbnRoLCAwIHdlZWtzLCA1IGhvdXJzLCBhbmQgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IHVuaXREaXNwbGF5OiBcInNob3J0XCIgfSkgLy89PiAnMSBtdGgsIDAgd2tzLCA1IGhyLCA2IG1pbidcbiAgICogZHVyLnRvSHVtYW4oeyBzaG93WmVyb3M6IGZhbHNlIH0pIC8vPT4gJzEgbW9udGgsIDUgaG91cnMsIDYgbWludXRlcydcbiAgICogYGBgXG4gICAqL1xuICB0b0h1bWFuKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcblxuICAgIGNvbnN0IHNob3daZXJvcyA9IG9wdHMuc2hvd1plcm9zICE9PSBmYWxzZTtcblxuICAgIGNvbnN0IGwgPSBvcmRlcmVkVW5pdHNcbiAgICAgIC5tYXAoKHVuaXQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy52YWx1ZXNbdW5pdF07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWwpIHx8ICh2YWwgPT09IDAgJiYgIXNob3daZXJvcykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgICAgICAubnVtYmVyRm9ybWF0dGVyKHsgc3R5bGU6IFwidW5pdFwiLCB1bml0RGlzcGxheTogXCJsb25nXCIsIC4uLm9wdHMsIHVuaXQ6IHVuaXQuc2xpY2UoMCwgLTEpIH0pXG4gICAgICAgICAgLmZvcm1hdCh2YWwpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKG4pID0+IG4pO1xuXG4gICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAubGlzdEZvcm1hdHRlcih7IHR5cGU6IFwiY29uanVuY3Rpb25cIiwgc3R5bGU6IG9wdHMubGlzdFN0eWxlIHx8IFwibmFycm93XCIsIC4uLm9wdHMgfSlcbiAgICAgIC5mb3JtYXQobCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEdXJhdGlvbidzIHZhbHVlcy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcbiAgICByZXR1cm4geyAuLi50aGlzLnZhbHVlcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDMsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDNZVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNCwgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQNE1UNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA1IH0pLnRvSVNPKCkgLy89PiAnUDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogNSB9KS50b0lTTygpIC8vPT4gJ1BUNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDYgfSkudG9JU08oKSAvLz0+ICdQVDAuMDA2UydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oKSB7XG4gICAgLy8gd2UgY291bGQgdXNlIHRoZSBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGlzIGFuIGVhc2llciB3YXkgdG8gZ2V0IHRoZSBtaW5pbXVtIHN0cmluZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBzID0gXCJQXCI7XG4gICAgaWYgKHRoaXMueWVhcnMgIT09IDApIHMgKz0gdGhpcy55ZWFycyArIFwiWVwiO1xuICAgIGlmICh0aGlzLm1vbnRocyAhPT0gMCB8fCB0aGlzLnF1YXJ0ZXJzICE9PSAwKSBzICs9IHRoaXMubW9udGhzICsgdGhpcy5xdWFydGVycyAqIDMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy53ZWVrcyAhPT0gMCkgcyArPSB0aGlzLndlZWtzICsgXCJXXCI7XG4gICAgaWYgKHRoaXMuZGF5cyAhPT0gMCkgcyArPSB0aGlzLmRheXMgKyBcIkRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCB8fCB0aGlzLm1pbnV0ZXMgIT09IDAgfHwgdGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgcyArPSBcIlRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCkgcyArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgaWYgKHRoaXMubWludXRlcyAhPT0gMCkgcyArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgLy8gdGhpcyB3aWxsIGhhbmRsZSBcImZsb2F0aW5nIHBvaW50IG1hZG5lc3NcIiBieSByZW1vdmluZyBleHRyYSBkZWNpbWFsIHBsYWNlc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg4MDA0L2lzLWZsb2F0aW5nLXBvaW50LW1hdGgtYnJva2VuXG4gICAgICBzICs9IHJvdW5kVG8odGhpcy5zZWNvbmRzICsgdGhpcy5taWxsaXNlY29uZHMgLyAxMDAwLCAzKSArIFwiU1wiO1xuICAgIGlmIChzID09PSBcIlBcIikgcyArPSBcIlQwU1wiO1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLCBmb3JtYXR0ZWQgYXMgYSB0aW1lIG9mIGRheS5cbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgZHVyYXRpb24gaXMgaW52YWxpZCwgbmVnYXRpdmUsIG9yIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAyNCBob3Vycy5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSgpIC8vPT4gJzExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc01pbGxpc2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMDowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxMTAwMDAuMDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbWlsbGlzID0gdGhpcy50b01pbGxpcygpO1xuICAgIGlmIChtaWxsaXMgPCAwIHx8IG1pbGxpcyA+PSA4NjQwMDAwMCkgcmV0dXJuIG51bGw7XG5cbiAgICBvcHRzID0ge1xuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHM6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NTZWNvbmRzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVQcmVmaXg6IGZhbHNlLFxuICAgICAgZm9ybWF0OiBcImV4dGVuZGVkXCIsXG4gICAgICAuLi5vcHRzLFxuICAgICAgaW5jbHVkZU9mZnNldDogZmFsc2UsXG4gICAgfTtcblxuICAgIGNvbnN0IGRhdGVUaW1lID0gRGF0ZVRpbWUuZnJvbU1pbGxpcyhtaWxsaXMsIHsgem9uZTogXCJVVENcIiB9KTtcbiAgICByZXR1cm4gZGF0ZVRpbWUudG9JU09UaW1lKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHRoZSBSRVBMLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gYER1cmF0aW9uIHsgdmFsdWVzOiAke0pTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKX0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgRHVyYXRpb24geyBJbnZhbGlkLCByZWFzb246ICR7dGhpcy5pbnZhbGlkUmVhc29ufSB9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG5cbiAgICByZXR1cm4gZHVyYXRpb25Ub01pbGxpcyh0aGlzLm1hdHJpeCwgdGhpcy52YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uIEFsaWFzIG9mIHtAbGluayB0b01pbGxpc31cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b01pbGxpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBsb25nZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGsgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoZHVyLnZhbHVlcywgaykgfHwgaGFzT3duUHJvcGVydHkodGhpcy52YWx1ZXMsIGspKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IGR1ci5nZXQoaykgKyB0aGlzLmdldChrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gc2hvcnRlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIHN1YnRyYWN0LiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMucGx1cyhkdXIubmVnYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoaXMgRHVyYXRpb24gYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHVuaXQuIEFyaXR5IGlzIDEgb3IgMjogdGhlIHZhbHVlIG9mIHRoZSB1bml0IGFuZCwgb3B0aW9uYWxseSwgdGhlIHVuaXQgbmFtZS4gTXVzdCByZXR1cm4gYSBudW1iZXIuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgbWludXRlczogMzAgfSkubWFwVW5pdHMoeCA9PiB4ICogMikgLy89PiB7IGhvdXJzOiAyLCBtaW51dGVzOiA2MCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgbWludXRlczogMzAgfSkubWFwVW5pdHMoKHgsIHUpID0+IHUgPT09IFwiaG91cnNcIiA/IHggKiAyIDogeCkgLy89PiB7IGhvdXJzOiAyLCBtaW51dGVzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWFwVW5pdHMoZm4pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKSkge1xuICAgICAgcmVzdWx0W2tdID0gYXNOdW1iZXIoZm4odGhpcy52YWx1ZXNba10sIGspKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCd5ZWFycycpIC8vPT4gMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnbW9udGhzJykgLy89PiAwXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdkYXlzJykgLy89PiAzXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KV07XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgeWVhcnM6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IGhvdXJzOiA4LCBtaW51dGVzOiAzMCB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBtaXhlZCA9IHsgLi4udGhpcy52YWx1ZXMsIC4uLm5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpIH07XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBtaXhlZCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUgYW5kL29yIG51bWJlcmluZ1N5c3RlbS4gIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgZHVyLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVjb25maWd1cmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgY29udmVyc2lvbkFjY3VyYWN5LCBtYXRyaXggfSA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5sb2MuY2xvbmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSB9KTtcbiAgICBjb25zdCBvcHRzID0geyBsb2MsIG1hdHJpeCwgY29udmVyc2lvbkFjY3VyYWN5IH07XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBkdXJhdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZXMnIG9yICdkYXlzJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdkYXlzJykgLy89PiAzNjVcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnbW9udGhzJykgLy89PiAxMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtob3VyczogNjB9KS5hcygnZGF5cycpIC8vPT4gMi41XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGFzKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zaGlmdFRvKHVuaXQpLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWR1Y2UgdGhpcyBEdXJhdGlvbiB0byBpdHMgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIGluIGl0cyBjdXJyZW50IHVuaXRzLlxuICAgKiBBc3N1bWluZyB0aGUgb3ZlcmFsbCB2YWx1ZSBvZiB0aGUgRHVyYXRpb24gaXMgcG9zaXRpdmUsIHRoaXMgbWVhbnM6XG4gICAqIC0gZXhjZXNzaXZlIHZhbHVlcyBmb3IgbG93ZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBoaWdoZXItb3JkZXIgdW5pdHMgKGlmIHBvc3NpYmxlLCBzZWUgZmlyc3QgYW5kIHNlY29uZCBleGFtcGxlKVxuICAgKiAtIG5lZ2F0aXZlIGxvd2VyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gaGlnaGVyIG9yZGVyIHVuaXRzICh0aGVyZSBtdXN0IGJlIHN1Y2ggYSBoaWdoZXIgb3JkZXIgdW5pdCwgb3RoZXJ3aXNlXG4gICAqICAgdGhlIG92ZXJhbGwgdmFsdWUgd291bGQgYmUgbmVnYXRpdmUsIHNlZSB0aGlyZCBleGFtcGxlKVxuICAgKiAtIGZyYWN0aW9uYWwgdmFsdWVzIGZvciBoaWdoZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBsb3dlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmb3VydGggZXhhbXBsZSlcbiAgICpcbiAgICogSWYgdGhlIG92ZXJhbGwgdmFsdWUgaXMgbmVnYXRpdmUsIHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgdGhpcy5uZWdhdGUoKS5ub3JtYWxpemUoKS5uZWdhdGUoKWAuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDUwMDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEyLCBtaW51dGVzOiAtNDUgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAxNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMi41LCBkYXlzOiAwLCBob3VyczogMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIHZhbHMpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjYWxlIHVuaXRzIHRvIGl0cyBsYXJnZXN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDkwMDAwIH0pLnJlc2NhbGUoKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiAxLCBzZWNvbmRzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVzY2FsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHJlbW92ZVplcm9lcyh0aGlzLm5vcm1hbGl6ZSgpLnNoaWZ0VG9BbGwoKS50b09iamVjdCgpKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIER1cmF0aW9uIGludG8gaXRzIHJlcHJlc2VudGF0aW9uIGluIGEgZGlmZmVyZW50IHNldCBvZiB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5zaGlmdFRvKCdtaW51dGVzJywgJ21pbGxpc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDYwLCBtaWxsaXNlY29uZHM6IDMwMDAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvKC4uLnVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdW5pdHMgPSB1bml0cy5tYXAoKHUpID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IGtlZXAgdGhlIGludGVnZXIgcGFydCBmb3Igbm93IGluIHRoZSBob3BlcyBvZiBwdXR0aW5nIGFueSBkZWNpbWFsIHBhcnRcbiAgICAgICAgLy8gaW50byBhIHNtYWxsZXIgdW5pdCBsYXRlclxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gKG93biAqIDEwMDAgLSBpICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IHZhbHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgbGVmdG92ZXIgYmVjb21lcyB0aGUgZGVjaW1hbCBmb3IgdGhlIGxhc3QgdW5pdFxuICAgIC8vIGxhc3RVbml0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSB1bml0cyBpcyBub3QgZW1wdHlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9XG4gICAgICAgICAga2V5ID09PSBsYXN0VW5pdCA/IGFjY3VtdWxhdGVkW2tleV0gOiBhY2N1bXVsYXRlZFtrZXldIC8gdGhpcy5tYXRyaXhbbGFzdFVuaXRdW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCBidWlsdCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBidWlsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGlmdCB0aGlzIER1cmF0aW9uIHRvIGFsbCBhdmFpbGFibGUgdW5pdHMuXG4gICAqIFNhbWUgYXMgc2hpZnRUbyhcInllYXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG9BbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0VG8oXG4gICAgICBcInllYXJzXCIsXG4gICAgICBcIm1vbnRoc1wiLFxuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgXCJkYXlzXCIsXG4gICAgICBcImhvdXJzXCIsXG4gICAgICBcIm1pbnV0ZXNcIixcbiAgICAgIFwic2Vjb25kc1wiLFxuICAgICAgXCJtaWxsaXNlY29uZHNcIlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLm5lZ2F0ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAtMSwgc2Vjb25kczogLTMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG5lZ2F0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICBuZWdhdGVkW2tdID0gdGhpcy52YWx1ZXNba10gPT09IDAgPyAwIDogLXRoaXMudmFsdWVzW2tdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG5lZ2F0ZWQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdW5pdHMgd2l0aCB2YWx1ZXMgZXF1YWwgdG8gMCBmcm9tIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogMCwgaG91cnM6IDAsIG1pbnV0ZXM6IDAgfSkucmVtb3ZlWmVyb3MoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMiB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVtb3ZlWmVyb3MoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSByZW1vdmVaZXJvZXModGhpcy52YWx1ZXMpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy55ZWFycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnF1YXJ0ZXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5tb250aHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLndlZWtzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXlzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmRheXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5ob3VycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlcy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taW51dGVzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taWxsaXNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIER1cmF0aW9uIGlzIGludmFsaWQuIEludmFsaWQgZHVyYXRpb25zIGFyZSByZXR1cm5lZCBieSBkaWZmIG9wZXJhdGlvbnNcbiAgICogb24gaW52YWxpZCBEYXRlVGltZXMgb3IgSW50ZXJ2YWxzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXEodjEsIHYyKSB7XG4gICAgICAvLyBDb25zaWRlciAwIGFuZCB1bmRlZmluZWQgYXMgZXF1YWxcbiAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkIHx8IHYxID09PSAwKSByZXR1cm4gdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gMDtcbiAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKCFlcSh0aGlzLnZhbHVlc1t1XSwgb3RoZXIudmFsdWVzW3VdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/duration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js":
/*!***********************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/errors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingSpecificationError: () => (/* binding */ ConflictingSpecificationError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDateTimeError: () => (/* binding */ InvalidDateTimeError),\n/* harmony export */   InvalidDurationError: () => (/* binding */ InvalidDurationError),\n/* harmony export */   InvalidIntervalError: () => (/* binding */ InvalidIntervalError),\n/* harmony export */   InvalidUnitError: () => (/* binding */ InvalidUnitError),\n/* harmony export */   ZoneIsAbstractError: () => (/* binding */ ZoneIsAbstractError)\n/* harmony export */ });\n// these aren't really private, but nor are they really useful to document\n\n/**\n * @private\n */\nclass LuxonError extends Error {}\n\n/**\n * @private\n */\nclass InvalidDateTimeError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid DateTime: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidIntervalError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Interval: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidDurationError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Duration: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nclass ConflictingSpecificationError extends LuxonError {}\n\n/**\n * @private\n */\nclass InvalidUnitError extends LuxonError {\n  constructor(unit) {\n    super(`Invalid unit ${unit}`);\n  }\n}\n\n/**\n * @private\n */\nclass InvalidArgumentError extends LuxonError {}\n\n/**\n * @private\n */\nclass ZoneIsAbstractError extends LuxonError {\n  constructor() {\n    super(\"Zone is an abstract class\");\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoZXNlIGFyZW4ndCByZWFsbHkgcHJpdmF0ZSwgYnV0IG5vciBhcmUgdGhleSByZWFsbHkgdXNlZnVsIHRvIGRvY3VtZW50XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTHV4b25FcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREYXRlVGltZUVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIERhdGVUaW1lOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW50ZXJ2YWxFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBJbnRlcnZhbDogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZER1cmF0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRHVyYXRpb246ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVW5pdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHVuaXQpIHtcbiAgICBzdXBlcihgSW52YWxpZCB1bml0ICR7dW5pdH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgWm9uZUlzQWJzdHJhY3RFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlpvbmUgaXMgYW4gYWJzdHJhY3QgY2xhc3NcIik7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/conversions.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/conversions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dayOfWeek: () => (/* binding */ dayOfWeek),\n/* harmony export */   gregorianToOrdinal: () => (/* binding */ gregorianToOrdinal),\n/* harmony export */   gregorianToWeek: () => (/* binding */ gregorianToWeek),\n/* harmony export */   hasInvalidGregorianData: () => (/* binding */ hasInvalidGregorianData),\n/* harmony export */   hasInvalidOrdinalData: () => (/* binding */ hasInvalidOrdinalData),\n/* harmony export */   hasInvalidTimeData: () => (/* binding */ hasInvalidTimeData),\n/* harmony export */   hasInvalidWeekData: () => (/* binding */ hasInvalidWeekData),\n/* harmony export */   isoWeekdayToLocal: () => (/* binding */ isoWeekdayToLocal),\n/* harmony export */   ordinalToGregorian: () => (/* binding */ ordinalToGregorian),\n/* harmony export */   usesLocalWeekValues: () => (/* binding */ usesLocalWeekValues),\n/* harmony export */   weekToGregorian: () => (/* binding */ weekToGregorian)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _invalid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invalid.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\");\n\n\n\n\nconst nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n\nfunction unitOutOfRange(unit, value) {\n  return new _invalid_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n    \"unit out of range\",\n    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`\n  );\n}\n\nfunction dayOfWeek(year, month, day) {\n  const d = new Date(Date.UTC(year, month - 1, day));\n\n  if (year < 100 && year >= 0) {\n    d.setUTCFullYear(d.getUTCFullYear() - 1900);\n  }\n\n  const js = d.getUTCDay();\n\n  return js === 0 ? 7 : js;\n}\n\nfunction computeOrdinal(year, month, day) {\n  return day + ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder)[month - 1];\n}\n\nfunction uncomputeOrdinal(year, ordinal) {\n  const table = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder,\n    month0 = table.findIndex((i) => i < ordinal),\n    day = ordinal - table[month0];\n  return { month: month0 + 1, day };\n}\n\nfunction isoWeekdayToLocal(isoWeekday, startOfWeek) {\n  return ((isoWeekday - startOfWeek + 7) % 7) + 1;\n}\n\n/**\n * @private\n */\n\nfunction gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { year, month, day } = gregObj,\n    ordinal = computeOrdinal(year, month, day),\n    weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);\n\n  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7),\n    weekYear;\n\n  if (weekNumber < 1) {\n    weekYear = year - 1;\n    weekNumber = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(weekYear, minDaysInFirstWeek, startOfWeek);\n  } else if (weekNumber > (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(year, minDaysInFirstWeek, startOfWeek)) {\n    weekYear = year + 1;\n    weekNumber = 1;\n  } else {\n    weekYear = year;\n  }\n\n  return { weekYear, weekNumber, weekday, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregObj) };\n}\n\nfunction weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const { weekYear, weekNumber, weekday } = weekData,\n    weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek),\n    yearInDays = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n\n  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek,\n    year;\n\n  if (ordinal < 1) {\n    year = weekYear - 1;\n    ordinal += (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(year);\n  } else if (ordinal > yearInDays) {\n    year = weekYear + 1;\n    ordinal -= (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);\n  } else {\n    year = weekYear;\n  }\n\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(weekData) };\n}\n\nfunction gregorianToOrdinal(gregData) {\n  const { year, month, day } = gregData;\n  const ordinal = computeOrdinal(year, month, day);\n  return { year, ordinal, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregData) };\n}\n\nfunction ordinalToGregorian(ordinalData) {\n  const { year, ordinal } = ordinalData;\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(ordinalData) };\n}\n\n/**\n * Check if local week units like localWeekday are used in obj.\n * If so, validates that they are not mixed with ISO week units and then copies them to the normal week unit properties.\n * Modifies obj in-place!\n * @param obj the object values\n */\nfunction usesLocalWeekValues(obj, loc) {\n  const hasLocaleWeekData =\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber) ||\n    !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear);\n  if (hasLocaleWeekData) {\n    const hasIsoWeekData =\n      !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekday) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekNumber) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.weekYear);\n\n    if (hasIsoWeekData) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingSpecificationError(\n        \"Cannot mix locale-based week fields with ISO-based week fields\"\n      );\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekday)) obj.weekday = obj.localWeekday;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;\n    delete obj.localWeekday;\n    delete obj.localWeekNumber;\n    delete obj.localWeekYear;\n    return {\n      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),\n      startOfWeek: loc.getStartOfWeek(),\n    };\n  } else {\n    return { minDaysInFirstWeek: 4, startOfWeek: 1 };\n  }\n}\n\nfunction hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.weekYear),\n    validWeek = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(\n      obj.weekNumber,\n      1,\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(obj.weekYear, minDaysInFirstWeek, startOfWeek)\n    ),\n    validWeekday = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.weekday, 1, 7);\n\n  if (!validYear) {\n    return unitOutOfRange(\"weekYear\", obj.weekYear);\n  } else if (!validWeek) {\n    return unitOutOfRange(\"week\", obj.weekNumber);\n  } else if (!validWeekday) {\n    return unitOutOfRange(\"weekday\", obj.weekday);\n  } else return false;\n}\n\nfunction hasInvalidOrdinalData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validOrdinal = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.ordinal, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(obj.year));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validOrdinal) {\n    return unitOutOfRange(\"ordinal\", obj.ordinal);\n  } else return false;\n}\n\nfunction hasInvalidGregorianData(obj) {\n  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),\n    validMonth = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.month, 1, 12),\n    validDay = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.day, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInMonth)(obj.year, obj.month));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validMonth) {\n    return unitOutOfRange(\"month\", obj.month);\n  } else if (!validDay) {\n    return unitOutOfRange(\"day\", obj.day);\n  } else return false;\n}\n\nfunction hasInvalidTimeData(obj) {\n  const { hour, minute, second, millisecond } = obj;\n  const validHour =\n      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(hour, 0, 23) ||\n      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),\n    validMinute = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(minute, 0, 59),\n    validSecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(second, 0, 59),\n    validMillisecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(millisecond, 0, 999);\n\n  if (!validHour) {\n    return unitOutOfRange(\"hour\", hour);\n  } else if (!validMinute) {\n    return unitOutOfRange(\"minute\", minute);\n  } else if (!validSecond) {\n    return unitOutOfRange(\"second\", second);\n  } else if (!validMillisecond) {\n    return unitOutOfRange(\"millisecond\", millisecond);\n  } else return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2NvbnZlcnNpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU21CO0FBQ2dCO0FBQzBCOztBQUU3RDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtREFBTztBQUNwQjtBQUNBLHFCQUFxQixPQUFPLFdBQVcsYUFBYSxTQUFTLEtBQUs7QUFDbEU7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG9EQUFVO0FBQzFCOztBQUVBO0FBQ0EsZ0JBQWdCLG9EQUFVO0FBQzFCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFlO0FBQ2hDLElBQUksc0JBQXNCLHlEQUFlO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxXQUFXLGtDQUFrQyxvREFBVTtBQUN2RDs7QUFFTztBQUNQLFVBQVUsZ0NBQWdDO0FBQzFDO0FBQ0EsaUJBQWlCLG9EQUFVOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9EQUFVO0FBQ3pCLElBQUk7QUFDSjtBQUNBLGVBQWUsb0RBQVU7QUFDekIsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsVUFBVSxhQUFhO0FBQ3ZCLFdBQVcscUJBQXFCLG9EQUFVO0FBQzFDOztBQUVPO0FBQ1AsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQSxXQUFXLGtCQUFrQixvREFBVTtBQUN2Qzs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsYUFBYTtBQUN2QixXQUFXLHFCQUFxQixvREFBVTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsS0FBSyxxREFBVztBQUNoQixLQUFLLHFEQUFXO0FBQ2hCLEtBQUsscURBQVc7QUFDaEI7QUFDQTtBQUNBLE9BQU8scURBQVcsa0JBQWtCLHFEQUFXLHFCQUFxQixxREFBVzs7QUFFL0U7QUFDQSxnQkFBZ0IscUVBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVMscURBQVc7QUFDcEIsU0FBUyxxREFBVztBQUNwQixTQUFTLHFEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBOztBQUVPO0FBQ1Asb0JBQW9CLG1EQUFTO0FBQzdCLGdCQUFnQix3REFBYztBQUM5QjtBQUNBO0FBQ0EsTUFBTSx5REFBZTtBQUNyQjtBQUNBLG1CQUFtQix3REFBYzs7QUFFakM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFTztBQUNQLG9CQUFvQixtREFBUztBQUM3QixtQkFBbUIsd0RBQWMsaUJBQWlCLG9EQUFVOztBQUU1RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVPO0FBQ1Asb0JBQW9CLG1EQUFTO0FBQzdCLGlCQUFpQix3REFBYztBQUMvQixlQUFlLHdEQUFjLGFBQWEscURBQVc7O0FBRXJEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRU87QUFDUCxVQUFVLG9DQUFvQztBQUM5QztBQUNBLE1BQU0sd0RBQWM7QUFDcEI7QUFDQSxrQkFBa0Isd0RBQWM7QUFDaEMsa0JBQWtCLHdEQUFjO0FBQ2hDLHVCQUF1Qix3REFBYzs7QUFFckM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2NvbnZlcnNpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGludGVnZXJCZXR3ZWVuLFxuICBpc0xlYXBZZWFyLFxuICB0aW1lT2JqZWN0LFxuICBkYXlzSW5ZZWFyLFxuICBkYXlzSW5Nb250aCxcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBpc0ludGVnZXIsXG4gIGlzVW5kZWZpbmVkLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgeyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuY29uc3Qgbm9uTGVhcExhZGRlciA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF0sXG4gIGxlYXBMYWRkZXIgPSBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzVdO1xuXG5mdW5jdGlvbiB1bml0T3V0T2ZSYW5nZSh1bml0LCB2YWx1ZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXG4gICAgXCJ1bml0IG91dCBvZiByYW5nZVwiLFxuICAgIGB5b3Ugc3BlY2lmaWVkICR7dmFsdWV9IChvZiB0eXBlICR7dHlwZW9mIHZhbHVlfSkgYXMgYSAke3VuaXR9LCB3aGljaCBpcyBpbnZhbGlkYFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cbiAgaWYgKHllYXIgPCAxMDAgJiYgeWVhciA+PSAwKSB7XG4gICAgZC5zZXRVVENGdWxsWWVhcihkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwKTtcbiAgfVxuXG4gIGNvbnN0IGpzID0gZC5nZXRVVENEYXkoKTtcblxuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICBjb25zdCB0YWJsZSA9IGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcixcbiAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoKGkpID0+IGkgPCBvcmRpbmFsKSxcbiAgICBkYXkgPSBvcmRpbmFsIC0gdGFibGVbbW9udGgwXTtcbiAgcmV0dXJuIHsgbW9udGg6IG1vbnRoMCArIDEsIGRheSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNvV2Vla2RheVRvTG9jYWwoaXNvV2Vla2RheSwgc3RhcnRPZldlZWspIHtcbiAgcmV0dXJuICgoaXNvV2Vla2RheSAtIHN0YXJ0T2ZXZWVrICsgNykgJSA3KSArIDE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9XZWVrKGdyZWdPYmosIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdPYmosXG4gICAgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpLFxuICAgIHdlZWtkYXkgPSBpc29XZWVrZGF5VG9Mb2NhbChkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSksIHN0YXJ0T2ZXZWVrKTtcblxuICBsZXQgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTQgLSBtaW5EYXlzSW5GaXJzdFdlZWspIC8gNyksXG4gICAgd2Vla1llYXI7XG5cbiAgaWYgKHdlZWtOdW1iZXIgPCAxKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyIC0gMTtcbiAgICB3ZWVrTnVtYmVyID0gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgfSBlbHNlIGlmICh3ZWVrTnVtYmVyID4gd2Vla3NJbldlZWtZZWFyKHllYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyICsgMTtcbiAgICB3ZWVrTnVtYmVyID0gMTtcbiAgfSBlbHNlIHtcbiAgICB3ZWVrWWVhciA9IHllYXI7XG4gIH1cblxuICByZXR1cm4geyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSwgLi4udGltZU9iamVjdChncmVnT2JqKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhLCBtaW5EYXlzSW5GaXJzdFdlZWsgPSA0LCBzdGFydE9mV2VlayA9IDEpIHtcbiAgY29uc3QgeyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSB9ID0gd2Vla0RhdGEsXG4gICAgd2Vla2RheU9mSmFuNCA9IGlzb1dlZWtkYXlUb0xvY2FsKGRheU9mV2Vlayh3ZWVrWWVhciwgMSwgbWluRGF5c0luRmlyc3RXZWVrKSwgc3RhcnRPZldlZWspLFxuICAgIHllYXJJbkRheXMgPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcblxuICBsZXQgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSA3ICsgbWluRGF5c0luRmlyc3RXZWVrLFxuICAgIHllYXI7XG5cbiAgaWYgKG9yZGluYWwgPCAxKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyIC0gMTtcbiAgICBvcmRpbmFsICs9IGRheXNJblllYXIoeWVhcik7XG4gIH0gZWxzZSBpZiAob3JkaW5hbCA+IHllYXJJbkRheXMpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgKyAxO1xuICAgIG9yZGluYWwgLT0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSB7XG4gICAgeWVhciA9IHdlZWtZZWFyO1xuICB9XG5cbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KHdlZWtEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ0RhdGE7XG4gIGNvbnN0IG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KTtcbiAgcmV0dXJuIHsgeWVhciwgb3JkaW5hbCwgLi4udGltZU9iamVjdChncmVnRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWxUb0dyZWdvcmlhbihvcmRpbmFsRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG9yZGluYWwgfSA9IG9yZGluYWxEYXRhO1xuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qob3JkaW5hbERhdGEpIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgbG9jYWwgd2VlayB1bml0cyBsaWtlIGxvY2FsV2Vla2RheSBhcmUgdXNlZCBpbiBvYmouXG4gKiBJZiBzbywgdmFsaWRhdGVzIHRoYXQgdGhleSBhcmUgbm90IG1peGVkIHdpdGggSVNPIHdlZWsgdW5pdHMgYW5kIHRoZW4gY29waWVzIHRoZW0gdG8gdGhlIG5vcm1hbCB3ZWVrIHVuaXQgcHJvcGVydGllcy5cbiAqIE1vZGlmaWVzIG9iaiBpbi1wbGFjZSFcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXNMb2NhbFdlZWtWYWx1ZXMob2JqLCBsb2MpIHtcbiAgY29uc3QgaGFzTG9jYWxlV2Vla0RhdGEgPVxuICAgICFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrZGF5KSB8fFxuICAgICFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrTnVtYmVyKSB8fFxuICAgICFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrWWVhcik7XG4gIGlmIChoYXNMb2NhbGVXZWVrRGF0YSkge1xuICAgIGNvbnN0IGhhc0lzb1dlZWtEYXRhID1cbiAgICAgICFpc1VuZGVmaW5lZChvYmoud2Vla2RheSkgfHwgIWlzVW5kZWZpbmVkKG9iai53ZWVrTnVtYmVyKSB8fCAhaXNVbmRlZmluZWQob2JqLndlZWtZZWFyKTtcblxuICAgIGlmIChoYXNJc29XZWVrRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbm5vdCBtaXggbG9jYWxlLWJhc2VkIHdlZWsgZmllbGRzIHdpdGggSVNPLWJhc2VkIHdlZWsgZmllbGRzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla2RheSkpIG9iai53ZWVrZGF5ID0gb2JqLmxvY2FsV2Vla2RheTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtOdW1iZXIpKSBvYmoud2Vla051bWJlciA9IG9iai5sb2NhbFdlZWtOdW1iZXI7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrWWVhcikpIG9iai53ZWVrWWVhciA9IG9iai5sb2NhbFdlZWtZZWFyO1xuICAgIGRlbGV0ZSBvYmoubG9jYWxXZWVrZGF5O1xuICAgIGRlbGV0ZSBvYmoubG9jYWxXZWVrTnVtYmVyO1xuICAgIGRlbGV0ZSBvYmoubG9jYWxXZWVrWWVhcjtcbiAgICByZXR1cm4ge1xuICAgICAgbWluRGF5c0luRmlyc3RXZWVrOiBsb2MuZ2V0TWluRGF5c0luRmlyc3RXZWVrKCksXG4gICAgICBzdGFydE9mV2VlazogbG9jLmdldFN0YXJ0T2ZXZWVrKCksXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBtaW5EYXlzSW5GaXJzdFdlZWs6IDQsIHN0YXJ0T2ZXZWVrOiAxIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRXZWVrRGF0YShvYmosIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLndlZWtZZWFyKSxcbiAgICB2YWxpZFdlZWsgPSBpbnRlZ2VyQmV0d2VlbihcbiAgICAgIG9iai53ZWVrTnVtYmVyLFxuICAgICAgMSxcbiAgICAgIHdlZWtzSW5XZWVrWWVhcihvYmoud2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspXG4gICAgKSxcbiAgICB2YWxpZFdlZWtkYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla2RheSwgMSwgNyk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrWWVhclwiLCBvYmoud2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWspIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrXCIsIG9iai53ZWVrTnVtYmVyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrZGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla2RheVwiLCBvYmoud2Vla2RheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkT3JkaW5hbERhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRPcmRpbmFsID0gaW50ZWdlckJldHdlZW4ob2JqLm9yZGluYWwsIDEsIGRheXNJblllYXIob2JqLnllYXIpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE9yZGluYWwpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJvcmRpbmFsXCIsIG9iai5vcmRpbmFsKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkTW9udGggPSBpbnRlZ2VyQmV0d2VlbihvYmoubW9udGgsIDEsIDEyKSxcbiAgICB2YWxpZERheSA9IGludGVnZXJCZXR3ZWVuKG9iai5kYXksIDEsIGRheXNJbk1vbnRoKG9iai55ZWFyLCBvYmoubW9udGgpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1vbnRoKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibW9udGhcIiwgb2JqLm1vbnRoKTtcbiAgfSBlbHNlIGlmICghdmFsaWREYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJkYXlcIiwgb2JqLmRheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkVGltZURhdGEob2JqKSB7XG4gIGNvbnN0IHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0gPSBvYmo7XG4gIGNvbnN0IHZhbGlkSG91ciA9XG4gICAgICBpbnRlZ2VyQmV0d2Vlbihob3VyLCAwLCAyMykgfHxcbiAgICAgIChob3VyID09PSAyNCAmJiBtaW51dGUgPT09IDAgJiYgc2Vjb25kID09PSAwICYmIG1pbGxpc2Vjb25kID09PSAwKSxcbiAgICB2YWxpZE1pbnV0ZSA9IGludGVnZXJCZXR3ZWVuKG1pbnV0ZSwgMCwgNTkpLFxuICAgIHZhbGlkU2Vjb25kID0gaW50ZWdlckJldHdlZW4oc2Vjb25kLCAwLCA1OSksXG4gICAgdmFsaWRNaWxsaXNlY29uZCA9IGludGVnZXJCZXR3ZWVuKG1pbGxpc2Vjb25kLCAwLCA5OTkpO1xuXG4gIGlmICghdmFsaWRIb3VyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiaG91clwiLCBob3VyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaW51dGUpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaW51dGVcIiwgbWludXRlKTtcbiAgfSBlbHNlIGlmICghdmFsaWRTZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJzZWNvbmRcIiwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaWxsaXNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbGxpc2Vjb25kXCIsIG1pbGxpc2Vjb25kKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/conversions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/diff.js":
/*!**************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/diff.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../duration.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/duration.js\");\n\n\nfunction dayDiff(earlier, later) {\n  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf(\"day\").valueOf(),\n    ms = utcDayStart(later) - utcDayStart(earlier);\n  return Math.floor(_duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(ms).as(\"days\"));\n}\n\nfunction highOrderDiffs(cursor, later, units) {\n  const differs = [\n    [\"years\", (a, b) => b.year - a.year],\n    [\"quarters\", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],\n    [\"months\", (a, b) => b.month - a.month + (b.year - a.year) * 12],\n    [\n      \"weeks\",\n      (a, b) => {\n        const days = dayDiff(a, b);\n        return (days - (days % 7)) / 7;\n      },\n    ],\n    [\"days\", dayDiff],\n  ];\n\n  const results = {};\n  const earlier = cursor;\n  let lowestOrder, highWater;\n\n  /* This loop tries to diff using larger units first.\n     If we overshoot, we backtrack and try the next smaller unit.\n     \"cursor\" starts out at the earlier timestamp and moves closer and closer to \"later\"\n     as we use smaller and smaller units.\n     highWater keeps track of where we would be if we added one more of the smallest unit,\n     this is used later to potentially convert any difference smaller than the smallest higher order unit\n     into a fraction of that smallest higher order unit\n  */\n  for (const [unit, differ] of differs) {\n    if (units.indexOf(unit) >= 0) {\n      lowestOrder = unit;\n\n      results[unit] = differ(cursor, later);\n      highWater = earlier.plus(results);\n\n      if (highWater > later) {\n        // we overshot the end point, backtrack cursor by 1\n        results[unit]--;\n        cursor = earlier.plus(results);\n\n        // if we are still overshooting now, we need to backtrack again\n        // this happens in certain situations when diffing times in different zones,\n        // because this calculation ignores time zones\n        if (cursor > later) {\n          // keep the \"overshot by 1\" around as highWater\n          highWater = cursor;\n          // backtrack cursor by 1\n          results[unit]--;\n          cursor = earlier.plus(results);\n        }\n      } else {\n        cursor = highWater;\n      }\n    }\n  }\n\n  return [cursor, results, highWater, lowestOrder];\n}\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(earlier, later, units, opts) {\n  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);\n\n  const remainingMillis = later - cursor;\n\n  const lowerOrderUnits = units.filter(\n    (u) => [\"hours\", \"minutes\", \"seconds\", \"milliseconds\"].indexOf(u) >= 0\n  );\n\n  if (lowerOrderUnits.length === 0) {\n    if (highWater < later) {\n      highWater = cursor.plus({ [lowestOrder]: 1 });\n    }\n\n    if (highWater !== cursor) {\n      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);\n    }\n  }\n\n  const duration = _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromObject(results, opts);\n\n  if (lowerOrderUnits.length > 0) {\n    return _duration_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromMillis(remainingMillis, opts)\n      .shiftTo(...lowerOrderUnits)\n      .plus(duration);\n  } else {\n    return duration;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZmYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7O0FBRXRDO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRTtBQUNBLG9CQUFvQixvREFBUTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFVO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0RBQVE7O0FBRTNCO0FBQ0EsV0FBVyxvREFBUTtBQUNuQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZmYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gKGR0KSA9PiBkdC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkuc3RhcnRPZihcImRheVwiKS52YWx1ZU9mKCksXG4gICAgbXMgPSB1dGNEYXlTdGFydChsYXRlcikgLSB1dGNEYXlTdGFydChlYXJsaWVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgY29uc3QgZGlmZmVycyA9IFtcbiAgICBbXCJ5ZWFyc1wiLCAoYSwgYikgPT4gYi55ZWFyIC0gYS55ZWFyXSxcbiAgICBbXCJxdWFydGVyc1wiLCAoYSwgYikgPT4gYi5xdWFydGVyIC0gYS5xdWFydGVyICsgKGIueWVhciAtIGEueWVhcikgKiA0XSxcbiAgICBbXCJtb250aHNcIiwgKGEsIGIpID0+IGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMl0sXG4gICAgW1xuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5cyA9IGRheURpZmYoYSwgYik7XG4gICAgICAgIHJldHVybiAoZGF5cyAtIChkYXlzICUgNykpIC8gNztcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXCJkYXlzXCIsIGRheURpZmZdLFxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgY29uc3QgZWFybGllciA9IGN1cnNvcjtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgLyogVGhpcyBsb29wIHRyaWVzIHRvIGRpZmYgdXNpbmcgbGFyZ2VyIHVuaXRzIGZpcnN0LlxuICAgICBJZiB3ZSBvdmVyc2hvb3QsIHdlIGJhY2t0cmFjayBhbmQgdHJ5IHRoZSBuZXh0IHNtYWxsZXIgdW5pdC5cbiAgICAgXCJjdXJzb3JcIiBzdGFydHMgb3V0IGF0IHRoZSBlYXJsaWVyIHRpbWVzdGFtcCBhbmQgbW92ZXMgY2xvc2VyIGFuZCBjbG9zZXIgdG8gXCJsYXRlclwiXG4gICAgIGFzIHdlIHVzZSBzbWFsbGVyIGFuZCBzbWFsbGVyIHVuaXRzLlxuICAgICBoaWdoV2F0ZXIga2VlcHMgdHJhY2sgb2Ygd2hlcmUgd2Ugd291bGQgYmUgaWYgd2UgYWRkZWQgb25lIG1vcmUgb2YgdGhlIHNtYWxsZXN0IHVuaXQsXG4gICAgIHRoaXMgaXMgdXNlZCBsYXRlciB0byBwb3RlbnRpYWxseSBjb252ZXJ0IGFueSBkaWZmZXJlbmNlIHNtYWxsZXIgdGhhbiB0aGUgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgaW50byBhIGZyYWN0aW9uIG9mIHRoYXQgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgKi9cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGlmZmVyKGN1cnNvciwgbGF0ZXIpO1xuICAgICAgaGlnaFdhdGVyID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICBpZiAoaGlnaFdhdGVyID4gbGF0ZXIpIHtcbiAgICAgICAgLy8gd2Ugb3ZlcnNob3QgdGhlIGVuZCBwb2ludCwgYmFja3RyYWNrIGN1cnNvciBieSAxXG4gICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBzdGlsbCBvdmVyc2hvb3Rpbmcgbm93LCB3ZSBuZWVkIHRvIGJhY2t0cmFjayBhZ2FpblxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gY2VydGFpbiBzaXR1YXRpb25zIHdoZW4gZGlmZmluZyB0aW1lcyBpbiBkaWZmZXJlbnQgem9uZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhpcyBjYWxjdWxhdGlvbiBpZ25vcmVzIHRpbWUgem9uZXNcbiAgICAgICAgaWYgKGN1cnNvciA+IGxhdGVyKSB7XG4gICAgICAgICAgLy8ga2VlcCB0aGUgXCJvdmVyc2hvdCBieSAxXCIgYXJvdW5kIGFzIGhpZ2hXYXRlclxuICAgICAgICAgIGhpZ2hXYXRlciA9IGN1cnNvcjtcbiAgICAgICAgICAvLyBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgICByZXN1bHRzW3VuaXRdLS07XG4gICAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IgPSBoaWdoV2F0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBvcHRzKSB7XG4gIGxldCBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXSA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyk7XG5cbiAgY29uc3QgcmVtYWluaW5nTWlsbGlzID0gbGF0ZXIgLSBjdXJzb3I7XG5cbiAgY29uc3QgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKFxuICAgICh1KSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChyZXN1bHRzLCBvcHRzKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/diff.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/digits.js":
/*!****************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/digits.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   digitRegex: () => (/* binding */ digitRegex),\n/* harmony export */   parseDigits: () => (/* binding */ parseDigits),\n/* harmony export */   resetDigitRegexCache: () => (/* binding */ resetDigitRegexCache)\n/* harmony export */ });\nconst numberingSystems = {\n  arab: \"[\\u0660-\\u0669]\",\n  arabext: \"[\\u06F0-\\u06F9]\",\n  bali: \"[\\u1B50-\\u1B59]\",\n  beng: \"[\\u09E6-\\u09EF]\",\n  deva: \"[\\u0966-\\u096F]\",\n  fullwide: \"[\\uFF10-\\uFF19]\",\n  gujr: \"[\\u0AE6-\\u0AEF]\",\n  hanidec: \"[|||||||||]\",\n  khmr: \"[\\u17E0-\\u17E9]\",\n  knda: \"[\\u0CE6-\\u0CEF]\",\n  laoo: \"[\\u0ED0-\\u0ED9]\",\n  limb: \"[\\u1946-\\u194F]\",\n  mlym: \"[\\u0D66-\\u0D6F]\",\n  mong: \"[\\u1810-\\u1819]\",\n  mymr: \"[\\u1040-\\u1049]\",\n  orya: \"[\\u0B66-\\u0B6F]\",\n  tamldec: \"[\\u0BE6-\\u0BEF]\",\n  telu: \"[\\u0C66-\\u0C6F]\",\n  thai: \"[\\u0E50-\\u0E59]\",\n  tibt: \"[\\u0F20-\\u0F29]\",\n  latn: \"\\\\d\",\n};\n\nconst numberingSystemsUTF16 = {\n  arab: [1632, 1641],\n  arabext: [1776, 1785],\n  bali: [6992, 7001],\n  beng: [2534, 2543],\n  deva: [2406, 2415],\n  fullwide: [65296, 65303],\n  gujr: [2790, 2799],\n  khmr: [6112, 6121],\n  knda: [3302, 3311],\n  laoo: [3792, 3801],\n  limb: [6470, 6479],\n  mlym: [3430, 3439],\n  mong: [6160, 6169],\n  mymr: [4160, 4169],\n  orya: [2918, 2927],\n  tamldec: [3046, 3055],\n  telu: [3174, 3183],\n  thai: [3664, 3673],\n  tibt: [3872, 3881],\n};\n\nconst hanidecChars = numberingSystems.hanidec.replace(/[\\[|\\]]/g, \"\").split(\"\");\n\nfunction parseDigits(str) {\n  let value = parseInt(str, 10);\n  if (isNaN(value)) {\n    value = \"\";\n    for (let i = 0; i < str.length; i++) {\n      const code = str.charCodeAt(i);\n\n      if (str[i].search(numberingSystems.hanidec) !== -1) {\n        value += hanidecChars.indexOf(str[i]);\n      } else {\n        for (const key in numberingSystemsUTF16) {\n          const [min, max] = numberingSystemsUTF16[key];\n          if (code >= min && code <= max) {\n            value += code - min;\n          }\n        }\n      }\n    }\n    return parseInt(value, 10);\n  } else {\n    return value;\n  }\n}\n\n// cache of {numberingSystem: {append: regex}}\nconst digitRegexCache = new Map();\nfunction resetDigitRegexCache() {\n  digitRegexCache.clear();\n}\n\nfunction digitRegex({ numberingSystem }, append = \"\") {\n  const ns = numberingSystem || \"latn\";\n\n  let appendCache = digitRegexCache.get(ns);\n  if (appendCache === undefined) {\n    appendCache = new Map();\n    digitRegexCache.set(ns, appendCache);\n  }\n  let regex = appendCache.get(append);\n  if (regex === undefined) {\n    regex = new RegExp(`${numberingSystems[ns]}${append}`);\n    appendCache.set(append, regex);\n  }\n\n  return regex;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ087QUFDUDtBQUNBOztBQUVPLHNCQUFzQixpQkFBaUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCLEVBQUUsT0FBTztBQUN4RDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWdpdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IHtcbiAgYXJhYjogXCJbXFx1MDY2MC1cXHUwNjY5XVwiLFxuICBhcmFiZXh0OiBcIltcXHUwNkYwLVxcdTA2RjldXCIsXG4gIGJhbGk6IFwiW1xcdTFCNTAtXFx1MUI1OV1cIixcbiAgYmVuZzogXCJbXFx1MDlFNi1cXHUwOUVGXVwiLFxuICBkZXZhOiBcIltcXHUwOTY2LVxcdTA5NkZdXCIsXG4gIGZ1bGx3aWRlOiBcIltcXHVGRjEwLVxcdUZGMTldXCIsXG4gIGd1anI6IFwiW1xcdTBBRTYtXFx1MEFFRl1cIixcbiAgaGFuaWRlYzogXCJb44CHfOS4gHzkuox85LiJfOWbm3zkupR85YWtfOS4g3zlhat85LmdXVwiLFxuICBraG1yOiBcIltcXHUxN0UwLVxcdTE3RTldXCIsXG4gIGtuZGE6IFwiW1xcdTBDRTYtXFx1MENFRl1cIixcbiAgbGFvbzogXCJbXFx1MEVEMC1cXHUwRUQ5XVwiLFxuICBsaW1iOiBcIltcXHUxOTQ2LVxcdTE5NEZdXCIsXG4gIG1seW06IFwiW1xcdTBENjYtXFx1MEQ2Rl1cIixcbiAgbW9uZzogXCJbXFx1MTgxMC1cXHUxODE5XVwiLFxuICBteW1yOiBcIltcXHUxMDQwLVxcdTEwNDldXCIsXG4gIG9yeWE6IFwiW1xcdTBCNjYtXFx1MEI2Rl1cIixcbiAgdGFtbGRlYzogXCJbXFx1MEJFNi1cXHUwQkVGXVwiLFxuICB0ZWx1OiBcIltcXHUwQzY2LVxcdTBDNkZdXCIsXG4gIHRoYWk6IFwiW1xcdTBFNTAtXFx1MEU1OV1cIixcbiAgdGlidDogXCJbXFx1MEYyMC1cXHUwRjI5XVwiLFxuICBsYXRuOiBcIlxcXFxkXCIsXG59O1xuXG5jb25zdCBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXSxcbn07XG5cbmNvbnN0IGhhbmlkZWNDaGFycyA9IG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYy5yZXBsYWNlKC9bXFxbfFxcXV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZ2l0cyhzdHIpIHtcbiAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG51bWJlcmluZ1N5c3RlbXNVVEYxNikge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XTtcbiAgICAgICAgICBpZiAoY29kZSA+PSBtaW4gJiYgY29kZSA8PSBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGNvZGUgLSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vLyBjYWNoZSBvZiB7bnVtYmVyaW5nU3lzdGVtOiB7YXBwZW5kOiByZWdleH19XG5jb25zdCBkaWdpdFJlZ2V4Q2FjaGUgPSBuZXcgTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXREaWdpdFJlZ2V4Q2FjaGUoKSB7XG4gIGRpZ2l0UmVnZXhDYWNoZS5jbGVhcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlnaXRSZWdleCh7IG51bWJlcmluZ1N5c3RlbSB9LCBhcHBlbmQgPSBcIlwiKSB7XG4gIGNvbnN0IG5zID0gbnVtYmVyaW5nU3lzdGVtIHx8IFwibGF0blwiO1xuXG4gIGxldCBhcHBlbmRDYWNoZSA9IGRpZ2l0UmVnZXhDYWNoZS5nZXQobnMpO1xuICBpZiAoYXBwZW5kQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGFwcGVuZENhY2hlID0gbmV3IE1hcCgpO1xuICAgIGRpZ2l0UmVnZXhDYWNoZS5zZXQobnMsIGFwcGVuZENhY2hlKTtcbiAgfVxuICBsZXQgcmVnZXggPSBhcHBlbmRDYWNoZS5nZXQoYXBwZW5kKTtcbiAgaWYgKHJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZWdleCA9IG5ldyBSZWdFeHAoYCR7bnVtYmVyaW5nU3lzdGVtc1tuc119JHthcHBlbmR9YCk7XG4gICAgYXBwZW5kQ2FjaGUuc2V0KGFwcGVuZCwgcmVnZXgpO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/digits.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/english.js":
/*!*****************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/english.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eraForDateTime: () => (/* binding */ eraForDateTime),\n/* harmony export */   eras: () => (/* binding */ eras),\n/* harmony export */   erasLong: () => (/* binding */ erasLong),\n/* harmony export */   erasNarrow: () => (/* binding */ erasNarrow),\n/* harmony export */   erasShort: () => (/* binding */ erasShort),\n/* harmony export */   formatRelativeTime: () => (/* binding */ formatRelativeTime),\n/* harmony export */   formatString: () => (/* binding */ formatString),\n/* harmony export */   meridiemForDateTime: () => (/* binding */ meridiemForDateTime),\n/* harmony export */   meridiems: () => (/* binding */ meridiems),\n/* harmony export */   monthForDateTime: () => (/* binding */ monthForDateTime),\n/* harmony export */   months: () => (/* binding */ months),\n/* harmony export */   monthsLong: () => (/* binding */ monthsLong),\n/* harmony export */   monthsNarrow: () => (/* binding */ monthsNarrow),\n/* harmony export */   monthsShort: () => (/* binding */ monthsShort),\n/* harmony export */   weekdayForDateTime: () => (/* binding */ weekdayForDateTime),\n/* harmony export */   weekdays: () => (/* binding */ weekdays),\n/* harmony export */   weekdaysLong: () => (/* binding */ weekdaysLong),\n/* harmony export */   weekdaysNarrow: () => (/* binding */ weekdaysNarrow),\n/* harmony export */   weekdaysShort: () => (/* binding */ weekdaysShort)\n/* harmony export */ });\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n\n\n\nfunction stringify(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\n\n/**\n * @private\n */\n\nconst monthsLong = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n];\n\nconst monthsShort = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\nconst monthsNarrow = [\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"];\n\nfunction months(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...monthsNarrow];\n    case \"short\":\n      return [...monthsShort];\n    case \"long\":\n      return [...monthsLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"];\n    case \"2-digit\":\n      return [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\n    default:\n      return null;\n  }\n}\n\nconst weekdaysLong = [\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\",\n];\n\nconst weekdaysShort = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n\nconst weekdaysNarrow = [\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\"];\n\nfunction weekdays(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...weekdaysNarrow];\n    case \"short\":\n      return [...weekdaysShort];\n    case \"long\":\n      return [...weekdaysLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n    default:\n      return null;\n  }\n}\n\nconst meridiems = [\"AM\", \"PM\"];\n\nconst erasLong = [\"Before Christ\", \"Anno Domini\"];\n\nconst erasShort = [\"BC\", \"AD\"];\n\nconst erasNarrow = [\"B\", \"A\"];\n\nfunction eras(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...erasNarrow];\n    case \"short\":\n      return [...erasShort];\n    case \"long\":\n      return [...erasLong];\n    default:\n      return null;\n  }\n}\n\nfunction meridiemForDateTime(dt) {\n  return meridiems[dt.hour < 12 ? 0 : 1];\n}\n\nfunction weekdayForDateTime(dt, length) {\n  return weekdays(length)[dt.weekday - 1];\n}\n\nfunction monthForDateTime(dt, length) {\n  return months(length)[dt.month - 1];\n}\n\nfunction eraForDateTime(dt, length) {\n  return eras(length)[dt.year < 0 ? 0 : 1];\n}\n\nfunction formatRelativeTime(unit, count, numeric = \"always\", narrow = false) {\n  const units = {\n    years: [\"year\", \"yr.\"],\n    quarters: [\"quarter\", \"qtr.\"],\n    months: [\"month\", \"mo.\"],\n    weeks: [\"week\", \"wk.\"],\n    days: [\"day\", \"day\", \"days\"],\n    hours: [\"hour\", \"hr.\"],\n    minutes: [\"minute\", \"min.\"],\n    seconds: [\"second\", \"sec.\"],\n  };\n\n  const lastable = [\"hours\", \"minutes\", \"seconds\"].indexOf(unit) === -1;\n\n  if (numeric === \"auto\" && lastable) {\n    const isDay = unit === \"days\";\n    switch (count) {\n      case 1:\n        return isDay ? \"tomorrow\" : `next ${units[unit][0]}`;\n      case -1:\n        return isDay ? \"yesterday\" : `last ${units[unit][0]}`;\n      case 0:\n        return isDay ? \"today\" : `this ${units[unit][0]}`;\n      default: // fall through\n    }\n  }\n\n  const isInPast = Object.is(count, -0) || count < 0,\n    fmtValue = Math.abs(count),\n    singular = fmtValue === 1,\n    lilUnits = units[unit],\n    fmtUnit = narrow\n      ? singular\n        ? lilUnits[1]\n        : lilUnits[2] || lilUnits[1]\n      : singular\n      ? units[unit][0]\n      : unit;\n  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;\n}\n\nfunction formatString(knownFormat) {\n  // these all have the offsets removed because we don't have access to them\n  // without all the intl stuff this is backfilling\n  const filtered = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.pick)(knownFormat, [\n      \"weekday\",\n      \"era\",\n      \"year\",\n      \"month\",\n      \"day\",\n      \"hour\",\n      \"minute\",\n      \"second\",\n      \"timeZoneName\",\n      \"hourCycle\",\n    ]),\n    key = stringify(filtered),\n    dateTimeHuge = \"EEEE, LLLL d, yyyy, h:mm a\";\n  switch (key) {\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_SHORT):\n      return \"M/d/yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED):\n      return \"LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED_WITH_WEEKDAY):\n      return \"EEE, LLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_FULL):\n      return \"LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_HUGE):\n      return \"EEEE, LLLL d, yyyy\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_SIMPLE):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SECONDS):\n      return \"h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SHORT_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_LONG_OFFSET):\n      return \"h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_SIMPLE):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SECONDS):\n      return \"HH:mm:ss\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SHORT_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_LONG_OFFSET):\n      return \"HH:mm\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT):\n      return \"M/d/yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED):\n      return \"LLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL):\n      return \"LLLL d, yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE):\n      return dateTimeHuge;\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT_WITH_SECONDS):\n      return \"M/d/yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_SECONDS):\n      return \"LLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_WEEKDAY):\n      return \"EEE, d LLL yyyy, h:mm a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL_WITH_SECONDS):\n      return \"LLLL d, yyyy, h:mm:ss a\";\n    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE_WITH_SECONDS):\n      return \"EEEE, LLLL d, yyyy, h:mm:ss a\";\n    default:\n      return dateTimeHuge;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2VuZ2xpc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ1A7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0EsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVLEVBQUUsU0FBUyxhQUFhLFVBQVUsRUFBRSxRQUFRO0FBQzdFOztBQUVPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFrQjtBQUNyQztBQUNBLG1CQUFtQixpREFBZ0I7QUFDbkM7QUFDQSxtQkFBbUIsOERBQTZCO0FBQ2hEO0FBQ0EsbUJBQW1CLGtEQUFpQjtBQUNwQztBQUNBLG1CQUFtQixrREFBaUI7QUFDcEM7QUFDQSxtQkFBbUIsb0RBQW1CO0FBQ3RDO0FBQ0EsbUJBQW1CLDBEQUF5QjtBQUM1QztBQUNBLG1CQUFtQiwrREFBOEI7QUFDakQ7QUFDQSxtQkFBbUIsOERBQTZCO0FBQ2hEO0FBQ0EsbUJBQW1CLHVEQUFzQjtBQUN6QztBQUNBLG1CQUFtQiw2REFBNEI7QUFDL0M7QUFDQSxtQkFBbUIsa0VBQWlDO0FBQ3BEO0FBQ0EsbUJBQW1CLGlFQUFnQztBQUNuRDtBQUNBLG1CQUFtQix1REFBc0I7QUFDekM7QUFDQSxtQkFBbUIscURBQW9CO0FBQ3ZDO0FBQ0EsbUJBQW1CLHNEQUFxQjtBQUN4QztBQUNBLG1CQUFtQixzREFBcUI7QUFDeEM7QUFDQSxtQkFBbUIsb0VBQW1DO0FBQ3REO0FBQ0EsbUJBQW1CLGtFQUFpQztBQUNwRDtBQUNBLG1CQUFtQixrRUFBaUM7QUFDcEQ7QUFDQSxtQkFBbUIsbUVBQWtDO0FBQ3JEO0FBQ0EsbUJBQW1CLG1FQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBpY2sgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgT2JqZWN0LmtleXMob2JqKS5zb3J0KCkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1vbnRoc0xvbmcgPSBbXG4gIFwiSmFudWFyeVwiLFxuICBcIkZlYnJ1YXJ5XCIsXG4gIFwiTWFyY2hcIixcbiAgXCJBcHJpbFwiLFxuICBcIk1heVwiLFxuICBcIkp1bmVcIixcbiAgXCJKdWx5XCIsXG4gIFwiQXVndXN0XCIsXG4gIFwiU2VwdGVtYmVyXCIsXG4gIFwiT2N0b2JlclwiLFxuICBcIk5vdmVtYmVyXCIsXG4gIFwiRGVjZW1iZXJcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IFtcbiAgXCJKYW5cIixcbiAgXCJGZWJcIixcbiAgXCJNYXJcIixcbiAgXCJBcHJcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5cIixcbiAgXCJKdWxcIixcbiAgXCJBdWdcIixcbiAgXCJTZXBcIixcbiAgXCJPY3RcIixcbiAgXCJOb3ZcIixcbiAgXCJEZWNcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNOYXJyb3cgPSBbXCJKXCIsIFwiRlwiLCBcIk1cIiwgXCJBXCIsIFwiTVwiLCBcIkpcIiwgXCJKXCIsIFwiQVwiLCBcIlNcIiwgXCJPXCIsIFwiTlwiLCBcIkRcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aHMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgY2FzZSBcIjItZGlnaXRcIjpcbiAgICAgIHJldHVybiBbXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c0xvbmcgPSBbXG4gIFwiTW9uZGF5XCIsXG4gIFwiVHVlc2RheVwiLFxuICBcIldlZG5lc2RheVwiLFxuICBcIlRodXJzZGF5XCIsXG4gIFwiRnJpZGF5XCIsXG4gIFwiU2F0dXJkYXlcIixcbiAgXCJTdW5kYXlcIixcbl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c1Nob3J0ID0gW1wiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsIFwiU3VuXCJdO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNOYXJyb3cgPSBbXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIiwgXCJTXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWVyaWRpZW1zID0gW1wiQU1cIiwgXCJQTVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNMb25nID0gW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc1Nob3J0ID0gW1wiQkNcIiwgXCJBRFwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNOYXJyb3cgPSBbXCJCXCIsIFwiQVwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVyYXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTG9uZ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJpZGllbUZvckRhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBtZXJpZGllbXNbZHQuaG91ciA8IDEyID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIHdlZWtkYXlzKGxlbmd0aClbZHQud2Vla2RheSAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBtb250aHMobGVuZ3RoKVtkdC5tb250aCAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gZXJhcyhsZW5ndGgpW2R0LnllYXIgPCAwID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCBudW1lcmljID0gXCJhbHdheXNcIiwgbmFycm93ID0gZmFsc2UpIHtcbiAgY29uc3QgdW5pdHMgPSB7XG4gICAgeWVhcnM6IFtcInllYXJcIiwgXCJ5ci5cIl0sXG4gICAgcXVhcnRlcnM6IFtcInF1YXJ0ZXJcIiwgXCJxdHIuXCJdLFxuICAgIG1vbnRoczogW1wibW9udGhcIiwgXCJtby5cIl0sXG4gICAgd2Vla3M6IFtcIndlZWtcIiwgXCJ3ay5cIl0sXG4gICAgZGF5czogW1wiZGF5XCIsIFwiZGF5XCIsIFwiZGF5c1wiXSxcbiAgICBob3VyczogW1wiaG91clwiLCBcImhyLlwiXSxcbiAgICBtaW51dGVzOiBbXCJtaW51dGVcIiwgXCJtaW4uXCJdLFxuICAgIHNlY29uZHM6IFtcInNlY29uZFwiLCBcInNlYy5cIl0sXG4gIH07XG5cbiAgY29uc3QgbGFzdGFibGUgPSBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdLmluZGV4T2YodW5pdCkgPT09IC0xO1xuXG4gIGlmIChudW1lcmljID09PSBcImF1dG9cIiAmJiBsYXN0YWJsZSkge1xuICAgIGNvbnN0IGlzRGF5ID0gdW5pdCA9PT0gXCJkYXlzXCI7XG4gICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvbW9ycm93XCIgOiBgbmV4dCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInllc3RlcmRheVwiIDogYGxhc3QgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvZGF5XCIgOiBgdGhpcyAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBkZWZhdWx0OiAvLyBmYWxsIHRocm91Z2hcbiAgICB9XG4gIH1cblxuICBjb25zdCBpc0luUGFzdCA9IE9iamVjdC5pcyhjb3VudCwgLTApIHx8IGNvdW50IDwgMCxcbiAgICBmbXRWYWx1ZSA9IE1hdGguYWJzKGNvdW50KSxcbiAgICBzaW5ndWxhciA9IGZtdFZhbHVlID09PSAxLFxuICAgIGxpbFVuaXRzID0gdW5pdHNbdW5pdF0sXG4gICAgZm10VW5pdCA9IG5hcnJvd1xuICAgICAgPyBzaW5ndWxhclxuICAgICAgICA/IGxpbFVuaXRzWzFdXG4gICAgICAgIDogbGlsVW5pdHNbMl0gfHwgbGlsVW5pdHNbMV1cbiAgICAgIDogc2luZ3VsYXJcbiAgICAgID8gdW5pdHNbdW5pdF1bMF1cbiAgICAgIDogdW5pdDtcbiAgcmV0dXJuIGlzSW5QYXN0ID8gYCR7Zm10VmFsdWV9ICR7Zm10VW5pdH0gYWdvYCA6IGBpbiAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmluZyhrbm93bkZvcm1hdCkge1xuICAvLyB0aGVzZSBhbGwgaGF2ZSB0aGUgb2Zmc2V0cyByZW1vdmVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICAvLyB3aXRob3V0IGFsbCB0aGUgaW50bCBzdHVmZiB0aGlzIGlzIGJhY2tmaWxsaW5nXG4gIGNvbnN0IGZpbHRlcmVkID0gcGljayhrbm93bkZvcm1hdCwgW1xuICAgICAgXCJ3ZWVrZGF5XCIsXG4gICAgICBcImVyYVwiLFxuICAgICAgXCJ5ZWFyXCIsXG4gICAgICBcIm1vbnRoXCIsXG4gICAgICBcImRheVwiLFxuICAgICAgXCJob3VyXCIsXG4gICAgICBcIm1pbnV0ZVwiLFxuICAgICAgXCJzZWNvbmRcIixcbiAgICAgIFwidGltZVpvbmVOYW1lXCIsXG4gICAgICBcImhvdXJDeWNsZVwiLFxuICAgIF0pLFxuICAgIGtleSA9IHN0cmluZ2lmeShmaWx0ZXJlZCksXG4gICAgZGF0ZVRpbWVIdWdlID0gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0hVR0UpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcImg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfU0lNUExFKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJISDptbTpzc1wiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRSk6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIGQgTExMIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/english.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formats.js":
/*!*****************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/formats.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DATETIME_FULL: () => (/* binding */ DATETIME_FULL),\n/* harmony export */   DATETIME_FULL_WITH_SECONDS: () => (/* binding */ DATETIME_FULL_WITH_SECONDS),\n/* harmony export */   DATETIME_HUGE: () => (/* binding */ DATETIME_HUGE),\n/* harmony export */   DATETIME_HUGE_WITH_SECONDS: () => (/* binding */ DATETIME_HUGE_WITH_SECONDS),\n/* harmony export */   DATETIME_MED: () => (/* binding */ DATETIME_MED),\n/* harmony export */   DATETIME_MED_WITH_SECONDS: () => (/* binding */ DATETIME_MED_WITH_SECONDS),\n/* harmony export */   DATETIME_MED_WITH_WEEKDAY: () => (/* binding */ DATETIME_MED_WITH_WEEKDAY),\n/* harmony export */   DATETIME_SHORT: () => (/* binding */ DATETIME_SHORT),\n/* harmony export */   DATETIME_SHORT_WITH_SECONDS: () => (/* binding */ DATETIME_SHORT_WITH_SECONDS),\n/* harmony export */   DATE_FULL: () => (/* binding */ DATE_FULL),\n/* harmony export */   DATE_HUGE: () => (/* binding */ DATE_HUGE),\n/* harmony export */   DATE_MED: () => (/* binding */ DATE_MED),\n/* harmony export */   DATE_MED_WITH_WEEKDAY: () => (/* binding */ DATE_MED_WITH_WEEKDAY),\n/* harmony export */   DATE_SHORT: () => (/* binding */ DATE_SHORT),\n/* harmony export */   TIME_24_SIMPLE: () => (/* binding */ TIME_24_SIMPLE),\n/* harmony export */   TIME_24_WITH_LONG_OFFSET: () => (/* binding */ TIME_24_WITH_LONG_OFFSET),\n/* harmony export */   TIME_24_WITH_SECONDS: () => (/* binding */ TIME_24_WITH_SECONDS),\n/* harmony export */   TIME_24_WITH_SHORT_OFFSET: () => (/* binding */ TIME_24_WITH_SHORT_OFFSET),\n/* harmony export */   TIME_SIMPLE: () => (/* binding */ TIME_SIMPLE),\n/* harmony export */   TIME_WITH_LONG_OFFSET: () => (/* binding */ TIME_WITH_LONG_OFFSET),\n/* harmony export */   TIME_WITH_SECONDS: () => (/* binding */ TIME_WITH_SECONDS),\n/* harmony export */   TIME_WITH_SHORT_OFFSET: () => (/* binding */ TIME_WITH_SHORT_OFFSET)\n/* harmony export */ });\n/**\n * @private\n */\n\nconst n = \"numeric\",\n  s = \"short\",\n  l = \"long\";\n\nconst DATE_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n};\n\nconst DATE_MED = {\n  year: n,\n  month: s,\n  day: n,\n};\n\nconst DATE_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n};\n\nconst DATE_FULL = {\n  year: n,\n  month: l,\n  day: n,\n};\n\nconst DATE_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n};\n\nconst TIME_SIMPLE = {\n  hour: n,\n  minute: n,\n};\n\nconst TIME_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst TIME_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst TIME_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n\nconst TIME_24_SIMPLE = {\n  hour: n,\n  minute: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SECONDS = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n};\n\nconst TIME_24_WITH_SHORT_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: s,\n};\n\nconst TIME_24_WITH_LONG_OFFSET = {\n  hour: n,\n  minute: n,\n  second: n,\n  hourCycle: \"h23\",\n  timeZoneName: l,\n};\n\nconst DATETIME_SHORT = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_SHORT_WITH_SECONDS = {\n  year: n,\n  month: n,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_MED_WITH_SECONDS = {\n  year: n,\n  month: s,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n};\n\nconst DATETIME_MED_WITH_WEEKDAY = {\n  year: n,\n  month: s,\n  day: n,\n  weekday: s,\n  hour: n,\n  minute: n,\n};\n\nconst DATETIME_FULL = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_FULL_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: s,\n};\n\nconst DATETIME_HUGE = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  timeZoneName: l,\n};\n\nconst DATETIME_HUGE_WITH_SECONDS = {\n  year: n,\n  month: l,\n  day: n,\n  weekday: l,\n  hour: n,\n  minute: n,\n  second: n,\n  timeZoneName: l,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgbiA9IFwibnVtZXJpY1wiLFxuICBzID0gXCJzaG9ydFwiLFxuICBsID0gXCJsb25nXCI7XG5cbmV4cG9ydCBjb25zdCBEQVRFX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formats.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formatter.js":
/*!*******************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/formatter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Formatter)\n/* harmony export */ });\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formats.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formats.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n\n\n\n\nfunction stringifyTokens(splits, tokenToString) {\n  let s = \"\";\n  for (const token of splits) {\n    if (token.literal) {\n      s += token.val;\n    } else {\n      s += tokenToString(token.val);\n    }\n  }\n  return s;\n}\n\nconst macroTokenToFormatOpts = {\n  D: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_SHORT,\n  DD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_MED,\n  DDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_FULL,\n  DDDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_HUGE,\n  t: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_SIMPLE,\n  tt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SECONDS,\n  ttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SHORT_OFFSET,\n  tttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_LONG_OFFSET,\n  T: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_SIMPLE,\n  TT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SECONDS,\n  TTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SHORT_OFFSET,\n  TTTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_LONG_OFFSET,\n  f: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT,\n  ff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED,\n  fff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL,\n  ffff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE,\n  F: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT_WITH_SECONDS,\n  FF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED_WITH_SECONDS,\n  FFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL_WITH_SECONDS,\n  FFFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE_WITH_SECONDS,\n};\n\n/**\n * @private\n */\n\nclass Formatter {\n  static create(locale, opts = {}) {\n    return new Formatter(locale, opts);\n  }\n\n  static parseFormat(fmt) {\n    // white-space is always considered a literal in user-provided formats\n    // the \" \" token has a special meaning (see unitForToken)\n\n    let current = null,\n      currentFull = \"\",\n      bracketed = false;\n    const splits = [];\n    for (let i = 0; i < fmt.length; i++) {\n      const c = fmt.charAt(i);\n      if (c === \"'\") {\n        // turn '' into a literal signal quote instead of just skipping the empty literal\n        if (currentFull.length > 0 || bracketed) {\n          splits.push({\n            literal: bracketed || /^\\s+$/.test(currentFull),\n            val: currentFull === \"\" ? \"'\" : currentFull,\n          });\n        }\n        current = null;\n        currentFull = \"\";\n        bracketed = !bracketed;\n      } else if (bracketed) {\n        currentFull += c;\n      } else if (c === current) {\n        currentFull += c;\n      } else {\n        if (currentFull.length > 0) {\n          splits.push({ literal: /^\\s+$/.test(currentFull), val: currentFull });\n        }\n        currentFull = c;\n        current = c;\n      }\n    }\n\n    if (currentFull.length > 0) {\n      splits.push({ literal: bracketed || /^\\s+$/.test(currentFull), val: currentFull });\n    }\n\n    return splits;\n  }\n\n  static macroTokenToFormatOpts(token) {\n    return macroTokenToFormatOpts[token];\n  }\n\n  constructor(locale, formatOpts) {\n    this.opts = formatOpts;\n    this.loc = locale;\n    this.systemLoc = null;\n  }\n\n  formatWithSystemDefault(dt, opts) {\n    if (this.systemLoc === null) {\n      this.systemLoc = this.loc.redefaultToSystem();\n    }\n    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });\n    return df.format();\n  }\n\n  dtFormatter(dt, opts = {}) {\n    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });\n  }\n\n  formatDateTime(dt, opts) {\n    return this.dtFormatter(dt, opts).format();\n  }\n\n  formatDateTimeParts(dt, opts) {\n    return this.dtFormatter(dt, opts).formatToParts();\n  }\n\n  formatInterval(interval, opts) {\n    const df = this.dtFormatter(interval.start, opts);\n    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());\n  }\n\n  resolvedOptions(dt, opts) {\n    return this.dtFormatter(dt, opts).resolvedOptions();\n  }\n\n  num(n, p = 0, signDisplay = undefined) {\n    // we get some perf out of doing this here, annoyingly\n    if (this.opts.forceSimple) {\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.padStart)(n, p);\n    }\n\n    const opts = { ...this.opts };\n\n    if (p > 0) {\n      opts.padTo = p;\n    }\n    if (signDisplay) {\n      opts.signDisplay = signDisplay;\n    }\n\n    return this.loc.numberFormatter(opts).format(n);\n  }\n\n  formatDateTimeFromString(dt, fmt) {\n    const knownEnglish = this.loc.listingMode() === \"en\",\n      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== \"gregory\",\n      string = (opts, extract) => this.loc.extract(dt, opts, extract),\n      formatOffset = (opts) => {\n        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {\n          return \"Z\";\n        }\n\n        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : \"\";\n      },\n      meridiem = () =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.meridiemForDateTime(dt)\n          : string({ hour: \"numeric\", hourCycle: \"h12\" }, \"dayperiod\"),\n      month = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.monthForDateTime(dt, length)\n          : string(standalone ? { month: length } : { month: length, day: \"numeric\" }, \"month\"),\n      weekday = (length, standalone) =>\n        knownEnglish\n          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.weekdayForDateTime(dt, length)\n          : string(\n              standalone ? { weekday: length } : { weekday: length, month: \"long\", day: \"numeric\" },\n              \"weekday\"\n            ),\n      maybeMacro = (token) => {\n        const formatOpts = Formatter.macroTokenToFormatOpts(token);\n        if (formatOpts) {\n          return this.formatWithSystemDefault(dt, formatOpts);\n        } else {\n          return token;\n        }\n      },\n      era = (length) =>\n        knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_0__.eraForDateTime(dt, length) : string({ era: length }, \"era\"),\n      tokenToString = (token) => {\n        // Where possible: https://cldr.unicode.org/translation/date-time/date-time-symbols\n        switch (token) {\n          // ms\n          case \"S\":\n            return this.num(dt.millisecond);\n          case \"u\":\n          // falls through\n          case \"SSS\":\n            return this.num(dt.millisecond, 3);\n          // seconds\n          case \"s\":\n            return this.num(dt.second);\n          case \"ss\":\n            return this.num(dt.second, 2);\n          // fractional seconds\n          case \"uu\":\n            return this.num(Math.floor(dt.millisecond / 10), 2);\n          case \"uuu\":\n            return this.num(Math.floor(dt.millisecond / 100));\n          // minutes\n          case \"m\":\n            return this.num(dt.minute);\n          case \"mm\":\n            return this.num(dt.minute, 2);\n          // hours\n          case \"h\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);\n          case \"hh\":\n            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);\n          case \"H\":\n            return this.num(dt.hour);\n          case \"HH\":\n            return this.num(dt.hour, 2);\n          // offset\n          case \"Z\":\n            // like +6\n            return formatOffset({ format: \"narrow\", allowZ: this.opts.allowZ });\n          case \"ZZ\":\n            // like +06:00\n            return formatOffset({ format: \"short\", allowZ: this.opts.allowZ });\n          case \"ZZZ\":\n            // like +0600\n            return formatOffset({ format: \"techie\", allowZ: this.opts.allowZ });\n          case \"ZZZZ\":\n            // like EST\n            return dt.zone.offsetName(dt.ts, { format: \"short\", locale: this.loc.locale });\n          case \"ZZZZZ\":\n            // like Eastern Standard Time\n            return dt.zone.offsetName(dt.ts, { format: \"long\", locale: this.loc.locale });\n          // zone\n          case \"z\":\n            // like America/New_York\n            return dt.zoneName;\n          // meridiems\n          case \"a\":\n            return meridiem();\n          // dates\n          case \"d\":\n            return useDateTimeFormatter ? string({ day: \"numeric\" }, \"day\") : this.num(dt.day);\n          case \"dd\":\n            return useDateTimeFormatter ? string({ day: \"2-digit\" }, \"day\") : this.num(dt.day, 2);\n          // weekdays - standalone\n          case \"c\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"ccc\":\n            // like 'Tues'\n            return weekday(\"short\", true);\n          case \"cccc\":\n            // like 'Tuesday'\n            return weekday(\"long\", true);\n          case \"ccccc\":\n            // like 'T'\n            return weekday(\"narrow\", true);\n          // weekdays - format\n          case \"E\":\n            // like 1\n            return this.num(dt.weekday);\n          case \"EEE\":\n            // like 'Tues'\n            return weekday(\"short\", false);\n          case \"EEEE\":\n            // like 'Tuesday'\n            return weekday(\"long\", false);\n          case \"EEEEE\":\n            // like 'T'\n            return weekday(\"narrow\", false);\n          // months - standalone\n          case \"L\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"LL\":\n            // like 01, doesn't seem to work\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\", day: \"numeric\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"LLL\":\n            // like Jan\n            return month(\"short\", true);\n          case \"LLLL\":\n            // like January\n            return month(\"long\", true);\n          case \"LLLLL\":\n            // like J\n            return month(\"narrow\", true);\n          // months - format\n          case \"M\":\n            // like 1\n            return useDateTimeFormatter\n              ? string({ month: \"numeric\" }, \"month\")\n              : this.num(dt.month);\n          case \"MM\":\n            // like 01\n            return useDateTimeFormatter\n              ? string({ month: \"2-digit\" }, \"month\")\n              : this.num(dt.month, 2);\n          case \"MMM\":\n            // like Jan\n            return month(\"short\", false);\n          case \"MMMM\":\n            // like January\n            return month(\"long\", false);\n          case \"MMMMM\":\n            // like J\n            return month(\"narrow\", false);\n          // years\n          case \"y\":\n            // like 2014\n            return useDateTimeFormatter ? string({ year: \"numeric\" }, \"year\") : this.num(dt.year);\n          case \"yy\":\n            // like 14\n            return useDateTimeFormatter\n              ? string({ year: \"2-digit\" }, \"year\")\n              : this.num(dt.year.toString().slice(-2), 2);\n          case \"yyyy\":\n            // like 0012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 4);\n          case \"yyyyyy\":\n            // like 000012\n            return useDateTimeFormatter\n              ? string({ year: \"numeric\" }, \"year\")\n              : this.num(dt.year, 6);\n          // eras\n          case \"G\":\n            // like AD\n            return era(\"short\");\n          case \"GG\":\n            // like Anno Domini\n            return era(\"long\");\n          case \"GGGGG\":\n            return era(\"narrow\");\n          case \"kk\":\n            return this.num(dt.weekYear.toString().slice(-2), 2);\n          case \"kkkk\":\n            return this.num(dt.weekYear, 4);\n          case \"W\":\n            return this.num(dt.weekNumber);\n          case \"WW\":\n            return this.num(dt.weekNumber, 2);\n          case \"n\":\n            return this.num(dt.localWeekNumber);\n          case \"nn\":\n            return this.num(dt.localWeekNumber, 2);\n          case \"ii\":\n            return this.num(dt.localWeekYear.toString().slice(-2), 2);\n          case \"iiii\":\n            return this.num(dt.localWeekYear, 4);\n          case \"o\":\n            return this.num(dt.ordinal);\n          case \"ooo\":\n            return this.num(dt.ordinal, 3);\n          case \"q\":\n            // like 1\n            return this.num(dt.quarter);\n          case \"qq\":\n            // like 01\n            return this.num(dt.quarter, 2);\n          case \"X\":\n            return this.num(Math.floor(dt.ts / 1000));\n          case \"x\":\n            return this.num(dt.ts);\n          default:\n            return maybeMacro(token);\n        }\n      };\n\n    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);\n  }\n\n  formatDurationFromString(dur, fmt) {\n    const invertLargest = this.opts.signMode === \"negativeLargestOnly\" ? -1 : 1;\n    const tokenToField = (token) => {\n        switch (token[0]) {\n          case \"S\":\n            return \"milliseconds\";\n          case \"s\":\n            return \"seconds\";\n          case \"m\":\n            return \"minutes\";\n          case \"h\":\n            return \"hours\";\n          case \"d\":\n            return \"days\";\n          case \"w\":\n            return \"weeks\";\n          case \"M\":\n            return \"months\";\n          case \"y\":\n            return \"years\";\n          default:\n            return null;\n        }\n      },\n      tokenToString = (lildur, info) => (token) => {\n        const mapped = tokenToField(token);\n        if (mapped) {\n          const inversionFactor =\n            info.isNegativeDuration && mapped !== info.largestUnit ? invertLargest : 1;\n          let signDisplay;\n          if (this.opts.signMode === \"negativeLargestOnly\" && mapped !== info.largestUnit) {\n            signDisplay = \"never\";\n          } else if (this.opts.signMode === \"all\") {\n            signDisplay = \"always\";\n          } else {\n            // \"auto\" and \"negative\" are the same, but \"auto\" has better support\n            signDisplay = \"auto\";\n          }\n          return this.num(lildur.get(mapped) * inversionFactor, token.length, signDisplay);\n        } else {\n          return token;\n        }\n      },\n      tokens = Formatter.parseFormat(fmt),\n      realTokens = tokens.reduce(\n        (found, { literal, val }) => (literal ? found : found.concat(val)),\n        []\n      ),\n      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t)),\n      durationInfo = {\n        isNegativeDuration: collapsed < 0,\n        // this relies on \"collapsed\" being based on \"shiftTo\", which builds up the object\n        // in order\n        largestUnit: Object.keys(collapsed.values)[0],\n      };\n    return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ0E7QUFDSDs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxtREFBa0I7QUFDdkIsTUFBTSxpREFBZ0I7QUFDdEIsT0FBTyxrREFBaUI7QUFDeEIsUUFBUSxrREFBaUI7QUFDekIsS0FBSyxvREFBbUI7QUFDeEIsTUFBTSwwREFBeUI7QUFDL0IsT0FBTywrREFBOEI7QUFDckMsUUFBUSw4REFBNkI7QUFDckMsS0FBSyx1REFBc0I7QUFDM0IsTUFBTSw2REFBNEI7QUFDbEMsT0FBTyxrRUFBaUM7QUFDeEMsUUFBUSxpRUFBZ0M7QUFDeEMsS0FBSyx1REFBc0I7QUFDM0IsTUFBTSxxREFBb0I7QUFDMUIsT0FBTyxzREFBcUI7QUFDNUIsUUFBUSxzREFBcUI7QUFDN0IsS0FBSyxvRUFBbUM7QUFDeEMsTUFBTSxrRUFBaUM7QUFDdkMsT0FBTyxtRUFBa0M7QUFDekMsUUFBUSxtRUFBa0M7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2YsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixzREFBc0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtRUFBbUU7QUFDdkY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXR0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBhZFN0YXJ0IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlUb2tlbnMoc3BsaXRzLCB0b2tlblRvU3RyaW5nKSB7XG4gIGxldCBzID0gXCJcIjtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBzcGxpdHMpIHtcbiAgICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgICAgcyArPSB0b2tlbi52YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgKz0gdG9rZW5Ub1N0cmluZyh0b2tlbi52YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cblxuY29uc3QgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyA9IHtcbiAgRDogRm9ybWF0cy5EQVRFX1NIT1JULFxuICBERDogRm9ybWF0cy5EQVRFX01FRCxcbiAgREREOiBGb3JtYXRzLkRBVEVfRlVMTCxcbiAgRERERDogRm9ybWF0cy5EQVRFX0hVR0UsXG4gIHQ6IEZvcm1hdHMuVElNRV9TSU1QTEUsXG4gIHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTLFxuICB0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCxcbiAgdHR0dDogRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQsXG4gIFQ6IEZvcm1hdHMuVElNRV8yNF9TSU1QTEUsXG4gIFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTLFxuICBUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCxcbiAgVFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQsXG4gIGY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlQsXG4gIGZmOiBGb3JtYXRzLkRBVEVUSU1FX01FRCxcbiAgZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEwsXG4gIGZmZmY6IEZvcm1hdHMuREFURVRJTUVfSFVHRSxcbiAgRjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMsXG4gIEZGOiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMsXG4gIEZGRjogRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyxcbiAgRkZGRjogRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyxcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtYXR0ZXIge1xuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYXR0ZXIobG9jYWxlLCBvcHRzKTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUZvcm1hdChmbXQpIHtcbiAgICAvLyB3aGl0ZS1zcGFjZSBpcyBhbHdheXMgY29uc2lkZXJlZCBhIGxpdGVyYWwgaW4gdXNlci1wcm92aWRlZCBmb3JtYXRzXG4gICAgLy8gdGhlIFwiIFwiIHRva2VuIGhhcyBhIHNwZWNpYWwgbWVhbmluZyAoc2VlIHVuaXRGb3JUb2tlbilcblxuICAgIGxldCBjdXJyZW50ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRGdWxsID0gXCJcIixcbiAgICAgIGJyYWNrZXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm10Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gZm10LmNoYXJBdChpKTtcbiAgICAgIGlmIChjID09PSBcIidcIikge1xuICAgICAgICAvLyB0dXJuICcnIGludG8gYSBsaXRlcmFsIHNpZ25hbCBxdW90ZSBpbnN0ZWFkIG9mIGp1c3Qgc2tpcHBpbmcgdGhlIGVtcHR5IGxpdGVyYWxcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDAgfHwgYnJhY2tldGVkKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goe1xuICAgICAgICAgICAgbGl0ZXJhbDogYnJhY2tldGVkIHx8IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLFxuICAgICAgICAgICAgdmFsOiBjdXJyZW50RnVsbCA9PT0gXCJcIiA/IFwiJ1wiIDogY3VycmVudEZ1bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRGdWxsID0gXCJcIjtcbiAgICAgICAgYnJhY2tldGVkID0gIWJyYWNrZXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldGVkKSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnVsbCA9IGM7XG4gICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG5cbiAgc3RhdGljIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pIHtcbiAgICByZXR1cm4gbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdE9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBmb3JtYXRPcHRzO1xuICAgIHRoaXMubG9jID0gbG9jYWxlO1xuICAgIHRoaXMuc3lzdGVtTG9jID0gbnVsbDtcbiAgfVxuXG4gIGZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtTG9jID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN5c3RlbUxvYyA9IHRoaXMubG9jLnJlZGVmYXVsdFRvU3lzdGVtKCk7XG4gICAgfVxuICAgIGNvbnN0IGRmID0gdGhpcy5zeXN0ZW1Mb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWUoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLmZvcm1hdFRvUGFydHMoKTtcbiAgfVxuXG4gIGZvcm1hdEludGVydmFsKGludGVydmFsLCBvcHRzKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGludGVydmFsLnN0YXJ0LCBvcHRzKTtcbiAgICByZXR1cm4gZGYuZHRmLmZvcm1hdFJhbmdlKGludGVydmFsLnN0YXJ0LnRvSlNEYXRlKCksIGludGVydmFsLmVuZC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIHJlc29sdmVkT3B0aW9ucyhkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxuXG4gIG51bShuLCBwID0gMCwgc2lnbkRpc3BsYXkgPSB1bmRlZmluZWQpIHtcbiAgICAvLyB3ZSBnZXQgc29tZSBwZXJmIG91dCBvZiBkb2luZyB0aGlzIGhlcmUsIGFubm95aW5nbHlcbiAgICBpZiAodGhpcy5vcHRzLmZvcmNlU2ltcGxlKSB7XG4gICAgICByZXR1cm4gcGFkU3RhcnQobiwgcCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG5cbiAgICBpZiAocCA+IDApIHtcbiAgICAgIG9wdHMucGFkVG8gPSBwO1xuICAgIH1cbiAgICBpZiAoc2lnbkRpc3BsYXkpIHtcbiAgICAgIG9wdHMuc2lnbkRpc3BsYXkgPSBzaWduRGlzcGxheTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2MubnVtYmVyRm9ybWF0dGVyKG9wdHMpLmZvcm1hdChuKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm10KSB7XG4gICAgY29uc3Qga25vd25FbmdsaXNoID0gdGhpcy5sb2MubGlzdGluZ01vZGUoKSA9PT0gXCJlblwiLFxuICAgICAgdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAmJiB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAhPT0gXCJncmVnb3J5XCIsXG4gICAgICBzdHJpbmcgPSAob3B0cywgZXh0cmFjdCkgPT4gdGhpcy5sb2MuZXh0cmFjdChkdCwgb3B0cywgZXh0cmFjdCksXG4gICAgICBmb3JtYXRPZmZzZXQgPSAob3B0cykgPT4ge1xuICAgICAgICBpZiAoZHQuaXNPZmZzZXRGaXhlZCAmJiBkdC5vZmZzZXQgPT09IDAgJiYgb3B0cy5hbGxvd1opIHtcbiAgICAgICAgICByZXR1cm4gXCJaXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZHQuaXNWYWxpZCA/IGR0LnpvbmUuZm9ybWF0T2Zmc2V0KGR0LnRzLCBvcHRzLmZvcm1hdCkgOiBcIlwiO1xuICAgICAgfSxcbiAgICAgIG1lcmlkaWVtID0gKCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpXG4gICAgICAgICAgOiBzdHJpbmcoeyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH0sIFwiZGF5cGVyaW9kXCIpLFxuICAgICAgbW9udGggPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7IG1vbnRoOiBsZW5ndGggfSA6IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpLFxuICAgICAgd2Vla2RheSA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZSA/IHsgd2Vla2RheTogbGVuZ3RoIH0gOiB7IHdlZWtkYXk6IGxlbmd0aCwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sXG4gICAgICAgICAgICAgIFwid2Vla2RheVwiXG4gICAgICAgICAgICApLFxuICAgICAgbWF5YmVNYWNybyA9ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pO1xuICAgICAgICBpZiAoZm9ybWF0T3B0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBmb3JtYXRPcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcmEgPSAobGVuZ3RoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2ggPyBFbmdsaXNoLmVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHsgZXJhOiBsZW5ndGggfSwgXCJlcmFcIiksXG4gICAgICB0b2tlblRvU3RyaW5nID0gKHRva2VuKSA9PiB7XG4gICAgICAgIC8vIFdoZXJlIHBvc3NpYmxlOiBodHRwczovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lL2RhdGUtdGltZS1zeW1ib2xzXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAvLyBtc1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCwgMyk7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQsIDIpO1xuICAgICAgICAgIC8vIGZyYWN0aW9uYWwgc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMCksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTAwKSk7XG4gICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlKTtcbiAgICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUsIDIpO1xuICAgICAgICAgIC8vIGhvdXJzXG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMik7XG4gICAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91cik7XG4gICAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciwgMik7XG4gICAgICAgICAgLy8gb2Zmc2V0XG4gICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzZcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwibmFycm93XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2OjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInNob3J0XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInRlY2hpZVwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRVNUXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJzaG9ydFwiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRWFzdGVybiBTdGFuZGFyZCBUaW1lXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJsb25nXCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIC8vIHpvbmVcbiAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZU5hbWU7XG4gICAgICAgICAgLy8gbWVyaWRpZW1zXG4gICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgIHJldHVybiBtZXJpZGllbSgpO1xuICAgICAgICAgIC8vIGRhdGVzXG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCJudW1lcmljXCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXkpO1xuICAgICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIjItZGlnaXRcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSwgMik7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDEsIGRvZXNuJ3Qgc2VlbSB0byB3b3JrXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyB5ZWFyc1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDIwMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKSA6IHRoaXMubnVtKGR0LnllYXIpO1xuICAgICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCIyLWRpZ2l0XCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDYpO1xuICAgICAgICAgIC8vIGVyYXNcbiAgICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBRFxuICAgICAgICAgICAgcmV0dXJuIGVyYShcInNob3J0XCIpO1xuICAgICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbm5vIERvbWluaVxuICAgICAgICAgICAgcmV0dXJuIGVyYShcImxvbmdcIik7XG4gICAgICAgICAgY2FzZSBcIkdHR0dHXCI6XG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibmFycm93XCIpO1xuICAgICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubG9jYWxXZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwibm5cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtOdW1iZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJpaVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla1llYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJpaWlpXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubG9jYWxXZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsKTtcbiAgICAgICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCwgMyk7XG4gICAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnF1YXJ0ZXIpO1xuICAgICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnF1YXJ0ZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC50cyAvIDEwMDApKTtcbiAgICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnRzKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG1heWJlTWFjcm8odG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgdG9rZW5Ub1N0cmluZyk7XG4gIH1cblxuICBmb3JtYXREdXJhdGlvbkZyb21TdHJpbmcoZHVyLCBmbXQpIHtcbiAgICBjb25zdCBpbnZlcnRMYXJnZXN0ID0gdGhpcy5vcHRzLnNpZ25Nb2RlID09PSBcIm5lZ2F0aXZlTGFyZ2VzdE9ubHlcIiA/IC0xIDogMTtcbiAgICBjb25zdCB0b2tlblRvRmllbGQgPSAodG9rZW4pID0+IHtcbiAgICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZHNcIjtcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vjb25kc1wiO1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaW51dGVzXCI7XG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiBcImhvdXJzXCI7XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImRheXNcIjtcbiAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwid2Vla3NcIjtcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibW9udGhzXCI7XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInllYXJzXCI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5Ub1N0cmluZyA9IChsaWxkdXIsIGluZm8pID0+ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBtYXBwZWQgPSB0b2tlblRvRmllbGQodG9rZW4pO1xuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgY29uc3QgaW52ZXJzaW9uRmFjdG9yID1cbiAgICAgICAgICAgIGluZm8uaXNOZWdhdGl2ZUR1cmF0aW9uICYmIG1hcHBlZCAhPT0gaW5mby5sYXJnZXN0VW5pdCA/IGludmVydExhcmdlc3QgOiAxO1xuICAgICAgICAgIGxldCBzaWduRGlzcGxheTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRzLnNpZ25Nb2RlID09PSBcIm5lZ2F0aXZlTGFyZ2VzdE9ubHlcIiAmJiBtYXBwZWQgIT09IGluZm8ubGFyZ2VzdFVuaXQpIHtcbiAgICAgICAgICAgIHNpZ25EaXNwbGF5ID0gXCJuZXZlclwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLnNpZ25Nb2RlID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBzaWduRGlzcGxheSA9IFwiYWx3YXlzXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFwiYXV0b1wiIGFuZCBcIm5lZ2F0aXZlXCIgYXJlIHRoZSBzYW1lLCBidXQgXCJhdXRvXCIgaGFzIGJldHRlciBzdXBwb3J0XG4gICAgICAgICAgICBzaWduRGlzcGxheSA9IFwiYXV0b1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5udW0obGlsZHVyLmdldChtYXBwZWQpICogaW52ZXJzaW9uRmFjdG9yLCB0b2tlbi5sZW5ndGgsIHNpZ25EaXNwbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlbnMgPSBGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSxcbiAgICAgIHJlYWxUb2tlbnMgPSB0b2tlbnMucmVkdWNlKFxuICAgICAgICAoZm91bmQsIHsgbGl0ZXJhbCwgdmFsIH0pID0+IChsaXRlcmFsID8gZm91bmQgOiBmb3VuZC5jb25jYXQodmFsKSksXG4gICAgICAgIFtdXG4gICAgICApLFxuICAgICAgY29sbGFwc2VkID0gZHVyLnNoaWZ0VG8oLi4ucmVhbFRva2Vucy5tYXAodG9rZW5Ub0ZpZWxkKS5maWx0ZXIoKHQpID0+IHQpKSxcbiAgICAgIGR1cmF0aW9uSW5mbyA9IHtcbiAgICAgICAgaXNOZWdhdGl2ZUR1cmF0aW9uOiBjb2xsYXBzZWQgPCAwLFxuICAgICAgICAvLyB0aGlzIHJlbGllcyBvbiBcImNvbGxhcHNlZFwiIGJlaW5nIGJhc2VkIG9uIFwic2hpZnRUb1wiLCB3aGljaCBidWlsZHMgdXAgdGhlIG9iamVjdFxuICAgICAgICAvLyBpbiBvcmRlclxuICAgICAgICBsYXJnZXN0VW5pdDogT2JqZWN0LmtleXMoY29sbGFwc2VkLnZhbHVlcylbMF0sXG4gICAgICB9O1xuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnModG9rZW5zLCB0b2tlblRvU3RyaW5nKGNvbGxhcHNlZCwgZHVyYXRpb25JbmZvKSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formatter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/invalid.js":
/*!*****************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/invalid.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Invalid)\n/* harmony export */ });\nclass Invalid {\n  constructor(reason, explanation) {\n    this.reason = reason;\n    this.explanation = explanation;\n  }\n\n  toMessage() {\n    if (this.explanation) {\n      return `${this.reason}: ${this.explanation}`;\n    } else {\n      return this.reason;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixZQUFZLElBQUksaUJBQWlCO0FBQ2pELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZCB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gIH1cblxuICB0b01lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGFuYXRpb24pIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnJlYXNvbn06ICR7dGhpcy5leHBsYW5hdGlvbn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/invalid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/locale.js":
/*!****************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/locale.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Locale)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nconst intlDTCache = new Map();\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache.get(key);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache.set(key, dtf);\n  }\n  return dtf;\n}\n\nconst intlNumCache = new Map();\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache.set(key, inf);\n  }\n  return inf;\n}\n\nconst intlRelCache = new Map();\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache.set(key, inf);\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nconst intlResolvedOptionsCache = new Map();\nfunction getCachedIntResolvedOptions(locString) {\n  let opts = intlResolvedOptionsCache.get(locString);\n  if (opts === undefined) {\n    opts = new Intl.DateTimeFormat(locString).resolvedOptions();\n    intlResolvedOptionsCache.set(locString, opts);\n  }\n  return opts;\n}\n\nconst weekInfoCache = new Map();\nfunction getCachedWeekInfo(locString) {\n  let data = weekInfoCache.get(locString);\n  if (!data) {\n    const locale = new Intl.Locale(locString);\n    // browsers currently implement this as a property, but spec says it should be a getter function\n    data = \"getWeekInfo\" in locale ? locale.getWeekInfo() : locale.weekInfo;\n    // minimalDays was removed from WeekInfo: https://github.com/tc39/proposal-intl-locale-info/issues/86\n    if (!(\"minimalDays\" in data)) {\n      data = { ...fallbackWeekSettings, ...data };\n    }\n    weekInfoCache.set(locString, data);\n  }\n  return data;\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const { numberingSystem, calendar } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2009, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, englishFn, intlFn) {\n  const mode = loc.listingMode();\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      getCachedIntResolvedOptions(loc.locale).numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roundTo)(i, 3);\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n\n    let z = undefined;\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n      this.originalZone = dt.zone;\n    }\n\n    const intlOpts = { ...this.opts };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts()\n        .map(({ value }) => value)\n        .join(\"\");\n    }\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n    if (this.originalZone) {\n      return parts.map((part) => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName,\n          });\n          return {\n            ...part,\n            value: offsetName,\n          };\n        } else {\n          return part;\n        }\n      });\n    }\n    return parts;\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasRelative)()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return _english_js__WEBPACK_IMPORTED_MODULE_1__.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\nconst fallbackWeekSettings = {\n  firstDay: 1,\n  minimalDays: 4,\n  weekend: [6, 7],\n};\n\n/**\n * @private\n */\nclass Locale {\n  static fromOpts(opts) {\n    return Locale.create(\n      opts.locale,\n      opts.numberingSystem,\n      opts.outputCalendar,\n      opts.weekSettings,\n      opts.defaultToEN\n    );\n  }\n\n  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {\n    const specifiedLocale = locale || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLocale;\n    // the system locale is useful for human-readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultOutputCalendar;\n    const weekSettingsR = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(weekSettings) || _settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultWeekSettings;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache.clear();\n    intlNumCache.clear();\n    intlRelCache.clear();\n    intlResolvedOptionsCache.clear();\n    weekInfoCache.clear();\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);\n  }\n\n  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.weekSettings = weekSettings;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.validateWeekSettings)(alts.weekSettings) || this.weekSettings,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.months, () => {\n      // Workaround for \"ja\" locale: formatToParts does not label all parts of the month\n      // as \"month\" and for this locale there is no difference between \"format\" and \"non-format\".\n      // As such, just use format() instead of formatToParts() and take the whole string\n      const monthSpecialCase = this.intl === \"ja\" || this.intl.startsWith(\"ja-\");\n      format &= !monthSpecialCase;\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        const mapper = !monthSpecialCase\n          ? (dt) => this.extract(dt, intl, \"month\")\n          : (dt) => this.dtFormatter(dt, intl).format();\n        this.monthsCache[formatStr][length] = mapMonths(mapper);\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems() {\n    return listStuff(\n      this,\n      undefined,\n      () => _english_js__WEBPACK_IMPORTED_MODULE_1__.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 9), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length) {\n    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(-40, 1, 1), _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      getCachedIntResolvedOptions(this.intl).locale.startsWith(\"en-us\")\n    );\n  }\n\n  getWeekSettings() {\n    if (this.weekSettings) {\n      return this.weekSettings;\n    } else if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasLocaleWeekInfo)()) {\n      return fallbackWeekSettings;\n    } else {\n      return getCachedWeekInfo(this.locale);\n    }\n  }\n\n  getStartOfWeek() {\n    return this.getWeekSettings().firstDay;\n  }\n\n  getMinDaysInFirstWeek() {\n    return this.getWeekSettings().minimalDays;\n  }\n\n  getWeekendDays() {\n    return this.getWeekSettings().weekend;\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n\n  toString() {\n    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2xvY2FsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0c7QUFDNUQ7QUFDRjtBQUNBO0FBQ007O0FBRTVDOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDLFVBQVUsd0JBQXdCLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7O0FBRUE7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVB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b3ZpZGVycy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvbG9jYWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc0xvY2FsZVdlZWtJbmZvLCBoYXNSZWxhdGl2ZSwgcGFkU3RhcnQsIHJvdW5kVG8sIHZhbGlkYXRlV2Vla1NldHRpbmdzIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8vIHRvZG8gLSByZW1hcCBjYWNoaW5nXG5cbmxldCBpbnRsTEZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkTEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bExGQ2FjaGVba2V5XTtcbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bExGQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5jb25zdCBpbnRsRFRDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlZERURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsRFRDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGR0ZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZS5zZXQoa2V5LCBkdGYpO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmNvbnN0IGludGxOdW1DYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsTnVtQ2FjaGUuZ2V0KGtleSk7XG4gIGlmIChpbmYgPT09IHVuZGVmaW5lZCkge1xuICAgIGluZiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxOdW1DYWNoZS5zZXQoa2V5LCBpbmYpO1xuICB9XG4gIHJldHVybiBpbmY7XG59XG5cbmNvbnN0IGludGxSZWxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlZFJURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGJhc2UsIC4uLmNhY2hlS2V5T3B0cyB9ID0gb3B0czsgLy8gZXhjbHVkZSBgYmFzZWAgZnJvbSB0aGUgb3B0aW9uc1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBjYWNoZUtleU9wdHNdKTtcbiAgbGV0IGluZiA9IGludGxSZWxDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGluZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5mID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bFJlbENhY2hlLnNldChrZXksIGluZik7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IHN5c0xvY2FsZUNhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIHN5c3RlbUxvY2FsZSgpIHtcbiAgaWYgKHN5c0xvY2FsZUNhY2hlKSB7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9IGVsc2Uge1xuICAgIHN5c0xvY2FsZUNhY2hlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9XG59XG5cbmNvbnN0IGludGxSZXNvbHZlZE9wdGlvbnNDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlZEludFJlc29sdmVkT3B0aW9ucyhsb2NTdHJpbmcpIHtcbiAgbGV0IG9wdHMgPSBpbnRsUmVzb2x2ZWRPcHRpb25zQ2FjaGUuZ2V0KGxvY1N0cmluZyk7XG4gIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICBpbnRsUmVzb2x2ZWRPcHRpb25zQ2FjaGUuc2V0KGxvY1N0cmluZywgb3B0cyk7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59XG5cbmNvbnN0IHdlZWtJbmZvQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRDYWNoZWRXZWVrSW5mbyhsb2NTdHJpbmcpIHtcbiAgbGV0IGRhdGEgPSB3ZWVrSW5mb0NhY2hlLmdldChsb2NTdHJpbmcpO1xuICBpZiAoIWRhdGEpIHtcbiAgICBjb25zdCBsb2NhbGUgPSBuZXcgSW50bC5Mb2NhbGUobG9jU3RyaW5nKTtcbiAgICAvLyBicm93c2VycyBjdXJyZW50bHkgaW1wbGVtZW50IHRoaXMgYXMgYSBwcm9wZXJ0eSwgYnV0IHNwZWMgc2F5cyBpdCBzaG91bGQgYmUgYSBnZXR0ZXIgZnVuY3Rpb25cbiAgICBkYXRhID0gXCJnZXRXZWVrSW5mb1wiIGluIGxvY2FsZSA/IGxvY2FsZS5nZXRXZWVrSW5mbygpIDogbG9jYWxlLndlZWtJbmZvO1xuICAgIC8vIG1pbmltYWxEYXlzIHdhcyByZW1vdmVkIGZyb20gV2Vla0luZm86IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWludGwtbG9jYWxlLWluZm8vaXNzdWVzLzg2XG4gICAgaWYgKCEoXCJtaW5pbWFsRGF5c1wiIGluIGRhdGEpKSB7XG4gICAgICBkYXRhID0geyAuLi5mYWxsYmFja1dlZWtTZXR0aW5ncywgLi4uZGF0YSB9O1xuICAgIH1cbiAgICB3ZWVrSW5mb0NhY2hlLnNldChsb2NTdHJpbmcsIGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2FsZVN0cmluZyhsb2NhbGVTdHIpIHtcbiAgLy8gSSByZWFsbHkgd2FudCB0byBhdm9pZCB3cml0aW5nIGEgQkNQIDQ3IHBhcnNlclxuICAvLyBzZWUsIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9iY3AtNDdcbiAgLy8gSW5zdGVhZCwgd2UnbGwgZG8gdGhpczpcblxuICAvLyBhKSBpZiB0aGUgc3RyaW5nIGhhcyBubyAtdSBleHRlbnNpb25zLCBqdXN0IGxlYXZlIGl0IGFsb25lXG4gIC8vIGIpIGlmIGl0IGRvZXMsIHVzZSBJbnRsIHRvIHJlc29sdmUgZXZlcnl0aGluZ1xuICAvLyBjKSBpZiBJbnRsIGZhaWxzLCB0cnkgYWdhaW4gd2l0aG91dCB0aGUgLXVcblxuICAvLyBwcml2YXRlIHN1YnRhZ3MgYW5kIHVuaWNvZGUgc3VidGFncyBoYXZlIG9yZGVyaW5nIHJlcXVpcmVtZW50cyxcbiAgLy8gYW5kIHdlJ3JlIG5vdCBwcm9wZXJseSBwYXJzaW5nIHRoaXMsIHNvIGp1c3Qgc3RyaXAgb3V0IHRoZVxuICAvLyBwcml2YXRlIG9uZXMgaWYgdGhleSBleGlzdC5cbiAgY29uc3QgeEluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCIteC1cIik7XG4gIGlmICh4SW5kZXggIT09IC0xKSB7XG4gICAgbG9jYWxlU3RyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB4SW5kZXgpO1xuICB9XG5cbiAgY29uc3QgdUluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCItdS1cIik7XG4gIGlmICh1SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIFtsb2NhbGVTdHJdO1xuICB9IGVsc2Uge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGxldCBzZWxlY3RlZFN0cjtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihsb2NhbGVTdHIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBsb2NhbGVTdHI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3Qgc21hbGxlciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgdUluZGV4KTtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYoc21hbGxlcikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IHNtYWxsZXI7XG4gICAgfVxuXG4gICAgY29uc3QgeyBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBbc2VsZWN0ZWRTdHIsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGxDb25maWdTdHJpbmcobG9jYWxlU3RyLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSB7XG4gIGlmIChvdXRwdXRDYWxlbmRhciB8fCBudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBpZiAoIWxvY2FsZVN0ci5pbmNsdWRlcyhcIi11LVwiKSkge1xuICAgICAgbG9jYWxlU3RyICs9IFwiLXVcIjtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLWNhLSR7b3V0cHV0Q2FsZW5kYXJ9YDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1udS0ke251bWJlcmluZ1N5c3RlbX1gO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwTW9udGhzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTI7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMDksIGksIDEpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbWFwV2Vla2RheXMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSA3OyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMgKyBpKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIGxpc3RTdHVmZihsb2MsIGxlbmd0aCwgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZSgpO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBnZXRDYWNoZWRJbnRSZXNvbHZlZE9wdGlvbnMobG9jLmxvY2FsZSkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5vcmlnaW5hbFpvbmUgPSB1bmRlZmluZWQ7XG5cbiAgICBsZXQgeiA9IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5vcHRzLnRpbWVab25lKSB7XG4gICAgICAvLyBEb24ndCBhcHBseSBhbnkgd29ya2Fyb3VuZHMgaWYgYSB0aW1lWm9uZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIG9wdHNcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAvLyBVVEMtOCBvciBFdGMvVVRDLTggYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YSwgb25seSBFdGMvR01UKzggYW5kIHRoZSBsaWtlLlxuICAgICAgLy8gVGhhdCBpcyB3aHkgZml4ZWQtb2Zmc2V0IFRaIGlzIHNldCB0byB0aGF0IHVubGVzcyBpdCBpczpcbiAgICAgIC8vIDEuIFJlcHJlc2VudGluZyBvZmZzZXQgMCB3aGVuIFVUQyBpcyB1c2VkIHRvIG1haW50YWluIHByZXZpb3VzIGJlaGF2aW9yIGFuZCBkb2VzIG5vdCBiZWNvbWUgR01ULlxuICAgICAgLy8gMi4gVW5zdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXI6XG4gICAgICAvLyAgICAtIHNvbWUgZG8gbm90IHN1cHBvcnQgRXRjL1xuICAgICAgLy8gICAgLSA8IEV0Yy9HTVQtMTQsID4gRXRjL0dNVCsxMiwgYW5kIDMwLW1pbnV0ZSBvciA0NS1taW51dGUgb2Zmc2V0cyBhcmUgbm90IHBhcnQgb2YgdHpkYXRhXG4gICAgICBjb25zdCBnbXRPZmZzZXQgPSAtMSAqIChkdC5vZmZzZXQgLyA2MCk7XG4gICAgICBjb25zdCBvZmZzZXRaID0gZ210T2Zmc2V0ID49IDAgPyBgRXRjL0dNVCske2dtdE9mZnNldH1gIDogYEV0Yy9HTVQke2dtdE9mZnNldH1gO1xuICAgICAgaWYgKGR0Lm9mZnNldCAhPT0gMCAmJiBJQU5BWm9uZS5jcmVhdGUob2Zmc2V0WikudmFsaWQpIHtcbiAgICAgICAgeiA9IG9mZnNldFo7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhbGwgZml4ZWQtb2Zmc2V0IHpvbmVzIGxpa2UgRXRjLys0OjMwIGFyZSBwcmVzZW50IGluIHR6ZGF0YSBzb1xuICAgICAgICAvLyB3ZSBtYW51YWxseSBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIHRoaXMuZHQgPSBkdC5vZmZzZXQgPT09IDAgPyBkdCA6IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFpvbmUgPSBkdC56b25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwiaWFuYVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB6ID0gZHQuem9uZS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDdXN0b20gem9uZXMgY2FuIGhhdmUgYW55IG9mZnNldCAvIG9mZnNldE5hbWUgc28gd2UganVzdCBtYW51YWxseVxuICAgICAgLy8gYXBwbHkgdGhlIG9mZnNldCBhbmQgc3Vic3RpdHV0ZSB0aGUgem9uZSBhcyBuZWVkZWQuXG4gICAgICB6ID0gXCJVVENcIjtcbiAgICAgIHRoaXMuZHQgPSBkdC5zZXRab25lKFwiVVRDXCIpLnBsdXMoeyBtaW51dGVzOiBkdC5vZmZzZXQgfSk7XG4gICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGludGxPcHRzLnRpbWVab25lID0gaW50bE9wdHMudGltZVpvbmUgfHwgejtcbiAgICB0aGlzLmR0ZiA9IGdldENhY2hlZERURihpbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICBmb3JtYXQoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxab25lKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRvIHN1YnN0aXR1dGUgaW4gdGhlIGFjdHVhbCB6b25lIG5hbWUsIHdlIGhhdmUgdG8gdXNlXG4gICAgICAvLyBmb3JtYXRUb1BhcnRzIHNvIHRoYXQgdGhlIHRpbWV6b25lIGNhbiBiZSByZXBsYWNlZC5cbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFRvUGFydHMoKVxuICAgICAgICAubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKVxuICAgICAgICAuam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdCh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cygpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuZHRmLmZvcm1hdFRvUGFydHModGhpcy5kdC50b0pTRGF0ZSgpKTtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0aW1lWm9uZU5hbWVcIikge1xuICAgICAgICAgIGNvbnN0IG9mZnNldE5hbWUgPSB0aGlzLm9yaWdpbmFsWm9uZS5vZmZzZXROYW1lKHRoaXMuZHQudHMsIHtcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5kdC5sb2NhbGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMub3B0cy50aW1lWm9uZU5hbWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBhcnQsXG4gICAgICAgICAgICB2YWx1ZTogb2Zmc2V0TmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBvbHlSZWxGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IHN0eWxlOiBcImxvbmdcIiwgLi4ub3B0cyB9O1xuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgdGhpcy5vcHRzLm51bWVyaWMsIHRoaXMub3B0cy5zdHlsZSAhPT0gXCJsb25nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBmYWxsYmFja1dlZWtTZXR0aW5ncyA9IHtcbiAgZmlyc3REYXk6IDEsXG4gIG1pbmltYWxEYXlzOiA0LFxuICB3ZWVrZW5kOiBbNiwgN10sXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2FsZSB7XG4gIHN0YXRpYyBmcm9tT3B0cyhvcHRzKSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICBvcHRzLmxvY2FsZSxcbiAgICAgIG9wdHMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgb3B0cy5vdXRwdXRDYWxlbmRhcixcbiAgICAgIG9wdHMud2Vla1NldHRpbmdzLFxuICAgICAgb3B0cy5kZWZhdWx0VG9FTlxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzLCBkZWZhdWx0VG9FTiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3BlY2lmaWVkTG9jYWxlID0gbG9jYWxlIHx8IFNldHRpbmdzLmRlZmF1bHRMb2NhbGU7XG4gICAgLy8gdGhlIHN5c3RlbSBsb2NhbGUgaXMgdXNlZnVsIGZvciBodW1hbi1yZWFkYWJsZSBzdHJpbmdzIGJ1dCBhbm5veWluZyBmb3IgcGFyc2luZy9mb3JtYXR0aW5nIGtub3duIGZvcm1hdHNcbiAgICBjb25zdCBsb2NhbGVSID0gc3BlY2lmaWVkTG9jYWxlIHx8IChkZWZhdWx0VG9FTiA/IFwiZW4tVVNcIiA6IHN5c3RlbUxvY2FsZSgpKTtcbiAgICBjb25zdCBudW1iZXJpbmdTeXN0ZW1SID0gbnVtYmVyaW5nU3lzdGVtIHx8IFNldHRpbmdzLmRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gICAgY29uc3Qgb3V0cHV0Q2FsZW5kYXJSID0gb3V0cHV0Q2FsZW5kYXIgfHwgU2V0dGluZ3MuZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICAgIGNvbnN0IHdlZWtTZXR0aW5nc1IgPSB2YWxpZGF0ZVdlZWtTZXR0aW5ncyh3ZWVrU2V0dGluZ3MpIHx8IFNldHRpbmdzLmRlZmF1bHRXZWVrU2V0dGluZ3M7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlUiwgbnVtYmVyaW5nU3lzdGVtUiwgb3V0cHV0Q2FsZW5kYXJSLCB3ZWVrU2V0dGluZ3NSLCBzcGVjaWZpZWRMb2NhbGUpO1xuICB9XG5cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuICAgIGludGxEVENhY2hlLmNsZWFyKCk7XG4gICAgaW50bE51bUNhY2hlLmNsZWFyKCk7XG4gICAgaW50bFJlbENhY2hlLmNsZWFyKCk7XG4gICAgaW50bFJlc29sdmVkT3B0aW9uc0NhY2hlLmNsZWFyKCk7XG4gICAgd2Vla0luZm9DYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgc3RhdGljIGZyb21PYmplY3QoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIHdlZWtTZXR0aW5ncyB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIHdlZWtTZXR0aW5ncyk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHdlZWtTZXR0aW5ncywgc3BlY2lmaWVkTG9jYWxlKSB7XG4gICAgY29uc3QgW3BhcnNlZExvY2FsZSwgcGFyc2VkTnVtYmVyaW5nU3lzdGVtLCBwYXJzZWRPdXRwdXRDYWxlbmRhcl0gPSBwYXJzZUxvY2FsZVN0cmluZyhsb2NhbGUpO1xuXG4gICAgdGhpcy5sb2NhbGUgPSBwYXJzZWRMb2NhbGU7XG4gICAgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmcgfHwgcGFyc2VkTnVtYmVyaW5nU3lzdGVtIHx8IG51bGw7XG4gICAgdGhpcy5vdXRwdXRDYWxlbmRhciA9IG91dHB1dENhbGVuZGFyIHx8IHBhcnNlZE91dHB1dENhbGVuZGFyIHx8IG51bGw7XG4gICAgdGhpcy53ZWVrU2V0dGluZ3MgPSB3ZWVrU2V0dGluZ3M7XG4gICAgdGhpcy5pbnRsID0gaW50bENvbmZpZ1N0cmluZyh0aGlzLmxvY2FsZSwgdGhpcy5udW1iZXJpbmdTeXN0ZW0sIHRoaXMub3V0cHV0Q2FsZW5kYXIpO1xuXG4gICAgdGhpcy53ZWVrZGF5c0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubW9udGhzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tZXJpZGllbUNhY2hlID0gbnVsbDtcbiAgICB0aGlzLmVyYUNhY2hlID0ge307XG5cbiAgICB0aGlzLnNwZWNpZmllZExvY2FsZSA9IHNwZWNpZmllZExvY2FsZTtcbiAgICB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID0gbnVsbDtcbiAgfVxuXG4gIGdldCBmYXN0TnVtYmVycygpIHtcbiAgICBpZiAodGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID0gc3VwcG9ydHNGYXN0TnVtYmVycyh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mYXN0TnVtYmVyc0NhY2hlZDtcbiAgfVxuXG4gIGxpc3RpbmdNb2RlKCkge1xuICAgIGNvbnN0IGlzQWN0dWFsbHlFbiA9IHRoaXMuaXNFbmdsaXNoKCk7XG4gICAgY29uc3QgaGFzTm9XZWlyZG5lc3MgPVxuICAgICAgKHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBudWxsIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIikgJiZcbiAgICAgICh0aGlzLm91dHB1dENhbGVuZGFyID09PSBudWxsIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IFwiZ3JlZ29yeVwiKTtcbiAgICByZXR1cm4gaXNBY3R1YWxseUVuICYmIGhhc05vV2VpcmRuZXNzID8gXCJlblwiIDogXCJpbnRsXCI7XG4gIH1cblxuICBjbG9uZShhbHRzKSB7XG4gICAgaWYgKCFhbHRzIHx8IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFsdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKFxuICAgICAgICBhbHRzLmxvY2FsZSB8fCB0aGlzLnNwZWNpZmllZExvY2FsZSxcbiAgICAgICAgYWx0cy5udW1iZXJpbmdTeXN0ZW0gfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGFsdHMub3V0cHV0Q2FsZW5kYXIgfHwgdGhpcy5vdXRwdXRDYWxlbmRhcixcbiAgICAgICAgdmFsaWRhdGVXZWVrU2V0dGluZ3MoYWx0cy53ZWVrU2V0dGluZ3MpIHx8IHRoaXMud2Vla1NldHRpbmdzLFxuICAgICAgICBhbHRzLmRlZmF1bHRUb0VOIHx8IGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlZGVmYXVsdFRvRU4oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJlZGVmYXVsdFRvU3lzdGVtKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHsgLi4uYWx0cywgZGVmYXVsdFRvRU46IGZhbHNlIH0pO1xuICB9XG5cbiAgbW9udGhzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC5tb250aHMsICgpID0+IHtcbiAgICAgIC8vIFdvcmthcm91bmQgZm9yIFwiamFcIiBsb2NhbGU6IGZvcm1hdFRvUGFydHMgZG9lcyBub3QgbGFiZWwgYWxsIHBhcnRzIG9mIHRoZSBtb250aFxuICAgICAgLy8gYXMgXCJtb250aFwiIGFuZCBmb3IgdGhpcyBsb2NhbGUgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIFwiZm9ybWF0XCIgYW5kIFwibm9uLWZvcm1hdFwiLlxuICAgICAgLy8gQXMgc3VjaCwganVzdCB1c2UgZm9ybWF0KCkgaW5zdGVhZCBvZiBmb3JtYXRUb1BhcnRzKCkgYW5kIHRha2UgdGhlIHdob2xlIHN0cmluZ1xuICAgICAgY29uc3QgbW9udGhTcGVjaWFsQ2FzZSA9IHRoaXMuaW50bCA9PT0gXCJqYVwiIHx8IHRoaXMuaW50bC5zdGFydHNXaXRoKFwiamEtXCIpO1xuICAgICAgZm9ybWF0ICY9ICFtb250aFNwZWNpYWxDYXNlO1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdCA/IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9IDogeyBtb250aDogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgY29uc3QgbWFwcGVyID0gIW1vbnRoU3BlY2lhbENhc2VcbiAgICAgICAgICA/IChkdCkgPT4gdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIm1vbnRoXCIpXG4gICAgICAgICAgOiAoZHQpID0+IHRoaXMuZHRGb3JtYXR0ZXIoZHQsIGludGwpLmZvcm1hdCgpO1xuICAgICAgICB0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcE1vbnRocyhtYXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgd2Vla2RheXMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLndlZWtkYXlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0XG4gICAgICAgICAgPyB7IHdlZWtkYXk6IGxlbmd0aCwgeWVhcjogXCJudW1lcmljXCIsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9XG4gICAgICAgICAgOiB7IHdlZWtkYXk6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcFdlZWtkYXlzKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwid2Vla2RheVwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBtZXJpZGllbXMoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmlkaWVtQ2FjaGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGVyYXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2guZXJhcywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IHsgZXJhOiBsZW5ndGggfTtcblxuICAgICAgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYy4gRGlmZmVyZW50IGNhbGVuZGFycyBhcmUgZ29pbmcgdG8gZGVmaW5lIGVyYXMgdG90YWxseSBkaWZmZXJlbnRseS4gV2hhdCBJIG5lZWQgaXMgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGVzXG4gICAgICAvLyB0byBkZWZpbml0ZWx5IGVudW1lcmF0ZSB0aGVtLlxuICAgICAgaWYgKCF0aGlzLmVyYUNhY2hlW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5lcmFDYWNoZVtsZW5ndGhdID0gW0RhdGVUaW1lLnV0YygtNDAsIDEsIDEpLCBEYXRlVGltZS51dGMoMjAxNywgMSwgMSldLm1hcCgoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImVyYVwiKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lcmFDYWNoZVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgZXh0cmFjdChkdCwgaW50bE9wdHMsIGZpZWxkKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyksXG4gICAgICByZXN1bHRzID0gZGYuZm9ybWF0VG9QYXJ0cygpLFxuICAgICAgbWF0Y2hpbmcgPSByZXN1bHRzLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBmaWVsZCk7XG4gICAgcmV0dXJuIG1hdGNoaW5nID8gbWF0Y2hpbmcudmFsdWUgOiBudWxsO1xuICB9XG5cbiAgbnVtYmVyRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIC8vIHRoaXMgZm9yY2VzaW1wbGUgb3B0aW9uIGlzIG5ldmVyIHVzZWQgKHRoZSBvbmx5IGNhbGxlciBzaG9ydC1jaXJjdWl0cyBvbiBpdCwgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGxlYXZlKVxuICAgIC8vIChpbiBjb250cmFzdCwgdGhlIHJlc3Qgb2YgdGhlIGNvbmRpdGlvbiBpcyB1c2VkIGhlYXZpbHkpXG4gICAgcmV0dXJuIG5ldyBQb2x5TnVtYmVyRm9ybWF0dGVyKHRoaXMuaW50bCwgb3B0cy5mb3JjZVNpbXBsZSB8fCB0aGlzLmZhc3ROdW1iZXJzLCBvcHRzKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5RGF0ZUZvcm1hdHRlcihkdCwgdGhpcy5pbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICByZWxGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5UmVsRm9ybWF0dGVyKHRoaXMuaW50bCwgdGhpcy5pc0VuZ2xpc2goKSwgb3B0cyk7XG4gIH1cblxuICBsaXN0Rm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBnZXRDYWNoZWRMRih0aGlzLmludGwsIG9wdHMpO1xuICB9XG5cbiAgaXNFbmdsaXNoKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gXCJlblwiIHx8XG4gICAgICB0aGlzLmxvY2FsZS50b0xvd2VyQ2FzZSgpID09PSBcImVuLXVzXCIgfHxcbiAgICAgIGdldENhY2hlZEludFJlc29sdmVkT3B0aW9ucyh0aGlzLmludGwpLmxvY2FsZS5zdGFydHNXaXRoKFwiZW4tdXNcIilcbiAgICApO1xuICB9XG5cbiAgZ2V0V2Vla1NldHRpbmdzKCkge1xuICAgIGlmICh0aGlzLndlZWtTZXR0aW5ncykge1xuICAgICAgcmV0dXJuIHRoaXMud2Vla1NldHRpbmdzO1xuICAgIH0gZWxzZSBpZiAoIWhhc0xvY2FsZVdlZWtJbmZvKCkpIHtcbiAgICAgIHJldHVybiBmYWxsYmFja1dlZWtTZXR0aW5ncztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldENhY2hlZFdlZWtJbmZvKHRoaXMubG9jYWxlKTtcbiAgICB9XG4gIH1cblxuICBnZXRTdGFydE9mV2VlaygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXZWVrU2V0dGluZ3MoKS5maXJzdERheTtcbiAgfVxuXG4gIGdldE1pbkRheXNJbkZpcnN0V2VlaygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXZWVrU2V0dGluZ3MoKS5taW5pbWFsRGF5cztcbiAgfVxuXG4gIGdldFdlZWtlbmREYXlzKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtTZXR0aW5ncygpLndlZWtlbmQ7XG4gIH1cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IG90aGVyLmxvY2FsZSAmJlxuICAgICAgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG90aGVyLm51bWJlcmluZ1N5c3RlbSAmJlxuICAgICAgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gb3RoZXIub3V0cHV0Q2FsZW5kYXJcbiAgICApO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBMb2NhbGUoJHt0aGlzLmxvY2FsZX0sICR7dGhpcy5udW1iZXJpbmdTeXN0ZW19LCAke3RoaXMub3V0cHV0Q2FsZW5kYXJ9KWA7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/regexParser.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/regexParser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseHTTPDate: () => (/* binding */ parseHTTPDate),\n/* harmony export */   parseISODate: () => (/* binding */ parseISODate),\n/* harmony export */   parseISODuration: () => (/* binding */ parseISODuration),\n/* harmony export */   parseISOTimeOnly: () => (/* binding */ parseISOTimeOnly),\n/* harmony export */   parseRFC2822Date: () => (/* binding */ parseRFC2822Date),\n/* harmony export */   parseSQL: () => (/* binding */ parseSQL)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/english.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\");\n\n\n\n\n\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */\n\nconst ianaRegex = /[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;\n\nfunction combineRegexes(...regexes) {\n  const full = regexes.reduce((f, r) => f + r.source, \"\");\n  return RegExp(`^${full}$`);\n}\n\nfunction combineExtractors(...extractors) {\n  return (m) =>\n    extractors\n      .reduce(\n        ([mergedVals, mergedZone, cursor], ex) => {\n          const [val, zone, next] = ex(m, cursor);\n          return [{ ...mergedVals, ...val }, zone || mergedZone, next];\n        },\n        [{}, null, 1]\n      )\n      .slice(0, 2);\n}\n\nfunction parse(s, ...patterns) {\n  if (s == null) {\n    return [null, null];\n  }\n\n  for (const [regex, extractor] of patterns) {\n    const m = regex.exec(s);\n    if (m) {\n      return extractor(m);\n    }\n  }\n  return [null, null];\n}\n\nfunction simpleParse(...keys) {\n  return (match, cursor) => {\n    const ret = {};\n    let i;\n\n    for (i = 0; i < keys.length; i++) {\n      ret[keys[i]] = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(match[cursor + i]);\n    }\n    return [ret, null, cursor + i];\n  };\n}\n\n// ISO and SQL parsing\nconst offsetRegex = /(?:([Zz])|([+-]\\d\\d)(?::?(\\d\\d))?)/;\nconst isoExtendedZone = `(?:${offsetRegex.source}?(?:\\\\[(${ianaRegex.source})\\\\])?)?`;\nconst isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/;\nconst isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);\nconst isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);\nconst isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/;\nconst isoWeekRegex = /(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/;\nconst isoOrdinalRegex = /(\\d{4})-?(\\d{3})/;\nconst extractISOWeekData = simpleParse(\"weekYear\", \"weekNumber\", \"weekDay\");\nconst extractISOOrdinalData = simpleParse(\"year\", \"ordinal\");\nconst sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/; // dumbed-down version of the ISO one\nconst sqlTimeRegex = RegExp(\n  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`\n);\nconst sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);\n\nfunction int(match, pos, fallback) {\n  const m = match[pos];\n  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(m) ? fallback : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(m);\n}\n\nfunction extractISOYmd(match, cursor) {\n  const item = {\n    year: int(match, cursor),\n    month: int(match, cursor + 1, 1),\n    day: int(match, cursor + 2, 1),\n  };\n\n  return [item, null, cursor + 3];\n}\n\nfunction extractISOTime(match, cursor) {\n  const item = {\n    hours: int(match, cursor, 0),\n    minutes: int(match, cursor + 1, 0),\n    seconds: int(match, cursor + 2, 0),\n    milliseconds: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(match[cursor + 3]),\n  };\n\n  return [item, null, cursor + 4];\n}\n\nfunction extractISOOffset(match, cursor) {\n  const local = !match[cursor] && !match[cursor + 1],\n    fullOffset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(match[cursor + 1], match[cursor + 2]),\n    zone = local ? null : _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(fullOffset);\n  return [{}, zone, cursor + 3];\n}\n\nfunction extractIANAZone(match, cursor) {\n  const zone = match[cursor] ? _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(match[cursor]) : null;\n  return [{}, zone, cursor + 1];\n}\n\n// ISO time parsing\n\nconst isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);\n\n// ISO duration parsing\n\nconst isoDuration =\n  /^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;\n\nfunction extractISODuration(match) {\n  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =\n    match;\n\n  const hasNegativePrefix = s[0] === \"-\";\n  const negativeSeconds = secondStr && secondStr[0] === \"-\";\n\n  const maybeNegate = (num, force = false) =>\n    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;\n\n  return [\n    {\n      years: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(yearStr)),\n      months: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(monthStr)),\n      weeks: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(weekStr)),\n      days: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(dayStr)),\n      hours: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(hourStr)),\n      minutes: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(minuteStr)),\n      seconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(secondStr), secondStr === \"-0\"),\n      milliseconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(millisecondsStr), negativeSeconds),\n    },\n  ];\n}\n\n// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\nconst obsOffsets = {\n  GMT: 0,\n  EDT: -4 * 60,\n  EST: -5 * 60,\n  CDT: -5 * 60,\n  CST: -6 * 60,\n  MDT: -6 * 60,\n  MST: -7 * 60,\n  PDT: -7 * 60,\n  PST: -8 * 60,\n};\n\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n  const result = {\n    year: yearStr.length === 2 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr)) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr),\n    month: _english_js__WEBPACK_IMPORTED_MODULE_1__.monthsShort.indexOf(monthStr) + 1,\n    day: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(dayStr),\n    hour: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(hourStr),\n    minute: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(minuteStr),\n  };\n\n  if (secondStr) result.second = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(secondStr);\n  if (weekdayStr) {\n    result.weekday =\n      weekdayStr.length > 3\n        ? _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysLong.indexOf(weekdayStr) + 1\n        : _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysShort.indexOf(weekdayStr) + 1;\n  }\n\n  return result;\n}\n\n// RFC 2822/5322\nconst rfc2822 =\n  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\n\nfunction extractRFC2822(match) {\n  const [\n      ,\n      weekdayStr,\n      dayStr,\n      monthStr,\n      yearStr,\n      hourStr,\n      minuteStr,\n      secondStr,\n      obsOffset,\n      milOffset,\n      offHourStr,\n      offMinuteStr,\n    ] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  let offset;\n  if (obsOffset) {\n    offset = obsOffsets[obsOffset];\n  } else if (milOffset) {\n    offset = 0;\n  } else {\n    offset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(offHourStr, offMinuteStr);\n  }\n\n  return [result, new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](offset)];\n}\n\nfunction preprocessRFC2822(s) {\n  // Remove comments and folding whitespace and replace multiple-spaces with a single space\n  return s\n    .replace(/\\([^()]*\\)|[\\n\\t]/g, \" \")\n    .replace(/(\\s\\s+)/g, \" \")\n    .trim();\n}\n\n// http date\n\nconst rfc1123 =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  rfc850 =\n    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  ascii =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\n\nfunction extractRFC1123Or850(match) {\n  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nfunction extractASCII(match) {\n  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance];\n}\n\nconst isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nconst isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);\nconst isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);\nconst isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\n\nconst extractISOYmdTimeAndOffset = combineExtractors(\n  extractISOYmd,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOWeekTimeAndOffset = combineExtractors(\n  extractISOWeekData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOOrdinalDateAndTime = combineExtractors(\n  extractISOOrdinalData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOTimeAndOffset = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\n/*\n * @private\n */\n\nfunction parseISODate(s) {\n  return parse(\n    s,\n    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],\n    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],\n    [isoTimeCombinedRegex, extractISOTimeAndOffset]\n  );\n}\n\nfunction parseRFC2822Date(s) {\n  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);\n}\n\nfunction parseHTTPDate(s) {\n  return parse(\n    s,\n    [rfc1123, extractRFC1123Or850],\n    [rfc850, extractRFC1123Or850],\n    [ascii, extractASCII]\n  );\n}\n\nfunction parseISODuration(s) {\n  return parse(s, [isoDuration, extractISODuration]);\n}\n\nconst extractISOTimeOnly = combineExtractors(extractISOTime);\n\nfunction parseISOTimeOnly(s) {\n  return parse(s, [isoTimeOnly, extractISOTimeOnly]);\n}\n\nconst sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nconst sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\n\nconst extractISOTimeOffsetAndIANAZone = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\nfunction parseSQL(s) {\n  return parse(\n    s,\n    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3JlZ2V4UGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFPbUI7QUFDcUI7QUFDa0I7QUFDZDs7QUFFNUM7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHdCQUF3QjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixNQUFNLHNCQUFzQixNQUFNLG9CQUFvQixNQUFNOztBQUUzRjtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQyxTQUFTO0FBQ1QsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakMscUJBQXFCLHNEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CLFVBQVUsaUJBQWlCO0FBQzVFLGlFQUFpRSxLQUFLO0FBQ3RFLCtCQUErQix3QkFBd0IsRUFBRSxnQkFBZ0I7QUFDekUsK0NBQStDLG9CQUFvQjtBQUNuRSw2QkFBNkIsRUFBRSxJQUFJLEVBQUU7QUFDckMsMEJBQTBCLEVBQUU7QUFDNUIsNkJBQTZCLEVBQUUsT0FBTyxFQUFFO0FBQ3hDO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxrQkFBa0I7QUFDN0M7QUFDQSxLQUFLLHlCQUF5QixNQUFNLG1CQUFtQixJQUFJLGlCQUFpQjtBQUM1RTtBQUNBLDRDQUE0QyxvQkFBb0I7O0FBRWhFO0FBQ0E7QUFDQSxTQUFTLHFEQUFXLGlCQUFpQixzREFBWTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFXO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzREFBWTtBQUM3QiwwQkFBMEIsaUVBQWU7QUFDekMsWUFBWTtBQUNaOztBQUVBO0FBQ0EsK0JBQStCLDBEQUFRO0FBQ3ZDLFlBQVk7QUFDWjs7QUFFQTs7QUFFQSxpQ0FBaUMsd0JBQXdCOztBQUV6RDs7QUFFQTtBQUNBLG1CQUFtQixLQUFLLFFBQVEsS0FBSyxlQUFlLEtBQUssUUFBUSxLQUFLLGVBQWUsS0FBSyxRQUFRLEtBQUssZUFBZSxLQUFLLFFBQVEsS0FBSyxtQkFBbUIsS0FBSyxRQUFRLEtBQUssZUFBZSxLQUFLLFFBQVEsS0FBSyxlQUFlLEtBQUssY0FBYyxLQUFLOztBQUVyUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQWE7QUFDdEMsMEJBQTBCLHVEQUFhO0FBQ3ZDLHlCQUF5Qix1REFBYTtBQUN0Qyx3QkFBd0IsdURBQWE7QUFDckMseUJBQXlCLHVEQUFhO0FBQ3RDLDJCQUEyQix1REFBYTtBQUN4QywyQkFBMkIsdURBQWE7QUFDeEMsZ0NBQWdDLHFEQUFXO0FBQzNDLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyx3REFBYyxDQUFDLHNEQUFZLGFBQWEsc0RBQVk7QUFDckYsV0FBVyxvREFBbUI7QUFDOUIsU0FBUyxzREFBWTtBQUNyQixVQUFVLHNEQUFZO0FBQ3RCLFlBQVksc0RBQVk7QUFDeEI7O0FBRUEsaUNBQWlDLHNEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQW9CO0FBQzlCLFVBQVUsc0RBQXFCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxJQUFJLDBEQUEwRCxJQUFJOztBQUUvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osYUFBYSxzREFBWTtBQUN6Qjs7QUFFQSxzQkFBc0IsaUVBQWU7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrR0FBa0csRUFBRTtBQUNwRztBQUNBO0FBQ0E7QUFDQSwwSEFBMEgsRUFBRTs7QUFFNUg7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFlO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBZTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB1bnRydW5jYXRlWWVhcixcbiAgc2lnbmVkT2Zmc2V0LFxuICBwYXJzZUludGVnZXIsXG4gIHBhcnNlTWlsbGlzLFxuICBpc1VuZGVmaW5lZCxcbiAgcGFyc2VGbG9hdGluZyxcbn0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLypcbiAqIFRoaXMgZmlsZSBoYW5kbGVzIHBhcnNpbmcgZm9yIHdlbGwtc3BlY2lmaWVkIGZvcm1hdHMuIEhlcmUncyBob3cgaXQgd29ya3M6XG4gKiBUd28gdGhpbmdzIGdvIGludG8gcGFyc2luZzogYSByZWdleCB0byBtYXRjaCB3aXRoIGFuZCBhbiBleHRyYWN0b3IgdG8gdGFrZSBhcGFydCB0aGUgZ3JvdXBzIGluIHRoZSBtYXRjaC5cbiAqIEFuIGV4dHJhY3RvciBpcyBqdXN0IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlZ2V4IG1hdGNoIGFycmF5IGFuZCByZXR1cm5zIGEgeyB5ZWFyOiAuLi4sIG1vbnRoOiAuLi4gfSBvYmplY3RcbiAqIHBhcnNlKCkgZG9lcyB0aGUgd29yayBvZiBleGVjdXRpbmcgdGhlIHJlZ2V4IGFuZCBhcHBseWluZyB0aGUgZXh0cmFjdG9yLiBJdCB0YWtlcyBtdWx0aXBsZSByZWdleC9leHRyYWN0b3IgcGFpcnMgdG8gdHJ5IGluIHNlcXVlbmNlLlxuICogRXh0cmFjdG9ycyBjYW4gdGFrZSBhIFwiY3Vyc29yXCIgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgaW4gdGhlIG1hdGNoIHRvIGxvb2sgYXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBjb21iaW5lIGV4dHJhY3RvcnMuXG4gKiBjb21iaW5lRXh0cmFjdG9ycygpIGRvZXMgdGhlIHdvcmsgb2YgY29tYmluaW5nIHRoZW0sIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGN1cnNvciB0aHJvdWdoIG11bHRpcGxlIGV4dHJhY3Rpb25zLlxuICogU29tZSBleHRyYWN0aW9ucyBhcmUgc3VwZXIgZHVtYiBhbmQgc2ltcGxlUGFyc2UgYW5kIGZyb21TdHJpbmdzIGhlbHAgRFJZIHRoZW0uXG4gKi9cblxuY29uc3QgaWFuYVJlZ2V4ID0gL1tBLVphLXpfKy1dezEsMjU2fSg/Ojo/XFwvW0EtWmEtejAtOV8rLV17MSwyNTZ9KD86XFwvW0EtWmEtejAtOV8rLV17MSwyNTZ9KT8pPy87XG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWdleGVzKC4uLnJlZ2V4ZXMpIHtcbiAgY29uc3QgZnVsbCA9IHJlZ2V4ZXMucmVkdWNlKChmLCByKSA9PiBmICsgci5zb3VyY2UsIFwiXCIpO1xuICByZXR1cm4gUmVnRXhwKGBeJHtmdWxsfSRgKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUV4dHJhY3RvcnMoLi4uZXh0cmFjdG9ycykge1xuICByZXR1cm4gKG0pID0+XG4gICAgZXh0cmFjdG9yc1xuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFttZXJnZWRWYWxzLCBtZXJnZWRab25lLCBjdXJzb3JdLCBleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt2YWwsIHpvbmUsIG5leHRdID0gZXgobSwgY3Vyc29yKTtcbiAgICAgICAgICByZXR1cm4gW3sgLi4ubWVyZ2VkVmFscywgLi4udmFsIH0sIHpvbmUgfHwgbWVyZ2VkWm9uZSwgbmV4dF07XG4gICAgICAgIH0sXG4gICAgICAgIFt7fSwgbnVsbCwgMV1cbiAgICAgIClcbiAgICAgIC5zbGljZSgwLCAyKTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocywgLi4ucGF0dGVybnMpIHtcbiAgaWYgKHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICBmb3IgKGNvbnN0IFtyZWdleCwgZXh0cmFjdG9yXSBvZiBwYXR0ZXJucykge1xuICAgIGNvbnN0IG0gPSByZWdleC5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdG9yKG0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW251bGwsIG51bGxdO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVQYXJzZSguLi5rZXlzKSB7XG4gIHJldHVybiAobWF0Y2gsIGN1cnNvcikgPT4ge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtrZXlzW2ldXSA9IHBhcnNlSW50ZWdlcihtYXRjaFtjdXJzb3IgKyBpXSk7XG4gICAgfVxuICAgIHJldHVybiBbcmV0LCBudWxsLCBjdXJzb3IgKyBpXTtcbiAgfTtcbn1cblxuLy8gSVNPIGFuZCBTUUwgcGFyc2luZ1xuY29uc3Qgb2Zmc2V0UmVnZXggPSAvKD86KFtael0pfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPykvO1xuY29uc3QgaXNvRXh0ZW5kZWRab25lID0gYCg/OiR7b2Zmc2V0UmVnZXguc291cmNlfT8oPzpcXFxcWygke2lhbmFSZWdleC5zb3VyY2V9KVxcXFxdKT8pP2A7XG5jb25zdCBpc29UaW1lQmFzZVJlZ2V4ID0gLyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzpbLixdKFxcZHsxLDMwfSkpPyk/KT8vO1xuY29uc3QgaXNvVGltZVJlZ2V4ID0gUmVnRXhwKGAke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSR7aXNvRXh0ZW5kZWRab25lfWApO1xuY29uc3QgaXNvVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzpbVHRdJHtpc29UaW1lUmVnZXguc291cmNlfSk/YCk7XG5jb25zdCBpc29ZbWRSZWdleCA9IC8oWystXVxcZHs2fXxcXGR7NH0pKD86LT8oXFxkXFxkKSg/Oi0/KFxcZFxcZCkpPyk/LztcbmNvbnN0IGlzb1dlZWtSZWdleCA9IC8oXFxkezR9KS0/VyhcXGRcXGQpKD86LT8oXFxkKSk/LztcbmNvbnN0IGlzb09yZGluYWxSZWdleCA9IC8oXFxkezR9KS0/KFxcZHszfSkvO1xuY29uc3QgZXh0cmFjdElTT1dlZWtEYXRhID0gc2ltcGxlUGFyc2UoXCJ3ZWVrWWVhclwiLCBcIndlZWtOdW1iZXJcIiwgXCJ3ZWVrRGF5XCIpO1xuY29uc3QgZXh0cmFjdElTT09yZGluYWxEYXRhID0gc2ltcGxlUGFyc2UoXCJ5ZWFyXCIsIFwib3JkaW5hbFwiKTtcbmNvbnN0IHNxbFltZFJlZ2V4ID0gLyhcXGR7NH0pLShcXGRcXGQpLShcXGRcXGQpLzsgLy8gZHVtYmVkLWRvd24gdmVyc2lvbiBvZiB0aGUgSVNPIG9uZVxuY29uc3Qgc3FsVGltZVJlZ2V4ID0gUmVnRXhwKFxuICBgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0gPyg/OiR7b2Zmc2V0UmVnZXguc291cmNlfXwoJHtpYW5hUmVnZXguc291cmNlfSkpP2Bcbik7XG5jb25zdCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OiAke3NxbFRpbWVSZWdleC5zb3VyY2V9KT9gKTtcblxuZnVuY3Rpb24gaW50KG1hdGNoLCBwb3MsIGZhbGxiYWNrKSB7XG4gIGNvbnN0IG0gPSBtYXRjaFtwb3NdO1xuICByZXR1cm4gaXNVbmRlZmluZWQobSkgPyBmYWxsYmFjayA6IHBhcnNlSW50ZWdlcihtKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1ltZChtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgeWVhcjogaW50KG1hdGNoLCBjdXJzb3IpLFxuICAgIG1vbnRoOiBpbnQobWF0Y2gsIGN1cnNvciArIDEsIDEpLFxuICAgIGRheTogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAxKSxcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPVGltZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaG91cnM6IGludChtYXRjaCwgY3Vyc29yLCAwKSxcbiAgICBtaW51dGVzOiBpbnQobWF0Y2gsIGN1cnNvciArIDEsIDApLFxuICAgIHNlY29uZHM6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMCksXG4gICAgbWlsbGlzZWNvbmRzOiBwYXJzZU1pbGxpcyhtYXRjaFtjdXJzb3IgKyAzXSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyA0XTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT09mZnNldChtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IGxvY2FsID0gIW1hdGNoW2N1cnNvcl0gJiYgIW1hdGNoW2N1cnNvciArIDFdLFxuICAgIGZ1bGxPZmZzZXQgPSBzaWduZWRPZmZzZXQobWF0Y2hbY3Vyc29yICsgMV0sIG1hdGNoW2N1cnNvciArIDJdKSxcbiAgICB6b25lID0gbG9jYWwgPyBudWxsIDogRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGZ1bGxPZmZzZXQpO1xuICByZXR1cm4gW3t9LCB6b25lLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElBTkFab25lKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3Qgem9uZSA9IG1hdGNoW2N1cnNvcl0gPyBJQU5BWm9uZS5jcmVhdGUobWF0Y2hbY3Vyc29yXSkgOiBudWxsO1xuICByZXR1cm4gW3t9LCB6b25lLCBjdXJzb3IgKyAxXTtcbn1cblxuLy8gSVNPIHRpbWUgcGFyc2luZ1xuXG5jb25zdCBpc29UaW1lT25seSA9IFJlZ0V4cChgXlQ/JHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0kYCk7XG5cbi8vIElTTyBkdXJhdGlvbiBwYXJzaW5nXG5cbmNvbnN0IGlzb0R1cmF0aW9uID1cbiAgL14tP1AoPzooPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylZKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylNKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylXKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylEKT8oPzpUKD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pSCk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KSg/OlsuLF0oLT9cXGR7MSwyMH0pKT9TKT8pPykkLztcblxuZnVuY3Rpb24gZXh0cmFjdElTT0R1cmF0aW9uKG1hdGNoKSB7XG4gIGNvbnN0IFtzLCB5ZWFyU3RyLCBtb250aFN0ciwgd2Vla1N0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgbWlsbGlzZWNvbmRzU3RyXSA9XG4gICAgbWF0Y2g7XG5cbiAgY29uc3QgaGFzTmVnYXRpdmVQcmVmaXggPSBzWzBdID09PSBcIi1cIjtcbiAgY29uc3QgbmVnYXRpdmVTZWNvbmRzID0gc2Vjb25kU3RyICYmIHNlY29uZFN0clswXSA9PT0gXCItXCI7XG5cbiAgY29uc3QgbWF5YmVOZWdhdGUgPSAobnVtLCBmb3JjZSA9IGZhbHNlKSA9PlxuICAgIG51bSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCAobnVtICYmIGhhc05lZ2F0aXZlUHJlZml4KSkgPyAtbnVtIDogbnVtO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgeWVhcnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoeWVhclN0cikpLFxuICAgICAgbW9udGhzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1vbnRoU3RyKSksXG4gICAgICB3ZWVrczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh3ZWVrU3RyKSksXG4gICAgICBkYXlzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGRheVN0cikpLFxuICAgICAgaG91cnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoaG91clN0cikpLFxuICAgICAgbWludXRlczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtaW51dGVTdHIpKSxcbiAgICAgIHNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoc2Vjb25kU3RyKSwgc2Vjb25kU3RyID09PSBcIi0wXCIpLFxuICAgICAgbWlsbGlzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZU1pbGxpcyhtaWxsaXNlY29uZHNTdHIpLCBuZWdhdGl2ZVNlY29uZHMpLFxuICAgIH0sXG4gIF07XG59XG5cbi8vIFRoZXNlIGFyZSBhIGxpdHRsZSBicmFpbmRlYWQuIEVEVCAqc2hvdWxkKiB0ZWxsIHVzIHRoYXQgd2UncmUgaW4sIHNheSwgQW1lcmljYS9OZXdfWW9ya1xuLy8gYW5kIG5vdCBqdXN0IHRoYXQgd2UncmUgaW4gLTI0MCAqcmlnaHQgbm93Ki4gQnV0IHNpbmNlIEkgZG9uJ3QgdGhpbmsgdGhlc2UgYXJlIHVzZWQgdGhhdCBvZnRlblxuLy8gSSdtIGp1c3QgZ29pbmcgdG8gaWdub3JlIHRoYXRcbmNvbnN0IG9ic09mZnNldHMgPSB7XG4gIEdNVDogMCxcbiAgRURUOiAtNCAqIDYwLFxuICBFU1Q6IC01ICogNjAsXG4gIENEVDogLTUgKiA2MCxcbiAgQ1NUOiAtNiAqIDYwLFxuICBNRFQ6IC02ICogNjAsXG4gIE1TVDogLTcgKiA2MCxcbiAgUERUOiAtNyAqIDYwLFxuICBQU1Q6IC04ICogNjAsXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgeWVhcjogeWVhclN0ci5sZW5ndGggPT09IDIgPyB1bnRydW5jYXRlWWVhcihwYXJzZUludGVnZXIoeWVhclN0cikpIDogcGFyc2VJbnRlZ2VyKHllYXJTdHIpLFxuICAgIG1vbnRoOiBFbmdsaXNoLm1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpICsgMSxcbiAgICBkYXk6IHBhcnNlSW50ZWdlcihkYXlTdHIpLFxuICAgIGhvdXI6IHBhcnNlSW50ZWdlcihob3VyU3RyKSxcbiAgICBtaW51dGU6IHBhcnNlSW50ZWdlcihtaW51dGVTdHIpLFxuICB9O1xuXG4gIGlmIChzZWNvbmRTdHIpIHJlc3VsdC5zZWNvbmQgPSBwYXJzZUludGVnZXIoc2Vjb25kU3RyKTtcbiAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICByZXN1bHQud2Vla2RheSA9XG4gICAgICB3ZWVrZGF5U3RyLmxlbmd0aCA+IDNcbiAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlzTG9uZy5pbmRleE9mKHdlZWtkYXlTdHIpICsgMVxuICAgICAgICA6IEVuZ2xpc2gud2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpICsgMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFJGQyAyODIyLzUzMjJcbmNvbnN0IHJmYzI4MjIgPVxuICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLFxccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoPzooWystXVxcZFxcZCkoXFxkXFxkKSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMyODIyKG1hdGNoKSB7XG4gIGNvbnN0IFtcbiAgICAgICxcbiAgICAgIHdlZWtkYXlTdHIsXG4gICAgICBkYXlTdHIsXG4gICAgICBtb250aFN0cixcbiAgICAgIHllYXJTdHIsXG4gICAgICBob3VyU3RyLFxuICAgICAgbWludXRlU3RyLFxuICAgICAgc2Vjb25kU3RyLFxuICAgICAgb2JzT2Zmc2V0LFxuICAgICAgbWlsT2Zmc2V0LFxuICAgICAgb2ZmSG91clN0cixcbiAgICAgIG9mZk1pbnV0ZVN0cixcbiAgICBdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuXG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvYnNPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gIH0gZWxzZSBpZiAobWlsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKTtcbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0LCBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCldO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcKFteKCldKlxcKXxbXFxuXFx0XS9nLCBcIiBcIilcbiAgICAucmVwbGFjZSgvKFxcc1xccyspL2csIFwiIFwiKVxuICAgIC50cmltKCk7XG59XG5cbi8vIGh0dHAgZGF0ZVxuXG5jb25zdCByZmMxMTIzID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLCAoXFxkXFxkKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpIChcXGR7NH0pIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICByZmM4NTAgPVxuICAgIC9eKE1vbmRheXxUdWVzZGF5fFdlZG5lc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8U3VuZGF5KSwgKFxcZFxcZCktKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKS0oXFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgYXNjaWkgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1bikgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoIFxcZHxcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIChcXGR7NH0pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMxMTIzT3I4NTAobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgZGF5U3RyLCBtb250aFN0ciwgeWVhclN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEFTQ0lJKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCB5ZWFyU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmNvbnN0IGlzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29ZbWRSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvV2Vla1JlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29PcmRpbmFsUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29UaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1RpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09ZbWQsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1dlZWtEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZSA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPT3JkaW5hbERhdGEsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuXG4vKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09EYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW2lzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lXSxcbiAgICBbaXNvVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0XVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSRkMyODIyRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShwcmVwcm9jZXNzUkZDMjgyMihzKSwgW3JmYzI4MjIsIGV4dHJhY3RSRkMyODIyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUhUVFBEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3JmYzExMjMsIGV4dHJhY3RSRkMxMTIzT3I4NTBdLFxuICAgIFtyZmM4NTAsIGV4dHJhY3RSRkMxMTIzT3I4NTBdLFxuICAgIFthc2NpaSwgZXh0cmFjdEFTQ0lJXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09EdXJhdGlvbihzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvRHVyYXRpb24sIGV4dHJhY3RJU09EdXJhdGlvbl0pO1xufVxuXG5jb25zdCBleHRyYWN0SVNPVGltZU9ubHkgPSBjb21iaW5lRXh0cmFjdG9ycyhleHRyYWN0SVNPVGltZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT1RpbWVPbmx5KHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29UaW1lT25seSwgZXh0cmFjdElTT1RpbWVPbmx5XSk7XG59XG5cbmNvbnN0IHNxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxZbWRSZWdleCwgc3FsVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IHNxbFRpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1RpbWVPZmZzZXRBbmRJQU5BWm9uZSA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTUUwocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtzcWxUaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVPZmZzZXRBbmRJQU5BWm9uZV1cbiAgKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/regexParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/tokenParser.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/tokenParser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TokenParser: () => (/* binding */ TokenParser),\n/* harmony export */   expandMacroTokens: () => (/* binding */ expandMacroTokens),\n/* harmony export */   explainFromTokens: () => (/* binding */ explainFromTokens),\n/* harmony export */   formatOptsToTokens: () => (/* binding */ formatOptsToTokens),\n/* harmony export */   parseFromTokens: () => (/* binding */ parseFromTokens)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datetime.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _digits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./digits.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/digits.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\");\n\n\n\n\n\n\n\n\nconst MISSING_FTP = \"missing Intl.DateTimeFormat.formatToParts support\";\n\nfunction intUnit(regex, post = (i) => i) {\n  return { regex, deser: ([s]) => post((0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.parseDigits)(s)) };\n}\n\nconst NBSP = String.fromCharCode(160);\nconst spaceOrNBSP = `[ ${NBSP}]`;\nconst spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, \"g\");\n\nfunction fixListRegex(s) {\n  // make dots optional and also make them literal\n  // make space and non breakable space characters interchangeable\n  return s.replace(/\\./g, \"\\\\.?\").replace(spaceOrNBSPRegExp, spaceOrNBSP);\n}\n\nfunction stripInsensitivities(s) {\n  return s\n    .replace(/\\./g, \"\") // ignore dots that were made optional\n    .replace(spaceOrNBSPRegExp, \" \") // interchange space and nbsp\n    .toLowerCase();\n}\n\nfunction oneOf(strings, startIndex) {\n  if (strings === null) {\n    return null;\n  } else {\n    return {\n      regex: RegExp(strings.map(fixListRegex).join(\"|\")),\n      deser: ([s]) =>\n        strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,\n    };\n  }\n}\n\nfunction offset(regex, groups) {\n  return { regex, deser: ([, h, m]) => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(h, m), groups };\n}\n\nfunction simple(regex) {\n  return { regex, deser: ([s]) => s };\n}\n\nfunction escapeToken(value) {\n  return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n\n/**\n * @param token\n * @param {Locale} loc\n */\nfunction unitForToken(token, loc) {\n  const one = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc),\n    two = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2}\"),\n    three = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{3}\"),\n    four = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4}\"),\n    six = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{6}\"),\n    oneOrTwo = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,2}\"),\n    oneToThree = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,3}\"),\n    oneToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,6}\"),\n    oneToNine = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{1,9}\"),\n    twoToFour = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{2,4}\"),\n    fourToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, \"{4,6}\"),\n    literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),\n    unitate = (t) => {\n      if (token.literal) {\n        return literal(t);\n      }\n      switch (t.val) {\n        // era\n        case \"G\":\n          return oneOf(loc.eras(\"short\"), 0);\n        case \"GG\":\n          return oneOf(loc.eras(\"long\"), 0);\n        // years\n        case \"y\":\n          return intUnit(oneToSix);\n        case \"yy\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        case \"yyyy\":\n          return intUnit(four);\n        case \"yyyyy\":\n          return intUnit(fourToSix);\n        case \"yyyyyy\":\n          return intUnit(six);\n        // months\n        case \"M\":\n          return intUnit(oneOrTwo);\n        case \"MM\":\n          return intUnit(two);\n        case \"MMM\":\n          return oneOf(loc.months(\"short\", true), 1);\n        case \"MMMM\":\n          return oneOf(loc.months(\"long\", true), 1);\n        case \"L\":\n          return intUnit(oneOrTwo);\n        case \"LL\":\n          return intUnit(two);\n        case \"LLL\":\n          return oneOf(loc.months(\"short\", false), 1);\n        case \"LLLL\":\n          return oneOf(loc.months(\"long\", false), 1);\n        // dates\n        case \"d\":\n          return intUnit(oneOrTwo);\n        case \"dd\":\n          return intUnit(two);\n        // ordinals\n        case \"o\":\n          return intUnit(oneToThree);\n        case \"ooo\":\n          return intUnit(three);\n        // time\n        case \"HH\":\n          return intUnit(two);\n        case \"H\":\n          return intUnit(oneOrTwo);\n        case \"hh\":\n          return intUnit(two);\n        case \"h\":\n          return intUnit(oneOrTwo);\n        case \"mm\":\n          return intUnit(two);\n        case \"m\":\n          return intUnit(oneOrTwo);\n        case \"q\":\n          return intUnit(oneOrTwo);\n        case \"qq\":\n          return intUnit(two);\n        case \"s\":\n          return intUnit(oneOrTwo);\n        case \"ss\":\n          return intUnit(two);\n        case \"S\":\n          return intUnit(oneToThree);\n        case \"SSS\":\n          return intUnit(three);\n        case \"u\":\n          return simple(oneToNine);\n        case \"uu\":\n          return simple(oneOrTwo);\n        case \"uuu\":\n          return intUnit(one);\n        // meridiem\n        case \"a\":\n          return oneOf(loc.meridiems(), 0);\n        // weekYear (k)\n        case \"kkkk\":\n          return intUnit(four);\n        case \"kk\":\n          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);\n        // weekNumber (W)\n        case \"W\":\n          return intUnit(oneOrTwo);\n        case \"WW\":\n          return intUnit(two);\n        // weekdays\n        case \"E\":\n        case \"c\":\n          return intUnit(one);\n        case \"EEE\":\n          return oneOf(loc.weekdays(\"short\", false), 1);\n        case \"EEEE\":\n          return oneOf(loc.weekdays(\"long\", false), 1);\n        case \"ccc\":\n          return oneOf(loc.weekdays(\"short\", true), 1);\n        case \"cccc\":\n          return oneOf(loc.weekdays(\"long\", true), 1);\n        // offset/zone\n        case \"Z\":\n        case \"ZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);\n        case \"ZZZ\":\n          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);\n        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing\n        // because we don't have any way to figure out what they are\n        case \"z\":\n          return simple(/[a-z_+-/]{1,256}?/i);\n        // this special-case \"token\" represents a place where a macro-token expanded into a white-space literal\n        // in this case we accept any non-newline white-space\n        case \" \":\n          return simple(/[^\\S\\n\\r]/);\n        default:\n          return literal(t);\n      }\n    };\n\n  const unit = unitate(token) || {\n    invalidReason: MISSING_FTP,\n  };\n\n  unit.token = token;\n\n  return unit;\n}\n\nconst partTypeStyleToTokenVal = {\n  year: {\n    \"2-digit\": \"yy\",\n    numeric: \"yyyyy\",\n  },\n  month: {\n    numeric: \"M\",\n    \"2-digit\": \"MM\",\n    short: \"MMM\",\n    long: \"MMMM\",\n  },\n  day: {\n    numeric: \"d\",\n    \"2-digit\": \"dd\",\n  },\n  weekday: {\n    short: \"EEE\",\n    long: \"EEEE\",\n  },\n  dayperiod: \"a\",\n  dayPeriod: \"a\",\n  hour12: {\n    numeric: \"h\",\n    \"2-digit\": \"hh\",\n  },\n  hour24: {\n    numeric: \"H\",\n    \"2-digit\": \"HH\",\n  },\n  minute: {\n    numeric: \"m\",\n    \"2-digit\": \"mm\",\n  },\n  second: {\n    numeric: \"s\",\n    \"2-digit\": \"ss\",\n  },\n  timeZoneName: {\n    long: \"ZZZZZ\",\n    short: \"ZZZ\",\n  },\n};\n\nfunction tokenForPart(part, formatOpts, resolvedOpts) {\n  const { type, value } = part;\n\n  if (type === \"literal\") {\n    const isSpace = /^\\s+$/.test(value);\n    return {\n      literal: !isSpace,\n      val: isSpace ? \" \" : value,\n    };\n  }\n\n  const style = formatOpts[type];\n\n  // The user might have explicitly specified hour12 or hourCycle\n  // if so, respect their decision\n  // if not, refer back to the resolvedOpts, which are based on the locale\n  let actualType = type;\n  if (type === \"hour\") {\n    if (formatOpts.hour12 != null) {\n      actualType = formatOpts.hour12 ? \"hour12\" : \"hour24\";\n    } else if (formatOpts.hourCycle != null) {\n      if (formatOpts.hourCycle === \"h11\" || formatOpts.hourCycle === \"h12\") {\n        actualType = \"hour12\";\n      } else {\n        actualType = \"hour24\";\n      }\n    } else {\n      // tokens only differentiate between 24 hours or not,\n      // so we do not need to check hourCycle here, which is less supported anyways\n      actualType = resolvedOpts.hour12 ? \"hour12\" : \"hour24\";\n    }\n  }\n  let val = partTypeStyleToTokenVal[actualType];\n  if (typeof val === \"object\") {\n    val = val[style];\n  }\n\n  if (val) {\n    return {\n      literal: false,\n      val,\n    };\n  }\n\n  return undefined;\n}\n\nfunction buildRegex(units) {\n  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, \"\");\n  return [`^${re}$`, units];\n}\n\nfunction match(input, regex, handlers) {\n  const matches = input.match(regex);\n\n  if (matches) {\n    const all = {};\n    let matchIndex = 1;\n    for (const i in handlers) {\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(handlers, i)) {\n        const h = handlers[i],\n          groups = h.groups ? h.groups + 1 : 1;\n        if (!h.literal && h.token) {\n          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));\n        }\n        matchIndex += groups;\n      }\n    }\n    return [matches, all];\n  } else {\n    return [matches, {}];\n  }\n}\n\nfunction dateTimeFromMatches(matches) {\n  const toField = (token) => {\n    switch (token) {\n      case \"S\":\n        return \"millisecond\";\n      case \"s\":\n        return \"second\";\n      case \"m\":\n        return \"minute\";\n      case \"h\":\n      case \"H\":\n        return \"hour\";\n      case \"d\":\n        return \"day\";\n      case \"o\":\n        return \"ordinal\";\n      case \"L\":\n      case \"M\":\n        return \"month\";\n      case \"y\":\n        return \"year\";\n      case \"E\":\n      case \"c\":\n        return \"weekday\";\n      case \"W\":\n        return \"weekNumber\";\n      case \"k\":\n        return \"weekYear\";\n      case \"q\":\n        return \"quarter\";\n      default:\n        return null;\n    }\n  };\n\n  let zone = null;\n  let specificOffset;\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.z)) {\n    zone = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(matches.z);\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.Z)) {\n    if (!zone) {\n      zone = new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matches.Z);\n    }\n    specificOffset = matches.Z;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.q)) {\n    matches.M = (matches.q - 1) * 3 + 1;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.h)) {\n    if (matches.h < 12 && matches.a === 1) {\n      matches.h += 12;\n    } else if (matches.h === 12 && matches.a === 0) {\n      matches.h = 0;\n    }\n  }\n\n  if (matches.G === 0 && matches.y) {\n    matches.y = -matches.y;\n  }\n\n  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.u)) {\n    matches.S = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(matches.u);\n  }\n\n  const vals = Object.keys(matches).reduce((r, k) => {\n    const f = toField(k);\n    if (f) {\n      r[f] = matches[k];\n    }\n\n    return r;\n  }, {});\n\n  return [vals, zone, specificOffset];\n}\n\nlet dummyDateTimeCache = null;\n\nfunction getDummyDateTime() {\n  if (!dummyDateTimeCache) {\n    dummyDateTimeCache = _datetime_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromMillis(1555555555555);\n  }\n\n  return dummyDateTimeCache;\n}\n\nfunction maybeExpandMacroToken(token, locale) {\n  if (token.literal) {\n    return token;\n  }\n\n  const formatOpts = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].macroTokenToFormatOpts(token.val);\n  const tokens = formatOptsToTokens(formatOpts, locale);\n\n  if (tokens == null || tokens.includes(undefined)) {\n    return token;\n  }\n\n  return tokens;\n}\n\nfunction expandMacroTokens(tokens, locale) {\n  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));\n}\n\n/**\n * @private\n */\n\nclass TokenParser {\n  constructor(locale, format) {\n    this.locale = locale;\n    this.format = format;\n    this.tokens = expandMacroTokens(_formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parseFormat(format), locale);\n    this.units = this.tokens.map((t) => unitForToken(t, locale));\n    this.disqualifyingUnit = this.units.find((t) => t.invalidReason);\n\n    if (!this.disqualifyingUnit) {\n      const [regexString, handlers] = buildRegex(this.units);\n      this.regex = RegExp(regexString, \"i\");\n      this.handlers = handlers;\n    }\n  }\n\n  explainFromTokens(input) {\n    if (!this.isValid) {\n      return { input, tokens: this.tokens, invalidReason: this.invalidReason };\n    } else {\n      const [rawMatches, matches] = match(input, this.regex, this.handlers),\n        [result, zone, specificOffset] = matches\n          ? dateTimeFromMatches(matches)\n          : [null, null, undefined];\n      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"a\") && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, \"H\")) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(\n          \"Can't include meridiem when specifying 24-hour format\"\n        );\n      }\n      return {\n        input,\n        tokens: this.tokens,\n        regex: this.regex,\n        rawMatches,\n        matches,\n        result,\n        zone,\n        specificOffset,\n      };\n    }\n  }\n\n  get isValid() {\n    return !this.disqualifyingUnit;\n  }\n\n  get invalidReason() {\n    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;\n  }\n}\n\nfunction explainFromTokens(locale, input, format) {\n  const parser = new TokenParser(locale, format);\n  return parser.explainFromTokens(input);\n}\n\nfunction parseFromTokens(locale, input, format) {\n  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);\n  return [result, zone, specificOffset, invalidReason];\n}\n\nfunction formatOptsToTokens(formatOpts, locale) {\n  if (!formatOpts) {\n    return null;\n  }\n\n  const formatter = _formatter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(locale, formatOpts);\n  const df = formatter.dtFormatter(getDummyDateTime());\n  const parts = df.formatToParts();\n  const resolvedOpts = df.resolvedOptions();\n  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtRztBQUM1RDtBQUNtQjtBQUNkO0FBQ047QUFDZ0I7QUFDTzs7QUFFN0Q7O0FBRUE7QUFDQSxXQUFXLDRCQUE0Qix1REFBVztBQUNsRDs7QUFFQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsNEJBQTRCLHNEQUFZO0FBQ25EOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGNBQWMsc0RBQVU7QUFDeEIsVUFBVSxzREFBVSxRQUFRLEVBQUU7QUFDOUIsWUFBWSxzREFBVSxRQUFRLEVBQUU7QUFDaEMsV0FBVyxzREFBVSxRQUFRLEVBQUU7QUFDL0IsVUFBVSxzREFBVSxRQUFRLEVBQUU7QUFDOUIsZUFBZSxzREFBVSxRQUFRLElBQUk7QUFDckMsaUJBQWlCLHNEQUFVLFFBQVEsSUFBSTtBQUN2QyxlQUFlLHNEQUFVLFFBQVEsSUFBSTtBQUNyQyxnQkFBZ0Isc0RBQVUsUUFBUSxJQUFJO0FBQ3RDLGdCQUFnQixzREFBVSxRQUFRLElBQUk7QUFDdEMsZ0JBQWdCLHNEQUFVLFFBQVEsSUFBSTtBQUN0Qyx3QkFBd0IscUVBQXFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0RBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvREFBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQixRQUFRLFdBQVc7QUFDOUU7QUFDQSwyQ0FBMkMsZ0JBQWdCLElBQUksV0FBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxFQUFFLEdBQUcsU0FBUztBQUN6RSxjQUFjLEdBQUc7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLHFEQUFXO0FBQ2xCLFdBQVcsMERBQVE7QUFDbkI7O0FBRUEsT0FBTyxxREFBVztBQUNsQjtBQUNBLGlCQUFpQixpRUFBZTtBQUNoQztBQUNBO0FBQ0E7O0FBRUEsT0FBTyxxREFBVztBQUNsQjtBQUNBOztBQUVBLE9BQU8scURBQVc7QUFDbEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU8scURBQVc7QUFDbEIsZ0JBQWdCLHFEQUFXO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFEQUFTO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscURBQVM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFjLGtCQUFrQix3REFBYztBQUN4RCxrQkFBa0IscUVBQTZCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLDhDQUE4QztBQUN4RDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdG9rZW5QYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VNaWxsaXMsIGlzVW5kZWZpbmVkLCB1bnRydW5jYXRlWWVhciwgc2lnbmVkT2Zmc2V0LCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCB7IGRpZ2l0UmVnZXgsIHBhcnNlRGlnaXRzIH0gZnJvbSBcIi4vZGlnaXRzLmpzXCI7XG5pbXBvcnQgeyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuY29uc3QgTUlTU0lOR19GVFAgPSBcIm1pc3NpbmcgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIHN1cHBvcnRcIjtcblxuZnVuY3Rpb24gaW50VW5pdChyZWdleCwgcG9zdCA9IChpKSA9PiBpKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcG9zdChwYXJzZURpZ2l0cyhzKSkgfTtcbn1cblxuY29uc3QgTkJTUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKTtcbmNvbnN0IHNwYWNlT3JOQlNQID0gYFsgJHtOQlNQfV1gO1xuY29uc3Qgc3BhY2VPck5CU1BSZWdFeHAgPSBuZXcgUmVnRXhwKHNwYWNlT3JOQlNQLCBcImdcIik7XG5cbmZ1bmN0aW9uIGZpeExpc3RSZWdleChzKSB7XG4gIC8vIG1ha2UgZG90cyBvcHRpb25hbCBhbmQgYWxzbyBtYWtlIHRoZW0gbGl0ZXJhbFxuICAvLyBtYWtlIHNwYWNlIGFuZCBub24gYnJlYWthYmxlIHNwYWNlIGNoYXJhY3RlcnMgaW50ZXJjaGFuZ2VhYmxlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuP1wiKS5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBzcGFjZU9yTkJTUCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwuL2csIFwiXCIpIC8vIGlnbm9yZSBkb3RzIHRoYXQgd2VyZSBtYWRlIG9wdGlvbmFsXG4gICAgLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIFwiIFwiKSAvLyBpbnRlcmNoYW5nZSBzcGFjZSBhbmQgbmJzcFxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogKFtzXSkgPT5cbiAgICAgICAgc3RyaW5ncy5maW5kSW5kZXgoKGkpID0+IHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKSkgKyBzdGFydEluZGV4LFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoWywgaCwgbV0pID0+IHNpZ25lZE9mZnNldChoLCBtKSwgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZShyZWdleCkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHMgfTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdG9rZW5cbiAqIEBwYXJhbSB7TG9jYWxlfSBsb2NcbiAqL1xuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgY29uc3Qgb25lID0gZGlnaXRSZWdleChsb2MpLFxuICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICB0aHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInszfVwiKSxcbiAgICBmb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezR9XCIpLFxuICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICBvbmVPclR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDJ9XCIpLFxuICAgIG9uZVRvVGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwzfVwiKSxcbiAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgIG9uZVRvTmluZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDl9XCIpLFxuICAgIHR3b1RvRm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcInsyLDR9XCIpLFxuICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgIGxpdGVyYWwgPSAodCkgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gKHQpID0+IHtcbiAgICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0LnZhbCkge1xuICAgICAgICAvLyBlcmFcbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJzaG9ydFwiKSwgMCk7XG4gICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcImxvbmdcIiksIDApO1xuICAgICAgICAvLyB5ZWFyc1xuICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91cik7XG4gICAgICAgIGNhc2UgXCJ5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXJUb1NpeCk7XG4gICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChzaXgpO1xuICAgICAgICAvLyBtb250aHNcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIG9yZGluYWxzXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIC8vIHRpbWVcbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lVG9OaW5lKTtcbiAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICAvLyBtZXJpZGllbVxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubWVyaWRpZW1zKCksIDApO1xuICAgICAgICAvLyB3ZWVrWWVhciAoaylcbiAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIC8vIHdlZWtOdW1iZXIgKFcpXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyB3ZWVrZGF5c1xuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIC8vIG9mZnNldC96b25lXG4gICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKD86Oigke3R3by5zb3VyY2V9KSk/YCksIDIpO1xuICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoJHt0d28uc291cmNlfSk/YCksIDIpO1xuICAgICAgICAvLyB3ZSBkb24ndCBzdXBwb3J0IFpaWlogKFBTVCkgb3IgWlpaWlogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSkgaW4gcGFyc2luZ1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYW55IHdheSB0byBmaWd1cmUgb3V0IHdoYXQgdGhleSBhcmVcbiAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bYS16XystL117MSwyNTZ9Py9pKTtcbiAgICAgICAgLy8gdGhpcyBzcGVjaWFsLWNhc2UgXCJ0b2tlblwiIHJlcHJlc2VudHMgYSBwbGFjZSB3aGVyZSBhIG1hY3JvLXRva2VuIGV4cGFuZGVkIGludG8gYSB3aGl0ZS1zcGFjZSBsaXRlcmFsXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBhY2NlcHQgYW55IG5vbi1uZXdsaW5lIHdoaXRlLXNwYWNlXG4gICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW15cXFNcXG5cXHJdLyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgfTtcblxuICBjb25zdCB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQLFxuICB9O1xuXG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcblxuICByZXR1cm4gdW5pdDtcbn1cblxuY29uc3QgcGFydFR5cGVTdHlsZVRvVG9rZW5WYWwgPSB7XG4gIHllYXI6IHtcbiAgICBcIjItZGlnaXRcIjogXCJ5eVwiLFxuICAgIG51bWVyaWM6IFwieXl5eXlcIixcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiLFxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiLFxuICB9LFxuICB3ZWVrZGF5OiB7XG4gICAgc2hvcnQ6IFwiRUVFXCIsXG4gICAgbG9uZzogXCJFRUVFXCIsXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXIxMjoge1xuICAgIG51bWVyaWM6IFwiaFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImhoXCIsXG4gIH0sXG4gIGhvdXIyNDoge1xuICAgIG51bWVyaWM6IFwiSFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIkhIXCIsXG4gIH0sXG4gIG1pbnV0ZToge1xuICAgIG51bWVyaWM6IFwibVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIm1tXCIsXG4gIH0sXG4gIHNlY29uZDoge1xuICAgIG51bWVyaWM6IFwic1wiLFxuICAgIFwiMi1kaWdpdFwiOiBcInNzXCIsXG4gIH0sXG4gIHRpbWVab25lTmFtZToge1xuICAgIGxvbmc6IFwiWlpaWlpcIixcbiAgICBzaG9ydDogXCJaWlpcIixcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRva2VuRm9yUGFydChwYXJ0LCBmb3JtYXRPcHRzLCByZXNvbHZlZE9wdHMpIHtcbiAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gcGFydDtcblxuICBpZiAodHlwZSA9PT0gXCJsaXRlcmFsXCIpIHtcbiAgICBjb25zdCBpc1NwYWNlID0gL15cXHMrJC8udGVzdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdGVyYWw6ICFpc1NwYWNlLFxuICAgICAgdmFsOiBpc1NwYWNlID8gXCIgXCIgOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSBmb3JtYXRPcHRzW3R5cGVdO1xuXG4gIC8vIFRoZSB1c2VyIG1pZ2h0IGhhdmUgZXhwbGljaXRseSBzcGVjaWZpZWQgaG91cjEyIG9yIGhvdXJDeWNsZVxuICAvLyBpZiBzbywgcmVzcGVjdCB0aGVpciBkZWNpc2lvblxuICAvLyBpZiBub3QsIHJlZmVyIGJhY2sgdG8gdGhlIHJlc29sdmVkT3B0cywgd2hpY2ggYXJlIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgbGV0IGFjdHVhbFR5cGUgPSB0eXBlO1xuICBpZiAodHlwZSA9PT0gXCJob3VyXCIpIHtcbiAgICBpZiAoZm9ybWF0T3B0cy5ob3VyMTIgIT0gbnVsbCkge1xuICAgICAgYWN0dWFsVHlwZSA9IGZvcm1hdE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfSBlbHNlIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZm9ybWF0T3B0cy5ob3VyQ3ljbGUgPT09IFwiaDExXCIgfHwgZm9ybWF0T3B0cy5ob3VyQ3ljbGUgPT09IFwiaDEyXCIpIHtcbiAgICAgICAgYWN0dWFsVHlwZSA9IFwiaG91cjEyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMjRcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9rZW5zIG9ubHkgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIDI0IGhvdXJzIG9yIG5vdCxcbiAgICAgIC8vIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGhvdXJDeWNsZSBoZXJlLCB3aGljaCBpcyBsZXNzIHN1cHBvcnRlZCBhbnl3YXlzXG4gICAgICBhY3R1YWxUeXBlID0gcmVzb2x2ZWRPcHRzLmhvdXIxMiA/IFwiaG91cjEyXCIgOiBcImhvdXIyNFwiO1xuICAgIH1cbiAgfVxuICBsZXQgdmFsID0gcGFydFR5cGVTdHlsZVRvVG9rZW5WYWxbYWN0dWFsVHlwZV07XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFsID0gdmFsW3N0eWxlXTtcbiAgfVxuXG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICB2YWwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVnZXgodW5pdHMpIHtcbiAgY29uc3QgcmUgPSB1bml0cy5tYXAoKHUpID0+IHUucmVnZXgpLnJlZHVjZSgoZiwgcikgPT4gYCR7Zn0oJHtyLnNvdXJjZX0pYCwgXCJcIik7XG4gIHJldHVybiBbYF4ke3JlfSRgLCB1bml0c107XG59XG5cbmZ1bmN0aW9uIG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGlucHV0Lm1hdGNoKHJlZ2V4KTtcblxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IGFsbCA9IHt9O1xuICAgIGxldCBtYXRjaEluZGV4ID0gMTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaGFuZGxlcnMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShoYW5kbGVycywgaSkpIHtcbiAgICAgICAgY29uc3QgaCA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgIGdyb3VwcyA9IGguZ3JvdXBzID8gaC5ncm91cHMgKyAxIDogMTtcbiAgICAgICAgaWYgKCFoLmxpdGVyYWwgJiYgaC50b2tlbikge1xuICAgICAgICAgIGFsbFtoLnRva2VuLnZhbFswXV0gPSBoLmRlc2VyKG1hdGNoZXMuc2xpY2UobWF0Y2hJbmRleCwgbWF0Y2hJbmRleCArIGdyb3VwcykpO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoSW5kZXggKz0gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21hdGNoZXMsIGFsbF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFttYXRjaGVzLCB7fV07XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGNvbnN0IHRvRmllbGQgPSAodG9rZW4pID0+IHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiU1wiOlxuICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZFwiO1xuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICBjYXNlIFwibVwiOlxuICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgIGNhc2UgXCJoXCI6XG4gICAgICBjYXNlIFwiSFwiOlxuICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICBjYXNlIFwiZFwiOlxuICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgIHJldHVybiBcIm9yZGluYWxcIjtcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICByZXR1cm4gXCJtb250aFwiO1xuICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtkYXlcIjtcbiAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtOdW1iZXJcIjtcbiAgICAgIGNhc2UgXCJrXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtZZWFyXCI7XG4gICAgICBjYXNlIFwicVwiOlxuICAgICAgICByZXR1cm4gXCJxdWFydGVyXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgbGV0IHpvbmUgPSBudWxsO1xuICBsZXQgc3BlY2lmaWNPZmZzZXQ7XG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy56KSkge1xuICAgIHpvbmUgPSBJQU5BWm9uZS5jcmVhdGUobWF0Y2hlcy56KTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5aKSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgem9uZSA9IG5ldyBGaXhlZE9mZnNldFpvbmUobWF0Y2hlcy5aKTtcbiAgICB9XG4gICAgc3BlY2lmaWNPZmZzZXQgPSBtYXRjaGVzLlo7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMucSkpIHtcbiAgICBtYXRjaGVzLk0gPSAobWF0Y2hlcy5xIC0gMSkgKiAzICsgMTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5oKSkge1xuICAgIGlmIChtYXRjaGVzLmggPCAxMiAmJiBtYXRjaGVzLmEgPT09IDEpIHtcbiAgICAgIG1hdGNoZXMuaCArPSAxMjtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMuaCA9PT0gMTIgJiYgbWF0Y2hlcy5hID09PSAwKSB7XG4gICAgICBtYXRjaGVzLmggPSAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXRjaGVzLkcgPT09IDAgJiYgbWF0Y2hlcy55KSB7XG4gICAgbWF0Y2hlcy55ID0gLW1hdGNoZXMueTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy51KSkge1xuICAgIG1hdGNoZXMuUyA9IHBhcnNlTWlsbGlzKG1hdGNoZXMudSk7XG4gIH1cblxuICBjb25zdCB2YWxzID0gT2JqZWN0LmtleXMobWF0Y2hlcykucmVkdWNlKChyLCBrKSA9PiB7XG4gICAgY29uc3QgZiA9IHRvRmllbGQoayk7XG4gICAgaWYgKGYpIHtcbiAgICAgIHJbZl0gPSBtYXRjaGVzW2tdO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIFt2YWxzLCB6b25lLCBzcGVjaWZpY09mZnNldF07XG59XG5cbmxldCBkdW1teURhdGVUaW1lQ2FjaGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXREdW1teURhdGVUaW1lKCkge1xuICBpZiAoIWR1bW15RGF0ZVRpbWVDYWNoZSkge1xuICAgIGR1bW15RGF0ZVRpbWVDYWNoZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoMTU1NTU1NTU1NTU1NSk7XG4gIH1cblxuICByZXR1cm4gZHVtbXlEYXRlVGltZUNhY2hlO1xufVxuXG5mdW5jdGlvbiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odG9rZW4sIGxvY2FsZSkge1xuICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbi52YWwpO1xuICBjb25zdCB0b2tlbnMgPSBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKTtcblxuICBpZiAodG9rZW5zID09IG51bGwgfHwgdG9rZW5zLmluY2x1ZGVzKHVuZGVmaW5lZCkpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kTWFjcm9Ub2tlbnModG9rZW5zLCBsb2NhbGUpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4udG9rZW5zLm1hcCgodCkgPT4gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHQsIGxvY2FsZSkpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBjbGFzcyBUb2tlblBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy50b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKTtcbiAgICB0aGlzLnVuaXRzID0gdGhpcy50b2tlbnMubWFwKCh0KSA9PiB1bml0Rm9yVG9rZW4odCwgbG9jYWxlKSk7XG4gICAgdGhpcy5kaXNxdWFsaWZ5aW5nVW5pdCA9IHRoaXMudW5pdHMuZmluZCgodCkgPT4gdC5pbnZhbGlkUmVhc29uKTtcblxuICAgIGlmICghdGhpcy5kaXNxdWFsaWZ5aW5nVW5pdCkge1xuICAgICAgY29uc3QgW3JlZ2V4U3RyaW5nLCBoYW5kbGVyc10gPSBidWlsZFJlZ2V4KHRoaXMudW5pdHMpO1xuICAgICAgdGhpcy5yZWdleCA9IFJlZ0V4cChyZWdleFN0cmluZywgXCJpXCIpO1xuICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgfVxuXG4gIGV4cGxhaW5Gcm9tVG9rZW5zKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnM6IHRoaXMudG9rZW5zLCBpbnZhbGlkUmVhc29uOiB0aGlzLmludmFsaWRSZWFzb24gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3Jhd01hdGNoZXMsIG1hdGNoZXNdID0gbWF0Y2goaW5wdXQsIHRoaXMucmVnZXgsIHRoaXMuaGFuZGxlcnMpLFxuICAgICAgICBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldF0gPSBtYXRjaGVzXG4gICAgICAgICAgPyBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpXG4gICAgICAgICAgOiBbbnVsbCwgbnVsbCwgdW5kZWZpbmVkXTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcImFcIikgJiYgaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJIXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgICBcIkNhbid0IGluY2x1ZGUgbWVyaWRpZW0gd2hlbiBzcGVjaWZ5aW5nIDI0LWhvdXIgZm9ybWF0XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0LFxuICAgICAgICB0b2tlbnM6IHRoaXMudG9rZW5zLFxuICAgICAgICByZWdleDogdGhpcy5yZWdleCxcbiAgICAgICAgcmF3TWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICB6b25lLFxuICAgICAgICBzcGVjaWZpY09mZnNldCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmRpc3F1YWxpZnlpbmdVbml0O1xuICB9XG5cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcXVhbGlmeWluZ1VuaXQgPyB0aGlzLmRpc3F1YWxpZnlpbmdVbml0LmludmFsaWRSZWFzb24gOiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFRva2VuUGFyc2VyKGxvY2FsZSwgZm9ybWF0KTtcbiAgcmV0dXJuIHBhcnNlci5leHBsYWluRnJvbVRva2VucyhpbnB1dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIGNvbnN0IHsgcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbiB9ID0gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KTtcbiAgcmV0dXJuIFtyZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpIHtcbiAgaWYgKCFmb3JtYXRPcHRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBmb3JtYXR0ZXIgPSBGb3JtYXR0ZXIuY3JlYXRlKGxvY2FsZSwgZm9ybWF0T3B0cyk7XG4gIGNvbnN0IGRmID0gZm9ybWF0dGVyLmR0Rm9ybWF0dGVyKGdldER1bW15RGF0ZVRpbWUoKSk7XG4gIGNvbnN0IHBhcnRzID0gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICBjb25zdCByZXNvbHZlZE9wdHMgPSBkZi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgcmV0dXJuIHBhcnRzLm1hcCgocCkgPT4gdG9rZW5Gb3JQYXJ0KHAsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/tokenParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js":
/*!**************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/util.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asNumber: () => (/* binding */ asNumber),\n/* harmony export */   bestBy: () => (/* binding */ bestBy),\n/* harmony export */   daysInMonth: () => (/* binding */ daysInMonth),\n/* harmony export */   daysInYear: () => (/* binding */ daysInYear),\n/* harmony export */   floorMod: () => (/* binding */ floorMod),\n/* harmony export */   formatOffset: () => (/* binding */ formatOffset),\n/* harmony export */   hasLocaleWeekInfo: () => (/* binding */ hasLocaleWeekInfo),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasRelative: () => (/* binding */ hasRelative),\n/* harmony export */   integerBetween: () => (/* binding */ integerBetween),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isLeapYear: () => (/* binding */ isLeapYear),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   maybeArray: () => (/* binding */ maybeArray),\n/* harmony export */   normalizeObject: () => (/* binding */ normalizeObject),\n/* harmony export */   objToLocalTS: () => (/* binding */ objToLocalTS),\n/* harmony export */   padStart: () => (/* binding */ padStart),\n/* harmony export */   parseFloating: () => (/* binding */ parseFloating),\n/* harmony export */   parseInteger: () => (/* binding */ parseInteger),\n/* harmony export */   parseMillis: () => (/* binding */ parseMillis),\n/* harmony export */   parseZoneInfo: () => (/* binding */ parseZoneInfo),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   roundTo: () => (/* binding */ roundTo),\n/* harmony export */   signedOffset: () => (/* binding */ signedOffset),\n/* harmony export */   timeObject: () => (/* binding */ timeObject),\n/* harmony export */   untruncateYear: () => (/* binding */ untruncateYear),\n/* harmony export */   validateWeekSettings: () => (/* binding */ validateWeekSettings),\n/* harmony export */   weeksInWeekYear: () => (/* binding */ weeksInWeekYear)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _conversions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conversions.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/conversions.js\");\n/*\n  This is just a junk drawer, containing anything used across multiple classes.\n  Because Luxon is small(ish), this should stay small and we won't worry about splitting\n  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.\n*/\n\n\n\n\n\n/**\n * @private\n */\n\n// TYPES\n\nfunction isUndefined(o) {\n  return typeof o === \"undefined\";\n}\n\nfunction isNumber(o) {\n  return typeof o === \"number\";\n}\n\nfunction isInteger(o) {\n  return typeof o === \"number\" && o % 1 === 0;\n}\n\nfunction isString(o) {\n  return typeof o === \"string\";\n}\n\nfunction isDate(o) {\n  return Object.prototype.toString.call(o) === \"[object Date]\";\n}\n\n// CAPABILITIES\n\nfunction hasRelative() {\n  try {\n    return typeof Intl !== \"undefined\" && !!Intl.RelativeTimeFormat;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction hasLocaleWeekInfo() {\n  try {\n    return (\n      typeof Intl !== \"undefined\" &&\n      !!Intl.Locale &&\n      (\"weekInfo\" in Intl.Locale.prototype || \"getWeekInfo\" in Intl.Locale.prototype)\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\n// OBJECTS AND ARRAYS\n\nfunction maybeArray(thing) {\n  return Array.isArray(thing) ? thing : [thing];\n}\n\nfunction bestBy(arr, by, compare) {\n  if (arr.length === 0) {\n    return undefined;\n  }\n  return arr.reduce((best, next) => {\n    const pair = [by(next), next];\n    if (!best) {\n      return pair;\n    } else if (compare(best[0], pair[0]) === best[0]) {\n      return best;\n    } else {\n      return pair;\n    }\n  }, null)[1];\n}\n\nfunction pick(obj, keys) {\n  return keys.reduce((a, k) => {\n    a[k] = obj[k];\n    return a;\n  }, {});\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction validateWeekSettings(settings) {\n  if (settings == null) {\n    return null;\n  } else if (typeof settings !== \"object\") {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Week settings must be an object\");\n  } else {\n    if (\n      !integerBetween(settings.firstDay, 1, 7) ||\n      !integerBetween(settings.minimalDays, 1, 7) ||\n      !Array.isArray(settings.weekend) ||\n      settings.weekend.some((v) => !integerBetween(v, 1, 7))\n    ) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(\"Invalid week settings\");\n    }\n    return {\n      firstDay: settings.firstDay,\n      minimalDays: settings.minimalDays,\n      weekend: Array.from(settings.weekend),\n    };\n  }\n}\n\n// NUMBERS AND STRINGS\n\nfunction integerBetween(thing, bottom, top) {\n  return isInteger(thing) && thing >= bottom && thing <= top;\n}\n\n// x % n but takes the sign of n instead of x\nfunction floorMod(x, n) {\n  return x - n * Math.floor(x / n);\n}\n\nfunction padStart(input, n = 2) {\n  const isNeg = input < 0;\n  let padded;\n  if (isNeg) {\n    padded = \"-\" + (\"\" + -input).padStart(n, \"0\");\n  } else {\n    padded = (\"\" + input).padStart(n, \"0\");\n  }\n  return padded;\n}\n\nfunction parseInteger(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseInt(string, 10);\n  }\n}\n\nfunction parseFloating(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseFloat(string);\n  }\n}\n\nfunction parseMillis(fraction) {\n  // Return undefined (instead of 0) in these cases, where fraction is not set\n  if (isUndefined(fraction) || fraction === null || fraction === \"\") {\n    return undefined;\n  } else {\n    const f = parseFloat(\"0.\" + fraction) * 1000;\n    return Math.floor(f);\n  }\n}\n\nfunction roundTo(number, digits, rounding = \"round\") {\n  const factor = 10 ** digits;\n  switch (rounding) {\n    case \"expand\":\n      return number > 0\n        ? Math.ceil(number * factor) / factor\n        : Math.floor(number * factor) / factor;\n    case \"trunc\":\n      return Math.trunc(number * factor) / factor;\n    case \"round\":\n      return Math.round(number * factor) / factor;\n    case \"floor\":\n      return Math.floor(number * factor) / factor;\n    case \"ceil\":\n      return Math.ceil(number * factor) / factor;\n    default:\n      throw new RangeError(`Value rounding ${rounding} is out of range`);\n  }\n}\n\n// DATE BASICS\n\nfunction isLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\nfunction daysInYear(year) {\n  return isLeapYear(year) ? 366 : 365;\n}\n\nfunction daysInMonth(year, month) {\n  const modMonth = floorMod(month - 1, 12) + 1,\n    modYear = year + (month - modMonth) / 12;\n\n  if (modMonth === 2) {\n    return isLeapYear(modYear) ? 29 : 28;\n  } else {\n    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];\n  }\n}\n\n// convert a calendar object to a local timestamp (epoch, but with the offset baked in)\nfunction objToLocalTS(obj) {\n  let d = Date.UTC(\n    obj.year,\n    obj.month - 1,\n    obj.day,\n    obj.hour,\n    obj.minute,\n    obj.second,\n    obj.millisecond\n  );\n\n  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that\n  if (obj.year < 100 && obj.year >= 0) {\n    d = new Date(d);\n    // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not\n    // so if obj.year is in 99, but obj.day makes it roll over into year 100,\n    // the calculations done by Date.UTC are using year 2000 - which is incorrect\n    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);\n  }\n  return +d;\n}\n\n// adapted from moment.js: https://github.com/moment/moment/blob/000ac1800e620f770f4eb31b5ae908f6167b0ab2/src/lib/units/week-calendar-utils.js\nfunction firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {\n  const fwdlw = (0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.isoWeekdayToLocal)((0,_conversions_js__WEBPACK_IMPORTED_MODULE_2__.dayOfWeek)(year, 1, minDaysInFirstWeek), startOfWeek);\n  return -fwdlw + minDaysInFirstWeek - 1;\n}\n\nfunction weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {\n  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);\n  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);\n  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;\n}\n\nfunction untruncateYear(year) {\n  if (year > 99) {\n    return year;\n  } else return year > _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].twoDigitCutoffYear ? 1900 + year : 2000 + year;\n}\n\n// PARSING\n\nfunction parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {\n  const date = new Date(ts),\n    intlOpts = {\n      hourCycle: \"h23\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    };\n\n  if (timeZone) {\n    intlOpts.timeZone = timeZone;\n  }\n\n  const modified = { timeZoneName: offsetFormat, ...intlOpts };\n\n  const parsed = new Intl.DateTimeFormat(locale, modified)\n    .formatToParts(date)\n    .find((m) => m.type.toLowerCase() === \"timezonename\");\n  return parsed ? parsed.value : null;\n}\n\n// signedOffset('-5', '30') -> -330\nfunction signedOffset(offHourStr, offMinuteStr) {\n  let offHour = parseInt(offHourStr, 10);\n\n  // don't || this because we want to preserve -0\n  if (Number.isNaN(offHour)) {\n    offHour = 0;\n  }\n\n  const offMin = parseInt(offMinuteStr, 10) || 0,\n    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;\n  return offHour * 60 + offMinSigned;\n}\n\n// COERCION\n\nfunction asNumber(value) {\n  const numericValue = Number(value);\n  if (typeof value === \"boolean\" || value === \"\" || !Number.isFinite(numericValue))\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(`Invalid unit value ${value}`);\n  return numericValue;\n}\n\nfunction normalizeObject(obj, normalizer) {\n  const normalized = {};\n  for (const u in obj) {\n    if (hasOwnProperty(obj, u)) {\n      const v = obj[u];\n      if (v === undefined || v === null) continue;\n      normalized[normalizer(u)] = asNumber(v);\n    }\n  }\n  return normalized;\n}\n\n/**\n * Returns the offset's value as a string\n * @param {number} ts - Epoch milliseconds for which to get the offset\n * @param {string} format - What style of offset to return.\n *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n * @return {string}\n */\nfunction formatOffset(offset, format) {\n  const hours = Math.trunc(Math.abs(offset / 60)),\n    minutes = Math.trunc(Math.abs(offset % 60)),\n    sign = offset >= 0 ? \"+\" : \"-\";\n\n  switch (format) {\n    case \"short\":\n      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;\n    case \"narrow\":\n      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : \"\"}`;\n    case \"techie\":\n      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;\n    default:\n      throw new RangeError(`Value format ${format} is out of range for property format`);\n  }\n}\n\nfunction timeObject(obj) {\n  return pick(obj, [\"hour\", \"minute\", \"second\", \"millisecond\"]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ2Q7QUFDMEI7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsNERBQW9CO0FBQ2xDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixrRUFBaUIsQ0FBQywwREFBUztBQUMzQztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSSxtQkFBbUIsb0RBQVE7QUFDL0I7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0EsY0FBYyw0REFBb0IsdUJBQXVCLE1BQU07QUFDL0Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixLQUFLLEVBQUUsbUJBQW1CLEdBQUcscUJBQXFCO0FBQ2xFO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxNQUFNLEVBQUUsa0JBQWtCLFFBQVEsT0FBTztBQUNoRTtBQUNBLGdCQUFnQixLQUFLLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCO0FBQ2pFO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTs7QUFFTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG5cbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgZGF5T2ZXZWVrLCBpc29XZWVrZGF5VG9Mb2NhbCB9IGZyb20gXCIuL2NvbnZlcnNpb25zLmpzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBUWVBFU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIiAmJiBvICUgMSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG59XG5cbi8vIENBUEFCSUxJVElFU1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVsYXRpdmUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiICYmICEhSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0xvY2FsZVdlZWtJbmZvKCkge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgISFJbnRsLkxvY2FsZSAmJlxuICAgICAgKFwid2Vla0luZm9cIiBpbiBJbnRsLkxvY2FsZS5wcm90b3R5cGUgfHwgXCJnZXRXZWVrSW5mb1wiIGluIEludGwuTG9jYWxlLnByb3RvdHlwZSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBcnJheSh0aGluZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyB0aGluZyA6IFt0aGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXN0QnkoYXJyLCBieSwgY29tcGFyZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGJlc3QsIG5leHQpID0+IHtcbiAgICBjb25zdCBwYWlyID0gW2J5KG5leHQpLCBuZXh0XTtcbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyZShiZXN0WzBdLCBwYWlyWzBdKSA9PT0gYmVzdFswXSkge1xuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH1cbiAgfSwgbnVsbClbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGEsIGspID0+IHtcbiAgICBhW2tdID0gb2JqW2tdO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVXZWVrU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJXZWVrIHNldHRpbmdzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgICFpbnRlZ2VyQmV0d2VlbihzZXR0aW5ncy5maXJzdERheSwgMSwgNykgfHxcbiAgICAgICFpbnRlZ2VyQmV0d2VlbihzZXR0aW5ncy5taW5pbWFsRGF5cywgMSwgNykgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHNldHRpbmdzLndlZWtlbmQpIHx8XG4gICAgICBzZXR0aW5ncy53ZWVrZW5kLnNvbWUoKHYpID0+ICFpbnRlZ2VyQmV0d2Vlbih2LCAxLCA3KSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIkludmFsaWQgd2VlayBzZXR0aW5nc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0RGF5OiBzZXR0aW5ncy5maXJzdERheSxcbiAgICAgIG1pbmltYWxEYXlzOiBzZXR0aW5ncy5taW5pbWFsRGF5cyxcbiAgICAgIHdlZWtlbmQ6IEFycmF5LmZyb20oc2V0dGluZ3Mud2Vla2VuZCksXG4gICAgfTtcbiAgfVxufVxuXG4vLyBOVU1CRVJTIEFORCBTVFJJTkdTXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn1cblxuLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5leHBvcnQgZnVuY3Rpb24gZmxvb3JNb2QoeCwgbikge1xuICByZXR1cm4geCAtIG4gKiBNYXRoLmZsb29yKHggLyBuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KGlucHV0LCBuID0gMikge1xuICBjb25zdCBpc05lZyA9IGlucHV0IDwgMDtcbiAgbGV0IHBhZGRlZDtcbiAgaWYgKGlzTmVnKSB7XG4gICAgcGFkZGVkID0gXCItXCIgKyAoXCJcIiArIC1pbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhZGRlZCA9IChcIlwiICsgaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gcGFkZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgcm91bmRpbmcgPSBcInJvdW5kXCIpIHtcbiAgY29uc3QgZmFjdG9yID0gMTAgKiogZGlnaXRzO1xuICBzd2l0Y2ggKHJvdW5kaW5nKSB7XG4gICAgY2FzZSBcImV4cGFuZFwiOlxuICAgICAgcmV0dXJuIG51bWJlciA+IDBcbiAgICAgICAgPyBNYXRoLmNlaWwobnVtYmVyICogZmFjdG9yKSAvIGZhY3RvclxuICAgICAgICA6IE1hdGguZmxvb3IobnVtYmVyICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBjYXNlIFwidHJ1bmNcIjpcbiAgICAgIHJldHVybiBNYXRoLnRydW5jKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgY2FzZSBcInJvdW5kXCI6XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNhc2UgXCJmbG9vclwiOlxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBjYXNlIFwiY2VpbFwiOlxuICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgcm91bmRpbmcgJHtyb3VuZGluZ30gaXMgb3V0IG9mIHJhbmdlYCk7XG4gIH1cbn1cblxuLy8gREFURSBCQVNJQ1NcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICBjb25zdCBtb2RNb250aCA9IGZsb29yTW9kKG1vbnRoIC0gMSwgMTIpICsgMSxcbiAgICBtb2RZZWFyID0geWVhciArIChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuXG4gIGlmIChtb2RNb250aCA9PT0gMikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKG1vZFllYXIpID8gMjkgOiAyODtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzMxLCBudWxsLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9kTW9udGggLSAxXTtcbiAgfVxufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgbG9jYWwgdGltZXN0YW1wIChlcG9jaCwgYnV0IHdpdGggdGhlIG9mZnNldCBiYWtlZCBpbilcbmV4cG9ydCBmdW5jdGlvbiBvYmpUb0xvY2FsVFMob2JqKSB7XG4gIGxldCBkID0gRGF0ZS5VVEMoXG4gICAgb2JqLnllYXIsXG4gICAgb2JqLm1vbnRoIC0gMSxcbiAgICBvYmouZGF5LFxuICAgIG9iai5ob3VyLFxuICAgIG9iai5taW51dGUsXG4gICAgb2JqLnNlY29uZCxcbiAgICBvYmoubWlsbGlzZWNvbmRcbiAgKTtcblxuICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMsIHllYXJzIGJldHdlZW4gMCBhbmQgOTkgYXJlIGludGVycHJldGVkIGFzIDE5WFg7IHJldmVydCB0aGF0XG4gIGlmIChvYmoueWVhciA8IDEwMCAmJiBvYmoueWVhciA+PSAwKSB7XG4gICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIC8vIHNldCB0aGUgbW9udGggYW5kIGRheSBhZ2FpbiwgdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB5ZWFyIDIwMDAgaXMgYSBsZWFwIHllYXIsIGJ1dCB5ZWFyIDEwMCBpcyBub3RcbiAgICAvLyBzbyBpZiBvYmoueWVhciBpcyBpbiA5OSwgYnV0IG9iai5kYXkgbWFrZXMgaXQgcm9sbCBvdmVyIGludG8geWVhciAxMDAsXG4gICAgLy8gdGhlIGNhbGN1bGF0aW9ucyBkb25lIGJ5IERhdGUuVVRDIGFyZSB1c2luZyB5ZWFyIDIwMDAgLSB3aGljaCBpcyBpbmNvcnJlY3RcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKG9iai55ZWFyLCBvYmoubW9udGggLSAxLCBvYmouZGF5KTtcbiAgfVxuICByZXR1cm4gK2Q7XG59XG5cbi8vIGFkYXB0ZWQgZnJvbSBtb21lbnQuanM6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvMDAwYWMxODAwZTYyMGY3NzBmNGViMzFiNWFlOTA4ZjYxNjdiMGFiMi9zcmMvbGliL3VuaXRzL3dlZWstY2FsZW5kYXItdXRpbHMuanNcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKSB7XG4gIGNvbnN0IGZ3ZGx3ID0gaXNvV2Vla2RheVRvTG9jYWwoZGF5T2ZXZWVrKHllYXIsIDEsIG1pbkRheXNJbkZpcnN0V2VlayksIHN0YXJ0T2ZXZWVrKTtcbiAgcmV0dXJuIC1md2RsdyArIG1pbkRheXNJbkZpcnN0V2VlayAtIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHdlZWtZZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgY29uc3Qgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQod2Vla1llYXIgKyAxLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgcmV0dXJuIChkYXlzSW5ZZWFyKHdlZWtZZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhcikge1xuICBpZiAoeWVhciA+IDk5KSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSByZXR1cm4geWVhciA+IFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG59XG5cbi8vIFBBUlNJTkdcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWm9uZUluZm8odHMsIG9mZnNldEZvcm1hdCwgbG9jYWxlLCB0aW1lWm9uZSA9IG51bGwpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICBpbnRsT3B0cyA9IHtcbiAgICAgIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICBjb25zdCBtb2RpZmllZCA9IHsgdGltZVpvbmVOYW1lOiBvZmZzZXRGb3JtYXQsIC4uLmludGxPcHRzIH07XG5cbiAgY29uc3QgcGFyc2VkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZClcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIik7XG4gIHJldHVybiBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBudWxsO1xufVxuXG4vLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpIHtcbiAgbGV0IG9mZkhvdXIgPSBwYXJzZUludChvZmZIb3VyU3RyLCAxMCk7XG5cbiAgLy8gZG9uJ3QgfHwgdGhpcyBiZWNhdXNlIHdlIHdhbnQgdG8gcHJlc2VydmUgLTBcbiAgaWYgKE51bWJlci5pc05hTihvZmZIb3VyKSkge1xuICAgIG9mZkhvdXIgPSAwO1xuICB9XG5cbiAgY29uc3Qgb2ZmTWluID0gcGFyc2VJbnQob2ZmTWludXRlU3RyLCAxMCkgfHwgMCxcbiAgICBvZmZNaW5TaWduZWQgPSBvZmZIb3VyIDwgMCB8fCBPYmplY3QuaXMob2ZmSG91ciwgLTApID8gLW9mZk1pbiA6IG9mZk1pbjtcbiAgcmV0dXJuIG9mZkhvdXIgKiA2MCArIG9mZk1pblNpZ25lZDtcbn1cblxuLy8gQ09FUkNJT05cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIGNvbnN0IG51bWVyaWNWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBcIlwiIHx8ICFOdW1iZXIuaXNGaW5pdGUobnVtZXJpY1ZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYEludmFsaWQgdW5pdCB2YWx1ZSAke3ZhbHVlfWApO1xuICByZXR1cm4gbnVtZXJpY1ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplcikge1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGZvciAoY29uc3QgdSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCB1KSkge1xuICAgICAgY29uc3QgdiA9IG9ialt1XTtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBub3JtYWxpemVkW25vcm1hbGl6ZXIodSldID0gYXNOdW1iZXIodik7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob2Zmc2V0LCBmb3JtYXQpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgbWludXRlcyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0ICUgNjApKSxcbiAgICBzaWduID0gb2Zmc2V0ID49IDAgPyBcIitcIiA6IFwiLVwiO1xuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7aG91cnN9JHttaW51dGVzID4gMCA/IGA6JHttaW51dGVzfWAgOiBcIlwifWA7XG4gICAgY2FzZSBcInRlY2hpZVwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgZm9ybWF0ICR7Zm9ybWF0fSBpcyBvdXQgb2YgcmFuZ2UgZm9yIHByb3BlcnR5IGZvcm1hdGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/zoneUtil.js":
/*!******************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/impl/zoneUtil.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeZone: () => (/* binding */ normalizeZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zones/IANAZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/invalidZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../zones/systemZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/systemZone.js\");\n/**\n * @private\n */\n\n\n\n\n\n\n\n\n\nfunction normalizeZone(input, defaultZone) {\n  let offset;\n  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(input) || input === null) {\n    return defaultZone;\n  } else if (input instanceof _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    return input;\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isString)(input)) {\n    const lowered = input.toLowerCase();\n    if (lowered === \"default\") return defaultZone;\n    else if (lowered === \"local\" || lowered === \"system\") return _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instance;\n    else if (lowered === \"utc\" || lowered === \"gmt\") return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utcInstance;\n    else return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parseSpecifier(lowered) || _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create(input);\n  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(input)) {\n    return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instance(input);\n  } else if (typeof input === \"object\" && \"offset\" in input && typeof input.offset === \"function\") {\n    // This is dumb, but the instanceof check above doesn't seem to really work\n    // so we're duck checking it\n    return input;\n  } else {\n    return new _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](input);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3pvbmVVdGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRThCO0FBQ2M7QUFDYztBQUNSOztBQUVVO0FBQ1o7O0FBRXpDO0FBQ1A7QUFDQSxNQUFNLHFEQUFXO0FBQ2pCO0FBQ0EsSUFBSSwwQkFBMEIsZ0RBQUk7QUFDbEM7QUFDQSxJQUFJLFNBQVMsa0RBQVE7QUFDckI7QUFDQTtBQUNBLGlFQUFpRSw0REFBVTtBQUMzRSw0REFBNEQsaUVBQWU7QUFDM0UsZ0JBQWdCLGlFQUFlLDRCQUE0QiwwREFBUTtBQUNuRSxJQUFJLFNBQVMsa0RBQVE7QUFDckIsV0FBVyxpRUFBZTtBQUMxQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGVBQWUsNkRBQVc7QUFDMUI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3pvbmVVdGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSW52YWxpZFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ludmFsaWRab25lLmpzXCI7XG5cbmltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc1N0cmluZywgaXNOdW1iZXIgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWm9uZShpbnB1dCwgZGVmYXVsdFpvbmUpIHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSB8fCBpbnB1dCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFpvbmUpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcoaW5wdXQpKSB7XG4gICAgY29uc3QgbG93ZXJlZCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyZWQgPT09IFwiZGVmYXVsdFwiKSByZXR1cm4gZGVmYXVsdFpvbmU7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJsb2NhbFwiIHx8IGxvd2VyZWQgPT09IFwic3lzdGVtXCIpIHJldHVybiBTeXN0ZW1ab25lLmluc3RhbmNlO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwidXRjXCIgfHwgbG93ZXJlZCA9PT0gXCJnbXRcIikgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICBlbHNlIHJldHVybiBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIobG93ZXJlZCkgfHwgSUFOQVpvbmUuY3JlYXRlKGlucHV0KTtcbiAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGlucHV0KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgXCJvZmZzZXRcIiBpbiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQub2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBUaGlzIGlzIGR1bWIsIGJ1dCB0aGUgaW5zdGFuY2VvZiBjaGVjayBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gcmVhbGx5IHdvcmtcbiAgICAvLyBzbyB3ZSdyZSBkdWNrIGNoZWNraW5nIGl0XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSW52YWxpZFpvbmUoaW5wdXQpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/zoneUtil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/info.js":
/*!*********************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/info.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Info)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n\n\n\n\n\n\n\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nclass Info {\n  /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */\n  static hasDST(zone = _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone) {\n    const proto = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].now().setZone(zone).set({ month: 12 });\n\n    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;\n  }\n\n  /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */\n  static isValidIANAZone(zone) {\n    return _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isValidZone(zone);\n  }\n\n  /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone#isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */\n  static normalizeZone(input) {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(input, _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaultZone);\n  }\n\n  /**\n   * Get the weekday on which the week starts according to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday\n   */\n  static getStartOfWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getStartOfWeek();\n  }\n\n  /**\n   * Get the minimum number of days necessary in a week before it is considered part of the next year according\n   * to the given locale.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number}\n   */\n  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getMinDaysInFirstWeek();\n  }\n\n  /**\n   * Get the weekdays, which are considered the weekend according to the given locale\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday\n   */\n  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {\n    // copy the array, because we cache it internally\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale)).getWeekendDays().slice();\n  }\n\n  /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'\n   * @return {Array}\n   */\n  static months(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length);\n  }\n\n  /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link Info#months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {Array}\n   */\n  static monthsFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, outputCalendar)).months(length, true);\n  }\n\n  /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''\n   * @return {Array}\n   */\n  static weekdays(length = \"long\", { locale = null, numberingSystem = null, locObj = null } = {}) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length);\n  }\n\n  /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link Info#weekdays}\n   * @param {string} [length='long'] - the length of the month representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.locObj=null] - an existing locale object to use\n   * @return {Array}\n   */\n  static weekdaysFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, locObj = null } = {}\n  ) {\n    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, numberingSystem, null)).weekdays(length, true);\n  }\n\n  /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]\n   * @return {Array}\n   */\n  static meridiems({ locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale).meridiems();\n  }\n\n  /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\n   * @return {Array}\n   */\n  static eras(length = \"short\", { locale = null } = {}) {\n    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create(locale, null, \"gregory\").eras(length);\n  }\n\n  /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `relative`: whether this environment supports relative time formatting\n   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale\n   * @example Info.features() //=> { relative: false, localeWeek: true }\n   * @return {Object}\n   */\n  static features() {\n    return { relative: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasRelative)(), localeWeek: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasLocaleWeekInfo)() };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBcUM7QUFDQTtBQUNDO0FBQ0s7QUFDUTs7QUFFYTs7QUFFaEU7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWM7QUFDZDtBQUNBLHVCQUF1QixvREFBUTtBQUMvQixrQkFBa0Isb0RBQVEsMkJBQTJCLFdBQVc7O0FBRWhFLDZEQUE2RCxVQUFVO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLDBEQUFRO0FBQ25COztBQUVBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakMsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLGdFQUFhLFFBQVEsb0RBQVE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDBCQUEwQiwrQkFBK0IsSUFBSTtBQUM3RCxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0EscUNBQXFDLCtCQUErQixJQUFJO0FBQ3hFLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsOEJBQThCLCtCQUErQixJQUFJO0FBQ2pFO0FBQ0Esc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQsdUNBQXVDLGNBQWM7QUFDckQsb0NBQW9DLDJCQUEyQjtBQUMvRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRkFBbUY7QUFDekY7QUFDQSxzQkFBc0IsdURBQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUZBQW1GO0FBQ3pGO0FBQ0Esc0JBQXNCLHVEQUFNO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQsdUNBQXVDLGNBQWM7QUFDckQsY0FBYztBQUNkO0FBQ0EscUNBQXFDLHVEQUF1RCxJQUFJO0FBQ2hHLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUF1RDtBQUM3RDtBQUNBLHNCQUFzQix1REFBTTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLCtCQUErQixjQUFjO0FBQzdDLGNBQWM7QUFDZDtBQUNBLHFCQUFxQixnQkFBZ0IsSUFBSTtBQUN6QyxXQUFXLHVEQUFNO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQsY0FBYztBQUNkO0FBQ0Esa0NBQWtDLGdCQUFnQixJQUFJO0FBQ3RELFdBQVcsdURBQU07QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsYUFBYSxVQUFVLDBEQUFXLGdCQUFnQixnRUFBaUI7QUFDbkU7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmltcG9ydCB7IGhhc0xvY2FsZVdlZWtJbmZvLCBoYXNSZWxhdGl2ZSB9IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuXG4vKipcbiAqIFRoZSBJbmZvIGNsYXNzIGNvbnRhaW5zIHN0YXRpYyBtZXRob2RzIGZvciByZXRyaWV2aW5nIGdlbmVyYWwgdGltZSBhbmQgZGF0ZSByZWxhdGVkIGRhdGEuIEZvciBleGFtcGxlLCBpdCBoYXMgbWV0aG9kcyBmb3IgZmluZGluZyBvdXQgaWYgYSB0aW1lIHpvbmUgaGFzIGEgRFNULCBmb3IgbGlzdGluZyB0aGUgbW9udGhzIGluIGFueSBzdXBwb3J0ZWQgbG9jYWxlLCBhbmQgZm9yIGRpc2NvdmVyaW5nIHdoaWNoIG9mIEx1eG9uIGZlYXR1cmVzIGFyZSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZm8ge1xuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB6b25lIGNvbnRhaW5zIGEgRFNULlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIFpvbmUgdG8gY2hlY2suIERlZmF1bHRzIHRvIHRoZSBlbnZpcm9ubWVudCdzIGxvY2FsIHpvbmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaGFzRFNUKHpvbmUgPSBTZXR0aW5ncy5kZWZhdWx0Wm9uZSkge1xuICAgIGNvbnN0IHByb3RvID0gRGF0ZVRpbWUubm93KCkuc2V0Wm9uZSh6b25lKS5zZXQoeyBtb250aDogMTIgfSk7XG5cbiAgICByZXR1cm4gIXpvbmUuaXNVbml2ZXJzYWwgJiYgcHJvdG8ub2Zmc2V0ICE9PSBwcm90by5zZXQoeyBtb250aDogNiB9KS5vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB6b25lIGlzIGEgdmFsaWQgSUFOQSBzcGVjaWZpZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gWm9uZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRJQU5BWm9uZSh6b25lKSB7XG4gICAgcmV0dXJuIElBTkFab25lLmlzVmFsaWRab25lKHpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBpbnB1dCBpbnRvIGEge0BsaW5rIFpvbmV9IGluc3RhbmNlLlxuICAgKlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYWxyZWFkeSBhIFpvbmUgaW5zdGFuY2UsIGl0IGlzIHJldHVybmVkIHVuY2hhbmdlZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSB2YWxpZCB0aW1lIHpvbmUgbmFtZSwgYSBab25lIGluc3RhbmNlXG4gICAqICAgd2l0aCB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyB0aGF0IGRvZXNuJ3QgcmVmZXIgdG8gYSBrbm93biB0aW1lIHpvbmUsIGEgWm9uZVxuICAgKiAgIGluc3RhbmNlIHdpdGgge0BsaW5rIFpvbmUjaXNWYWxpZH0gPT0gZmFsc2UgaXMgcmV0dXJuZWQuXG4gICAqICogSWYgYGlucHV0IGlzIGEgbnVtYmVyLCBhIFpvbmUgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGZpeGVkIG9mZnNldFxuICAgKiAgIGluIG1pbnV0ZXMgaXMgcmV0dXJuZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIHRoZSBkZWZhdWx0IHpvbmUgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV8bnVtYmVyfSBbaW5wdXRdIC0gdGhlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtab25lfVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZVpvbmUoaW5wdXQpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplWm9uZShpbnB1dCwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla2RheSBvbiB3aGljaCB0aGUgd2VlayBzdGFydHMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBsb2NhbGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybnMge251bWJlcn0gdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCAxIGZvciBNb25kYXkgdGhyb3VnaCA3IGZvciBTdW5kYXlcbiAgICovXG4gIHN0YXRpYyBnZXRTdGFydE9mV2Vlayh7IGxvY2FsZSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUpKS5nZXRTdGFydE9mV2VlaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSBudW1iZXIgb2YgZGF5cyBuZWNlc3NhcnkgaW4gYSB3ZWVrIGJlZm9yZSBpdCBpcyBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIG5leHQgeWVhciBhY2NvcmRpbmdcbiAgICogdG8gdGhlIGdpdmVuIGxvY2FsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldE1pbmltdW1EYXlzSW5GaXJzdFdlZWsoeyBsb2NhbGUgPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlKSkuZ2V0TWluRGF5c0luRmlyc3RXZWVrKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrZGF5cywgd2hpY2ggYXJlIGNvbnNpZGVyZWQgdGhlIHdlZWtlbmQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBsb2NhbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IGFuIGFycmF5IG9mIHdlZWtkYXlzLCAxIGZvciBNb25kYXkgdGhyb3VnaCA3IGZvciBTdW5kYXlcbiAgICovXG4gIHN0YXRpYyBnZXRXZWVrZW5kV2Vla2RheXMoeyBsb2NhbGUgPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fSkge1xuICAgIC8vIGNvcHkgdGhlIGFycmF5LCBiZWNhdXNlIHdlIGNhY2hlIGl0IGludGVybmFsbHlcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSkpLmdldFdlZWtlbmREYXlzKCkuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSBtb250aCBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfZoSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiacq7IEknXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRocyhcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCBtb250aCBuYW1lcy5cbiAgICogRm9ybWF0IG1vbnRocyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIG1vbnRocyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gdGhlIGRheSBvZiB0aGUgbW9udGguIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI21vbnRoc31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIHdlZWsgbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygpWzBdIC8vPT4gJ01vbmRheSdcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnKVswXSAvLz0+ICdNb24nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSlbMF0gLy89PiAnbHVuLidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfYp9mE2KfYq9mG2YrZhidcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXMobGVuZ3RoID0gXCJsb25nXCIsIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI3dlZWtkYXlzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5c0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICfhgJThgLbhgJThgIDhgLonLCAn4YCK4YCU4YCxJyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmlkaWVtcyh7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZXJhcywgc3VjaCBhcyBbJ0JDJywgJ0FEJ10uIFRoZSBsb2NhbGUgY2FuIGJlIHNwZWNpZmllZCwgYnV0IHRoZSBjYWxlbmRhciBzeXN0ZW0gaXMgYWx3YXlzIEdyZWdvcmlhbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J3Nob3J0J10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBlcmEgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJzaG9ydFwiIG9yIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCkgLy89PiBbICdCQycsICdBRCcgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnKSAvLz0+IFsgJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJywgeyBsb2NhbGU6ICdmcicgfSkgLy89PiBbICdhdmFudCBKw6lzdXMtQ2hyaXN0JywgJ2FwcsOocyBKw6lzdXMtQ2hyaXN0JyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIGVyYXMobGVuZ3RoID0gXCJzaG9ydFwiLCB7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudWxsLCBcImdyZWdvcnlcIikuZXJhcyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nIHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS4gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAqIEtleXM6XG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiAqIGBsb2NhbGVXZWVrYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIGRpZmZlcmVudCB3ZWVrZGF5cyBmb3IgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgICogQGV4YW1wbGUgSW5mby5mZWF0dXJlcygpIC8vPT4geyByZWxhdGl2ZTogZmFsc2UsIGxvY2FsZVdlZWs6IHRydWUgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmU6IGhhc1JlbGF0aXZlKCksIGxvY2FsZVdlZWs6IGhhc0xvY2FsZVdlZWtJbmZvKCkgfTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/interval.js":
/*!*************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/interval.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interval)\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\");\n/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/invalid.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/invalid.js\");\n/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/formatter.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formatter.js\");\n/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/formats.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/formats.js\");\n\n\n\n\n\n\n\n\nconst INVALID = \"Invalid Interval\";\n\n// checks if the start is equal to or before the end\nfunction validateStartEnd(start, end) {\n  if (!start || !start.isValid) {\n    return Interval.invalid(\"missing or invalid start\");\n  } else if (!end || !end.isValid) {\n    return Interval.invalid(\"missing or invalid end\");\n  } else if (end < start) {\n    return Interval.invalid(\n      \"end before start\",\n      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`\n    );\n  } else {\n    return null;\n  }\n}\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.\n * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.\n * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}\n * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.\n */\nclass Interval {\n  /**\n   * @private\n   */\n  constructor(config) {\n    /**\n     * @access private\n     */\n    this.s = config.start;\n    /**\n     * @access private\n     */\n    this.e = config.end;\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.isLuxonInterval = true;\n  }\n\n  /**\n   * Create an invalid Interval.\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Interval}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\n    }\n\n    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](reason, explanation);\n\n    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].throwOnInvalid) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidIntervalError(invalid);\n    } else {\n      return new Interval({ invalid });\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n   * @param {DateTime|Date|Object} start\n   * @param {DateTime|Date|Object} end\n   * @return {Interval}\n   */\n  static fromDateTimes(start, end) {\n    const builtStart = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start),\n      builtEnd = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n\n    const validateError = validateStartEnd(builtStart, builtEnd);\n\n    if (validateError == null) {\n      return new Interval({\n        start: builtStart,\n        end: builtEnd,\n      });\n    } else {\n      return validateError;\n    }\n  }\n\n  /**\n   * Create an Interval from a start DateTime and a Duration to extend to.\n   * @param {DateTime|Date|Object} start\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static after(start, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start);\n    return Interval.fromDateTimes(dt, dt.plus(dur));\n  }\n\n  /**\n   * Create an Interval from an end DateTime and a Duration to extend backwards to.\n   * @param {DateTime|Date|Object} end\n   * @param {Duration|Object|number} duration - the length of the Interval.\n   * @return {Interval}\n   */\n  static before(end, duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration),\n      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);\n    return Interval.fromDateTimes(dt.minus(dur), dt);\n  }\n\n  /**\n   * Create an Interval from an ISO 8601 string.\n   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n   * @param {string} text - the ISO string to parse\n   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {Interval}\n   */\n  static fromISO(text, opts) {\n    const [s, e] = (text || \"\").split(\"/\", 2);\n    if (s && e) {\n      let start, startIsValid;\n      try {\n        start = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(s, opts);\n        startIsValid = start.isValid;\n      } catch (e) {\n        startIsValid = false;\n      }\n\n      let end, endIsValid;\n      try {\n        end = _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromISO(e, opts);\n        endIsValid = end.isValid;\n      } catch (e) {\n        endIsValid = false;\n      }\n\n      if (startIsValid && endIsValid) {\n        return Interval.fromDateTimes(start, end);\n      }\n\n      if (startIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(e, opts);\n        if (dur.isValid) {\n          return Interval.after(start, dur);\n        }\n      } else if (endIsValid) {\n        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromISO(s, opts);\n        if (dur.isValid) {\n          return Interval.before(end, dur);\n        }\n      }\n    }\n    return Interval.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n  }\n\n  /**\n   * Check if an object is an Interval. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isInterval(o) {\n    return (o && o.isLuxonInterval) || false;\n  }\n\n  /**\n   * Returns the start of the Interval\n   * @type {DateTime}\n   */\n  get start() {\n    return this.isValid ? this.s : null;\n  }\n\n  /**\n   * Returns the end of the Interval. This is the first instant which is not part of the interval\n   * (Interval is half-open).\n   * @type {DateTime}\n   */\n  get end() {\n    return this.isValid ? this.e : null;\n  }\n\n  /**\n   * Returns the last DateTime included in the interval (since end is not part of the interval)\n   * @type {DateTime}\n   */\n  get lastDateTime() {\n    return this.isValid ? (this.e ? this.e.minus(1) : null) : null;\n  }\n\n  /**\n   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalidReason === null;\n  }\n\n  /**\n   * Returns an error code if this Interval is invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Returns the length of the Interval in the specified unit.\n   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\n   * @return {number}\n   */\n  length(unit = \"milliseconds\") {\n    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;\n  }\n\n  /**\n   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n   * @param {string} [unit='milliseconds'] - the unit of time to count.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime\n   * @return {number}\n   */\n  count(unit = \"milliseconds\", opts) {\n    if (!this.isValid) return NaN;\n    const start = this.start.startOf(unit, opts);\n    let end;\n    if (opts?.useLocaleWeeks) {\n      end = this.end.reconfigure({ locale: start.locale });\n    } else {\n      end = this.end;\n    }\n    end = end.startOf(unit, opts);\n    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());\n  }\n\n  /**\n   * Returns whether this Interval's start and end are both in the same unit of time\n   * @param {string} unit - the unit of time to check sameness on\n   * @return {boolean}\n   */\n  hasSame(unit) {\n    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end DateTimes.\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.s.valueOf() === this.e.valueOf();\n  }\n\n  /**\n   * Return whether this Interval's start is after the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isAfter(dateTime) {\n    if (!this.isValid) return false;\n    return this.s > dateTime;\n  }\n\n  /**\n   * Return whether this Interval's end is before the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  isBefore(dateTime) {\n    if (!this.isValid) return false;\n    return this.e <= dateTime;\n  }\n\n  /**\n   * Return whether this Interval contains the specified DateTime.\n   * @param {DateTime} dateTime\n   * @return {boolean}\n   */\n  contains(dateTime) {\n    if (!this.isValid) return false;\n    return this.s <= dateTime && this.e > dateTime;\n  }\n\n  /**\n   * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n   * @param {Object} values - the values to set\n   * @param {DateTime} values.start - the starting DateTime\n   * @param {DateTime} values.end - the ending DateTime\n   * @return {Interval}\n   */\n  set({ start, end } = {}) {\n    if (!this.isValid) return this;\n    return Interval.fromDateTimes(start || this.s, end || this.e);\n  }\n\n  /**\n   * Split this Interval at each of the specified DateTimes\n   * @param {...DateTime} dateTimes - the unit of time to count.\n   * @return {Array}\n   */\n  splitAt(...dateTimes) {\n    if (!this.isValid) return [];\n    const sorted = dateTimes\n        .map(_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)\n        .filter((d) => this.contains(d))\n        .sort((a, b) => a.toMillis() - b.toMillis()),\n      results = [];\n    let { s } = this,\n      i = 0;\n\n    while (s < this.e) {\n      const added = sorted[i] || this.e,\n        next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      i += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into smaller Intervals, each of the specified length.\n   * Left over time is grouped into a smaller interval\n   * @param {Duration|Object|number} duration - The length of each resulting interval.\n   * @return {Array}\n   */\n  splitBy(duration) {\n    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromDurationLike(duration);\n\n    if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\n      return [];\n    }\n\n    let { s } = this,\n      idx = 1,\n      next;\n\n    const results = [];\n    while (s < this.e) {\n      const added = this.start.plus(dur.mapUnits((x) => x * idx));\n      next = +added > +this.e ? this.e : added;\n      results.push(Interval.fromDateTimes(s, next));\n      s = next;\n      idx += 1;\n    }\n\n    return results;\n  }\n\n  /**\n   * Split this Interval into the specified number of smaller intervals.\n   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\n   * @return {Array}\n   */\n  divideEqually(numberOfParts) {\n    if (!this.isValid) return [];\n    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\n  }\n\n  /**\n   * Return whether this Interval overlaps with the specified Interval\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  overlaps(other) {\n    return this.e > other.s && this.s < other.e;\n  }\n\n  /**\n   * Return whether this Interval's end is adjacent to the specified Interval's start.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsStart(other) {\n    if (!this.isValid) return false;\n    return +this.e === +other.s;\n  }\n\n  /**\n   * Return whether this Interval's start is adjacent to the specified Interval's end.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  abutsEnd(other) {\n    if (!this.isValid) return false;\n    return +other.e === +this.s;\n  }\n\n  /**\n   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  engulfs(other) {\n    if (!this.isValid) return false;\n    return this.s <= other.s && this.e >= other.e;\n  }\n\n  /**\n   * Return whether this Interval has the same start and end as the specified Interval.\n   * @param {Interval} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    return this.s.equals(other.s) && this.e.equals(other.e);\n  }\n\n  /**\n   * Return an Interval representing the intersection of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n   * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  intersection(other) {\n    if (!this.isValid) return this;\n    const s = this.s > other.s ? this.s : other.s,\n      e = this.e < other.e ? this.e : other.e;\n\n    if (s >= e) {\n      return null;\n    } else {\n      return Interval.fromDateTimes(s, e);\n    }\n  }\n\n  /**\n   * Return an Interval representing the union of this Interval and the specified Interval.\n   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n   * @param {Interval} other\n   * @return {Interval}\n   */\n  union(other) {\n    if (!this.isValid) return this;\n    const s = this.s < other.s ? this.s : other.s,\n      e = this.e > other.e ? this.e : other.e;\n    return Interval.fromDateTimes(s, e);\n  }\n\n  /**\n   * Merge an array of Intervals into an equivalent minimal set of Intervals.\n   * Combines overlapping and adjacent Intervals.\n   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval\n   * and ending with the latest.\n   *\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static merge(intervals) {\n    const [found, final] = intervals\n      .sort((a, b) => a.s - b.s)\n      .reduce(\n        ([sofar, current], item) => {\n          if (!current) {\n            return [sofar, item];\n          } else if (current.overlaps(item) || current.abutsStart(item)) {\n            return [sofar, current.union(item)];\n          } else {\n            return [sofar.concat([current]), item];\n          }\n        },\n        [[], null]\n      );\n    if (final) {\n      found.push(final);\n    }\n    return found;\n  }\n\n  /**\n   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n   * @param {Array} intervals\n   * @return {Array}\n   */\n  static xor(intervals) {\n    let start = null,\n      currentCount = 0;\n    const results = [],\n      ends = intervals.map((i) => [\n        { time: i.s, type: \"s\" },\n        { time: i.e, type: \"e\" },\n      ]),\n      flattened = Array.prototype.concat(...ends),\n      arr = flattened.sort((a, b) => a.time - b.time);\n\n    for (const i of arr) {\n      currentCount += i.type === \"s\" ? 1 : -1;\n\n      if (currentCount === 1) {\n        start = i.time;\n      } else {\n        if (start && +start !== +i.time) {\n          results.push(Interval.fromDateTimes(start, i.time));\n        }\n\n        start = null;\n      }\n    }\n\n    return Interval.merge(results);\n  }\n\n  /**\n   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n   * @param {...Interval} intervals\n   * @return {Array}\n   */\n  difference(...intervals) {\n    return Interval.xor([this].concat(intervals))\n      .map((i) => this.intersection(i))\n      .filter((i) => i && !i.isEmpty());\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for debugging.\n   * @return {string}\n   */\n  toString() {\n    if (!this.isValid) return INVALID;\n    return `[${this.s.toISO()}  ${this.e.toISO()})`;\n  }\n\n  /**\n   * Returns a string representation of this Interval appropriate for the REPL.\n   * @return {string}\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    if (this.isValid) {\n      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;\n    } else {\n      return `Interval { Invalid, reason: ${this.invalidReason} }`;\n    }\n  }\n\n  /**\n   * Returns a localized string representing this Interval. Accepts the same options as the\n   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as\n   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method\n   * is browser-specific, but in general it will return an appropriate representation of the\n   * Interval in the assigned locale. Defaults to the system's locale if no locale has been\n   * specified.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or\n   * Intl.DateTimeFormat constructor options.\n   * @param {Object} opts - Options to override the configuration of the start DateTime.\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022\n   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM\n   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p\n   * @return {string}\n   */\n  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__.DATE_SHORT, opts = {}) {\n    return this.isValid\n      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create(this.s.loc.clone(opts), formatOpts).formatInterval(this)\n      : INVALID;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Interval.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISO(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of date of this Interval.\n   * The time components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @return {string}\n   */\n  toISODate() {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISODate()}/${this.e.toISODate()}`;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of time of this Interval.\n   * The date components are ignored.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n   * @param {Object} opts - The same options as {@link DateTime#toISO}\n   * @return {string}\n   */\n  toISOTime(opts) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;\n  }\n\n  /**\n   * Returns a string representation of this Interval formatted according to the specified format\n   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible\n   * formatting tool.\n   * @param {string} dateFormat - The format string. This string formats the start and end time.\n   * See {@link DateTime#toFormat} for details.\n   * @param {Object} opts - Options.\n   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end\n   * representations.\n   * @return {string}\n   */\n  toFormat(dateFormat, { separator = \"  \" } = {}) {\n    if (!this.isValid) return INVALID;\n    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;\n  }\n\n  /**\n   * Return a Duration representing the time spanned by this interval.\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\n   * @param {Object} opts - options that affect the creation of the Duration\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n   * @return {Duration}\n   */\n  toDuration(unit, opts) {\n    if (!this.isValid) {\n      return _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].invalid(this.invalidReason);\n    }\n    return this.e.diff(this.s, unit, opts);\n  }\n\n  /**\n   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n   * @param {function} mapFn\n   * @return {Interval}\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n   */\n  mapEndpoints(mapFn) {\n    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEyRDtBQUN0QjtBQUNBO0FBQ29DO0FBQ2pDO0FBQ0k7QUFDQzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJFQUEyRSxlQUFlLFVBQVUsWUFBWTtBQUNoSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RkFBeUYsZUFBZTtBQUN4RztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsc0JBQXNCLE1BQU0sdUJBQXVCO0FBQ3pKLHdCQUF3QixzQkFBc0IsS0FBSyxvQkFBb0I7QUFDdkUscURBQXFELHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixNQUFNLHdCQUF3QjtBQUNoTix3RUFBd0UsbUJBQW1CLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsNEJBQTRCLE1BQU0sMEJBQTBCO0FBQ3BULGtFQUFrRSxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx3QkFBd0IsR0FBRztBQUM5Syx5RUFBeUUsd0JBQXdCLEdBQUcsOEJBQThCLEdBQUcscUJBQXFCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsd0JBQXdCLE9BQU8sMEJBQTBCO0FBQzlRO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNy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V0FBVztBQUMzRDtBQUNBLFFBQVEsMERBQVM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsNEJBQTRCO0FBQ2pELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQixHQUFHLG1CQUFtQjtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQixHQUFHLG1CQUFtQjtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSw0QkFBNEI7QUFDakQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQy9EOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUseUJBQXlCO0FBQ25DLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx5QkFBeUIsb0JBQW9CLElBQUk7QUFDakQ7QUFDQSxjQUFjLDRCQUE0QixFQUFFLFVBQVUsRUFBRSw0QkFBNEI7QUFDcEY7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsOEVBQThFO0FBQzlFLG9GQUFvRjtBQUNwRixrR0FBa0c7QUFDbEcsNkdBQTZHO0FBQzdHLHVGQUF1RjtBQUN2RixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixjQUFjO0FBQ2Q7QUFDQSx3RkFBd0YsVUFBVTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXByb3ZpZGVycy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ludGVydmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVGltZSwgeyBmcmllbmRseURhdGVUaW1lIH0gZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZEludGVydmFsRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBJbnRlcnZhbFwiO1xuXG4vLyBjaGVja3MgaWYgdGhlIHN0YXJ0IGlzIGVxdWFsIHRvIG9yIGJlZm9yZSB0aGUgZW5kXG5mdW5jdGlvbiB2YWxpZGF0ZVN0YXJ0RW5kKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCB8fCAhc3RhcnQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIHN0YXJ0XCIpO1xuICB9IGVsc2UgaWYgKCFlbmQgfHwgIWVuZC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kXCIpO1xuICB9IGVsc2UgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXG4gICAgICBcImVuZCBiZWZvcmUgc3RhcnRcIixcbiAgICAgIGBUaGUgZW5kIG9mIGFuIGludGVydmFsIG11c3QgYmUgYWZ0ZXIgaXRzIHN0YXJ0LCBidXQgeW91IGhhZCBzdGFydD0ke3N0YXJ0LnRvSVNPKCl9IGFuZCBlbmQ9JHtlbmQudG9JU08oKX1gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIEludGVydmFsIG9iamVjdCByZXByZXNlbnRzIGEgaGFsZi1vcGVuIGludGVydmFsIG9mIHRpbWUsIHdoZXJlIGVhY2ggZW5kcG9pbnQgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LiBDb25jZXB0dWFsbHksIGl0J3MgYSBjb250YWluZXIgZm9yIHRob3NlIHR3byBlbmRwb2ludHMsIGFjY29tcGFuaWVkIGJ5IG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCBjb21wYXJpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIEludGVydmFsOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhbiBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzfSwge0BsaW5rIEludGVydmFsLmFmdGVyfSwge0BsaW5rIEludGVydmFsLmJlZm9yZX0sIG9yIHtAbGluayBJbnRlcnZhbC5mcm9tSVNPfS5cbiAqICogKipBY2Nlc3NvcnMqKiBVc2Uge0BsaW5rIEludGVydmFsI3N0YXJ0fSBhbmQge0BsaW5rIEludGVydmFsI2VuZH0gdG8gZ2V0IHRoZSBzdGFydCBhbmQgZW5kLlxuICogKiAqKkludGVycm9nYXRpb24qKiBUbyBhbmFseXplIHRoZSBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbCNjb3VudH0sIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9LCB7QGxpbmsgSW50ZXJ2YWwjaGFzU2FtZX0sIHtAbGluayBJbnRlcnZhbCNjb250YWluc30sIHtAbGluayBJbnRlcnZhbCNpc0FmdGVyfSwgb3Ige0BsaW5rIEludGVydmFsI2lzQmVmb3JlfS5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBvdGhlciBJbnRlcnZhbHMgb3V0IG9mIHRoaXMgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI3NldH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEF0fSwge0BsaW5rIEludGVydmFsI3NwbGl0Qnl9LCB7QGxpbmsgSW50ZXJ2YWwjZGl2aWRlRXF1YWxseX0sIHtAbGluayBJbnRlcnZhbC5tZXJnZX0sIHtAbGluayBJbnRlcnZhbC54b3J9LCB7QGxpbmsgSW50ZXJ2YWwjdW5pb259LCB7QGxpbmsgSW50ZXJ2YWwjaW50ZXJzZWN0aW9ufSwgb3Ige0BsaW5rIEludGVydmFsI2RpZmZlcmVuY2V9LlxuICogKiAqKkNvbXBhcmlzb24qKiBUbyBjb21wYXJlIHRoaXMgSW50ZXJ2YWwgdG8gYW5vdGhlciBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjZXF1YWxzfSwge0BsaW5rIEludGVydmFsI292ZXJsYXBzfSwge0BsaW5rIEludGVydmFsI2FidXRzU3RhcnR9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNFbmR9LCB7QGxpbmsgSW50ZXJ2YWwjZW5ndWxmc31cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBJbnRlcnZhbCBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBJbnRlcnZhbCN0b1N0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0lTT30sIHtAbGluayBJbnRlcnZhbCN0b0lTT0RhdGV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09UaW1lfSwge0BsaW5rIEludGVydmFsI3RvRm9ybWF0fSwgYW5kIHtAbGluayBJbnRlcnZhbCN0b0R1cmF0aW9ufS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJ2YWwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucyA9IGNvbmZpZy5zdGFydDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmUgPSBjb25maWcuZW5kO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uSW50ZXJ2YWwgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIEludGVydmFsIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRJbnRlcnZhbEVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYW4gZW5kIERhdGVUaW1lLiBJbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGJ1dCBub3QgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ1aWx0U3RhcnQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KSxcbiAgICAgIGJ1aWx0RW5kID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuXG4gICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IHZhbGlkYXRlU3RhcnRFbmQoYnVpbHRTdGFydCwgYnVpbHRFbmQpO1xuXG4gICAgaWYgKHZhbGlkYXRlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7XG4gICAgICAgIHN0YXJ0OiBidWlsdFN0YXJ0LFxuICAgICAgICBlbmQ6IGJ1aWx0RW5kLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBhZnRlcihzdGFydCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQsIGR0LnBsdXMoZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gZW5kIERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCBiYWNrd2FyZHMgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGJlZm9yZShlbmQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdC5taW51cyhkdXIpLCBkdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICAgKiBBY2NlcHRzIGA8c3RhcnQ+LzxlbmQ+YCwgYDxzdGFydD4vPGR1cmF0aW9uPmAsIGFuZCBgPGR1cmF0aW9uPi88ZW5kPmAgZm9ybWF0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9ucyB0byBwYXNzIHtAbGluayBEYXRlVGltZSNmcm9tSVNPfSBhbmQgb3B0aW9uYWxseSB7QGxpbmsgRHVyYXRpb24jZnJvbUlTT31cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcywgZV0gPSAodGV4dCB8fCBcIlwiKS5zcGxpdChcIi9cIiwgMik7XG4gICAgaWYgKHMgJiYgZSkge1xuICAgICAgbGV0IHN0YXJ0LCBzdGFydElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFydCA9IERhdGVUaW1lLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IHN0YXJ0LmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgZW5kLCBlbmRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGVuZC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlbmRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQgJiYgZW5kSXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYWZ0ZXIoc3RhcnQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kSXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYmVmb3JlKGVuZCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gSW50ZXJ2YWwuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0ludGVydmFsKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uSW50ZXJ2YWwpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMucyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBJbnRlcnZhbC4gVGhpcyBpcyB0aGUgZmlyc3QgaW5zdGFudCB3aGljaCBpcyBub3QgcGFydCBvZiB0aGUgaW50ZXJ2YWxcbiAgICogKEludGVydmFsIGlzIGhhbGYtb3BlbikuXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBEYXRlVGltZSBpbmNsdWRlZCBpbiB0aGUgaW50ZXJ2YWwgKHNpbmNlIGVuZCBpcyBub3QgcGFydCBvZiB0aGUgaW50ZXJ2YWwpXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBsYXN0RGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/ICh0aGlzLmUgPyB0aGlzLmUubWludXMoMSkgOiBudWxsKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYXQgbGVhc3QgaXRzIHN0YXJ0LCBtZWFuaW5nIHRoYXQgdGhlIEludGVydmFsIGlzbid0ICdiYWNrd2FyZHMnLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWRSZWFzb24gPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIEludGVydmFsIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gcmV0dXJuIHRoZSBsZW5ndGggaW4uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvRHVyYXRpb24oLi4uW3VuaXRdKS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgbWludXRlcywgaG91cnMsIGRheXMsIG1vbnRocywgb3IgeWVhcnMgaW5jbHVkZWQgaW4gdGhlIEludGVydmFsLCBldmVuIGluIHBhcnQuXG4gICAqIFVubGlrZSB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSB0aGlzIGNvdW50cyBzZWN0aW9ucyBvZiB0aGUgY2FsZW5kYXIsIG5vdCBwZXJpb2RzIG9mIHRpbWUsIGUuZy4gc3BlY2lmeWluZyAnZGF5J1xuICAgKiBhc2tzICd3aGF0IGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGludGVydmFsPycsIG5vdCAnaG93IG1hbnkgZGF5cyBsb25nIGlzIHRoaXMgaW50ZXJ2YWw/J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VuaXQ9J21pbGxpc2Vjb25kcyddIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudXNlTG9jYWxlV2Vla3M9ZmFsc2VdIC0gSWYgdHJ1ZSwgdXNlIHdlZWtzIGJhc2VkIG9uIHRoZSBsb2NhbGUsIGkuZS4gdXNlIHRoZSBsb2NhbGUtZGVwZW5kZW50IHN0YXJ0IG9mIHRoZSB3ZWVrOyB0aGlzIG9wZXJhdGlvbiB3aWxsIGFsd2F5cyB1c2UgdGhlIGxvY2FsZSBvZiB0aGUgc3RhcnQgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnQodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhcnQuc3RhcnRPZih1bml0LCBvcHRzKTtcbiAgICBsZXQgZW5kO1xuICAgIGlmIChvcHRzPy51c2VMb2NhbGVXZWVrcykge1xuICAgICAgZW5kID0gdGhpcy5lbmQucmVjb25maWd1cmUoeyBsb2NhbGU6IHN0YXJ0LmxvY2FsZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gdGhpcy5lbmQ7XG4gICAgfVxuICAgIGVuZCA9IGVuZC5zdGFydE9mKHVuaXQsIG9wdHMpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCkpICsgKGVuZC52YWx1ZU9mKCkgIT09IHRoaXMuZW5kLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBhbmQgZW5kIGFyZSBib3RoIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmlzRW1wdHkoKSB8fCB0aGlzLmUubWludXMoMSkuaGFzU2FtZSh0aGlzLnMsIHVuaXQpIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBEYXRlVGltZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnMudmFsdWVPZigpID09PSB0aGlzLmUudmFsdWVPZigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZnRlciB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBZnRlcihkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0JlZm9yZShkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZSA8PSBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWlucyhkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBkYXRlVGltZSAmJiB0aGlzLmUgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldHNcIiB0aGUgc3RhcnQgYW5kL29yIGVuZCBkYXRlcy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIHZhbHVlcyB0byBzZXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLnN0YXJ0IC0gdGhlIHN0YXJ0aW5nIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5lbmQgLSB0aGUgZW5kaW5nIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc2V0KHsgc3RhcnQsIGVuZCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQgfHwgdGhpcy5zLCBlbmQgfHwgdGhpcy5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGF0IGVhY2ggb2YgdGhlIHNwZWNpZmllZCBEYXRlVGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEF0KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgY29uc3Qgc29ydGVkID0gZGF0ZVRpbWVzXG4gICAgICAgIC5tYXAoZnJpZW5kbHlEYXRlVGltZSlcbiAgICAgICAgLmZpbHRlcigoZCkgPT4gdGhpcy5jb250YWlucyhkKSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEudG9NaWxsaXMoKSAtIGIudG9NaWxsaXMoKSksXG4gICAgICByZXN1bHRzID0gW107XG4gICAgbGV0IHsgcyB9ID0gdGhpcyxcbiAgICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gc29ydGVkW2ldIHx8IHRoaXMuZSxcbiAgICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byBzbWFsbGVyIEludGVydmFscywgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogTGVmdCBvdmVyIHRpbWUgaXMgZ3JvdXBlZCBpbnRvIGEgc21hbGxlciBpbnRlcnZhbFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGxlbmd0aCBvZiBlYWNoIHJlc3VsdGluZyBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEJ5KGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhZHVyLmlzVmFsaWQgfHwgZHVyLmFzKFwibWlsbGlzZWNvbmRzXCIpID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IHsgcyB9ID0gdGhpcyxcbiAgICAgIGlkeCA9IDEsXG4gICAgICBuZXh0O1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChzIDwgdGhpcy5lKSB7XG4gICAgICBjb25zdCBhZGRlZCA9IHRoaXMuc3RhcnQucGx1cyhkdXIubWFwVW5pdHMoKHgpID0+IHggKiBpZHgpKTtcbiAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzbWFsbGVyIGludGVydmFscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mUGFydHMgLSBUaGUgbnVtYmVyIG9mIEludGVydmFscyB0byBkaXZpZGUgdGhlIEludGVydmFsIGludG8uXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZGl2aWRlRXF1YWxseShudW1iZXJPZlBhcnRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gdGhpcy5zcGxpdEJ5KHRoaXMubGVuZ3RoKCkgLyBudW1iZXJPZlBhcnRzKS5zbGljZSgwLCBudW1iZXJPZlBhcnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCBJbnRlcnZhbFxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgb3ZlcmxhcHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lID4gb3RoZXIucyAmJiB0aGlzLnMgPCBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYWRqYWNlbnQgdG8gdGhlIHNwZWNpZmllZCBJbnRlcnZhbCdzIHN0YXJ0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWJ1dHNTdGFydChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICt0aGlzLmUgPT09ICtvdGhlci5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3MgZW5kLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWJ1dHNFbmQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArb3RoZXIuZSA9PT0gK3RoaXMucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBJbnRlcnZhbCBmdWxseSBjb250YWlucyB0aGUgc3BlY2lmaWVkIEludGVydmFsLCBzcGVjaWZpY2FsbHkgaWYgdGhlIGludGVyc2VjdCAob2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIG90aGVyIEludGVydmFsKSBpcyBlcXVhbCB0byB0aGUgb3RoZXIgSW50ZXJ2YWw7IGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVuZ3VsZnMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPD0gb3RoZXIucyAmJiB0aGlzLmUgPj0gb3RoZXIuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIGFzIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnMuZXF1YWxzKG90aGVyLnMpICYmIHRoaXMuZS5lcXVhbHMob3RoZXIuZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1heGltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1pbmltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5LCBtZWFuaW5nLCB0aGUgaW50ZXJ2YWxzIGRvbid0IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA+IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA8IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuXG4gICAgaWYgKHMgPj0gZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSB1bmlvbiBvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSByZXN1bHRpbmcgSW50ZXJ2YWwgaGFzIHRoZSBtaW5pbXVtIHN0YXJ0IHRpbWUgYW5kIHRoZSBtYXhpbXVtIGVuZCB0aW1lIG9mIHRoZSB0d28gSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHVuaW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMgPCBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgIGUgPSB0aGlzLmUgPiBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhbiBhcnJheSBvZiBJbnRlcnZhbHMgaW50byBhbiBlcXVpdmFsZW50IG1pbmltYWwgc2V0IG9mIEludGVydmFscy5cbiAgICogQ29tYmluZXMgb3ZlcmxhcHBpbmcgYW5kIGFkamFjZW50IEludGVydmFscy5cbiAgICogVGhlIHJlc3VsdGluZyBhcnJheSB3aWxsIGNvbnRhaW4gdGhlIEludGVydmFscyBpbiBhc2NlbmRpbmcgb3JkZXIsIHRoYXQgaXMsIHN0YXJ0aW5nIHdpdGggdGhlIGVhcmxpZXN0IEludGVydmFsXG4gICAqIGFuZCBlbmRpbmcgd2l0aCB0aGUgbGF0ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWVyZ2UoaW50ZXJ2YWxzKSB7XG4gICAgY29uc3QgW2ZvdW5kLCBmaW5hbF0gPSBpbnRlcnZhbHNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnMgLSBiLnMpXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW3NvZmFyLCBjdXJyZW50XSwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2ZhciwgaXRlbV07XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Lm92ZXJsYXBzKGl0ZW0pIHx8IGN1cnJlbnQuYWJ1dHNTdGFydChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2ZhciwgY3VycmVudC51bmlvbihpdGVtKV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIuY29uY2F0KFtjdXJyZW50XSksIGl0ZW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1tdLCBudWxsXVxuICAgICAgKTtcbiAgICBpZiAoZmluYWwpIHtcbiAgICAgIGZvdW5kLnB1c2goZmluYWwpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIEludGVydmFscyByZXByZXNlbnRpbmcgdGhlIHNwYW5zIG9mIHRpbWUgdGhhdCBvbmx5IGFwcGVhciBpbiBvbmUgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB4b3IoaW50ZXJ2YWxzKSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRDb3VudCA9IDA7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdLFxuICAgICAgZW5kcyA9IGludGVydmFscy5tYXAoKGkpID0+IFtcbiAgICAgICAgeyB0aW1lOiBpLnMsIHR5cGU6IFwic1wiIH0sXG4gICAgICAgIHsgdGltZTogaS5lLCB0eXBlOiBcImVcIiB9LFxuICAgICAgXSksXG4gICAgICBmbGF0dGVuZWQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0KC4uLmVuZHMpLFxuICAgICAgYXJyID0gZmxhdHRlbmVkLnNvcnQoKGEsIGIpID0+IGEudGltZSAtIGIudGltZSk7XG5cbiAgICBmb3IgKGNvbnN0IGkgb2YgYXJyKSB7XG4gICAgICBjdXJyZW50Q291bnQgKz0gaS50eXBlID09PSBcInNcIiA/IDEgOiAtMTtcblxuICAgICAgaWYgKGN1cnJlbnRDb3VudCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IGkudGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydCAmJiArc3RhcnQgIT09ICtpLnRpbWUpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgaS50aW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEludGVydmFsLm1lcmdlKHJlc3VsdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHNwYW4gb2YgdGltZSBpbiB0aGlzIEludGVydmFsIHRoYXQgZG9lc24ndCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0gey4uLkludGVydmFsfSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaWZmZXJlbmNlKC4uLmludGVydmFscykge1xuICAgIHJldHVybiBJbnRlcnZhbC54b3IoW3RoaXNdLmNvbmNhdChpbnRlcnZhbHMpKVxuICAgICAgLm1hcCgoaSkgPT4gdGhpcy5pbnRlcnNlY3Rpb24oaSkpXG4gICAgICAuZmlsdGVyKChpKSA9PiBpICYmICFpLmlzRW1wdHkoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYFske3RoaXMucy50b0lTTygpfSDigJMgJHt0aGlzLmUudG9JU08oKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIHRoZSBSRVBMLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gYEludGVydmFsIHsgc3RhcnQ6ICR7dGhpcy5zLnRvSVNPKCl9LCBlbmQ6ICR7dGhpcy5lLnRvSVNPKCl9IH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEludGVydmFsIHsgSW52YWxpZCwgcmVhc29uOiAke3RoaXMuaW52YWxpZFJlYXNvbn0gfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIEludGVydmFsLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXNcbiAgICoge0BsaW5rIERhdGVUaW1lLkRBVEVfRlVMTH0gb3Ige0BsaW5rIERhdGVUaW1lLlRJTUVfU0lNUExFfS4gVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kXG4gICAqIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiBJbnRlcnZhbCBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlblxuICAgKiBzcGVjaWZpZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmb3JtYXRPcHRzPURhdGVUaW1lLkRBVEVfU0hPUlRdIC0gRWl0aGVyIGEgRGF0ZVRpbWUgcHJlc2V0IG9yXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBzdGFydCBEYXRlVGltZS5cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDExLzcvMjAyMiDigJMgMTEvOC8yMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiBOb3ZlbWJlciA3IOKAkyA4LCAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyLUZSJyB9KTsgLy89PiA34oCTOCBub3ZlbWJyZSAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+IDY6MDAg4oCTIDg6MDAgUE1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiBNb24sIE5vdiAwNywgNjowMCDigJMgODowMCBwXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLnMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXRJbnRlcnZhbCh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTTyhvcHRzKX0vJHt0aGlzLmUudG9JU08ob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZGF0ZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgdGltZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT0RhdGUoKX0vJHt0aGlzLmUudG9JU09EYXRlKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgZGF0ZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09UaW1lKG9wdHMpfS8ke3RoaXMuZS50b0lTT1RpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICAgKiBzdHJpbmcuICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGVcbiAgICogZm9ybWF0dGluZyB0b29sLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZUZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLiBUaGlzIHN0cmluZyBmb3JtYXRzIHRoZSBzdGFydCBhbmQgZW5kIHRpbWUuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5zZXBhcmF0b3IgPSAgJyDigJMgJ10gLSBBIHNlcGFyYXRvciB0byBwbGFjZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kXG4gICAqIHJlcHJlc2VudGF0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZGF0ZUZvcm1hdCwgeyBzZXBhcmF0b3IgPSBcIiDigJMgXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9JHtzZXBhcmF0b3J9JHt0aGlzLmUudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgdGhlIHRpbWUgc3Bhbm5lZCBieSB0aGlzIGludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA4ODQ4OTI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ2RheXMnKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiAxLjAyNDE4MTIxNTI3Nzc3NzggfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LjgyMDk1IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LCBzZWNvbmRzOiA0OS4yNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgc2Vjb25kczogODg0ODkuMjU3IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICB0b0R1cmF0aW9uKHVuaXQsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkUmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZS5kaWZmKHRoaXMucywgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG1hcEZuIG9uIHRoZSBpbnRlcnZhbCBzdGFydCBhbmQgZW5kLCByZXR1cm5pbmcgYSBuZXcgSW50ZXJ2YWwgZnJvbSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnRvVVRDKCkpXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC5wbHVzKHsgaG91cnM6IDIgfSkpXG4gICAqL1xuICBtYXBFbmRwb2ludHMobWFwRm4pIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhtYXBGbih0aGlzLnMpLCBtYXBGbih0aGlzLmUpKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/interval.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/luxon.js":
/*!**********************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/luxon.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* reexport safe */ _datetime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Duration: () => (/* reexport safe */ _duration_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   FixedOffsetZone: () => (/* reexport safe */ _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   IANAZone: () => (/* reexport safe */ _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   Info: () => (/* reexport safe */ _info_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   Interval: () => (/* reexport safe */ _interval_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   InvalidZone: () => (/* reexport safe */ _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   Settings: () => (/* reexport safe */ _settings_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   SystemZone: () => (/* reexport safe */ _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Zone: () => (/* reexport safe */ _zone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/duration.js\");\n/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/interval.js\");\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/info.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js\");\n/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zones/invalidZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/invalidZone.js\");\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"3.7.1\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9sdXhvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQTtBQUNBO0FBQ1I7QUFDQTtBQUM0QjtBQUNkO0FBQ007QUFDRjtBQUNWOztBQUVyQzs7QUFjRSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9sdXhvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IEludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi96b25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgSW52YWxpZFpvbmUgZnJvbSBcIi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcbmltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuXG5jb25zdCBWRVJTSU9OID0gXCIzLjcuMVwiO1xuXG5leHBvcnQge1xuICBWRVJTSU9OLFxuICBEYXRlVGltZSxcbiAgRHVyYXRpb24sXG4gIEludGVydmFsLFxuICBJbmZvLFxuICBab25lLFxuICBGaXhlZE9mZnNldFpvbmUsXG4gIElBTkFab25lLFxuICBJbnZhbGlkWm9uZSxcbiAgU3lzdGVtWm9uZSxcbiAgU2V0dGluZ3MsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/luxon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js":
/*!*************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/settings.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Settings)\n/* harmony export */ });\n/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zones/systemZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/systemZone.js\");\n/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zones/IANAZone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\");\n/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/locale.js\");\n/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./datetime.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/datetime.js\");\n/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/zoneUtil.js\");\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _impl_digits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/digits.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/digits.js\");\n\n\n\n\n\n\n\n\n\nlet now = () => Date.now(),\n  defaultZone = \"system\",\n  defaultLocale = null,\n  defaultNumberingSystem = null,\n  defaultOutputCalendar = null,\n  twoDigitCutoffYear = 60,\n  throwOnInvalid,\n  defaultWeekSettings = null;\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.\n */\nclass Settings {\n  /**\n   * Get the callback for returning the current timestamp.\n   * @type {function}\n   */\n  static get now() {\n    return now;\n  }\n\n  /**\n   * Set the callback for returning the current timestamp.\n   * The function should return a number, which will be interpreted as an Epoch millisecond count\n   * @type {function}\n   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n   */\n  static set now(n) {\n    now = n;\n  }\n\n  /**\n   * Set the default time zone to create DateTimes in. Does not affect existing instances.\n   * Use the value \"system\" to reset this value to the system's time zone.\n   * @type {string}\n   */\n  static set defaultZone(zone) {\n    defaultZone = zone;\n  }\n\n  /**\n   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.\n   * The default value is the system's time zone (the one set on the machine that runs this code).\n   * @type {Zone}\n   */\n  static get defaultZone() {\n    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(defaultZone, _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance);\n  }\n\n  /**\n   * Get the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultLocale() {\n    return defaultLocale;\n  }\n\n  /**\n   * Set the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultLocale(locale) {\n    defaultLocale = locale;\n  }\n\n  /**\n   * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultNumberingSystem() {\n    return defaultNumberingSystem;\n  }\n\n  /**\n   * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultNumberingSystem(numberingSystem) {\n    defaultNumberingSystem = numberingSystem;\n  }\n\n  /**\n   * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultOutputCalendar() {\n    return defaultOutputCalendar;\n  }\n\n  /**\n   * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultOutputCalendar(outputCalendar) {\n    defaultOutputCalendar = outputCalendar;\n  }\n\n  /**\n   * @typedef {Object} WeekSettings\n   * @property {number} firstDay\n   * @property {number} minimalDays\n   * @property {number[]} weekend\n   */\n\n  /**\n   * @return {WeekSettings|null}\n   */\n  static get defaultWeekSettings() {\n    return defaultWeekSettings;\n  }\n\n  /**\n   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and\n   * how many days are required in the first week of a year.\n   * Does not affect existing instances.\n   *\n   * @param {WeekSettings|null} weekSettings\n   */\n  static set defaultWeekSettings(weekSettings) {\n    defaultWeekSettings = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.validateWeekSettings)(weekSettings);\n  }\n\n  /**\n   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   */\n  static get twoDigitCutoffYear() {\n    return twoDigitCutoffYear;\n  }\n\n  /**\n   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.\n   * @type {number}\n   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century\n   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century\n   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950\n   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50\n   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50\n   */\n  static set twoDigitCutoffYear(cutoffYear) {\n    twoDigitCutoffYear = cutoffYear % 100;\n  }\n\n  /**\n   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static get throwOnInvalid() {\n    return throwOnInvalid;\n  }\n\n  /**\n   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static set throwOnInvalid(t) {\n    throwOnInvalid = t;\n  }\n\n  /**\n   * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCaches() {\n    _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resetCache();\n    _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resetCache();\n    _datetime_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].resetCache();\n    (0,_impl_digits_js__WEBPACK_IMPORTED_MODULE_6__.resetDigitRegexCache)();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9zZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQztBQUNKO0FBQ0w7QUFDRDs7QUFFYztBQUNHO0FBQ0U7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVyxnRUFBYSxjQUFjLDREQUFVO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixVQUFVO0FBQzFCOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0EsMEJBQTBCLG1FQUFvQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLElBQUksdURBQU07QUFDVixJQUFJLDBEQUFRO0FBQ1osSUFBSSxvREFBUTtBQUNaLElBQUkscUVBQW9CO0FBQ3hCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcblxuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlV2Vla1NldHRpbmdzIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgeyByZXNldERpZ2l0UmVnZXhDYWNoZSB9IGZyb20gXCIuL2ltcGwvZGlnaXRzLmpzXCI7XG5cbmxldCBub3cgPSAoKSA9PiBEYXRlLm5vdygpLFxuICBkZWZhdWx0Wm9uZSA9IFwic3lzdGVtXCIsXG4gIGRlZmF1bHRMb2NhbGUgPSBudWxsLFxuICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVsbCxcbiAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gbnVsbCxcbiAgdHdvRGlnaXRDdXRvZmZZZWFyID0gNjAsXG4gIHRocm93T25JbnZhbGlkLFxuICBkZWZhdWx0V2Vla1NldHRpbmdzID0gbnVsbDtcblxuLyoqXG4gKiBTZXR0aW5ncyBjb250YWlucyBzdGF0aWMgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IGNvbnRyb2wgTHV4b24ncyBvdmVyYWxsIGJlaGF2aW9yLiBMdXhvbiBpcyBhIHNpbXBsZSBsaWJyYXJ5IHdpdGggZmV3IG9wdGlvbnMsIGJ1dCB0aGUgb25lcyBpdCBkb2VzIGhhdmUgbGl2ZSBoZXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqL1xuICBzdGF0aWMgZ2V0IG5vdygpIHtcbiAgICByZXR1cm4gbm93O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFuIEVwb2NoIG1pbGxpc2Vjb25kIGNvdW50XG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gRGF0ZS5ub3coKSArIDMwMDAgLy8gcHJldGVuZCBpdCBpcyAzIHNlY29uZHMgaW4gdGhlIGZ1dHVyZVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiAwIC8vIGFsd2F5cyBwcmV0ZW5kIGl0J3MgSmFuIDEsIDE5NzAgYXQgbWlkbmlnaHQgaW4gVVRDIHRpbWVcbiAgICovXG4gIHN0YXRpYyBzZXQgbm93KG4pIHtcbiAgICBub3cgPSBuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVXNlIHRoZSB2YWx1ZSBcInN5c3RlbVwiIHRvIHJlc2V0IHRoaXMgdmFsdWUgdG8gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFpvbmUoem9uZSkge1xuICAgIGRlZmF1bHRab25lID0gem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIG9iamVjdCBjdXJyZW50bHkgdXNlZCB0byBjcmVhdGUgRGF0ZVRpbWVzLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgc3lzdGVtJ3MgdGltZSB6b25lICh0aGUgb25lIHNldCBvbiB0aGUgbWFjaGluZSB0aGF0IHJ1bnMgdGhpcyBjb2RlKS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRab25lKCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGRlZmF1bHRab25lLCBTeXN0ZW1ab25lLmluc3RhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdExvY2FsZSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdExvY2FsZShsb2NhbGUpIHtcbiAgICBkZWZhdWx0TG9jYWxlID0gbG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0obnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiBkZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcihvdXRwdXRDYWxlbmRhcikge1xuICAgIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFdlZWtTZXR0aW5nc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gZmlyc3REYXlcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbmltYWxEYXlzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHdlZWtlbmRcbiAgICovXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1dlZWtTZXR0aW5nc3xudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0V2Vla1NldHRpbmdzKCkge1xuICAgIHJldHVybiBkZWZhdWx0V2Vla1NldHRpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGxvY2FsZSB3ZWVrIHNldHRpbmdzLCBpLmUuIHRoZSBzdGFydCBvZiB0aGUgd2VlaywgdGhlIHdlZWtlbmQgYW5kXG4gICAqIGhvdyBtYW55IGRheXMgYXJlIHJlcXVpcmVkIGluIHRoZSBmaXJzdCB3ZWVrIG9mIGEgeWVhci5cbiAgICogRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWVrU2V0dGluZ3N8bnVsbH0gd2Vla1NldHRpbmdzXG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRXZWVrU2V0dGluZ3Mod2Vla1NldHRpbmdzKSB7XG4gICAgZGVmYXVsdFdlZWtTZXR0aW5ncyA9IHZhbGlkYXRlV2Vla1NldHRpbmdzKHdlZWtTZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXRvZmYgeWVhciBmb3Igd2hldGhlciBhIDItZGlnaXQgeWVhciBzdHJpbmcgaXMgaW50ZXJwcmV0ZWQgaW4gdGhlIGN1cnJlbnQgb3IgcHJldmlvdXMgY2VudHVyeS4gTnVtYmVycyBoaWdoZXIgdGhhbiB0aGUgY3V0b2ZmIHdpbGwgYmUgY29uc2lkZXJlZCB0byBtZWFuIDE5eHggYW5kIG51bWJlcnMgbG93ZXIgb3IgZXF1YWwgdG8gdGhlIGN1dG9mZiB3aWxsIGJlIGNvbnNpZGVyZWQgMjB4eC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdHdvRGlnaXRDdXRvZmZZZWFyKCkge1xuICAgIHJldHVybiB0d29EaWdpdEN1dG9mZlllYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXRvZmYgeWVhciBmb3Igd2hldGhlciBhIDItZGlnaXQgeWVhciBzdHJpbmcgaXMgaW50ZXJwcmV0ZWQgaW4gdGhlIGN1cnJlbnQgb3IgcHJldmlvdXMgY2VudHVyeS4gTnVtYmVycyBoaWdoZXIgdGhhbiB0aGUgY3V0b2ZmIHdpbGwgYmUgY29uc2lkZXJlZCB0byBtZWFuIDE5eHggYW5kIG51bWJlcnMgbG93ZXIgb3IgZXF1YWwgdG8gdGhlIGN1dG9mZiB3aWxsIGJlIGNvbnNpZGVyZWQgMjB4eC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMCAvLyBhbGwgJ3l5JyBhcmUgaW50ZXJwcmV0ZWQgYXMgMjB0aCBjZW50dXJ5XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDk5IC8vIGFsbCAneXknIGFyZSBpbnRlcnByZXRlZCBhcyAyMXN0IGNlbnR1cnlcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gNTAgLy8gJzQ5JyAtPiAyMDQ5OyAnNTAnIC0+IDE5NTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMTk1MCAvLyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAyMDUwIC8vIEFMU08gaW50ZXJwcmV0ZWQgYXMgNTBcbiAgICovXG4gIHN0YXRpYyBzZXQgdHdvRGlnaXRDdXRvZmZZZWFyKGN1dG9mZlllYXIpIHtcbiAgICB0d29EaWdpdEN1dG9mZlllYXIgPSBjdXRvZmZZZWFyICUgMTAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdGhyb3dPbkludmFsaWQoKSB7XG4gICAgcmV0dXJuIHRocm93T25JbnZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBzZXQgdGhyb3dPbkludmFsaWQodCkge1xuICAgIHRocm93T25JbnZhbGlkID0gdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBMdXhvbidzIGdsb2JhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlcygpIHtcbiAgICBMb2NhbGUucmVzZXRDYWNoZSgpO1xuICAgIElBTkFab25lLnJlc2V0Q2FjaGUoKTtcbiAgICBEYXRlVGltZS5yZXNldENhY2hlKCk7XG4gICAgcmVzZXREaWdpdFJlZ2V4Q2FjaGUoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/settings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js":
/*!*********************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/zone.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Zone)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/errors.js\");\n\n\n/**\n * @interface\n */\nclass Zone {\n  /**\n   * The type of zone\n   * @abstract\n   * @type {string}\n   */\n  get type() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The name of this zone.\n   * @abstract\n   * @type {string}\n   */\n  get name() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * The IANA name of this zone.\n   * Defaults to `name` if not overwritten by a subclass.\n   * @abstract\n   * @type {string}\n   */\n  get ianaName() {\n    return this.name;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year.\n   * @abstract\n   * @type {boolean}\n   */\n  get isUniversal() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, opts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @abstract\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @abstract\n   * @type {boolean}\n   */\n  get isValid() {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYywyREFBbUI7QUFDakM7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFpvbmVJc0Fic3RyYWN0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFpvbmUge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygem9uZVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyB6b25lLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIElBTkEgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIERlZmF1bHRzIHRvIGBuYW1lYCBpZiBub3Qgb3ZlcndyaXR0ZW4gYnkgYSBzdWJjbGFzcy5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaWFuYU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG9mZnNldCBpcyBrbm93biB0byBiZSBmaXhlZCBmb3IgdGhlIHdob2xlIHllYXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIGNvbW1vbiBuYW1lIChzdWNoIGFzIEVTVCkgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXBcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBhZmZlY3QgdGhlIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uIEFjY2VwdHMgJ2xvbmcnIG9yICdzaG9ydCcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmxvY2FsZSAtIFdoYXQgbG9jYWxlIHRvIHJldHVybiB0aGUgb2Zmc2V0IG5hbWUgaW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIG9mZnNldE5hbWUodHMsIG9wdHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmb3IgdGhpcyB6b25lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBjb21wdXRlIHRoZSBvZmZzZXRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgZXF1YWwgdG8gYW5vdGhlciB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge1pvbmV9IG90aGVyWm9uZSAtIHRoZSB6b25lIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js":
/*!*******************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/zones/IANAZone.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ IANAZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js\");\n\n\n\nconst dtfCache = new Map();\nfunction makeDTF(zoneName) {\n  let dtf = dtfCache.get(zoneName);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zoneName,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n    dtfCache.set(zoneName, dtf);\n  }\n  return dtf;\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nconst ianaZoneCache = new Map();\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nclass IANAZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    let zone = ianaZoneCache.get(name);\n    if (zone === undefined) {\n      ianaZoneCache.set(name, (zone = new IANAZone(name)));\n    }\n    return zone;\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache.clear();\n    dtfCache.clear();\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /**\n   * The type of zone. `iana` for all instances of `IANAZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"iana\";\n  }\n\n  /**\n   * The name of this zone (i.e. the IANA zone name).\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.zoneName;\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns false for all IANA zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return false;\n  }\n\n  /**\n   * Returns the offset's common name (such as EST) at the specified timestamp\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the name\n   * @param {Object} opts - Options to affect the format\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\n   * @param {string} opts.locale - What locale to return the offset name in.\n   * @return {string}\n   */\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale, this.name);\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    if (!this.valid) return NaN;\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.objToLocalTS)({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.valid;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9JQU5BWm9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUY7QUFDM0Q7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDLFlBQVksY0FBYztBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxVQUFVLDBEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ2UsdUJBQXVCLGdEQUFJO0FBQzFDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFKQUFxSjtBQUNySixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkMsV0FBVyw0REFBYTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLDJEQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLDJEQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvLCBpc1VuZGVmaW5lZCwgb2JqVG9Mb2NhbFRTIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxuY29uc3QgZHRmQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBtYWtlRFRGKHpvbmVOYW1lKSB7XG4gIGxldCBkdGYgPSBkdGZDYWNoZS5nZXQoem9uZU5hbWUpO1xuICBpZiAoZHRmID09PSB1bmRlZmluZWQpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogem9uZU5hbWUsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiLFxuICAgICAgZXJhOiBcInNob3J0XCIsXG4gICAgfSk7XG4gICAgZHRmQ2FjaGUuc2V0KHpvbmVOYW1lLCBkdGYpO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmNvbnN0IHR5cGVUb1BvcyA9IHtcbiAgeWVhcjogMCxcbiAgbW9udGg6IDEsXG4gIGRheTogMixcbiAgZXJhOiAzLFxuICBob3VyOiA0LFxuICBtaW51dGU6IDUsXG4gIHNlY29uZDogNixcbn07XG5cbmZ1bmN0aW9uIGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0KGRhdGUpLnJlcGxhY2UoL1xcdTIwMEUvZywgXCJcIiksXG4gICAgcGFyc2VkID0gLyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSAoQUR8QkMpLD8gKFxcZCspOihcXGQrKTooXFxkKykvLmV4ZWMoZm9ybWF0dGVkKSxcbiAgICBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWQ7XG4gIHJldHVybiBbZlllYXIsIGZNb250aCwgZkRheSwgZmFkT3JCYywgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdO1xufVxuXG5mdW5jdGlvbiBwYXJ0c09mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gIGNvbnN0IGZpbGxlZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IGZvcm1hdHRlZFtpXTtcbiAgICBjb25zdCBwb3MgPSB0eXBlVG9Qb3NbdHlwZV07XG5cbiAgICBpZiAodHlwZSA9PT0gXCJlcmFcIikge1xuICAgICAgZmlsbGVkW3Bvc10gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChwb3MpKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxsZWQ7XG59XG5cbmNvbnN0IGlhbmFab25lQ2FjaGUgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEEgem9uZSBpZGVudGlmaWVkIGJ5IGFuIElBTkEgaWRlbnRpZmllciwgbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSUFOQVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gWm9uZSBuYW1lXG4gICAqIEByZXR1cm4ge0lBTkFab25lfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShuYW1lKSB7XG4gICAgbGV0IHpvbmUgPSBpYW5hWm9uZUNhY2hlLmdldChuYW1lKTtcbiAgICBpZiAoem9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpYW5hWm9uZUNhY2hlLnNldChuYW1lLCAoem9uZSA9IG5ldyBJQU5BWm9uZShuYW1lKSkpO1xuICAgIH1cbiAgICByZXR1cm4gem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBsb2NhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIGlhbmFab25lQ2FjaGUuY2xlYXIoKTtcbiAgICBkdGZDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3BlY2lmaWVyLiBUaGlzIG9ubHkgY2hlY2tzIHRoZSBzdHJpbmcncyBmb3JtYXQsIG5vdCB0aGF0IHRoZSBzcGVjaWZpZXIgaWRlbnRpZmllcyBhIGtub3duIHpvbmU7IHNlZSBpc1ZhbGlkWm9uZSBmb3IgdGhhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNoZWNrIHZhbGlkaXR5IG9uXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQGRlcHJlY2F0ZWQgRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoaXMgZm9yd2FyZHMgdG8gaXNWYWxpZFpvbmUsIGJldHRlciB1c2UgYGlzVmFsaWRab25lKClgIGRpcmVjdGx5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFNwZWNpZmllcihzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFpvbmUocyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaWRlbnRpZmllcyBhIHJlYWwgem9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFRoZSBzdHJpbmcgdG8gY2hlY2tcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkZhbnRhc2lhL0Nhc3RsZVwiKSAvLz0+IGZhbHNlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkWm9uZSh6b25lKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVpvbmU6IHpvbmUgfSkuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMuem9uZU5hbWUgPSBuYW1lO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnZhbGlkID0gSUFOQVpvbmUuaXNWYWxpZFpvbmUobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygem9uZS4gYGlhbmFgIGZvciBhbGwgaW5zdGFuY2VzIG9mIGBJQU5BWm9uZWAuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaWFuYVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZSAoaS5lLiB0aGUgSUFOQSB6b25lIG5hbWUpLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhcjpcbiAgICogQWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGFsbCBJQU5BIHpvbmVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIGNvbW1vbiBuYW1lIChzdWNoIGFzIEVTVCkgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXBcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBhZmZlY3QgdGhlIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uIEFjY2VwdHMgJ2xvbmcnIG9yICdzaG9ydCcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmxvY2FsZSAtIFdoYXQgbG9jYWxlIHRvIHJldHVybiB0aGUgb2Zmc2V0IG5hbWUgaW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICBpZiAoIXRoaXMudmFsaWQpIHJldHVybiBOYU47XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKTtcblxuICAgIGlmIChpc05hTihkYXRlKSkgcmV0dXJuIE5hTjtcblxuICAgIGNvbnN0IGR0ZiA9IG1ha2VEVEYodGhpcy5uYW1lKTtcbiAgICBsZXQgW3llYXIsIG1vbnRoLCBkYXksIGFkT3JCYywgaG91ciwgbWludXRlLCBzZWNvbmRdID0gZHRmLmZvcm1hdFRvUGFydHNcbiAgICAgID8gcGFydHNPZmZzZXQoZHRmLCBkYXRlKVxuICAgICAgOiBoYWNreU9mZnNldChkdGYsIGRhdGUpO1xuXG4gICAgaWYgKGFkT3JCYyA9PT0gXCJCQ1wiKSB7XG4gICAgICB5ZWFyID0gLU1hdGguYWJzKHllYXIpICsgMTtcbiAgICB9XG5cbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHVzaW5nIGhvdXIxMiBhbmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyNTU2NCZjYW49MiZxPSUyMjI0JTNBMDAlMjIlMjBkYXRldGltZWZvcm1hdFxuICAgIGNvbnN0IGFkanVzdGVkSG91ciA9IGhvdXIgPT09IDI0ID8gMCA6IGhvdXI7XG5cbiAgICBjb25zdCBhc1VUQyA9IG9ialRvTG9jYWxUUyh7XG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXksXG4gICAgICBob3VyOiBhZGp1c3RlZEhvdXIsXG4gICAgICBtaW51dGUsXG4gICAgICBzZWNvbmQsXG4gICAgICBtaWxsaXNlY29uZDogMCxcbiAgICB9KTtcblxuICAgIGxldCBhc1RTID0gK2RhdGU7XG4gICAgY29uc3Qgb3ZlciA9IGFzVFMgJSAxMDAwO1xuICAgIGFzVFMgLT0gb3ZlciA+PSAwID8gb3ZlciA6IDEwMDAgKyBvdmVyO1xuICAgIHJldHVybiAoYXNVVEMgLSBhc1RTKSAvICg2MCAqIDEwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJpYW5hXCIgJiYgb3RoZXJab25lLm5hbWUgPT09IHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgdmFsaWQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/IANAZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js":
/*!**************************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FixedOffsetZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * A zone with a fixed offset (meaning no DST)\n * @implements {Zone}\n */\nclass FixedOffsetZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of UTC\n   * @return {FixedOffsetZone}\n   */\n  static get utcInstance() {\n    if (singleton === null) {\n      singleton = new FixedOffsetZone(0);\n    }\n    return singleton;\n  }\n\n  /**\n   * Get an instance with a specified offset\n   * @param {number} offset - The offset in minutes\n   * @return {FixedOffsetZone}\n   */\n  static instance(offset) {\n    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);\n  }\n\n  /**\n   * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n   * @param {string} s - The offset string to parse\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+6\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+06\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n   * @return {FixedOffsetZone}\n   */\n  static parseSpecifier(s) {\n    if (s) {\n      const r = s.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\n      if (r) {\n        return new FixedOffsetZone((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(r[1], r[2]));\n      }\n    }\n    return null;\n  }\n\n  constructor(offset) {\n    super();\n    /** @private **/\n    this.fixed = offset;\n  }\n\n  /**\n   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.\n   * @override\n   * @type {string}\n   */\n  get type() {\n    return \"fixed\";\n  }\n\n  /**\n   * The name of this zone.\n   * All fixed zones' names always start with \"UTC\" (plus optional offset)\n   * @override\n   * @type {string}\n   */\n  get name() {\n    return this.fixed === 0 ? \"UTC\" : `UTC${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, \"narrow\")}`;\n  }\n\n  /**\n   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`\n   *\n   * @override\n   * @type {string}\n   */\n  get ianaName() {\n    if (this.fixed === 0) {\n      return \"Etc/UTC\";\n    } else {\n      return `Etc/GMT${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(-this.fixed, \"narrow\")}`;\n    }\n  }\n\n  /**\n   * Returns the offset's common name at the specified timestamp.\n   *\n   * For fixed offset zones this equals to the zone name.\n   * @override\n   */\n  offsetName() {\n    return this.name;\n  }\n\n  /**\n   * Returns the offset's value as a string\n   * @override\n   * @param {number} ts - Epoch milliseconds for which to get the offset\n   * @param {string} format - What style of offset to return.\n   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n   * @return {string}\n   */\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, format);\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year:\n   * Always returns true for all fixed offset zones.\n   * @override\n   * @type {boolean}\n   */\n  get isUniversal() {\n    return true;\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   *\n   * For fixed offset zones, this is constant and does not depend on a timestamp.\n   * @override\n   * @return {number}\n   */\n  offset() {\n    return this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)\n   * @override\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    return otherZone.type === \"fixed\" && otherZone.fixed === this.fixed;\n  }\n\n  /**\n   * Return whether this Zone is valid:\n   * All fixed offset zones are valid.\n   * @override\n   * @type {boolean}\n   */\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9maXhlZE9mZnNldFpvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZEO0FBQy9COztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ2UsOEJBQThCLGdEQUFJO0FBQ2pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUksU0FBUyxFQUFFO0FBQ3ZEO0FBQ0EsbUNBQW1DLDJEQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0Q0FBNEMsMkRBQVksdUJBQXVCO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QiwyREFBWSx3QkFBd0I7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVywyREFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9maXhlZE9mZnNldFpvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBzaWduZWRPZmZzZXQgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBBIHpvbmUgd2l0aCBhIGZpeGVkIG9mZnNldCAobWVhbmluZyBubyBEU1QpXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRPZmZzZXRab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVVRDXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdXRjSW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgaW5zdGFuY2Uob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZSA6IG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRml4ZWRPZmZzZXRab25lIGZyb20gYSBVVEMgb2Zmc2V0IHN0cmluZywgbGlrZSBcIlVUQys2XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgb2Zmc2V0IHN0cmluZyB0byBwYXJzZVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrMDZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDLTY6MDBcIilcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlU3BlY2lmaWVyKHMpIHtcbiAgICBpZiAocykge1xuICAgICAgY29uc3QgciA9IHMubWF0Y2goL151dGMoPzooWystXVxcZHsxLDJ9KSg/OjooXFxkezJ9KSk/KT8kL2kpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE9mZnNldFpvbmUoc2lnbmVkT2Zmc2V0KHJbMV0sIHJbMl0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLmZpeGVkID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmUuIGBmaXhlZGAgZm9yIGFsbCBpbnN0YW5jZXMgb2YgYEZpeGVkT2Zmc2V0Wm9uZWAuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZml4ZWRcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIEFsbCBmaXhlZCB6b25lcycgbmFtZXMgYWx3YXlzIHN0YXJ0IHdpdGggXCJVVENcIiAocGx1cyBvcHRpb25hbCBvZmZzZXQpXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQgPT09IDAgPyBcIlVUQ1wiIDogYFVUQyR7Zm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIFwibmFycm93XCIpfWA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIElBTkEgbmFtZSBvZiB0aGlzIHpvbmUsIGkuZS4gYEV0Yy9VVENgIG9yIGBFdGMvR01UKy8tbm5gXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIGlmICh0aGlzLmZpeGVkID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJFdGMvVVRDXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgRXRjL0dNVCR7Zm9ybWF0T2Zmc2V0KC10aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyBjb21tb24gbmFtZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICpcbiAgICogRm9yIGZpeGVkIG9mZnNldCB6b25lcyB0aGlzIGVxdWFscyB0byB0aGUgem9uZSBuYW1lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIGZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyOlxuICAgKiBBbHdheXMgcmV0dXJucyB0cnVlIGZvciBhbGwgZml4ZWQgb2Zmc2V0IHpvbmVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmb3IgdGhpcyB6b25lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKlxuICAgKiBGb3IgZml4ZWQgb2Zmc2V0IHpvbmVzLCB0aGlzIGlzIGNvbnN0YW50IGFuZCBkb2VzIG5vdCBkZXBlbmQgb24gYSB0aW1lc3RhbXAuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZSAoaS5lLiBhbHNvIGZpeGVkIGFuZCBzYW1lIG9mZnNldClcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJmaXhlZFwiICYmIG90aGVyWm9uZS5maXhlZCA9PT0gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgdmFsaWQ6XG4gICAqIEFsbCBmaXhlZCBvZmZzZXQgem9uZXMgYXJlIHZhbGlkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/fixedOffsetZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/invalidZone.js":
/*!**********************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/zones/invalidZone.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InvalidZone)\n/* harmony export */ });\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js\");\n\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n * @implements {Zone}\n */\nclass InvalidZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(zoneName) {\n    super();\n    /**  @private */\n    this.zoneName = zoneName;\n  }\n\n  /** @override **/\n  get type() {\n    return \"invalid\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName() {\n    return null;\n  }\n\n  /** @override **/\n  formatOffset() {\n    return \"\";\n  }\n\n  /** @override **/\n  offset() {\n    return NaN;\n  }\n\n  /** @override **/\n  equals() {\n    return false;\n  }\n\n  /** @override **/\n  get isValid() {\n    return false;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9pbnZhbGlkWm9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNlLDBCQUEwQixnREFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvaW52YWxpZFpvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxuLyoqXG4gKiBBIHpvbmUgdGhhdCBmYWlsZWQgdG8gcGFyc2UuIFlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWRab25lIGV4dGVuZHMgWm9uZSB7XG4gIGNvbnN0cnVjdG9yKHpvbmVOYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogIEBwcml2YXRlICovXG4gICAgdGhpcy56b25lTmFtZSA9IHpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaW52YWxpZFwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/invalidZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/systemZone.js":
/*!*********************************************************************!*\
  !*** ../fjell-providers/node_modules/luxon/src/zones/systemZone.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SystemZone)\n/* harmony export */ });\n/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/impl/util.js\");\n/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ \"(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zone.js\");\n\n\n\nlet singleton = null;\n\n/**\n * Represents the local zone for this JavaScript environment.\n * @implements {Zone}\n */\nclass SystemZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * Get a singleton instance of the local zone\n   * @return {SystemZone}\n   */\n  static get instance() {\n    if (singleton === null) {\n      singleton = new SystemZone();\n    }\n    return singleton;\n  }\n\n  /** @override **/\n  get type() {\n    return \"system\";\n  }\n\n  /** @override **/\n  get name() {\n    return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    return -new Date(ts).getTimezoneOffset();\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"system\";\n  }\n\n  /** @override **/\n  get isValid() {\n    return true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9mamVsbC1wcm92aWRlcnMvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9zeXN0ZW1ab25lLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RDtBQUNoQzs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNlLHlCQUF5QixnREFBSTtBQUM1QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQyxXQUFXLDREQUFhO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDJEQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtcHJvdmlkZXJzL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvc3lzdGVtWm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8gfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB6b25lIGZvciB0aGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAqIEByZXR1cm4ge1N5c3RlbVpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBTeXN0ZW1ab25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgcmV0dXJuIC1uZXcgRGF0ZSh0cykuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../fjell-providers/node_modules/luxon/src/zones/systemZone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXNhbXBsZS1hcHAvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtc2FtcGxlLWFwcC9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgQnVmZmVyLmZyb20oYnVmKS5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbic7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftobrien%2Fgitw%2Fgetfjell%2Ffjell-sample-app%2Fsrc%2Fclient%2Fpages%2FHome.tsx%22%2C%22ids%22%3A%5B%22Home%22%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftobrien%2Fgitw%2Fgetfjell%2Ffjell-sample-app%2Fsrc%2Fclient%2Fpages%2FHome.tsx%22%2C%22ids%22%3A%5B%22Home%22%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/client/pages/Home.tsx */ \"(app-pages-browser)/./src/client/pages/Home.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZ0b2JyaWVuJTJGZ2l0dyUyRmdldGZqZWxsJTJGZmplbGwtc2FtcGxlLWFwcCUyRnNyYyUyRmNsaWVudCUyRnBhZ2VzJTJGSG9tZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJIb21lJTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsZ0xBQXNJIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJIb21lXCJdICovIFwiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL3NyYy9jbGllbnQvcGFnZXMvSG9tZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftobrien%2Fgitw%2Fgetfjell%2Ffjell-sample-app%2Fsrc%2Fclient%2Fpages%2FHome.tsx%22%2C%22ids%22%3A%5B%22Home%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMs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Q0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtc2FtcGxlLWFwcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(function(){var r={992:function(r){r.exports=function(r,t,n){if(r.filter)return r.filter(t,n);if(void 0===r||null===r)throw new TypeError;if(\"function\"!=typeof t)throw new TypeError;var o=[];for(var i=0;i<r.length;i++){if(!e.call(r,i))continue;var a=r[i];if(t.call(n,a,i,r))o.push(a)}return o};var e=Object.prototype.hasOwnProperty},256:function(r,e,t){\"use strict\";var n=t(192);var o=t(139);var i=o(n(\"String.prototype.indexOf\"));r.exports=function callBoundIntrinsic(r,e){var t=n(r,!!e);if(typeof t===\"function\"&&i(r,\".prototype.\")>-1){return o(t)}return t}},139:function(r,e,t){\"use strict\";var n=t(212);var o=t(192);var i=o(\"%Function.prototype.apply%\");var a=o(\"%Function.prototype.call%\");var f=o(\"%Reflect.apply%\",true)||n.call(a,i);var u=o(\"%Object.getOwnPropertyDescriptor%\",true);var s=o(\"%Object.defineProperty%\",true);var c=o(\"%Math.max%\");if(s){try{s({},\"a\",{value:1})}catch(r){s=null}}r.exports=function callBind(r){var e=f(n,a,arguments);if(u&&s){var t=u(e,\"length\");if(t.configurable){s(e,\"length\",{value:1+c(0,r.length-(arguments.length-1))})}}return e};var y=function applyBind(){return f(n,i,arguments)};if(s){s(r.exports,\"apply\",{value:y})}else{r.exports.apply=y}},181:function(r){\"use strict\";r.exports=EvalError},545:function(r){\"use strict\";r.exports=Error},22:function(r){\"use strict\";r.exports=RangeError},803:function(r){\"use strict\";r.exports=ReferenceError},182:function(r){\"use strict\";r.exports=SyntaxError},202:function(r){\"use strict\";r.exports=TypeError},284:function(r){\"use strict\";r.exports=URIError},144:function(r){var e=Object.prototype.hasOwnProperty;var t=Object.prototype.toString;r.exports=function forEach(r,n,o){if(t.call(n)!==\"[object Function]\"){throw new TypeError(\"iterator must be a function\")}var i=r.length;if(i===+i){for(var a=0;a<i;a++){n.call(o,r[a],a,r)}}else{for(var f in r){if(e.call(r,f)){n.call(o,r[f],f,r)}}}}},136:function(r){\"use strict\";var e=\"Function.prototype.bind called on incompatible \";var t=Object.prototype.toString;var n=Math.max;var o=\"[object Function]\";var i=function concatty(r,e){var t=[];for(var n=0;n<r.length;n+=1){t[n]=r[n]}for(var o=0;o<e.length;o+=1){t[o+r.length]=e[o]}return t};var a=function slicy(r,e){var t=[];for(var n=e||0,o=0;n<r.length;n+=1,o+=1){t[o]=r[n]}return t};var joiny=function(r,e){var t=\"\";for(var n=0;n<r.length;n+=1){t+=r[n];if(n+1<r.length){t+=e}}return t};r.exports=function bind(r){var f=this;if(typeof f!==\"function\"||t.apply(f)!==o){throw new TypeError(e+f)}var u=a(arguments,1);var s;var binder=function(){if(this instanceof s){var e=f.apply(this,i(u,arguments));if(Object(e)===e){return e}return this}return f.apply(r,i(u,arguments))};var c=n(0,f.length-u.length);var y=[];for(var p=0;p<c;p++){y[p]=\"$\"+p}s=Function(\"binder\",\"return function (\"+joiny(y,\",\")+\"){ return binder.apply(this,arguments); }\")(binder);if(f.prototype){var l=function Empty(){};l.prototype=f.prototype;s.prototype=new l;l.prototype=null}return s}},212:function(r,e,t){\"use strict\";var n=t(136);r.exports=Function.prototype.bind||n},192:function(r,e,t){\"use strict\";var n;var o=t(545);var i=t(181);var a=t(22);var f=t(803);var u=t(182);var s=t(202);var c=t(284);var y=Function;var getEvalledConstructor=function(r){try{return y('\"use strict\"; return ('+r+\").constructor;\")()}catch(r){}};var p=Object.getOwnPropertyDescriptor;if(p){try{p({},\"\")}catch(r){p=null}}var throwTypeError=function(){throw new s};var l=p?function(){try{arguments.callee;return throwTypeError}catch(r){try{return p(arguments,\"callee\").get}catch(r){return throwTypeError}}}():throwTypeError;var g=t(115)();var v=t(14)();var b=Object.getPrototypeOf||(v?function(r){return r.__proto__}:null);var d={};var m=typeof Uint8Array===\"undefined\"||!b?n:b(Uint8Array);var S={__proto__:null,\"%AggregateError%\":typeof AggregateError===\"undefined\"?n:AggregateError,\"%Array%\":Array,\"%ArrayBuffer%\":typeof ArrayBuffer===\"undefined\"?n:ArrayBuffer,\"%ArrayIteratorPrototype%\":g&&b?b([][Symbol.iterator]()):n,\"%AsyncFromSyncIteratorPrototype%\":n,\"%AsyncFunction%\":d,\"%AsyncGenerator%\":d,\"%AsyncGeneratorFunction%\":d,\"%AsyncIteratorPrototype%\":d,\"%Atomics%\":typeof Atomics===\"undefined\"?n:Atomics,\"%BigInt%\":typeof BigInt===\"undefined\"?n:BigInt,\"%BigInt64Array%\":typeof BigInt64Array===\"undefined\"?n:BigInt64Array,\"%BigUint64Array%\":typeof BigUint64Array===\"undefined\"?n:BigUint64Array,\"%Boolean%\":Boolean,\"%DataView%\":typeof DataView===\"undefined\"?n:DataView,\"%Date%\":Date,\"%decodeURI%\":decodeURI,\"%decodeURIComponent%\":decodeURIComponent,\"%encodeURI%\":encodeURI,\"%encodeURIComponent%\":encodeURIComponent,\"%Error%\":o,\"%eval%\":eval,\"%EvalError%\":i,\"%Float32Array%\":typeof Float32Array===\"undefined\"?n:Float32Array,\"%Float64Array%\":typeof Float64Array===\"undefined\"?n:Float64Array,\"%FinalizationRegistry%\":typeof FinalizationRegistry===\"undefined\"?n:FinalizationRegistry,\"%Function%\":y,\"%GeneratorFunction%\":d,\"%Int8Array%\":typeof Int8Array===\"undefined\"?n:Int8Array,\"%Int16Array%\":typeof Int16Array===\"undefined\"?n:Int16Array,\"%Int32Array%\":typeof Int32Array===\"undefined\"?n:Int32Array,\"%isFinite%\":isFinite,\"%isNaN%\":isNaN,\"%IteratorPrototype%\":g&&b?b(b([][Symbol.iterator]())):n,\"%JSON%\":typeof JSON===\"object\"?JSON:n,\"%Map%\":typeof Map===\"undefined\"?n:Map,\"%MapIteratorPrototype%\":typeof Map===\"undefined\"||!g||!b?n:b((new Map)[Symbol.iterator]()),\"%Math%\":Math,\"%Number%\":Number,\"%Object%\":Object,\"%parseFloat%\":parseFloat,\"%parseInt%\":parseInt,\"%Promise%\":typeof Promise===\"undefined\"?n:Promise,\"%Proxy%\":typeof Proxy===\"undefined\"?n:Proxy,\"%RangeError%\":a,\"%ReferenceError%\":f,\"%Reflect%\":typeof Reflect===\"undefined\"?n:Reflect,\"%RegExp%\":RegExp,\"%Set%\":typeof Set===\"undefined\"?n:Set,\"%SetIteratorPrototype%\":typeof Set===\"undefined\"||!g||!b?n:b((new Set)[Symbol.iterator]()),\"%SharedArrayBuffer%\":typeof SharedArrayBuffer===\"undefined\"?n:SharedArrayBuffer,\"%String%\":String,\"%StringIteratorPrototype%\":g&&b?b(\"\"[Symbol.iterator]()):n,\"%Symbol%\":g?Symbol:n,\"%SyntaxError%\":u,\"%ThrowTypeError%\":l,\"%TypedArray%\":m,\"%TypeError%\":s,\"%Uint8Array%\":typeof Uint8Array===\"undefined\"?n:Uint8Array,\"%Uint8ClampedArray%\":typeof Uint8ClampedArray===\"undefined\"?n:Uint8ClampedArray,\"%Uint16Array%\":typeof Uint16Array===\"undefined\"?n:Uint16Array,\"%Uint32Array%\":typeof Uint32Array===\"undefined\"?n:Uint32Array,\"%URIError%\":c,\"%WeakMap%\":typeof WeakMap===\"undefined\"?n:WeakMap,\"%WeakRef%\":typeof WeakRef===\"undefined\"?n:WeakRef,\"%WeakSet%\":typeof WeakSet===\"undefined\"?n:WeakSet};if(b){try{null.error}catch(r){var A=b(b(r));S[\"%Error.prototype%\"]=A}}var h=function doEval(r){var e;if(r===\"%AsyncFunction%\"){e=getEvalledConstructor(\"async function () {}\")}else if(r===\"%GeneratorFunction%\"){e=getEvalledConstructor(\"function* () {}\")}else if(r===\"%AsyncGeneratorFunction%\"){e=getEvalledConstructor(\"async function* () {}\")}else if(r===\"%AsyncGenerator%\"){var t=doEval(\"%AsyncGeneratorFunction%\");if(t){e=t.prototype}}else if(r===\"%AsyncIteratorPrototype%\"){var n=doEval(\"%AsyncGenerator%\");if(n&&b){e=b(n.prototype)}}S[r]=e;return e};var O={__proto__:null,\"%ArrayBufferPrototype%\":[\"ArrayBuffer\",\"prototype\"],\"%ArrayPrototype%\":[\"Array\",\"prototype\"],\"%ArrayProto_entries%\":[\"Array\",\"prototype\",\"entries\"],\"%ArrayProto_forEach%\":[\"Array\",\"prototype\",\"forEach\"],\"%ArrayProto_keys%\":[\"Array\",\"prototype\",\"keys\"],\"%ArrayProto_values%\":[\"Array\",\"prototype\",\"values\"],\"%AsyncFunctionPrototype%\":[\"AsyncFunction\",\"prototype\"],\"%AsyncGenerator%\":[\"AsyncGeneratorFunction\",\"prototype\"],\"%AsyncGeneratorPrototype%\":[\"AsyncGeneratorFunction\",\"prototype\",\"prototype\"],\"%BooleanPrototype%\":[\"Boolean\",\"prototype\"],\"%DataViewPrototype%\":[\"DataView\",\"prototype\"],\"%DatePrototype%\":[\"Date\",\"prototype\"],\"%ErrorPrototype%\":[\"Error\",\"prototype\"],\"%EvalErrorPrototype%\":[\"EvalError\",\"prototype\"],\"%Float32ArrayPrototype%\":[\"Float32Array\",\"prototype\"],\"%Float64ArrayPrototype%\":[\"Float64Array\",\"prototype\"],\"%FunctionPrototype%\":[\"Function\",\"prototype\"],\"%Generator%\":[\"GeneratorFunction\",\"prototype\"],\"%GeneratorPrototype%\":[\"GeneratorFunction\",\"prototype\",\"prototype\"],\"%Int8ArrayPrototype%\":[\"Int8Array\",\"prototype\"],\"%Int16ArrayPrototype%\":[\"Int16Array\",\"prototype\"],\"%Int32ArrayPrototype%\":[\"Int32Array\",\"prototype\"],\"%JSONParse%\":[\"JSON\",\"parse\"],\"%JSONStringify%\":[\"JSON\",\"stringify\"],\"%MapPrototype%\":[\"Map\",\"prototype\"],\"%NumberPrototype%\":[\"Number\",\"prototype\"],\"%ObjectPrototype%\":[\"Object\",\"prototype\"],\"%ObjProto_toString%\":[\"Object\",\"prototype\",\"toString\"],\"%ObjProto_valueOf%\":[\"Object\",\"prototype\",\"valueOf\"],\"%PromisePrototype%\":[\"Promise\",\"prototype\"],\"%PromiseProto_then%\":[\"Promise\",\"prototype\",\"then\"],\"%Promise_all%\":[\"Promise\",\"all\"],\"%Promise_reject%\":[\"Promise\",\"reject\"],\"%Promise_resolve%\":[\"Promise\",\"resolve\"],\"%RangeErrorPrototype%\":[\"RangeError\",\"prototype\"],\"%ReferenceErrorPrototype%\":[\"ReferenceError\",\"prototype\"],\"%RegExpPrototype%\":[\"RegExp\",\"prototype\"],\"%SetPrototype%\":[\"Set\",\"prototype\"],\"%SharedArrayBufferPrototype%\":[\"SharedArrayBuffer\",\"prototype\"],\"%StringPrototype%\":[\"String\",\"prototype\"],\"%SymbolPrototype%\":[\"Symbol\",\"prototype\"],\"%SyntaxErrorPrototype%\":[\"SyntaxError\",\"prototype\"],\"%TypedArrayPrototype%\":[\"TypedArray\",\"prototype\"],\"%TypeErrorPrototype%\":[\"TypeError\",\"prototype\"],\"%Uint8ArrayPrototype%\":[\"Uint8Array\",\"prototype\"],\"%Uint8ClampedArrayPrototype%\":[\"Uint8ClampedArray\",\"prototype\"],\"%Uint16ArrayPrototype%\":[\"Uint16Array\",\"prototype\"],\"%Uint32ArrayPrototype%\":[\"Uint32Array\",\"prototype\"],\"%URIErrorPrototype%\":[\"URIError\",\"prototype\"],\"%WeakMapPrototype%\":[\"WeakMap\",\"prototype\"],\"%WeakSetPrototype%\":[\"WeakSet\",\"prototype\"]};var j=t(212);var w=t(270);var P=j.call(Function.call,Array.prototype.concat);var B=j.call(Function.apply,Array.prototype.splice);var E=j.call(Function.call,String.prototype.replace);var x=j.call(Function.call,String.prototype.slice);var T=j.call(Function.call,RegExp.prototype.exec);var I=/[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;var k=/\\\\(\\\\)?/g;var F=function stringToPath(r){var e=x(r,0,1);var t=x(r,-1);if(e===\"%\"&&t!==\"%\"){throw new u(\"invalid intrinsic syntax, expected closing `%`\")}else if(t===\"%\"&&e!==\"%\"){throw new u(\"invalid intrinsic syntax, expected opening `%`\")}var n=[];E(r,I,(function(r,e,t,o){n[n.length]=t?E(o,k,\"$1\"):e||r}));return n};var U=function getBaseIntrinsic(r,e){var t=r;var n;if(w(O,t)){n=O[t];t=\"%\"+n[0]+\"%\"}if(w(S,t)){var o=S[t];if(o===d){o=h(t)}if(typeof o===\"undefined\"&&!e){throw new s(\"intrinsic \"+r+\" exists, but is not available. Please file an issue!\")}return{alias:n,name:t,value:o}}throw new u(\"intrinsic \"+r+\" does not exist!\")};r.exports=function GetIntrinsic(r,e){if(typeof r!==\"string\"||r.length===0){throw new s(\"intrinsic name must be a non-empty string\")}if(arguments.length>1&&typeof e!==\"boolean\"){throw new s('\"allowMissing\" argument must be a boolean')}if(T(/^%?[^%]*%?$/,r)===null){throw new u(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\")}var t=F(r);var o=t.length>0?t[0]:\"\";var i=U(\"%\"+o+\"%\",e);var a=i.name;var f=i.value;var c=false;var y=i.alias;if(y){o=y[0];B(t,P([0,1],y))}for(var l=1,g=true;l<t.length;l+=1){var v=t[l];var b=x(v,0,1);var d=x(v,-1);if((b==='\"'||b===\"'\"||b===\"`\"||(d==='\"'||d===\"'\"||d===\"`\"))&&b!==d){throw new u(\"property names with quotes must have matching quotes\")}if(v===\"constructor\"||!g){c=true}o+=\".\"+v;a=\"%\"+o+\"%\";if(w(S,a)){f=S[a]}else if(f!=null){if(!(v in f)){if(!e){throw new s(\"base intrinsic for \"+r+\" exists, but the property is not available.\")}return void n}if(p&&l+1>=t.length){var m=p(f,v);g=!!m;if(g&&\"get\"in m&&!(\"originalValue\"in m.get)){f=m.get}else{f=f[v]}}else{g=w(f,v);f=f[v]}if(g&&!c){S[a]=f}}}return f}},14:function(r){\"use strict\";var e={__proto__:null,foo:{}};var t=Object;r.exports=function hasProto(){return{__proto__:e}.foo===e.foo&&!(e instanceof t)}},942:function(r,e,t){\"use strict\";var n=typeof Symbol!==\"undefined\"&&Symbol;var o=t(773);r.exports=function hasNativeSymbols(){if(typeof n!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof n(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return o()}},773:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var n=42;r[e]=n;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var o=Object.getOwnPropertySymbols(r);if(o.length!==1||o[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==n||i.enumerable!==true){return false}}return true}},115:function(r,e,t){\"use strict\";var n=typeof Symbol!==\"undefined\"&&Symbol;var o=t(832);r.exports=function hasNativeSymbols(){if(typeof n!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof n(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return o()}},832:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var n=42;r[e]=n;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var o=Object.getOwnPropertySymbols(r);if(o.length!==1||o[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==n||i.enumerable!==true){return false}}return true}},270:function(r,e,t){\"use strict\";var n=Function.prototype.call;var o=Object.prototype.hasOwnProperty;var i=t(212);r.exports=i.call(n,o)},782:function(r){if(typeof Object.create===\"function\"){r.exports=function inherits(r,e){if(e){r.super_=e;r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:false,writable:true,configurable:true}})}}}else{r.exports=function inherits(r,e){if(e){r.super_=e;var TempCtor=function(){};TempCtor.prototype=e.prototype;r.prototype=new TempCtor;r.prototype.constructor=r}}}},157:function(r){\"use strict\";var e=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var t=Object.prototype.toString;var n=function isArguments(r){if(e&&r&&typeof r===\"object\"&&Symbol.toStringTag in r){return false}return t.call(r)===\"[object Arguments]\"};var o=function isArguments(r){if(n(r)){return true}return r!==null&&typeof r===\"object\"&&typeof r.length===\"number\"&&r.length>=0&&t.call(r)!==\"[object Array]\"&&t.call(r.callee)===\"[object Function]\"};var i=function(){return n(arguments)}();n.isLegacyArguments=o;r.exports=i?n:o},391:function(r){\"use strict\";var e=Object.prototype.toString;var t=Function.prototype.toString;var n=/^\\s*(?:function)?\\*/;var o=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var i=Object.getPrototypeOf;var getGeneratorFunc=function(){if(!o){return false}try{return Function(\"return function*() {}\")()}catch(r){}};var a=getGeneratorFunc();var f=a?i(a):{};r.exports=function isGeneratorFunction(r){if(typeof r!==\"function\"){return false}if(n.test(t.call(r))){return true}if(!o){var a=e.call(r);return a===\"[object GeneratorFunction]\"}return i(r)===f}},994:function(r,e,t){\"use strict\";var n=t(144);var o=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var f=t(942)();var u=f&&typeof Symbol.toStringTag===\"symbol\";var s=o();var c=i(\"Array.prototype.indexOf\",true)||function indexOf(r,e){for(var t=0;t<r.length;t+=1){if(r[t]===e){return t}}return-1};var y=i(\"String.prototype.slice\");var p={};var l=t(24);var g=Object.getPrototypeOf;if(u&&l&&g){n(s,(function(r){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=g(e);var n=l(t,Symbol.toStringTag);if(!n){var o=g(t);n=l(o,Symbol.toStringTag)}p[r]=n.get}))}var v=function tryAllTypedArrays(r){var e=false;n(p,(function(t,n){if(!e){try{e=t.call(r)===n}catch(r){}}}));return e};r.exports=function isTypedArray(r){if(!r||typeof r!==\"object\"){return false}if(!u){var e=y(a(r),8,-1);return c(s,e)>-1}if(!l){return false}return v(r)}},369:function(r){r.exports=function isBuffer(r){return r instanceof Buffer}},584:function(r,e,t){\"use strict\";var n=t(157);var o=t(391);var i=t(490);var a=t(994);function uncurryThis(r){return r.call.bind(r)}var f=typeof BigInt!==\"undefined\";var u=typeof Symbol!==\"undefined\";var s=uncurryThis(Object.prototype.toString);var c=uncurryThis(Number.prototype.valueOf);var y=uncurryThis(String.prototype.valueOf);var p=uncurryThis(Boolean.prototype.valueOf);if(f){var l=uncurryThis(BigInt.prototype.valueOf)}if(u){var g=uncurryThis(Symbol.prototype.valueOf)}function checkBoxedPrimitive(r,e){if(typeof r!==\"object\"){return false}try{e(r);return true}catch(r){return false}}e.isArgumentsObject=n;e.isGeneratorFunction=o;e.isTypedArray=a;function isPromise(r){return typeof Promise!==\"undefined\"&&r instanceof Promise||r!==null&&typeof r===\"object\"&&typeof r.then===\"function\"&&typeof r.catch===\"function\"}e.isPromise=isPromise;function isArrayBufferView(r){if(typeof ArrayBuffer!==\"undefined\"&&ArrayBuffer.isView){return ArrayBuffer.isView(r)}return a(r)||isDataView(r)}e.isArrayBufferView=isArrayBufferView;function isUint8Array(r){return i(r)===\"Uint8Array\"}e.isUint8Array=isUint8Array;function isUint8ClampedArray(r){return i(r)===\"Uint8ClampedArray\"}e.isUint8ClampedArray=isUint8ClampedArray;function isUint16Array(r){return i(r)===\"Uint16Array\"}e.isUint16Array=isUint16Array;function isUint32Array(r){return i(r)===\"Uint32Array\"}e.isUint32Array=isUint32Array;function isInt8Array(r){return i(r)===\"Int8Array\"}e.isInt8Array=isInt8Array;function isInt16Array(r){return i(r)===\"Int16Array\"}e.isInt16Array=isInt16Array;function isInt32Array(r){return i(r)===\"Int32Array\"}e.isInt32Array=isInt32Array;function isFloat32Array(r){return i(r)===\"Float32Array\"}e.isFloat32Array=isFloat32Array;function isFloat64Array(r){return i(r)===\"Float64Array\"}e.isFloat64Array=isFloat64Array;function isBigInt64Array(r){return i(r)===\"BigInt64Array\"}e.isBigInt64Array=isBigInt64Array;function isBigUint64Array(r){return i(r)===\"BigUint64Array\"}e.isBigUint64Array=isBigUint64Array;function isMapToString(r){return s(r)===\"[object Map]\"}isMapToString.working=typeof Map!==\"undefined\"&&isMapToString(new Map);function isMap(r){if(typeof Map===\"undefined\"){return false}return isMapToString.working?isMapToString(r):r instanceof Map}e.isMap=isMap;function isSetToString(r){return s(r)===\"[object Set]\"}isSetToString.working=typeof Set!==\"undefined\"&&isSetToString(new Set);function isSet(r){if(typeof Set===\"undefined\"){return false}return isSetToString.working?isSetToString(r):r instanceof Set}e.isSet=isSet;function isWeakMapToString(r){return s(r)===\"[object WeakMap]\"}isWeakMapToString.working=typeof WeakMap!==\"undefined\"&&isWeakMapToString(new WeakMap);function isWeakMap(r){if(typeof WeakMap===\"undefined\"){return false}return isWeakMapToString.working?isWeakMapToString(r):r instanceof WeakMap}e.isWeakMap=isWeakMap;function isWeakSetToString(r){return s(r)===\"[object WeakSet]\"}isWeakSetToString.working=typeof WeakSet!==\"undefined\"&&isWeakSetToString(new WeakSet);function isWeakSet(r){return isWeakSetToString(r)}e.isWeakSet=isWeakSet;function isArrayBufferToString(r){return s(r)===\"[object ArrayBuffer]\"}isArrayBufferToString.working=typeof ArrayBuffer!==\"undefined\"&&isArrayBufferToString(new ArrayBuffer);function isArrayBuffer(r){if(typeof ArrayBuffer===\"undefined\"){return false}return isArrayBufferToString.working?isArrayBufferToString(r):r instanceof ArrayBuffer}e.isArrayBuffer=isArrayBuffer;function isDataViewToString(r){return s(r)===\"[object DataView]\"}isDataViewToString.working=typeof ArrayBuffer!==\"undefined\"&&typeof DataView!==\"undefined\"&&isDataViewToString(new DataView(new ArrayBuffer(1),0,1));function isDataView(r){if(typeof DataView===\"undefined\"){return false}return isDataViewToString.working?isDataViewToString(r):r instanceof DataView}e.isDataView=isDataView;var v=typeof SharedArrayBuffer!==\"undefined\"?SharedArrayBuffer:undefined;function isSharedArrayBufferToString(r){return s(r)===\"[object SharedArrayBuffer]\"}function isSharedArrayBuffer(r){if(typeof v===\"undefined\"){return false}if(typeof isSharedArrayBufferToString.working===\"undefined\"){isSharedArrayBufferToString.working=isSharedArrayBufferToString(new v)}return isSharedArrayBufferToString.working?isSharedArrayBufferToString(r):r instanceof v}e.isSharedArrayBuffer=isSharedArrayBuffer;function isAsyncFunction(r){return s(r)===\"[object AsyncFunction]\"}e.isAsyncFunction=isAsyncFunction;function isMapIterator(r){return s(r)===\"[object Map Iterator]\"}e.isMapIterator=isMapIterator;function isSetIterator(r){return s(r)===\"[object Set Iterator]\"}e.isSetIterator=isSetIterator;function isGeneratorObject(r){return s(r)===\"[object Generator]\"}e.isGeneratorObject=isGeneratorObject;function isWebAssemblyCompiledModule(r){return s(r)===\"[object WebAssembly.Module]\"}e.isWebAssemblyCompiledModule=isWebAssemblyCompiledModule;function isNumberObject(r){return checkBoxedPrimitive(r,c)}e.isNumberObject=isNumberObject;function isStringObject(r){return checkBoxedPrimitive(r,y)}e.isStringObject=isStringObject;function isBooleanObject(r){return checkBoxedPrimitive(r,p)}e.isBooleanObject=isBooleanObject;function isBigIntObject(r){return f&&checkBoxedPrimitive(r,l)}e.isBigIntObject=isBigIntObject;function isSymbolObject(r){return u&&checkBoxedPrimitive(r,g)}e.isSymbolObject=isSymbolObject;function isBoxedPrimitive(r){return isNumberObject(r)||isStringObject(r)||isBooleanObject(r)||isBigIntObject(r)||isSymbolObject(r)}e.isBoxedPrimitive=isBoxedPrimitive;function isAnyArrayBuffer(r){return typeof Uint8Array!==\"undefined\"&&(isArrayBuffer(r)||isSharedArrayBuffer(r))}e.isAnyArrayBuffer=isAnyArrayBuffer;[\"isProxy\",\"isExternal\",\"isModuleNamespaceObject\"].forEach((function(r){Object.defineProperty(e,r,{enumerable:false,value:function(){throw new Error(r+\" is not supported in userland\")}})}))},177:function(r,e,t){var n=Object.getOwnPropertyDescriptors||function getOwnPropertyDescriptors(r){var e=Object.keys(r);var t={};for(var n=0;n<e.length;n++){t[e[n]]=Object.getOwnPropertyDescriptor(r,e[n])}return t};var o=/%[sdj%]/g;e.format=function(r){if(!isString(r)){var e=[];for(var t=0;t<arguments.length;t++){e.push(inspect(arguments[t]))}return e.join(\" \")}var t=1;var n=arguments;var i=n.length;var a=String(r).replace(o,(function(r){if(r===\"%%\")return\"%\";if(t>=i)return r;switch(r){case\"%s\":return String(n[t++]);case\"%d\":return Number(n[t++]);case\"%j\":try{return JSON.stringify(n[t++])}catch(r){return\"[Circular]\"}default:return r}}));for(var f=n[t];t<i;f=n[++t]){if(isNull(f)||!isObject(f)){a+=\" \"+f}else{a+=\" \"+inspect(f)}}return a};e.deprecate=function(r,t){if(typeof process!==\"undefined\"&&process.noDeprecation===true){return r}if(typeof process===\"undefined\"){return function(){return e.deprecate(r,t).apply(this,arguments)}}var n=false;function deprecated(){if(!n){if(process.throwDeprecation){throw new Error(t)}else if(process.traceDeprecation){console.trace(t)}else{console.error(t)}n=true}return r.apply(this,arguments)}return deprecated};var i={};var a=/^$/;if(process.env.NODE_DEBUG){var f=process.env.NODE_DEBUG;f=f.replace(/[|\\\\{}()[\\]^$+?.]/g,\"\\\\$&\").replace(/\\*/g,\".*\").replace(/,/g,\"$|^\").toUpperCase();a=new RegExp(\"^\"+f+\"$\",\"i\")}e.debuglog=function(r){r=r.toUpperCase();if(!i[r]){if(a.test(r)){var t=process.pid;i[r]=function(){var n=e.format.apply(e,arguments);console.error(\"%s %d: %s\",r,t,n)}}else{i[r]=function(){}}}return i[r]};function inspect(r,t){var n={seen:[],stylize:stylizeNoColor};if(arguments.length>=3)n.depth=arguments[2];if(arguments.length>=4)n.colors=arguments[3];if(isBoolean(t)){n.showHidden=t}else if(t){e._extend(n,t)}if(isUndefined(n.showHidden))n.showHidden=false;if(isUndefined(n.depth))n.depth=2;if(isUndefined(n.colors))n.colors=false;if(isUndefined(n.customInspect))n.customInspect=true;if(n.colors)n.stylize=stylizeWithColor;return formatValue(n,r,n.depth)}e.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:\"cyan\",number:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"};function stylizeWithColor(r,e){var t=inspect.styles[e];if(t){return\"\u001b[\"+inspect.colors[t][0]+\"m\"+r+\"\u001b[\"+inspect.colors[t][1]+\"m\"}else{return r}}function stylizeNoColor(r,e){return r}function arrayToHash(r){var e={};r.forEach((function(r,t){e[r]=true}));return e}function formatValue(r,t,n){if(r.customInspect&&t&&isFunction(t.inspect)&&t.inspect!==e.inspect&&!(t.constructor&&t.constructor.prototype===t)){var o=t.inspect(n,r);if(!isString(o)){o=formatValue(r,o,n)}return o}var i=formatPrimitive(r,t);if(i){return i}var a=Object.keys(t);var f=arrayToHash(a);if(r.showHidden){a=Object.getOwnPropertyNames(t)}if(isError(t)&&(a.indexOf(\"message\")>=0||a.indexOf(\"description\")>=0)){return formatError(t)}if(a.length===0){if(isFunction(t)){var u=t.name?\": \"+t.name:\"\";return r.stylize(\"[Function\"+u+\"]\",\"special\")}if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}if(isDate(t)){return r.stylize(Date.prototype.toString.call(t),\"date\")}if(isError(t)){return formatError(t)}}var s=\"\",c=false,y=[\"{\",\"}\"];if(isArray(t)){c=true;y=[\"[\",\"]\"]}if(isFunction(t)){var p=t.name?\": \"+t.name:\"\";s=\" [Function\"+p+\"]\"}if(isRegExp(t)){s=\" \"+RegExp.prototype.toString.call(t)}if(isDate(t)){s=\" \"+Date.prototype.toUTCString.call(t)}if(isError(t)){s=\" \"+formatError(t)}if(a.length===0&&(!c||t.length==0)){return y[0]+s+y[1]}if(n<0){if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}else{return r.stylize(\"[Object]\",\"special\")}}r.seen.push(t);var l;if(c){l=formatArray(r,t,n,f,a)}else{l=a.map((function(e){return formatProperty(r,t,n,f,e,c)}))}r.seen.pop();return reduceToSingleString(l,s,y)}function formatPrimitive(r,e){if(isUndefined(e))return r.stylize(\"undefined\",\"undefined\");if(isString(e)){var t=\"'\"+JSON.stringify(e).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return r.stylize(t,\"string\")}if(isNumber(e))return r.stylize(\"\"+e,\"number\");if(isBoolean(e))return r.stylize(\"\"+e,\"boolean\");if(isNull(e))return r.stylize(\"null\",\"null\")}function formatError(r){return\"[\"+Error.prototype.toString.call(r)+\"]\"}function formatArray(r,e,t,n,o){var i=[];for(var a=0,f=e.length;a<f;++a){if(hasOwnProperty(e,String(a))){i.push(formatProperty(r,e,t,n,String(a),true))}else{i.push(\"\")}}o.forEach((function(o){if(!o.match(/^\\d+$/)){i.push(formatProperty(r,e,t,n,o,true))}}));return i}function formatProperty(r,e,t,n,o,i){var a,f,u;u=Object.getOwnPropertyDescriptor(e,o)||{value:e[o]};if(u.get){if(u.set){f=r.stylize(\"[Getter/Setter]\",\"special\")}else{f=r.stylize(\"[Getter]\",\"special\")}}else{if(u.set){f=r.stylize(\"[Setter]\",\"special\")}}if(!hasOwnProperty(n,o)){a=\"[\"+o+\"]\"}if(!f){if(r.seen.indexOf(u.value)<0){if(isNull(t)){f=formatValue(r,u.value,null)}else{f=formatValue(r,u.value,t-1)}if(f.indexOf(\"\\n\")>-1){if(i){f=f.split(\"\\n\").map((function(r){return\"  \"+r})).join(\"\\n\").substr(2)}else{f=\"\\n\"+f.split(\"\\n\").map((function(r){return\"   \"+r})).join(\"\\n\")}}}else{f=r.stylize(\"[Circular]\",\"special\")}}if(isUndefined(a)){if(i&&o.match(/^\\d+$/)){return f}a=JSON.stringify(\"\"+o);if(a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)){a=a.substr(1,a.length-2);a=r.stylize(a,\"name\")}else{a=a.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\");a=r.stylize(a,\"string\")}}return a+\": \"+f}function reduceToSingleString(r,e,t){var n=0;var o=r.reduce((function(r,e){n++;if(e.indexOf(\"\\n\")>=0)n++;return r+e.replace(/\\u001b\\[\\d\\d?m/g,\"\").length+1}),0);if(o>60){return t[0]+(e===\"\"?\"\":e+\"\\n \")+\" \"+r.join(\",\\n  \")+\" \"+t[1]}return t[0]+e+\" \"+r.join(\", \")+\" \"+t[1]}e.types=t(584);function isArray(r){return Array.isArray(r)}e.isArray=isArray;function isBoolean(r){return typeof r===\"boolean\"}e.isBoolean=isBoolean;function isNull(r){return r===null}e.isNull=isNull;function isNullOrUndefined(r){return r==null}e.isNullOrUndefined=isNullOrUndefined;function isNumber(r){return typeof r===\"number\"}e.isNumber=isNumber;function isString(r){return typeof r===\"string\"}e.isString=isString;function isSymbol(r){return typeof r===\"symbol\"}e.isSymbol=isSymbol;function isUndefined(r){return r===void 0}e.isUndefined=isUndefined;function isRegExp(r){return isObject(r)&&objectToString(r)===\"[object RegExp]\"}e.isRegExp=isRegExp;e.types.isRegExp=isRegExp;function isObject(r){return typeof r===\"object\"&&r!==null}e.isObject=isObject;function isDate(r){return isObject(r)&&objectToString(r)===\"[object Date]\"}e.isDate=isDate;e.types.isDate=isDate;function isError(r){return isObject(r)&&(objectToString(r)===\"[object Error]\"||r instanceof Error)}e.isError=isError;e.types.isNativeError=isError;function isFunction(r){return typeof r===\"function\"}e.isFunction=isFunction;function isPrimitive(r){return r===null||typeof r===\"boolean\"||typeof r===\"number\"||typeof r===\"string\"||typeof r===\"symbol\"||typeof r===\"undefined\"}e.isPrimitive=isPrimitive;e.isBuffer=t(369);function objectToString(r){return Object.prototype.toString.call(r)}function pad(r){return r<10?\"0\"+r.toString(10):r.toString(10)}var u=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];function timestamp(){var r=new Date;var e=[pad(r.getHours()),pad(r.getMinutes()),pad(r.getSeconds())].join(\":\");return[r.getDate(),u[r.getMonth()],e].join(\" \")}e.log=function(){console.log(\"%s - %s\",timestamp(),e.format.apply(e,arguments))};e.inherits=t(782);e._extend=function(r,e){if(!e||!isObject(e))return r;var t=Object.keys(e);var n=t.length;while(n--){r[t[n]]=e[t[n]]}return r};function hasOwnProperty(r,e){return Object.prototype.hasOwnProperty.call(r,e)}var s=typeof Symbol!==\"undefined\"?Symbol(\"util.promisify.custom\"):undefined;e.promisify=function promisify(r){if(typeof r!==\"function\")throw new TypeError('The \"original\" argument must be of type Function');if(s&&r[s]){var e=r[s];if(typeof e!==\"function\"){throw new TypeError('The \"util.promisify.custom\" argument must be of type Function')}Object.defineProperty(e,s,{value:e,enumerable:false,writable:false,configurable:true});return e}function e(){var e,t;var n=new Promise((function(r,n){e=r;t=n}));var o=[];for(var i=0;i<arguments.length;i++){o.push(arguments[i])}o.push((function(r,n){if(r){t(r)}else{e(n)}}));try{r.apply(this,o)}catch(r){t(r)}return n}Object.setPrototypeOf(e,Object.getPrototypeOf(r));if(s)Object.defineProperty(e,s,{value:e,enumerable:false,writable:false,configurable:true});return Object.defineProperties(e,n(r))};e.promisify.custom=s;function callbackifyOnRejected(r,e){if(!r){var t=new Error(\"Promise was rejected with a falsy value\");t.reason=r;r=t}return e(r)}function callbackify(r){if(typeof r!==\"function\"){throw new TypeError('The \"original\" argument must be of type Function')}function callbackified(){var e=[];for(var t=0;t<arguments.length;t++){e.push(arguments[t])}var n=e.pop();if(typeof n!==\"function\"){throw new TypeError(\"The last argument must be of type Function\")}var o=this;var cb=function(){return n.apply(o,arguments)};r.apply(this,e).then((function(r){process.nextTick(cb.bind(null,null,r))}),(function(r){process.nextTick(callbackifyOnRejected.bind(null,r,cb))}))}Object.setPrototypeOf(callbackified,Object.getPrototypeOf(r));Object.defineProperties(callbackified,n(r));return callbackified}e.callbackify=callbackify},490:function(r,e,t){\"use strict\";var n=t(144);var o=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var f=t(942)();var u=f&&typeof Symbol.toStringTag===\"symbol\";var s=o();var c=i(\"String.prototype.slice\");var y={};var p=t(24);var l=Object.getPrototypeOf;if(u&&p&&l){n(s,(function(r){if(typeof __webpack_require__.g[r]===\"function\"){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=l(e);var n=p(t,Symbol.toStringTag);if(!n){var o=l(t);n=p(o,Symbol.toStringTag)}y[r]=n.get}}))}var g=function tryAllTypedArrays(r){var e=false;n(y,(function(t,n){if(!e){try{var o=t.call(r);if(o===n){e=o}}catch(r){}}}));return e};var v=t(994);r.exports=function whichTypedArray(r){if(!v(r)){return false}if(!u){return c(a(r),8,-1)}return g(r)}},349:function(r,e,t){\"use strict\";var n=t(992);r.exports=function availableTypedArrays(){return n([\"BigInt64Array\",\"BigUint64Array\",\"Float32Array\",\"Float64Array\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\"],(function(r){return typeof __webpack_require__.g[r]===\"function\"}))}},24:function(r,e,t){\"use strict\";var n=t(192);var o=n(\"%Object.getOwnPropertyDescriptor%\",true);if(o){try{o([],\"length\")}catch(r){o=null}}r.exports=o}};var e={};function __nccwpck_require__(t){var n=e[t];if(n!==undefined){return n.exports}var o=e[t]={exports:{}};var i=true;try{r[t](o,o.exports,__nccwpck_require__);i=false}finally{if(i)delete e[t]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(177);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLFlBQVksT0FBTyxnQkFBZ0IsMEJBQTBCLGlDQUFpQyw0Q0FBNEMsNENBQTRDLFNBQVMsWUFBWSxXQUFXLEtBQUsseUJBQXlCLFdBQVcsNkJBQTZCLFVBQVUsc0NBQXNDLHFCQUFxQixhQUFhLGFBQWEsYUFBYSx1Q0FBdUMsMkNBQTJDLGVBQWUsaURBQWlELFlBQVksVUFBVSxxQkFBcUIsYUFBYSxhQUFhLGFBQWEsc0NBQXNDLHFDQUFxQyw2Q0FBNkMsa0RBQWtELHdDQUF3QyxzQkFBc0IsTUFBTSxJQUFJLElBQUksTUFBTSxRQUFRLEVBQUUsU0FBUyxRQUFRLCtCQUErQix1QkFBdUIsU0FBUyxvQkFBb0IsbUJBQW1CLGNBQWMsMkNBQTJDLEdBQUcsVUFBVSwyQkFBMkIseUJBQXlCLE1BQU0scUJBQXFCLFFBQVEsRUFBRSxLQUFLLG1CQUFtQixpQkFBaUIsYUFBYSxvQkFBb0IsaUJBQWlCLGFBQWEsZ0JBQWdCLGdCQUFnQixhQUFhLHFCQUFxQixpQkFBaUIsYUFBYSx5QkFBeUIsaUJBQWlCLGFBQWEsc0JBQXNCLGlCQUFpQixhQUFhLG9CQUFvQixpQkFBaUIsYUFBYSxtQkFBbUIsaUJBQWlCLHNDQUFzQyxnQ0FBZ0Msa0NBQWtDLG9DQUFvQyxtREFBbUQsZUFBZSxXQUFXLFlBQVksSUFBSSxLQUFLLG9CQUFvQixLQUFLLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGlCQUFpQixhQUFhLHdEQUF3RCxnQ0FBZ0MsZUFBZSwwQkFBMEIsNkJBQTZCLFNBQVMsWUFBWSxXQUFXLE1BQU0sVUFBVSxZQUFZLFdBQVcsTUFBTSxtQkFBbUIsVUFBVSwwQkFBMEIsU0FBUyxtQkFBbUIsV0FBVyxXQUFXLFVBQVUsVUFBVSx3QkFBd0IsU0FBUyxZQUFZLFdBQVcsTUFBTSxRQUFRLGlCQUFpQixNQUFNLFVBQVUsMkJBQTJCLFdBQVcs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bUIsT0FBTyxJQUFJLGdCQUFnQixVQUFVLEtBQUssWUFBWSxHQUFHLFVBQVUsYUFBYSxzQ0FBc0MsVUFBVSxhQUFhLE9BQU8sb0JBQW9CLGFBQWEscUJBQXFCLGFBQWEsYUFBYSwwQ0FBMEMsMExBQTBMLGNBQWMscUJBQU0saUJBQWlCLElBQUksb0JBQW9CLGFBQWEsYUFBYSxrREFBa0QsTUFBTSxJQUFJLGVBQWUsU0FBUyxRQUFRLGNBQWMsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTI6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxuKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxuKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG4sYSxpLHIpKW8ucHVzaChhKX1yZXR1cm4gb307dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMjU2OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDE5Mik7dmFyIG89dCgxMzkpO3ZhciBpPW8obihcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW4ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG8odCl9cmV0dXJuIHR9fSwxMzk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMjEyKTt2YXIgbz10KDE5Mik7dmFyIGk9byhcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW8oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciBmPW8oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8bi5jYWxsKGEsaSk7dmFyIHU9byhcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBzPW8oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciBjPW8oXCIlTWF0aC5tYXglXCIpO2lmKHMpe3RyeXtzKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cz1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9ZihuLGEsYXJndW1lbnRzKTtpZih1JiZzKXt2YXIgdD11KGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3MoZSxcImxlbmd0aFwiLHt2YWx1ZToxK2MoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciB5PWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiBmKG4saSxhcmd1bWVudHMpfTtpZihzKXtzKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnl9KX1lbHNle3IuZXhwb3J0cy5hcHBseT15fX0sMTgxOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1FdmFsRXJyb3J9LDU0NTpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjtyLmV4cG9ydHM9RXJyb3J9LDIyOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1SYW5nZUVycm9yfSw4MDM6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7ci5leHBvcnRzPVJlZmVyZW5jZUVycm9yfSwxODI6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7ci5leHBvcnRzPVN5bnRheEVycm9yfSwyMDI6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7ci5leHBvcnRzPVR5cGVFcnJvcn0sMjg0OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1VUklFcnJvcn0sMTQ0OmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG4sbyl7aWYodC5jYWxsKG4pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7bi5jYWxsKG8sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgZiBpbiByKXtpZihlLmNhbGwocixmKSl7bi5jYWxsKG8scltmXSxmLHIpfX19fX0sMTM2OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBuPU1hdGgubWF4O3ZhciBvPVwiW29iamVjdCBGdW5jdGlvbl1cIjt2YXIgaT1mdW5jdGlvbiBjb25jYXR0eShyLGUpe3ZhciB0PVtdO2Zvcih2YXIgbj0wO248ci5sZW5ndGg7bis9MSl7dFtuXT1yW25dfWZvcih2YXIgbz0wO288ZS5sZW5ndGg7bys9MSl7dFtvK3IubGVuZ3RoXT1lW29dfXJldHVybiB0fTt2YXIgYT1mdW5jdGlvbiBzbGljeShyLGUpe3ZhciB0PVtdO2Zvcih2YXIgbj1lfHwwLG89MDtuPHIubGVuZ3RoO24rPTEsbys9MSl7dFtvXT1yW25dfXJldHVybiB0fTt2YXIgam9pbnk9ZnVuY3Rpb24ocixlKXt2YXIgdD1cIlwiO2Zvcih2YXIgbj0wO248ci5sZW5ndGg7bis9MSl7dCs9cltuXTtpZihuKzE8ci5sZW5ndGgpe3QrPWV9fXJldHVybiB0fTtyLmV4cG9ydHM9ZnVuY3Rpb24gYmluZChyKXt2YXIgZj10aGlzO2lmKHR5cGVvZiBmIT09XCJmdW5jdGlvblwifHx0LmFwcGx5KGYpIT09byl7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2YpfXZhciB1PWEoYXJndW1lbnRzLDEpO3ZhciBzO3ZhciBiaW5kZXI9ZnVuY3Rpb24oKXtpZih0aGlzIGluc3RhbmNlb2Ygcyl7dmFyIGU9Zi5hcHBseSh0aGlzLGkodSxhcmd1bWVudHMpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31yZXR1cm4gZi5hcHBseShyLGkodSxhcmd1bWVudHMpKX07dmFyIGM9bigwLGYubGVuZ3RoLXUubGVuZ3RoKTt2YXIgeT1bXTtmb3IodmFyIHA9MDtwPGM7cCsrKXt5W3BdPVwiJFwiK3B9cz1GdW5jdGlvbihcImJpbmRlclwiLFwicmV0dXJuIGZ1bmN0aW9uIChcIitqb2lueSh5LFwiLFwiKStcIil7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9XCIpKGJpbmRlcik7aWYoZi5wcm90b3R5cGUpe3ZhciBsPWZ1bmN0aW9uIEVtcHR5KCl7fTtsLnByb3RvdHlwZT1mLnByb3RvdHlwZTtzLnByb3RvdHlwZT1uZXcgbDtsLnByb3RvdHlwZT1udWxsfXJldHVybiBzfX0sMjEyOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDEzNik7ci5leHBvcnRzPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHxufSwxOTI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuO3ZhciBvPXQoNTQ1KTt2YXIgaT10KDE4MSk7dmFyIGE9dCgyMik7dmFyIGY9dCg4MDMpO3ZhciB1PXQoMTgyKTt2YXIgcz10KDIwMik7dmFyIGM9dCgyODQpO3ZhciB5PUZ1bmN0aW9uO3ZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3I9ZnVuY3Rpb24ocil7dHJ5e3JldHVybiB5KCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnK3IrXCIpLmNvbnN0cnVjdG9yO1wiKSgpfWNhdGNoKHIpe319O3ZhciBwPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7aWYocCl7dHJ5e3Aoe30sXCJcIil9Y2F0Y2gocil7cD1udWxsfX12YXIgdGhyb3dUeXBlRXJyb3I9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgc307dmFyIGw9cD9mdW5jdGlvbigpe3RyeXthcmd1bWVudHMuY2FsbGVlO3JldHVybiB0aHJvd1R5cGVFcnJvcn1jYXRjaChyKXt0cnl7cmV0dXJuIHAoYXJndW1lbnRzLFwiY2FsbGVlXCIpLmdldH1jYXRjaChyKXtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9fX0oKTp0aHJvd1R5cGVFcnJvcjt2YXIgZz10KDExNSkoKTt2YXIgdj10KDE0KSgpO3ZhciBiPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8KHY/ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTpudWxsKTt2YXIgZD17fTt2YXIgbT10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCJ8fCFiP246YihVaW50OEFycmF5KTt2YXIgUz17X19wcm90b19fOm51bGwsXCIlQWdncmVnYXRlRXJyb3IlXCI6dHlwZW9mIEFnZ3JlZ2F0ZUVycm9yPT09XCJ1bmRlZmluZWRcIj9uOkFnZ3JlZ2F0ZUVycm9yLFwiJUFycmF5JVwiOkFycmF5LFwiJUFycmF5QnVmZmVyJVwiOnR5cGVvZiBBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCI/bjpBcnJheUJ1ZmZlcixcIiVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJVwiOmcmJmI/YihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpOm4sXCIlQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiOm4sXCIlQXN5bmNGdW5jdGlvbiVcIjpkLFwiJUFzeW5jR2VuZXJhdG9yJVwiOmQsXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIjpkLFwiJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6ZCxcIiVBdG9taWNzJVwiOnR5cGVvZiBBdG9taWNzPT09XCJ1bmRlZmluZWRcIj9uOkF0b21pY3MsXCIlQmlnSW50JVwiOnR5cGVvZiBCaWdJbnQ9PT1cInVuZGVmaW5lZFwiP246QmlnSW50LFwiJUJpZ0ludDY0QXJyYXklXCI6dHlwZW9mIEJpZ0ludDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP246QmlnSW50NjRBcnJheSxcIiVCaWdVaW50NjRBcnJheSVcIjp0eXBlb2YgQmlnVWludDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP246QmlnVWludDY0QXJyYXksXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bjpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpvLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6aSxcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bjpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP246RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bjpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjp5LFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOmQsXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6ZyYmYj9iKGIoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6bixcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm4sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP246TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhZ3x8IWI/bjpiKChuZXcgTWFwKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFwiJU1hdGglXCI6TWF0aCxcIiVOdW1iZXIlXCI6TnVtYmVyLFwiJU9iamVjdCVcIjpPYmplY3QsXCIlcGFyc2VGbG9hdCVcIjpwYXJzZUZsb2F0LFwiJXBhcnNlSW50JVwiOnBhcnNlSW50LFwiJVByb21pc2UlXCI6dHlwZW9mIFByb21pc2U9PT1cInVuZGVmaW5lZFwiP246UHJvbWlzZSxcIiVQcm94eSVcIjp0eXBlb2YgUHJveHk9PT1cInVuZGVmaW5lZFwiP246UHJveHksXCIlUmFuZ2VFcnJvciVcIjphLFwiJVJlZmVyZW5jZUVycm9yJVwiOmYsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bjpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP246U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhZ3x8IWI/bjpiKChuZXcgU2V0KVtTeW1ib2wuaXRlcmF0b3JdKCkpLFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOnR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCI/bjpTaGFyZWRBcnJheUJ1ZmZlcixcIiVTdHJpbmclXCI6U3RyaW5nLFwiJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVwiOmcmJmI/YihcIlwiW1N5bWJvbC5pdGVyYXRvcl0oKSk6bixcIiVTeW1ib2wlXCI6Zz9TeW1ib2w6bixcIiVTeW50YXhFcnJvciVcIjp1LFwiJVRocm93VHlwZUVycm9yJVwiOmwsXCIlVHlwZWRBcnJheSVcIjptLFwiJVR5cGVFcnJvciVcIjpzLFwiJVVpbnQ4QXJyYXklXCI6dHlwZW9mIFVpbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP246VWludDhBcnJheSxcIiVVaW50OENsYW1wZWRBcnJheSVcIjp0eXBlb2YgVWludDhDbGFtcGVkQXJyYXk9PT1cInVuZGVmaW5lZFwiP246VWludDhDbGFtcGVkQXJyYXksXCIlVWludDE2QXJyYXklXCI6dHlwZW9mIFVpbnQxNkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQxNkFycmF5LFwiJVVpbnQzMkFycmF5JVwiOnR5cGVvZiBVaW50MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50MzJBcnJheSxcIiVVUklFcnJvciVcIjpjLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP246V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9uOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bjpXZWFrU2V0fTtpZihiKXt0cnl7bnVsbC5lcnJvcn1jYXRjaChyKXt2YXIgQT1iKGIocikpO1NbXCIlRXJyb3IucHJvdG90eXBlJVwiXT1BfX12YXIgaD1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG49ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihuJiZiKXtlPWIobi5wcm90b3R5cGUpfX1TW3JdPWU7cmV0dXJuIGV9O3ZhciBPPXtfX3Byb3RvX186bnVsbCxcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgaj10KDIxMik7dmFyIHc9dCgyNzApO3ZhciBQPWouY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBCPWouY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgRT1qLmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciB4PWouY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBUPWouY2FsbChGdW5jdGlvbi5jYWxsLFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7dmFyIEk9L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIGs9L1xcXFwoXFxcXCk/L2c7dmFyIEY9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPXgociwwLDEpO3ZhciB0PXgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyB1KFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgdShcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG49W107RShyLEksKGZ1bmN0aW9uKHIsZSx0LG8pe25bbi5sZW5ndGhdPXQ/RShvLGssXCIkMVwiKTplfHxyfSkpO3JldHVybiBufTt2YXIgVT1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbjtpZih3KE8sdCkpe249T1t0XTt0PVwiJVwiK25bMF0rXCIlXCJ9aWYodyhTLHQpKXt2YXIgbz1TW3RdO2lmKG89PT1kKXtvPWgodCl9aWYodHlwZW9mIG89PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IHMoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm4sbmFtZTp0LHZhbHVlOm99fXRocm93IG5ldyB1KFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBzKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgcygnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfWlmKFQoL14lP1teJV0qJT8kLyxyKT09PW51bGwpe3Rocm93IG5ldyB1KFwiYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZVwiKX12YXIgdD1GKHIpO3ZhciBvPXQubGVuZ3RoPjA/dFswXTpcIlwiO3ZhciBpPVUoXCIlXCIrbytcIiVcIixlKTt2YXIgYT1pLm5hbWU7dmFyIGY9aS52YWx1ZTt2YXIgYz1mYWxzZTt2YXIgeT1pLmFsaWFzO2lmKHkpe289eVswXTtCKHQsUChbMCwxXSx5KSl9Zm9yKHZhciBsPTEsZz10cnVlO2w8dC5sZW5ndGg7bCs9MSl7dmFyIHY9dFtsXTt2YXIgYj14KHYsMCwxKTt2YXIgZD14KHYsLTEpO2lmKChiPT09J1wiJ3x8Yj09PVwiJ1wifHxiPT09XCJgXCJ8fChkPT09J1wiJ3x8ZD09PVwiJ1wifHxkPT09XCJgXCIpKSYmYiE9PWQpe3Rocm93IG5ldyB1KFwicHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3Rlc1wiKX1pZih2PT09XCJjb25zdHJ1Y3RvclwifHwhZyl7Yz10cnVlfW8rPVwiLlwiK3Y7YT1cIiVcIitvK1wiJVwiO2lmKHcoUyxhKSl7Zj1TW2FdfWVsc2UgaWYoZiE9bnVsbCl7aWYoISh2IGluIGYpKXtpZighZSl7dGhyb3cgbmV3IHMoXCJiYXNlIGludHJpbnNpYyBmb3IgXCIrcitcIiBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS5cIil9cmV0dXJuIHZvaWQgbn1pZihwJiZsKzE+PXQubGVuZ3RoKXt2YXIgbT1wKGYsdik7Zz0hIW07aWYoZyYmXCJnZXRcImluIG0mJiEoXCJvcmlnaW5hbFZhbHVlXCJpbiBtLmdldCkpe2Y9bS5nZXR9ZWxzZXtmPWZbdl19fWVsc2V7Zz13KGYsdik7Zj1mW3ZdfWlmKGcmJiFjKXtTW2FdPWZ9fX1yZXR1cm4gZn19LDE0OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPXtfX3Byb3RvX186bnVsbCxmb286e319O3ZhciB0PU9iamVjdDtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzUHJvdG8oKXtyZXR1cm57X19wcm90b19fOmV9LmZvbz09PWUuZm9vJiYhKGUgaW5zdGFuY2VvZiB0KX19LDk0MjpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbDt2YXIgbz10KDc3Myk7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKXtpZih0eXBlb2YgbiE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgbihcImZvb1wiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sKFwiYmFyXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfXJldHVybiBvKCl9fSw3NzM6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc1N5bWJvbHMoKXtpZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwifHx0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cInN5bWJvbFwiKXtyZXR1cm4gdHJ1ZX12YXIgcj17fTt2YXIgZT1TeW1ib2woXCJ0ZXN0XCIpO3ZhciB0PU9iamVjdChlKTtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfXZhciBuPTQyO3JbZV09bjtmb3IoZSBpbiByKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5rZXlzPT09XCJmdW5jdGlvblwiJiZPYmplY3Qua2V5cyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzPT09XCJmdW5jdGlvblwiJiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyKTtpZihvLmxlbmd0aCE9PTF8fG9bMF0hPT1lKXtyZXR1cm4gZmFsc2V9aWYoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChyLGUpKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I9PT1cImZ1bmN0aW9uXCIpe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlKTtpZihpLnZhbHVlIT09bnx8aS5lbnVtZXJhYmxlIT09dHJ1ZSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX19LDExNTpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbDt2YXIgbz10KDgzMik7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKXtpZih0eXBlb2YgbiE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgbihcImZvb1wiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sKFwiYmFyXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfXJldHVybiBvKCl9fSw4MzI6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc1N5bWJvbHMoKXtpZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwifHx0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cInN5bWJvbFwiKXtyZXR1cm4gdHJ1ZX12YXIgcj17fTt2YXIgZT1TeW1ib2woXCJ0ZXN0XCIpO3ZhciB0PU9iamVjdChlKTtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfXZhciBuPTQyO3JbZV09bjtmb3IoZSBpbiByKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5rZXlzPT09XCJmdW5jdGlvblwiJiZPYmplY3Qua2V5cyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzPT09XCJmdW5jdGlvblwiJiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyKTtpZihvLmxlbmd0aCE9PTF8fG9bMF0hPT1lKXtyZXR1cm4gZmFsc2V9aWYoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChyLGUpKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I9PT1cImZ1bmN0aW9uXCIpe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlKTtpZihpLnZhbHVlIT09bnx8aS5lbnVtZXJhYmxlIT09dHJ1ZSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX19LDI3MDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49RnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7dmFyIG89T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgaT10KDIxMik7ci5leHBvcnRzPWkuY2FsbChuLG8pfSw3ODI6ZnVuY3Rpb24ocil7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PT1cImZ1bmN0aW9uXCIpe3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7ci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnIsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfX0pfX19ZWxzZXtyLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMocixlKXtpZihlKXtyLnN1cGVyXz1lO3ZhciBUZW1wQ3Rvcj1mdW5jdGlvbigpe307VGVtcEN0b3IucHJvdG90eXBlPWUucHJvdG90eXBlO3IucHJvdG90eXBlPW5ldyBUZW1wQ3RvcjtyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1yfX19fSwxNTc6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1mdW5jdGlvbiBpc0FyZ3VtZW50cyhyKXtpZihlJiZyJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJlN5bWJvbC50b1N0cmluZ1RhZyBpbiByKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHQuY2FsbChyKT09PVwiW29iamVjdCBBcmd1bWVudHNdXCJ9O3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKG4ocikpe3JldHVybiB0cnVlfXJldHVybiByIT09bnVsbCYmdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZ0eXBlb2Ygci5sZW5ndGg9PT1cIm51bWJlclwiJiZyLmxlbmd0aD49MCYmdC5jYWxsKHIpIT09XCJbb2JqZWN0IEFycmF5XVwiJiZ0LmNhbGwoci5jYWxsZWUpPT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwifTt2YXIgaT1mdW5jdGlvbigpe3JldHVybiBuKGFyZ3VtZW50cyl9KCk7bi5pc0xlZ2FjeUFyZ3VtZW50cz1vO3IuZXhwb3J0cz1pP246b30sMzkxOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7dmFyIHQ9RnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBuPS9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO3ZhciBvPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBpPU9iamVjdC5nZXRQcm90b3R5cGVPZjt2YXIgZ2V0R2VuZXJhdG9yRnVuYz1mdW5jdGlvbigpe2lmKCFvKXtyZXR1cm4gZmFsc2V9dHJ5e3JldHVybiBGdW5jdGlvbihcInJldHVybiBmdW5jdGlvbiooKSB7fVwiKSgpfWNhdGNoKHIpe319O3ZhciBhPWdldEdlbmVyYXRvckZ1bmMoKTt2YXIgZj1hP2koYSk6e307ci5leHBvcnRzPWZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24ocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZihuLnRlc3QodC5jYWxsKHIpKSl7cmV0dXJuIHRydWV9aWYoIW8pe3ZhciBhPWUuY2FsbChyKTtyZXR1cm4gYT09PVwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIn1yZXR1cm4gaShyKT09PWZ9fSw5OTQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTQ0KTt2YXIgbz10KDM0OSk7dmFyIGk9dCgyNTYpO3ZhciBhPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO3ZhciBmPXQoOTQyKSgpO3ZhciB1PWYmJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBzPW8oKTt2YXIgYz1pKFwiQXJyYXkucHJvdG90eXBlLmluZGV4T2ZcIix0cnVlKXx8ZnVuY3Rpb24gaW5kZXhPZihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCs9MSl7aWYoclt0XT09PWUpe3JldHVybiB0fX1yZXR1cm4tMX07dmFyIHk9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHA9e307dmFyIGw9dCgyNCk7dmFyIGc9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKHUmJmwmJmcpe24ocywoZnVuY3Rpb24ocil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWcoZSk7dmFyIG49bCh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW4pe3ZhciBvPWcodCk7bj1sKG8sU3ltYm9sLnRvU3RyaW5nVGFnKX1wW3JdPW4uZ2V0fSkpfXZhciB2PWZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHIpe3ZhciBlPWZhbHNlO24ocCwoZnVuY3Rpb24odCxuKXtpZighZSl7dHJ5e2U9dC5jYWxsKHIpPT09bn1jYXRjaChyKXt9fX0pKTtyZXR1cm4gZX07ci5leHBvcnRzPWZ1bmN0aW9uIGlzVHlwZWRBcnJheShyKXtpZighcnx8dHlwZW9mIHIhPT1cIm9iamVjdFwiKXtyZXR1cm4gZmFsc2V9aWYoIXUpe3ZhciBlPXkoYShyKSw4LC0xKTtyZXR1cm4gYyhzLGUpPi0xfWlmKCFsKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHYocil9fSwzNjk6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uIGlzQnVmZmVyKHIpe3JldHVybiByIGluc3RhbmNlb2YgQnVmZmVyfX0sNTg0OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDE1Nyk7dmFyIG89dCgzOTEpO3ZhciBpPXQoNDkwKTt2YXIgYT10KDk5NCk7ZnVuY3Rpb24gdW5jdXJyeVRoaXMocil7cmV0dXJuIHIuY2FsbC5iaW5kKHIpfXZhciBmPXR5cGVvZiBCaWdJbnQhPT1cInVuZGVmaW5lZFwiO3ZhciB1PXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiO3ZhciBzPXVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO3ZhciBjPXVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7dmFyIHk9dW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTt2YXIgcD11bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtpZihmKXt2YXIgbD11bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpfWlmKHUpe3ZhciBnPXVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZil9ZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGUpe2lmKHR5cGVvZiByIT09XCJvYmplY3RcIil7cmV0dXJuIGZhbHNlfXRyeXtlKHIpO3JldHVybiB0cnVlfWNhdGNoKHIpe3JldHVybiBmYWxzZX19ZS5pc0FyZ3VtZW50c09iamVjdD1uO2UuaXNHZW5lcmF0b3JGdW5jdGlvbj1vO2UuaXNUeXBlZEFycmF5PWE7ZnVuY3Rpb24gaXNQcm9taXNlKHIpe3JldHVybiB0eXBlb2YgUHJvbWlzZSE9PVwidW5kZWZpbmVkXCImJnIgaW5zdGFuY2VvZiBQcm9taXNlfHxyIT09bnVsbCYmdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZ0eXBlb2Ygci50aGVuPT09XCJmdW5jdGlvblwiJiZ0eXBlb2Ygci5jYXRjaD09PVwiZnVuY3Rpb25cIn1lLmlzUHJvbWlzZT1pc1Byb21pc2U7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcocil7aWYodHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmQXJyYXlCdWZmZXIuaXNWaWV3KXtyZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHIpfXJldHVybiBhKHIpfHxpc0RhdGFWaWV3KHIpfWUuaXNBcnJheUJ1ZmZlclZpZXc9aXNBcnJheUJ1ZmZlclZpZXc7ZnVuY3Rpb24gaXNVaW50OEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50OEFycmF5XCJ9ZS5pc1VpbnQ4QXJyYXk9aXNVaW50OEFycmF5O2Z1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQ4Q2xhbXBlZEFycmF5XCJ9ZS5pc1VpbnQ4Q2xhbXBlZEFycmF5PWlzVWludDhDbGFtcGVkQXJyYXk7ZnVuY3Rpb24gaXNVaW50MTZBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDE2QXJyYXlcIn1lLmlzVWludDE2QXJyYXk9aXNVaW50MTZBcnJheTtmdW5jdGlvbiBpc1VpbnQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50MzJBcnJheVwifWUuaXNVaW50MzJBcnJheT1pc1VpbnQzMkFycmF5O2Z1bmN0aW9uIGlzSW50OEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQ4QXJyYXlcIn1lLmlzSW50OEFycmF5PWlzSW50OEFycmF5O2Z1bmN0aW9uIGlzSW50MTZBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50MTZBcnJheVwifWUuaXNJbnQxNkFycmF5PWlzSW50MTZBcnJheTtmdW5jdGlvbiBpc0ludDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDMyQXJyYXlcIn1lLmlzSW50MzJBcnJheT1pc0ludDMyQXJyYXk7ZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIkZsb2F0MzJBcnJheVwifWUuaXNGbG9hdDMyQXJyYXk9aXNGbG9hdDMyQXJyYXk7ZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkZsb2F0NjRBcnJheVwifWUuaXNGbG9hdDY0QXJyYXk9aXNGbG9hdDY0QXJyYXk7ZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJCaWdJbnQ2NEFycmF5XCJ9ZS5pc0JpZ0ludDY0QXJyYXk9aXNCaWdJbnQ2NEFycmF5O2Z1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkJpZ1VpbnQ2NEFycmF5XCJ9ZS5pc0JpZ1VpbnQ2NEFycmF5PWlzQmlnVWludDY0QXJyYXk7ZnVuY3Rpb24gaXNNYXBUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBNYXBdXCJ9aXNNYXBUb1N0cmluZy53b3JraW5nPXR5cGVvZiBNYXAhPT1cInVuZGVmaW5lZFwiJiZpc01hcFRvU3RyaW5nKG5ldyBNYXApO2Z1bmN0aW9uIGlzTWFwKHIpe2lmKHR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZz9pc01hcFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBNYXB9ZS5pc01hcD1pc01hcDtmdW5jdGlvbiBpc1NldFRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFNldF1cIn1pc1NldFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFNldCE9PVwidW5kZWZpbmVkXCImJmlzU2V0VG9TdHJpbmcobmV3IFNldCk7ZnVuY3Rpb24gaXNTZXQocil7aWYodHlwZW9mIFNldD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nP2lzU2V0VG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIFNldH1lLmlzU2V0PWlzU2V0O2Z1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFdlYWtNYXBdXCJ9aXNXZWFrTWFwVG9TdHJpbmcud29ya2luZz10eXBlb2YgV2Vha01hcCE9PVwidW5kZWZpbmVkXCImJmlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKTtmdW5jdGlvbiBpc1dlYWtNYXAocil7aWYodHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmc/aXNXZWFrTWFwVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIFdlYWtNYXB9ZS5pc1dlYWtNYXA9aXNXZWFrTWFwO2Z1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFdlYWtTZXRdXCJ9aXNXZWFrU2V0VG9TdHJpbmcud29ya2luZz10eXBlb2YgV2Vha1NldCE9PVwidW5kZWZpbmVkXCImJmlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KTtmdW5jdGlvbiBpc1dlYWtTZXQocil7cmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHIpfWUuaXNXZWFrU2V0PWlzV2Vha1NldDtmdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgQXJyYXlCdWZmZXJdXCJ9aXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcik7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihyKXtpZih0eXBlb2YgQXJyYXlCdWZmZXI9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nP2lzQXJyYXlCdWZmZXJUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ9ZS5pc0FycmF5QnVmZmVyPWlzQXJyYXlCdWZmZXI7ZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IERhdGFWaWV3XVwifWlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nPXR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBEYXRhVmlldyE9PVwidW5kZWZpbmVkXCImJmlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLDAsMSkpO2Z1bmN0aW9uIGlzRGF0YVZpZXcocil7aWYodHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZz9pc0RhdGFWaWV3VG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIERhdGFWaWV3fWUuaXNEYXRhVmlldz1pc0RhdGFWaWV3O3ZhciB2PXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCI/U2hhcmVkQXJyYXlCdWZmZXI6dW5kZWZpbmVkO2Z1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl1cIn1mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHIpe2lmKHR5cGVvZiB2PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz09PVwidW5kZWZpbmVkXCIpe2lzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPWlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgdil9cmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nP2lzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhyKTpyIGluc3RhbmNlb2Ygdn1lLmlzU2hhcmVkQXJyYXlCdWZmZXI9aXNTaGFyZWRBcnJheUJ1ZmZlcjtmdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24ocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIn1lLmlzQXN5bmNGdW5jdGlvbj1pc0FzeW5jRnVuY3Rpb247ZnVuY3Rpb24gaXNNYXBJdGVyYXRvcihyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBNYXAgSXRlcmF0b3JdXCJ9ZS5pc01hcEl0ZXJhdG9yPWlzTWFwSXRlcmF0b3I7ZnVuY3Rpb24gaXNTZXRJdGVyYXRvcihyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTZXQgSXRlcmF0b3JdXCJ9ZS5pc1NldEl0ZXJhdG9yPWlzU2V0SXRlcmF0b3I7ZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3Qocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgR2VuZXJhdG9yXVwifWUuaXNHZW5lcmF0b3JPYmplY3Q9aXNHZW5lcmF0b3JPYmplY3Q7ZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV1cIn1lLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZT1pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7ZnVuY3Rpb24gaXNOdW1iZXJPYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixjKX1lLmlzTnVtYmVyT2JqZWN0PWlzTnVtYmVyT2JqZWN0O2Z1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIseSl9ZS5pc1N0cmluZ09iamVjdD1pc1N0cmluZ09iamVjdDtmdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixwKX1lLmlzQm9vbGVhbk9iamVjdD1pc0Jvb2xlYW5PYmplY3Q7ZnVuY3Rpb24gaXNCaWdJbnRPYmplY3Qocil7cmV0dXJuIGYmJmNoZWNrQm94ZWRQcmltaXRpdmUocixsKX1lLmlzQmlnSW50T2JqZWN0PWlzQmlnSW50T2JqZWN0O2Z1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHIpe3JldHVybiB1JiZjaGVja0JveGVkUHJpbWl0aXZlKHIsZyl9ZS5pc1N5bWJvbE9iamVjdD1pc1N5bWJvbE9iamVjdDtmdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHIpe3JldHVybiBpc051bWJlck9iamVjdChyKXx8aXNTdHJpbmdPYmplY3Qocil8fGlzQm9vbGVhbk9iamVjdChyKXx8aXNCaWdJbnRPYmplY3Qocil8fGlzU3ltYm9sT2JqZWN0KHIpfWUuaXNCb3hlZFByaW1pdGl2ZT1pc0JveGVkUHJpbWl0aXZlO2Z1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIocil7cmV0dXJuIHR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIiYmKGlzQXJyYXlCdWZmZXIocil8fGlzU2hhcmVkQXJyYXlCdWZmZXIocikpfWUuaXNBbnlBcnJheUJ1ZmZlcj1pc0FueUFycmF5QnVmZmVyO1tcImlzUHJveHlcIixcImlzRXh0ZXJuYWxcIixcImlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0XCJdLmZvckVhY2goKGZ1bmN0aW9uKHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ZmFsc2UsdmFsdWU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IocitcIiBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kXCIpfX0pfSkpfSwxNzc6ZnVuY3Rpb24ocixlLHQpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHIpe3ZhciBlPU9iamVjdC5rZXlzKHIpO3ZhciB0PXt9O2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt0W2Vbbl1dPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlW25dKX1yZXR1cm4gdH07dmFyIG89LyVbc2RqJV0vZztlLmZvcm1hdD1mdW5jdGlvbihyKXtpZighaXNTdHJpbmcocikpe3ZhciBlPVtdO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2UucHVzaChpbnNwZWN0KGFyZ3VtZW50c1t0XSkpfXJldHVybiBlLmpvaW4oXCIgXCIpfXZhciB0PTE7dmFyIG49YXJndW1lbnRzO3ZhciBpPW4ubGVuZ3RoO3ZhciBhPVN0cmluZyhyKS5yZXBsYWNlKG8sKGZ1bmN0aW9uKHIpe2lmKHI9PT1cIiUlXCIpcmV0dXJuXCIlXCI7aWYodD49aSlyZXR1cm4gcjtzd2l0Y2gocil7Y2FzZVwiJXNcIjpyZXR1cm4gU3RyaW5nKG5bdCsrXSk7Y2FzZVwiJWRcIjpyZXR1cm4gTnVtYmVyKG5bdCsrXSk7Y2FzZVwiJWpcIjp0cnl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KG5bdCsrXSl9Y2F0Y2gocil7cmV0dXJuXCJbQ2lyY3VsYXJdXCJ9ZGVmYXVsdDpyZXR1cm4gcn19KSk7Zm9yKHZhciBmPW5bdF07dDxpO2Y9blsrK3RdKXtpZihpc051bGwoZil8fCFpc09iamVjdChmKSl7YSs9XCIgXCIrZn1lbHNle2ErPVwiIFwiK2luc3BlY3QoZil9fXJldHVybiBhfTtlLmRlcHJlY2F0ZT1mdW5jdGlvbihyLHQpe2lmKHR5cGVvZiBwcm9jZXNzIT09XCJ1bmRlZmluZWRcIiYmcHJvY2Vzcy5ub0RlcHJlY2F0aW9uPT09dHJ1ZSl7cmV0dXJuIHJ9aWYodHlwZW9mIHByb2Nlc3M9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5kZXByZWNhdGUocix0KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBuPWZhbHNlO2Z1bmN0aW9uIGRlcHJlY2F0ZWQoKXtpZighbil7aWYocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKXt0aHJvdyBuZXcgRXJyb3IodCl9ZWxzZSBpZihwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pe2NvbnNvbGUudHJhY2UodCl9ZWxzZXtjb25zb2xlLmVycm9yKHQpfW49dHJ1ZX1yZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIGRlcHJlY2F0ZWR9O3ZhciBpPXt9O3ZhciBhPS9eJC87aWYocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyl7dmFyIGY9cHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztmPWYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXCovZyxcIi4qXCIpLnJlcGxhY2UoLywvZyxcIiR8XlwiKS50b1VwcGVyQ2FzZSgpO2E9bmV3IFJlZ0V4cChcIl5cIitmK1wiJFwiLFwiaVwiKX1lLmRlYnVnbG9nPWZ1bmN0aW9uKHIpe3I9ci50b1VwcGVyQ2FzZSgpO2lmKCFpW3JdKXtpZihhLnRlc3Qocikpe3ZhciB0PXByb2Nlc3MucGlkO2lbcl09ZnVuY3Rpb24oKXt2YXIgbj1lLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cyk7Y29uc29sZS5lcnJvcihcIiVzICVkOiAlc1wiLHIsdCxuKX19ZWxzZXtpW3JdPWZ1bmN0aW9uKCl7fX19cmV0dXJuIGlbcl19O2Z1bmN0aW9uIGluc3BlY3Qocix0KXt2YXIgbj17c2VlbjpbXSxzdHlsaXplOnN0eWxpemVOb0NvbG9yfTtpZihhcmd1bWVudHMubGVuZ3RoPj0zKW4uZGVwdGg9YXJndW1lbnRzWzJdO2lmKGFyZ3VtZW50cy5sZW5ndGg+PTQpbi5jb2xvcnM9YXJndW1lbnRzWzNdO2lmKGlzQm9vbGVhbih0KSl7bi5zaG93SGlkZGVuPXR9ZWxzZSBpZih0KXtlLl9leHRlbmQobix0KX1pZihpc1VuZGVmaW5lZChuLnNob3dIaWRkZW4pKW4uc2hvd0hpZGRlbj1mYWxzZTtpZihpc1VuZGVmaW5lZChuLmRlcHRoKSluLmRlcHRoPTI7aWYoaXNVbmRlZmluZWQobi5jb2xvcnMpKW4uY29sb3JzPWZhbHNlO2lmKGlzVW5kZWZpbmVkKG4uY3VzdG9tSW5zcGVjdCkpbi5jdXN0b21JbnNwZWN0PXRydWU7aWYobi5jb2xvcnMpbi5zdHlsaXplPXN0eWxpemVXaXRoQ29sb3I7cmV0dXJuIGZvcm1hdFZhbHVlKG4scixuLmRlcHRoKX1lLmluc3BlY3Q9aW5zcGVjdDtpbnNwZWN0LmNvbG9ycz17Ym9sZDpbMSwyMl0saXRhbGljOlszLDIzXSx1bmRlcmxpbmU6WzQsMjRdLGludmVyc2U6WzcsMjddLHdoaXRlOlszNywzOV0sZ3JleTpbOTAsMzldLGJsYWNrOlszMCwzOV0sYmx1ZTpbMzQsMzldLGN5YW46WzM2LDM5XSxncmVlbjpbMzIsMzldLG1hZ2VudGE6WzM1LDM5XSxyZWQ6WzMxLDM5XSx5ZWxsb3c6WzMzLDM5XX07aW5zcGVjdC5zdHlsZXM9e3NwZWNpYWw6XCJjeWFuXCIsbnVtYmVyOlwieWVsbG93XCIsYm9vbGVhbjpcInllbGxvd1wiLHVuZGVmaW5lZDpcImdyZXlcIixudWxsOlwiYm9sZFwiLHN0cmluZzpcImdyZWVuXCIsZGF0ZTpcIm1hZ2VudGFcIixyZWdleHA6XCJyZWRcIn07ZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihyLGUpe3ZhciB0PWluc3BlY3Quc3R5bGVzW2VdO2lmKHQpe3JldHVyblwiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3RdWzBdK1wibVwiK3IrXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbdF1bMV0rXCJtXCJ9ZWxzZXtyZXR1cm4gcn19ZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3IocixlKXtyZXR1cm4gcn1mdW5jdGlvbiBhcnJheVRvSGFzaChyKXt2YXIgZT17fTtyLmZvckVhY2goKGZ1bmN0aW9uKHIsdCl7ZVtyXT10cnVlfSkpO3JldHVybiBlfWZ1bmN0aW9uIGZvcm1hdFZhbHVlKHIsdCxuKXtpZihyLmN1c3RvbUluc3BlY3QmJnQmJmlzRnVuY3Rpb24odC5pbnNwZWN0KSYmdC5pbnNwZWN0IT09ZS5pbnNwZWN0JiYhKHQuY29uc3RydWN0b3ImJnQuY29uc3RydWN0b3IucHJvdG90eXBlPT09dCkpe3ZhciBvPXQuaW5zcGVjdChuLHIpO2lmKCFpc1N0cmluZyhvKSl7bz1mb3JtYXRWYWx1ZShyLG8sbil9cmV0dXJuIG99dmFyIGk9Zm9ybWF0UHJpbWl0aXZlKHIsdCk7aWYoaSl7cmV0dXJuIGl9dmFyIGE9T2JqZWN0LmtleXModCk7dmFyIGY9YXJyYXlUb0hhc2goYSk7aWYoci5zaG93SGlkZGVuKXthPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpfWlmKGlzRXJyb3IodCkmJihhLmluZGV4T2YoXCJtZXNzYWdlXCIpPj0wfHxhLmluZGV4T2YoXCJkZXNjcmlwdGlvblwiKT49MCkpe3JldHVybiBmb3JtYXRFcnJvcih0KX1pZihhLmxlbmd0aD09PTApe2lmKGlzRnVuY3Rpb24odCkpe3ZhciB1PXQubmFtZT9cIjogXCIrdC5uYW1lOlwiXCI7cmV0dXJuIHIuc3R5bGl6ZShcIltGdW5jdGlvblwiK3UrXCJdXCIsXCJzcGVjaWFsXCIpfWlmKGlzUmVnRXhwKHQpKXtyZXR1cm4gci5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcInJlZ2V4cFwiKX1pZihpc0RhdGUodCkpe3JldHVybiByLnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcImRhdGVcIil9aWYoaXNFcnJvcih0KSl7cmV0dXJuIGZvcm1hdEVycm9yKHQpfX12YXIgcz1cIlwiLGM9ZmFsc2UseT1bXCJ7XCIsXCJ9XCJdO2lmKGlzQXJyYXkodCkpe2M9dHJ1ZTt5PVtcIltcIixcIl1cIl19aWYoaXNGdW5jdGlvbih0KSl7dmFyIHA9dC5uYW1lP1wiOiBcIit0Lm5hbWU6XCJcIjtzPVwiIFtGdW5jdGlvblwiK3ArXCJdXCJ9aWYoaXNSZWdFeHAodCkpe3M9XCIgXCIrUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfWlmKGlzRGF0ZSh0KSl7cz1cIiBcIitEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHQpfWlmKGlzRXJyb3IodCkpe3M9XCIgXCIrZm9ybWF0RXJyb3IodCl9aWYoYS5sZW5ndGg9PT0wJiYoIWN8fHQubGVuZ3RoPT0wKSl7cmV0dXJuIHlbMF0rcyt5WzFdfWlmKG48MCl7aWYoaXNSZWdFeHAodCkpe3JldHVybiByLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwicmVnZXhwXCIpfWVsc2V7cmV0dXJuIHIuc3R5bGl6ZShcIltPYmplY3RdXCIsXCJzcGVjaWFsXCIpfX1yLnNlZW4ucHVzaCh0KTt2YXIgbDtpZihjKXtsPWZvcm1hdEFycmF5KHIsdCxuLGYsYSl9ZWxzZXtsPWEubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZm9ybWF0UHJvcGVydHkocix0LG4sZixlLGMpfSkpfXIuc2Vlbi5wb3AoKTtyZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcobCxzLHkpfWZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShyLGUpe2lmKGlzVW5kZWZpbmVkKGUpKXJldHVybiByLnN0eWxpemUoXCJ1bmRlZmluZWRcIixcInVuZGVmaW5lZFwiKTtpZihpc1N0cmluZyhlKSl7dmFyIHQ9XCInXCIrSlNPTi5zdHJpbmdpZnkoZSkucmVwbGFjZSgvXlwifFwiJC9nLFwiXCIpLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpK1wiJ1wiO3JldHVybiByLnN0eWxpemUodCxcInN0cmluZ1wiKX1pZihpc051bWJlcihlKSlyZXR1cm4gci5zdHlsaXplKFwiXCIrZSxcIm51bWJlclwiKTtpZihpc0Jvb2xlYW4oZSkpcmV0dXJuIHIuc3R5bGl6ZShcIlwiK2UsXCJib29sZWFuXCIpO2lmKGlzTnVsbChlKSlyZXR1cm4gci5zdHlsaXplKFwibnVsbFwiLFwibnVsbFwiKX1mdW5jdGlvbiBmb3JtYXRFcnJvcihyKXtyZXR1cm5cIltcIitFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKStcIl1cIn1mdW5jdGlvbiBmb3JtYXRBcnJheShyLGUsdCxuLG8pe3ZhciBpPVtdO2Zvcih2YXIgYT0wLGY9ZS5sZW5ndGg7YTxmOysrYSl7aWYoaGFzT3duUHJvcGVydHkoZSxTdHJpbmcoYSkpKXtpLnB1c2goZm9ybWF0UHJvcGVydHkocixlLHQsbixTdHJpbmcoYSksdHJ1ZSkpfWVsc2V7aS5wdXNoKFwiXCIpfX1vLmZvckVhY2goKGZ1bmN0aW9uKG8pe2lmKCFvLm1hdGNoKC9eXFxkKyQvKSl7aS5wdXNoKGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sbyx0cnVlKSl9fSkpO3JldHVybiBpfWZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sbyxpKXt2YXIgYSxmLHU7dT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbyl8fHt2YWx1ZTplW29dfTtpZih1LmdldCl7aWYodS5zZXQpe2Y9ci5zdHlsaXplKFwiW0dldHRlci9TZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfWVsc2V7Zj1yLnN0eWxpemUoXCJbR2V0dGVyXVwiLFwic3BlY2lhbFwiKX19ZWxzZXtpZih1LnNldCl7Zj1yLnN0eWxpemUoXCJbU2V0dGVyXVwiLFwic3BlY2lhbFwiKX19aWYoIWhhc093blByb3BlcnR5KG4sbykpe2E9XCJbXCIrbytcIl1cIn1pZighZil7aWYoci5zZWVuLmluZGV4T2YodS52YWx1ZSk8MCl7aWYoaXNOdWxsKHQpKXtmPWZvcm1hdFZhbHVlKHIsdS52YWx1ZSxudWxsKX1lbHNle2Y9Zm9ybWF0VmFsdWUocix1LnZhbHVlLHQtMSl9aWYoZi5pbmRleE9mKFwiXFxuXCIpPi0xKXtpZihpKXtmPWYuc3BsaXQoXCJcXG5cIikubWFwKChmdW5jdGlvbihyKXtyZXR1cm5cIiAgXCIrcn0pKS5qb2luKFwiXFxuXCIpLnN1YnN0cigyKX1lbHNle2Y9XCJcXG5cIitmLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuXCIgICBcIityfSkpLmpvaW4oXCJcXG5cIil9fX1lbHNle2Y9ci5zdHlsaXplKFwiW0NpcmN1bGFyXVwiLFwic3BlY2lhbFwiKX19aWYoaXNVbmRlZmluZWQoYSkpe2lmKGkmJm8ubWF0Y2goL15cXGQrJC8pKXtyZXR1cm4gZn1hPUpTT04uc3RyaW5naWZ5KFwiXCIrbyk7aWYoYS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpe2E9YS5zdWJzdHIoMSxhLmxlbmd0aC0yKTthPXIuc3R5bGl6ZShhLFwibmFtZVwiKX1lbHNle2E9YS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKS5yZXBsYWNlKC8oXlwifFwiJCkvZyxcIidcIik7YT1yLnN0eWxpemUoYSxcInN0cmluZ1wiKX19cmV0dXJuIGErXCI6IFwiK2Z9ZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcocixlLHQpe3ZhciBuPTA7dmFyIG89ci5yZWR1Y2UoKGZ1bmN0aW9uKHIsZSl7bisrO2lmKGUuaW5kZXhPZihcIlxcblwiKT49MCluKys7cmV0dXJuIHIrZS5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZyxcIlwiKS5sZW5ndGgrMX0pLDApO2lmKG8+NjApe3JldHVybiB0WzBdKyhlPT09XCJcIj9cIlwiOmUrXCJcXG4gXCIpK1wiIFwiK3Iuam9pbihcIixcXG4gIFwiKStcIiBcIit0WzFdfXJldHVybiB0WzBdK2UrXCIgXCIrci5qb2luKFwiLCBcIikrXCIgXCIrdFsxXX1lLnR5cGVzPXQoNTg0KTtmdW5jdGlvbiBpc0FycmF5KHIpe3JldHVybiBBcnJheS5pc0FycmF5KHIpfWUuaXNBcnJheT1pc0FycmF5O2Z1bmN0aW9uIGlzQm9vbGVhbihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cImJvb2xlYW5cIn1lLmlzQm9vbGVhbj1pc0Jvb2xlYW47ZnVuY3Rpb24gaXNOdWxsKHIpe3JldHVybiByPT09bnVsbH1lLmlzTnVsbD1pc051bGw7ZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQocil7cmV0dXJuIHI9PW51bGx9ZS5pc051bGxPclVuZGVmaW5lZD1pc051bGxPclVuZGVmaW5lZDtmdW5jdGlvbiBpc051bWJlcihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cIm51bWJlclwifWUuaXNOdW1iZXI9aXNOdW1iZXI7ZnVuY3Rpb24gaXNTdHJpbmcocil7cmV0dXJuIHR5cGVvZiByPT09XCJzdHJpbmdcIn1lLmlzU3RyaW5nPWlzU3RyaW5nO2Z1bmN0aW9uIGlzU3ltYm9sKHIpe3JldHVybiB0eXBlb2Ygcj09PVwic3ltYm9sXCJ9ZS5pc1N5bWJvbD1pc1N5bWJvbDtmdW5jdGlvbiBpc1VuZGVmaW5lZChyKXtyZXR1cm4gcj09PXZvaWQgMH1lLmlzVW5kZWZpbmVkPWlzVW5kZWZpbmVkO2Z1bmN0aW9uIGlzUmVnRXhwKHIpe3JldHVybiBpc09iamVjdChyKSYmb2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgUmVnRXhwXVwifWUuaXNSZWdFeHA9aXNSZWdFeHA7ZS50eXBlcy5pc1JlZ0V4cD1pc1JlZ0V4cDtmdW5jdGlvbiBpc09iamVjdChyKXtyZXR1cm4gdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZyIT09bnVsbH1lLmlzT2JqZWN0PWlzT2JqZWN0O2Z1bmN0aW9uIGlzRGF0ZShyKXtyZXR1cm4gaXNPYmplY3QocikmJm9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IERhdGVdXCJ9ZS5pc0RhdGU9aXNEYXRlO2UudHlwZXMuaXNEYXRlPWlzRGF0ZTtmdW5jdGlvbiBpc0Vycm9yKHIpe3JldHVybiBpc09iamVjdChyKSYmKG9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IEVycm9yXVwifHxyIGluc3RhbmNlb2YgRXJyb3IpfWUuaXNFcnJvcj1pc0Vycm9yO2UudHlwZXMuaXNOYXRpdmVFcnJvcj1pc0Vycm9yO2Z1bmN0aW9uIGlzRnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiByPT09XCJmdW5jdGlvblwifWUuaXNGdW5jdGlvbj1pc0Z1bmN0aW9uO2Z1bmN0aW9uIGlzUHJpbWl0aXZlKHIpe3JldHVybiByPT09bnVsbHx8dHlwZW9mIHI9PT1cImJvb2xlYW5cInx8dHlwZW9mIHI9PT1cIm51bWJlclwifHx0eXBlb2Ygcj09PVwic3RyaW5nXCJ8fHR5cGVvZiByPT09XCJzeW1ib2xcInx8dHlwZW9mIHI9PT1cInVuZGVmaW5lZFwifWUuaXNQcmltaXRpdmU9aXNQcmltaXRpdmU7ZS5pc0J1ZmZlcj10KDM2OSk7ZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcocil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKX1mdW5jdGlvbiBwYWQocil7cmV0dXJuIHI8MTA/XCIwXCIrci50b1N0cmluZygxMCk6ci50b1N0cmluZygxMCl9dmFyIHU9W1wiSmFuXCIsXCJGZWJcIixcIk1hclwiLFwiQXByXCIsXCJNYXlcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2N0XCIsXCJOb3ZcIixcIkRlY1wiXTtmdW5jdGlvbiB0aW1lc3RhbXAoKXt2YXIgcj1uZXcgRGF0ZTt2YXIgZT1bcGFkKHIuZ2V0SG91cnMoKSkscGFkKHIuZ2V0TWludXRlcygpKSxwYWQoci5nZXRTZWNvbmRzKCkpXS5qb2luKFwiOlwiKTtyZXR1cm5bci5nZXREYXRlKCksdVtyLmdldE1vbnRoKCldLGVdLmpvaW4oXCIgXCIpfWUubG9nPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCIlcyAtICVzXCIsdGltZXN0YW1wKCksZS5mb3JtYXQuYXBwbHkoZSxhcmd1bWVudHMpKX07ZS5pbmhlcml0cz10KDc4Mik7ZS5fZXh0ZW5kPWZ1bmN0aW9uKHIsZSl7aWYoIWV8fCFpc09iamVjdChlKSlyZXR1cm4gcjt2YXIgdD1PYmplY3Qua2V5cyhlKTt2YXIgbj10Lmxlbmd0aDt3aGlsZShuLS0pe3JbdFtuXV09ZVt0W25dXX1yZXR1cm4gcn07ZnVuY3Rpb24gaGFzT3duUHJvcGVydHkocixlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsZSl9dmFyIHM9dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCI/U3ltYm9sKFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIpOnVuZGVmaW5lZDtlLnByb21pc2lmeT1mdW5jdGlvbiBwcm9taXNpZnkocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtpZihzJiZyW3NdKXt2YXIgZT1yW3NdO2lmKHR5cGVvZiBlIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxzLHt2YWx1ZTplLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6ZmFsc2UsY29uZmlndXJhYmxlOnRydWV9KTtyZXR1cm4gZX1mdW5jdGlvbiBlKCl7dmFyIGUsdDt2YXIgbj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixuKXtlPXI7dD1ufSkpO3ZhciBvPVtdO2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe28ucHVzaChhcmd1bWVudHNbaV0pfW8ucHVzaCgoZnVuY3Rpb24ocixuKXtpZihyKXt0KHIpfWVsc2V7ZShuKX19KSk7dHJ5e3IuYXBwbHkodGhpcyxvKX1jYXRjaChyKXt0KHIpfXJldHVybiBufU9iamVjdC5zZXRQcm90b3R5cGVPZihlLE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSk7aWYocylPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxzLHt2YWx1ZTplLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6ZmFsc2UsY29uZmlndXJhYmxlOnRydWV9KTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxuKHIpKX07ZS5wcm9taXNpZnkuY3VzdG9tPXM7ZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHIsZSl7aWYoIXIpe3ZhciB0PW5ldyBFcnJvcihcIlByb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZVwiKTt0LnJlYXNvbj1yO3I9dH1yZXR1cm4gZShyKX1mdW5jdGlvbiBjYWxsYmFja2lmeShyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKX1mdW5jdGlvbiBjYWxsYmFja2lmaWVkKCl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZS5wdXNoKGFyZ3VtZW50c1t0XSl9dmFyIG49ZS5wb3AoKTtpZih0eXBlb2YgbiE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvblwiKX12YXIgbz10aGlzO3ZhciBjYj1mdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KG8sYXJndW1lbnRzKX07ci5hcHBseSh0aGlzLGUpLnRoZW4oKGZ1bmN0aW9uKHIpe3Byb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLG51bGwscikpfSksKGZ1bmN0aW9uKHIpe3Byb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCxyLGNiKSl9KSl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLG4ocikpO3JldHVybiBjYWxsYmFja2lmaWVkfWUuY2FsbGJhY2tpZnk9Y2FsbGJhY2tpZnl9LDQ5MDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxNDQpO3ZhciBvPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIGY9dCg5NDIpKCk7dmFyIHU9ZiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHM9bygpO3ZhciBjPWkoXCJTdHJpbmcucHJvdG90eXBlLnNsaWNlXCIpO3ZhciB5PXt9O3ZhciBwPXQoMjQpO3ZhciBsPU9iamVjdC5nZXRQcm90b3R5cGVPZjtpZih1JiZwJiZsKXtuKHMsKGZ1bmN0aW9uKHIpe2lmKHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCIpe3ZhciBlPW5ldyBnbG9iYWxbcl07aWYoIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gZSkpe3Rocm93IG5ldyBFdmFsRXJyb3IoXCJ0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgXCIrcitcIiBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLlwiKX12YXIgdD1sKGUpO3ZhciBuPXAodCxTeW1ib2wudG9TdHJpbmdUYWcpO2lmKCFuKXt2YXIgbz1sKHQpO249cChvLFN5bWJvbC50b1N0cmluZ1RhZyl9eVtyXT1uLmdldH19KSl9dmFyIGc9ZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXMocil7dmFyIGU9ZmFsc2U7bih5LChmdW5jdGlvbih0LG4pe2lmKCFlKXt0cnl7dmFyIG89dC5jYWxsKHIpO2lmKG89PT1uKXtlPW99fWNhdGNoKHIpe319fSkpO3JldHVybiBlfTt2YXIgdj10KDk5NCk7ci5leHBvcnRzPWZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheShyKXtpZighdihyKSl7cmV0dXJuIGZhbHNlfWlmKCF1KXtyZXR1cm4gYyhhKHIpLDgsLTEpfXJldHVybiBnKHIpfX0sMzQ5OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDk5Mik7ci5leHBvcnRzPWZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCl7cmV0dXJuIG4oW1wiQmlnSW50NjRBcnJheVwiLFwiQmlnVWludDY0QXJyYXlcIixcIkZsb2F0MzJBcnJheVwiLFwiRmxvYXQ2NEFycmF5XCIsXCJJbnQxNkFycmF5XCIsXCJJbnQzMkFycmF5XCIsXCJJbnQ4QXJyYXlcIixcIlVpbnQxNkFycmF5XCIsXCJVaW50MzJBcnJheVwiLFwiVWludDhBcnJheVwiLFwiVWludDhDbGFtcGVkQXJyYXlcIl0sKGZ1bmN0aW9uKHIpe3JldHVybiB0eXBlb2YgZ2xvYmFsW3JdPT09XCJmdW5jdGlvblwifSkpfX0sMjQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTkyKTt2YXIgbz1uKFwiJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlXCIsdHJ1ZSk7aWYobyl7dHJ5e28oW10sXCJsZW5ndGhcIil9Y2F0Y2gocil7bz1udWxsfX1yLmV4cG9ydHM9b319O3ZhciBlPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49ZVt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBvPWVbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e3JbdF0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIGVbdF19cmV0dXJuIG8uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxNzcpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/cache/ClientCache.ts":
/*!*****************************************!*\
  !*** ./src/client/cache/ClientCache.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCacheUtils: () => (/* binding */ getCacheUtils),\n/* harmony export */   getWidgetCache: () => (/* binding */ getWidgetCache),\n/* harmony export */   getWidgetCacheSync: () => (/* binding */ getWidgetCacheSync),\n/* harmony export */   getWidgetTypeCache: () => (/* binding */ getWidgetTypeCache),\n/* harmony export */   getWidgetTypeCacheSync: () => (/* binding */ getWidgetTypeCacheSync),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser)\n/* harmony export */ });\n/**\n * Client-side cache instances that are only initialized when accessed in the browser.\n * This prevents SSR issues with IndexedDB.\n */ let _widgetCache = null;\nlet _widgetTypeCache = null;\n/**\n * Get widget cache instance, initializing it only on first access in the browser\n */ const getWidgetCache = async ()=>{\n    if (!_widgetCache) {\n        if (false) {}\n        // Import and initialize cache only in browser\n        const { widgetCache } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_client_cache_WidgetCache_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./WidgetCache */ \"(app-pages-browser)/./src/client/cache/WidgetCache.ts\"));\n        _widgetCache = widgetCache;\n    }\n    return _widgetCache; // We know it's not null after the check above\n};\n/**\n * Get widget cache instance synchronously (must be called after async initialization)\n */ const getWidgetCacheSync = ()=>{\n    if (!_widgetCache) {\n        throw new Error('Widget cache not yet initialized. Call getWidgetCache() first.');\n    }\n    return _widgetCache;\n};\n/**\n * Get widget type cache instance, initializing it only on first access in the browser\n */ const getWidgetTypeCache = async ()=>{\n    if (!_widgetTypeCache) {\n        if (false) {}\n        // Import and initialize cache only in browser\n        const { widgetTypeCache } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_client_cache_WidgetTypeCache_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./WidgetTypeCache */ \"(app-pages-browser)/./src/client/cache/WidgetTypeCache.ts\"));\n        _widgetTypeCache = widgetTypeCache;\n    }\n    return _widgetTypeCache;\n};\n/**\n * Get widget type cache instance synchronously (must be called after async initialization)\n */ const getWidgetTypeCacheSync = ()=>{\n    if (!_widgetTypeCache) {\n        throw new Error('Widget type cache not yet initialized. Call getWidgetTypeCache() first.');\n    }\n    return _widgetTypeCache;\n};\n/**\n * Get all cache utilities, initializing them only on first access in the browser\n */ const getCacheUtils = async ()=>{\n    if (false) {}\n    // Import utilities only in browser\n    const { cacheUtils } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_client_cache_index_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./index */ \"(app-pages-browser)/./src/client/cache/index.ts\"));\n    return cacheUtils;\n};\n/**\n * Check if we're in a browser environment\n */ const isBrowser = ()=>\"object\" !== 'undefined';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvY2FjaGUvQ2xpZW50Q2FjaGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBTUE7OztDQUdDLEdBQ0QsSUFBSUEsZUFBbUM7QUFDdkMsSUFBSUMsbUJBQStCO0FBRW5DOztDQUVDLEdBQ00sTUFBTUMsaUJBQWlCO0lBQzVCLElBQUksQ0FBQ0YsY0FBYztRQUNqQixJQUFJLEtBQTZCLEVBQUUsRUFFbEM7UUFFRCw4Q0FBOEM7UUFDOUMsTUFBTSxFQUFFSSxXQUFXLEVBQUUsR0FBRyxNQUFNLDZOQUF1QjtRQUNyREosZUFBZUk7SUFDakI7SUFFQSxPQUFPSixjQUFlLDhDQUE4QztBQUN0RSxFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNSyxxQkFBcUI7SUFDaEMsSUFBSSxDQUFDTCxjQUFjO1FBQ2pCLE1BQU0sSUFBSUcsTUFBTTtJQUNsQjtJQUNBLE9BQU9IO0FBQ1QsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTU0scUJBQXFCO0lBQ2hDLElBQUksQ0FBQ0wsa0JBQWtCO1FBQ3JCLElBQUksS0FBNkIsRUFBRSxFQUVsQztRQUVELDhDQUE4QztRQUM5QyxNQUFNLEVBQUVNLGVBQWUsRUFBRSxHQUFHLE1BQU0seU9BQTJCO1FBQzdETixtQkFBbUJNO0lBQ3JCO0lBRUEsT0FBT047QUFDVCxFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNTyx5QkFBeUI7SUFDcEMsSUFBSSxDQUFDUCxrQkFBa0I7UUFDckIsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Y7QUFDVCxFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNUSxnQkFBZ0I7SUFDM0IsSUFBSSxLQUE2QixFQUFFLEVBRWxDO0lBRUQsbUNBQW1DO0lBQ25DLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUcsTUFBTSwyTUFBaUI7SUFDOUMsT0FBT0E7QUFDVCxFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNQyxZQUFZLElBQU0sYUFBa0IsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL3NyYy9jbGllbnQvY2FjaGUvQ2xpZW50Q2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICdAZmplbGwvY2FjaGUnO1xuaW1wb3J0IHsgV2lkZ2V0IH0gZnJvbSAnLi4vLi4vbW9kZWwvV2lkZ2V0JztcblxuLy8gVHlwZS1vbmx5IGltcG9ydHMgdG8gYXZvaWQgdHJpZ2dlcmluZyBjYWNoZSBjcmVhdGlvbiBkdXJpbmcgU1NSXG50eXBlIFdpZGdldENhY2hlID0gQ2FjaGU8V2lkZ2V0LCAnd2lkZ2V0Jz47XG5cbi8qKlxuICogQ2xpZW50LXNpZGUgY2FjaGUgaW5zdGFuY2VzIHRoYXQgYXJlIG9ubHkgaW5pdGlhbGl6ZWQgd2hlbiBhY2Nlc3NlZCBpbiB0aGUgYnJvd3Nlci5cbiAqIFRoaXMgcHJldmVudHMgU1NSIGlzc3VlcyB3aXRoIEluZGV4ZWREQi5cbiAqL1xubGV0IF93aWRnZXRDYWNoZTogV2lkZ2V0Q2FjaGUgfCBudWxsID0gbnVsbDtcbmxldCBfd2lkZ2V0VHlwZUNhY2hlOiBhbnkgfCBudWxsID0gbnVsbDtcblxuLyoqXG4gKiBHZXQgd2lkZ2V0IGNhY2hlIGluc3RhbmNlLCBpbml0aWFsaXppbmcgaXQgb25seSBvbiBmaXJzdCBhY2Nlc3MgaW4gdGhlIGJyb3dzZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFdpZGdldENhY2hlID0gYXN5bmMgKCk6IFByb21pc2U8V2lkZ2V0Q2FjaGU+ID0+IHtcbiAgaWYgKCFfd2lkZ2V0Q2FjaGUpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2lkZ2V0IGNhY2hlIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQnKTtcbiAgICB9XG5cbiAgICAvLyBJbXBvcnQgYW5kIGluaXRpYWxpemUgY2FjaGUgb25seSBpbiBicm93c2VyXG4gICAgY29uc3QgeyB3aWRnZXRDYWNoZSB9ID0gYXdhaXQgaW1wb3J0KCcuL1dpZGdldENhY2hlJyk7XG4gICAgX3dpZGdldENhY2hlID0gd2lkZ2V0Q2FjaGU7XG4gIH1cblxuICByZXR1cm4gX3dpZGdldENhY2hlITsgLy8gV2Uga25vdyBpdCdzIG5vdCBudWxsIGFmdGVyIHRoZSBjaGVjayBhYm92ZVxufTtcblxuLyoqXG4gKiBHZXQgd2lkZ2V0IGNhY2hlIGluc3RhbmNlIHN5bmNocm9ub3VzbHkgKG11c3QgYmUgY2FsbGVkIGFmdGVyIGFzeW5jIGluaXRpYWxpemF0aW9uKVxuICovXG5leHBvcnQgY29uc3QgZ2V0V2lkZ2V0Q2FjaGVTeW5jID0gKCk6IFdpZGdldENhY2hlID0+IHtcbiAgaWYgKCFfd2lkZ2V0Q2FjaGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpZGdldCBjYWNoZSBub3QgeWV0IGluaXRpYWxpemVkLiBDYWxsIGdldFdpZGdldENhY2hlKCkgZmlyc3QuJyk7XG4gIH1cbiAgcmV0dXJuIF93aWRnZXRDYWNoZTtcbn07XG5cbi8qKlxuICogR2V0IHdpZGdldCB0eXBlIGNhY2hlIGluc3RhbmNlLCBpbml0aWFsaXppbmcgaXQgb25seSBvbiBmaXJzdCBhY2Nlc3MgaW4gdGhlIGJyb3dzZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFdpZGdldFR5cGVDYWNoZSA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCFfd2lkZ2V0VHlwZUNhY2hlKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpZGdldCB0eXBlIGNhY2hlIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQnKTtcbiAgICB9XG5cbiAgICAvLyBJbXBvcnQgYW5kIGluaXRpYWxpemUgY2FjaGUgb25seSBpbiBicm93c2VyXG4gICAgY29uc3QgeyB3aWRnZXRUeXBlQ2FjaGUgfSA9IGF3YWl0IGltcG9ydCgnLi9XaWRnZXRUeXBlQ2FjaGUnKTtcbiAgICBfd2lkZ2V0VHlwZUNhY2hlID0gd2lkZ2V0VHlwZUNhY2hlO1xuICB9XG5cbiAgcmV0dXJuIF93aWRnZXRUeXBlQ2FjaGU7XG59O1xuXG4vKipcbiAqIEdldCB3aWRnZXQgdHlwZSBjYWNoZSBpbnN0YW5jZSBzeW5jaHJvbm91c2x5IChtdXN0IGJlIGNhbGxlZCBhZnRlciBhc3luYyBpbml0aWFsaXphdGlvbilcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFdpZGdldFR5cGVDYWNoZVN5bmMgPSAoKSA9PiB7XG4gIGlmICghX3dpZGdldFR5cGVDYWNoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2lkZ2V0IHR5cGUgY2FjaGUgbm90IHlldCBpbml0aWFsaXplZC4gQ2FsbCBnZXRXaWRnZXRUeXBlQ2FjaGUoKSBmaXJzdC4nKTtcbiAgfVxuICByZXR1cm4gX3dpZGdldFR5cGVDYWNoZTtcbn07XG5cbi8qKlxuICogR2V0IGFsbCBjYWNoZSB1dGlsaXRpZXMsIGluaXRpYWxpemluZyB0aGVtIG9ubHkgb24gZmlyc3QgYWNjZXNzIGluIHRoZSBicm93c2VyXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDYWNoZVV0aWxzID0gYXN5bmMgKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIHV0aWxzIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQnKTtcbiAgfVxuXG4gIC8vIEltcG9ydCB1dGlsaXRpZXMgb25seSBpbiBicm93c2VyXG4gIGNvbnN0IHsgY2FjaGVVdGlscyB9ID0gYXdhaXQgaW1wb3J0KCcuL2luZGV4Jyk7XG4gIHJldHVybiBjYWNoZVV0aWxzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuIl0sIm5hbWVzIjpbIl93aWRnZXRDYWNoZSIsIl93aWRnZXRUeXBlQ2FjaGUiLCJnZXRXaWRnZXRDYWNoZSIsIkVycm9yIiwid2lkZ2V0Q2FjaGUiLCJnZXRXaWRnZXRDYWNoZVN5bmMiLCJnZXRXaWRnZXRUeXBlQ2FjaGUiLCJ3aWRnZXRUeXBlQ2FjaGUiLCJnZXRXaWRnZXRUeXBlQ2FjaGVTeW5jIiwiZ2V0Q2FjaGVVdGlscyIsImNhY2hlVXRpbHMiLCJpc0Jyb3dzZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/cache/ClientCache.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/components/WidgetCard.tsx":
/*!**********************************************!*\
  !*** ./src/client/components/WidgetCard.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WidgetCard: () => (/* binding */ WidgetCard)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _providers_WidgetTypeProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../providers/WidgetTypeProvider */ \"(app-pages-browser)/./src/client/providers/WidgetTypeProvider.tsx\");\n/* __next_internal_client_entry_do_not_use__ WidgetCard auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst WidgetCard = (param)=>{\n    let { widget, onEdit, onDelete } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const { items: widgetTypes } = (0,_providers_WidgetTypeProvider__WEBPACK_IMPORTED_MODULE_3__.useWidgetTypes)();\n    const formatData = (data)=>{\n        if (!data) return 'No data';\n        return JSON.stringify(data, null, 2);\n    };\n    const formatDate = (date)=>{\n        return new Date(date).toLocaleDateString();\n    };\n    const getWidgetTypeName = ()=>{\n        const widgetType = widgetTypes.find((wt)=>wt.id === widget.widgetTypeId);\n        return widgetType ? \"\".concat(widgetType.name, \" (\").concat(widgetType.code, \")\") : widget.widgetTypeId;\n    };\n    const handleCardClick = ()=>{\n        router.push(\"/widget/\".concat(widget.id));\n    };\n    var _widget_createdAt, _widget_updatedAt;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"widget-card \".concat(!widget.isActive ? 'inactive' : ''),\n        onClick: handleCardClick,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"widget-header\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"widget-name\",\n                        children: widget.name\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 43,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"widget-status\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"status-badge \".concat(widget.isActive ? 'active' : 'inactive'),\n                            children: widget.isActive ? 'Active' : 'Inactive'\n                        }, void 0, false, {\n                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                            lineNumber: 45,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 44,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                lineNumber: 42,\n                columnNumber: 7\n            }, undefined),\n            widget.description && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"widget-description\",\n                children: widget.description\n            }, void 0, false, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                lineNumber: 52,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"widget-details\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"detail-row\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"label\",\n                                children: \"ID:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"value\",\n                                children: widget.id\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 58,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 56,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"detail-row\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"label\",\n                                children: \"Type:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 61,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"value\",\n                                children: getWidgetTypeName()\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 62,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 60,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"detail-row\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"label\",\n                                children: \"Created:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 65,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"value\",\n                                children: formatDate((_widget_createdAt = widget.createdAt) !== null && _widget_createdAt !== void 0 ? _widget_createdAt : new Date())\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 66,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 64,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"detail-row\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"label\",\n                                children: \"Updated:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 69,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"value\",\n                                children: formatDate((_widget_updatedAt = widget.updatedAt) !== null && _widget_updatedAt !== void 0 ? _widget_updatedAt : new Date())\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                                lineNumber: 70,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 68,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                lineNumber: 55,\n                columnNumber: 7\n            }, undefined),\n            widget.data && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"widget-data\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                        children: \"Data:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 76,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                        className: \"data-display\",\n                        children: formatData(widget.data)\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 77,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                lineNumber: 75,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"widget-actions\",\n                children: [\n                    onEdit && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"btn btn-primary\",\n                        onClick: (e)=>{\n                            e.stopPropagation();\n                            onEdit(widget);\n                        },\n                        children: \"Edit\"\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 83,\n                        columnNumber: 11\n                    }, undefined),\n                    onDelete && widget.isActive && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"btn btn-danger\",\n                        onClick: (e)=>{\n                            e.stopPropagation();\n                            onDelete(widget);\n                        },\n                        children: \"Delete\"\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                        lineNumber: 94,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n                lineNumber: 81,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetCard.tsx\",\n        lineNumber: 41,\n        columnNumber: 5\n    }, undefined);\n};\n_s(WidgetCard, \"NWZ4SBK4KXDJ25wLzaZzSfIa0cg=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        _providers_WidgetTypeProvider__WEBPACK_IMPORTED_MODULE_3__.useWidgetTypes\n    ];\n});\n_c = WidgetCard;\nvar _c;\n$RefreshReg$(_c, \"WidgetCard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvY29tcG9uZW50cy9XaWRnZXRDYXJkLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUwQjtBQUNrQjtBQUVxQjtBQVExRCxNQUFNRyxhQUF3QztRQUFDLEVBQ3BEQyxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsUUFBUSxFQUNUOztJQUNDLE1BQU1DLFNBQVNOLDBEQUFTQTtJQUN4QixNQUFNLEVBQUVPLE9BQU9DLFdBQVcsRUFBRSxHQUFHUCw2RUFBY0E7SUFFN0MsTUFBTVEsYUFBYSxDQUFDQztRQUNsQixJQUFJLENBQUNBLE1BQU0sT0FBTztRQUNsQixPQUFPQyxLQUFLQyxTQUFTLENBQUNGLE1BQU0sTUFBTTtJQUNwQztJQUVBLE1BQU1HLGFBQWEsQ0FBQ0M7UUFDbEIsT0FBTyxJQUFJQyxLQUFLRCxNQUFNRSxrQkFBa0I7SUFDMUM7SUFFQSxNQUFNQyxvQkFBb0I7UUFDeEIsTUFBTUMsYUFBYVYsWUFBWVcsSUFBSSxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHQyxFQUFFLEtBQUtsQixPQUFPbUIsWUFBWTtRQUN2RSxPQUFPSixhQUFhLEdBQXVCQSxPQUFwQkEsV0FBV0ssSUFBSSxFQUFDLE1BQW9CLE9BQWhCTCxXQUFXTSxJQUFJLEVBQUMsT0FBS3JCLE9BQU9tQixZQUFZO0lBQ3JGO0lBRUEsTUFBTUcsa0JBQWtCO1FBQ3RCbkIsT0FBT29CLElBQUksQ0FBQyxXQUFxQixPQUFWdkIsT0FBT2tCLEVBQUU7SUFDbEM7UUE0QjRDbEIsbUJBSUFBO0lBOUI1QyxxQkFDRSw4REFBQ3dCO1FBQUlDLFdBQVcsZUFBa0QsT0FBbkMsQ0FBQ3pCLE9BQU8wQixRQUFRLEdBQUcsYUFBYTtRQUFNQyxTQUFTTDs7MEJBQzVFLDhEQUFDRTtnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUNHO3dCQUFHSCxXQUFVO2tDQUFlekIsT0FBT29CLElBQUk7Ozs7OztrQ0FDeEMsOERBQUNJO3dCQUFJQyxXQUFVO2tDQUNiLDRFQUFDSTs0QkFBS0osV0FBVyxnQkFBd0QsT0FBeEN6QixPQUFPMEIsUUFBUSxHQUFHLFdBQVc7c0NBQzNEMUIsT0FBTzBCLFFBQVEsR0FBRyxXQUFXOzs7Ozs7Ozs7Ozs7Ozs7OztZQUtuQzFCLE9BQU84QixXQUFXLGtCQUNqQiw4REFBQ0M7Z0JBQUVOLFdBQVU7MEJBQXNCekIsT0FBTzhCLFdBQVc7Ozs7OzswQkFHdkQsOERBQUNOO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0Q7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDSTtnQ0FBS0osV0FBVTswQ0FBUTs7Ozs7OzBDQUN4Qiw4REFBQ0k7Z0NBQUtKLFdBQVU7MENBQVN6QixPQUFPa0IsRUFBRTs7Ozs7Ozs7Ozs7O2tDQUVwQyw4REFBQ007d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDSTtnQ0FBS0osV0FBVTswQ0FBUTs7Ozs7OzBDQUN4Qiw4REFBQ0k7Z0NBQUtKLFdBQVU7MENBQVNYOzs7Ozs7Ozs7Ozs7a0NBRTNCLDhEQUFDVTt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNJO2dDQUFLSixXQUFVOzBDQUFROzs7Ozs7MENBQ3hCLDhEQUFDSTtnQ0FBS0osV0FBVTswQ0FBU2YsV0FBV1YsQ0FBQUEsb0JBQUFBLE9BQU9nQyxTQUFTLGNBQWhCaEMsK0JBQUFBLG9CQUFvQixJQUFJWTs7Ozs7Ozs7Ozs7O2tDQUU5RCw4REFBQ1k7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDSTtnQ0FBS0osV0FBVTswQ0FBUTs7Ozs7OzBDQUN4Qiw4REFBQ0k7Z0NBQUtKLFdBQVU7MENBQVNmLFdBQVdWLENBQUFBLG9CQUFBQSxPQUFPaUMsU0FBUyxjQUFoQmpDLCtCQUFBQSxvQkFBb0IsSUFBSVk7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUkvRFosT0FBT08sSUFBSSxrQkFDViw4REFBQ2lCO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ1M7a0NBQUc7Ozs7OztrQ0FDSiw4REFBQ0M7d0JBQUlWLFdBQVU7a0NBQWdCbkIsV0FBV04sT0FBT08sSUFBSTs7Ozs7Ozs7Ozs7OzBCQUl6RCw4REFBQ2lCO2dCQUFJQyxXQUFVOztvQkFDWnhCLHdCQUNDLDhEQUFDbUM7d0JBQ0NYLFdBQVU7d0JBQ1ZFLFNBQVMsQ0FBQ1U7NEJBQ1JBLEVBQUVDLGVBQWU7NEJBQ2pCckMsT0FBT0Q7d0JBQ1Q7a0NBQ0Q7Ozs7OztvQkFJRkUsWUFBWUYsT0FBTzBCLFFBQVEsa0JBQzFCLDhEQUFDVTt3QkFDQ1gsV0FBVTt3QkFDVkUsU0FBUyxDQUFDVTs0QkFDUkEsRUFBRUMsZUFBZTs0QkFDakJwQyxTQUFTRjt3QkFDWDtrQ0FDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT1gsRUFBRTtHQTdGV0Q7O1FBS0lGLHNEQUFTQTtRQUNPQyx5RUFBY0E7OztLQU5sQ0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy90b2JyaWVuL2dpdHcvZ2V0ZmplbGwvZmplbGwtc2FtcGxlLWFwcC9zcmMvY2xpZW50L2NvbXBvbmVudHMvV2lkZ2V0Q2FyZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBXaWRnZXQgfSBmcm9tICcuLi8uLi9tb2RlbC9XaWRnZXQnO1xuaW1wb3J0IHsgdXNlV2lkZ2V0VHlwZXMgfSBmcm9tICcuLi9wcm92aWRlcnMvV2lkZ2V0VHlwZVByb3ZpZGVyJztcblxuaW50ZXJmYWNlIFdpZGdldENhcmRQcm9wcyB7XG4gIHdpZGdldDogV2lkZ2V0O1xuICBvbkVkaXQ/OiAod2lkZ2V0OiBXaWRnZXQpID0+IHZvaWQ7XG4gIG9uRGVsZXRlPzogKHdpZGdldDogV2lkZ2V0KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgV2lkZ2V0Q2FyZDogUmVhY3QuRkM8V2lkZ2V0Q2FyZFByb3BzPiA9ICh7XG4gIHdpZGdldCxcbiAgb25FZGl0LFxuICBvbkRlbGV0ZVxufSkgPT4ge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgeyBpdGVtczogd2lkZ2V0VHlwZXMgfSA9IHVzZVdpZGdldFR5cGVzKCk7XG5cbiAgY29uc3QgZm9ybWF0RGF0YSA9IChkYXRhOiBhbnkpID0+IHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiAnTm8gZGF0YSc7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICB9O1xuXG4gIGNvbnN0IGZvcm1hdERhdGUgPSAoZGF0ZTogc3RyaW5nIHwgRGF0ZSkgPT4ge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgfTtcblxuICBjb25zdCBnZXRXaWRnZXRUeXBlTmFtZSA9ICgpID0+IHtcbiAgICBjb25zdCB3aWRnZXRUeXBlID0gd2lkZ2V0VHlwZXMuZmluZCh3dCA9PiB3dC5pZCA9PT0gd2lkZ2V0LndpZGdldFR5cGVJZCk7XG4gICAgcmV0dXJuIHdpZGdldFR5cGUgPyBgJHt3aWRnZXRUeXBlLm5hbWV9ICgke3dpZGdldFR5cGUuY29kZX0pYCA6IHdpZGdldC53aWRnZXRUeXBlSWQ7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2FyZENsaWNrID0gKCkgPT4ge1xuICAgIHJvdXRlci5wdXNoKGAvd2lkZ2V0LyR7d2lkZ2V0LmlkfWApO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2B3aWRnZXQtY2FyZCAkeyF3aWRnZXQuaXNBY3RpdmUgPyAnaW5hY3RpdmUnIDogJyd9YH0gb25DbGljaz17aGFuZGxlQ2FyZENsaWNrfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkZ2V0LWhlYWRlclwiPlxuICAgICAgICA8aDMgY2xhc3NOYW1lPVwid2lkZ2V0LW5hbWVcIj57d2lkZ2V0Lm5hbWV9PC9oMz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWRnZXQtc3RhdHVzXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgc3RhdHVzLWJhZGdlICR7d2lkZ2V0LmlzQWN0aXZlID8gJ2FjdGl2ZScgOiAnaW5hY3RpdmUnfWB9PlxuICAgICAgICAgICAge3dpZGdldC5pc0FjdGl2ZSA/ICdBY3RpdmUnIDogJ0luYWN0aXZlJ31cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHt3aWRnZXQuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ3aWRnZXQtZGVzY3JpcHRpb25cIj57d2lkZ2V0LmRlc2NyaXB0aW9ufTwvcD5cbiAgICAgICl9XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkZ2V0LWRldGFpbHNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZXRhaWwtcm93XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibGFiZWxcIj5JRDo8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidmFsdWVcIj57d2lkZ2V0LmlkfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGV0YWlsLXJvd1wiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImxhYmVsXCI+VHlwZTo8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidmFsdWVcIj57Z2V0V2lkZ2V0VHlwZU5hbWUoKX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRldGFpbC1yb3dcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYWJlbFwiPkNyZWF0ZWQ6PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInZhbHVlXCI+e2Zvcm1hdERhdGUod2lkZ2V0LmNyZWF0ZWRBdCA/PyBuZXcgRGF0ZSgpKX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRldGFpbC1yb3dcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYWJlbFwiPlVwZGF0ZWQ6PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInZhbHVlXCI+e2Zvcm1hdERhdGUod2lkZ2V0LnVwZGF0ZWRBdCA/PyBuZXcgRGF0ZSgpKX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHt3aWRnZXQuZGF0YSAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkZ2V0LWRhdGFcIj5cbiAgICAgICAgICA8aDQ+RGF0YTo8L2g0PlxuICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPVwiZGF0YS1kaXNwbGF5XCI+e2Zvcm1hdERhdGEod2lkZ2V0LmRhdGEpfTwvcHJlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkZ2V0LWFjdGlvbnNcIj5cbiAgICAgICAge29uRWRpdCAmJiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1wcmltYXJ5XCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIG9uRWRpdCh3aWRnZXQpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBFZGl0XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICl9XG4gICAgICAgIHtvbkRlbGV0ZSAmJiB3aWRnZXQuaXNBY3RpdmUgJiYgKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0biBidG4tZGFuZ2VyXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIG9uRGVsZXRlKHdpZGdldCk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIERlbGV0ZVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlUm91dGVyIiwidXNlV2lkZ2V0VHlwZXMiLCJXaWRnZXRDYXJkIiwid2lkZ2V0Iiwib25FZGl0Iiwib25EZWxldGUiLCJyb3V0ZXIiLCJpdGVtcyIsIndpZGdldFR5cGVzIiwiZm9ybWF0RGF0YSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybWF0RGF0ZSIsImRhdGUiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiZ2V0V2lkZ2V0VHlwZU5hbWUiLCJ3aWRnZXRUeXBlIiwiZmluZCIsInd0IiwiaWQiLCJ3aWRnZXRUeXBlSWQiLCJuYW1lIiwiY29kZSIsImhhbmRsZUNhcmRDbGljayIsInB1c2giLCJkaXYiLCJjbGFzc05hbWUiLCJpc0FjdGl2ZSIsIm9uQ2xpY2siLCJoMyIsInNwYW4iLCJkZXNjcmlwdGlvbiIsInAiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJoNCIsInByZSIsImJ1dHRvbiIsImUiLCJzdG9wUHJvcGFnYXRpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/components/WidgetCard.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/components/WidgetList.tsx":
/*!**********************************************!*\
  !*** ./src/client/components/WidgetList.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WidgetList: () => (/* binding */ WidgetList)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _providers_WidgetProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../providers/WidgetProvider */ \"(app-pages-browser)/./src/client/providers/WidgetProvider.tsx\");\n/* harmony import */ var _WidgetCard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WidgetCard */ \"(app-pages-browser)/./src/client/components/WidgetCard.tsx\");\n/* __next_internal_client_entry_do_not_use__ WidgetList auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst WidgetList = ()=>{\n    _s();\n    const { items: widgets, isLoading: loading, remove: deleteWidget } = (0,_providers_WidgetProvider__WEBPACK_IMPORTED_MODULE_2__.useWidgets)();\n    const [summary, setSummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showInactive, setShowInactive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Load summary data\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WidgetList.useEffect\": ()=>{\n            const loadSummary = {\n                \"WidgetList.useEffect.loadSummary\": async ()=>{\n                    try {\n                        // Calculate summary from widgets data\n                        const active = widgets.filter({\n                            \"WidgetList.useEffect.loadSummary\": (w)=>w.isActive\n                        }[\"WidgetList.useEffect.loadSummary\"]).length;\n                        const total = widgets.length;\n                        const inactive = total - active;\n                        const activePercentage = total > 0 ? Math.round(active / total * 100) : 0;\n                        setSummary({\n                            total,\n                            active,\n                            inactive,\n                            activePercentage\n                        });\n                    } catch (error) {\n                        console.error('Failed to calculate summary:', error);\n                    }\n                }\n            }[\"WidgetList.useEffect.loadSummary\"];\n            loadSummary();\n        }\n    }[\"WidgetList.useEffect\"], [\n        widgets\n    ]);\n    const handleDelete = async (widget)=>{\n        if (window.confirm('Are you sure you want to delete \"'.concat(widget.name, '\"?'))) {\n            try {\n                await deleteWidget(widget.key);\n            } catch (error) {\n                console.error('Failed to delete widget:', error);\n                alert('Failed to delete widget. Please try again.');\n            }\n        }\n    };\n    const filteredWidgets = widgets.filter((widget)=>showInactive || widget.isActive);\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"widget-list-container\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"loading\",\n                children: \"Loading widgets...\"\n            }, void 0, false, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                lineNumber: 56,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n            lineNumber: 55,\n            columnNumber: 7\n        }, undefined);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"widget-list-container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"widget-list-header\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        children: \"Widgets\"\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                        lineNumber: 64,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"small\", {\n                        style: {\n                            color: '#666',\n                            marginLeft: '10px'\n                        },\n                        children: \"(Using IndexedDB Cache)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                        lineNumber: 65,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"widget-controls\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"btn btn-secondary\",\n                                onClick: ()=>{},\n                                children: \"Refresh\"\n                            }, void 0, false, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                lineNumber: 69,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"checkbox-label\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"checkbox\",\n                                        checked: showInactive,\n                                        onChange: (e)=>setShowInactive(e.target.checked)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                        lineNumber: 76,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    \"Show inactive widgets\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                lineNumber: 75,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                        lineNumber: 68,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                lineNumber: 63,\n                columnNumber: 7\n            }, undefined),\n            summary && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"widget-summary\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"summary-card\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            children: \"Summary\"\n                        }, void 0, false, {\n                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                            lineNumber: 89,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"summary-stats\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"stat\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-value\",\n                                            children: summary.total\n                                        }, void 0, false, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 92,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-label\",\n                                            children: \"Total\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 93,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                    lineNumber: 91,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"stat\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-value\",\n                                            children: summary.active\n                                        }, void 0, false, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 96,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-label\",\n                                            children: \"Active\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 97,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                    lineNumber: 95,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"stat\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-value\",\n                                            children: summary.inactive\n                                        }, void 0, false, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 100,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-label\",\n                                            children: \"Inactive\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 101,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                    lineNumber: 99,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"stat\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-value\",\n                                            children: [\n                                                summary.activePercentage,\n                                                \"%\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 104,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"stat-label\",\n                                            children: \"Active Rate\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                            lineNumber: 105,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                                    lineNumber: 103,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                            lineNumber: 90,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                    lineNumber: 88,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                lineNumber: 87,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"widget-grid\",\n                children: filteredWidgets.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"no-widgets\",\n                    children: showInactive ? 'No widgets found.' : 'No active widgets found. Try showing inactive widgets.'\n                }, void 0, false, {\n                    fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                    lineNumber: 114,\n                    columnNumber: 11\n                }, undefined) : filteredWidgets.map((widget)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_WidgetCard__WEBPACK_IMPORTED_MODULE_3__.WidgetCard, {\n                        widget: widget,\n                        onDelete: handleDelete\n                    }, widget.id, false, {\n                        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                        lineNumber: 122,\n                        columnNumber: 13\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n                lineNumber: 112,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/components/WidgetList.tsx\",\n        lineNumber: 62,\n        columnNumber: 5\n    }, undefined);\n};\n_s(WidgetList, \"teDfTJlhTvM0/rvlAMq90jpuYDU=\", false, function() {\n    return [\n        _providers_WidgetProvider__WEBPACK_IMPORTED_MODULE_2__.useWidgets\n    ];\n});\n_c = WidgetList;\nvar _c;\n$RefreshReg$(_c, \"WidgetList\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvY29tcG9uZW50cy9XaWRnZXRMaXN0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUVtRDtBQUNNO0FBQ2Y7QUFJbkMsTUFBTUssYUFBdUI7O0lBQ2xDLE1BQU0sRUFBRUMsT0FBT0MsT0FBTyxFQUFFQyxXQUFXQyxPQUFPLEVBQUVDLFFBQVFDLFlBQVksRUFBRSxHQUFHUixxRUFBVUE7SUFDL0UsTUFBTSxDQUFDUyxTQUFTQyxXQUFXLEdBQUdYLCtDQUFRQSxDQUF1QjtJQUM3RCxNQUFNLENBQUNZLGNBQWNDLGdCQUFnQixHQUFHYiwrQ0FBUUEsQ0FBQztJQUVqRCxvQkFBb0I7SUFDcEJELGdEQUFTQTtnQ0FBQztZQUNSLE1BQU1lO29EQUFjO29CQUNsQixJQUFJO3dCQUNGLHNDQUFzQzt3QkFDdEMsTUFBTUMsU0FBU1YsUUFBUVcsTUFBTTtnRUFBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsUUFBUTsrREFBRUMsTUFBTTt3QkFDckQsTUFBTUMsUUFBUWYsUUFBUWMsTUFBTTt3QkFDNUIsTUFBTUUsV0FBV0QsUUFBUUw7d0JBQ3pCLE1BQU1PLG1CQUFtQkYsUUFBUSxJQUFJRyxLQUFLQyxLQUFLLENBQUMsU0FBVUosUUFBUyxPQUFPO3dCQUUxRVQsV0FBVzs0QkFDVFM7NEJBQ0FMOzRCQUNBTTs0QkFDQUM7d0JBQ0Y7b0JBQ0YsRUFBRSxPQUFPRyxPQUFPO3dCQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtvQkFDaEQ7Z0JBQ0Y7O1lBRUFYO1FBQ0Y7K0JBQUc7UUFBQ1Q7S0FBUTtJQUVaLE1BQU1zQixlQUFlLE9BQU9DO1FBQzFCLElBQUlDLE9BQU9DLE9BQU8sQ0FBQyxvQ0FBZ0QsT0FBWkYsT0FBT0csSUFBSSxFQUFDLFFBQU07WUFDdkUsSUFBSTtnQkFDRixNQUFNdEIsYUFBYW1CLE9BQU9JLEdBQUc7WUFDL0IsRUFBRSxPQUFPUCxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtnQkFDMUNRLE1BQU07WUFDUjtRQUNGO0lBQ0Y7SUFFQSxNQUFNQyxrQkFBa0I3QixRQUFRVyxNQUFNLENBQUNZLENBQUFBLFNBQ3JDaEIsZ0JBQWdCZ0IsT0FBT1YsUUFBUTtJQUdqQyxJQUFJWCxTQUFTO1FBQ1gscUJBQ0UsOERBQUM0QjtZQUFJQyxXQUFVO3NCQUNiLDRFQUFDRDtnQkFBSUMsV0FBVTswQkFBVTs7Ozs7Ozs7Ozs7SUFHL0I7SUFFQSxxQkFDRSw4REFBQ0Q7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0M7a0NBQUc7Ozs7OztrQ0FDSiw4REFBQ0M7d0JBQU1DLE9BQU87NEJBQUVDLE9BQU87NEJBQVFDLFlBQVk7d0JBQU87a0NBQUc7Ozs7OztrQ0FHckQsOERBQUNOO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ007Z0NBQ0NOLFdBQVU7Z0NBQ1ZPLFNBQVMsS0FBUTswQ0FDbEI7Ozs7OzswQ0FHRCw4REFBQ0M7Z0NBQU1SLFdBQVU7O2tEQUNmLDhEQUFDUzt3Q0FDQ0MsTUFBSzt3Q0FDTEMsU0FBU25DO3dDQUNUb0MsVUFBVSxDQUFDQyxJQUFNcEMsZ0JBQWdCb0MsRUFBRUMsTUFBTSxDQUFDSCxPQUFPOzs7Ozs7b0NBQ2pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBTVByQyx5QkFDQyw4REFBQ3lCO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNlO3NDQUFHOzs7Ozs7c0NBQ0osOERBQUNoQjs0QkFBSUMsV0FBVTs7OENBQ2IsOERBQUNEO29DQUFJQyxXQUFVOztzREFDYiw4REFBQ2dCOzRDQUFLaEIsV0FBVTtzREFBYzFCLFFBQVFVLEtBQUs7Ozs7OztzREFDM0MsOERBQUNnQzs0Q0FBS2hCLFdBQVU7c0RBQWE7Ozs7Ozs7Ozs7Ozs4Q0FFL0IsOERBQUNEO29DQUFJQyxXQUFVOztzREFDYiw4REFBQ2dCOzRDQUFLaEIsV0FBVTtzREFBYzFCLFFBQVFLLE1BQU07Ozs7OztzREFDNUMsOERBQUNxQzs0Q0FBS2hCLFdBQVU7c0RBQWE7Ozs7Ozs7Ozs7Ozs4Q0FFL0IsOERBQUNEO29DQUFJQyxXQUFVOztzREFDYiw4REFBQ2dCOzRDQUFLaEIsV0FBVTtzREFBYzFCLFFBQVFXLFFBQVE7Ozs7OztzREFDOUMsOERBQUMrQjs0Q0FBS2hCLFdBQVU7c0RBQWE7Ozs7Ozs7Ozs7Ozs4Q0FFL0IsOERBQUNEO29DQUFJQyxXQUFVOztzREFDYiw4REFBQ2dCOzRDQUFLaEIsV0FBVTs7Z0RBQWMxQixRQUFRWSxnQkFBZ0I7Z0RBQUM7Ozs7Ozs7c0RBQ3ZELDhEQUFDOEI7NENBQUtoQixXQUFVO3NEQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPdkMsOERBQUNEO2dCQUFJQyxXQUFVOzBCQUNaRixnQkFBZ0JmLE1BQU0sS0FBSyxrQkFDMUIsOERBQUNnQjtvQkFBSUMsV0FBVTs4QkFDWnhCLGVBQ0csc0JBQ0E7Ozs7O2dDQUlOc0IsZ0JBQWdCbUIsR0FBRyxDQUFDekIsQ0FBQUEsdUJBQ2xCLDhEQUFDMUIsbURBQVVBO3dCQUVUMEIsUUFBUUE7d0JBQ1IwQixVQUFVM0I7dUJBRkxDLE9BQU8yQixFQUFFOzs7Ozs7Ozs7Ozs7Ozs7O0FBUzVCLEVBQUU7R0EzSFdwRDs7UUFDMERGLGlFQUFVQTs7O0tBRHBFRSIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL3NyYy9jbGllbnQvY29tcG9uZW50cy9XaWRnZXRMaXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VXaWRnZXRzIH0gZnJvbSAnLi4vcHJvdmlkZXJzL1dpZGdldFByb3ZpZGVyJztcbmltcG9ydCB7IFdpZGdldENhcmQgfSBmcm9tICcuL1dpZGdldENhcmQnO1xuaW1wb3J0IHR5cGUgeyBXaWRnZXQgfSBmcm9tICcuLi8uLi9tb2RlbC9XaWRnZXQnO1xuaW1wb3J0IHR5cGUgeyBXaWRnZXRTdW1tYXJ5IH0gZnJvbSAnLi4vYXBpL1dpZGdldEFQSSc7XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRMaXN0OiBSZWFjdC5GQyA9ICgpID0+IHtcbiAgY29uc3QgeyBpdGVtczogd2lkZ2V0cywgaXNMb2FkaW5nOiBsb2FkaW5nLCByZW1vdmU6IGRlbGV0ZVdpZGdldCB9ID0gdXNlV2lkZ2V0cygpO1xuICBjb25zdCBbc3VtbWFyeSwgc2V0U3VtbWFyeV0gPSB1c2VTdGF0ZTxXaWRnZXRTdW1tYXJ5IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzaG93SW5hY3RpdmUsIHNldFNob3dJbmFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gTG9hZCBzdW1tYXJ5IGRhdGFcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkU3VtbWFyeSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBzdW1tYXJ5IGZyb20gd2lkZ2V0cyBkYXRhXG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHdpZGdldHMuZmlsdGVyKHcgPT4gdy5pc0FjdGl2ZSkubGVuZ3RoO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHdpZGdldHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbmFjdGl2ZSA9IHRvdGFsIC0gYWN0aXZlO1xuICAgICAgICBjb25zdCBhY3RpdmVQZXJjZW50YWdlID0gdG90YWwgPiAwID8gTWF0aC5yb3VuZCgoYWN0aXZlIC8gdG90YWwpICogMTAwKSA6IDA7XG5cbiAgICAgICAgc2V0U3VtbWFyeSh7XG4gICAgICAgICAgdG90YWwsXG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIGluYWN0aXZlLFxuICAgICAgICAgIGFjdGl2ZVBlcmNlbnRhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2FsY3VsYXRlIHN1bW1hcnk6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkU3VtbWFyeSgpO1xuICB9LCBbd2lkZ2V0c10pO1xuXG4gIGNvbnN0IGhhbmRsZURlbGV0ZSA9IGFzeW5jICh3aWRnZXQ6IFdpZGdldCkgPT4ge1xuICAgIGlmICh3aW5kb3cuY29uZmlybShgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSBcIiR7d2lkZ2V0Lm5hbWV9XCI/YCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGRlbGV0ZVdpZGdldCh3aWRnZXQua2V5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgd2lkZ2V0OicsIGVycm9yKTtcbiAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBkZWxldGUgd2lkZ2V0LiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBmaWx0ZXJlZFdpZGdldHMgPSB3aWRnZXRzLmZpbHRlcih3aWRnZXQgPT5cbiAgICBzaG93SW5hY3RpdmUgfHwgd2lkZ2V0LmlzQWN0aXZlXG4gICk7XG5cbiAgaWYgKGxvYWRpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWRnZXQtbGlzdC1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2FkaW5nXCI+TG9hZGluZyB3aWRnZXRzLi4uPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIndpZGdldC1saXN0LWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWRnZXQtbGlzdC1oZWFkZXJcIj5cbiAgICAgICAgPGgyPldpZGdldHM8L2gyPlxuICAgICAgICA8c21hbGwgc3R5bGU9e3sgY29sb3I6ICcjNjY2JywgbWFyZ2luTGVmdDogJzEwcHgnIH19PlxuICAgICAgICAgIChVc2luZyBJbmRleGVkREIgQ2FjaGUpXG4gICAgICAgIDwvc21hbGw+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkZ2V0LWNvbnRyb2xzXCI+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4geyB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIFJlZnJlc2hcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiY2hlY2tib3gtbGFiZWxcIj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICBjaGVja2VkPXtzaG93SW5hY3RpdmV9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0U2hvd0luYWN0aXZlKGUudGFyZ2V0LmNoZWNrZWQpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIFNob3cgaW5hY3RpdmUgd2lkZ2V0c1xuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHtzdW1tYXJ5ICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWRnZXQtc3VtbWFyeVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3VtbWFyeS1jYXJkXCI+XG4gICAgICAgICAgICA8aDM+U3VtbWFyeTwvaDM+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN1bW1hcnktc3RhdHNcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzdGF0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3RhdC12YWx1ZVwiPntzdW1tYXJ5LnRvdGFsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzdGF0LWxhYmVsXCI+VG90YWw8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN0YXRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzdGF0LXZhbHVlXCI+e3N1bW1hcnkuYWN0aXZlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzdGF0LWxhYmVsXCI+QWN0aXZlPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzdGF0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3RhdC12YWx1ZVwiPntzdW1tYXJ5LmluYWN0aXZlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzdGF0LWxhYmVsXCI+SW5hY3RpdmU8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN0YXRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzdGF0LXZhbHVlXCI+e3N1bW1hcnkuYWN0aXZlUGVyY2VudGFnZX0lPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInN0YXQtbGFiZWxcIj5BY3RpdmUgUmF0ZTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIndpZGdldC1ncmlkXCI+XG4gICAgICAgIHtmaWx0ZXJlZFdpZGdldHMubGVuZ3RoID09PSAwID8gKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibm8td2lkZ2V0c1wiPlxuICAgICAgICAgICAge3Nob3dJbmFjdGl2ZVxuICAgICAgICAgICAgICA/ICdObyB3aWRnZXRzIGZvdW5kLidcbiAgICAgICAgICAgICAgOiAnTm8gYWN0aXZlIHdpZGdldHMgZm91bmQuIFRyeSBzaG93aW5nIGluYWN0aXZlIHdpZGdldHMuJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogKFxuICAgICAgICAgIGZpbHRlcmVkV2lkZ2V0cy5tYXAod2lkZ2V0ID0+IChcbiAgICAgICAgICAgIDxXaWRnZXRDYXJkXG4gICAgICAgICAgICAgIGtleT17d2lkZ2V0LmlkfVxuICAgICAgICAgICAgICB3aWRnZXQ9e3dpZGdldH1cbiAgICAgICAgICAgICAgb25EZWxldGU9e2hhbmRsZURlbGV0ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSlcbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlV2lkZ2V0cyIsIldpZGdldENhcmQiLCJXaWRnZXRMaXN0IiwiaXRlbXMiLCJ3aWRnZXRzIiwiaXNMb2FkaW5nIiwibG9hZGluZyIsInJlbW92ZSIsImRlbGV0ZVdpZGdldCIsInN1bW1hcnkiLCJzZXRTdW1tYXJ5Iiwic2hvd0luYWN0aXZlIiwic2V0U2hvd0luYWN0aXZlIiwibG9hZFN1bW1hcnkiLCJhY3RpdmUiLCJmaWx0ZXIiLCJ3IiwiaXNBY3RpdmUiLCJsZW5ndGgiLCJ0b3RhbCIsImluYWN0aXZlIiwiYWN0aXZlUGVyY2VudGFnZSIsIk1hdGgiLCJyb3VuZCIsImVycm9yIiwiY29uc29sZSIsImhhbmRsZURlbGV0ZSIsIndpZGdldCIsIndpbmRvdyIsImNvbmZpcm0iLCJuYW1lIiwia2V5IiwiYWxlcnQiLCJmaWx0ZXJlZFdpZGdldHMiLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsInNtYWxsIiwic3R5bGUiLCJjb2xvciIsIm1hcmdpbkxlZnQiLCJidXR0b24iLCJvbkNsaWNrIiwibGFiZWwiLCJpbnB1dCIsInR5cGUiLCJjaGVja2VkIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwiaDMiLCJzcGFuIiwibWFwIiwib25EZWxldGUiLCJpZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/components/WidgetList.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/pages/Home.tsx":
/*!***********************************!*\
  !*** ./src/client/pages/Home.tsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Home: () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _providers_WidgetProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../providers/WidgetProvider */ \"(app-pages-browser)/./src/client/providers/WidgetProvider.tsx\");\n/* harmony import */ var _components_WidgetList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/WidgetList */ \"(app-pages-browser)/./src/client/components/WidgetList.tsx\");\n/* __next_internal_client_entry_do_not_use__ Home auto */ \n\n\n\nconst Home = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_providers_WidgetProvider__WEBPACK_IMPORTED_MODULE_2__.WidgetsAll, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_WidgetList__WEBPACK_IMPORTED_MODULE_3__.WidgetList, {}, void 0, false, {\n            fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/pages/Home.tsx\",\n            lineNumber: 13,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/pages/Home.tsx\",\n        lineNumber: 10,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvcGFnZXMvSG9tZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUUwQjtBQUM4QztBQUVsQjtBQUUvQyxNQUFNRyxPQUFpQjtJQUM1QixxQkFDRSw4REFBQ0YsaUVBQVVBO2tCQUdULDRFQUFDQyw4REFBVUE7Ozs7Ozs7Ozs7QUFHakIsRUFBRTtLQVJXQyIsInNvdXJjZXMiOlsiL1VzZXJzL3RvYnJpZW4vZ2l0dy9nZXRmamVsbC9mamVsbC1zYW1wbGUtYXBwL3NyYy9jbGllbnQvcGFnZXMvSG9tZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBXaWRnZXRBZGFwdGVyLCBXaWRnZXRzQWxsIH0gZnJvbSAnLi4vcHJvdmlkZXJzL1dpZGdldFByb3ZpZGVyJztcbmltcG9ydCB7IFdpZGdldFR5cGVzQWxsIH0gZnJvbSAnLi4vcHJvdmlkZXJzL1dpZGdldFR5cGVQcm92aWRlcic7XG5pbXBvcnQgeyBXaWRnZXRMaXN0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9XaWRnZXRMaXN0JztcblxuZXhwb3J0IGNvbnN0IEhvbWU6IFJlYWN0LkZDID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxXaWRnZXRzQWxsPlxuICAgICAgey8qIDxEZWJ1Z1BJdGVtc1F1ZXJ5IC8+XG4gICAgICAgICAgPERlYnVnV2lkZ2V0TGlzdCAvPiAqL31cbiAgICAgIDxXaWRnZXRMaXN0IC8+XG4gICAgPC9XaWRnZXRzQWxsPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIldpZGdldHNBbGwiLCJXaWRnZXRMaXN0IiwiSG9tZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/pages/Home.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/providers/WidgetProvider.tsx":
/*!*************************************************!*\
  !*** ./src/client/providers/WidgetProvider.tsx ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WidgetAdapter: () => (/* binding */ WidgetAdapter),\n/* harmony export */   WidgetAdapterContext: () => (/* binding */ WidgetAdapterContext),\n/* harmony export */   WidgetContext: () => (/* binding */ WidgetContext),\n/* harmony export */   WidgetLoad: () => (/* binding */ WidgetLoad),\n/* harmony export */   WidgetQuery: () => (/* binding */ WidgetQuery),\n/* harmony export */   WidgetsAll: () => (/* binding */ WidgetsAll),\n/* harmony export */   WidgetsContext: () => (/* binding */ WidgetsContext),\n/* harmony export */   WidgetsQuery: () => (/* binding */ WidgetsQuery),\n/* harmony export */   useWidget: () => (/* binding */ useWidget),\n/* harmony export */   useWidgetAdapter: () => (/* binding */ useWidgetAdapter),\n/* harmony export */   useWidgets: () => (/* binding */ useWidgets)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fjell_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fjell/providers */ \"(app-pages-browser)/../fjell-providers/dist/index.js\");\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fjell/core */ \"(app-pages-browser)/../fjell-core/dist/index.js\");\n/* harmony import */ var _cache_ClientCache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cache/ClientCache */ \"(app-pages-browser)/./src/client/cache/ClientCache.ts\");\n/* __next_internal_client_entry_do_not_use__ WidgetAdapterContext,useWidgetAdapter,WidgetAdapter,WidgetContext,useWidget,WidgetLoad,WidgetsContext,useWidgets,WidgetQuery,WidgetsQuery,WidgetsAll auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\nconst WidgetAdapterContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useWidgetAdapter = ()=>{\n    _s();\n    return _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemAdapter.usePItemAdapter(WidgetAdapterContext, 'WidgetAdapterContext');\n};\n_s(useWidgetAdapter, \"p8V+B1UDIroLpcV31XCHiGc7KcI=\", false, function() {\n    return [\n        _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemAdapter.usePItemAdapter\n    ];\n});\nconst WidgetAdapter = (param)=>{\n    let { children } = param;\n    // Get cache instance synchronously (CacheInitializer has already initialized it)\n    const widgetCache = (0,_cache_ClientCache__WEBPACK_IMPORTED_MODULE_4__.getWidgetCacheSync)();\n    // Create a typed version of the Adapter component\n    const TypedAdapter = _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemAdapter.Adapter;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TypedAdapter, {\n        name: \"WidgetAdapter\",\n        cache: widgetCache,\n        context: WidgetAdapterContext,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/providers/WidgetProvider.tsx\",\n        lineNumber: 36,\n        columnNumber: 5\n    }, undefined);\n};\n_c = WidgetAdapter;\nconst WidgetContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useWidget = ()=>{\n    _s1();\n    return _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItem.usePItem(WidgetContext, 'WidgetContext');\n};\n_s1(useWidget, \"x+Nauny49JmNxdeO3qEIYKxc6G8=\", false, function() {\n    return [\n        _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItem.usePItem\n    ];\n});\nconst WidgetLoad = (param)=>{\n    let { ik, children } = param;\n    return (0,_fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemLoad)({\n        name: 'WidgetLoad',\n        ik,\n        adapter: WidgetAdapterContext,\n        context: WidgetContext,\n        contextName: 'WidgetContext',\n        children\n    });\n};\n_c1 = WidgetLoad;\nconst WidgetsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useWidgets = ()=>{\n    _s2();\n    return _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItems.usePItems(WidgetsContext, 'WidgetsContext');\n};\n_s2(useWidgets, \"S4iuAied6fnIunMEFk4XAFp5Kp8=\", false, function() {\n    return [\n        _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItems.usePItems\n    ];\n});\nconst WidgetQuery = (param)=>{\n    let { query, children, optional } = param;\n    return (0,_fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemQuery)({\n        name: 'WidgetQuery',\n        query,\n        adapter: WidgetAdapterContext,\n        context: WidgetContext,\n        contextName: 'WidgetContext',\n        children,\n        optional\n    });\n};\n_c2 = WidgetQuery;\nconst WidgetsQuery = (param)=>{\n    let { query, children } = param;\n    return (0,_fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemsQuery)({\n        name: 'WidgetsQuery',\n        query,\n        adapter: WidgetAdapterContext,\n        context: WidgetsContext,\n        contextName: 'WidgetsContext',\n        children\n    });\n};\n_c3 = WidgetsQuery;\nconst WidgetsAll = (param)=>{\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(WidgetsQuery, {\n        query: _fjell_core__WEBPACK_IMPORTED_MODULE_3__.IQFactory.all().toQuery(),\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/providers/WidgetProvider.tsx\",\n        lineNumber: 129,\n        columnNumber: 12\n    }, undefined);\n};\n_c4 = WidgetsAll;\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"WidgetAdapter\");\n$RefreshReg$(_c1, \"WidgetLoad\");\n$RefreshReg$(_c2, \"WidgetQuery\");\n$RefreshReg$(_c3, \"WidgetsQuery\");\n$RefreshReg$(_c4, \"WidgetsAll\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvcHJvdmlkZXJzL1dpZGdldFByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRzZDO0FBU25CO0FBQ2lDO0FBRUQ7QUFFbkQsTUFBTVUscUNBQ1hULG9EQUFhQSxDQUF5RFUsV0FBVztBQUU1RSxNQUFNQyxtQkFBbUI7O0lBQU1ULE9BQUFBLDBEQUFZQSxDQUFDVSxlQUFlLENBR2hFSCxzQkFBc0I7QUFBc0IsRUFBRTtHQUhuQ0U7O1FBQXlCVCwwREFBWUEsQ0FBQ1U7OztBQUs1QyxNQUFNQyxnQkFFUjtRQUFDLEVBQUVDLFFBQVEsRUFBRTtJQUNoQixpRkFBaUY7SUFDakYsTUFBTUMsY0FBY1Asc0VBQWtCQTtJQUV0QyxrREFBa0Q7SUFDbEQsTUFBTVEsZUFBZWQsMERBQVlBLENBQUNlLE9BQU87SUFFekMscUJBQ0UsOERBQUNEO1FBQ0NFLE1BQUs7UUFDTEMsT0FBT0o7UUFDUEssU0FBU1g7a0JBRVJLOzs7Ozs7QUFHUCxFQUFDO0tBbEJZRDtBQW9CTixNQUFNUSw4QkFDWHJCLG9EQUFhQSxDQUFrRFUsV0FBVztBQUVyRSxNQUFNWSxZQUFZOztJQUN2QnJCLE9BQUFBLG1EQUFLQSxDQUFDc0IsUUFBUSxDQUFtQkYsZUFBZTtBQUFlLEVBQUU7SUFEdERDOztRQUNYckIsbURBQUtBLENBQUNzQjs7O0FBRUQsTUFBTUMsYUFHUjtRQUNILEVBQUVDLEVBQUUsRUFBRVgsUUFBUSxFQUdiO1dBQ0VYLDJEQUFTQSxDQUdaO1FBQ0FlLE1BQU07UUFDTk87UUFDQUMsU0FBU2pCO1FBQ1RXLFNBQVNDO1FBQ1RNLGFBQWE7UUFDYmI7SUFDRjtFQUFHO01BbEJVVTtBQXVCTixNQUFNSSwrQkFDWDVCLG9EQUFhQSxDQUFpQ1UsV0FBVztBQUVwRCxNQUFNbUIsYUFBYTs7SUFDeEJ4QixPQUFBQSxvREFBTUEsQ0FBQ3lCLFNBQVMsQ0FBbUJGLGdCQUFnQjtBQUFnQixFQUF3QjtJQURoRkM7O1FBQ1h4QixvREFBTUEsQ0FBQ3lCOzs7QUFFRixNQUFNQyxjQUlSO1FBQ0gsRUFBRUMsS0FBSyxFQUFFbEIsUUFBUSxFQUFFbUIsUUFBUSxFQUkxQjtXQUNFN0IsNERBQVVBLENBR2I7UUFDQWMsTUFBTTtRQUNOYztRQUNBTixTQUFTakI7UUFDVFcsU0FBU0M7UUFDVE0sYUFBYTtRQUNiYjtRQUNBbUI7SUFDRjtFQUFHO01BckJVRjtBQXVCTixNQUFNRyxlQUdSO1FBQ0gsRUFBRUYsS0FBSyxFQUFFbEIsUUFBUSxFQUdoQjtXQUNFUiw2REFBV0EsQ0FHZDtRQUNBWSxNQUFNO1FBQ05jO1FBQ0FOLFNBQVNqQjtRQUNUVyxTQUFTUTtRQUNURCxhQUFhO1FBQ2JiO0lBQ0Y7RUFBRztNQWxCVW9CO0FBb0JOLE1BQU1DLGFBRVI7UUFBQyxFQUFFckIsUUFBUSxFQUVmO0lBQ0cscUJBQU8sOERBQUNvQjtRQUFhRixPQUFPekIsa0RBQVNBLENBQUM2QixHQUFHLEdBQUdDLE9BQU87a0JBQUt2Qjs7Ozs7O0FBQzFELEVBQUU7TUFOU3FCIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXNhbXBsZS1hcHAvc3JjL2NsaWVudC9wcm92aWRlcnMvV2lkZ2V0UHJvdmlkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7XG4gIFBJdGVtLFxuICBQSXRlbUFkYXB0ZXIsXG4gIFBJdGVtTG9hZCxcbiAgUEl0ZW1RdWVyeSxcbiAgUEl0ZW1zLFxuICBQSXRlbXNRdWVyeSxcbn0gZnJvbSBcIkBmamVsbC9wcm92aWRlcnNcIjtcbmltcG9ydCB7IElRRmFjdG9yeSwgSXRlbVF1ZXJ5LCBQcmlLZXkgfSBmcm9tIFwiQGZqZWxsL2NvcmVcIjtcbmltcG9ydCB7IFdpZGdldCB9IGZyb20gXCIuLi8uLi9tb2RlbC9XaWRnZXRcIjtcbmltcG9ydCB7IGdldFdpZGdldENhY2hlU3luYyB9IGZyb20gXCIuLi9jYWNoZS9DbGllbnRDYWNoZVwiO1xuXG5leHBvcnQgY29uc3QgV2lkZ2V0QWRhcHRlckNvbnRleHQgPVxuICBjcmVhdGVDb250ZXh0PFBJdGVtQWRhcHRlci5Db250ZXh0VHlwZTxXaWRnZXQsIFwid2lkZ2V0XCI+IHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5leHBvcnQgY29uc3QgdXNlV2lkZ2V0QWRhcHRlciA9ICgpID0+IFBJdGVtQWRhcHRlci51c2VQSXRlbUFkYXB0ZXI8XG4gIFdpZGdldCxcbiAgXCJ3aWRnZXRcIlxuPihXaWRnZXRBZGFwdGVyQ29udGV4dCwgJ1dpZGdldEFkYXB0ZXJDb250ZXh0Jyk7XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRBZGFwdGVyOiBSZWFjdC5GQzx7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgLy8gR2V0IGNhY2hlIGluc3RhbmNlIHN5bmNocm9ub3VzbHkgKENhY2hlSW5pdGlhbGl6ZXIgaGFzIGFscmVhZHkgaW5pdGlhbGl6ZWQgaXQpXG4gIGNvbnN0IHdpZGdldENhY2hlID0gZ2V0V2lkZ2V0Q2FjaGVTeW5jKCk7XG5cbiAgLy8gQ3JlYXRlIGEgdHlwZWQgdmVyc2lvbiBvZiB0aGUgQWRhcHRlciBjb21wb25lbnRcbiAgY29uc3QgVHlwZWRBZGFwdGVyID0gUEl0ZW1BZGFwdGVyLkFkYXB0ZXIgYXMgYW55O1xuXG4gIHJldHVybiAoXG4gICAgPFR5cGVkQWRhcHRlclxuICAgICAgbmFtZT0nV2lkZ2V0QWRhcHRlcidcbiAgICAgIGNhY2hlPXt3aWRnZXRDYWNoZX1cbiAgICAgIGNvbnRleHQ9e1dpZGdldEFkYXB0ZXJDb250ZXh0fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1R5cGVkQWRhcHRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IFdpZGdldENvbnRleHQgPVxuICBjcmVhdGVDb250ZXh0PFBJdGVtLkNvbnRleHRUeXBlPFdpZGdldCwgJ3dpZGdldCc+IHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5leHBvcnQgY29uc3QgdXNlV2lkZ2V0ID0gKCkgPT5cbiAgUEl0ZW0udXNlUEl0ZW08V2lkZ2V0LCAnd2lkZ2V0Jz4oV2lkZ2V0Q29udGV4dCwgJ1dpZGdldENvbnRleHQnKTtcblxuZXhwb3J0IGNvbnN0IFdpZGdldExvYWQ6IFJlYWN0LkZDPHtcbiAgaWs6IFByaUtleTwnd2lkZ2V0Jz47XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59PiA9IChcbiAgeyBpaywgY2hpbGRyZW4gfToge1xuICAgIGlrOiBQcmlLZXk8J3dpZGdldCc+O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIH1cbikgPT4gUEl0ZW1Mb2FkPFxuICBXaWRnZXQsXG4gIFwid2lkZ2V0XCJcbj4oe1xuICBuYW1lOiAnV2lkZ2V0TG9hZCcsXG4gIGlrLFxuICBhZGFwdGVyOiBXaWRnZXRBZGFwdGVyQ29udGV4dCxcbiAgY29udGV4dDogV2lkZ2V0Q29udGV4dCxcbiAgY29udGV4dE5hbWU6ICdXaWRnZXRDb250ZXh0JyxcbiAgY2hpbGRyZW4sXG59KTtcblxuZXhwb3J0IHR5cGUgV2lkZ2V0c0NvbnRleHRUeXBlID1cbiAgUEl0ZW1zLkNvbnRleHRUeXBlPFdpZGdldCwgJ3dpZGdldCc+O1xuXG5leHBvcnQgY29uc3QgV2lkZ2V0c0NvbnRleHQgPVxuICBjcmVhdGVDb250ZXh0PFdpZGdldHNDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGNvbnN0IHVzZVdpZGdldHMgPSAoKSA9PlxuICBQSXRlbXMudXNlUEl0ZW1zPFdpZGdldCwgJ3dpZGdldCc+KFdpZGdldHNDb250ZXh0LCAnV2lkZ2V0c0NvbnRleHQnKSBhcyBXaWRnZXRzQ29udGV4dFR5cGU7XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRRdWVyeTogUmVhY3QuRkM8e1xuICBxdWVyeTogSXRlbVF1ZXJ5O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBvcHRpb25hbD86IGJvb2xlYW47XG59PiA9IChcbiAgeyBxdWVyeSwgY2hpbGRyZW4sIG9wdGlvbmFsIH06IHtcbiAgICBxdWVyeTogSXRlbVF1ZXJ5O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgb3B0aW9uYWw/OiBib29sZWFuO1xuICB9XG4pID0+IFBJdGVtUXVlcnk8XG4gIFdpZGdldCxcbiAgXCJ3aWRnZXRcIlxuPih7XG4gIG5hbWU6ICdXaWRnZXRRdWVyeScsXG4gIHF1ZXJ5LFxuICBhZGFwdGVyOiBXaWRnZXRBZGFwdGVyQ29udGV4dCxcbiAgY29udGV4dDogV2lkZ2V0Q29udGV4dCxcbiAgY29udGV4dE5hbWU6ICdXaWRnZXRDb250ZXh0JyxcbiAgY2hpbGRyZW4sXG4gIG9wdGlvbmFsLFxufSk7XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRzUXVlcnk6IFJlYWN0LkZDPHtcbiAgcXVlcnk/OiBJdGVtUXVlcnk7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59PiA9IChcbiAgeyBxdWVyeSwgY2hpbGRyZW4gfToge1xuICAgIHF1ZXJ5PzogSXRlbVF1ZXJ5O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIH1cbikgPT4gUEl0ZW1zUXVlcnk8XG4gIFdpZGdldCxcbiAgXCJ3aWRnZXRcIlxuPih7XG4gIG5hbWU6ICdXaWRnZXRzUXVlcnknLFxuICBxdWVyeSxcbiAgYWRhcHRlcjogV2lkZ2V0QWRhcHRlckNvbnRleHQsXG4gIGNvbnRleHQ6IFdpZGdldHNDb250ZXh0LFxuICBjb250ZXh0TmFtZTogJ1dpZGdldHNDb250ZXh0JyxcbiAgY2hpbGRyZW4sXG59KTtcblxuZXhwb3J0IGNvbnN0IFdpZGdldHNBbGw6IFJlYWN0LkZDPHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn0+ID0gKHsgY2hpbGRyZW4gfToge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufSkgPT4ge1xuICAgIHJldHVybiA8V2lkZ2V0c1F1ZXJ5IHF1ZXJ5PXtJUUZhY3RvcnkuYWxsKCkudG9RdWVyeSgpfT57Y2hpbGRyZW59PC9XaWRnZXRzUXVlcnk+O1xuICB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsIlBJdGVtIiwiUEl0ZW1BZGFwdGVyIiwiUEl0ZW1Mb2FkIiwiUEl0ZW1RdWVyeSIsIlBJdGVtcyIsIlBJdGVtc1F1ZXJ5IiwiSVFGYWN0b3J5IiwiZ2V0V2lkZ2V0Q2FjaGVTeW5jIiwiV2lkZ2V0QWRhcHRlckNvbnRleHQiLCJ1bmRlZmluZWQiLCJ1c2VXaWRnZXRBZGFwdGVyIiwidXNlUEl0ZW1BZGFwdGVyIiwiV2lkZ2V0QWRhcHRlciIsImNoaWxkcmVuIiwid2lkZ2V0Q2FjaGUiLCJUeXBlZEFkYXB0ZXIiLCJBZGFwdGVyIiwibmFtZSIsImNhY2hlIiwiY29udGV4dCIsIldpZGdldENvbnRleHQiLCJ1c2VXaWRnZXQiLCJ1c2VQSXRlbSIsIldpZGdldExvYWQiLCJpayIsImFkYXB0ZXIiLCJjb250ZXh0TmFtZSIsIldpZGdldHNDb250ZXh0IiwidXNlV2lkZ2V0cyIsInVzZVBJdGVtcyIsIldpZGdldFF1ZXJ5IiwicXVlcnkiLCJvcHRpb25hbCIsIldpZGdldHNRdWVyeSIsIldpZGdldHNBbGwiLCJhbGwiLCJ0b1F1ZXJ5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/providers/WidgetProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/client/providers/WidgetTypeProvider.tsx":
/*!*****************************************************!*\
  !*** ./src/client/providers/WidgetTypeProvider.tsx ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WidgetTypeAdapter: () => (/* binding */ WidgetTypeAdapter),\n/* harmony export */   WidgetTypeAdapterContext: () => (/* binding */ WidgetTypeAdapterContext),\n/* harmony export */   WidgetTypeContext: () => (/* binding */ WidgetTypeContext),\n/* harmony export */   WidgetTypeLoad: () => (/* binding */ WidgetTypeLoad),\n/* harmony export */   WidgetTypeQuery: () => (/* binding */ WidgetTypeQuery),\n/* harmony export */   WidgetTypesAll: () => (/* binding */ WidgetTypesAll),\n/* harmony export */   WidgetTypesContext: () => (/* binding */ WidgetTypesContext),\n/* harmony export */   WidgetTypesQuery: () => (/* binding */ WidgetTypesQuery),\n/* harmony export */   useWidgetType: () => (/* binding */ useWidgetType),\n/* harmony export */   useWidgetTypeAdapter: () => (/* binding */ useWidgetTypeAdapter),\n/* harmony export */   useWidgetTypes: () => (/* binding */ useWidgetTypes)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fjell_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fjell/providers */ \"(app-pages-browser)/../fjell-providers/dist/index.js\");\n/* harmony import */ var _fjell_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fjell/core */ \"(app-pages-browser)/../fjell-core/dist/index.js\");\n/* harmony import */ var _cache_ClientCache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cache/ClientCache */ \"(app-pages-browser)/./src/client/cache/ClientCache.ts\");\n/* __next_internal_client_entry_do_not_use__ WidgetTypeAdapterContext,useWidgetTypeAdapter,WidgetTypeAdapter,WidgetTypeContext,useWidgetType,WidgetTypeLoad,WidgetTypesContext,useWidgetTypes,WidgetTypeQuery,WidgetTypesQuery,WidgetTypesAll auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\nconst WidgetTypeAdapterContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useWidgetTypeAdapter = ()=>{\n    _s();\n    return _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemAdapter.usePItemAdapter(WidgetTypeAdapterContext, 'WidgetTypeAdapterContext');\n};\n_s(useWidgetTypeAdapter, \"p8V+B1UDIroLpcV31XCHiGc7KcI=\", false, function() {\n    return [\n        _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemAdapter.usePItemAdapter\n    ];\n});\nconst WidgetTypeAdapter = (param)=>{\n    let { children } = param;\n    // Get cache instance synchronously (CacheInitializer has already initialized it)\n    const widgetTypeCache = (0,_cache_ClientCache__WEBPACK_IMPORTED_MODULE_4__.getWidgetTypeCacheSync)();\n    // Create a typed version of the Adapter component\n    const TypedAdapter = _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemAdapter.Adapter;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TypedAdapter, {\n        name: \"WidgetTypeAdapter\",\n        cache: widgetTypeCache,\n        context: WidgetTypeAdapterContext,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/providers/WidgetTypeProvider.tsx\",\n        lineNumber: 35,\n        columnNumber: 5\n    }, undefined);\n};\n_c = WidgetTypeAdapter;\nconst WidgetTypeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useWidgetType = ()=>{\n    _s1();\n    return _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItem.usePItem(WidgetTypeContext, 'WidgetTypeContext');\n};\n_s1(useWidgetType, \"x+Nauny49JmNxdeO3qEIYKxc6G8=\", false, function() {\n    return [\n        _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItem.usePItem\n    ];\n});\nconst WidgetTypeLoad = (param)=>{\n    let { ik, children } = param;\n    return (0,_fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemLoad)({\n        name: 'WidgetTypeLoad',\n        ik,\n        adapter: WidgetTypeAdapterContext,\n        context: WidgetTypeContext,\n        contextName: 'WidgetTypeContext',\n        children\n    });\n};\n_c1 = WidgetTypeLoad;\nconst WidgetTypesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useWidgetTypes = ()=>{\n    _s2();\n    return _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItems.usePItems(WidgetTypesContext, 'WidgetTypesContext');\n};\n_s2(useWidgetTypes, \"S4iuAied6fnIunMEFk4XAFp5Kp8=\", false, function() {\n    return [\n        _fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItems.usePItems\n    ];\n});\nconst WidgetTypeQuery = (param)=>{\n    let { query, children, optional } = param;\n    return (0,_fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemQuery)({\n        name: 'WidgetTypeQuery',\n        query,\n        adapter: WidgetTypeAdapterContext,\n        context: WidgetTypeContext,\n        contextName: 'WidgetTypeContext',\n        children,\n        optional\n    });\n};\n_c2 = WidgetTypeQuery;\nconst WidgetTypesQuery = (param)=>{\n    let { query, children } = param;\n    return (0,_fjell_providers__WEBPACK_IMPORTED_MODULE_2__.PItemsQuery)({\n        name: 'WidgetTypesQuery',\n        query,\n        adapter: WidgetTypeAdapterContext,\n        context: WidgetTypesContext,\n        contextName: 'WidgetTypesContext',\n        children\n    });\n};\n_c3 = WidgetTypesQuery;\nconst WidgetTypesAll = (param)=>{\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(WidgetTypesQuery, {\n        query: _fjell_core__WEBPACK_IMPORTED_MODULE_3__.IQFactory.all().toQuery(),\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/developer/gitw/getfjell/fjell-sample-app/src/client/providers/WidgetTypeProvider.tsx\",\n        lineNumber: 128,\n        columnNumber: 12\n    }, undefined);\n};\n_c4 = WidgetTypesAll;\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"WidgetTypeAdapter\");\n$RefreshReg$(_c1, \"WidgetTypeLoad\");\n$RefreshReg$(_c2, \"WidgetTypeQuery\");\n$RefreshReg$(_c3, \"WidgetTypesQuery\");\n$RefreshReg$(_c4, \"WidgetTypesAll\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jbGllbnQvcHJvdmlkZXJzL1dpZGdldFR5cGVQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUU2QztBQVNuQjtBQUNpQztBQUVHO0FBRXZELE1BQU1VLHlDQUNYVCxvREFBYUEsQ0FBaUVVLFdBQVc7QUFFcEYsTUFBTUMsdUJBQXVCOztJQUFNVCxPQUFBQSwwREFBWUEsQ0FBQ1UsZUFBZSxDQUdwRUgsMEJBQTBCO0FBQTBCLEVBQUU7R0FIM0NFOztRQUE2QlQsMERBQVlBLENBQUNVOzs7QUFLaEQsTUFBTUMsb0JBRVI7UUFBQyxFQUFFQyxRQUFRLEVBQUU7SUFDaEIsaUZBQWlGO0lBQ2pGLE1BQU1DLGtCQUFrQlAsMEVBQXNCQTtJQUU5QyxrREFBa0Q7SUFDbEQsTUFBTVEsZUFBZWQsMERBQVlBLENBQUNlLE9BQU87SUFFekMscUJBQ0UsOERBQUNEO1FBQ0NFLE1BQUs7UUFDTEMsT0FBT0o7UUFDUEssU0FBU1g7a0JBRVJLOzs7Ozs7QUFHUCxFQUFDO0tBbEJZRDtBQW9CTixNQUFNUSxrQ0FDWHJCLG9EQUFhQSxDQUEwRFUsV0FBVztBQUU3RSxNQUFNWSxnQkFBZ0I7O0lBQzNCckIsT0FBQUEsbURBQUtBLENBQUNzQixRQUFRLENBQTJCRixtQkFBbUI7QUFBbUIsRUFBRTtJQUR0RUM7O1FBQ1hyQixtREFBS0EsQ0FBQ3NCOzs7QUFFRCxNQUFNQyxpQkFHUjtRQUNILEVBQUVDLEVBQUUsRUFBRVgsUUFBUSxFQUdiO1dBQ0VYLDJEQUFTQSxDQUdaO1FBQ0FlLE1BQU07UUFDTk87UUFDQUMsU0FBU2pCO1FBQ1RXLFNBQVNDO1FBQ1RNLGFBQWE7UUFDYmI7SUFDRjtFQUFHO01BbEJVVTtBQXVCTixNQUFNSSxtQ0FDWDVCLG9EQUFhQSxDQUFxQ1UsV0FBVztBQUV4RCxNQUFNbUIsaUJBQWlCOztJQUM1QnhCLE9BQUFBLG9EQUFNQSxDQUFDeUIsU0FBUyxDQUEyQkYsb0JBQW9CO0FBQW9CLEVBQTRCO0lBRHBHQzs7UUFDWHhCLG9EQUFNQSxDQUFDeUI7OztBQUVGLE1BQU1DLGtCQUlSO1FBQ0gsRUFBRUMsS0FBSyxFQUFFbEIsUUFBUSxFQUFFbUIsUUFBUSxFQUkxQjtXQUNFN0IsNERBQVVBLENBR2I7UUFDQWMsTUFBTTtRQUNOYztRQUNBTixTQUFTakI7UUFDVFcsU0FBU0M7UUFDVE0sYUFBYTtRQUNiYjtRQUNBbUI7SUFDRjtFQUFHO01BckJVRjtBQXVCTixNQUFNRyxtQkFHUjtRQUNILEVBQUVGLEtBQUssRUFBRWxCLFFBQVEsRUFHaEI7V0FDRVIsNkRBQVdBLENBR2Q7UUFDQVksTUFBTTtRQUNOYztRQUNBTixTQUFTakI7UUFDVFcsU0FBU1E7UUFDVEQsYUFBYTtRQUNiYjtJQUNGO0VBQUc7TUFsQlVvQjtBQW9CTixNQUFNQyxpQkFFUjtRQUFDLEVBQUVyQixRQUFRLEVBRWY7SUFDRyxxQkFBTyw4REFBQ29CO1FBQWlCRixPQUFPekIsa0RBQVNBLENBQUM2QixHQUFHLEdBQUdDLE9BQU87a0JBQUt2Qjs7Ozs7O0FBQzlELEVBQUU7TUFOU3FCIiwic291cmNlcyI6WyIvVXNlcnMvdG9icmllbi9naXR3L2dldGZqZWxsL2ZqZWxsLXNhbXBsZS1hcHAvc3JjL2NsaWVudC9wcm92aWRlcnMvV2lkZ2V0VHlwZVByb3ZpZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgUEl0ZW0sXG4gIFBJdGVtQWRhcHRlcixcbiAgUEl0ZW1Mb2FkLFxuICBQSXRlbVF1ZXJ5LFxuICBQSXRlbXMsXG4gIFBJdGVtc1F1ZXJ5LFxufSBmcm9tIFwiQGZqZWxsL3Byb3ZpZGVyc1wiO1xuaW1wb3J0IHsgSVFGYWN0b3J5LCBJdGVtUXVlcnksIFByaUtleSB9IGZyb20gXCJAZmplbGwvY29yZVwiO1xuaW1wb3J0IHsgV2lkZ2V0VHlwZSB9IGZyb20gXCIuLi8uLi9tb2RlbC9XaWRnZXRUeXBlXCI7XG5pbXBvcnQgeyBnZXRXaWRnZXRUeXBlQ2FjaGVTeW5jIH0gZnJvbSBcIi4uL2NhY2hlL0NsaWVudENhY2hlXCI7XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRUeXBlQWRhcHRlckNvbnRleHQgPVxuICBjcmVhdGVDb250ZXh0PFBJdGVtQWRhcHRlci5Db250ZXh0VHlwZTxXaWRnZXRUeXBlLCBcIndpZGdldFR5cGVcIj4gfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBjb25zdCB1c2VXaWRnZXRUeXBlQWRhcHRlciA9ICgpID0+IFBJdGVtQWRhcHRlci51c2VQSXRlbUFkYXB0ZXI8XG4gIFdpZGdldFR5cGUsXG4gIFwid2lkZ2V0VHlwZVwiXG4+KFdpZGdldFR5cGVBZGFwdGVyQ29udGV4dCwgJ1dpZGdldFR5cGVBZGFwdGVyQ29udGV4dCcpO1xuXG5leHBvcnQgY29uc3QgV2lkZ2V0VHlwZUFkYXB0ZXI6IFJlYWN0LkZDPHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAvLyBHZXQgY2FjaGUgaW5zdGFuY2Ugc3luY2hyb25vdXNseSAoQ2FjaGVJbml0aWFsaXplciBoYXMgYWxyZWFkeSBpbml0aWFsaXplZCBpdClcbiAgY29uc3Qgd2lkZ2V0VHlwZUNhY2hlID0gZ2V0V2lkZ2V0VHlwZUNhY2hlU3luYygpO1xuXG4gIC8vIENyZWF0ZSBhIHR5cGVkIHZlcnNpb24gb2YgdGhlIEFkYXB0ZXIgY29tcG9uZW50XG4gIGNvbnN0IFR5cGVkQWRhcHRlciA9IFBJdGVtQWRhcHRlci5BZGFwdGVyIGFzIGFueTtcblxuICByZXR1cm4gKFxuICAgIDxUeXBlZEFkYXB0ZXJcbiAgICAgIG5hbWU9J1dpZGdldFR5cGVBZGFwdGVyJ1xuICAgICAgY2FjaGU9e3dpZGdldFR5cGVDYWNoZX1cbiAgICAgIGNvbnRleHQ9e1dpZGdldFR5cGVBZGFwdGVyQ29udGV4dH1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9UeXBlZEFkYXB0ZXI+XG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRUeXBlQ29udGV4dCA9XG4gIGNyZWF0ZUNvbnRleHQ8UEl0ZW0uQ29udGV4dFR5cGU8V2lkZ2V0VHlwZSwgJ3dpZGdldFR5cGUnPiB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGNvbnN0IHVzZVdpZGdldFR5cGUgPSAoKSA9PlxuICBQSXRlbS51c2VQSXRlbTxXaWRnZXRUeXBlLCAnd2lkZ2V0VHlwZSc+KFdpZGdldFR5cGVDb250ZXh0LCAnV2lkZ2V0VHlwZUNvbnRleHQnKTtcblxuZXhwb3J0IGNvbnN0IFdpZGdldFR5cGVMb2FkOiBSZWFjdC5GQzx7XG4gIGlrOiBQcmlLZXk8J3dpZGdldFR5cGUnPjtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn0+ID0gKFxuICB7IGlrLCBjaGlsZHJlbiB9OiB7XG4gICAgaWs6IFByaUtleTwnd2lkZ2V0VHlwZSc+O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIH1cbikgPT4gUEl0ZW1Mb2FkPFxuICBXaWRnZXRUeXBlLFxuICBcIndpZGdldFR5cGVcIlxuPih7XG4gIG5hbWU6ICdXaWRnZXRUeXBlTG9hZCcsXG4gIGlrLFxuICBhZGFwdGVyOiBXaWRnZXRUeXBlQWRhcHRlckNvbnRleHQsXG4gIGNvbnRleHQ6IFdpZGdldFR5cGVDb250ZXh0LFxuICBjb250ZXh0TmFtZTogJ1dpZGdldFR5cGVDb250ZXh0JyxcbiAgY2hpbGRyZW4sXG59KTtcblxuZXhwb3J0IHR5cGUgV2lkZ2V0VHlwZXNDb250ZXh0VHlwZSA9XG4gIFBJdGVtcy5Db250ZXh0VHlwZTxXaWRnZXRUeXBlLCAnd2lkZ2V0VHlwZSc+O1xuXG5leHBvcnQgY29uc3QgV2lkZ2V0VHlwZXNDb250ZXh0ID1cbiAgY3JlYXRlQ29udGV4dDxXaWRnZXRUeXBlc0NvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5leHBvcnQgY29uc3QgdXNlV2lkZ2V0VHlwZXMgPSAoKSA9PlxuICBQSXRlbXMudXNlUEl0ZW1zPFdpZGdldFR5cGUsICd3aWRnZXRUeXBlJz4oV2lkZ2V0VHlwZXNDb250ZXh0LCAnV2lkZ2V0VHlwZXNDb250ZXh0JykgYXMgV2lkZ2V0VHlwZXNDb250ZXh0VHlwZTtcblxuZXhwb3J0IGNvbnN0IFdpZGdldFR5cGVRdWVyeTogUmVhY3QuRkM8e1xuICBxdWVyeTogSXRlbVF1ZXJ5O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBvcHRpb25hbD86IGJvb2xlYW47XG59PiA9IChcbiAgeyBxdWVyeSwgY2hpbGRyZW4sIG9wdGlvbmFsIH06IHtcbiAgICBxdWVyeTogSXRlbVF1ZXJ5O1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgb3B0aW9uYWw/OiBib29sZWFuO1xuICB9XG4pID0+IFBJdGVtUXVlcnk8XG4gIFdpZGdldFR5cGUsXG4gIFwid2lkZ2V0VHlwZVwiXG4+KHtcbiAgbmFtZTogJ1dpZGdldFR5cGVRdWVyeScsXG4gIHF1ZXJ5LFxuICBhZGFwdGVyOiBXaWRnZXRUeXBlQWRhcHRlckNvbnRleHQsXG4gIGNvbnRleHQ6IFdpZGdldFR5cGVDb250ZXh0LFxuICBjb250ZXh0TmFtZTogJ1dpZGdldFR5cGVDb250ZXh0JyxcbiAgY2hpbGRyZW4sXG4gIG9wdGlvbmFsLFxufSk7XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRUeXBlc1F1ZXJ5OiBSZWFjdC5GQzx7XG4gIHF1ZXJ5PzogSXRlbVF1ZXJ5O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufT4gPSAoXG4gIHsgcXVlcnksIGNoaWxkcmVuIH06IHtcbiAgICBxdWVyeT86IEl0ZW1RdWVyeTtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICB9XG4pID0+IFBJdGVtc1F1ZXJ5PFxuICBXaWRnZXRUeXBlLFxuICBcIndpZGdldFR5cGVcIlxuPih7XG4gIG5hbWU6ICdXaWRnZXRUeXBlc1F1ZXJ5JyxcbiAgcXVlcnksXG4gIGFkYXB0ZXI6IFdpZGdldFR5cGVBZGFwdGVyQ29udGV4dCxcbiAgY29udGV4dDogV2lkZ2V0VHlwZXNDb250ZXh0LFxuICBjb250ZXh0TmFtZTogJ1dpZGdldFR5cGVzQ29udGV4dCcsXG4gIGNoaWxkcmVuLFxufSk7XG5cbmV4cG9ydCBjb25zdCBXaWRnZXRUeXBlc0FsbDogUmVhY3QuRkM8e1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufT4gPSAoeyBjaGlsZHJlbiB9OiB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59KSA9PiB7XG4gICAgcmV0dXJuIDxXaWRnZXRUeXBlc1F1ZXJ5IHF1ZXJ5PXtJUUZhY3RvcnkuYWxsKCkudG9RdWVyeSgpfT57Y2hpbGRyZW59PC9XaWRnZXRUeXBlc1F1ZXJ5PjtcbiAgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJQSXRlbSIsIlBJdGVtQWRhcHRlciIsIlBJdGVtTG9hZCIsIlBJdGVtUXVlcnkiLCJQSXRlbXMiLCJQSXRlbXNRdWVyeSIsIklRRmFjdG9yeSIsImdldFdpZGdldFR5cGVDYWNoZVN5bmMiLCJXaWRnZXRUeXBlQWRhcHRlckNvbnRleHQiLCJ1bmRlZmluZWQiLCJ1c2VXaWRnZXRUeXBlQWRhcHRlciIsInVzZVBJdGVtQWRhcHRlciIsIldpZGdldFR5cGVBZGFwdGVyIiwiY2hpbGRyZW4iLCJ3aWRnZXRUeXBlQ2FjaGUiLCJUeXBlZEFkYXB0ZXIiLCJBZGFwdGVyIiwibmFtZSIsImNhY2hlIiwiY29udGV4dCIsIldpZGdldFR5cGVDb250ZXh0IiwidXNlV2lkZ2V0VHlwZSIsInVzZVBJdGVtIiwiV2lkZ2V0VHlwZUxvYWQiLCJpayIsImFkYXB0ZXIiLCJjb250ZXh0TmFtZSIsIldpZGdldFR5cGVzQ29udGV4dCIsInVzZVdpZGdldFR5cGVzIiwidXNlUEl0ZW1zIiwiV2lkZ2V0VHlwZVF1ZXJ5IiwicXVlcnkiLCJvcHRpb25hbCIsIldpZGdldFR5cGVzUXVlcnkiLCJXaWRnZXRUeXBlc0FsbCIsImFsbCIsInRvUXVlcnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/client/providers/WidgetTypeProvider.tsx\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftobrien%2Fgitw%2Fgetfjell%2Ffjell-sample-app%2Fsrc%2Fclient%2Fpages%2FHome.tsx%22%2C%22ids%22%3A%5B%22Home%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);